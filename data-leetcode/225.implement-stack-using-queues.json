[
    {
        "title": "Reverse Nodes in k-Group",
        "question_content": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n\nExample 2:\n\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is n.\n\t1 <= k <= n <= 5000\n\t0 <= Node.val <= 1000\n\n&nbsp;\nFollow-up: Can you solve the problem in O(1) extra memory space?",
        "solutions": [
            {
                "id": 11423,
                "title": "short-but-recursive-java-code-with-comments",
                "content": "Hi, guys!\\nDespite the fact that the approach is recursive, the code is less than 20 lines. :)\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode curr = head;\\n        int count = 0;\\n        while (curr != null && count != k) { // find the k+1 node\\n            curr = curr.next;\\n            count++;\\n        }\\n        if (count == k) { // if k+1 node is found\\n            curr = reverseKGroup(curr, k); // reverse list with k+1 node as head\\n            // head - head-pointer to direct part, \\n            // curr - head-pointer to reversed part;\\n            while (count-- > 0) { // reverse current k-group: \\n                ListNode tmp = head.next; // tmp - next head in direct part\\n                head.next = curr; // preappending \"direct\" head to the reversed list \\n                curr = head; // move head of reversed part to a new node\\n                head = tmp; // move \"direct\" head to the next node in direct part\\n            }\\n            head = curr;\\n        }\\n        return head;\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi, guys!\\nDespite the fact that the approach is recursive, the code is less than 20 lines. :)\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode curr = head;\\n        int count = 0;\\n        while (curr != null && count != k) { // find the k+1 node\\n            curr = curr.next;\\n            count++;\\n        }\\n        if (count == k) { // if k+1 node is found\\n            curr = reverseKGroup(curr, k); // reverse list with k+1 node as head\\n            // head - head-pointer to direct part, \\n            // curr - head-pointer to reversed part;\\n            while (count-- > 0) { // reverse current k-group: \\n                ListNode tmp = head.next; // tmp - next head in direct part\\n                head.next = curr; // preappending \"direct\" head to the reversed list \\n                curr = head; // move head of reversed part to a new node\\n                head = tmp; // move \"direct\" head to the next node in direct part\\n            }\\n            head = curr;\\n        }\\n        return head;\\n    }\\n\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 11440,
                "title": "non-recursive-java-solution-and-idea",
                "content": "Reference: \\nhttp://www.cnblogs.com/lichen782/p/leetcode_Reverse_Nodes_in_kGroup.html\\n\\nFirst, build a function reverse() to reverse the ListNode between begin and end. See the explanation below:\\n\\n       /**\\n         * Reverse a link list between begin and end exclusively\\n         * an example:\\n         * a linked list:\\n         * 0->1->2->3->4->5->6\\n         * |           |   \\n         * begin       end\\n         * after call begin = reverse(begin, end)\\n         * \\n         * 0->3->2->1->4->5->6\\n         *          |  |\\n         *      begin end\\n         * @return the reversed list's 'begin' node, which is the precedence of node end\\n         */\\n\\nThen walk thru the linked list and apply reverse() iteratively. See the code below.\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode begin;\\n        if (head==null || head.next ==null || k==1)\\n        \\treturn head;\\n        ListNode dummyhead = new ListNode(-1);\\n        dummyhead.next = head;\\n        begin = dummyhead;\\n        int i=0;\\n        while (head != null){\\n        \\ti++;\\n        \\tif (i%k == 0){\\n        \\t\\tbegin = reverse(begin, head.next);\\n        \\t\\thead = begin.next;\\n        \\t} else {\\n        \\t\\thead = head.next;\\n        \\t}\\n        }\\n        return dummyhead.next;\\n        \\n    }\\n    \\n    public ListNode reverse(ListNode begin, ListNode end){\\n    \\tListNode curr = begin.next;\\n    \\tListNode next, first;\\n    \\tListNode prev = begin;\\n    \\tfirst = curr;\\n    \\twhile (curr!=end){\\n    \\t\\tnext = curr.next;\\n    \\t\\tcurr.next = prev;\\n    \\t\\tprev = curr;\\n    \\t\\tcurr = next;\\n    \\t}\\n    \\tbegin.next = prev;\\n    \\tfirst.next = curr;\\n    \\treturn first;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Reference: \\nhttp://www.cnblogs.com/lichen782/p/leetcode_Reverse_Nodes_in_kGroup.html\\n\\nFirst, build a function reverse() to reverse the ListNode between begin and end. See the explanation below:\\n\\n       /**\\n         * Reverse a link list between begin and end exclusively\\n         * an example:\\n         * a linked list:\\n         * 0->1->2->3->4->5->6\\n         * |           |   \\n         * begin       end\\n         * after call begin = reverse(begin, end)\\n         * \\n         * 0->3->2->1->4->5->6\\n         *          |  |\\n         *      begin end\\n         * @return the reversed list's 'begin' node, which is the precedence of node end\\n         */\\n\\nThen walk thru the linked list and apply reverse() iteratively. See the code below.\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode begin;\\n        if (head==null || head.next ==null || k==1)\\n        \\treturn head;\\n        ListNode dummyhead = new ListNode(-1);\\n        dummyhead.next = head;\\n        begin = dummyhead;\\n        int i=0;\\n        while (head != null){\\n        \\ti++;\\n        \\tif (i%k == 0){\\n        \\t\\tbegin = reverse(begin, head.next);\\n        \\t\\thead = begin.next;\\n        \\t} else {\\n        \\t\\thead = head.next;\\n        \\t}\\n        }\\n        return dummyhead.next;\\n        \\n    }\\n    \\n    public ListNode reverse(ListNode begin, ListNode end){\\n    \\tListNode curr = begin.next;\\n    \\tListNode next, first;\\n    \\tListNode prev = begin;\\n    \\tfirst = curr;\\n    \\twhile (curr!=end){\\n    \\t\\tnext = curr.next;\\n    \\t\\tcurr.next = prev;\\n    \\t\\tprev = curr;\\n    \\t\\tcurr = next;\\n    \\t}\\n    \\tbegin.next = prev;\\n    \\tfirst.next = curr;\\n    \\treturn first;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11491,
                "title": "succinct-iterative-python-o-n-time-o-1-space",
                "content": "Use a dummy head, and\\n\\nl, r :          define reversing range\\n\\npre, cur :  used in reversing, standard reverse linked linked list method\\n\\njump :      used to connect last node in previous k-group to first node in following k-group\\n\\n    def reverseKGroup(self, head, k):\\n        dummy = jump = ListNode(0)\\n        dummy.next = l = r = head\\n        \\n        while True:\\n            count = 0\\n            while r and count < k:   # use r to locate the range\\n                r = r.next\\n                count += 1\\n            if count == k:  # if size k satisfied, reverse the inner linked list\\n                pre, cur = r, l\\n                for _ in range(k):\\n                    cur.next, cur, pre = pre, cur.next, cur  # standard reversing\\n                jump.next, jump, l = pre, l, r  # connect two k-groups\\n            else:\\n                return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "Use a dummy head, and\\n\\nl, r :          define reversing range\\n\\npre, cur :  used in reversing, standard reverse linked linked list method\\n\\njump :      used to connect last node in previous k-group to first node in following k-group\\n\\n    def reverseKGroup(self, head, k):\\n        dummy = jump = ListNode(0)\\n        dummy.next = l = r = head\\n        \\n        while True:\\n            count = 0\\n            while r and count < k:   # use r to locate the range\\n                r = r.next\\n                count += 1\\n            if count == k:  # if size k satisfied, reverse the inner linked list\\n                pre, cur = r, l\\n                for _ in range(k):\\n                    cur.next, cur, pre = pre, cur.next, cur  # standard reversing\\n                jump.next, jump, l = pre, l, r  # connect two k-groups\\n            else:\\n                return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 183356,
                "title": "java-o-n-solution-with-super-detailed-explanation-illustration",
                "content": "This problem can be split into several steps:\\n1. Since we need to reverse the linked-list every k nodes, we need to check whether the number of list nodes are enough to reverse. Otherwise, there is no need to reverse.\\n\\n2. If we need to reverse the k nodes, how to do that? Following is my idea:\\n\\n\\t  If the structure of the linkedlist is like this:   \\n\\t\\t\\n\\t\\t1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n\\t\\t\\nThen there will always be a pointer, which points to the node **AHEAD** of the first node to reverse. The pointer will help to link the linkedlist after.\\n\\nAt first, we will add a dummy node in front of the linked list to act as the first pointer. After we add the pointer, the linked list will look like this:\\n```\\n    0 (pointer) -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n```\\n\\t\\nSuppose that there are enough nodes to be reversed, we just use the \"reverse linked list\" trick to reverse the k nodes. Please refer to \"https://leetcode.com/problems/reverse-linked-list/\" if you don\\'t know how to reverse a linked list.\\n\\nif k = 3, we can reverse 1 to 3 first using the following code:\\n```\\n  ListNode prev = null, curr = pointer.next, next = null;\\n  for (int i = 0; i < k; i++) {\\n\\t\\tnext = curr.next;\\n\\t\\tcurr.next = prev;\\n\\t\\tprev = curr;\\n\\t\\tcurr = next;\\n  }\\n```\\nThis is the illustartion of the first 3 steps:\\n```\\n    step1: 0 (pointer) -> 1      2 -> 3 -> 4 -> 5 -> 6 -> 7\\n\\tstep2: 0 (pointer) -> 1 <- 2      3 -> 4 -> 5 -> 6 -> 7\\n\\tstep3: 0 (pointer) -> 1 <- 2 <- 3      4 -> 5 -> 6 -> 7\\n```\\n\\nThis is an easy and general algorithm to reverse a linked list. However, if you are careful enough, you will find that after the for-loop, the link from 3 to 4 will be cut (as shown in step3).\\n\\t\\nNow we need to reconstruct the linked list and fix the issue. You will figure out that at step3, the 3 is the **prev** node, 4 is the **curr** node. \\n```\\n\\tstep3: 0 (pointer) -> 1 <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n```\\nWe can fix the sequence based on the following codes. The basic idea is to link the pointer to 3 and link 1 to 4:\\n```\\n\\tListNode tail = pointer.next;\\n\\ttail.next = curr; \\n\\tpointer.next = prev;\\n\\tpointer = tail;\\n```\\n\\nThen the result is:\\n```\\n\\tafter first line:   0 (pointer) -> 1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\tafter second line:  0 (pointer) -> 1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t       |____________________________\\u2191\\n\\tafter third line:   \\n\\t\\t\\t\\t\\t\\t\\t\\t|-----------------------\\u2193\\n\\t\\t\\t\\t\\t\\t0 (pointer)    1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   |____________________________\\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\tafter forth line:\\t0 -> 3 -> 2 -> 1 (pointer) -> 4 -> 5 -> 6 -> 7\\n```\\n\\t\\t\\t\\nNow we get the new pointer, and we can repeat the process. Note that to retrieve the head, we need to record the first dummy node (0).\\n\\nHere is the code:\\n```\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode pointer = dummy;\\n        while (pointer != null) {\\n            ListNode node = pointer;\\n            // first check whether there are k nodes to reverse\\n            for (int i = 0; i < k && node != null; i++) {\\n                node = node.next;\\n            }\\n            if (node == null) break;\\n            \\n            // now we know that we have k nodes, we will start from the first node\\n            ListNode prev = null, curr = pointer.next, next = null;\\n            for (int i = 0; i < k; i++) {\\n                next = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = next;\\n            }\\n            ListNode tail = pointer.next;\\n            tail.next = curr;\\n            pointer.next = prev;\\n            pointer = tail;\\n        }\\n        return dummy.next;\\n    }\\n```\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n    0 (pointer) -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n```\n```\\n  ListNode prev = null, curr = pointer.next, next = null;\\n  for (int i = 0; i < k; i++) {\\n\\t\\tnext = curr.next;\\n\\t\\tcurr.next = prev;\\n\\t\\tprev = curr;\\n\\t\\tcurr = next;\\n  }\\n```\n```\\n    step1: 0 (pointer) -> 1      2 -> 3 -> 4 -> 5 -> 6 -> 7\\n\\tstep2: 0 (pointer) -> 1 <- 2      3 -> 4 -> 5 -> 6 -> 7\\n\\tstep3: 0 (pointer) -> 1 <- 2 <- 3      4 -> 5 -> 6 -> 7\\n```\n```\\n\\tstep3: 0 (pointer) -> 1 <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n```\n```\\n\\tListNode tail = pointer.next;\\n\\ttail.next = curr; \\n\\tpointer.next = prev;\\n\\tpointer = tail;\\n```\n```\\n\\tafter first line:   0 (pointer) -> 1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\tafter second line:  0 (pointer) -> 1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t       |____________________________\\u2191\\n\\tafter third line:   \\n\\t\\t\\t\\t\\t\\t\\t\\t|-----------------------\\u2193\\n\\t\\t\\t\\t\\t\\t0 (pointer)    1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   |____________________________\\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\tafter forth line:\\t0 -> 3 -> 2 -> 1 (pointer) -> 4 -> 5 -> 6 -> 7\\n```\n```\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode pointer = dummy;\\n        while (pointer != null) {\\n            ListNode node = pointer;\\n            // first check whether there are k nodes to reverse\\n            for (int i = 0; i < k && node != null; i++) {\\n                node = node.next;\\n            }\\n            if (node == null) break;\\n            \\n            // now we know that we have k nodes, we will start from the first node\\n            ListNode prev = null, curr = pointer.next, next = null;\\n            for (int i = 0; i < k; i++) {\\n                next = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = next;\\n            }\\n            ListNode tail = pointer.next;\\n            tail.next = curr;\\n            pointer.next = prev;\\n            pointer = tail;\\n        }\\n        return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 523641,
                "title": "c-iterative-solution-recursive-solution",
                "content": "# Recursive solution\\n\\nRecursive solution has `O(n)` space complexity because of call stacks.\\n\\n```c++\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n            if(cursor == nullptr) return head;\\n            cursor = cursor->next;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* nxt = nullptr;\\n        for(int i = 0; i < k; i++){\\n            nxt = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        head->next = reverseKGroup(curr, k);\\n        return prev;\\n    }\\n```\\n\\n\\n******************************************************************************************\\n\\n\\n# Iterative solution\\n\\nIterative solution has `O(1)` space complexity.\\n\\n```c++\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* before = dummy;\\n        ListNode* after = head;\\n        ListNode* curr = nullptr;\\n        ListNode* prev = nullptr;\\n        ListNode* nxt = nullptr;\\n        while(true){\\n            ListNode* cursor = after;\\n            for(int i = 0; i < k; i++){\\n                if(cursor == nullptr) return dummy->next;\\n                cursor = cursor->next;\\n            }\\n            curr = after;\\n            prev = before;\\n            for(int i = 0; i < k; i++){\\n                nxt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nxt;\\n            }\\n            after->next = curr;\\n            before->next = prev;\\n            before = after;\\n            after = curr;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```c++\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n            if(cursor == nullptr) return head;\\n            cursor = cursor->next;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* nxt = nullptr;\\n        for(int i = 0; i < k; i++){\\n            nxt = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        head->next = reverseKGroup(curr, k);\\n        return prev;\\n    }\\n```\n```c++\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* before = dummy;\\n        ListNode* after = head;\\n        ListNode* curr = nullptr;\\n        ListNode* prev = nullptr;\\n        ListNode* nxt = nullptr;\\n        while(true){\\n            ListNode* cursor = after;\\n            for(int i = 0; i < k; i++){\\n                if(cursor == nullptr) return dummy->next;\\n                cursor = cursor->next;\\n            }\\n            curr = after;\\n            prev = before;\\n            for(int i = 0; i < k; i++){\\n                nxt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nxt;\\n            }\\n            after->next = curr;\\n            before->next = prev;\\n            before = after;\\n            after = curr;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11435,
                "title": "c-elegant-and-small",
                "content": "    class Solution \\n    {\\n    public:\\n        \\n        ListNode* reverse(ListNode* first, ListNode* last)\\n        {\\n            ListNode* prev = last;\\n            \\n            while ( first != last )\\n            {\\n                auto tmp = first->next;\\n                first->next = prev;\\n                prev = first;\\n                first = tmp;\\n            }\\n            \\n            return prev;\\n        }\\n        \\n        ListNode* reverseKGroup(ListNode* head, int k) \\n        {\\n            auto node=head;\\n            for (int i=0; i < k; ++i)\\n            {\\n                if ( ! node  )\\n                    return head; // nothing to do list too sort\\n                node = node->next;\\n            }\\n    \\n            auto new_head = reverse( head, node);\\n            head->next = reverseKGroup( node, k);\\n            return new_head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution \\n    {\\n    public:\\n        \\n        ListNode* reverse(ListNode* first, ListNode* last)\\n        {\\n            ListNode* prev = last;\\n            \\n            while ( first != last )\\n            {\\n                auto tmp = first->next;\\n                first->next = prev;\\n                prev = first;\\n                first = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 11457,
                "title": "20-line-iterative-c-solution",
                "content": "    -1 -> 1 -> 2 -> 3 -> 4 -> 5\\n     |    |    |    | \\n    pre  cur  nex  tmp\\n\\n    -1 -> 2 -> 1 -> 3 -> 4 -> 5\\n     |         |    |    | \\n    pre       cur  nex  tmp\\n\\n    -1 -> 3 -> 2 -> 1 -> 4 -> 5\\n     |              |    |    | \\n    pre            cur  nex  tmp\\n\\n\\nAbove is how it works inside one group iteration(for example, k=3)\\n\\n    class Solution {\\n    public:\\n        ListNode *reverseKGroup(ListNode *head, int k) {\\n            if(head==NULL||k==1) return head;\\n            int num=0;\\n            ListNode *preheader = new ListNode(-1);\\n            preheader->next = head;\\n            ListNode *cur = preheader, *nex, *tmp, *pre = preheader;\\n            while(cur = cur->next) \\n                num++;\\n            while(num>=k) {\\n                cur = pre->next;\\n                nex = cur->next;\\n                for(int i=1;i<k;i++) {\\n                    tmp= nex->next;\\n                    nex->next = pre->next;\\n                    pre->next = nex;\\n                    cur->next = tmp;\\n                    nex = tmp;\\n                }\\n                pre = cur;\\n                num-=k;\\n            }\\n            return preheader->next;\\n        }\\n    };\\n\\nThanks to ciaoliang1992, the tmp pointer is no necessary, so the more concise solution is \\n\\n    class Solution {\\n    public:\\n        ListNode *reverseKGroup(ListNode *head, int k) {\\n            if(head==NULL||k==1) return head;\\n            int num=0;\\n            ListNode *preheader = new ListNode(-1);\\n            preheader->next = head;\\n            ListNode *cur = preheader, *nex, *pre = preheader;\\n            while(cur = cur->next) \\n                num++;\\n            while(num>=k) {\\n                cur = pre->next;\\n                nex = cur->next;\\n                for(int i=1;i<k;++i) {\\n                    cur->next=nex->next;\\n                    nex->next=pre->next;\\n                    pre->next=nex;\\n                    nex=cur->next;\\n                }\\n                pre = cur;\\n                num-=k;\\n            }\\n            return preheader->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *reverseKGroup(ListNode *head, int k) {\\n            if(head==NULL||k==1) return head;\\n            int num=0;\\n            ListNode *preheader = new ListNode(-1);\\n            preheader->next = head;\\n            ListNode *cur = preheader, *nex, *tmp, *pre = preheader;\\n            while(cur = cur->next) \\n                num++;\\n            while(num>=k) {\\n                cur = pre->next;\\n                nex = cur->next;\\n                for(int i=1;i<k;i++) {\\n                    tmp= nex->next;\\n                    nex->next = pre->next;\\n                    pre->next = nex;\\n                    cur->next = tmp;\\n                    nex = tmp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 172576,
                "title": "python-follow-up-of-lc206",
                "content": "This problem is a standard follow up to\n`LC 206 Reverse Linked List`\n\nA lot of the solutions implemented the reversing logic from scratch\nI am going to pretend that I just finish writing the standard reverse method, and reuse the method on the follow up.\n\n### LC 206 Reverse Linked List\n```python\nclass Solution:\n    def reverseList(self, head):\n        if not head or not head.next:\n            return head\n        \n        prev, cur, nxt = None, head, head\n        while cur:\n            nxt = cur.next\n            cur.next = prev\n            prev = cur\n            cur = nxt\n        return prev    \n```\n\n\n\n### Follow up: Please reverse the list into K Group\n```python\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        count, node = 0, head\n        while node and count < k:\n            node = node.next\n            count += 1\n        if count < k: return head\n        new_head, prev = self.reverse(head, count)\n        head.next = self.reverseKGroup(new_head, k)\n        return prev\n    \n    def reverse(self, head, count):\n        prev, cur, nxt = None, head, head\n        while count > 0:\n            nxt = cur.next\n            cur.next = prev\n            prev = cur\n            cur = nxt\n            count -= 1\n        return (cur, prev)\n```",
                "solutionTags": [],
                "code": "```python\nclass Solution:\n    def reverseList(self, head):\n        if not head or not head.next:\n            return head\n        \n        prev, cur, nxt = None, head, head\n        while cur:\n            nxt = cur.next\n            cur.next = prev\n            prev = cur\n            cur = nxt\n        return prev    \n```\n```python\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        count, node = 0, head\n        while node and count < k:\n            node = node.next\n            count += 1\n        if count < k: return head\n        new_head, prev = self.reverse(head, count)\n        head.next = self.reverseKGroup(new_head, k)\n        return prev\n    \n    def reverse(self, head, count):\n        prev, cur, nxt = None, head, head\n        while count > 0:\n            nxt = cur.next\n            cur.next = prev\n            prev = cur\n            cur = nxt\n            count -= 1\n        return (cur, prev)\n```",
                "codeTag": "Java"
            },
            {
                "id": 11413,
                "title": "share-my-java-solution-with-comments-in-line",
                "content": "      \\n      public class Solution {\\n            public ListNode reverseKGroup(ListNode head, int k) {\\n                if (head==null||head.next==null||k<2) return head;\\n        \\n                ListNode dummy = new ListNode(0);\\n                dummy.next = head;\\n                \\n                ListNode tail = dummy, prev = dummy,temp;\\n                int count;\\n                while(true){\\n                    count =k;\\n                    while(count>0&&tail!=null){\\n                        count--;\\n                        tail=tail.next;\\n                    } \\n                    if (tail==null) break;//Has reached the end\\n                    \\n        \\n                    head=prev.next;//for next cycle\\n                // prev-->temp-->...--->....--->tail-->....\\n                // Delete @temp and insert to the next position of @tail\\n                // prev-->...-->...-->tail-->head-->...\\n                // Assign @temp to the next node of @prev\\n                // prev-->temp-->...-->tail-->...-->...\\n                // Keep doing until @tail is the next node of @prev\\n                    while(prev.next!=tail){\\n                        temp=prev.next;//Assign\\n                        prev.next=temp.next;//Delete\\n                        \\n                        temp.next=tail.next;\\n                        tail.next=temp;//Insert\\n                        \\n                    }\\n                    \\n                    tail=head;\\n                    prev=head;\\n                    \\n                }\\n                return dummy.next;\\n                \\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public ListNode reverseKGroup(ListNode head, int k) {\\n                if (head==null||head.next==null||k<2) return head;\\n        \\n                ListNode dummy = new ListNode(0);\\n                dummy.next = head;\\n                \\n                ListNode tail = dummy, prev = dummy,temp;\\n                int count;\\n                while(true){\\n                    count =k;\\n                    while(count>0&&tail!=null){\\n                        count--;\\n                        tail=tail.next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 718457,
                "title": "python3-easy-recursion-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:        \\n        # Check if we need to reverse the group\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n\\t\\t        \\n\\t\\t\\t\\t\\n        # Reverse the group (basic way to reverse linked list)\\n        prev = None\\n        curr = head\\n        for _ in range(k):\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        \\n\\t\\t\\n        # After reverse, we know that `head` is the tail of the group.\\n\\t\\t# And `curr` is the next pointer in original linked list order\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n    ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:        \\n        # Check if we need to reverse the group\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n\\t\\t        \\n\\t\\t\\t\\t\\n        # Reverse the group (basic way to reverse linked list)\\n        prev = None\\n        curr = head\\n        for _ in range(k):\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        \\n\\t\\t\\n        # After reverse, we know that `head` is the tail of the group.\\n\\t\\t# And `curr` is the next pointer in original linked list order\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 11653,
                "title": "python-recursive-and-iterative-solutions-with-comments",
                "content": "       \\n    # Recursively\\n    def reverseKGroup(self, head, k):\\n        l, node = 0, head\\n        while node:\\n            l += 1\\n            node = node.next\\n        if k <= 1 or l < k:\\n            return head\\n        node, cur = None, head\\n        for _ in xrange(k):\\n            nxt = cur.next\\n            cur.next = node\\n            node = cur\\n            cur = nxt\\n        head.next = self.reverseKGroup(cur, k)\\n        return node\\n    \\n    # Iteratively    \\n    def reverseKGroup(self, head, k):\\n        if not head or not head.next or k <= 1:\\n            return head\\n        cur, l = head, 0\\n        while cur:\\n            l += 1\\n            cur = cur.next\\n        if k > l:\\n            return head\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        # totally l//k groups\\n        for i in xrange(l//k):\\n            # reverse each group\\n            node = None\\n            for j in xrange(k-1):\\n                nxt = head.next\\n                head.next = node\\n                node = head\\n                head = nxt\\n            # update nodes and connect nodes\\n            tmp = head.next\\n            head.next = node\\n            pre.next.next = tmp\\n            tmp1 = pre.next\\n            pre.next = head\\n            head = tmp\\n            pre = tmp1\\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "       \\n    # Recursively\\n    def reverseKGroup(self, head, k):\\n        l, node = 0, head\\n        while node:\\n            l += 1\\n            node = node.next\\n        if k <= 1 or l < k:\\n            return head\\n        node, cur = None, head\\n        for _ in xrange(k):\\n            nxt = cur.next\\n            cur.next = node\\n            node = cur\\n            cur = nxt\\n        head.next = self.reverseKGroup(cur, k)\\n        return node\\n    \\n    # Iteratively    \\n    def reverseKGroup(self, head, k):\\n        if not head or not head.next or k <= 1:\\n            return head\\n        cur, l = head, 0\\n        while cur:\\n            l += 1\\n            cur = cur.next\\n        if k > l:\\n            return head\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        # totally l//k groups\\n        for i in xrange(l//k):\\n            # reverse each group\\n            node = None\\n            for j in xrange(k-1):\\n                nxt = head.next\\n                head.next = node\\n                node = head\\n                head = nxt\\n            # update nodes and connect nodes\\n            tmp = head.next\\n            head.next = node\\n            pre.next.next = tmp\\n            tmp1 = pre.next\\n            pre.next = head\\n            head = tmp\\n            pre = tmp1\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 11543,
                "title": "c-iterative",
                "content": "We first get the length `len` of the list. Then we know we need to perform `len / k` groups of reverse operations. In each group, the reverse is performed for `k - 1` times.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        dummy -> next = head;\\n        int len = length(head);\\n        for (int i = 0; i < len / k; i++) {\\n            for (int j = 1; j < k; j++) {\\n                ListNode* temp = pre -> next;\\n                pre -> next = head -> next;\\n                head -> next = head -> next -> next;\\n                pre -> next -> next = temp;\\n            }\\n            pre = head;\\n            head = head -> next;\\n        }\\n        return dummy -> next;\\n    }\\nprivate:\\n    ListNode *dummy = new ListNode(0), *pre = dummy;\\n    int length(ListNode* head) {\\n        int len = 0;\\n        while (head) {\\n            len++;\\n            head = head -> next;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        dummy -> next = head;\\n        int len = length(head);\\n        for (int i = 0; i < len / k; i++) {\\n            for (int j = 1; j < k; j++) {\\n                ListNode* temp = pre -> next;\\n                pre -> next = head -> next;\\n                head -> next = head -> next -> next;\\n                pre -> next -> next = temp;\\n            }\\n            pre = head;\\n            head = head -> next;\\n        }\\n        return dummy -> next;\\n    }\\nprivate:\\n    ListNode *dummy = new ListNode(0), *pre = dummy;\\n    int length(ListNode* head) {\\n        int len = 0;\\n        while (head) {\\n            len++;\\n            head = head -> next;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345510,
                "title": "reverse-nodes-in-k-group-iterative-recursion-w-explanation",
                "content": "***Solution 1:(Recursion)***\\n***\\n**Approach:**\\n```\\n1) The first step is to check whether the Head is NULL or Not, if its NULL then we can directly return NULL,\\n2) If the Head is not NULL, then we need to check the length of Linked List starting from current Head.\\n3) If it is not a multiple of K(Less than K) , then there is no need to reverse it and hence we can directly return head,\\n4) Else if its a multiple of K, then we have to reverse the K elements starting from current Head,\\n5) We will follow the same steps for the rest of the elements Recursively.\\n```\\n***\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(!head)\\n            return NULL;\\n        ListNode *KSizeChecker = head;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(KSizeChecker==NULL)\\n                return head;\\n            KSizeChecker = KSizeChecker->next;\\n        }\\n        int cnt=0;\\n        ListNode *cur=head,*prev=NULL,*next=NULL;\\n        while(cur and cnt<k)\\n        {\\n            next=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=next;\\n            cnt++;\\n        }\\n        if(next)\\n            head->next=reverseKGroup(next,k);\\n        return prev;\\n    }\\n};\\n```\\n\\n***\\n***Solution 2:(Iterative):***\\n**Approach:**\\n```\\n1) We first try to find out the length of linked list,\\nLet it be \"Len\"\\n2) Now we try to find out , how many groups of size \"K\" are there to reverse,\\nthis can be easily done using the formula --- \"Len/K\"\\n3) Hence we have Len/K groups to reverse,\\n4) To easily find out the new Linked List\\'s Head(After reversal), we will make a dummyNode just before the head,\\nand at last for new Head we can directly return dummyNode->next,\\n5) The reversal of linked list is very easy ,\\nwe just need to keep track of remaining Nodes and the new head for reversed linked list.\\n```\\n\\n**C++:**\\n```\\nclass Solution {\\n    int getLengthOfLinkedList(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        int cnt=0;\\n        while(ptr)\\n        {\\n            cnt++;\\n            ptr=ptr->next;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(!head)\\n            return NULL;\\n    \\n        int len = getLengthOfLinkedList(head);\\n        if(len<k)\\n            return head;\\n        \\n        int numberOfGroupsToReverse = len/k;\\n        \\n        ListNode *dummyNode = new ListNode(-1);\\n        dummyNode->next = head;\\n        ListNode *start = dummyNode;\\n\\n        ListNode *pre,*remaining,*next;\\n        for(int i=0;i<numberOfGroupsToReverse;i++)\\n        {\\n            pre = NULL;\\n            remaining = head;\\n            for(int j=0;j<k;j++)\\n            {\\n                next = head->next;\\n                head->next = pre;\\n                pre=head;\\n                head=next;\\n            }\\n            start->next = pre;\\n            remaining->next = head;\\n            start = remaining;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1) The first step is to check whether the Head is NULL or Not, if its NULL then we can directly return NULL,\\n2) If the Head is not NULL, then we need to check the length of Linked List starting from current Head.\\n3) If it is not a multiple of K(Less than K) , then there is no need to reverse it and hence we can directly return head,\\n4) Else if its a multiple of K, then we have to reverse the K elements starting from current Head,\\n5) We will follow the same steps for the rest of the elements Recursively.\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(!head)\\n            return NULL;\\n        ListNode *KSizeChecker = head;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(KSizeChecker==NULL)\\n                return head;\\n            KSizeChecker = KSizeChecker->next;\\n        }\\n        int cnt=0;\\n        ListNode *cur=head,*prev=NULL,*next=NULL;\\n        while(cur and cnt<k)\\n        {\\n            next=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=next;\\n            cnt++;\\n        }\\n        if(next)\\n            head->next=reverseKGroup(next,k);\\n        return prev;\\n    }\\n};\\n```\n```\\n1) We first try to find out the length of linked list,\\nLet it be \"Len\"\\n2) Now we try to find out , how many groups of size \"K\" are there to reverse,\\nthis can be easily done using the formula --- \"Len/K\"\\n3) Hence we have Len/K groups to reverse,\\n4) To easily find out the new Linked List\\'s Head(After reversal), we will make a dummyNode just before the head,\\nand at last for new Head we can directly return dummyNode->next,\\n5) The reversal of linked list is very easy ,\\nwe just need to keep track of remaining Nodes and the new head for reversed linked list.\\n```\n```\\nclass Solution {\\n    int getLengthOfLinkedList(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        int cnt=0;\\n        while(ptr)\\n        {\\n            cnt++;\\n            ptr=ptr->next;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(!head)\\n            return NULL;\\n    \\n        int len = getLengthOfLinkedList(head);\\n        if(len<k)\\n            return head;\\n        \\n        int numberOfGroupsToReverse = len/k;\\n        \\n        ListNode *dummyNode = new ListNode(-1);\\n        dummyNode->next = head;\\n        ListNode *start = dummyNode;\\n\\n        ListNode *pre,*remaining,*next;\\n        for(int i=0;i<numberOfGroupsToReverse;i++)\\n        {\\n            pre = NULL;\\n            remaining = head;\\n            for(int j=0;j<k;j++)\\n            {\\n                next = head->next;\\n                head->next = pre;\\n                pre=head;\\n                head=next;\\n            }\\n            start->next = pre;\\n            remaining->next = head;\\n            start = remaining;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11475,
                "title": "my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n    int length(ListNode * node){\\n        int count=0;\\n        while(node){\\n            count++;\\n            node=node->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       if(length(head) < k)return head;\\n       ListNode * cur=head;\\n       ListNode * prev=NULL, *next=NULL;\\n       while(int i=0; i < k; i++){\\n           next=cur->next;\\n           cur->next=prev;\\n           prev=cur;\\n           cur=next;\\n       }\\n       head->next=reverseKGroup(cur, k);\\n       return prev;\\n     }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int length(ListNode * node){\\n        int count=0;\\n        while(node){\\n            count++;\\n            node=node->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1345590,
                "title": "python-o-n-o-1-time-memory-a-bit-explained",
                "content": "This is quite classical linked list problem and it is quite nasty in my opinion. It can be a bit problematic to imagine all this in your head, do it on paper. The idea is to add dummy variable, then calculate number of nodes. We need this, because we do not need to reverse last group. Then we use idea similar to problem **0206** Reverse Linked List: but here we need to reverse `k` elements, and then reconnect first and last nodes in each group and update `cnt`.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def reverseKGroup(self, head, k):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur, nxt, pre = dummy, dummy, dummy\\n        cnt = 0\\n        while cur.next:\\n            cnt += 1\\n            cur = cur.next\\n            \\n        while cnt >= k:\\n            cur = new = pre.next\\n            nxt = cur.next\\n            for _ in range(k-1):\\n                tmp = nxt.next\\n                nxt.next = cur\\n                cur = nxt\\n                nxt = tmp\\n            \\n            pre.next = cur\\n            new.next = nxt\\n            pre = new\\n            cnt -= k\\n            \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseKGroup(self, head, k):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur, nxt, pre = dummy, dummy, dummy\\n        cnt = 0\\n        while cur.next:\\n            cnt += 1\\n            cur = cur.next\\n            \\n        while cnt >= k:\\n            cur = new = pre.next\\n            nxt = cur.next\\n            for _ in range(k-1):\\n                tmp = nxt.next\\n                nxt.next = cur\\n                cur = nxt\\n                nxt = tmp\\n            \\n            pre.next = cur\\n            new.next = nxt\\n            pre = new\\n            cnt -= k\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367041,
                "title": "c-simple-and-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head, ListNode* tail) {\\n        ListNode* current = head;\\n        ListNode *prev = NULL, *next = NULL;\\n \\n        while (current != tail) {\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* ptr = head;\\n        \\n        for (int i = 0; i < k; i++) {\\n            if (!ptr) return head;\\n            ptr = ptr->next;\\n            \\n        }\\n        ListNode* tmp = reverse(head, ptr);\\n        head->next = reverseKGroup(ptr, k);\\n        return tmp;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head, ListNode* tail) {\\n        ListNode* current = head;\\n        ListNode *prev = NULL, *next = NULL;\\n \\n        while (current != tail) {\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* ptr = head;\\n        \\n        for (int i = 0; i < k; i++) {\\n            if (!ptr) return head;\\n            ptr = ptr->next;\\n            \\n        }\\n        ListNode* tmp = reverse(head, ptr);\\n        head->next = reverseKGroup(ptr, k);\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11638,
                "title": "java-o-n-elegant-code-solution",
                "content": "  why use while(true) loop? We don't know if there is k nodes left out in advance. So we advance tail for k steps to check for that. If there is no k nodes, the program exits from there.\\n\\n \\n\\n     public class Solution {\\n            public ListNode reverseKGroup(ListNode head, int k) {\\n                if (k <= 1 || head == null || head.next == null)\\n                    return head;\\n                ListNode newHead = new ListNode(0);\\n                newHead.next = head;\\n                ListNode prev, start, then, tail;\\n                tail = prev = newHead;\\n                start = prev.next;\\n                while (true) {\\n                    // check if there's k nodes left-out\\n                    for (int i = 0; i < k; i++) {\\n                        tail = tail.next;\\n                        if (tail == null)\\n                            return newHead.next;\\n                    }\\n                    // reverse k nodes\\n                    for (int i = 0; i < k - 1; i++) {\\n                        then = start.next;\\n                        start.next = then.next;\\n                        then.next = prev.next;\\n                        prev.next = then;\\n                    }\\n                    tail = prev = start;\\n                    start = prev.next;\\n                }\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public ListNode reverseKGroup(ListNode head, int k) {\\n                if (k <= 1 || head == null || head.next == null)\\n                    return head;\\n                ListNode newHead = new ListNode(0);\\n                newHead.next = head;\\n                ListNode prev, start, then, tail;\\n                tail = prev = newHead;\\n                start = prev.next;\\n                while (true) {\\n                    // check if there's k nodes left-out\\n                    for (int i = 0; i < k; i++) {\\n                        tail = tail.next;\\n                        if (tail == null)\\n                            return newHead.next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1656819,
                "title": "solution-swift-reverse-nodes-in-k-group-test-cases",
                "content": "```swift\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        let node = ListNode(0)\\n        node.next = head\\n        \\n        var prev = node\\n        \\n        while prev.next != nil {\\n            var tail: ListNode? = prev\\n            for _ in 1...k { tail = tail?.next }\\n            guard var node = tail else { break }\\n            \\n            let next = node.next\\n            var last = next\\n            var curr = prev.next\\n            \\n            while curr !== next {\\n                let cnext = curr!.next\\n                curr!.next = last\\n                last = curr\\n                curr = cnext\\n            }\\n            if let pnext = prev.next { node = pnext }\\n            prev.next = last\\n            prev = node\\n        }\\n        return node.next\\n    }\\n}\\n```\\n\\n---\\n\\n<p><details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.040 (0.042) seconds\\n</pre></p>\\n\\n```swift\\n// Result: Executed 2 tests, with 0 failures (0 unexpected) in 0.020 (0.022) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.reverseKGroup(ListNode([1,2,3,4,5]), 2)\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3,5])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.reverseKGroup(ListNode([1,2,3,4,5]), 3)\\n        XCTAssertEqual(value?.val, ListNode([3,2,1,4,5])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>\\n\\n<p><details>\\n<summary>\\n<b>ListNode</b>\\n</summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        let node = ListNode(0)\\n        node.next = head\\n        \\n        var prev = node\\n        \\n        while prev.next != nil {\\n            var tail: ListNode? = prev\\n            for _ in 1...k { tail = tail?.next }\\n            guard var node = tail else { break }\\n            \\n            let next = node.next\\n            var last = next\\n            var curr = prev.next\\n            \\n            while curr !== next {\\n                let cnext = curr!.next\\n                curr!.next = last\\n                last = curr\\n                curr = cnext\\n            }\\n            if let pnext = prev.next { node = pnext }\\n            prev.next = last\\n            prev = node\\n        }\\n        return node.next\\n    }\\n}\\n```\n```swift\\n// Result: Executed 2 tests, with 0 failures (0 unexpected) in 0.020 (0.022) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.reverseKGroup(ListNode([1,2,3,4,5]), 2)\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3,5])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.reverseKGroup(ListNode([1,2,3,4,5]), 3)\\n        XCTAssertEqual(value?.val, ListNode([3,2,1,4,5])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799333,
                "title": "c-simple-recursive-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++){\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        ListNode *prev=NULL;\\n        ListNode *nex1=NULL;\\n        temp=head;\\n        for(int i=0;i<k;i++){\\n            nex1=temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nex1;\\n        }\\n        if(nex1!=NULL)\\n            head->next=reverseKGroup(nex1,k);\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++){\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        ListNode *prev=NULL;\\n        ListNode *nex1=NULL;\\n        temp=head;\\n        for(int i=0;i<k;i++){\\n            nex1=temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nex1;\\n        }\\n        if(nex1!=NULL)\\n            head->next=reverseKGroup(nex1,k);\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441014,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* counter = head;\\n        ListNode* temp = head;\\n        ListNode* ans = head;\\n        while(counter!=NULL){\\n            cnt++;\\n            counter = counter->next;\\n        }\\n        cnt /= k;\\n        stack<int> st;\\n        int k1 = k;\\n\\n        while(temp!=NULL){\\n            st.push(temp->val);\\n            k1--;\\n            temp = temp->next;\\n            if(k1==0){\\n                while(!st.empty()){\\n                    ans->val = st.top();\\n                    st.pop();\\n                    ans = ans->next;\\n                }\\n                cnt--;\\n                k1 = k;\\n            }\\n            if(cnt==0){\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* counter = head;\\n        ListNode* temp = head;\\n        ListNode* ans = head;\\n        while(counter!=NULL){\\n            cnt++;\\n            counter = counter->next;\\n        }\\n        cnt /= k;\\n        stack<int> st;\\n        int k1 = k;\\n\\n        while(temp!=NULL){\\n            st.push(temp->val);\\n            k1--;\\n            temp = temp->next;\\n            if(k1==0){\\n                while(!st.empty()){\\n                    ans->val = st.top();\\n                    st.pop();\\n                    ans = ans->next;\\n                }\\n                cnt--;\\n                k1 = k;\\n            }\\n            if(cnt==0){\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517593,
                "title": "c-java-python-javascript-tc-o-n-optimized-solution",
                "content": "# Intuition:\\nWe can use a two-pointer approach to reverse the linked list in groups of k nodes. We will maintain a `prevGroupTail` pointer that will point to the tail of the previous reversed group, and we will connect it to the head of the current group after reversing it. We will also use a `dummy` node as the head of the resulting list to avoid edge cases.\\n\\n# Approach:\\n1. Create a dummy node and set its next to the head of the input list.\\n2. Initialize a `prevGroupTail` pointer to the dummy node.\\n3. Loop through the list until we reach the end.\\n4. In each iteration, set `groupStart` to the current `head`, and find `groupEnd` using the `getGroupEnd` function, which returns the end node of the current group (which is `k` nodes away from the `groupStart`). If `groupEnd` is null, then we don\\'t need to reverse the remaining nodes because there are less than `k` nodes left in the list.\\n5. Set `nextGroupStart` to `groupEnd->next`, and then set `groupEnd->next` to null to separate the group to be reversed from the rest of the list.\\n6. Reverse the current group using the `reverseList` function and set `prevGroupTail->next` to the new head of the reversed group. Then set `groupStart->next` to `nextGroupStart`.\\n7. Update `prevGroupTail` to the `groupStart`.\\n8. Set `head` to `nextGroupStart`.\\n9. Return the head of the resulting list (which is the `dummy->next` node).\\n\\n# Complexity\\n- Time Complexity:\\nThe time complexity of the algorithm is O(n), where n is the number of nodes in the list, since we visit each node once.\\n\\n- Space Complexity:\\nThe space complexity of the algorithm is O(1), since we only use a constant amount of extra space for the `dummy` and `prevGroupTail` nodes, and we reverse the list in-place without using any additional data structures.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prevGroupTail = dummy;\\n        \\n        while (head) {\\n            ListNode* groupStart = head;\\n            ListNode* groupEnd = getGroupEnd(head, k);\\n            \\n            if (!groupEnd) {\\n                break; // Remaining nodes are less than k, so no need to reverse\\n            }\\n            \\n            ListNode* nextGroupStart = groupEnd->next;\\n            groupEnd->next = nullptr; // Separate the group to be reversed\\n            \\n            // Reverse the group\\n            prevGroupTail->next = reverseList(groupStart);\\n            groupStart->next = nextGroupStart;\\n            \\n            prevGroupTail = groupStart;\\n            head = nextGroupStart;\\n        }\\n        \\n        ListNode* newHead = dummy->next;\\n        delete dummy;\\n        return newHead;\\n    }\\n    \\nprivate:\\n    ListNode* getGroupEnd(ListNode* head, int k) {\\n        while (head && k > 1) {\\n            head = head->next;\\n            k--;\\n        }\\n        return head;\\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr) {\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prevGroupTail = dummy;\\n\\n        while (head != null) {\\n            ListNode groupStart = head;\\n            ListNode groupEnd = getGroupEnd(head, k);\\n\\n            if (groupEnd == null)\\n                break;\\n\\n            prevGroupTail.next = reverseList(groupStart, groupEnd.next);\\n            prevGroupTail = groupStart;\\n            head = prevGroupTail.next;\\n        }\\n\\n        ListNode newHead = dummy.next;\\n        return newHead;\\n    }\\n\\n    private ListNode getGroupEnd(ListNode head, int k) {\\n        while (head != null && --k > 0)\\n            head = head.next;\\n        return head;\\n    }\\n\\n    private ListNode reverseList(ListNode head, ListNode stop) {\\n        ListNode prev = stop;\\n        while (head != stop) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def reverseKGroup(self, head, k):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prevGroupTail = dummy\\n\\n        while head:\\n            groupStart = head\\n            groupEnd = self.getGroupEnd(head, k)\\n\\n            if not groupEnd:\\n                break\\n\\n            prevGroupTail.next = self.reverseList(groupStart, groupEnd.next)\\n            prevGroupTail = groupStart\\n            head = prevGroupTail.next\\n\\n        newHead = dummy.next\\n        return newHead\\n\\n    def getGroupEnd(self, head, k):\\n        while head and k > 1:\\n            head = head.next\\n            k -= 1\\n        return head\\n\\n    def reverseList(self, head, stop):\\n        prev = stop\\n        while head != stop:\\n            next = head.next\\n            head.next = prev\\n            prev = head\\n            head = next\\n        return prev\\n```\\n---\\n# JavaScript\\n```\\nvar reverseKGroup = function(head, k) {\\n    var dummy = new ListNode(0);\\n        dummy.next = head;\\n        var prevGroupTail = dummy;\\n\\n        while (head) {\\n            var groupStart = head;\\n            var groupEnd = getGroupEnd(head, k);\\n\\n            if (!groupEnd)\\n                break;\\n\\n            prevGroupTail.next = reverseList(groupStart, groupEnd.next);\\n            prevGroupTail = groupStart;\\n            head = prevGroupTail.next;\\n        }\\n    var newHead = dummy.next;\\n    return newHead;\\n}\\n\\nvar getGroupEnd = function(head, k) {\\n    while (head && k > 1) {\\n        head = head.next;\\n        k--;\\n    }\\n    return head;\\n}\\n\\nvar reverseList = function(head, stop) {\\n    var prev = stop;\\n    while (head !== stop) {\\n        var next = head.next;\\n        head.next = prev;\\n        prev = head;\\n        head = next;\\n    }\\n    return prev;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prevGroupTail = dummy;\\n        \\n        while (head) {\\n            ListNode* groupStart = head;\\n            ListNode* groupEnd = getGroupEnd(head, k);\\n            \\n            if (!groupEnd) {\\n                break; // Remaining nodes are less than k, so no need to reverse\\n            }\\n            \\n            ListNode* nextGroupStart = groupEnd->next;\\n            groupEnd->next = nullptr; // Separate the group to be reversed\\n            \\n            // Reverse the group\\n            prevGroupTail->next = reverseList(groupStart);\\n            groupStart->next = nextGroupStart;\\n            \\n            prevGroupTail = groupStart;\\n            head = nextGroupStart;\\n        }\\n        \\n        ListNode* newHead = dummy->next;\\n        delete dummy;\\n        return newHead;\\n    }\\n    \\nprivate:\\n    ListNode* getGroupEnd(ListNode* head, int k) {\\n        while (head && k > 1) {\\n            head = head->next;\\n            k--;\\n        }\\n        return head;\\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr) {\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prevGroupTail = dummy;\\n\\n        while (head != null) {\\n            ListNode groupStart = head;\\n            ListNode groupEnd = getGroupEnd(head, k);\\n\\n            if (groupEnd == null)\\n                break;\\n\\n            prevGroupTail.next = reverseList(groupStart, groupEnd.next);\\n            prevGroupTail = groupStart;\\n            head = prevGroupTail.next;\\n        }\\n\\n        ListNode newHead = dummy.next;\\n        return newHead;\\n    }\\n\\n    private ListNode getGroupEnd(ListNode head, int k) {\\n        while (head != null && --k > 0)\\n            head = head.next;\\n        return head;\\n    }\\n\\n    private ListNode reverseList(ListNode head, ListNode stop) {\\n        ListNode prev = stop;\\n        while (head != stop) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def reverseKGroup(self, head, k):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prevGroupTail = dummy\\n\\n        while head:\\n            groupStart = head\\n            groupEnd = self.getGroupEnd(head, k)\\n\\n            if not groupEnd:\\n                break\\n\\n            prevGroupTail.next = self.reverseList(groupStart, groupEnd.next)\\n            prevGroupTail = groupStart\\n            head = prevGroupTail.next\\n\\n        newHead = dummy.next\\n        return newHead\\n\\n    def getGroupEnd(self, head, k):\\n        while head and k > 1:\\n            head = head.next\\n            k -= 1\\n        return head\\n\\n    def reverseList(self, head, stop):\\n        prev = stop\\n        while head != stop:\\n            next = head.next\\n            head.next = prev\\n            prev = head\\n            head = next\\n        return prev\\n```\n```\\nvar reverseKGroup = function(head, k) {\\n    var dummy = new ListNode(0);\\n        dummy.next = head;\\n        var prevGroupTail = dummy;\\n\\n        while (head) {\\n            var groupStart = head;\\n            var groupEnd = getGroupEnd(head, k);\\n\\n            if (!groupEnd)\\n                break;\\n\\n            prevGroupTail.next = reverseList(groupStart, groupEnd.next);\\n            prevGroupTail = groupStart;\\n            head = prevGroupTail.next;\\n        }\\n    var newHead = dummy.next;\\n    return newHead;\\n}\\n\\nvar getGroupEnd = function(head, k) {\\n    while (head && k > 1) {\\n        head = head.next;\\n        k--;\\n    }\\n    return head;\\n}\\n\\nvar reverseList = function(head, stop) {\\n    var prev = stop;\\n    while (head !== stop) {\\n        var next = head.next;\\n        head.next = prev;\\n        prev = head;\\n        head = next;\\n    }\\n    return prev;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11649,
                "title": "javascript-solution",
                "content": "    function reverseKGroup(head, k) {\\n      if (!head) return null;\\n      var tail = head;\\n      for (var i = 1; i < k; i++) {\\n        tail = tail.next;\\n        if (!tail) return head;\\n      }\\n      var next = tail.next;\\n      tail.next = null;\\n      reverse(head);\\n      head.next = reverseKGroup(next, k);\\n      return tail;\\n    }\\n    \\n    function reverse(curr) {\\n      var prev = null;\\n      while (curr) {\\n        var next = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = next;\\n      }\\n      return prev;\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function reverseKGroup(head, k) {\\n      if (!head) return null;\\n      var tail = head;\\n      for (var i = 1; i < k; i++) {\\n        tail = tail.next;\\n        if (!tail) return head;\\n      }\\n      var next = tail.next;\\n      tail.next = null;\\n      reverse(head);\\n      head.next = reverseKGroup(next, k);\\n      return tail;\\n    }\\n    \\n    function reverse(curr) {\\n      var prev = null;\\n      while (curr) {\\n        var next = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = next;\\n      }\\n      return prev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11425,
                "title": "simple-python-solution-one-pass-no-additional-space-109ms",
                "content": "The key idea is to keep track of the `next_head` while reversing the group, `tail` of the current group is always the start node of the group, once the group reversing is done, `next_head` is available, simply connect it to `tail`. \\n\\n     \\n    def reverseKGroup(self, head, k):\\n        if head is None or k < 2:\\n            return head\\n        \\n        next_head = head\\n        for i in range(k - 1):\\n            next_head = next_head.next\\n            if next_head is None:\\n                return head\\n        ret = next_head\\n        \\n        current = head\\n        while next_head:\\n            tail = current\\n            prev = None\\n            for i in range(k):\\n                if next_head:\\n                    next_head = next_head.next\\n                _next = current.next\\n                current.next = prev\\n                prev = current\\n                current = _next\\n            tail.next = next_head or current\\n                \\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "The key idea is to keep track of the `next_head` while reversing the group, `tail` of the current group is always the start node of the group, once the group reversing is done, `next_head` is available, simply connect it to `tail`. \\n\\n     \\n    def reverseKGroup(self, head, k):\\n        if head is None or k < 2:\\n            return head\\n        \\n        next_head = head\\n        for i in range(k - 1):\\n            next_head = next_head.next\\n            if next_head is None:\\n                return head\\n        ret = next_head\\n        \\n        current = head\\n        while next_head:\\n            tail = current\\n            prev = None\\n            for i in range(k):\\n                if next_head:\\n                    next_head = next_head.next\\n                _next = current.next\\n                current.next = prev\\n                prev = current\\n                current = _next\\n            tail.next = next_head or current\\n                \\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 3521559,
                "title": "python3-iterative-recursive-solutions-beats-98",
                "content": "# Iterative solution:\\n```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        def getGroupEnd(cur, k):\\n            while k > 1 and cur.next:\\n                cur = cur.next \\n                k-=1\\n            return cur if k == 1 else None\\n\\n        def reverseGroup(start, end):\\n            prev, cur, new_group_start = None, start, end.next\\n            while cur != new_group_start:\\n                cur.next, cur, prev = prev, cur.next, cur  \\n\\n        dummy = ListNode()\\n        prev_group = dummy\\n        while head:\\n            group_start = head\\n            group_end = getGroupEnd(head, k)\\n            if not group_end: break # not enough todes to make a new group\\n            next_group_start = group_end.next # save link to the next group start\\n            reverseGroup(group_start, group_end) # reverse the current group\\n            prev_group.next = group_end # group_end is the start of the reversed group\\n            prev_group = group_start # group_start is the end of the reversed group\\n            group_start.next = next_group_start # link current reversed group with the next group\\n            head = next_group_start # move current point to the start of the next group\\n\\n        return dummy.next        \\n```\\n```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        prev_group = dummy\\n        while head:\\n            j, group_end = 1, head #start of group = end after reverse\\n            while j < k and head.next:\\n                head = head.next \\n                j+=1\\n            group_start = head #end of group = start after reverse\\n            next_group = head = head.next #start of next group\\n\\n            if j != k:  #don\\'t need reverse (not enough nodes)\\n                break\\n            #reverse current group without links to prev and next groups\\n            prev, cur = None, group_end\\n            while cur != next_group:\\n                cur.next, cur, prev = prev, cur.next, cur  \\n\\n            prev_group.next = group_start\\n            prev_group = group_end\\n            group_end.next = next_group\\n\\n        return dummy.next    \\n```\\n![Screenshot 2023-08-03 at 03.09.07.png](https://assets.leetcode.com/users/images/b4a03976-433e-4ee0-b939-8d792674dcea_1691021437.7787385.png)\\n# Recursive solution:\\n```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head: return\\n        start, end = head, head\\n        for _ in range(k):\\n            if not end: return head\\n            end = end.next\\n        \\n        # reverse diapason [start:end)\\n        def reverse(start, end):\\n            prev = None\\n            while start != end:\\n                start.next, start, prev = prev, start.next, start\\n            return prev # return head node of the reversed group\\n        \\n        newHead = reverse(start, end)\\n        start.next = self.reverseKGroup(end, k)\\n\\n        return newHead\\n```\\n![Screenshot 2023-08-03 at 04.06.16.png](https://assets.leetcode.com/users/images/23207cea-9dec-4462-acd9-b5e9732060c4_1691024788.7471995.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        def getGroupEnd(cur, k):\\n            while k > 1 and cur.next:\\n                cur = cur.next \\n                k-=1\\n            return cur if k == 1 else None\\n\\n        def reverseGroup(start, end):\\n            prev, cur, new_group_start = None, start, end.next\\n            while cur != new_group_start:\\n                cur.next, cur, prev = prev, cur.next, cur  \\n\\n        dummy = ListNode()\\n        prev_group = dummy\\n        while head:\\n            group_start = head\\n            group_end = getGroupEnd(head, k)\\n            if not group_end: break # not enough todes to make a new group\\n            next_group_start = group_end.next # save link to the next group start\\n            reverseGroup(group_start, group_end) # reverse the current group\\n            prev_group.next = group_end # group_end is the start of the reversed group\\n            prev_group = group_start # group_start is the end of the reversed group\\n            group_start.next = next_group_start # link current reversed group with the next group\\n            head = next_group_start # move current point to the start of the next group\\n\\n        return dummy.next        \\n```\n```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        prev_group = dummy\\n        while head:\\n            j, group_end = 1, head #start of group = end after reverse\\n            while j < k and head.next:\\n                head = head.next \\n                j+=1\\n            group_start = head #end of group = start after reverse\\n            next_group = head = head.next #start of next group\\n\\n            if j != k:  #don\\'t need reverse (not enough nodes)\\n                break\\n            #reverse current group without links to prev and next groups\\n            prev, cur = None, group_end\\n            while cur != next_group:\\n                cur.next, cur, prev = prev, cur.next, cur  \\n\\n            prev_group.next = group_start\\n            prev_group = group_end\\n            group_end.next = next_group\\n\\n        return dummy.next    \\n```\n```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head: return\\n        start, end = head, head\\n        for _ in range(k):\\n            if not end: return head\\n            end = end.next\\n        \\n        # reverse diapason [start:end)\\n        def reverse(start, end):\\n            prev = None\\n            while start != end:\\n                start.next, start, prev = prev, start.next, start\\n            return prev # return head node of the reversed group\\n        \\n        newHead = reverse(start, end)\\n        start.next = self.reverseKGroup(end, k)\\n\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391334,
                "title": "0ms-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic ListNode reverseKGroup(ListNode head, int k) {\\n        int count = 0;\\n        ListNode temp = head;\\n        while(temp!=null && count<k) {\\n            temp = temp.next;\\n            count++;\\n        }\\n        if(count<k) return head; \\n        \\n        int n = k;\\n        ListNode tail = head;                \\n        ListNode front = reverse(head,n);\\n        tail.next = reverseKGroup(temp,n);        \\n        return front;\\n    }\\n    \\n    private ListNode reverse(ListNode head,int k){\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next = head;  \\n        while(k--!=0){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic ListNode reverseKGroup(ListNode head, int k) {\\n        int count = 0;\\n        ListNode temp = head;\\n        while(temp!=null && count<k) {\\n            temp = temp.next;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 816529,
                "title": "c-easy-code-with-explanation",
                "content": "Code taken from @luming.zhang.75\\n\\n**Code Explanation:**\\n![image](https://assets.leetcode.com/users/images/5032b423-d4e6-4c75-92d4-4d4a2f289f31_1598617516.880798.png)\\n![image](https://assets.leetcode.com/users/images/f4ef38d4-073c-4dd9-a89f-4c92cb2d0678_1598617518.1261814.png)\\n\\n**Code**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        \\n        ListNode *preheader=new ListNode(-1);\\n        preheader->next=head;\\n        ListNode *pre=preheader,*curr=preheader,*nex;\\n        \\n        //Counting total elements\\n        int nums=0;\\n        while(curr->next!=NULL)\\n            nums++,curr=curr->next;\\n        \\n        while(nums>=k)\\n        {\\n            curr=pre->next;\\n            nex=curr->next;\\n            \\n            //k-1 swaps\\n            for(int i=1;i<k;i++)\\n            {\\n                curr->next=nex->next;\\n                nex->next=pre->next;\\n                pre->next=nex;\\n                nex=curr->next;\\n            }\\n            pre=curr;\\n            nums=nums-k;\\n        }\\n        return preheader->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        \\n        ListNode *preheader=new ListNode(-1);\\n        preheader->next=head;\\n        ListNode *pre=preheader,*curr=preheader,*nex;\\n        \\n        //Counting total elements\\n        int nums=0;\\n        while(curr->next!=NULL)\\n            nums++,curr=curr->next;\\n        \\n        while(nums>=k)\\n        {\\n            curr=pre->next;\\n            nex=curr->next;\\n            \\n            //k-1 swaps\\n            for(int i=1;i<k;i++)\\n            {\\n                curr->next=nex->next;\\n                nex->next=pre->next;\\n                pre->next=nex;\\n                nex=curr->next;\\n            }\\n            pre=curr;\\n            nums=nums-k;\\n        }\\n        return preheader->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902455,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        var tmp1: ListNode? = head\\n        \\n        for _ in 0..<k - 1 { tmp1 = tmp1?.next }\\n        if tmp1 == nil {\\n            return head\\n        } else {\\n            var current: ListNode?\\n            var tmp2: ListNode?\\n            \\n            for _ in 0..<k {\\n                if current == nil {\\n                    current = head?.next\\n                    head?.next = reverseKGroup(tmp1?.next, k)\\n                    tmp1 = head\\n                } else {\\n                    tmp2 = current?.next\\n                    current?.next = tmp1\\n                    tmp1 = current\\n                    current = tmp2\\n                }\\n            }\\n            return tmp1\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        var tmp1: ListNode? = head\\n        \\n        for _ in 0..<k - 1 { tmp1 = tmp1?.next }\\n        if tmp1 == nil {\\n            return head\\n        } else {\\n            var current: ListNode?\\n            var tmp2: ListNode?\\n            \\n            for _ in 0..<k {\\n                if current == nil {\\n                    current = head?.next\\n                    head?.next = reverseKGroup(tmp1?.next, k)\\n                    tmp1 = head\\n                } else {\\n                    tmp2 = current?.next\\n                    current?.next = tmp1\\n                    tmp1 = current\\n                    current = tmp2\\n                }\\n            }\\n            return tmp1\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909747,
                "title": "solution-using-known-methods-to-solve-for-reverse-linked-list",
                "content": "* Code to solve [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head || !head -> next)\\n            return head;\\n        \\n        ListNode *curr = head, *pre = NULL, *next = NULL;\\n        while(curr){\\n            next = curr -> next;\\n            curr -> next = pre;\\n            pre = curr;\\n            curr = next;\\n        }\\n        \\n        return pre;\\n    }\\n};\\n```\\n* Code to solve [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(m != 1){\\n            head -> next = reverseBetween(head -> next, m - 1, n -1);\\n            return head;\\n        }\\n        else{\\n            ListNode *prev = nullptr, *next = nullptr, *temp = head;\\n            int count = 0;\\n            // Following code is same as Reverse Linked List\\n            while(count++ < n){\\n                next = head -> next;\\n                head -> next = prev;\\n                prev = head;\\n                head = next;\\n            }\\n            temp -> next = head;\\n            return prev;\\n        }\\n    }\\n};\\n```\\n* Code to solve [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(k == 1)\\n            return head;\\n        int n = 0;\\n        ListNode* temp = head;\\n        while(temp){\\n            temp = temp -> next;\\n            ++n;\\n        }\\n\\n        int i = 1;\\n        while(i + k <= n + 1){\\n            head = reverseBetween(head, i , i + k - 1);\\n            i += k;\\n        }\\n        return head;\\n    }\\n    \\n    // Following code is same as Reverse Linked List II\\n    ListNode* reverseBetween(ListNode* head, int m, int n){\\n        if(m != 1){\\n            head -> next = reverseBetween(head -> next, m - 1, n -1);\\n            return head;\\n        }\\n        else{\\n            ListNode *prev = nullptr, *next = nullptr, *temp = head;\\n            int count = 0;\\n            // Following code is same as Reverse Linked List\\n            while(count++ < n){\\n                next = head -> next;\\n                head -> next = prev;\\n                prev = head;\\n                head = next;\\n            }\\n            temp -> next = head;\\n            return prev;\\n        }\\n    }\\n};\\n```\\n\\nAs we can see one method can be used within another method to solve the problem.\\n\\n* Same problem can also be solved using calling the same reverse function till it reaches end or where k is more than end.\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(k == 1)\\n            return head;\\n        ListNode *curr = head, *prev = nullptr, *next = nullptr;\\n        int count = 0;\\n        while(count++ < k && curr){\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        if(next){\\n            int i = 0;\\n            ListNode* temp = next;\\n            while(temp && i < k){\\n                temp = temp -> next;\\n                i++;\\n            }\\n            if(i == k)\\n                head -> next = reverseKGroup(next, k);\\n            else\\n                head -> next = next;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head || !head -> next)\\n            return head;\\n        \\n        ListNode *curr = head, *pre = NULL, *next = NULL;\\n        while(curr){\\n            next = curr -> next;\\n            curr -> next = pre;\\n            pre = curr;\\n            curr = next;\\n        }\\n        \\n        return pre;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(m != 1){\\n            head -> next = reverseBetween(head -> next, m - 1, n -1);\\n            return head;\\n        }\\n        else{\\n            ListNode *prev = nullptr, *next = nullptr, *temp = head;\\n            int count = 0;\\n            // Following code is same as Reverse Linked List\\n            while(count++ < n){\\n                next = head -> next;\\n                head -> next = prev;\\n                prev = head;\\n                head = next;\\n            }\\n            temp -> next = head;\\n            return prev;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(k == 1)\\n            return head;\\n        int n = 0;\\n        ListNode* temp = head;\\n        while(temp){\\n            temp = temp -> next;\\n            ++n;\\n        }\\n\\n        int i = 1;\\n        while(i + k <= n + 1){\\n            head = reverseBetween(head, i , i + k - 1);\\n            i += k;\\n        }\\n        return head;\\n    }\\n    \\n    // Following code is same as Reverse Linked List II\\n    ListNode* reverseBetween(ListNode* head, int m, int n){\\n        if(m != 1){\\n            head -> next = reverseBetween(head -> next, m - 1, n -1);\\n            return head;\\n        }\\n        else{\\n            ListNode *prev = nullptr, *next = nullptr, *temp = head;\\n            int count = 0;\\n            // Following code is same as Reverse Linked List\\n            while(count++ < n){\\n                next = head -> next;\\n                head -> next = prev;\\n                prev = head;\\n                head = next;\\n            }\\n            temp -> next = head;\\n            return prev;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(k == 1)\\n            return head;\\n        ListNode *curr = head, *prev = nullptr, *next = nullptr;\\n        int count = 0;\\n        while(count++ < k && curr){\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        if(next){\\n            int i = 0;\\n            ListNode* temp = next;\\n            while(temp && i < k){\\n                temp = temp -> next;\\n                i++;\\n            }\\n            if(i == k)\\n                head -> next = reverseKGroup(next, k);\\n            else\\n                head -> next = next;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346053,
                "title": "java-solution-0ms-100-with-detailed-comments",
                "content": "**Time Complexity for this solution is O(n) \\nSpace Complexity is O(1)**\\n\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n\\t\\t/**\\n\\t\\t* The first rule is if k = 1 we don\\'t need to swap anything. \\n\\t\\t* That is because the only way is to swap with itself that doesn\\'t make any sense\\n\\t\\t*/\\n        if (k == 1) return head;\\n\\t\\t\\n\\t\\t/**\\n\\t\\t* That is my favourite technique to have the top handler of LinkedList. \\n\\t\\t* It prevents from accidentally losing or damaging the head node somewhere in our code\\n\\t\\t*/\\n        ListNode root = new ListNode(-1);\\n        root.next = head;\\n\\n\\t\\t/**\\n\\t\\t* That approach helps us to know beforehand how many groups are available for reversing. \\n\\t\\t* e.g if head = 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 and k = 3 we will know that only 1 -> 2 -> 3 \\n\\t\\t* and 4 -> 5 -> 6 are groups that need to be swapped and not to touch 7 -> 8\\n\\t\\t*/\\n        int count = countNodes(head);\\n        int reverseCount = count / k;\\n        ListNode node = root;\\n        while (reverseCount > 0) {\\n            node = reverse(node, k);\\n            reverseCount--;\\n        }\\n\\n        return root.next;\\n    }\\n\\n\\t/*\\n\\t* The main job is in that method. Basically what we are doing here is to reverse the LinkedList in a particular range.  \\n\\t* That method takes the handler of the current potential group and returns the new handler for the next group for a further iteration.\\n\\t* e.g if we are given head = 1 -> 2 -> 3 -> 4 -> 5 and k = 2 as I mentioned earlier I add root handler(value = -1) to the head like this: \\n\\t* root => -1 ->  | 1 -> 2 | -> 3 -> 4 -> 5. \\n\\t* So the method will take reference of -1 at first, then reverses 1 and 2 like this \\n\\t* root = -1 -> | 2 -> 1 | -> 3 -> 4 -> 5 and returns the reference of next potential group node = 1 -> | 3 -> 4 | -> 5. \\n\\t* On the second iteration the method does the same. it reverses 3 and 4 like this 1 -> | 4 -> 3 | -> 5 and \\n\\t* returns the reference of next potential group node = 3 -> | 5 . . . |\\n\\t* And this process goes again and again\\n\\t*/\\n    public ListNode reverse(ListNode node, int k) {\\n        ListNode curr = node.next;\\n        ListNode tail = null;\\n        ListNode reversed = null;\\n\\n        while (k > 0 && curr != null) {\\n            ListNode newNode = curr.next;\\n            curr.next = reversed;\\n            reversed = curr;\\n            curr = newNode;\\n            if (reversed.next == null) tail = reversed;\\n\\n            k--;\\n        }\\n\\n        tail.next = curr;\\n        node.next = reversed;\\n\\n        return tail;\\n    }\\n\\n    public int countNodes(ListNode node) {\\n        int count = 0;\\n        while (node != null) {\\n            count++;\\n            node = node.next;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n\\t\\t/**\\n\\t\\t* The first rule is if k = 1 we don\\'t need to swap anything. \\n\\t\\t* That is because the only way is to swap with itself that doesn\\'t make any sense\\n\\t\\t*/\\n        if (k == 1) return head;\\n\\t\\t\\n\\t\\t/**\\n\\t\\t* That is my favourite technique to have the top handler of LinkedList. \\n\\t\\t* It prevents from accidentally losing or damaging the head node somewhere in our code\\n\\t\\t*/\\n        ListNode root = new ListNode(-1);\\n        root.next = head;\\n\\n\\t\\t/**\\n\\t\\t* That approach helps us to know beforehand how many groups are available for reversing. \\n\\t\\t* e.g if head = 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 and k = 3 we will know that only 1 -> 2 -> 3 \\n\\t\\t* and 4 -> 5 -> 6 are groups that need to be swapped and not to touch 7 -> 8\\n\\t\\t*/\\n        int count = countNodes(head);\\n        int reverseCount = count / k;\\n        ListNode node = root;\\n        while (reverseCount > 0) {\\n            node = reverse(node, k);\\n            reverseCount--;\\n        }\\n\\n        return root.next;\\n    }\\n\\n\\t/*\\n\\t* The main job is in that method. Basically what we are doing here is to reverse the LinkedList in a particular range.  \\n\\t* That method takes the handler of the current potential group and returns the new handler for the next group for a further iteration.\\n\\t* e.g if we are given head = 1 -> 2 -> 3 -> 4 -> 5 and k = 2 as I mentioned earlier I add root handler(value = -1) to the head like this: \\n\\t* root => -1 ->  | 1 -> 2 | -> 3 -> 4 -> 5. \\n\\t* So the method will take reference of -1 at first, then reverses 1 and 2 like this \\n\\t* root = -1 -> | 2 -> 1 | -> 3 -> 4 -> 5 and returns the reference of next potential group node = 1 -> | 3 -> 4 | -> 5. \\n\\t* On the second iteration the method does the same. it reverses 3 and 4 like this 1 -> | 4 -> 3 | -> 5 and \\n\\t* returns the reference of next potential group node = 3 -> | 5 . . . |\\n\\t* And this process goes again and again\\n\\t*/\\n    public ListNode reverse(ListNode node, int k) {\\n        ListNode curr = node.next;\\n        ListNode tail = null;\\n        ListNode reversed = null;\\n\\n        while (k > 0 && curr != null) {\\n            ListNode newNode = curr.next;\\n            curr.next = reversed;\\n            reversed = curr;\\n            curr = newNode;\\n            if (reversed.next == null) tail = reversed;\\n\\n            k--;\\n        }\\n\\n        tail.next = curr;\\n        node.next = reversed;\\n\\n        return tail;\\n    }\\n\\n    public int countNodes(ListNode node) {\\n        int count = 0;\\n        while (node != null) {\\n            count++;\\n            node = node.next;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11602,
                "title": "4ms-c-solution-o-n-time-and-o-1-space",
                "content": "Use a scout pointer to scan ahead. Once scout has passed k nodes, reverse this chain of k nodes just passed by scout. Initially, both first and current point to the beginning node of this chain. As each node in the chain following current is placed to the beginning of the chain, first is adjusted to always point to the beginning of the chain, while current moves down the chain (since nodes are placed before it). (k-1) nodes need to be moved during each chain reversing. The reversed chain is connected to the previous node (which always points to the one node before the just reversed chain). current (which points to the end of the chain now) is moved forward to the place of scout, count is reset to 0, and scout can now resume scanning forward. : )\\n\\n    struct ListNode* reverseKGroup(struct ListNode* head, int k) {\\n        \\n        struct ListNode *current, *previous, *scout;\\n        int count;\\n        \\n        scout = current = head;\\n        previous = NULL;\\n        count = 0;\\n    \\n        while (scout) {\\n            \\n            ++count;\\n    \\n            if (k > 1 && count == k) {\\n                \\n                scout = scout->next;\\n                struct ListNode *first, *following;\\n                first = current;\\n                \\n                while (count-- > 1) {\\n                    \\n                    following = current->next;\\n                    current->next = following->next;\\n                    following->next = first;\\n                    first = following;\\n                }\\n                \\n                if (previous)\\n                    previous->next = first;\\n                else\\n                    head = first;\\n                    \\n                previous = current;\\n                current = scout;\\n                count = 0;\\n            }\\n            else\\n                scout = scout->next;\\n        }\\n        \\n        return head;\\n    }",
                "solutionTags": [],
                "code": "Use a scout pointer to scan ahead. Once scout has passed k nodes, reverse this chain of k nodes just passed by scout. Initially, both first and current point to the beginning node of this chain. As each node in the chain following current is placed to the beginning of the chain, first is adjusted to always point to the beginning of the chain, while current moves down the chain (since nodes are placed before it). (k-1) nodes need to be moved during each chain reversing. The reversed chain is connected to the previous node (which always points to the one node before the just reversed chain). current (which points to the end of the chain now) is moved forward to the place of scout, count is reset to 0, and scout can now resume scanning forward. : )\\n\\n    struct ListNode* reverseKGroup(struct ListNode* head, int k) {\\n        \\n        struct ListNode *current, *previous, *scout;\\n        int count;\\n        \\n        scout = current = head;\\n        previous = NULL;\\n        count = 0;\\n    \\n        while (scout) {\\n            \\n            ++count;\\n    \\n            if (k > 1 && count == k) {\\n                \\n                scout = scout->next;\\n                struct ListNode *first, *following;\\n                first = current;\\n                \\n                while (count-- > 1) {\\n                    \\n                    following = current->next;\\n                    current->next = following->next;\\n                    following->next = first;\\n                    first = following;\\n                }\\n                \\n                if (previous)\\n                    previous->next = first;\\n                else\\n                    head = first;\\n                    \\n                previous = current;\\n                current = scout;\\n                count = 0;\\n            }\\n            else\\n                scout = scout->next;\\n        }\\n        \\n        return head;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2026441,
                "title": "python-simple-o-n-time-o-1-space-iterative-solution",
                "content": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        cur = head\\n        count = 0\\n        while cur:\\n            count += 1\\n            cur = cur.next\\n        \\n        pre = dummy\\n        while count >= k:\\n            cur = pre.next\\n            nex = cur.next\\n            for i in range(k-1):\\n                cur.next = nex.next\\n                nex.next = pre.next\\n                pre.next = nex\\n                nex = cur.next\\n            pre = cur\\n            count -= k\\n            \\n        return dummy.next\\n\\n# Time: O(N)\\n# Space: O(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        cur = head\\n        count = 0\\n        while cur:\\n            count += 1\\n            cur = cur.next\\n        \\n        pre = dummy\\n        while count >= k:\\n            cur = pre.next\\n            nex = cur.next\\n            for i in range(k-1):\\n                cur.next = nex.next\\n                nex.next = pre.next\\n                pre.next = nex\\n                nex = cur.next\\n            pre = cur\\n            count -= k\\n            \\n        return dummy.next\\n\\n# Time: O(N)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187652,
                "title": "javascript-2-steps-reverse-linked-list-attach",
                "content": "The first part of this problem `reverse()` can be done using pretty much the [[Easy] Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/) algorithm. But instead of reversing it all, this time we\\'re just interested in K length, so `reverse(head, length)`.\\n\\nThe second part of this problem consists in iterating (making sure K group can be done) and attaching the reversed parts.\\n\\n`[reversedPart] + [reversedPart] + ...`\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nvar reverseKGroup = function(head, k) {\\n    const root = new ListNode();\\n    root.next = head;\\n    \\n    let prev = root; // prev.next --> start of group\\n    let i = 0;\\n    while (i < k && head) { // head --> start of next group\\n        head = head.next;\\n        i += 1;\\n        if (i === k) {\\n            const [reversedHead, reversedTail] = reverse(prev.next, k);\\n            prev.next = reversedHead;\\n            reversedTail.next = head;\\n            prev = reversedTail;\\n            i = 0;\\n        }\\n    }\\n    \\n    return root.next;\\n};\\n\\nfunction reverse(head, length) {\\n    const tail = head;\\n    let prev = null;\\n    while (length > 0) {\\n        const next = head.next;\\n        head.next = prev;\\n        prev = head;\\n        head = next;\\n        length -= 1;\\n    }\\n    return [prev, tail];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nvar reverseKGroup = function(head, k) {\\n    const root = new ListNode();\\n    root.next = head;\\n    \\n    let prev = root; // prev.next --> start of group\\n    let i = 0;\\n    while (i < k && head) { // head --> start of next group\\n        head = head.next;\\n        i += 1;\\n        if (i === k) {\\n            const [reversedHead, reversedTail] = reverse(prev.next, k);\\n            prev.next = reversedHead;\\n            reversedTail.next = head;\\n            prev = reversedTail;\\n            i = 0;\\n        }\\n    }\\n    \\n    return root.next;\\n};\\n\\nfunction reverse(head, length) {\\n    const tail = head;\\n    let prev = null;\\n    while (length > 0) {\\n        const next = head.next;\\n        head.next = prev;\\n        prev = head;\\n        head = next;\\n        length -= 1;\\n    }\\n    return [prev, tail];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3330501,
                "title": "c-recursive-easy-to-understand-short-sweet-code",
                "content": "````\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int x = k;\\n        ListNode* p = head;\\n        while(x>0&&p){\\n            p = p->next;\\n            x--;\\n        }\\n        if(x==0){\\n            ListNode* pre = NULL,*next = NULL,*curr = head;\\n            while(curr != p){\\n                next = curr->next;\\n                curr->next = pre;\\n                pre = curr;\\n                curr = next;\\n            }\\n            head->next = reverseKGroup(p,k);\\n            return head = pre;\\n        }else{\\n            return head;\\n        }\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int x = k;\\n        ListNode* p = head;\\n        while(x>0&&p){\\n            p = p->next;\\n            x--;\\n        }\\n        if(x==0){\\n            ListNode* pre = NULL,*next = NULL,*curr = head;\\n            while(curr != p){\\n                next = curr->next;\\n                curr->next = pre;\\n                pre = curr;\\n                curr = next;\\n            }\\n            head->next = reverseKGroup(p,k);\\n            return head = pre;\\n        }else{\\n            return head;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083185,
                "title": "c-iterative-with-comments-and-images-readable-code",
                "content": "\\n![image](https://assets.leetcode.com/users/images/419ed926-0459-4594-a19f-451d5b313576_1653739309.9063733.jpeg)\\n![image](https://assets.leetcode.com/users/images/7fab7e72-8191-4dc5-87f5-810742bf1b63_1653739324.674521.jpeg)\\n![image](https://assets.leetcode.com/users/images/4f618fa2-25f3-4257-a778-8781a8fea0ba_1653739334.9270487.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthofll(ListNode* head){\\n        int cnt=0;\\n        while(head != nullptr){\\n            cnt++;\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || !head->next || k == 1) return head; \\n        int n = lengthofll(head);\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* pre = dummy;\\n        ListNode* curr;\\n        ListNode* nex;\\n        while(n >= k){\\n            curr = pre->next;\\n            nex = curr->next;\\n            for(int i=1;i < k;i++){\\n                curr->next = nex->next;\\n                nex->next = pre->next;\\n                pre->next = nex;\\n                nex = curr->next;\\n            }\\n            pre = curr;\\n            n = n-k;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthofll(ListNode* head){\\n        int cnt=0;\\n        while(head != nullptr){\\n            cnt++;\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || !head->next || k == 1) return head; \\n        int n = lengthofll(head);\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* pre = dummy;\\n        ListNode* curr;\\n        ListNode* nex;\\n        while(n >= k){\\n            curr = pre->next;\\n            nex = curr->next;\\n            for(int i=1;i < k;i++){\\n                curr->next = nex->next;\\n                nex->next = pre->next;\\n                pre->next = nex;\\n                nex = curr->next;\\n            }\\n            pre = curr;\\n            n = n-k;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745897,
                "title": "easy-12-line-solution",
                "content": "**Please upvote if you find it helpfull\\uD83D\\uDE4F**\\n```\\n public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode cur = head, temp = head, prev=null;\\n        for(int i=0;i<k;i++,  temp=temp.next){\\n            //temp=temp.next; \\n            if(temp==null)\\n                return head;   \\n        }\\n        for(int i=0;i<k;i++){\\n            temp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = temp;\\n        }\\n        head.next = reverseKGroup(cur, k);\\n        return prev;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode cur = head, temp = head, prev=null;\\n        for(int i=0;i<k;i++,  temp=temp.next){\\n            //temp=temp.next; \\n            if(temp==null)\\n                return head;   \\n        }\\n        for(int i=0;i<k;i++){\\n            temp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = temp;\\n        }\\n        head.next = reverseKGroup(cur, k);\\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1508396,
                "title": "javascript-o-n-easy-solution-with-stack",
                "content": "```\\nvar reverseKGroup = function(head, k) {\\n    let stack = [];\\n    let newNode = new ListNode(-1);\\n    let temp = newNode;\\n    \\n    while(head) {\\n        for(let i = 0; i < k && head; i++) {\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        \\n        if(stack.length === k) {\\n            while(stack.length > 0) {\\n                temp.next = stack.pop();\\n                temp = temp.next;\\n            }\\n            temp.next = head;\\n        }\\n    }\\n    return newNode.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar reverseKGroup = function(head, k) {\\n    let stack = [];\\n    let newNode = new ListNode(-1);\\n    let temp = newNode;\\n    \\n    while(head) {\\n        for(let i = 0; i < k && head; i++) {\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        \\n        if(stack.length === k) {\\n            while(stack.length > 0) {\\n                temp.next = stack.pop();\\n                temp = temp.next;\\n            }\\n            temp.next = head;\\n        }\\n    }\\n    return newNode.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113903,
                "title": "java-simple-and-easy-solution-0-ms-faster-than-100-00-space-o-1-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode mainCurr = head;\\n        \\n\\t\\t/*\\n            Intuition \\n            a. if K or more nodes available in given list\\n                 1. reverse first k node,\\n                 2. remove from the main list\\n                 3. append in the new list\\n                 4. move main pointer to next group first node\\n\\n            b. if NOT available \\n                 1. just append the Remaining nodes in new list\\n        \\n        */\\n            \\n        \\n        \\n        //dummy nodes, places holder of head \\n        //reverse linked list\\n        ListNode dummyNode = new ListNode();\\n        ListNode newCurr = dummyNode;\\n        \\n        while(mainCurr != null){\\n            ListNode curr = mainCurr;\\n            \\n            //get next group first node\\n            int i = k;\\n            int availableNode = 0;\\n            while(i --> 0 && curr != null){\\n                curr = curr.next;\\n                availableNode++;\\n            }\\n            ListNode nextGroupFirstNode = curr;\\n            \\n            //if Available node is K, then reverse and add in newNode list\\n            //otherwise just append remaining node\\n            if(availableNode == k){\\n                newCurr.next = getReverseFirstKNodes(mainCurr, k);\\n                newCurr = mainCurr;\\n            }else{\\n                newCurr.next = mainCurr;\\n            }\\n            \\n            //move to next group\\n            mainCurr = nextGroupFirstNode;\\n        }\\n        \\n        return dummyNode.next;\\n    }\\n    \\n\\n    //reverse K first node, and \\n    //return the head of K node list\\n    private ListNode getReverseFirstKNodes(ListNode node, int k){\\n        ListNode prev = null;\\n        ListNode curr = node;\\n        \\n        while(curr != null && k --> 0){\\n            ListNode next = curr.next;\\n            \\n            curr.next = prev;\\n            prev = curr;\\n            \\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode mainCurr = head;\\n        \\n\\t\\t/*\\n            Intuition \\n            a. if K or more nodes available in given list\\n                 1. reverse first k node,\\n                 2. remove from the main list\\n                 3. append in the new list\\n                 4. move main pointer to next group first node\\n\\n            b. if NOT available \\n                 1. just append the Remaining nodes in new list\\n        \\n        */\\n            \\n        \\n        \\n        //dummy nodes, places holder of head \\n        //reverse linked list\\n        ListNode dummyNode = new ListNode();\\n        ListNode newCurr = dummyNode;\\n        \\n        while(mainCurr != null){\\n            ListNode curr = mainCurr;\\n            \\n            //get next group first node\\n            int i = k;\\n            int availableNode = 0;\\n            while(i --> 0 && curr != null){\\n                curr = curr.next;\\n                availableNode++;\\n            }\\n            ListNode nextGroupFirstNode = curr;\\n            \\n            //if Available node is K, then reverse and add in newNode list\\n            //otherwise just append remaining node\\n            if(availableNode == k){\\n                newCurr.next = getReverseFirstKNodes(mainCurr, k);\\n                newCurr = mainCurr;\\n            }else{\\n                newCurr.next = mainCurr;\\n            }\\n            \\n            //move to next group\\n            mainCurr = nextGroupFirstNode;\\n        }\\n        \\n        return dummyNode.next;\\n    }\\n    \\n\\n    //reverse K first node, and \\n    //return the head of K node list\\n    private ListNode getReverseFirstKNodes(ListNode node, int k){\\n        ListNode prev = null;\\n        ListNode curr = node;\\n        \\n        while(curr != null && k --> 0){\\n            ListNode next = curr.next;\\n            \\n            curr.next = prev;\\n            prev = curr;\\n            \\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515740,
                "title": "easy-to-understand-python-solution-with-comments-52ms-o-1-space",
                "content": "The basic idea is rearranging the nodes in a new list. I use `p` to iterate through the original list, while putting all the nodes behind a new starting node `r`, and `e` is used to store the end of the previous group, where new nodes of the next group will be inserted.\\n```python\\ndef reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n    p = head\\n    e = r = ListNode(None)\\n\\n\\t# find out the length of the list\\n    n = 0\\n    while head:\\n        head = head.next\\n        n += 1\\n\\n\\t# rearrange the nodes\\n    for i in range(n // k):    # for every group\\n        s = p                  # record the first node of a group that will soon become the last node of the reversed group\\n        for _ in range(k):     # for every node in a group\\n            t = p.next\\n            p.next = e.next    # put the current node right before the head of the reversed group\\n            e.next = p         # register p as the head of the reversed group\\n            p = t              # visit the next node in the original list\\n        e = s                  # update the end of the reversed group\\n    e.next = p                 # append the tail to the end\\n    return r.next\\n```\\nVote up if find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\ndef reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n    p = head\\n    e = r = ListNode(None)\\n\\n\\t# find out the length of the list\\n    n = 0\\n    while head:\\n        head = head.next\\n        n += 1\\n\\n\\t# rearrange the nodes\\n    for i in range(n // k):    # for every group\\n        s = p                  # record the first node of a group that will soon become the last node of the reversed group\\n        for _ in range(k):     # for every node in a group\\n            t = p.next\\n            p.next = e.next    # put the current node right before the head of the reversed group\\n            e.next = p         # register p as the head of the reversed group\\n            p = t              # visit the next node in the original list\\n        e = s                  # update the end of the reversed group\\n    e.next = p                 # append the tail to the end\\n    return r.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 11486,
                "title": "beautiful-javascript-code",
                "content": "```\\nfunction reverseKGroup(head, k) {\\n    const stack = [], preHead = new ListNode();\\n    preHead.next = head;\\n    let lastTail = preHead;\\n    while (head) {\\n        for (let i = 0; i < k && head; i++) {\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        if (stack.length === k) {\\n            while (stack.length > 0) {\\n                lastTail.next = stack.pop();\\n                lastTail = lastTail.next;\\n            }\\n            lastTail.next = head;\\n        }\\n    }\\n\\n    return preHead.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction reverseKGroup(head, k) {\\n    const stack = [], preHead = new ListNode();\\n    preHead.next = head;\\n    let lastTail = preHead;\\n    while (head) {\\n        for (let i = 0; i < k && head; i++) {\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        if (stack.length === k) {\\n            while (stack.length > 0) {\\n                lastTail.next = stack.pop();\\n                lastTail = lastTail.next;\\n            }\\n            lastTail.next = head;\\n        }\\n    }\\n\\n    return preHead.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3236987,
                "title": "c-recursive-easy-10-liner-unique-and-diffrent-approach",
                "content": "# Intuition\\n**Simple** and **easy Brute force** intuition(read Approach you will get to know why it is **EASY** and **SIMPLE**).\\n\\n# Approach\\n- Take a var and count if there are k nodes left in list to be reversed.\\n-  If there were no k nodes left So  we will return the normal list without reversing according to the question.\\n- If at least K nodes Left it means k nodes should be reversed So the normal Recursive reversing process(rest of the code) will be executed.\\n- We will reverse the list till next k nodes.\\n- We will have to attach next upcoming list to our current reversed list so we will get to the tail of current reversed list and attach it to the recursively reversed rest of  the list(you will unterstand it properly when u see the code).\\n- \\n\\n\\n# Complexity\\n- Time complexity: **O(N)**\\n   - Traversing to N nodes that\\'s why N Time Complexity.\\n\\n- Space complexity: **Recursion Stack**\\n\\n\\n# Code\\n### swipe up a bit for clean code without comments\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* curr, int k) {\\n        int t=0;\\n        ListNode* prev=nullptr, *check=curr;\\n        while(t<k && check!=nullptr) check=check->next,t++;   //checking if there are k nodes left to be reversed (using loop)\\n        if(t<k) return curr;  // if there are less than k nodes we need not reverse so return the normal List\\n        while(t-- && curr!=nullptr){   // reversing loop\\n            ListNode* next= curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        ListNode* tail=prev;  //iterating till tail of the current reversed List\\n        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;  //  so that we can attach it to  recursively reversed upcomming List\\n        tail->next = curr ? reverseKGroup(curr,k) : nullptr;  //attacing the next upcomming reverse list the current reversed List\\n        return prev;\\n    }\\n};\\n```\\n# C++ Solution\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* curr, int k) {\\n        int t=0;\\n        ListNode* prev=nullptr, *check=curr;\\n        while(t<k && check!=nullptr) check=check->next,t++;\\n        if(t<k) return curr;\\n        while(t-- && curr!=nullptr){\\n            ListNode* next= curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        ListNode* tail=prev;\\n        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;\\n        tail->next = curr ? reverseKGroup(curr,k) : nullptr;\\n        return prev;\\n    }\\n};\\n```\\n## Thanks for the Upvote \\uD83D\\uDE07",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* curr, int k) {\\n        int t=0;\\n        ListNode* prev=nullptr, *check=curr;\\n        while(t<k && check!=nullptr) check=check->next,t++;   //checking if there are k nodes left to be reversed (using loop)\\n        if(t<k) return curr;  // if there are less than k nodes we need not reverse so return the normal List\\n        while(t-- && curr!=nullptr){   // reversing loop\\n            ListNode* next= curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        ListNode* tail=prev;  //iterating till tail of the current reversed List\\n        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;  //  so that we can attach it to  recursively reversed upcomming List\\n        tail->next = curr ? reverseKGroup(curr,k) : nullptr;  //attacing the next upcomming reverse list the current reversed List\\n        return prev;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* curr, int k) {\\n        int t=0;\\n        ListNode* prev=nullptr, *check=curr;\\n        while(t<k && check!=nullptr) check=check->next,t++;\\n        if(t<k) return curr;\\n        while(t-- && curr!=nullptr){\\n            ListNode* next= curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        ListNode* tail=prev;\\n        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;\\n        tail->next = curr ? reverseKGroup(curr,k) : nullptr;\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789332,
                "title": "easy-c-recursive-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* curr = head;\\n        ListNode* nodenext=NULL;\\n        ListNode* prevnode = NULL;\\n        int count=0;\\n        while(curr!=NULL && count<k){\\n            nodenext = curr->next;\\n            curr->next = prevnode;\\n            prevnode = curr;\\n            curr = nodenext;\\n            count++;\\n        }\\n        if(count!=k){\\n            ListNode* t = prevnode;\\n            prevnode = NULL;\\n            while(t!=NULL){\\n                nodenext = t->next;\\n                t->next = prevnode;\\n                prevnode = t;\\n                t = nodenext;\\n            }\\n            return prevnode;\\n        }\\n        if(nodenext!=NULL){\\n            ListNode* rest_head = reverseKGroup(nodenext , k);\\n            head->next = rest_head;\\n        }\\n        return prevnode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* curr = head;\\n        ListNode* nodenext=NULL;\\n        ListNode* prevnode = NULL;\\n        int count=0;\\n        while(curr!=NULL && count<k){\\n            nodenext = curr->next;\\n            curr->next = prevnode;\\n            prevnode = curr;\\n            curr = nodenext;\\n            count++;\\n        }\\n        if(count!=k){\\n            ListNode* t = prevnode;\\n            prevnode = NULL;\\n            while(t!=NULL){\\n                nodenext = t->next;\\n                t->next = prevnode;\\n                prevnode = t;\\n                t = nodenext;\\n            }\\n            return prevnode;\\n        }\\n        if(nodenext!=NULL){\\n            ListNode* rest_head = reverseKGroup(nodenext , k);\\n            head->next = rest_head;\\n        }\\n        return prevnode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188167,
                "title": "c-recursive-solution-12ms-only-13-line-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n  ListNode *reverseKGroup(ListNode *head, int k) {\\n    ListNode *post = head; // indicate the latest one to be connected\\n    for (int i = 0; i < k; i++) {\\n      if (!post) return head;\\n      post = post->next;\\n    }\\n    ListNode *last = head; // current the head, but the last of a group after reversion\\n    for (int i = 0; i < k; i++) {\\n      ListNode *temp = head->next;\\n      head->next = post;\\n      post = head;\\n      head = temp;\\n    }\\n    last->next = reverseKGroup(last->next, k);\\n    return post;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  ListNode *reverseKGroup(ListNode *head, int k) {\\n    ListNode *post = head; // indicate the latest one to be connected\\n    for (int i = 0; i < k; i++) {\\n      if (!post) return head;\\n      post = post->next;\\n    }\\n    ListNode *last = head; // current the head, but the last of a group after reversion\\n    for (int i = 0; i < k; i++) {\\n      ListNode *temp = head->next;\\n      head->next = post;\\n      post = head;\\n      head = temp;\\n    }\\n    last->next = reverseKGroup(last->next, k);\\n    return post;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11498,
                "title": "10-lines-short-easy-java-code-with-comments",
                "content": "    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode cur = head, tmp = head, prev = null;\\n        for(int i = 0 ; i < k; i++, tmp = tmp.next) if(tmp == null) return head;  // check if there is enough k elements for reverse in current group\\n        for(int i = 0; i < k; i++){ // reverse k elements in current group\\n            tmp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        head.next = reverseKGroup(cur, k); // connect the real tail of current reversed group with the real head of remaining reversed group\\n        return prev; // return the real tail of current reversed group\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode cur = head, tmp = head, prev = null;\\n        for(int i = 0 ; i < k; i++, tmp = tmp.next) if(tmp == null) return head;  // check if there is enough k elements for reverse in current group\\n        for(int i = 0; i < k; i++){ // reverse k elements in current group\\n            tmp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        head.next = reverseKGroup(cur, k); // connect the real tail of current reversed group with the real head of remaining reversed group\\n        return prev; // return the real tail of current reversed group\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3181828,
                "title": "tc-o-n-sc-o-n-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n    if(head==NULL)\\n        return NULL;\\n    \\n    //reverse 1st k nodes\\n    ListNode* forward=NULL;\\n    ListNode* prev=NULL;\\n    ListNode* curr=head;\\n    int cnt=0;\\n    \\n    ListNode* cursor = head;\\n    for(int i = 0; i < k; i++){\\n         if(cursor == nullptr) \\n             return head;\\n         cursor = cursor->next;\\n    }\\n    while(curr!=NULL && cnt<k ){\\n        forward=curr->next;\\n        curr->next=prev;\\n        prev=curr;\\n        curr=forward;\\n        cnt++;\\n    }\\n    \\n    head->next=reverseKGroup(forward,k);\\n    return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n    if(head==NULL)\\n        return NULL;\\n    \\n    //reverse 1st k nodes\\n    ListNode* forward=NULL;\\n    ListNode* prev=NULL;\\n    ListNode* curr=head;\\n    int cnt=0;\\n    \\n    ListNode* cursor = head;\\n    for(int i = 0; i < k; i++){\\n         if(cursor == nullptr) \\n             return head;\\n         cursor = cursor->next;\\n    }\\n    while(curr!=NULL && cnt<k ){\\n        forward=curr->next;\\n        curr->next=prev;\\n        prev=curr;\\n        curr=forward;\\n        cnt++;\\n    }\\n    \\n    head->next=reverseKGroup(forward,k);\\n    return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714698,
                "title": "c-solution-using-recursion-easy-0ms",
                "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n \\n //please UPVOTE\\nclass Solution {\\npublic:\\n    int getllsize(ListNode* head){\\n        ListNode* temp=head;\\n        int c=0;\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            c++;\\n        }\\n        return c;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int n =getllsize(head);\\n        if(head==NULL || n < k)return head;\\n     ListNode *prev=NULL;\\n      ListNode *curr=head;\\n      ListNode *forw=NULL;\\n    int c=0;\\n    while(curr!=NULL && c!=k ){\\n      forw = curr -> next;\\n            curr -> next=prev;\\n            prev=curr;\\n            curr=forw;\\n        c++;\\n    }\\n    head->next=reverseKGroup(curr,k);\\n    \\n    \\n    \\n    return prev;\\n    }\\n\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int getllsize(ListNode* head){\\n        ListNode* temp=head;\\n        int c=0;\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2245982,
                "title": "iterative-time-complexity-space-complexity-explanation",
                "content": "Time Complexity - Iterating over all the nodes once takes O(N) time.\\nSpace Complexity - Since we are not using any extra space, space complexity is O(1).\\nExplanation -\\nA dummy node is created which points to the initial head of the LL.\\nWe create currNode, nextNode and prevNode - all of which are point to the same address as dummy.\\nThen we calculate the length of the LL and store it in a variable called count.\\n\\nWe have a WHILE LOOP running while count >= k.\\nAt the start of every group of k size, we need to have currNode set as the 1st node and nextNode as the second node.\\nThen we run a FOR LOOP k times in order to reverse the links for the group of size k  (links of k - 1 nodes are reversed as the first node does not need reversal).\\nWhen the for loop ends - prevNode is a pointer to the last node in the group of size k, currNode->next stores the address which helps us travel to the next set of nodes.\\nWe now change prevNode to point to currNode - because it is necessary to store the address that will help us travel to next set of nodes.\\nThus, upon the next iteration of the while loop, we can use prevNode->next to set new values of currNode and nextNode.\\n\\nAt the end of the while loop, we return our new head node which is pointed to by dummy->next.\\nHOW? Initially prevNode and dummy are pointing to the same address, hence any change makes to prevNode reflects in dummy. \\nBut after reversing the first group of size k, prevNode points to a completely different address and hence dummy->next manages to save the address of the new head node.\\n\\n```\\n\\tclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || k == 1) return head;\\n        ListNode *dummy = new ListNode(0, head); // Dummy node with value 0 pointing to the initial head of the given LL\\n        ListNode *currNode = dummy, *nextNode = dummy, *prevNode = dummy;\\n        \\n        // Calculate length of LL\\n        int count = -1; // The initial value of count is taken as -1 because the dummy node shouldn\\'t be counted\\n        while(currNode){\\n            count++;\\n            currNode = currNode->next;\\n        }\\n        \\n        // Iterating till we have groups of size >= k\\n        while(count >= k){\\n            // For every group of size k, we need to make sure that currNode is 1st node and nextNode is 2nd node\\n            currNode = prevNode->next; // prevNode is the previous node of the previous group and points to the first node of the new group\\n            nextNode = currNode->next;\\n            \\n            // Reverse k - 1 nodes\\n            for(int i = 1; i < k; i++){\\n                currNode->next = nextNode->next; // currNode keeps track of where we can shift nextNode after a single reversal\\n                nextNode->next = prevNode->next; // Reversing the link\\n                prevNode->next = nextNode; // prevNode->next stores the address where we can shift currNode (current nextNode is going to be our next currNode)\\n                nextNode = currNode->next; // currNode->next indicates the new address of nextNode (nextNode->next cannot be used as it has been reversed)\\n            }\\n            prevNode = currNode; // prevNode should stand at the last node of the previous reversed group of size k\\n            count -= k; // Reversal has been successful for k nodes, so we reduce k from count\\n        }\\n        return dummy->next; // dummy->next points to the last node of the first reversed group of size k\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || k == 1) return head;\\n        ListNode *dummy = new ListNode(0, head); // Dummy node with value 0 pointing to the initial head of the given LL\\n        ListNode *currNode = dummy, *nextNode = dummy, *prevNode = dummy;\\n        \\n        // Calculate length of LL\\n        int count = -1; // The initial value of count is taken as -1 because the dummy node shouldn\\'t be counted\\n        while(currNode){\\n            count++;\\n            currNode = currNode->next;\\n        }\\n        \\n        // Iterating till we have groups of size >= k\\n        while(count >= k){\\n            // For every group of size k, we need to make sure that currNode is 1st node and nextNode is 2nd node\\n            currNode = prevNode->next; // prevNode is the previous node of the previous group and points to the first node of the new group\\n            nextNode = currNode->next;\\n            \\n            // Reverse k - 1 nodes\\n            for(int i = 1; i < k; i++){\\n                currNode->next = nextNode->next; // currNode keeps track of where we can shift nextNode after a single reversal\\n                nextNode->next = prevNode->next; // Reversing the link\\n                prevNode->next = nextNode; // prevNode->next stores the address where we can shift currNode (current nextNode is going to be our next currNode)\\n                nextNode = currNode->next; // currNode->next indicates the new address of nextNode (nextNode->next cannot be used as it has been reversed)\\n            }\\n            prevNode = currNode; // prevNode should stand at the last node of the previous reversed group of size k\\n            count -= k; // Reversal has been successful for k nodes, so we reduce k from count\\n        }\\n        return dummy->next; // dummy->next points to the last node of the first reversed group of size k\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054341,
                "title": "easy-recursion-understanding-ii-c",
                "content": "We will use the intuition behind Reverse Linked List.Only difference is we will reverse Nodes in K group. So we will seggregate the Linked List into size K and let recursion handle the rest.\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //base condition\\n        //to not reverse the last group which is less than k\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(temp==nullptr)\\n                return head;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        //reverse first k nodes\\n        ListNode* prev=nullptr;\\n        ListNode* curr=head;\\n        ListNode* next=nullptr;\\n        int count=0;\\n        \\n        while(curr && count<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            count++;\\n        }\\n        \\n        //recursion will take care the rest\\n        if(next){\\n            head->next = reverseKGroup(next,k);\\n        }\\n        \\n        //return head of reversed list i.e., prev\\n        return prev;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE** *if you liked the approach*",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //base condition\\n        //to not reverse the last group which is less than k\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(temp==nullptr)\\n                return head;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        //reverse first k nodes\\n        ListNode* prev=nullptr;\\n        ListNode* curr=head;\\n        ListNode* next=nullptr;\\n        int count=0;\\n        \\n        while(curr && count<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            count++;\\n        }\\n        \\n        //recursion will take care the rest\\n        if(next){\\n            head->next = reverseKGroup(next,k);\\n        }\\n        \\n        //return head of reversed list i.e., prev\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621752,
                "title": "13-line-easy-to-understand-code-using-vectors",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        vector<int> order;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            order.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        for(int index = 0 ; index+ k <= order.size() ; index += k)\\n            reverse(order.begin() + index , order.begin() + index + k);\\n        \\n        int index = 0;\\n        temp = head;\\n        \\n        while(temp != NULL){\\n            temp->val = order[index++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        vector<int> order;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            order.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        for(int index = 0 ; index+ k <= order.size() ; index += k)\\n            reverse(order.begin() + index , order.begin() + index + k);\\n        \\n        int index = 0;\\n        temp = head;\\n        \\n        while(temp != NULL){\\n            temp->val = order[index++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346680,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n```\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n\\tnode, cnt := head, 0\\n\\tfor cnt < k {\\n\\t\\tif node == nil {\\n\\t\\t\\treturn head\\n\\t\\t}\\n\\t\\tnode = node.Next\\n\\t\\tcnt++\\n\\t}\\n\\n\\tprev := reverseKGroup(node, k)\\n\\tfor cnt > 0 {\\n\\t\\tnext := head.Next\\n\\t\\thead.Next = prev\\n\\t\\tprev = head\\n\\t\\thead = next\\n\\t\\tcnt--\\n\\t}\\n\\n\\treturn prev\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n\\tnode, cnt := head, 0\\n\\tfor cnt < k {\\n\\t\\tif node == nil {\\n\\t\\t\\treturn head\\n\\t\\t}\\n\\t\\tnode = node.Next\\n\\t\\tcnt++\\n\\t}\\n\\n\\tprev := reverseKGroup(node, k)\\n\\tfor cnt > 0 {\\n\\t\\tnext := head.Next\\n\\t\\thead.Next = prev\\n\\t\\tprev = head\\n\\t\\thead = next\\n\\t\\tcnt--\\n\\t}\\n\\n\\treturn prev\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11606,
                "title": "java-recursive-and-iterative-solutions",
                "content": "       \\n     // recursively \\n    public ListNode reverseKGroup1(ListNode head, int k) {\\n        int l = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            l++;\\n            cur = cur.next;\\n        }\\n        if (k > l) {\\n            return head;\\n        }\\n        cur = head;\\n        ListNode node = null;\\n        for (int i = 0; i < k; i++) {\\n            ListNode nxt = cur.next;\\n            cur.next = node;\\n            node = cur;\\n            cur = nxt;\\n        }\\n        head.next = reverseKGroup(cur, k);\\n        return node;\\n    }\\n    \\n    // iteratively\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int l = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            l++;\\n            cur = cur.next;\\n        }\\n        if (l < k) {\\n            return head;\\n        }\\n        int n = l/k;\\n        ListNode pre = new ListNode(0), node, rem, ret = pre;\\n        for (int i = 0; i < n; i++) {\\n            node = null;\\n            rem = head;\\n            for (int j = 0; j < k; j++) {\\n                ListNode nxt = head.next;\\n                head.next = node;\\n                node = head;\\n                head = nxt;\\n            }\\n            pre.next = node;\\n            rem.next = head;\\n            pre = rem;\\n        }\\n        return ret.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "       \\n     // recursively \\n    public ListNode reverseKGroup1(ListNode head, int k) {\\n        int l = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            l++;\\n            cur = cur.next;\\n        }\\n        if (k > l) {\\n            return head;\\n        }\\n        cur = head;\\n        ListNode node = null;\\n        for (int i = 0; i < k; i++) {\\n            ListNode nxt = cur.next;\\n            cur.next = node;\\n            node = cur;\\n            cur = nxt;\\n        }\\n        head.next = reverseKGroup(cur, k);\\n        return node;\\n    }\\n    \\n    // iteratively\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int l = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            l++;\\n            cur = cur.next;\\n        }\\n        if (l < k) {\\n            return head;\\n        }\\n        int n = l/k;\\n        ListNode pre = new ListNode(0), node, rem, ret = pre;\\n        for (int i = 0; i < n; i++) {\\n            node = null;\\n            rem = head;\\n            for (int j = 0; j < k; j++) {\\n                ListNode nxt = head.next;\\n                head.next = node;\\n                node = head;\\n                head = nxt;\\n            }\\n            pre.next = node;\\n            rem.next = head;\\n            pre = rem;\\n        }\\n        return ret.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2204168,
                "title": "python-solution-space-o-1-time-o-n-faster-iterative-easy-solution-with-comments",
                "content": "**If You like the Solution , Please Upvote **\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        # Base case\\n        if k==1:\\n            return  head\\n        # find lenght of linked list\\n        lenght = 0\\n        curr = head\\n        while curr:\\n            curr = curr.next\\n            lenght+=1\\n            \\n        groups = lenght//k # no. of groups, we want to reverse\\n        ans = ListNode(-1) #dummy node : next of this node point head of requried linked list\\n        last = ans # pointer last : point the last node of each reversed group of  k\\n\\n        while groups:\\n            count = 1 #count the size of reversed group\\n            st = head # start node of group which will be last node after reverse the group \\n            pre , curr , nxt = None, head , head.next #reverse the group by taking three pointers\\n            while count<k:\\n                curr.next = pre\\n                pre , curr , nxt = curr , nxt  , nxt.next # move each pointer to next node\\n                count+=1\\n                \\n            curr.next = pre\\n            # curr point the start node of reversed group \\n            last.next = curr # asign last node->next of previous reversed group to start node of this reversed group \\n            last = st # asign last pointer to end node of currently reveresed group       \\n            head = nxt\\n            last.next = head # take care if last group have size less than k\\n            groups -=1 # reduce the count of unreversed groups\\n            \\n        return ans.next # return head of required linked list   \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "**If You like the Solution , Please Upvote **\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        # Base case\\n        if k==1:\\n            return  head\\n        # find lenght of linked list\\n        lenght = 0\\n        curr = head\\n        while curr:\\n            curr = curr.next\\n            lenght+=1\\n            \\n        groups = lenght//k # no. of groups, we want to reverse\\n        ans = ListNode(-1) #dummy node : next of this node point head of requried linked list\\n        last = ans # pointer last : point the last node of each reversed group of  k\\n\\n        while groups:\\n            count = 1 #count the size of reversed group\\n            st = head # start node of group which will be last node after reverse the group \\n            pre , curr , nxt = None, head , head.next #reverse the group by taking three pointers\\n            while count<k:\\n                curr.next = pre\\n                pre , curr , nxt = curr , nxt  , nxt.next # move each pointer to next node\\n                count+=1\\n                \\n            curr.next = pre\\n            # curr point the start node of reversed group \\n            last.next = curr # asign last node->next of previous reversed group to start node of this reversed group \\n            last = st # asign last pointer to end node of currently reveresed group       \\n            head = nxt\\n            last.next = head # take care if last group have size less than k\\n            groups -=1 # reduce the count of unreversed groups\\n            \\n        return ans.next # return head of required linked list   \\n",
                "codeTag": "Java"
            },
            {
                "id": 1598365,
                "title": "iterative-solution-100-faster-in-java",
                "content": "```\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n        if(head.next == null){\\n            return head;\\n        }\\n        int size = 0;\\n# \\t\\tCalculating size so that we have to only reverse size/k times. For example - 1->2->3->4>-5 and k = 2, we will reverse in groups. First 1->2 and then 3->4 and we do not have to reach till the end of the list.;\\n        ListNode temp = head;\\n        while(temp != null){\\n            size++;\\n            temp = temp.next;\\n        }\\n\\t\\n        temp = head;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode p = dummy;\\n        ListNode prev = dummy;\\n        for(int j = 0; j < size / k; j++){\\n            ListNode last = temp;\\n# \\t\\t\\tReverse k items in the list\\n            for(int i = 0; i < k; i++){\\n                ListNode node = temp.next;\\n                temp.next = prev;\\n                prev = temp;\\n                temp = node;\\n            }\\n# \\t\\t\\tConnect the list\\n            p.next = prev;\\n            last.next = temp;\\n            p = last;\\n            prev = last;\\n# \\t\\t\\tAfter 1 loop -  the list will look like this dummy->2->1->3->4->5->null\\n# \\t\\t\\tp = 1, prev = 2, temp = 3\\n\\t\\t\\t\\n# \\t\\t\\tAfter 2 loop - dummy->2->1->4->3->5->null\\n# \\t\\t\\tRepeat this process size/k times until the list looks like this \\n# \\t\\t\\tSince the outer loop will run size/k times this will be the required output\\n        }\\n        \\n        return dummy.next;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n        if(head.next == null){\\n            return head;\\n        }\\n        int size = 0;\\n# \\t\\tCalculating size so that we have to only reverse size/k times. For example - 1->2->3->4>-5 and k = 2, we will reverse in groups. First 1->2 and then 3->4 and we do not have to reach till the end of the list.;\\n        ListNode temp = head;\\n        while(temp != null){\\n            size++;\\n            temp = temp.next;\\n        }\\n\\t\\n        temp = head;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode p = dummy;\\n        ListNode prev = dummy;\\n        for(int j = 0; j < size / k; j++){\\n            ListNode last = temp;\\n# \\t\\t\\tReverse k items in the list\\n            for(int i = 0; i < k; i++){\\n                ListNode node = temp.next;\\n                temp.next = prev;\\n                prev = temp;\\n                temp = node;\\n            }\\n# \\t\\t\\tConnect the list\\n            p.next = prev;\\n            last.next = temp;\\n            p = last;\\n            prev = last;\\n# \\t\\t\\tAfter 1 loop -  the list will look like this dummy->2->1->3->4->5->null\\n# \\t\\t\\tp = 1, prev = 2, temp = 3\\n\\t\\t\\t\\n# \\t\\t\\tAfter 2 loop - dummy->2->1->4->3->5->null\\n# \\t\\t\\tRepeat this process size/k times until the list looks like this \\n# \\t\\t\\tSince the outer loop will run size/k times this will be the required output\\n        }\\n        \\n        return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1159137,
                "title": "c-recursively-get-reversed-linked-list",
                "content": "The difference between https://leetcode.com/problems/reverse-linked-list/ is we calculate each group recursively and set it as the  `start node` of the previous group\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\t// first, find the (k+1)-th node, that is the node for the next group\\n\\t\\t// if the nodes remained is smaller than k, just return\\n\\t\\n        ListNode* node = head;\\n        for(int i=0;i<k;i++) {\\n            if(!node) return head;\\n            node = node->next;\\n        }   \\n        \\n\\t\\t// Like problem in `reverse-linked-list` (https://leetcode.com/problems/reverse-linked-list/)\\n\\t\\t// Instead, compute next group first\\n        ListNode* cur = reverseKGroup(node, k);\\n        while(head != node) {\\n            ListNode* next = head->next;\\n            head->next = cur;\\n            cur = head;\\n            head = next;\\n        }\\n        return cur;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\t// first, find the (k+1)-th node, that is the node for the next group\\n\\t\\t// if the nodes remained is smaller than k, just return\\n\\t\\n        ListNode* node = head;\\n        for(int i=0;i<k;i++) {\\n            if(!node) return head;\\n            node = node->next;\\n        }   \\n        \\n\\t\\t// Like problem in `reverse-linked-list` (https://leetcode.com/problems/reverse-linked-list/)\\n\\t\\t// Instead, compute next group first\\n        ListNode* cur = reverseKGroup(node, k);\\n        while(head != node) {\\n            ListNode* next = head->next;\\n            head->next = cur;\\n            cur = head;\\n            head = next;\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096547,
                "title": "c-simple-solution",
                "content": "**Key points:**\\n* Peek k steps ahead to decide we have enough to do reverse. If not long enough, just return as is.\\n* Reverse k nodes.\\n* Do the same recursively for the remaining list.\\n```\\n  ListNode* reverseKGroup(ListNode* head, int k) {\\n    if (k <= 1)\\n      return head;\\n    \\n    ListNode * nextHead = head;\\n    for (int i=0; i<k; ++i) {\\n      if (!nextHead)\\n        return head;\\n      nextHead = nextHead->next;\\n    }\\n    \\n    ListNode * prev = head;\\n    ListNode * next = head->next;\\n    for (int i=0; i<k-1; ++i) {\\n      ListNode * tmp = next->next;\\n      next->next = prev;\\n      prev = next;\\n      next = tmp;\\n    }\\n    \\n    head->next = reverseKGroup(nextHead, k);\\n    return prev;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  ListNode* reverseKGroup(ListNode* head, int k) {\\n    if (k <= 1)\\n      return head;\\n    \\n    ListNode * nextHead = head;\\n    for (int i=0; i<k; ++i) {\\n      if (!nextHead)\\n        return head;\\n      nextHead = nextHead->next;\\n    }\\n    \\n    ListNode * prev = head;\\n    ListNode * next = head->next;\\n    for (int i=0; i<k-1; ++i) {\\n      ListNode * tmp = next->next;\\n      next->next = prev;\\n      prev = next;\\n      next = tmp;\\n    }\\n    \\n    head->next = reverseKGroup(nextHead, k);\\n    return prev;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817587,
                "title": "python-easy-solution-o-n-time-o-1-space",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseHelper(self, head, k, leftNodes):\\n        if leftNodes < k:\\n            return head\\n    \\n        count = 0\\n        prev = None\\n        current = head\\n        while current and count < k:\\n            count += 1\\n            leftNodes -= 1\\n            next = current.next\\n            current.next = prev\\n            prev = current\\n            current = next\\n\\n        if next:\\n            head.next = self.reverseHelper(next, k, leftNodes)\\n\\n        return prev\\n        \\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        leftNodes = 0\\n        node = head\\n        while node:\\n            leftNodes += 1\\n            node = node.next\\n\\n        return self.reverseHelper(head, k, leftNodes)\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseHelper(self, head, k, leftNodes):\\n        if leftNodes < k:\\n            return head\\n    \\n        count = 0\\n        prev = None\\n        current = head\\n        while current and count < k:\\n            count += 1\\n            leftNodes -= 1\\n            next = current.next\\n            current.next = prev\\n            prev = current\\n            current = next\\n\\n        if next:\\n            head.next = self.reverseHelper(next, k, leftNodes)\\n\\n        return prev\\n        \\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        leftNodes = 0\\n        node = head\\n        while node:\\n            leftNodes += 1\\n            node = node.next\\n\\n        return self.reverseHelper(head, k, leftNodes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987590,
                "title": "python-97-85-faster-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        count=0\\n        temp=head\\n        while temp:\\n            temp=temp.next\\n            count+=1\\n        n=count//k #No. of groups to be reversed\\n        prev=dummy=ListNode()\\n        dummy.next=head\\n        while n:\\n            curr=prev.next\\n            nex=curr.next\\n            for i in range(1,k): #If we have to reverse k nodes then k-1 links will be reversed\\n                curr.next=nex.next\\n                nex.next=prev.next\\n                prev.next=nex\\n                nex=curr.next\\n            prev=curr\\n            n-=1\\n        return dummy.next\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        count=0\\n        temp=head\\n        while temp:\\n            temp=temp.next\\n            count+=1\\n        n=count//k #No. of groups to be reversed\\n        prev=dummy=ListNode()\\n        dummy.next=head\\n        while n:\\n            curr=prev.next\\n            nex=curr.next\\n            for i in range(1,k): #If we have to reverse k nodes then k-1 links will be reversed\\n                curr.next=nex.next\\n                nex.next=prev.next\\n                prev.next=nex\\n                nex=curr.next\\n            prev=curr\\n            n-=1\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584694,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* head, int k) {\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        ListNode* nxt;\\n        while (k--) {\\n            nxt = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = nxt;\\n        }\\n        head->next = cur;\\n        return prev;\\n    }    \\n    int length(ListNode* head) {\\n        int len = 0;\\n        while(head != NULL) {\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        ListNode* cur = head;\\n        while (cur != NULL) {\\n            if (len >= k) {\\n                temp->next = reverse(cur, k);\\n                len -= k;\\n                temp = cur;\\n                cur = cur->next;\\n            } else {\\n                break;\\n            }\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* head, int k) {\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        ListNode* nxt;\\n        while (k--) {\\n            nxt = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = nxt;\\n        }\\n        head->next = cur;\\n        return prev;\\n    }    \\n    int length(ListNode* head) {\\n        int len = 0;\\n        while(head != NULL) {\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        ListNode* cur = head;\\n        while (cur != NULL) {\\n            if (len >= k) {\\n                temp->next = reverse(cur, k);\\n                len -= k;\\n                temp = cur;\\n                cur = cur->next;\\n            } else {\\n                break;\\n            }\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431696,
                "title": "easy-to-understand-recursive-approach-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken by this solution is as follows:\\n\\n1. Check if k group is available to reverse or not. If not, return head as it is.\\n2. If k group is available, then reverse the first k nodes.\\n3. Recursively apply the same operation on the remaining linked list starting from the k+1th node.\\n4. Return the new head, which is the last node of the first k nodes.\\n\\nThe function takes in a head node of the linked list and an integer k as arguments and returns the head of the modified linked list after reversing the nodes in k groups.\\n\\n![image.png](https://assets.leetcode.com/users/images/9deb0470-dff9-4582-96f2-0bb7ff79689a_1681834820.5916502.png)\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        if(head==NULL){\\n            return NULL;\\n        }\\n        //step1-we check that if k group is avaliable or not to reverse\\n        int avaliable= k, cnt = 0;\\n        ListNode* temp = head;\\n        while(avaliable > 0 && temp != NULL){\\n            temp = temp -> next;\\n           avaliable--;\\n        }\\n        if(avaliable==0){\\n        //step2- we reverse for first k group\\n        ListNode* next=NULL;\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        while(curr!=NULL && cnt<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev =curr;\\n            curr=next;\\n            cnt++;\\n        }\\n        //step3-we recursively take care of the remaining cases that are left out\\n        if(next!=NULL){\\n            head->next=reverseKGroup(next,k);\\n        }\\n        //step4 return prev as at last it will be the new head\\n        return prev;\\n        }\\n        //return head as the k group is not present to reverse\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        if(head==NULL){\\n            return NULL;\\n        }\\n        //step1-we check that if k group is avaliable or not to reverse\\n        int avaliable= k, cnt = 0;\\n        ListNode* temp = head;\\n        while(avaliable > 0 && temp != NULL){\\n            temp = temp -> next;\\n           avaliable--;\\n        }\\n        if(avaliable==0){\\n        //step2- we reverse for first k group\\n        ListNode* next=NULL;\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        while(curr!=NULL && cnt<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev =curr;\\n            curr=next;\\n            cnt++;\\n        }\\n        //step3-we recursively take care of the remaining cases that are left out\\n        if(next!=NULL){\\n            head->next=reverseKGroup(next,k);\\n        }\\n        //step4 return prev as at last it will be the new head\\n        return prev;\\n        }\\n        //return head as the k group is not present to reverse\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395110,
                "title": "extending-reverse-ll-approach-recursive-boom",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are asked to reverse nodes in groups. We will reverse first k nodes, then make a recursive call.\\n\\nif you dont know, how to reverse LL, go and check- https://leetcode.com/problems/reverse-linked-list/solutions/3389694/cpp-solution-iterative-recursion-o-n/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. check reverse LL, through link.\\n2. Here, we take x = k, to check if Further k nodes are present or not.\\n3. if present, then reverse the K nodes. \\n4. if not, return head bcz head is pointing to the next element , that is, forward node. EXAMPLE- 1,2,3,4,5    AND K = 3,  in this, head points to 4. and it gets attached to head->next pointer. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head == NULL)\\n        return head;\\n\\n        int x = k, count = 0;\\n        ListNode* temp = head;\\n        while(x > 0 && temp != NULL){\\n            temp = temp -> next;\\n            x--;\\n        }\\n        if(x == 0)\\n        {\\n            ListNode* forward = NULL;\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            while(count < k){\\n                forward = curr -> next;\\n                curr -> next = prev;\\n                prev = curr;\\n                curr = forward;\\n                count++:\\n            }\\n            head -> next = reverseKGroup(forward, k);\\n            return prev;\\n        }\\n        else\\n            return head; // gets attached to head->next as it points to null.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head == NULL)\\n        return head;\\n\\n        int x = k, count = 0;\\n        ListNode* temp = head;\\n        while(x > 0 && temp != NULL){\\n            temp = temp -> next;\\n            x--;\\n        }\\n        if(x == 0)\\n        {\\n            ListNode* forward = NULL;\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            while(count < k){\\n                forward = curr -> next;\\n                curr -> next = prev;\\n                prev = curr;\\n                curr = forward;\\n                count++:\\n            }\\n            head -> next = reverseKGroup(forward, k);\\n            return prev;\\n        }\\n        else\\n            return head; // gets attached to head->next as it points to null.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276880,
                "title": "easy-solution-in-c-recursive",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // Base case\\n        if (head == NULL || k == 1) {\\n            return head;\\n        }\\n\\n        //step 1: reverse first k Nodes\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int count = 0;\\n\\n        while (curr != NULL && count < k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Check if there are enough nodes to reverse\\n        if (count < k) {\\n            // Reverse back the first count nodes to maintain the original order\\n            ListNode* temp = NULL;\\n            while (count > 0) {\\n                temp = prev->next;\\n                prev->next = curr;\\n                curr = prev;\\n                prev = temp;\\n                count--;\\n            }\\n            return curr;\\n        }\\n\\n        // step 2: recursion for k groups\\n        if (next != NULL) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // step 3: return the head of reversed list\\n        return prev;\\n    }\\n};\\n\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // Base case\\n        if (head == NULL || k == 1) {\\n            return head;\\n        }\\n\\n        //step 1: reverse first k Nodes\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int count = 0;\\n\\n        while (curr != NULL && count < k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Check if there are enough nodes to reverse\\n        if (count < k) {\\n            // Reverse back the first count nodes to maintain the original order\\n            ListNode* temp = NULL;\\n            while (count > 0) {\\n                temp = prev->next;\\n                prev->next = curr;\\n                curr = prev;\\n                prev = temp;\\n                count--;\\n            }\\n            return curr;\\n        }\\n\\n        // step 2: recursion for k groups\\n        if (next != NULL) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // step 3: return the head of reversed list\\n        return prev;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138247,
                "title": "clean-understandable-java-sol-0ms-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1) return head;\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n\\n        ListNode curr = dummy,nex = dummy,pre = dummy;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr = curr.next;             // counting number of nodes.\\n            count++;\\n        }\\n\\n        while(count>=k){                 // iterate till groups of k.\\n            curr = pre.next;             // put curr at first and nex at second node of that group.\\n            nex = curr.next;           \\n            for(int i=1;i<k;i++){        //rum loop K-1 times and revrerse every link.\\n                curr.next = nex.next;\\n                nex.next = pre.next;\\n                pre.next = nex;\\n                nex = curr.next;\\n            }\\n            pre = curr;                   // to make pre stand at last node of previous reversed group of size k.\\n            count-=k;                     // decrementing count by k as the group is reversed and we move to next group of k if present.\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1) return head;\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n\\n        ListNode curr = dummy,nex = dummy,pre = dummy;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr = curr.next;             // counting number of nodes.\\n            count++;\\n        }\\n\\n        while(count>=k){                 // iterate till groups of k.\\n            curr = pre.next;             // put curr at first and nex at second node of that group.\\n            nex = curr.next;           \\n            for(int i=1;i<k;i++){        //rum loop K-1 times and revrerse every link.\\n                curr.next = nex.next;\\n                nex.next = pre.next;\\n                pre.next = nex;\\n                nex = curr.next;\\n            }\\n            pre = curr;                   // to make pre stand at last node of previous reversed group of size k.\\n            count-=k;                     // decrementing count by k as the group is reversed and we move to next group of k if present.\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694132,
                "title": "1ms-java-solution-beats-69",
                "content": "*Time Complexity - O(n)*\\nPlease upvote if it was helpful\\n\\n```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n \\n        ListNode dum = new ListNode(0);\\n        dum.next = head;\\n        ListNode pointer = dum;\\n        while (pointer != null) {\\n            ListNode node = pointer;\\n            //  check there are k nodes to reverse\\n            for (int i = 0; i < k && node != null; i++) {\\n                node = node.next;\\n            }\\n            if (node == null) break;\\n            \\n            //  we have k nodes, then start from the first node\\n            ListNode prev = null, curr = pointer.next, next = null;\\n            for (int i = 0; i < k; i++) {\\n                next = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = next;\\n            }\\n            ListNode tail = pointer.next;\\n            tail.next = curr;\\n            pointer.next = prev;\\n            pointer = tail;\\n        }\\n        return dum.next;\\n    }\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n \\n        ListNode dum = new ListNode(0);\\n        dum.next = head;\\n        ListNode pointer = dum;\\n        while (pointer != null) {\\n            ListNode node = pointer;\\n            //  check there are k nodes to reverse\\n            for (int i = 0; i < k && node != null; i++) {\\n                node = node.next;\\n            }\\n            if (node == null) break;\\n            \\n            //  we have k nodes, then start from the first node\\n            ListNode prev = null, curr = pointer.next, next = null;\\n            for (int i = 0; i < k; i++) {\\n                next = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = next;\\n            }\\n            ListNode tail = pointer.next;\\n            tail.next = curr;\\n            pointer.next = prev;\\n            pointer = tail;\\n        }\\n        return dum.next;\\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521178,
                "title": "two-pointers-make-this-problem-to-an-easy-one",
                "content": "``` class Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head\\n        temp = []\\n        \\n        while fast:\\n            temp.append(fast.val)\\n            \\n            if len(temp) == k:\\n                while temp:\\n                    slow.val = temp.pop()\\n                    slow = slow.next\\n                    \\n            fast = fast.next\\n            \\n        return head\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "``` class Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head\\n        temp = []\\n        \\n        while fast:\\n            temp.append(fast.val)\\n            \\n            if len(temp) == k:\\n                while temp:\\n                    slow.val = temp.pop()\\n                    slow = slow.next\\n                    \\n            fast = fast.next\\n            \\n        return head\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2041406,
                "title": "c-recursive-easy-to-understand",
                "content": "```\\n ListNode* reverseKGroup(ListNode* head, int k) \\n    {   \\n        //to not reverse the last group which is less than k\\n         ListNode* temp=head;\\n         for(int i=0;i<k;i++)\\n         {\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        //here we go again\\n        ListNode *prev = NULL;\\n        ListNode *curr = head;\\n        ListNode *next;\\n        int count=0;\\n        while(curr and count<k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        //aage ka recursion ke bharose\\n        if(next){\\n            head->next = reverseKGroup(next,k);    //head->next=prev\\n        }\\n        \\n        return prev;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n ListNode* reverseKGroup(ListNode* head, int k) \\n    {   \\n        //to not reverse the last group which is less than k\\n         ListNode* temp=head;\\n         for(int i=0;i<k;i++)\\n         {\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        //here we go again\\n        ListNode *prev = NULL;\\n        ListNode *curr = head;\\n        ListNode *next;\\n        int count=0;\\n        while(curr and count<k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        //aage ka recursion ke bharose\\n        if(next){\\n            head->next = reverseKGroup(next,k);    //head->next=prev\\n        }\\n        \\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943998,
                "title": "my-simple-100-faster-solution-using-recursion-with-explanation",
                "content": "class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n\\t\\n        ListNode prev = null;\\n        ListNode current = head;\\n        int count = 0;\\n        ListNode next = null;\\n\\t\\t\\n        //reverse blindly\\n        while (current != null && count < k) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }\\n\\n        //restoring if count lesser\\n        if (count < k) {\\n            current = prev;\\n            prev = null;\\n            next = null;\\n\\t\\t\\t\\n            while (count != 0) {\\n                count--;\\n                next = current.next;\\n                current.next = prev;\\n                prev = current;\\n                current = next;\\n            }\\n        }\\n        //head always contains first node (last node after reverse) current head will become current tail and next set should be attached to that\\n        if (next != null) {\\n            head.next = reverseKGroup(next, k);\\n        }\\n        //prev contains current head and it should be returned\\n        return prev;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n\\t\\n        ListNode prev = null;\\n        ListNode current = head;\\n        int count = 0;\\n        ListNode next = null;\\n\\t\\t\\n        //reverse blindly\\n        while (current != null && count < k) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 493558,
                "title": "c-simple-solution-with-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head)\\n            return NULL;\\n        ListNode *prev = NULL;\\n        auto cur = head;\\n        int n = 0;\\n        while(cur && n != k){\\n            auto tmp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = tmp;\\n            n++;\\n        }\\n        if(n != k){\\n            return reverseKGroup(prev, n);\\n        }\\n        head->next = reverseKGroup(cur, k);\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head)\\n            return NULL;\\n        ListNode *prev = NULL;\\n        auto cur = head;\\n        int n = 0;\\n        while(cur && n != k){\\n            auto tmp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = tmp;\\n            n++;\\n        }\\n        if(n != k){\\n            return reverseKGroup(prev, n);\\n        }\\n        head->next = reverseKGroup(cur, k);\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 215165,
                "title": "rust",
                "content": "```\\nfn add(head: Option<Box<ListNode>>, tail: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n    let mut head = head;\\n    let mut tail = tail;\\n\\n    while let Some(mut new_tail) = head.take() {\\n        head = new_tail.next.take();\\n        new_tail.next = tail.take();\\n        tail = Some(new_tail);\\n    }\\n    tail\\n}\\n\\nimpl Solution {\\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut tail = &mut head;\\n        for _ in 0..k {\\n            match tail.as_mut() {\\n                None => return head,\\n                Some(tail_ref) => tail = &mut tail_ref.next,\\n            }\\n        }\\n        let tail = tail.take();\\n        add(head, Solution::reverse_k_group(tail, k))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfn add(head: Option<Box<ListNode>>, tail: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n    let mut head = head;\\n    let mut tail = tail;\\n\\n    while let Some(mut new_tail) = head.take() {\\n        head = new_tail.next.take();\\n        new_tail.next = tail.take();\\n        tail = Some(new_tail);\\n    }\\n    tail\\n}\\n\\nimpl Solution {\\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut tail = &mut head;\\n        for _ in 0..k {\\n            match tail.as_mut() {\\n                None => return head,\\n                Some(tail_ref) => tail = &mut tail_ref.next,\\n            }\\n        }\\n        let tail = tail.take();\\n        add(head, Solution::reverse_k_group(tail, k))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11622,
                "title": "python-non-recursive-solution-easy-understand-68-ms",
                "content": "\\n    # pre alway point the last one in previous KGoup. \\n    # Constant insert cur kGroup's node after it.\\n    class Solution(object): \\n    def reverseKGroup(self, head, k):\\n        pre, pre.next = self, head\\n        while self.needReverse(head, k):\\n            tail = head  # 1st one in cur KGroup\\n            for _ in xrange(k):\\n                pre.next, head.next, head = head, pre.next, head.next\\n            pre = tail  # now, it become the last one in previous KGroup \\n        pre.next = head  #maybe there are some rest node.\\n        return self.next\\n        \\n    def needReverse(self, head, k):\\n        while head and k:\\n            k -= 1\\n            head = head.next\\n        return k == 0\\n\\n    # 68 ms, 81 / 81 test cases passed.\\n    # beats 84.43% of python submissions.",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    # pre alway point the last one in previous KGoup. \\n    # Constant insert cur kGroup's node after it.\\n    class Solution(object): \\n    def reverseKGroup(self, head, k):\\n        pre, pre.next = self, head\\n        while self.needReverse(head, k):\\n            tail = head  # 1st one in cur KGroup\\n            for _ in xrange(k):\\n                pre.next, head.next, head = head, pre.next, head.next\\n            pre = tail  # now, it become the last one in previous KGroup \\n        pre.next = head  #maybe there are some rest node.\\n        return self.next\\n        \\n    def needReverse(self, head, k):\\n        while head and k:\\n            k -= 1\\n            head = head.next\\n        return k == 0\\n\\n    # 68 ms, 81 / 81 test cases passed.\\n    # beats 84.43% of python submissions.",
                "codeTag": "Java"
            },
            {
                "id": 11645,
                "title": "short-recursive-java-solution",
                "content": "    public class Solution {\\n           \\n       public  ListNode reverse(ListNode head, ListNode end){\\n    \\t       if(head==null || head.next==null || head==end || head.next==end) return head;\\n    \\t       ListNode sec = head.next;\\n    \\t       ListNode rem = reverse(sec,end);\\n    \\t       sec.next =head; head.next=null;\\n    \\t       return rem;\\n    \\t   }\\n    \\t    public  ListNode reverseKGroup(ListNode head, int k) {\\n    \\t        ListNode curr = head; int count = 0;\\n    \\t        while (curr != null && count != k) {\\n    \\t            curr = curr.next;count++;\\n    \\t        }\\n    \\t        if (count == k) {\\n    \\t            ListNode temp = reverseKGroup(curr, k);\\n    \\t            ListNode t = reverse(head,curr);\\n    \\t            head.next = temp;\\n    \\t            return t;\\n    \\t        }\\n    \\t        return head;\\n    \\t    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n           \\n       public  ListNode reverse(ListNode head, ListNode end){\\n    \\t       if(head==null || head.next==null || head==end || head.next==end) return head;\\n    \\t       ListNode sec = head.next;\\n    \\t       ListNode rem = reverse(sec,end);\\n    \\t       sec.next =head; head.next=null;\\n    \\t       return rem;\\n    \\t   }",
                "codeTag": "Java"
            },
            {
                "id": 3865908,
                "title": "best-recursive-and-iterative-approach-with-video-explanation-beats-100",
                "content": "# [Video link](https://youtu.be/fi2vh0nQLi0) \\n\\n# Code\\n```\\n// Recursive approach Space O(N) (Stack)\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int size = 0;\\n        ListNode *temp = head;\\n        while(temp!=NULL){\\n            temp = temp -> next;\\n            size++;\\n        }\\n        if(size < k)    return head;   \\n\\n        // Base call\\n        if(head == NULL)\\n            return NULL;\\n\\n        // Step 1 - Reverse first k nodes\\n        ListNode *curr = head, *prev = NULL, *next = NULL;\\n        int count = 0;\\n        while(curr != NULL && count <k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Step 2 - Use recursion to reverse rest of the nodes\\n        if(next!=NULL){\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // Step 3 - Return head\\n        return prev;\\n    }\\n};\\n\\n// Iterative approach Space - O(1)\\nclass Solution {\\npublic:\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode *before = dummy, *after = head;\\n        ListNode *curr = NULL, *prev = NULL, *nxt = NULL;\\n        while(true){\\n            ListNode* cursor = after;\\n            for(int i = 0; i < k; i++){\\n                if(cursor == nullptr) \\n                    return dummy->next;\\n                cursor = cursor->next;\\n            }\\n            curr = after;\\n            prev = before;\\n            for(int i = 0; i < k; i++){\\n                nxt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nxt;\\n            }\\n            after->next = curr;\\n            before->next = prev;\\n            before = after;\\n            after = curr;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n// Recursive approach Space O(N) (Stack)\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int size = 0;\\n        ListNode *temp = head;\\n        while(temp!=NULL){\\n            temp = temp -> next;\\n            size++;\\n        }\\n        if(size < k)    return head;   \\n\\n        // Base call\\n        if(head == NULL)\\n            return NULL;\\n\\n        // Step 1 - Reverse first k nodes\\n        ListNode *curr = head, *prev = NULL, *next = NULL;\\n        int count = 0;\\n        while(curr != NULL && count <k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Step 2 - Use recursion to reverse rest of the nodes\\n        if(next!=NULL){\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // Step 3 - Return head\\n        return prev;\\n    }\\n};\\n\\n// Iterative approach Space - O(1)\\nclass Solution {\\npublic:\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode *before = dummy, *after = head;\\n        ListNode *curr = NULL, *prev = NULL, *nxt = NULL;\\n        while(true){\\n            ListNode* cursor = after;\\n            for(int i = 0; i < k; i++){\\n                if(cursor == nullptr) \\n                    return dummy->next;\\n                cursor = cursor->next;\\n            }\\n            curr = after;\\n            prev = before;\\n            for(int i = 0; i < k; i++){\\n                nxt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nxt;\\n            }\\n            after->next = curr;\\n            before->next = prev;\\n            before = after;\\n            after = curr;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796263,
                "title": "c-easy-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(K)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int LinkListLen(ListNode* head){\\n        int res = 0;\\n        while(head!=NULL){\\n            res++;head = head->next;\\n        }\\n\\n        return res;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* ans = new ListNode(-1);\\n        ListNode* dummy = ans;\\n        int len = LinkListLen(head);\\n        while(head!=NULL){\\n            if(len>=k){\\n                ListNode* tem = NULL;\\n                for(int i=0;i<k;i++){\\n                    ListNode* n = new ListNode(head->val);\\n                    head = head->next;\\n                    n->next = tem;\\n                    tem = n;len--;\\n                }\\n                dummy->next = tem;\\n                while(dummy->next!=NULL){\\n                    dummy = dummy->next;\\n                }\\n            } else {\\n                dummy->next=head;\\n                break;\\n            }\\n        }\\n        \\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int LinkListLen(ListNode* head){\\n        int res = 0;\\n        while(head!=NULL){\\n            res++;head = head->next;\\n        }\\n\\n        return res;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* ans = new ListNode(-1);\\n        ListNode* dummy = ans;\\n        int len = LinkListLen(head);\\n        while(head!=NULL){\\n            if(len>=k){\\n                ListNode* tem = NULL;\\n                for(int i=0;i<k;i++){\\n                    ListNode* n = new ListNode(head->val);\\n                    head = head->next;\\n                    n->next = tem;\\n                    tem = n;len--;\\n                }\\n                dummy->next = tem;\\n                while(dummy->next!=NULL){\\n                    dummy = dummy->next;\\n                }\\n            } else {\\n                dummy->next=head;\\n                break;\\n            }\\n        }\\n        \\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606051,
                "title": "better-than-92-easy-recursive-solution-with-comments-for-better-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReverse k nodes and then do recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**IMPORTANT: Read the comments in the code, they are self-explanatory.**\\n1. Reverse k nodes initially.\\n2. Call for the remaining \\'len - k\\' nodes, where len = length of the Linked List.\\n3. Connect the kth node of the k nodes reversed linked list to the head of the remaining linked list.\\n\\n# Complexity\\n- Time complexity: **O(len)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(len) for the length function\\nO(len/k) for the loop inside reverseKGroup\\nO(len) for the recursive calls inside reverseKGroup\\n\\nOverall ~ O(len)\\n\\n- Space complexity:**O(len)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nlen = length of the linked list, this is due to recursive call stack.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length (ListNode* head)\\n    {\\n        int len = 0;\\n        while(head != NULL)\\n        {\\n            len++;\\n            head = head -> next;\\n        }\\n        return len;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //head = 1\\n\\n        int len = length(head); //Calculate length of LL\\n        if(len < k) //As mentioned in aue, if len < k don\\'t reverse\\n        {\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* curr = head; //1 --- After 1st step, curr = 2\\n        ListNode* prev = NULL; //NULL\\n        ListNode* forward = NULL;\\n\\n        while(curr != NULL && cnt < k)  //Reverseing \\'k\\' nodes initially\\n        {\\n            forward = curr -> next; //2 --- 3\\n            curr -> next = prev; //1 -> 2 is broken and NULL <- 1 --- 2 -> 1\\n            prev = curr; //prev = 1 --- prev = 2\\n            curr = forward; // curr = 2 --- curr = 3\\n            cnt++;\\n        }\\n        if(forward != NULL)\\n        {\\n            head -> next = reverseKGroup(forward, k); //Recursively calling for remaining nodes\\n        }\\n        //I\\'ve stored it in head -> next bcz, head = 1 and I\\'ve coneected it with 4, head of the new LL\\n\\n        return prev; // return prev bcz, 2 is the head of our final LL and it is stored in prev\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length (ListNode* head)\\n    {\\n        int len = 0;\\n        while(head != NULL)\\n        {\\n            len++;\\n            head = head -> next;\\n        }\\n        return len;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //head = 1\\n\\n        int len = length(head); //Calculate length of LL\\n        if(len < k) //As mentioned in aue, if len < k don\\'t reverse\\n        {\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* curr = head; //1 --- After 1st step, curr = 2\\n        ListNode* prev = NULL; //NULL\\n        ListNode* forward = NULL;\\n\\n        while(curr != NULL && cnt < k)  //Reverseing \\'k\\' nodes initially\\n        {\\n            forward = curr -> next; //2 --- 3\\n            curr -> next = prev; //1 -> 2 is broken and NULL <- 1 --- 2 -> 1\\n            prev = curr; //prev = 1 --- prev = 2\\n            curr = forward; // curr = 2 --- curr = 3\\n            cnt++;\\n        }\\n        if(forward != NULL)\\n        {\\n            head -> next = reverseKGroup(forward, k); //Recursively calling for remaining nodes\\n        }\\n        //I\\'ve stored it in head -> next bcz, head = 1 and I\\'ve coneected it with 4, head of the new LL\\n\\n        return prev; // return prev bcz, 2 is the head of our final LL and it is stored in prev\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558230,
                "title": "easy-c-solution-beat-85",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        ListNode* temp=head;\\n        int i=0;\\n        while(temp!=NULL){\\n            i++;\\n            temp=temp->next;\\n        }\\n        return i;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n    if(head==NULL)\\n    return NULL;\\n    int len=length(head);\\n    if(k>len)\\n    return head;\\n\\n    int count=0;\\n    ListNode* prev=NULL;\\n    ListNode* curr=head;\\n    ListNode* next=head->next;\\n    //reverse\\n    while(count<k){\\n        next=curr->next;\\n        curr->next=prev;\\n        prev=curr;\\n        curr=next;\\n        count++;\\n    }\\n    //reverse ll\\n    if(next!=NULL)\\n        head->next=reverseKGroup(next,k);\\n    return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        ListNode* temp=head;\\n        int i=0;\\n        while(temp!=NULL){\\n            i++;\\n            temp=temp->next;\\n        }\\n        return i;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n    if(head==NULL)\\n    return NULL;\\n    int len=length(head);\\n    if(k>len)\\n    return head;\\n\\n    int count=0;\\n    ListNode* prev=NULL;\\n    ListNode* curr=head;\\n    ListNode* next=head->next;\\n    //reverse\\n    while(count<k){\\n        next=curr->next;\\n        curr->next=prev;\\n        prev=curr;\\n        curr=next;\\n        count++;\\n    }\\n    //reverse ll\\n    if(next!=NULL)\\n        head->next=reverseKGroup(next,k);\\n    return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778878,
                "title": "easiest-approach-only-3-steps-beginner-friendly-easiest-c-solution",
                "content": "# **ONLY 3 STEPS**\\n1. Store all node values in a vector.\\n2. Apply operations on the vector i.e, swap values in a loop. \\n3. Make a new LinkedList by the processed vector and return it.\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\t//edge cases\\n        if (head == NULL || k ==0 ||k==1)return head;\\n\\t\\t// Store all node values in a vector.\\n        vector<int> v;\\n        ListNode* p = head;\\n        while(p){\\n            v.push_back(p->val);\\n            p = p->next;\\n        }\\n        int n = v.size();\\n\\t\\t// r is how many sub groups are to be reversed; \\n        int r = n/k;\\n        int q = 0;\\n\\t\\t// Apply operations on the vector i.e, swap values in a loop. \\n        while(r--){\\n            int i = k*q;\\n            int j = (k)*(q+1) - 1;\\n            while(i<j){\\n                swap(v[i++], v[j--]);\\n            }\\n            q++;\\n        }\\n\\t\\t// Make a new LinkedList by the processed vector and return it.\\n        ListNode* a = new ListNode(v[0]);\\n        ListNode* b = a;\\n        for(int i =1; i<v.size(); i++){\\n            b->next = new ListNode(v[i]);\\n            b = b->next;\\n        }\\n        return a;\\n    }\\n};\\n```\\n**Liked it ?\\nPlease Upvote**",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\t//edge cases\\n        if (head == NULL || k ==0 ||k==1)return head;\\n\\t\\t// Store all node values in a vector.\\n        vector<int> v;\\n        ListNode* p = head;\\n        while(p){\\n            v.push_back(p->val);\\n            p = p->next;\\n        }\\n        int n = v.size();\\n\\t\\t// r is how many sub groups are to be reversed; \\n        int r = n/k;\\n        int q = 0;\\n\\t\\t// Apply operations on the vector i.e, swap values in a loop. \\n        while(r--){\\n            int i = k*q;\\n            int j = (k)*(q+1) - 1;\\n            while(i<j){\\n                swap(v[i++], v[j--]);\\n            }\\n            q++;\\n        }\\n\\t\\t// Make a new LinkedList by the processed vector and return it.\\n        ListNode* a = new ListNode(v[0]);\\n        ListNode* b = a;\\n        for(int i =1; i<v.size(); i++){\\n            b->next = new ListNode(v[i]);\\n            b = b->next;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776693,
                "title": "java-fast-clean-recursion-beat-100-and-well-explain",
                "content": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        // base case\\n        if(k == 1) return head;\\n\\t\\t// first keep finding each group until we found last group\\n\\t\\t// there is no need to reverse the last group when we found it, just return start point of it\\n\\t\\t// even if the last group is null, it is still fine, just return it\\n        ListNode curr = head;\\n        for(int i = 0 ; i < k ; i ++) {\\n           if(head != null) {\\n                head = head.next;\\n           }else {\\n               // last group found\\n               return curr;\\n           }\\n        }\\n        // recursion\\n        ListNode nextGroup = reverseKGroup(head,k);\\n        // back tracking reverse curr group\\n        ListNode finalTail = curr;\\n        ListNode prev = curr;\\n        ListNode tempNext = null;\\n        for(int i = 0 ; i < k ; i ++) {\\n            tempNext = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tempNext;\\n        }\\n        // connect reversed curr to next group\\n        finalTail.next = nextGroup;\\n\\t\\t// return new reversed first node of curr group(which the prev point to) and keep back tracking until stack is empty\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        // base case\\n        if(k == 1) return head;\\n\\t\\t// first keep finding each group until we found last group\\n\\t\\t// there is no need to reverse the last group when we found it, just return start point of it\\n\\t\\t// even if the last group is null, it is still fine, just return it\\n        ListNode curr = head;\\n        for(int i = 0 ; i < k ; i ++) {\\n           if(head != null) {\\n                head = head.next;\\n           }else {\\n               // last group found\\n               return curr;\\n           }\\n        }\\n        // recursion\\n        ListNode nextGroup = reverseKGroup(head,k);\\n        // back tracking reverse curr group\\n        ListNode finalTail = curr;\\n        ListNode prev = curr;\\n        ListNode tempNext = null;\\n        for(int i = 0 ; i < k ; i ++) {\\n            tempNext = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tempNext;\\n        }\\n        // connect reversed curr to next group\\n        finalTail.next = nextGroup;\\n\\t\\t// return new reversed first node of curr group(which the prev point to) and keep back tracking until stack is empty\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253458,
                "title": "c-simple-fast-solution-reverse-nodes-in-k-group",
                "content": "class Solution {\\npublic:\\n    int lengthOfLL(ListNode* head)\\n    {\\n        int length=0;\\n        while(head!=NULL)\\n        {\\n            head=head->next;\\n            length++;   \\n        }\\n        return length;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k,int length)\\n    {\\n        if(length<k) return head;\\n        int count=0;\\n        ListNode*prev=NULL;\\n        ListNode*c=head;\\n        ListNode*n=NULL;\\n        while(c!=NULL && count<k)\\n        {\\n            n=c->next;\\n            c->next=prev;\\n            prev=c;\\n            c=n;\\n            count++;\\n        }\\n        //call recursion for remaining node\\n        if(n!=NULL)\\n        {\\n            head->next=reverseKGroup(n,k,length-k);\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n   int length=lengthOfLL(head);\\n        return reverseKGroup(head,k,length);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int lengthOfLL(ListNode* head)\\n    {\\n        int length=0;\\n        while(head!=NULL)\\n        {\\n            head=head->next;\\n            length++;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1990895,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n\\n    ListNode prev = null;\\n    ListNode current = head;\\n    int count = 0;\\n    ListNode next = null;\\n\\t\\n    //reverse blindly\\n    while (current != null && count < k) {\\n        next = current.next;\\n        current.next = prev;\\n        prev = current;\\n        current = next;\\n        count++;\\n    }\\n\\n    //restoring if count lesser\\n    if (count < k) {\\n        current = prev;\\n        prev = null;\\n        next = null;\\n\\t\\t\\n        while (count != 0) {\\n            count--;\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n    }\\n    //head always contains first node (last node after reverse) current head will become current tail and next set should be attached to that\\n    if (next != null) {\\n        head.next = reverseKGroup(next, k);\\n    }\\n    //prev contains current head and it should be returned\\n    return prev;\\n}\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++){\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        ListNode *prev=NULL;\\n        ListNode *nex1=NULL;\\n        temp=head;\\n        for(int i=0;i<k;i++){\\n            nex1=temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nex1;\\n        }\\n        if(nex1!=NULL)\\n            head->next=reverseKGroup(nex1,k);\\n        return prev;\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n        prev = None\\n        curr = head\\n        for _ in range(k):\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar reverseKGroup = function(head, k) {\\n\\t// will return the new head of the resultant linked list\\n    return reverseAGroup(head);\\n    \\n    function reverseAGroup(start) {\\n\\t\\t// a temp varaible to move the curr start pointer k steps \\n        let temp_k = k;\\n        let curr = start;\\n        while(curr && temp_k-- > 0) {\\n            curr = curr.next;\\n        }\\n        if(temp_k > 0) {  // curr group size is less than k, so need not reverse\\n            return start;\\n        }\\n        const groupTail = start,                // the start pointer is pointing to the tail node of the current group (on reversal)\\n              groupHead = reverse(start, curr); // get the tail pointer of the current group by reversing the group of nodes\\n        \\n        if(curr) {  // if there is a node followed by the current group, update the next pointer of the current group\\'s tail next pointer\\n            groupTail.next = reverseAGroup(curr);    // we will get the next group head by recursively calling the function on the following node\\n        }\\n        return groupHead;    // finally return the current group head node\\n    }\\n    function reverse(root, nextGroup) {\\n        let curr = root,\\n            next = null,\\n            prev = null;\\n        \\n        while(curr && curr !== nextGroup) {    // the terminate condition will check if the current node reaches the next group\\'s head node\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;    // this will point to the new head node of the group after reversing \\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\\n        \\n        // check whether there is more than k nodes \\n        var temp = head\\n        for (i in 0 until k) {\\n            // if there are less than k nodes, return head (no need to reverse node)\\n            if (temp == null) return head else temp = temp.next\\n        }\\n\\n        // newNextStart is the starting node(after which reversion has taken place)\\n        val newNextStart = reverseKGroup(temp, k) \\n        \\n        // reverse k nodes one by one \\n        var prev: ListNode? = null \\n        var curr: ListNode? = head \\n        for (i in 0 until k) {\\n            var next = curr!!.next \\n            curr.next = prev\\n            \\n            prev = curr\\n            curr = next\\n        }\\n        \\n        // link starting node(head) with the new next starting node(newNextStart)\\n        head!!.next = newNextStart\\n        \\n        return prev\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if(head == nil) {return nil}\\n        if(k < 2) {\\n            return head\\n        }\\n        var dummy = ListNode(0)\\n        guard let head = head else {\\n            return nil\\n        }\\n        dummy.next = head\\n        \\n        var current = dummy\\n\\n        while(current.next != nil) {\\n            var start = current.next\\n            var end = current.next\\n            \\n            var count = 1\\n            while(count < k && end != nil) {\\n                end = end!.next\\n                count += 1\\n            }\\n            if(end == nil) {\\n                break\\n            }\\n            \\n            //next keep track for head of remaing list\\n            var next = end!.next\\n            \\n            //break the chain to reverse the k elements\\n            end!.next = nil\\n            \\n            var tCurr = start\\n            var prev:ListNode? = nil\\n            while(tCurr != nil) {\\n                let tNext = tCurr!.next\\n                tCurr!.next = prev\\n                prev = tCurr!\\n                tCurr = tNext\\n            }\\n            \\n            \\n            //after reversing. Put the conenction back\\n            \\n            current.next = end\\n            \\n            start!.next = next\\n            \\n            //start next iteration\\n            current = start!\\n            \\n        }\\n        return dummy.next\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n\\n    ListNode prev = null;\\n    ListNode current = head;\\n    int count = 0;\\n    ListNode next = null;\\n\\t\\n    //reverse blindly\\n    while (current != null && count < k) {\\n        next = current.next;\\n        current.next = prev;\\n        prev = current;\\n        current = next;\\n        count++;\\n    }\\n\\n    //restoring if count lesser\\n    if (count < k) {\\n        current = prev;\\n        prev = null;\\n        next = null;\\n\\t\\t\\n        while (count != 0) {\\n            count--;\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n    }\\n    //head always contains first node (last node after reverse) current head will become current tail and next set should be attached to that\\n    if (next != null) {\\n        head.next = reverseKGroup(next, k);\\n    }\\n    //prev contains current head and it should be returned\\n    return prev;\\n}\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++){\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        ListNode *prev=NULL;\\n        ListNode *nex1=NULL;\\n        temp=head;\\n        for(int i=0;i<k;i++){\\n            nex1=temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nex1;\\n        }\\n        if(nex1!=NULL)\\n            head->next=reverseKGroup(nex1,k);\\n        return prev;\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n        prev = None\\n        curr = head\\n        for _ in range(k):\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\n```\\n```\n```\\n```\n```\\nvar reverseKGroup = function(head, k) {\\n\\t// will return the new head of the resultant linked list\\n    return reverseAGroup(head);\\n    \\n    function reverseAGroup(start) {\\n\\t\\t// a temp varaible to move the curr start pointer k steps \\n        let temp_k = k;\\n        let curr = start;\\n        while(curr && temp_k-- > 0) {\\n            curr = curr.next;\\n        }\\n        if(temp_k > 0) {  // curr group size is less than k, so need not reverse\\n            return start;\\n        }\\n        const groupTail = start,                // the start pointer is pointing to the tail node of the current group (on reversal)\\n              groupHead = reverse(start, curr); // get the tail pointer of the current group by reversing the group of nodes\\n        \\n        if(curr) {  // if there is a node followed by the current group, update the next pointer of the current group\\'s tail next pointer\\n            groupTail.next = reverseAGroup(curr);    // we will get the next group head by recursively calling the function on the following node\\n        }\\n        return groupHead;    // finally return the current group head node\\n    }\\n    function reverse(root, nextGroup) {\\n        let curr = root,\\n            next = null,\\n            prev = null;\\n        \\n        while(curr && curr !== nextGroup) {    // the terminate condition will check if the current node reaches the next group\\'s head node\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;    // this will point to the new head node of the group after reversing \\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\\n        \\n        // check whether there is more than k nodes \\n        var temp = head\\n        for (i in 0 until k) {\\n            // if there are less than k nodes, return head (no need to reverse node)\\n            if (temp == null) return head else temp = temp.next\\n        }\\n\\n        // newNextStart is the starting node(after which reversion has taken place)\\n        val newNextStart = reverseKGroup(temp, k) \\n        \\n        // reverse k nodes one by one \\n        var prev: ListNode? = null \\n        var curr: ListNode? = head \\n        for (i in 0 until k) {\\n            var next = curr!!.next \\n            curr.next = prev\\n            \\n            prev = curr\\n            curr = next\\n        }\\n        \\n        // link starting node(head) with the new next starting node(newNextStart)\\n        head!!.next = newNextStart\\n        \\n        return prev\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if(head == nil) {return nil}\\n        if(k < 2) {\\n            return head\\n        }\\n        var dummy = ListNode(0)\\n        guard let head = head else {\\n            return nil\\n        }\\n        dummy.next = head\\n        \\n        var current = dummy\\n\\n        while(current.next != nil) {\\n            var start = current.next\\n            var end = current.next\\n            \\n            var count = 1\\n            while(count < k && end != nil) {\\n                end = end!.next\\n                count += 1\\n            }\\n            if(end == nil) {\\n                break\\n            }\\n            \\n            //next keep track for head of remaing list\\n            var next = end!.next\\n            \\n            //break the chain to reverse the k elements\\n            end!.next = nil\\n            \\n            var tCurr = start\\n            var prev:ListNode? = nil\\n            while(tCurr != nil) {\\n                let tNext = tCurr!.next\\n                tCurr!.next = prev\\n                prev = tCurr!\\n                tCurr = tNext\\n            }\\n            \\n            \\n            //after reversing. Put the conenction back\\n            \\n            current.next = end\\n            \\n            start!.next = next\\n            \\n            //start next iteration\\n            current = start!\\n            \\n        }\\n        return dummy.next\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845558,
                "title": "without-extra-space-recursion-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int length(ListNode *head){\\n        if(head==NULL){\\n            return 0;\\n        }\\n        else{\\n            return 1+length(head->next);\\n        }\\n    }\\n    ListNode *reverse(ListNode *head){\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        else{\\n            ListNode *newHead=reverse(head->next);\\n            ListNode *temp=head->next;\\n            temp->next=head;\\n            head->next=NULL;\\n            return newHead;\\n        }\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        if(length(head)<k){\\n            return head;\\n        }\\n        int count=0;\\n        ListNode *temp=head;\\n        while(count< k-1 and temp!=NULL){\\n            temp=temp->next;\\n            count=count+1;\\n        }\\n        ListNode *newpart=reverseKGroup(temp->next,k);\\n        temp->next=NULL;\\n        ListNode *newHead=reverse(head);\\n        head->next=newpart;\\n        return newHead;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(ListNode *head){\\n        if(head==NULL){\\n            return 0;\\n        }\\n        else{\\n            return 1+length(head->next);\\n        }\\n    }\\n    ListNode *reverse(ListNode *head){\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        else{\\n            ListNode *newHead=reverse(head->next);\\n            ListNode *temp=head->next;\\n            temp->next=head;\\n            head->next=NULL;\\n            return newHead;\\n        }\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        if(length(head)<k){\\n            return head;\\n        }\\n        int count=0;\\n        ListNode *temp=head;\\n        while(count< k-1 and temp!=NULL){\\n            temp=temp->next;\\n            count=count+1;\\n        }\\n        ListNode *newpart=reverseKGroup(temp->next,k);\\n        temp->next=NULL;\\n        ListNode *newHead=reverse(head);\\n        head->next=newpart;\\n        return newHead;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775313,
                "title": "short-and-easy-to-understand-c-iterative-solution-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *reverse(ListNode *head,int k){\\n        ListNode *curr=head,*prev=NULL,*temp;\\n        \\n         while(curr && k--){\\n            temp=curr->next;            \\n            curr->next=prev;\\n            prev=curr;\\n            curr=temp;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        ListNode *dummy=new ListNode();\\n        ListNode *curr=head;\\n        ListNode *first_node=head,*temp,*prev=dummy;  // here first_node is the first node of the group before reversing\\n        \\n        int count=0;\\n        while(curr){            \\n            count++;\\n            temp=curr->next;\\n            if(count%k==0){\\n                prev->next=reverse(first_node,k);\\n                prev=first_node; // prev points to the last node of the most recently reversed group\\n                first_node->next=temp;\\n                first_node=temp;\\n                count=0;\\n            }\\n            curr=temp;\\n        }       \\n        return dummy->next;\\n    }\\n};\\n```\\n\\n\\t\\t\\t",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *reverse(ListNode *head,int k){\\n        ListNode *curr=head,*prev=NULL,*temp;\\n        \\n         while(curr && k--){\\n            temp=curr->next;            \\n            curr->next=prev;\\n            prev=curr;\\n            curr=temp;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        ListNode *dummy=new ListNode();\\n        ListNode *curr=head;\\n        ListNode *first_node=head,*temp,*prev=dummy;  // here first_node is the first node of the group before reversing\\n        \\n        int count=0;\\n        while(curr){            \\n            count++;\\n            temp=curr->next;\\n            if(count%k==0){\\n                prev->next=reverse(first_node,k);\\n                prev=first_node; // prev points to the last node of the most recently reversed group\\n                first_node->next=temp;\\n                first_node=temp;\\n                count=0;\\n            }\\n            curr=temp;\\n        }       \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512614,
                "title": "easy-to-understand-code-c-recursion",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* prevptr=NULL;\\n        ListNode* currptr=head;\\n        ListNode* nextptr;\\n        int cnt=0;\\n        while(currptr){\\n            cnt++;\\n            currptr=currptr->next;\\n        }\\n        if(cnt<k){\\n            return head;\\n        }\\n        cnt=0;\\n        currptr=head;\\n        int count=0;\\n        while(currptr!=NULL && count<k){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            \\n            prevptr=currptr;\\n            currptr=nextptr;\\n            count++;\\n        }\\n        if(nextptr!=NULL){\\n            head->next=reverseKGroup(nextptr,k);\\n        }\\n        return prevptr;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* prevptr=NULL;\\n        ListNode* currptr=head;\\n        ListNode* nextptr;\\n        int cnt=0;\\n        while(currptr){\\n            cnt++;\\n            currptr=currptr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1346312,
                "title": "rust-simple-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut node = &mut head;\\n        for _ in 0..k {\\n            if let Some(n) = node {\\n                node = &mut n.next;\\n            } else {\\n                return head;\\n            }\\n        }\\n        let mut ret = Self::reverse_k_group(node.take(), k);\\n        while let Some(h) = head.take() {\\n            ret = Some(Box::new(ListNode {\\n                val: h.val,\\n                next: ret,\\n            }));\\n            head = h.next;\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut node = &mut head;\\n        for _ in 0..k {\\n            if let Some(n) = node {\\n                node = &mut n.next;\\n            } else {\\n                return head;\\n            }\\n        }\\n        let mut ret = Self::reverse_k_group(node.take(), k);\\n        while let Some(h) = head.take() {\\n            ret = Some(Box::new(ListNode {\\n                val: h.val,\\n                next: ret,\\n            }));\\n            head = h.next;\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1321590,
                "title": "simple-solution-with-explanation",
                "content": "Reversing *K nodes* at a time in linked list is similar to *reversing a specified portion of a linked list.* So I created a function **reverse()** which reverse a specified portion of the linked list from m to n. I called this function in a loop with portion as **[i,i+k-1], [i+k,i+2k -1]**, and so on until we have a upper bound less than the number of nodes in the given linked list.\\n\\nThis was my approach, feel free to share your approach :).\\n\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        if k==1:\\n            return head\\n        def reverse(head, m, n):\\n \\n            prev = None\\n            curr = head\\n            i = 1\\n            while curr is not None and i < m:\\n                prev = curr\\n                curr = curr.next\\n                i = i + 1\\n\\n            start = curr\\n            end = None\\n            while curr is not None and i <= n:\\n                next = curr.next\\n                curr.next = end\\n                end = curr\\n                curr = next\\n                i = i + 1\\n\\n            start.next = curr\\n            if prev is None:\\n                head = end\\n            else:\\n                prev.next = end\\n\\n            return head\\n        n=0\\n        cur = head\\n        while cur:\\n            cur=cur.next\\n            n+=1\\n        for i in range(1,n+1,k): \\n            if i+k-1<=n:\\n                head = reverse(head, i, i+k-1)\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        if k==1:\\n            return head\\n        def reverse(head, m, n):\\n \\n            prev = None\\n            curr = head\\n            i = 1\\n            while curr is not None and i < m:\\n                prev = curr\\n                curr = curr.next\\n                i = i + 1\\n\\n            start = curr\\n            end = None\\n            while curr is not None and i <= n:\\n                next = curr.next\\n                curr.next = end\\n                end = curr\\n                curr = next\\n                i = i + 1\\n\\n            start.next = curr\\n            if prev is None:\\n                head = end\\n            else:\\n                prev.next = end\\n\\n            return head\\n        n=0\\n        cur = head\\n        while cur:\\n            cur=cur.next\\n            n+=1\\n        for i in range(1,n+1,k): \\n            if i+k-1<=n:\\n                head = reverse(head, i, i+k-1)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290581,
                "title": "simple-java-solution-with-explanation-0ms-faster-than-100",
                "content": "**class Solution** {\\n\\t\\n\\tpublic ListNode reverseKGroup(ListNode head, int k) {   \\n        if(checkLength(head,k))return head;\\n        int count = 0;\\n        ListNode current = head;\\n        ListNode next=null,prev=null;\\n\\t\\t//usual linked list reversal\\n\\t\\t\\n        while(current!=null && count<k){\\n            next = current.next;\\n            current.next=prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }\\n\\t\\t//the head of the original list will now be the tail of the reversed linked list of size k\\n\\t\\t// and the next of that head is recursively assigned to what the function returns (prev)\\n        if(next!=null){\\n            ListNode temp = reverseKGroup(next,k);\\n            head.next = temp;\\n        }\\n        return prev;\\n    }\\n\\t// a helper function to check if the size of the remaining list is less than k\\n\\t// we need this to check whether we need to reverse the list or not\\n    public boolean checkLength(ListNode head,int k){\\n        ListNode start = head;\\n        int size = 0;\\n        while(start!=null){\\n            start = start.next;\\n            size++;\\n        }\\n        return size<k;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "class Solution** {\\n\\t\\n\\tpublic ListNode reverseKGroup(ListNode head, int k) {   \\n        if(checkLength(head,k))return head;\\n        int count = 0;\\n        ListNode current = head;\\n        ListNode next=null,prev=null;\\n\\t\\t//usual linked list reversal\\n\\t\\t\\n        while(current!=null && count<k){\\n            next = current.next;\\n            current.next=prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1256548,
                "title": "c-short-approach-with-explanation",
                "content": "To do:\\nReverse the starting k nodes and let recursion handle the rest nodes.\\n If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\\n \\n Give it a try :)\\n  For recusive approach we consider three steps 1)Base Case  2)Small calculation  3)Recursive call\\n \\nSTEPS:\\nstep 1. Base Case \\n * If  head==NULL (or) head->next=NULL\\n* return head \\n\\nstep 2. Samll Calculation\\n* Check if K nodes are available, and if not return head without any change\\nas mentioned in qsn **If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.**\\n* or else  Reverse the first k nodes \\n* Now head of the k nodes becomes the tail after reversing the k nodes \\n* tail of k nodes becomes head after reversing which we will return later.\\n\\nstep 3.Recursive Call\\n* perfome same process on the rest nodes using a recursive call\\n* now point the next pointer of head of small calculation to recursive call \\n* return the new head obtained in step2 after reversing k nodes \\n\\nclass Solution {\\npublic:\\n \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL) return head;\\n        if(k==1) return head; //no modification required\\n        \\n        ListNode *nTail=head;\\n        for(int i=0;i<k;i++){\\n            if(nTail==NULL) return head; //If the no. of nodes is not a multiple of k \\n                                          //then left-out nodes, in the end, should remain as it is\\n            nTail=nTail->next;\\n        }\\n  \\n        //to reverse the starting k nodes\\n        ListNode *currentNode=head;\\n        ListNode *previousNode=head;\\n        ListNode *nextNode=head;\\n        for(int i=0;i<k;i++){\\n            nextNode=currentNode->next;\\n            currentNode->next=previousNode;\\n            previousNode=currentNode;\\n            currentNode=nextNode;\\n        }\\n        \\n        head->next=reverseKGroup(currentNode,k); //head->next because staring k nodes have been reversed \\n                                                 //so head is now tail of those reversed node\\n        return previousNode;\\n    }\\n    \\n    \\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL) return head;\\n        if(k==1) return head; //no modification required\\n        \\n        ListNode *nTail=head;\\n        for(int i=0;i<k;i++){\\n            if(nTail==NULL) return head; //If the no. of nodes is not a multiple of k \\n                                          //then left-out nodes, in the end, should remain as it is\\n            nTail=nTail->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 484612,
                "title": "java-recursive-10-line-code-with-comments-beats-100",
                "content": "The idea is to use simple recursion and form the new linked list. \\nWe will start reversing the linked list in the groups of k. After reversal head will be the last of the reversed list, so we will call `reverseKGroup` for the next set of nodes and store them in head.next.\\n\\nIf we have less than k nodes remaining in our list we can reset the reversal by calling `reverseKGroup(prev, i)` as we know there are only i nodes and we don\\'t need to reverse them.\\n\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null) return null;\\n        ListNode curr = head, prev = null;\\n        \\n        for (int i = 0; i < k; i++) {\\n            if (curr == null) return reverseKGroup(prev, i); // We need to reset the nodes that have been reversed\\n            ListNode tmp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }\\n        \\n        head.next = reverseKGroup(curr, k);\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null) return null;\\n        ListNode curr = head, prev = null;\\n        \\n        for (int i = 0; i < k; i++) {\\n            if (curr == null) return reverseKGroup(prev, i); // We need to reset the nodes that have been reversed\\n            ListNode tmp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }\\n        \\n        head.next = reverseKGroup(curr, k);\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312180,
                "title": "java-recursive-solution-easiest-to-understand",
                "content": "The solution is not O(1) space though.\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode node = head;\\n        if (node == null) return node;\\n        for (int i = 0; i < k - 1; i++) {\\n            node = node.next;\\n            if (node == null) return head;\\n        }\\n        node.next = reverseKGroup(node.next, k);\\n        return reverseLinkedList(head, node.next);\\n    }\\n    \\n    private ListNode reverseLinkedList(ListNode head, ListNode tail) {\\n        ListNode p = head;\\n        ListNode prev = null;\\n        while (p != tail){\\n            ListNode tmp = p.next;\\n            p.next = prev;\\n            prev = p;\\n            p = tmp;\\n        }\\n        head.next = tail;\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode node = head;\\n        if (node == null) return node;\\n        for (int i = 0; i < k - 1; i++) {\\n            node = node.next;\\n            if (node == null) return head;\\n        }\\n        node.next = reverseKGroup(node.next, k);\\n        return reverseLinkedList(head, node.next);\\n    }\\n    \\n    private ListNode reverseLinkedList(ListNode head, ListNode tail) {\\n        ListNode p = head;\\n        ListNode prev = null;\\n        while (p != tail){\\n            ListNode tmp = p.next;\\n            p.next = prev;\\n            prev = p;\\n            p = tmp;\\n        }\\n        head.next = tail;\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276405,
                "title": "easy-to-understand-c-solution-beats-100-in-time-and-memory",
                "content": "The idea behind this is deceptively easy - it just combines several topics to make it look more intimidating. \\n\\nAre summarized description of this algorithm is : \\n\\n##### Function reverseKGroup(ListNode \\\\*head, int K) \\n\\n1. Check remaining amount of nodes and retrieve the (K+1) _th_ element if it exists. This element shall be designated \"next\".\\n2. If there\\'s less than K elements, stop.  Return head.\\n3. Otherwise, reverse the next K elements. The old head is now at the end of the K elements.\\n4. Set the next element after the old head is  **reverseKGroup(next,K)**\\n5. Return the new head.\\n\\nA C++ implementation is as follows: \\n\\n    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        ListNode* reverseKGroup(ListNode* head, int k) {\\n            ListNode *endOfGroup;\\n            // If there\\'s less than K elements, simply return the head - no further modification.\\n            if (gatherKGroup(head, endOfGroup, k) < k) return head; \\n            // Reverse the next K nodes\\n            ListNode *newHead = reverseKNodes(head,k);\\n            // Recursively reverse the rest\\n            head->next = reverseKGroup(endOfGroup,k);\\n            return newHead;\\n        }\\n    \\n        // Reverses K nodes\\n        ListNode *reverseKNodes(ListNode* node, int k) {\\n            ListNode *nextNode;\\n            ListNode *currNode = node;\\n            ListNode *prevNode = NULL;\\n            while (k > 0) {\\n                nextNode = currNode->next;\\n                currNode->next = prevNode;\\n                prevNode = currNode;\\n                currNode = nextNode;\\n                k = k-1;\\n            }\\n            return prevNode;\\n        }\\n    \\n        // This function does a few things - it finds the first element of the end of the list\\n        // And returns the amount of members, up to k.\\n        int gatherKGroup(ListNode *node, ListNode *&it, const int k) {\\n            if (node == NULL) return 0;\\n            int count = 0;\\n            while (node && count < k) {\\n                count = count+1;\\n                node = node->next;\\n            }\\n            if (count == k) it = node;\\n            return count;\\n        }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* reverseKGroup(ListNode* head, int k) {\\n            ListNode *endOfGroup;\\n            // If there\\'s less than K elements, simply return the head - no further modification.\\n            if (gatherKGroup(head, endOfGroup, k) < k) return head; \\n            // Reverse the next K nodes\\n            ListNode *newHead = reverseKNodes(head,k);\\n            // Recursively reverse the rest\\n            head->next = reverseKGroup(endOfGroup,k);\\n            return newHead;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 174192,
                "title": "java-4ms-non-recursive-solution-beats-100-o-n-time-and-o-1-memory",
                "content": "The solution itself is pretty straight forward, only thing worth noticing is the handling of pointers within each iteration, the intimidating part is the double for-loop, but it is after all just a \"reverse linked list\" problem.\\n```\\n  public ListNode reverseKGroup(ListNode head, int k) {\\n    // Count the length of the list\\n    if (head == null || k < 2) {\\n      return head;\\n    }\\n    int len = 0;\\n    ListNode ptr0 = head;\\n    while (ptr0 != null) {\\n      ptr0 = ptr0.next;\\n      len++;\\n    }\\n    if (len < k) {\\n      return head;\\n    }\\n\\t\\t\\n    // Start reversing the list\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ptr0 = dummy;\\n    ListNode ptr1 = dummy.next;\\n    for (int i = 0; i < len / k; i++) {\\n      for (int j = 0; j < k - 1; j++) { // k nodes only have k-1 links to reverse\\n        ListNode tmp = ptr1.next;\\n        ptr1.next = tmp.next;\\n        tmp.next = ptr0.next;\\n        ptr0.next = tmp;\\n      }\\n      ptr0 = ptr1;\\n      ptr1 = ptr0.next;\\n    }\\n    return dummy.next;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public ListNode reverseKGroup(ListNode head, int k) {\\n    // Count the length of the list\\n    if (head == null || k < 2) {\\n      return head;\\n    }\\n    int len = 0;\\n    ListNode ptr0 = head;\\n    while (ptr0 != null) {\\n      ptr0 = ptr0.next;\\n      len++;\\n    }\\n    if (len < k) {\\n      return head;\\n    }\\n\\t\\t\\n    // Start reversing the list\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ptr0 = dummy;\\n    ListNode ptr1 = dummy.next;\\n    for (int i = 0; i < len / k; i++) {\\n      for (int j = 0; j < k - 1; j++) { // k nodes only have k-1 links to reverse\\n        ListNode tmp = ptr1.next;\\n        ptr1.next = tmp.next;\\n        tmp.next = ptr0.next;\\n        ptr0.next = tmp;\\n      }\\n      ptr0 = ptr1;\\n      ptr1 = ptr0.next;\\n    }\\n    return dummy.next;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11573,
                "title": "share-my-java-recursive-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode temp = head;\\n        for (int i = 1; i < k && temp != null; i++, temp = temp.next);\\n        if (temp == null) return head;\\n        \\n        ListNode prev = reverseKGroup(temp.next, k);\\n        temp = head;\\n        while (k-- > 0) {\\n            ListNode post = temp.next;\\n            temp.next = prev;\\n            prev = temp;\\n            temp = post;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode temp = head;\\n        for (int i = 1; i < k && temp != null; i++, temp = temp.next);\\n        if (temp == null) return head;\\n        \\n        ListNode prev = reverseKGroup(temp.next, k);\\n        temp = head;\\n        while (k-- > 0) {\\n            ListNode post = temp.next;\\n            temp.next = prev;\\n            prev = temp;\\n            temp = post;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042248,
                "title": "c-solution-easy-to-understand",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode * reverse(ListNode * ptr, int &k, int size)\\n    {\\n        if(size < k) {\\n            return ptr;\\n        }\\n        if(ptr == NULL){\\n            return ptr;\\n        }\\n\\n        ListNode * cur = ptr;\\n        ListNode * temp = NULL;\\n        ListNode * pre = NULL;\\n        int cnt = 0;\\n        while(cur!=NULL && cnt < k)\\n        {\\n            temp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = temp;\\n            cnt++;\\n        }\\n\\n        ptr->next = reverse(temp,k,size-k);\\n        return pre;\\n    }\\n\\n    int func(ListNode * ptr)\\n    {\\n        int len = 0;\\n        while(ptr)\\n        {\\n            len++;\\n            ptr = ptr->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int n = func(head);\\n        return reverse(head,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode * reverse(ListNode * ptr, int &k, int size)\\n    {\\n        if(size < k) {\\n            return ptr;\\n        }\\n        if(ptr == NULL){\\n            return ptr;\\n        }\\n\\n        ListNode * cur = ptr;\\n        ListNode * temp = NULL;\\n        ListNode * pre = NULL;\\n        int cnt = 0;\\n        while(cur!=NULL && cnt < k)\\n        {\\n            temp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = temp;\\n            cnt++;\\n        }\\n\\n        ptr->next = reverse(temp,k,size-k);\\n        return pre;\\n    }\\n\\n    int func(ListNode * ptr)\\n    {\\n        int len = 0;\\n        while(ptr)\\n        {\\n            len++;\\n            ptr = ptr->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int n = func(head);\\n        return reverse(head,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010353,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "\\n# Approach\\nReverse k node at a time. \\nThen reduce Linked List size as size-k.\\nMake a recursive call for further nodes.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n// Reverse the node.\\n    ListNode * reverse(ListNode * ptr, int &k, int size)\\n    {\\n        if(size < k) return ptr;\\n        if(ptr == NULL) return ptr;\\n\\n        ListNode * cur = ptr, *temp = NULL, *pre = NULL;\\n        int cnt = 0;\\n        while(cur!=NULL && cnt < k)\\n        {\\n            temp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = temp;\\n            cnt++;\\n        }\\n\\n        ptr->next = reverse(temp,k,size-k);\\n        return pre;\\n    }\\n\\n// Find the length of the Linked List.\\n    int func(ListNode * ptr)\\n    {\\n        int len = 0;\\n        while(ptr)\\n        {\\n            len++;\\n            ptr = ptr->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int n = func(head);\\n        return reverse(head,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n// Reverse the node.\\n    ListNode * reverse(ListNode * ptr, int &k, int size)\\n    {\\n        if(size < k) return ptr;\\n        if(ptr == NULL) return ptr;\\n\\n        ListNode * cur = ptr, *temp = NULL, *pre = NULL;\\n        int cnt = 0;\\n        while(cur!=NULL && cnt < k)\\n        {\\n            temp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = temp;\\n            cnt++;\\n        }\\n\\n        ptr->next = reverse(temp,k,size-k);\\n        return pre;\\n    }\\n\\n// Find the length of the Linked List.\\n    int func(ListNode * ptr)\\n    {\\n        int len = 0;\\n        while(ptr)\\n        {\\n            len++;\\n            ptr = ptr->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int n = func(head);\\n        return reverse(head,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847909,
                "title": "step-by-step-recursive-c-code-with-elaborate-comments-for-better-understanding",
                "content": "# Intuition\\nThe problem requires reversing the nodes of a linked list in groups of size k. To do this, we can use a recursive approach where we reverse the first k nodes, then recursively call the function on the remaining linked list. We keep track of the previous and next nodes while reversing the current group, and the head of the reversed list is returned at each recursion level.\\n\\n# Approach\\n# \\n\\n1. Function definition: **`reverseKGroup(head, k)`**\\n2. Base case:\\n    - If the **`head`** is NULL (empty list), return NULL to indicate an empty list.\\n3. Check if the current group has enough nodes to reverse:\\n    - Traverse **`k`** nodes from the **`head`** and count the number of nodes in the current group.\\n    - If the count is less than **`k`**, it means the current group does not have enough nodes to reverse, so return the **`head`** of the group as it is.\\n4. Initialize three pointers:\\n    - **`prev`**: Points to the previous node (initially set to NULL).\\n    - **`next`**: Points to the next node (initially set to NULL).\\n    - **`curr`**: Points to the current node (initially set to **`head`**).\\n5. Reverse the current group of **`k`** nodes using a while loop:\\n    - Inside the loop, do the following k times:\\n        - Update **`next`** to **`curr->next`**.\\n        - Set **`curr->next`** to **`prev`**.\\n        - Move **`prev`** and **`curr`** to their respective next nodes.\\n    - After the loop, the current group of **`k`** nodes is reversed.\\n6. Check if there are more nodes left in the list (**`next != NULL`**):\\n    - If there are more nodes, make a recursive call to **`reverseKGroup`** with **`next`** as the new **`head`** and **`k`** as the group size.\\n    - This handles the remaining linked list and continues reversing groups until the end.\\n7. Return the **`prev`** pointer:\\n    - The **`prev`** pointer now points to the new head of the reversed list.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // base case\\n        if (head == NULL) return NULL;\\n\\n        // step 1: reverse first k nodes\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n\\n        // count the number of nodes in the current group\\n        while (curr != NULL && count < k) {\\n            curr = curr->next;\\n            count++;\\n        }\\n\\n        // if the current group has less than k nodes, no need to reverse, return the head as it is\\n        if (count < k) {\\n            return head;\\n        }\\n\\n        curr = head;\\n        count = 0;\\n\\n        while (curr != NULL && count < k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // step 2: recursive call for the remaining linked list\\n        if (next != NULL) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // step 3: return head of the reversed list\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // base case\\n        if (head == NULL) return NULL;\\n\\n        // step 1: reverse first k nodes\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n\\n        // count the number of nodes in the current group\\n        while (curr != NULL && count < k) {\\n            curr = curr->next;\\n            count++;\\n        }\\n\\n        // if the current group has less than k nodes, no need to reverse, return the head as it is\\n        if (count < k) {\\n            return head;\\n        }\\n\\n        curr = head;\\n        count = 0;\\n\\n        while (curr != NULL && count < k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // step 2: recursive call for the remaining linked list\\n        if (next != NULL) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // step 3: return head of the reversed list\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649799,
                "title": "best-solution-using-stack-20ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->store the values of nodes till k in a stack and add them back again into the list by popping them using two temp ptrs.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        stack<int> st;\\n        ListNode* temp1=head;\\n        ListNode* temp2=head;\\n        int n = 0;\\n        while(temp1!=NULL){\\n            n++;\\n            temp1=temp1->next;\\n        }\\n        temp1=head;\\n\\n        int i =0;\\n        while(i<n){\\n            if(n-i>=k){\\n                for(int r=0;r<k;r++){\\n                    st.push(temp1->val);\\n                    temp1=temp1->next;\\n                }\\n                for(int l=0;l<k;l++){\\n                    temp2->val=st.top();\\n                    st.pop();\\n                    temp2=temp2->next;\\n                }\\n                i+=k;\\n            }\\n            else{\\n                return head;\\n            }\\n          \\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        stack<int> st;\\n        ListNode* temp1=head;\\n        ListNode* temp2=head;\\n        int n = 0;\\n        while(temp1!=NULL){\\n            n++;\\n            temp1=temp1->next;\\n        }\\n        temp1=head;\\n\\n        int i =0;\\n        while(i<n){\\n            if(n-i>=k){\\n                for(int r=0;r<k;r++){\\n                    st.push(temp1->val);\\n                    temp1=temp1->next;\\n                }\\n                for(int l=0;l<k;l++){\\n                    temp2->val=st.top();\\n                    st.pop();\\n                    temp2=temp2->next;\\n                }\\n                i+=k;\\n            }\\n            else{\\n                return head;\\n            }\\n          \\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572472,
                "title": "easy-solution-using-recursion-in-java",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode temp=head;\\n        for(int i=0;i<k;i++){\\n            if(temp==null){\\n                return head;\\n            }\\n            temp=temp.next;\\n        }\\n        ListNode sp=reverseKGroup(temp,k);\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        for(int i=0;i<k;i++){\\n            ListNode after =curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=after;\\n        }\\n        head.next=sp;\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode temp=head;\\n        for(int i=0;i<k;i++){\\n            if(temp==null){\\n                return head;\\n            }\\n            temp=temp.next;\\n        }\\n        ListNode sp=reverseKGroup(temp,k);\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        for(int i=0;i<k;i++){\\n            ListNode after =curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=after;\\n        }\\n        head.next=sp;\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369195,
                "title": "my-solution-using-reverse-and-link",
                "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def link(self,a,b):\\n        r=a\\n        while a.next:\\n            a=a.next\\n        a.next=b\\n\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        h=head\\n        nh=head\\n        if head == None:\\n            return None\\n        while h.next!=None:\\n            second=nh\\n            nh=h.next \\n            h.next=nh.next\\n            nh.next=second            \\n        return nh\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        heads=[]\\n        count=0\\n        x=head\\n        while x:\\n            if count%k==0:\\n                heads.append(x)\\n            x=x.next\\n            count+=1\\n        last=None\\n        if count%k!=0:\\n            last=heads.pop()\\n        newheads=[]\\n        for i in heads:\\n            c=0\\n            t=i\\n            while c<k-1:\\n                i=i.next\\n                c+=1\\n            i.next=None\\n            newheads.append(t)\\n        reverse=[]\\n        for i in newheads:\\n            reverse.append(self.reverseList(i))\\n        print(reverse)\\n        self.link(reverse[-1],last)\\n        for i in range(len(reverse)-2,-1,-1):\\n            self.link(reverse[i],reverse[i+1])\\n        return reverse[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def link(self,a,b):\\n        r=a\\n        while a.next:\\n            a=a.next\\n        a.next=b\\n\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        h=head\\n        nh=head\\n        if head == None:\\n            return None\\n        while h.next!=None:\\n            second=nh\\n            nh=h.next \\n            h.next=nh.next\\n            nh.next=second            \\n        return nh\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        heads=[]\\n        count=0\\n        x=head\\n        while x:\\n            if count%k==0:\\n                heads.append(x)\\n            x=x.next\\n            count+=1\\n        last=None\\n        if count%k!=0:\\n            last=heads.pop()\\n        newheads=[]\\n        for i in heads:\\n            c=0\\n            t=i\\n            while c<k-1:\\n                i=i.next\\n                c+=1\\n            i.next=None\\n            newheads.append(t)\\n        reverse=[]\\n        for i in newheads:\\n            reverse.append(self.reverseList(i))\\n        print(reverse)\\n        self.link(reverse[-1],last)\\n        for i in range(len(reverse)-2,-1,-1):\\n            self.link(reverse[i],reverse[i+1])\\n        return reverse[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284555,
                "title": "java-o-n-time-and-o-1-space",
                "content": "```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int n = 0;\\n        ListNode temp = head;\\n        while(temp != null){\\n            temp  = temp.next;\\n            n++;\\n        }\\n        ListNode ddfd = new ListNode(3423);\\n        ddfd.next = head;\\n        ListNode firstNode = ddfd;\\n        ListNode tempNode = head;\\n        int ptr = 1;\\n        int kptr = 1;\\n        ListNode cur = head;\\n        ListNode prev = null;\\n        if(k == 1) return ddfd.next;\\n        while(cur != null){\\n            ListNode next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n           // tempNode.next = null;\\n            if(kptr == k){\\n                firstNode.next = prev;\\n                firstNode = tempNode;\\n                firstNode.next = null;\\n                tempNode = cur;\\n                kptr = 0;\\n                if(ptr + k > n ){\\n                    firstNode.next = cur;\\n                    //System.out.println(\"breaked \" + ptr + \" \" + firstNode.val);\\n                    return ddfd.next;\\n                }\\n            }\\n            \\n            ptr++;\\n            kptr++;\\n        }\\n        return ddfd.next;\\n    }\\n    \\n}\\n```\\n# Please UpVote, If Found Useful :)",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int n = 0;\\n        ListNode temp = head;\\n        while(temp != null){\\n            temp  = temp.next;\\n            n++;\\n        }\\n        ListNode ddfd = new ListNode(3423);\\n        ddfd.next = head;\\n        ListNode firstNode = ddfd;\\n        ListNode tempNode = head;\\n        int ptr = 1;\\n        int kptr = 1;\\n        ListNode cur = head;\\n        ListNode prev = null;\\n        if(k == 1) return ddfd.next;\\n        while(cur != null){\\n            ListNode next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n           // tempNode.next = null;\\n            if(kptr == k){\\n                firstNode.next = prev;\\n                firstNode = tempNode;\\n                firstNode.next = null;\\n                tempNode = cur;\\n                kptr = 0;\\n                if(ptr + k > n ){\\n                    firstNode.next = cur;\\n                    //System.out.println(\"breaked \" + ptr + \" \" + firstNode.val);\\n                    return ddfd.next;\\n                }\\n            }\\n            \\n            ptr++;\\n            kptr++;\\n        }\\n        return ddfd.next;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284421,
                "title": "c-solution-with-iterative-approach",
                "content": "# Intuition\\nWe can traverse the Linked List in the group of `k` by traversing the List if `k` nodes are present in the further groups. In the end we can return the new head by putting it at the last node of first group.\\n\\n\\n\\n# Approach\\n1. We count the `length` of the whole list by iterating once over the list.\\n2. Then traverse the list `length/k` times to reverse the groups in `k` and by not reversing the nodes in the group remaining with less number of nodes than `k`.\\n3. Now after the reversal of first group of with `k` nodes we will have new head which is `prev` in this code. Here, we maintain one `bool isFirstGrp` to check if it is the first group or not, if it is than we assign `head` with the `prev`.\\n4. With another while loop which runs for `k` times for each group we perform the actual reverse operation.\\n5. After reversing the `k` nodes we attach the reversed node to the next remaning list by `firstOfPrev->next=prev`.\\n6. After traversing `length/k` times if there is one group of nodes with number of nodes less than `k` we will attach that list to the last reversed list with `firstOfPrev->next=curr` and will return `head`.\\n\\n# Complexity\\n- Time complexity:\\nIf there are \\'n\\' the given list then the for loop runs for $$O(n/k)$$ times and inner while loop runs for $$O(k)$$ times. n/k * k = n. Therefore, time complexity will be $$O(n)$$.\\n- Space complexity:\\nOnly constant space is used, therefore, space complexity = $$O(1)$$.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        int length=0;\\n\\n        //find length of the list\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            length++;\\n        }\\n\\n        bool isFirstGrp=1;                    \\n        ListNode* curr=head;\\n        ListNode* firstOfPrev=NULL;\\n        for(int i=0;i<length/k;i++){\\n            ListNode* prev=NULL;\\n            ListNode* first=curr;\\n            int cnt=0;\\n            //reversing the list with \\'k\\' nodes\\n            while(curr!=NULL && cnt<k){\\n                ListNode* next=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=next;\\n                cnt++;\\n            }\\n            //If its first group \\'head\\' will be \\'prev\\'\\n            if(isFirstGrp){\\n                head=prev;\\n                isFirstGrp=0;\\n            }\\n            else{\\n                //attaching the reversed list with the remaining list\\n                firstOfPrev->next=prev;\\n            }\\n            firstOfPrev=first;\\n            //if its the last group with \\'k\\' nodes connecting\\n            //it with the remaining nodes less than \\'k\\'\\n            firstOfPrev->next=curr;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\nUPVOTE :)",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        int length=0;\\n\\n        //find length of the list\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            length++;\\n        }\\n\\n        bool isFirstGrp=1;                    \\n        ListNode* curr=head;\\n        ListNode* firstOfPrev=NULL;\\n        for(int i=0;i<length/k;i++){\\n            ListNode* prev=NULL;\\n            ListNode* first=curr;\\n            int cnt=0;\\n            //reversing the list with \\'k\\' nodes\\n            while(curr!=NULL && cnt<k){\\n                ListNode* next=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=next;\\n                cnt++;\\n            }\\n            //If its first group \\'head\\' will be \\'prev\\'\\n            if(isFirstGrp){\\n                head=prev;\\n                isFirstGrp=0;\\n            }\\n            else{\\n                //attaching the reversed list with the remaining list\\n                firstOfPrev->next=prev;\\n            }\\n            firstOfPrev=first;\\n            //if its the last group with \\'k\\' nodes connecting\\n            //it with the remaining nodes less than \\'k\\'\\n            firstOfPrev->next=curr;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068608,
                "title": "c-easy-and-fast-recursive-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool length(ListNode* head, int k)\\n    {\\n        while(k and head)\\n        {\\n            head = head->next;\\n            k--;\\n        }\\n        return k==0;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *curr = head, *prev=NULL, *forward, *first = head;\\n        if(k==1) return head;\\n        if(!length(head, k)) return head;\\n\\n        for(int i=0;i<k;i++)\\n        {\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        // curr->next = NULL;\\n        head = prev;\\n        first->next = reverseKGroup(forward, k);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool length(ListNode* head, int k)\\n    {\\n        while(k and head)\\n        {\\n            head = head->next;\\n            k--;\\n        }\\n        return k==0;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *curr = head, *prev=NULL, *forward, *first = head;\\n        if(k==1) return head;\\n        if(!length(head, k)) return head;\\n\\n        for(int i=0;i<k;i++)\\n        {\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        // curr->next = NULL;\\n        head = prev;\\n        first->next = reverseKGroup(forward, k);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056035,
                "title": "c-easy-and-clean-solution-with-comments-recursive-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // Base condition\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n\\n        // Three pointer approach\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward;\\n\\n        // Check whether \\'k\\' no. of nodes present in list or not\\n        if(!possible(head, k)){\\n            return head;\\n        }\\n\\n        // Reverse first \\'K\\' Nodes\\n        for(int i=0; i<k; i++){\\n            forward = curr->next;\\n\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n\\n            if(curr == NULL){\\n                return prev;\\n            }\\n        }\\n\\n        // Connect first \\'K\\' nodes with rest of the list\\n        head -> next = reverseKGroup(curr, k);\\n\\n        return prev;\\n    }\\n\\n    bool possible(ListNode* head, int k){\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n        while(temp != NULL){\\n            temp=temp->next;\\n            length++;\\n\\n            // If at any point, length become greater than K, then return true\\n            if(length >= k){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // Base condition\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n\\n        // Three pointer approach\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward;\\n\\n        // Check whether \\'k\\' no. of nodes present in list or not\\n        if(!possible(head, k)){\\n            return head;\\n        }\\n\\n        // Reverse first \\'K\\' Nodes\\n        for(int i=0; i<k; i++){\\n            forward = curr->next;\\n\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n\\n            if(curr == NULL){\\n                return prev;\\n            }\\n        }\\n\\n        // Connect first \\'K\\' nodes with rest of the list\\n        head -> next = reverseKGroup(curr, k);\\n\\n        return prev;\\n    }\\n\\n    bool possible(ListNode* head, int k){\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n        while(temp != NULL){\\n            temp=temp->next;\\n            length++;\\n\\n            // If at any point, length become greater than K, then return true\\n            if(length >= k){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676238,
                "title": "c-recursive-solution",
                "content": "```\\n//Recursive Solution\\n\\n//Function for finding length of a node\\nint getLength(ListNode *head)\\n{\\n    int count = 0;\\n    while (head)\\n    {\\n        count++;\\n        head = head->next;\\n    }\\n    return count;\\n}\\n\\n\\nListNode* ReverseList(ListNode *head, int k, int length)\\n{\\n\\n   \\t//Base case \\n    if (length < k) return head;\\n\\n   \\t//step 1 -> reverse first k element\\n    ListNode *previous = NULL;\\n    ListNode *current = head;\\n    ListNode *forward = NULL;\\n    int count = 0;\\n\\n    while ((current != NULL) && (count < k))\\n    {\\n        forward = current->next;\\n        current->next = previous;\\n\\n       \\t// 1 step sabhi ko aage badhaoo\\n        previous = current;\\n        current = forward;\\n        count++;\\n    }\\n\\n   \\t//Step 2 -> Make a recursive call if node is avilable after k\\n\\n    if (forward != NULL)\\n    {\\n        head->next = ReverseList(forward, k, length - k);\\n    }\\n\\n   \\t//step 3 -> return previous beacuse eventually our previous become head of given Node\\n    return previous;\\n}\\n\\n\\nclass Solution\\n{\\n    public:\\n        ListNode* reverseKGroup(ListNode *head, int k)\\n        {\\n            int length = getLength(head);\\n            return ReverseList(head, k, length);\\n        }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//Recursive Solution\\n\\n//Function for finding length of a node\\nint getLength(ListNode *head)\\n{\\n    int count = 0;\\n    while (head)\\n    {\\n        count++;\\n        head = head->next;\\n    }\\n    return count;\\n}\\n\\n\\nListNode* ReverseList(ListNode *head, int k, int length)\\n{\\n\\n   \\t//Base case \\n    if (length < k) return head;\\n\\n   \\t//step 1 -> reverse first k element\\n    ListNode *previous = NULL;\\n    ListNode *current = head;\\n    ListNode *forward = NULL;\\n    int count = 0;\\n\\n    while ((current != NULL) && (count < k))\\n    {\\n        forward = current->next;\\n        current->next = previous;\\n\\n       \\t// 1 step sabhi ko aage badhaoo\\n        previous = current;\\n        current = forward;\\n        count++;\\n    }\\n\\n   \\t//Step 2 -> Make a recursive call if node is avilable after k\\n\\n    if (forward != NULL)\\n    {\\n        head->next = ReverseList(forward, k, length - k);\\n    }\\n\\n   \\t//step 3 -> return previous beacuse eventually our previous become head of given Node\\n    return previous;\\n}\\n\\n\\nclass Solution\\n{\\n    public:\\n        ListNode* reverseKGroup(ListNode *head, int k)\\n        {\\n            int length = getLength(head);\\n            return ReverseList(head, k, length);\\n        }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616355,
                "title": "c-solution-easily-understandable-well-commented",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseList(struct ListNode* head)\\n{\\n    struct ListNode *prev = NULL, *curr = head, *nxt = NULL;\\n    \\n    while (curr != NULL) {\\n        nxt = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = nxt;\\n    }\\n    \\n    return prev;\\n}\\n\\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    // return head if there is 0/1 element in the list \\n    if (head == NULL || head->next == NULL)\\n        return head;\\n    \\n    struct ListNode *curr = head, *prev = head, *nxt = NULL;\\n    struct ListNode *lastTail = NULL, *retHead = NULL;\\n    struct ListNode *reverse = NULL;\\n    \\n    while (curr != NULL) {\\n        /*\\n\\t\\t * create a k-distance between the prev and curr node\\n\\t\\t * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL\\n\\t\\t * further we reverse the sub-list 1->2->3\\n\\t\\t */\\n        for (int i = 0; i < k - 1 && curr != NULL; i++)\\n            curr = curr->next;\\n        /*\\n         * if the curr has reached the end-point, \\n         * then there aren\\'t enough k-elements to\\n         * to reverse k-groups => Leaving the rest of\\n         * the list as it is\\n         */\\n        if (curr == NULL)\\n            return retHead;\\n        \\n        nxt = curr->next;\\n        curr->next = NULL;\\n        \\n        // reverse the elemnts in the k-group\\n        reverse = reverseList(prev);\\n        \\n        // keep track of the head node to be returned.\\n        if (retHead == NULL)\\n            retHead = reverse;\\n        \\n        // keep a track of the tail of the previously reversed k-group set\\n        if (lastTail != NULL)\\n            lastTail->next = reverse;\\n        lastTail = prev;\\n        \\n        // updating all pointers for the next set of k-group\\n        prev->next = nxt;\\n        curr = nxt;\\n        prev = curr;\\n    }\\n    \\n    return retHead;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseList(struct ListNode* head)\\n{\\n    struct ListNode *prev = NULL, *curr = head, *nxt = NULL;\\n    \\n    while (curr != NULL) {\\n        nxt = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = nxt;\\n    }\\n    \\n    return prev;\\n}\\n\\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    // return head if there is 0/1 element in the list \\n    if (head == NULL || head->next == NULL)\\n        return head;\\n    \\n    struct ListNode *curr = head, *prev = head, *nxt = NULL;\\n    struct ListNode *lastTail = NULL, *retHead = NULL;\\n    struct ListNode *reverse = NULL;\\n    \\n    while (curr != NULL) {\\n        /*\\n\\t\\t * create a k-distance between the prev and curr node\\n\\t\\t * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL\\n\\t\\t * further we reverse the sub-list 1->2->3\\n\\t\\t */\\n        for (int i = 0; i < k - 1 && curr != NULL; i++)\\n            curr = curr->next;\\n        /*\\n         * if the curr has reached the end-point, \\n         * then there aren\\'t enough k-elements to\\n         * to reverse k-groups => Leaving the rest of\\n         * the list as it is\\n         */\\n        if (curr == NULL)\\n            return retHead;\\n        \\n        nxt = curr->next;\\n        curr->next = NULL;\\n        \\n        // reverse the elemnts in the k-group\\n        reverse = reverseList(prev);\\n        \\n        // keep track of the head node to be returned.\\n        if (retHead == NULL)\\n            retHead = reverse;\\n        \\n        // keep a track of the tail of the previously reversed k-group set\\n        if (lastTail != NULL)\\n            lastTail->next = reverse;\\n        lastTail = prev;\\n        \\n        // updating all pointers for the next set of k-group\\n        prev->next = nxt;\\n        curr = nxt;\\n        prev = curr;\\n    }\\n    \\n    return retHead;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2166263,
                "title": "simple-java-solution-iterative-easy-to-understand-100-accepted",
                "content": "```\\n// Appraoch: Traverse the list and cut the list of k size and reverse it an so on.\\n\\npublic ListNode reverse(ListNode head){\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(curr != null){\\n            ListNode forw = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forw;\\n        }\\n        return prev;\\n    }\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head == null || head.next == null || k < 0)\\n            return head;\\n        ListNode curr = head;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode dp = dummy;\\n        \\n        while(curr != null){\\n            ListNode forw = curr;\\n            int temp = k;\\n            ListNode nhead;\\n            while(temp-- > 1 && forw != null){\\n                forw = forw.next;\\n            }\\n            if(forw != null){\\n                nhead = forw.next;\\n                forw.next = null;\\n            }else{\\n                break;\\n            }\\n            dp.next = reverse(curr);\\n            while(dp.next != null)\\n                dp = dp.next;\\n            curr = nhead;\\n        }\\n        dp.next = curr;\\n        return dummy.next;\\n    }\\n\\n**All suggestions are honoured**\\n\\n**UPVOTE IF YOU LIKE IT **",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n// Appraoch: Traverse the list and cut the list of k size and reverse it an so on.\\n\\npublic ListNode reverse(ListNode head){\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(curr != null){\\n            ListNode forw = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forw;\\n        }\\n        return prev;\\n    }\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head == null || head.next == null || k < 0)\\n            return head;\\n        ListNode curr = head;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode dp = dummy;\\n        \\n        while(curr != null){\\n            ListNode forw = curr;\\n            int temp = k;\\n            ListNode nhead;\\n            while(temp-- > 1 && forw != null){\\n                forw = forw.next;\\n            }\\n            if(forw != null){\\n                nhead = forw.next;\\n                forw.next = null;\\n            }else{\\n                break;\\n            }\\n            dp.next = reverse(curr);\\n            while(dp.next != null)\\n                dp = dp.next;\\n            curr = nhead;\\n        }\\n        dp.next = curr;\\n        return dummy.next;\\n    }\\n\\n**All suggestions are honoured**\\n\\n**UPVOTE IF YOU LIKE IT **",
                "codeTag": "Unknown"
            },
            {
                "id": 2154889,
                "title": "java-0ms-100-faster-easy-solution",
                "content": "# Please Upvote IF You Find This Helpful\\n![image](https://assets.leetcode.com/users/images/eaeceec3-5d52-4977-9f28-02b1662e5ead_1655296087.9395077.png)\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k == 1) return head;\\n        int count = 1;\\n        ListNode node = head, tempHead = head, tempPrev = null;\\n        while (node != null) {\\n            if (count == k) {\\n                ListNode tempLast = node.next;\\n                node.next = null;\\n                if (tempHead == head) head = reverseList(tempHead);\\n                else tempPrev.next = reverseList(tempHead);\\n                tempHead.next = tempLast;\\n                tempPrev = node = tempHead;\\n                tempHead = tempHead.next;\\n                count = 0;\\n            }\\n            count++;\\n            node = node.next;\\n        }\\n        return head;\\n    }\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next = curr == null ? null : head.next;\\n        while (curr != null) {\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            next = next == null ? next  : next.next;\\n        }\\n        return prev;\\n    }\\n}\\n```\\n# Please Upvote IF You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k == 1) return head;\\n        int count = 1;\\n        ListNode node = head, tempHead = head, tempPrev = null;\\n        while (node != null) {\\n            if (count == k) {\\n                ListNode tempLast = node.next;\\n                node.next = null;\\n                if (tempHead == head) head = reverseList(tempHead);\\n                else tempPrev.next = reverseList(tempHead);\\n                tempHead.next = tempLast;\\n                tempPrev = node = tempHead;\\n                tempHead = tempHead.next;\\n                count = 0;\\n            }\\n            count++;\\n            node = node.next;\\n        }\\n        return head;\\n    }\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next = curr == null ? null : head.next;\\n        while (curr != null) {\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            next = next == null ? next  : next.next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051653,
                "title": "java-super-easy-code-100-fast",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        \\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode temp = head;\\n        \\n        int count = 0;  // to only execute the reverse function for k times\\n        \\n        // check if there are enough elements ahead for k to run\\n        \\n        int check = k;\\n        \\n        while(check != 0)\\n        {\\n            if(temp == null)\\n            {\\n                return head;\\n            }\\n            temp = temp.next;\\n            check--;\\n        }\\n        \\n        while(curr != null && count < k)\\n        {\\n            temp = curr.next;\\n            \\n            curr.next = prev;\\n            \\n            prev = curr;\\n            curr = temp;\\n            \\n            count++;\\n        }\\n        \\n        if(temp != null)\\n        {\\n            head.next = reverseKGroup(temp, k);    // it will attach the head to the head of the newly transformed (reversed) linked list\\n        }\\n        \\n        return prev;    // the reason of returning this prev is - how internally the recursion function call works\\n        \\n        // Consider an example of 1->2->3->4 with k = 2\\n        // after the reverse in first iteration we will get \\n        // null<-1-<2    3->4->null\\n        // here prev = 2, and head = 1\\n        // now after second iteration - with the head.next part\\n        // 2->1->4->3\\n        // in second iteration prev = 4, and head = 3\\n        // but, in the case of recursion - when we return them it takes its parent value which was originally 2\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        \\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode temp = head;\\n        \\n        int count = 0;  // to only execute the reverse function for k times\\n        \\n        // check if there are enough elements ahead for k to run\\n        \\n        int check = k;\\n        \\n        while(check != 0)\\n        {\\n            if(temp == null)\\n            {\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1776121,
                "title": "best-solution-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\n\\t    // base case\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\t\\t\\n        //checking for reversing or not \\n        ListNode* temp=head;\\n        int cnt=0;\\n        while(temp!=NULL && cnt<k){\\n            temp = temp->next;\\n            cnt++;\\n        }\\n        \\n        if(cnt!=k)\\n            return head;\\n        \\n        //reversing in the window of size k\\n        ListNode* curr=head;\\n        ListNode* next = NULL;\\n        ListNode* prev=NULL;\\n        int count =0;\\n        \\n        while(curr!=NULL && count<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            count++;\\n        }\\n        \\n\\t\\t//recursion call\\n        if(next!=NULL){\\n              head->next = reverseKGroup(next,k);\\n        }\\n\\n        return prev;\\n    }\\n};\\n```\\n\\n# ****PLEASE UPVOTE",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\n\\t    // base case\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\t\\t\\n        //checking for reversing or not \\n        ListNode* temp=head;\\n        int cnt=0;\\n        while(temp!=NULL && cnt<k){\\n            temp = temp->next;\\n            cnt++;\\n        }\\n        \\n        if(cnt!=k)\\n            return head;\\n        \\n        //reversing in the window of size k\\n        ListNode* curr=head;\\n        ListNode* next = NULL;\\n        ListNode* prev=NULL;\\n        int count =0;\\n        \\n        while(curr!=NULL && count<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            count++;\\n        }\\n        \\n\\t\\t//recursion call\\n        if(next!=NULL){\\n              head->next = reverseKGroup(next,k);\\n        }\\n\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248374,
                "title": "javascript-iterative",
                "content": "```\\nvar reverseKGroup = function (head, k) {\\n    const reverseNextKNodes = (head, k) => {\\n        let tempHead = head;\\n        for (let i = 0; i < k; i++) {\\n            if (tempHead.next === null) {\\n                return tempHead;\\n            }\\n            tempHead = tempHead.next;\\n        }\\n\\n        let nodeFirst = head.next;\\n        let prevNode = head;\\n        let currentNode = nodeFirst;\\n        for (let i = 0; i < k; i++) {\\n            let temp = currentNode.next;\\n            currentNode.next = prevNode;\\n            prevNode = currentNode;\\n            currentNode = temp;\\n        }\\n\\n        nodeFirst.next = currentNode;\\n        head.next = prevNode;\\n\\n        return nodeFirst;\\n    }\\n\\n    if (head === null || k <= 1) {\\n        return head;\\n    }\\n\\n    const tempNode = new ListNode(0);\\n    tempNode.next = head;\\n\\n    head = tempNode;\\n    while (head.next !== null) {\\n        head = reverseNextKNodes(head, k);\\n    }\\n\\n    return tempNode.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar reverseKGroup = function (head, k) {\\n    const reverseNextKNodes = (head, k) => {\\n        let tempHead = head;\\n        for (let i = 0; i < k; i++) {\\n            if (tempHead.next === null) {\\n                return tempHead;\\n            }\\n            tempHead = tempHead.next;\\n        }\\n\\n        let nodeFirst = head.next;\\n        let prevNode = head;\\n        let currentNode = nodeFirst;\\n        for (let i = 0; i < k; i++) {\\n            let temp = currentNode.next;\\n            currentNode.next = prevNode;\\n            prevNode = currentNode;\\n            currentNode = temp;\\n        }\\n\\n        nodeFirst.next = currentNode;\\n        head.next = prevNode;\\n\\n        return nodeFirst;\\n    }\\n\\n    if (head === null || k <= 1) {\\n        return head;\\n    }\\n\\n    const tempNode = new ListNode(0);\\n    tempNode.next = head;\\n\\n    head = tempNode;\\n    while (head.next !== null) {\\n        head = reverseNextKNodes(head, k);\\n    }\\n\\n    return tempNode.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128578,
                "title": "best-self-explanatory-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int count = 0;\\n        ListNode *curr = head;\\n        ListNode *prev = nullptr;\\n        ListNode *next = nullptr;\\n        \\n        ListNode *pCrawl = head;\\n        \\n        while(pCrawl) {\\n            count++;\\n            pCrawl = pCrawl->next;\\n        }\\n        \\n        if(count < k) return curr;\\n        else count = 0;\\n        \\n        while(count < k && curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        if(next) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int count = 0;\\n        ListNode *curr = head;\\n        ListNode *prev = nullptr;\\n        ListNode *next = nullptr;\\n        \\n        ListNode *pCrawl = head;\\n        \\n        while(pCrawl) {\\n            count++;\\n            pCrawl = pCrawl->next;\\n        }\\n        \\n        if(count < k) return curr;\\n        else count = 0;\\n        \\n        while(count < k && curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        if(next) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529672,
                "title": "javascript-with-comments-easy-understand-by-iteration-and-recursion",
                "content": "```javascript\\n/**\\n * 25. Reverse Nodes in k-Group\\n * https://leetcode.com/problems/reverse-nodes-in-k-group/\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nconst reverseKGroup = (head, k) => {\\n  if (head === null) return head\\n  // define startNode and endNode\\n  let start = head, end = head\\n  \\n  // return self if linked list\\'s length is smaller than k\\n  for (let i = 0; i < k; i++) {\\n    if (end === null) return head\\n    end = end.next\\n  }\\n  // reverse from startNode to endNode\\n  let newHead = reverse(start, end)\\n  // recursive the rest nodes and concat the result\\n  start.next = reverseKGroup(end, k)\\n  return newHead\\n};\\n\\n// reverse from startNode to endNode\\nconst reverse = (start, end) => {\\n  let [prev, curr] = [null, start]\\n  while (curr != end) [curr.next, prev, curr] = [prev, curr, curr.next]\\n  return prev\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```javascript\\n/**\\n * 25. Reverse Nodes in k-Group\\n * https://leetcode.com/problems/reverse-nodes-in-k-group/\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nconst reverseKGroup = (head, k) => {\\n  if (head === null) return head\\n  // define startNode and endNode\\n  let start = head, end = head\\n  \\n  // return self if linked list\\'s length is smaller than k\\n  for (let i = 0; i < k; i++) {\\n    if (end === null) return head\\n    end = end.next\\n  }\\n  // reverse from startNode to endNode\\n  let newHead = reverse(start, end)\\n  // recursive the rest nodes and concat the result\\n  start.next = reverseKGroup(end, k)\\n  return newHead\\n};\\n\\n// reverse from startNode to endNode\\nconst reverse = (start, end) => {\\n  let [prev, curr] = [null, start]\\n  while (curr != end) [curr.next, prev, curr] = [prev, curr, curr.next]\\n  return prev\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389483,
                "title": "easy-to-understand-iterative-way-in-java-with-detailed-comments",
                "content": "```\\n\\tpublic class ListNode {\\n\\t\\tint val;\\n\\t\\tListNode next;\\n\\n\\t\\tListNode(int x) {\\n\\t\\t\\tval = x;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"ListNode [val=\" + val + \", next=\" + next + \"]\";\\n\\t\\t}\\n\\n\\t}\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n                \\n        ListNode preOfGroupHead = dummy;\\n        ListNode groupHead = head; // the head node in this group\\n        ListNode groupNode = head; // the node that is used for traversal in this group\\n        ListNode groupTail = head; // the tail node in this group\\n\\n        while(true){\\n            int count = 1;\\n            while(count <= k && groupNode != null){ // if a group of K nodes have been traversed\\n                groupTail = groupNode;\\n                groupNode = groupNode.next;\\n                count ++;\\n            }\\n                        \\n            if(count <= k){ // a group has less then k nodes, aka the last group\\n                break;\\n            }\\n            \\n            // now, groupTail is the tail of current group\\n            // groupNode is the head of next group\\n            \\n            // preOfGroupHead -> (groupHead -> ... -> groupTail) -> groupNode\\n            reverseK(groupHead, k);\\n            \\n            // preOfGroupHead ? groupTail -> ... -> groupHead ? groupNode\\n            \\n            preOfGroupHead.next = groupTail;\\n            groupHead.next = groupNode;\\n            \\n            // preOfGroupHead -> groupTail -> ... -> groupHead -> groupNode\\n            preOfGroupHead = groupHead;\\n            groupHead = groupNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    /**\\n     * Reverse k linked nodes from head \\n     * this method returns nothing, because we\\'ve got left node and right node of the reversed part\\n     * @param head\\n     * @param k\\n     */\\n    private void reverseK(ListNode head, int k){\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(k > 0){\\n            ListNode tmpNext = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmpNext;\\n            k --;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n\\tpublic class ListNode {\\n\\t\\tint val;\\n\\t\\tListNode next;\\n\\n\\t\\tListNode(int x) {\\n\\t\\t\\tval = x;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"ListNode [val=\" + val + \", next=\" + next + \"]\";\\n\\t\\t}\\n\\n\\t}\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n                \\n        ListNode preOfGroupHead = dummy;\\n        ListNode groupHead = head; // the head node in this group\\n        ListNode groupNode = head; // the node that is used for traversal in this group\\n        ListNode groupTail = head; // the tail node in this group\\n\\n        while(true){\\n            int count = 1;\\n            while(count <= k && groupNode != null){ // if a group of K nodes have been traversed\\n                groupTail = groupNode;\\n                groupNode = groupNode.next;\\n                count ++;\\n            }\\n                        \\n            if(count <= k){ // a group has less then k nodes, aka the last group\\n                break;\\n            }\\n            \\n            // now, groupTail is the tail of current group\\n            // groupNode is the head of next group\\n            \\n            // preOfGroupHead -> (groupHead -> ... -> groupTail) -> groupNode\\n            reverseK(groupHead, k);\\n            \\n            // preOfGroupHead ? groupTail -> ... -> groupHead ? groupNode\\n            \\n            preOfGroupHead.next = groupTail;\\n            groupHead.next = groupNode;\\n            \\n            // preOfGroupHead -> groupTail -> ... -> groupHead -> groupNode\\n            preOfGroupHead = groupHead;\\n            groupHead = groupNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    /**\\n     * Reverse k linked nodes from head \\n     * this method returns nothing, because we\\'ve got left node and right node of the reversed part\\n     * @param head\\n     * @param k\\n     */\\n    private void reverseK(ListNode head, int k){\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(k > 0){\\n            ListNode tmpNext = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmpNext;\\n            k --;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313274,
                "title": "c-sol-beats-100-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* ptr = head, *nptr = NULL, *pptr = NULL;\\n        int count = 0;\\n        int size = 0;\\n        while(ptr){\\n            ptr = ptr->next;\\n            size++;\\n        }\\n        if(size < k){\\n            return head;\\n        }\\n        ptr = head;\\n        while(ptr && count < k){\\n            nptr = ptr->next;\\n            ptr->next = pptr;\\n            pptr = ptr;\\n            ptr = nptr;\\n            count++;\\n        }\\n        if(nptr != NULL)\\n            head->next = reverseKGroup(nptr, k);\\n        return pptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* ptr = head, *nptr = NULL, *pptr = NULL;\\n        int count = 0;\\n        int size = 0;\\n        while(ptr){\\n            ptr = ptr->next;\\n            size++;\\n        }\\n        if(size < k){\\n            return head;\\n        }\\n        ptr = head;\\n        while(ptr && count < k){\\n            nptr = ptr->next;\\n            ptr->next = pptr;\\n            pptr = ptr;\\n            ptr = nptr;\\n            count++;\\n        }\\n        if(nptr != NULL)\\n            head->next = reverseKGroup(nptr, k);\\n        return pptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11582,
                "title": "simple-java-iterative-solution-with-explanation",
                "content": "The basic idea is  for each step,we set the the node after `head` as the list's new head, so that `head` then is `tail`. After reversing k nodes, we update the references and iterate through the whole list. If the size of the list is a multiple of k, the list is safely returned. Otherwise, a recursive call is made on the left-out nodes to undo the reverse.  So the whole iteration times will be `(n + n%k)`\\n\\n Here is an example of how it works(case of K = 3):\\n\\nInitial:\\n\\n    sentinel -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 ->...\\n        |       |    |\\n      dummy    tail newHead   \\nSet the node after tail @newHead as the new head. And the list:\\n\\n    sentinel -> 2 -> 1 -> 3 -> 4 -> 5 -> 6 ->...\\n        |            |    |\\n      dummy        tail newHead\\nSet node after tail as new Head:\\n    \\n     sentinel -> 3 -> 2 -> 1 -> 4 -> 5 -> 6 ->...\\n        |                  |\\n      dummy               tail   \\n3 nodes are reversed. Update the references:\\n\\n    sentinel -> 3 -> 2 -> 1 -> 4 -> 5 -> 6 ->...\\n                          |    |    |\\n                        dummy tail newHead   \\n\\nHere is code:\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (k < 2 || head == null) return head;\\n        ListNode sentinel = new ListNode(0);\\n        sentinel.next = head;\\n        ListNode dummy = sentinel, tail = head, newHead;\\n        While (true) {\\n            int count = k - 1;\\n            while (count > 0) {\\n                if (tail.next != null) {\\n                    newHead = tail.next;\\n                    tail.next = newHead.next;\\n                    newHead.next = dummy.next;\\n                    dummy.next = newHead;\\n                    count--;\\n                } else { \\n                    /// list size is not multiple of k, a recursive call on the left-out nodes to undo the reverse\\n                    dummy.next = reverseKGroup(dummy.next, k - count);\\n                    return sentinel.next;\\n                }\\n            }\\n            if (tail.next == null) return sentinel.next; /// list size is multiple of k, safely return\\n            dummy = tail;\\n            tail = tail.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The basic idea is  for each step,we set the the node after `head` as the list's new head, so that `head` then is `tail`. After reversing k nodes, we update the references and iterate through the whole list. If the size of the list is a multiple of k, the list is safely returned. Otherwise, a recursive call is made on the left-out nodes to undo the reverse.  So the whole iteration times will be `(n + n%k)`\\n\\n Here is an example of how it works(case of K = 3):\\n\\nInitial:\\n\\n    sentinel -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 ->...\\n        |       |    |\\n      dummy    tail newHead   \\nSet the node after tail @newHead as the new head. And the list:\\n\\n    sentinel -> 2 -> 1 -> 3 -> 4 -> 5 -> 6 ->...\\n        |            |    |\\n      dummy        tail newHead\\nSet node after tail as new Head:\\n    \\n     sentinel -> 3 -> 2 -> 1 -> 4 -> 5 -> 6 ->...\\n        |                  |\\n      dummy               tail   \\n3 nodes are reversed. Update the references:\\n\\n    sentinel -> 3 -> 2 -> 1 -> 4 -> 5 -> 6 ->...\\n                          |    |    |\\n                        dummy tail newHead   \\n\\nHere is code:\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (k < 2 || head == null) return head;\\n        ListNode sentinel = new ListNode(0);\\n        sentinel.next = head;\\n        ListNode dummy = sentinel, tail = head, newHead;\\n        While (true) {\\n            int count = k - 1;\\n            while (count > 0) {\\n                if (tail.next != null) {\\n                    newHead = tail.next;\\n                    tail.next = newHead.next;\\n                    newHead.next = dummy.next;\\n                    dummy.next = newHead;\\n                    count--;\\n                } else { \\n                    /// list size is not multiple of k, a recursive call on the left-out nodes to undo the reverse\\n                    dummy.next = reverseKGroup(dummy.next, k - count);\\n                    return sentinel.next;\\n                }\\n            }\\n            if (tail.next == null) return sentinel.next; /// list size is multiple of k, safely return\\n            dummy = tail;\\n            tail = tail.next;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11596,
                "title": "my-recursive-c-solution-easy-to-understand",
                "content": "class Solution {\\n\\npublic:\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        for (int i=1; i<k; i++){\\n            if (!temp) return head;\\n            temp = temp->next;\\n        }\\n        ListNode* pre = NULL;\\n        if (!temp) return head;\\n        else pre = reverseKGroup(temp->next, k);\\n        ListNode* cur = head;\\n        ListNode* next;\\n        //reverse k nodes\\n        for (int i=1; i<k; i++){\\n            next = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = next;\\n        }\\n        cur->next = pre;\\n        return cur;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        for (int i=1; i<k; i++){\\n            if (!temp) return head;\\n            temp = temp->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11676,
                "title": "64ms-python-solution-1",
                "content": "It says it runs only 64 ms, in Python?! I don't buy that. But whatever.\\n\\n    class Solution(object):\\n    def reverseKGroup(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return head\\n\\n        tail = head\\n        for i in range(k):\\n            if not tail:\\n                return head\\n\\n            tail = tail.next\\n\\n        tail = self.reverseKGroup(tail, k)\\n\\n        for i in range(k):\\n            next = head.next\\n            head.next = tail\\n            tail = head\\n            head = next\\n\\n        return tail",
                "solutionTags": [
                    "Python"
                ],
                "code": "It says it runs only 64 ms, in Python?! I don't buy that. But whatever.\\n\\n    class Solution(object):\\n    def reverseKGroup(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return head\\n\\n        tail = head\\n        for i in range(k):\\n            if not tail:\\n                return head\\n\\n            tail = tail.next\\n\\n        tail = self.reverseKGroup(tail, k)\\n\\n        for i in range(k):\\n            next = head.next\\n            head.next = tail\\n            tail = head\\n            head = next\\n\\n        return tail",
                "codeTag": "Java"
            },
            {
                "id": 11684,
                "title": "my-recursive-c-code-is-concise-and-easy",
                "content": "    void reverseGroup(ListNode *head, ListNode *tail) {\\n        ListNode *node = head, *tmp, *pre = node;\\n        if (!node) return;\\n        node = node->next;\\n        while (pre != tail) {\\n            tmp = node->next;\\n            node->next = pre;\\n            pre = node;\\n            node = tmp;\\n        }\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *runner = head, *tHead = head;\\n        for (int i = 1;i < k;++i)\\n            if (runner) runner = runner->next; else break;\\n        if (!runner) return head;\\n        tHead = runner->next;\\n        reverseGroup(head,runner);\\n        head->next = reverseKGroup(tHead,k);\\n        return runner;\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "    void reverseGroup(ListNode *head, ListNode *tail) {\\n        ListNode *node = head, *tmp, *pre = node;\\n        if (!node) return;\\n        node = node->next;\\n        while (pre != tail) {\\n            tmp = node->next;\\n            node->next = pre;\\n            pre = node;\\n            node = tmp;\\n        }\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *runner = head, *tHead = head;\\n        for (int i = 1;i < k;++i)\\n            if (runner) runner = runner->next; else break;\\n        if (!runner) return head;\\n        tHead = runner->next;\\n        reverseGroup(head,runner);\\n        head->next = reverseKGroup(tHead,k);\\n        return runner;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11693,
                "title": "easy-to-understand-c-solution",
                "content": "The idea is to take k items from main list, reverse them and join to the new list. thats all. And dont forget about leftovers.\\n\\n    class Solution {\\n    public:\\n        ListNode* reverseKGroup(ListNode* head, int k)\\n        {\\n            // Count size of the original list\\n            int size = 0;\\n            ListNode *tmp = head;\\n            while (tmp != NULL)\\n            {\\n                tmp = tmp->next;\\n                ++size;\\n            }\\n            \\n            // make sure we need to do anything :)\\n            if (k > size)\\n                return head;\\n            \\n            // these are the pointers to the final list that we a building\\n            ListNode *newHead = NULL;\\n            ListNode *newTail = NULL;\\n            \\n            // main cycle. While we need to reverse anything\\n            while (size >= k)\\n            {\\n                // build a short reversed list that will contain k items ready to be joined the final list.\\n                ListNode *grHead = NULL;\\n                for (int i=0; i<k; ++i)\\n                {\\n                    ListNode *item = head;\\n                    head = head->next;\\n                    --size;\\n                    item->next = grHead;\\n                    grHead = item;\\n                }\\n                // note after building reversed we move head as well and reduce size.\\n                \\n                // join group (reversed) list to the final list\\n                if (newHead == NULL)\\n                {\\n                    newHead = grHead;\\n                    newTail = grHead;\\n                }\\n                else\\n                {\\n                    newTail->next = grHead;\\n                }\\n                \\n                // newTail will point to the group of a k items. move it to the end\\n                while (newTail->next != NULL)\\n                    newTail = newTail->next;\\n            }\\n            \\n            // in case original list has leftovers. it may occur if we have list size 5 and k = 3. 2 last items needs to be joined too\\n            if (head != NULL)\\n                newTail->next = head;\\n            \\n            return newHead;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* reverseKGroup(ListNode* head, int k)\\n        {\\n            // Count size of the original list\\n            int size = 0;\\n            ListNode *tmp = head;\\n            while (tmp != NULL)\\n            {\\n                tmp = tmp->next;\\n                ++size;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3827662,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* Kreverse(ListNode* head,int k,int n){\\n\\n        if(n<k)return head;\\n        ListNode* next=NULL;\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        int cnt=0;\\n        while(cnt<k and curr!=NULL){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            cnt++;\\n        }\\n        if(next!=NULL)head->next=Kreverse(next,k,n-k);\\n\\n        return prev;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        if(head==NULL)return NULL;\\n        ListNode* temp=head;\\n        int n=0;\\n        while(temp){\\n            temp=temp->next;\\n            n++;\\n        }\\n        return Kreverse(head,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* Kreverse(ListNode* head,int k,int n){\\n\\n        if(n<k)return head;\\n        ListNode* next=NULL;\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        int cnt=0;\\n        while(cnt<k and curr!=NULL){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            cnt++;\\n        }\\n        if(next!=NULL)head->next=Kreverse(next,k,n-k);\\n\\n        return prev;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        if(head==NULL)return NULL;\\n        ListNode* temp=head;\\n        int n=0;\\n        while(temp){\\n            temp=temp->next;\\n            n++;\\n        }\\n        return Kreverse(head,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799257,
                "title": "clean-and-readable-python-code",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(0, head)\\n        currGroup = dummy\\n\\n        while True:\\n            kth = self.getKth(currGroup, k)\\n            if not kth:\\n                break\\n            nextGroup =  kth.next\\n\\n            # reverse the currGroup\\n            prev, curr = kth.next, currGroup.next\\n            while curr != nextGroup:\\n                tmp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = tmp\\n\\n            currGroup.next, currGroup = kth, currGroup.next\\n\\n        return dummy.next\\n\\n\\n    def getKth(self, node, k):\\n        while node and k:\\n            node = node.next\\n            k -= 1\\n        return node\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(0, head)\\n        currGroup = dummy\\n\\n        while True:\\n            kth = self.getKth(currGroup, k)\\n            if not kth:\\n                break\\n            nextGroup =  kth.next\\n\\n            # reverse the currGroup\\n            prev, curr = kth.next, currGroup.next\\n            while curr != nextGroup:\\n                tmp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = tmp\\n\\n            currGroup.next, currGroup = kth, currGroup.next\\n\\n        return dummy.next\\n\\n\\n    def getKth(self, node, k):\\n        while node and k:\\n            node = node.next\\n            k -= 1\\n        return node\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723473,
                "title": "c-soro",
                "content": "## Intuition\\nGive it a ```dry run```, you well get it.\\n\\n....\\nhey you, yes you.. please do vote this up and let leetcode know you are enjoying what you are watching.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        if(head == NULL) return NULL;\\n\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int count = 0;\\n\\n        // edge case\\n        ListNode* ptr = head;\\n        for(int i = 0; i < k; i++) {\\n            if(ptr == NULL) return head;\\n            ptr = ptr->next;\\n        }\\n\\n\\n        while(curr != NULL && count < k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        if(next != NULL) head->next = reverseKGroup(next,k);\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```dry run```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        if(head == NULL) return NULL;\\n\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int count = 0;\\n\\n        // edge case\\n        ListNode* ptr = head;\\n        for(int i = 0; i < k; i++) {\\n            if(ptr == NULL) return head;\\n            ptr = ptr->next;\\n        }\\n\\n\\n        while(curr != NULL && count < k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        if(next != NULL) head->next = reverseKGroup(next,k);\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717931,
                "title": "easy-to-understand-recursion-c",
                "content": "\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n       //base case \\n       if(head == NULL)\\n       return NULL;\\n\\n       //reverse 1st k nodes \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n        int count = 0;\\n\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n         if(cursor == nullptr) \\n             return head;\\n         cursor = cursor->next;\\n    }\\n\\n        while(curr!=NULL && count<k){\\n           forward = curr->next; \\n           curr->next = prev;\\n           prev = curr;\\n           curr = forward;\\n           count++;\\n        }\\n\\n        // recursion dek lega\\n        if(forward != NULL){\\n            head->next = reverseKGroup(forward,k);\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n       //base case \\n       if(head == NULL)\\n       return NULL;\\n\\n       //reverse 1st k nodes \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n        int count = 0;\\n\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n         if(cursor == nullptr) \\n             return head;\\n         cursor = cursor->next;\\n    }\\n\\n        while(curr!=NULL && count<k){\\n           forward = curr->next; \\n           curr->next = prev;\\n           prev = curr;\\n           curr = forward;\\n           count++;\\n        }\\n\\n        // recursion dek lega\\n        if(forward != NULL){\\n            head->next = reverseKGroup(forward,k);\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628347,
                "title": "o-n-solution-intuitive-and-easy-to-understand-c-solution",
                "content": "# Approach : \\nDry run side by side to understand better.\\nCount the length of linked list to find how many groups needs to be reversed by dividing cnt /k. Run a loop until cnt\\u2265k to perform reverse and keep decrementing count by k once a group of k is reversed.\\n\\nFor reversing we take into account 3 pointers prev, nex, curr. We know that the first elem of the group to be reversed should always point to the next reversed group so always keep curr pointer at the first element. Create a dummy node for initial group and prev, curr and next all point to this dummy. now we know first elem of every group must be pointed by curr and curr will  point to the next element of the last element of the previous group meaning if k=3 in list 1\\u20142\\u20143\\u20144 then at the end of reversing curr\\u2192next will point to 4 because it is the next elem of the reversed group. so inside outer loop we write curr=prev\\u2192next. and next will point to current elem next which is next=curr\\u2192next\\n\\nNow in 1\\u20142\\u20143\\u20144 the link to be broken is 1\\u20142 we know 1 next must point to starting of another group. so now curr is pointing to 1 so we shift 1 by one the curr\\u2192next because curr\\u2192next is pointing to the next elem whose link needs to be changes so moving step by step curr\\u2192next will point to next\\u2192next because that is the only elem the farthest we can move using these pointers.\\n\\nnow once curr\\u2192next =nex\\u2192next now 2\\u20143 link needs to be broken so nex\\u2192next should now point to prev\\u2192next. now moving pointers prev\\u2192next=nex because we need to invert 3\\u20144 link for 3, the prev element must be 2 which is pointed by nex now moving nex which will be nex=curr\\u2192next mpving nex by 1 position. \\n\\nWe know prev\\u2192next and dummy\\u2192next points to same elem so when we are changing prev\\u2192 next dummy\\u2192next also changes. But after one iteration we change prev=curr\\u2192next so now dummy is no more affected by prev because now prev is pointed to other elem.\\n\\nNow for the next group we need to again set prev to curr\\u2192next because it was the last elem of previous group as we know that prev must point to the elem just before whose link needs to be altered.  We also reduce cnt-=k;\\n\\nAt last dummy stores the head so we return dummy\\u2192next\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int cnt=0;\\n        ListNode* temp=head;\\n        ListNode* dummy=new ListNode();\\n        dummy->next=head;\\n        ListNode *prev=dummy,*nex=dummy,*curr=dummy;\\n        while(temp!=NULL)\\n        {\\n            cnt++;\\n            temp=temp->next;\\n        }\\n        while(cnt>=k)\\n        {\\n            curr=prev->next;\\n            nex=curr->next;\\n            for(int i=1;i<k;i++)\\n            {\\n                curr->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=curr->next;\\n            }\\n            prev=curr;\\n            cnt-=k;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n\\n- Time Complexity : O(N/K)*K which is equal to O(N)\\n- Space Complexity : O(1)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int cnt=0;\\n        ListNode* temp=head;\\n        ListNode* dummy=new ListNode();\\n        dummy->next=head;\\n        ListNode *prev=dummy,*nex=dummy,*curr=dummy;\\n        while(temp!=NULL)\\n        {\\n            cnt++;\\n            temp=temp->next;\\n        }\\n        while(cnt>=k)\\n        {\\n            curr=prev->next;\\n            nex=curr->next;\\n            for(int i=1;i<k;i++)\\n            {\\n                curr->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=curr->next;\\n            }\\n            prev=curr;\\n            cnt-=k;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604279,
                "title": "c-iterative-o-n-time-o-1-space-detailed-explanation",
                "content": "# Explanation\\n- Use a dummy node to simplify the process. The dummy node is set as the previous node of the original head node.\\n- Maintain two pointers, beforeGroup and afterGroup, to keep track of the nodes before and after each group of k nodes.\\n- The current pointer is used to traverse the nodes within each group. The previous pointer is used to reverse the links between nodes. The nextNode pointer is used to store the next node before modifying the link.\\n- The main loop runs indefinitely until the entire list is processed.\\n- Inside the loop, first check if there are k nodes remaining. If not, return the modified list. Iterate k times to advance the cursor pointer, which helps determine if there are enough nodes remaining in the group. After confirming that there are k nodes, perform the actual reversal.\\n- Iterate k times and reverse the links between nodes by updating the next pointers.\\n- After reversing the group, update the links for the previous group (beforeGroup points to the last node of the reversed group) and the next group (afterGroup points to the first node of the next group).\\n- Finally, update the beforeGroup and afterGroup pointers to the appropriate positions for the next iteration of the loop.\\n- When the loop ends, the entire list is reversed in groups of k, return the modified list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* beforeGroup = dummy;\\n    ListNode* afterGroup = head;\\n    ListNode* current = nullptr;\\n    ListNode* previous = nullptr;\\n    ListNode* nextNode = nullptr;\\n\\n    while (true) {\\n        ListNode* cursor = afterGroup;\\n        for (int i = 0; i < k; i++) {\\n            if (cursor == nullptr) {\\n                return dummy->next;\\n            }\\n            cursor = cursor->next;\\n        }\\n\\n        current = afterGroup;\\n        previous = beforeGroup;\\n        for (int i = 0; i < k; i++) {\\n            nextNode = current->next;\\n            current->next = previous;\\n            previous = current;\\n            current = nextNode;\\n        }\\n\\n        afterGroup->next = current;\\n        beforeGroup->next = previous;\\n        beforeGroup = afterGroup;\\n        afterGroup = current;\\n    }\\n}\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* beforeGroup = dummy;\\n    ListNode* afterGroup = head;\\n    ListNode* current = nullptr;\\n    ListNode* previous = nullptr;\\n    ListNode* nextNode = nullptr;\\n\\n    while (true) {\\n        ListNode* cursor = afterGroup;\\n        for (int i = 0; i < k; i++) {\\n            if (cursor == nullptr) {\\n                return dummy->next;\\n            }\\n            cursor = cursor->next;\\n        }\\n\\n        current = afterGroup;\\n        previous = beforeGroup;\\n        for (int i = 0; i < k; i++) {\\n            nextNode = current->next;\\n            current->next = previous;\\n            previous = current;\\n            current = nextNode;\\n        }\\n\\n        afterGroup->next = current;\\n        beforeGroup->next = previous;\\n        beforeGroup = afterGroup;\\n        afterGroup = current;\\n    }\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446353,
                "title": "0ms-100-faster-solution-in-java-naive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nnaive approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n  if(head==null || k==1) return head;\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n\\n        ListNode curr = dummy,nex = dummy,pre = dummy;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr = curr.next;         \\n            count++;\\n        }\\n\\n        while(count>=k){                 \\n            curr = pre.next;            \\n            nex = curr.next;           \\n            for(int i=1;i<k;i++){        \\n                curr.next = nex.next;\\n                nex.next = pre.next;\\n                pre.next = nex;\\n                nex = curr.next;\\n            }\\n            pre = curr;   \\n            count-=k;                   \\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n  if(head==null || k==1) return head;\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n\\n        ListNode curr = dummy,nex = dummy,pre = dummy;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr = curr.next;         \\n            count++;\\n        }\\n\\n        while(count>=k){                 \\n            curr = pre.next;            \\n            nex = curr.next;           \\n            for(int i=1;i<k;i++){        \\n                curr.next = nex.next;\\n                nex.next = pre.next;\\n                pre.next = nex;\\n                nex = curr.next;\\n            }\\n            pre = curr;   \\n            count-=k;                   \\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400834,
                "title": "simple-c-solution-without-recursion-well-explained",
                "content": "# Intuition\\nCounting the total nodes to find how many `k` groups can be made. Using stack to reverse the order of the `k` nodes and then adding them to ListNode and returning that LinkedList.\\n\\n# Approach\\n1. Count the number of nodes.\\n2. devide number of nodes by `k` to find how many groups of `k` size can be made. save the result to `cnt` variable.\\n3. Declare a stack.\\n4. make a Listnode `ans` initially pointing to head node (`ListNode* ans = head`). We will make changes as said in question and return head to return the desired linkedlist.\\n5. Start interating in the LinkedList, use a variable `k1 = k`, so that we can renew the value of k1 after changing. push node values in stack and decrease value of `k1` till it reaches 0.\\n6. Once it reaches 0, start a loop till the stack gets empty and get the top value and assign it to the node of `ans` listNode and make `ans = ans->next`. pop the top value from stack.\\n7. once the stack gets empty decrease the `cnt` value by 1. make `k1 = k`.\\n8. let the iteration started in `5th` point continue till out `cnt` value gets 0, once it gets 0, we\\'ll break the loop and return the `head` of the linkedList.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* counter = head;\\n        ListNode* temp = head;\\n        ListNode* ans = head;\\n        while(counter!=NULL){\\n            cnt++;\\n            counter = counter->next;\\n        }\\n        cnt /= k;\\n        stack<int> st;\\n        int k1 = k;\\n\\n        while(temp!=NULL){\\n            st.push(temp->val);\\n            k1--;\\n            temp = temp->next;\\n            if(k1==0){\\n                while(!st.empty()){\\n                    ans->val = st.top();\\n                    st.pop();\\n                    ans = ans->next;\\n                }\\n                cnt--;\\n                k1 = k;\\n            }\\n            if(cnt==0){\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* counter = head;\\n        ListNode* temp = head;\\n        ListNode* ans = head;\\n        while(counter!=NULL){\\n            cnt++;\\n            counter = counter->next;\\n        }\\n        cnt /= k;\\n        stack<int> st;\\n        int k1 = k;\\n\\n        while(temp!=NULL){\\n            st.push(temp->val);\\n            k1--;\\n            temp = temp->next;\\n            if(k1==0){\\n                while(!st.empty()){\\n                    ans->val = st.top();\\n                    st.pop();\\n                    ans = ans->next;\\n                }\\n                cnt--;\\n                k1 = k;\\n            }\\n            if(cnt==0){\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387398,
                "title": "python-iterative-simple-and-clean-beats-98-09",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to reverse the nodes of the list k at a time. One way to approach this problem is to keep track of the length of the list and reverse the nodes of each group of k nodes. We will use a dummy node to keep track of the head of the list and use two pointers to reverse the nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the length of the list.\\n1. Create a dummy node and set its next to the head of the list.\\n1. Set the prev pointer to the dummy node and loop through the list in groups of k nodes.\\n1. For each group, set the curr pointer to prev.next and loop k-1 times.\\n1. In the loop, set the nxt pointer to curr.next, set curr.next to nxt.next, set nxt.next to prev.next, and set prev.next to nxt.\\n1. Set prev to curr.\\n1. Return the next node of the dummy node.\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the number of nodes in the list.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$, since we are only modifying the pointers of the existing list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or k==1:\\n            return head\\n\\n        length = 0\\n        curr = head\\n        while curr:\\n            length += 1\\n            curr = curr.next\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n        for i in range(length//k):\\n            curr = prev.next\\n            for j in range(k-1):\\n                nxt = curr.next\\n                curr.next = nxt.next\\n                nxt.next = prev.next\\n                prev.next = nxt\\n            prev = curr\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or k==1:\\n            return head\\n\\n        length = 0\\n        curr = head\\n        while curr:\\n            length += 1\\n            curr = curr.next\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n        for i in range(length//k):\\n            curr = prev.next\\n            for j in range(k-1):\\n                nxt = curr.next\\n                curr.next = nxt.next\\n                nxt.next = prev.next\\n                prev.next = nxt\\n            prev = curr\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353014,
                "title": "easy-python-solution-99-80-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->If  you like the solution please upvote guys.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have to reverse the every k nodes and assign to the new linkedlist.finally dont reverse the nodes which nodes length is less than k.We have to link those nodes to our newlinked list and finally rerturn the linkedlist.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        a=b=ListNode()\\n        i=0\\n        z=None\\n        #Reverse the k nodes\\n        while head:\\n            i=i+1\\n            if i<=k:\\n                x=head.next\\n                head.next=z\\n                z=head\\n                head=x\\n            #Assign the reversed nodes to the new links\\n            if i==k:\\n                b.next=z\\n                #Take pointer until end of the reversed nodes\\n                while b and b.next:\\n                    b=b.next\\n                z=None\\n                i=0\\n        #And finally reverse the nodes and assign the nodes\\n        zz=None\\n        while z:\\n            #Reverse\\n            g=z.next\\n            z.next=zz\\n            zz=z\\n            z=g\\n        #Assign the final nodes which are length is the less than k\\n        b.next=zz\\n        #The total link connection is in a then return a.next\\n        return a.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        a=b=ListNode()\\n        i=0\\n        z=None\\n        #Reverse the k nodes\\n        while head:\\n            i=i+1\\n            if i<=k:\\n                x=head.next\\n                head.next=z\\n                z=head\\n                head=x\\n            #Assign the reversed nodes to the new links\\n            if i==k:\\n                b.next=z\\n                #Take pointer until end of the reversed nodes\\n                while b and b.next:\\n                    b=b.next\\n                z=None\\n                i=0\\n        #And finally reverse the nodes and assign the nodes\\n        zz=None\\n        while z:\\n            #Reverse\\n            g=z.next\\n            z.next=zz\\n            zz=z\\n            z=g\\n        #Assign the final nodes which are length is the less than k\\n        b.next=zz\\n        #The total link connection is in a then return a.next\\n        return a.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214814,
                "title": "using-recursion-easy-and-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n            if(cursor == nullptr) return head;\\n            cursor = cursor->next;\\n        }\\n\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* next = NULL;\\n\\n        int count=0;\\n\\n        while(curr != NULL && count < k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        if(next != NULL){\\n            head->next = reverseKGroup(next,k);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n            if(cursor == nullptr) return head;\\n            cursor = cursor->next;\\n        }\\n\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* next = NULL;\\n\\n        int count=0;\\n\\n        while(curr != NULL && count < k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        if(next != NULL){\\n            head->next = reverseKGroup(next,k);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205239,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n           ListNode * dummy = new ListNode(0);\\n           dummy->next = head;\\n           ListNode* curr = dummy , *nex = dummy , *pre = dummy;\\n           int cnt = 0;\\n           while(curr->next) {\\n               curr = curr->next;\\n               cnt++;\\n           } \\n           while(cnt >= k) {\\n               curr = pre->next;\\n               nex = curr->next;\\n               for(int i=1;i<k;i++) {\\n                   curr->next = nex->next;\\n                   nex->next = pre->next;\\n                   pre->next = nex;\\n                   nex = curr->next;\\n               }\\n               pre = curr;\\n               cnt-=k;\\n           }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n           ListNode * dummy = new ListNode(0);\\n           dummy->next = head;\\n           ListNode* curr = dummy , *nex = dummy , *pre = dummy;\\n           int cnt = 0;\\n           while(curr->next) {\\n               curr = curr->next;\\n               cnt++;\\n           } \\n           while(cnt >= k) {\\n               curr = pre->next;\\n               nex = curr->next;\\n               for(int i=1;i<k;i++) {\\n                   curr->next = nex->next;\\n                   nex->next = pre->next;\\n                   pre->next = nex;\\n                   nex = curr->next;\\n               }\\n               pre = curr;\\n               cnt-=k;\\n           }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157702,
                "title": "golang-iterative-recursive",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\n/* Recursive Solution */\\n\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n    l := length(head)\\n    return reverse(head, l, k)\\n}\\n\\nfunc reverse(node *ListNode, l, k int) *ListNode {\\n    if l < k {\\n        return node\\n    }\\n\\n    var prev, next *ListNode\\n    curr := node\\n    for i := 0; i < k; i++ {\\n        next = curr.Next\\n        curr.Next = prev\\n        prev = curr\\n        curr = next\\n    }\\n\\n    node.Next = reverse(next, l-k, k)\\n    return prev\\n}\\n\\nfunc length(head *ListNode) int {\\n    count := 0\\n\\n    for head != nil {\\n        head = head.Next\\n        count++\\n    }\\n    return count\\n}\\n\\n/* Iterative Solution */\\n\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n    if head == nil || k == 1 {\\n        return head\\n    }\\n\\n    l := length(head)\\n    preHead := &ListNode{Next: head}\\n\\n    prev := preHead\\n    for l >= k {\\n        curr := prev.Next\\n        for i := 1; i < k; i++ {\\n            next := curr.Next\\n            curr.Next = next.Next\\n            next.Next = prev.Next\\n            prev.Next = next\\n        }\\n        prev = curr\\n        l -= k\\n    }\\n\\n    return preHead.Next\\n}\\n\\nfunc length(head *ListNode) int {\\n    count := 0\\n\\n    for head != nil {\\n        head = head.Next\\n        count++\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\n/* Recursive Solution */\\n\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n    l := length(head)\\n    return reverse(head, l, k)\\n}\\n\\nfunc reverse(node *ListNode, l, k int) *ListNode {\\n    if l < k {\\n        return node\\n    }\\n\\n    var prev, next *ListNode\\n    curr := node\\n    for i := 0; i < k; i++ {\\n        next = curr.Next\\n        curr.Next = prev\\n        prev = curr\\n        curr = next\\n    }\\n\\n    node.Next = reverse(next, l-k, k)\\n    return prev\\n}\\n\\nfunc length(head *ListNode) int {\\n    count := 0\\n\\n    for head != nil {\\n        head = head.Next\\n        count++\\n    }\\n    return count\\n}\\n\\n/* Iterative Solution */\\n\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n    if head == nil || k == 1 {\\n        return head\\n    }\\n\\n    l := length(head)\\n    preHead := &ListNode{Next: head}\\n\\n    prev := preHead\\n    for l >= k {\\n        curr := prev.Next\\n        for i := 1; i < k; i++ {\\n            next := curr.Next\\n            curr.Next = next.Next\\n            next.Next = prev.Next\\n            prev.Next = next\\n        }\\n        prev = curr\\n        l -= k\\n    }\\n\\n    return preHead.Next\\n}\\n\\nfunc length(head *ListNode) int {\\n    count := 0\\n\\n    for head != nil {\\n        head = head.Next\\n        count++\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144386,
                "title": "simple-o-n-iterative-cpp",
                "content": "# Intuition\\nAs the question suggests, I have partitioned the whole length into groups of \\'k\\' nodes and then reversed the pointers within those k nodes along with changing the conventional head and tail of the list as a whole.\\n\\n# Approach\\nThe idea is to have a dummy head pointing to current head at first. Then I have sectioned the whol elength into groups of \\'k\\'. In those sections one can simply reverse the pointers with current and previous nodes. And hence the whole list will be reversed\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int findLen(ListNode *head){\\n        if (head==NULL){return 0;}\\n        if (head->next==NULL){return 1;}\\n        int len =1;\\n        while(head->next){\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n         if (head==NULL || head->next==NULL){\\n             return head;\\n         }\\n        int len = findLen(head); \\n        ListNode* dummyHead = new ListNode(0);\\n        dummyHead->next = head;\\n        ListNode* pre = dummyHead;\\n        ListNode* cur;\\n        ListNode* nex;\\n        while(len >= k) {\\n            cur = pre->next;\\n            nex = cur->next;\\n            for(int i=1;i<k;i++) {\\n                cur->next = nex->next;\\n                nex->next = pre->next;\\n                pre->next = nex;\\n                nex = cur->next;\\n            }\\n            pre = cur;\\n            len -= k;\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findLen(ListNode *head){\\n        if (head==NULL){return 0;}\\n        if (head->next==NULL){return 1;}\\n        int len =1;\\n        while(head->next){\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n         if (head==NULL || head->next==NULL){\\n             return head;\\n         }\\n        int len = findLen(head); \\n        ListNode* dummyHead = new ListNode(0);\\n        dummyHead->next = head;\\n        ListNode* pre = dummyHead;\\n        ListNode* cur;\\n        ListNode* nex;\\n        while(len >= k) {\\n            cur = pre->next;\\n            nex = cur->next;\\n            for(int i=1;i<k;i++) {\\n                cur->next = nex->next;\\n                nex->next = pre->next;\\n                pre->next = nex;\\n                nex = cur->next;\\n            }\\n            pre = cur;\\n            len -= k;\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113150,
                "title": "reverse-nodes-in-k-group",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     int length(ListNode* node)\\n     {\\n         int count=0;\\n         while(node)\\n         {\\n             count++;\\n             node = node->next;\\n         }\\n         return count;\\n     }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        if(length(head)<k)\\n        {\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* next = nullptr;\\n        ListNode* prev = nullptr;\\n        for(int i=0; i<k; i++)\\n        {\\n             next = curr->next;\\n             curr->next= prev;\\n             prev = curr;\\n             curr = next;\\n        }\\n        head -> next = reverseKGroup(curr,k);\\n        return prev;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     int length(ListNode* node)\\n     {\\n         int count=0;\\n         while(node)\\n         {\\n             count++;\\n             node = node->next;\\n         }\\n         return count;\\n     }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        if(length(head)<k)\\n        {\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* next = nullptr;\\n        ListNode* prev = nullptr;\\n        for(int i=0; i<k; i++)\\n        {\\n             next = curr->next;\\n             curr->next= prev;\\n             prev = curr;\\n             curr = next;\\n        }\\n        head -> next = reverseKGroup(curr,k);\\n        return prev;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043971,
                "title": "c-o-1-space-complexity",
                "content": "\\n### Complexity\\n- Time complexity: $$O(N * K)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* F(ListNode *curr) {\\n        ListNode *next = curr, *prev = nullptr;\\n        while(curr) {\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || !head-> next || k == 1) return head;\\n\\n        ListNode *curr = head;\\n        ListNode *answer = nullptr, *dummy = nullptr;\\n\\n        while(curr) {\\n            ListNode *left = curr, *right = nullptr;\\n            int cnt = 0;\\n            while(curr && cnt != k) {\\n                right = curr;\\n                curr = curr -> next;\\n                cnt++;\\n            }\\n\\n            if(cnt != k) {\\n                if(!answer) return head;\\n                dummy -> next = left;\\n                return answer;\\n            }\\n\\n            right -> next = nullptr;\\n            ListNode *r = F(left);\\n\\n            if(!answer) answer = r;\\n            else dummy -> next = r;\\n            dummy = left;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* F(ListNode *curr) {\\n        ListNode *next = curr, *prev = nullptr;\\n        while(curr) {\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || !head-> next || k == 1) return head;\\n\\n        ListNode *curr = head;\\n        ListNode *answer = nullptr, *dummy = nullptr;\\n\\n        while(curr) {\\n            ListNode *left = curr, *right = nullptr;\\n            int cnt = 0;\\n            while(curr && cnt != k) {\\n                right = curr;\\n                curr = curr -> next;\\n                cnt++;\\n            }\\n\\n            if(cnt != k) {\\n                if(!answer) return head;\\n                dummy -> next = left;\\n                return answer;\\n            }\\n\\n            right -> next = nullptr;\\n            ListNode *r = F(left);\\n\\n            if(!answer) answer = r;\\n            else dummy -> next = r;\\n            dummy = left;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949622,
                "title": "python-solution-faster-than-90-o-n-time-and-space",
                "content": "# Intuition\\nWe are going to find the length of the list and knowing that reverse as many groups of k elements as we can. We will then append the remaining list.\\n\\n# Approach\\nTo find the length of the list we will just go through the entire list once.\\nThen we will reverse as many groups of k elements as we can. Those are going to be l//k. We will reverse them the same way we did in [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\\nFor every one of those groups we will put them in a dummy.\\nAt the end we will append the remaining list to the dummy.\\n# Complexity\\n- Time complexity: **O(n)** since we go through the linked list twice\\n\\n- Space complexity: **O(n)** since we store the dummy with length equal to the linked list.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if k == 1: return head\\n\\n        # find lenght of list by going through it\\n        l = 1\\n        tail = head\\n        while tail.next:\\n            tail = tail.next\\n            l += 1\\n        \\n        # reverse l//k times k elements\\n        curr,dummy = head,ListNode()\\n        tail = dummy\\n\\n        for i in range(l//k): # for every group of size k\\n            prev = None\\n\\n            # reverse it\\n            for x in range(k):\\n                temp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = temp\\n\\n\\n            tail.next = prev # append the group to the dummy\\n            # get the pointer to the end\\n            for x in range(k): tail = tail.next \\n\\n        # append the remaining list\\n        tail.next = curr\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if k == 1: return head\\n\\n        # find lenght of list by going through it\\n        l = 1\\n        tail = head\\n        while tail.next:\\n            tail = tail.next\\n            l += 1\\n        \\n        # reverse l//k times k elements\\n        curr,dummy = head,ListNode()\\n        tail = dummy\\n\\n        for i in range(l//k): # for every group of size k\\n            prev = None\\n\\n            # reverse it\\n            for x in range(k):\\n                temp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = temp\\n\\n\\n            tail.next = prev # append the group to the dummy\\n            # get the pointer to the end\\n            for x in range(k): tail = tail.next \\n\\n        # append the remaining list\\n        tail.next = curr\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927097,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length(ListNode * node)\\n    {\\n        int count=0;\\n        while(node){\\n            count++;\\n            node=node->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       if(length(head) < k)\\n           return head;\\n       ListNode * cur=head;\\n       ListNode * prev=NULL, *next=NULL;\\n       for(int i=0; i < k; i++)\\n       {\\n           next=cur->next;\\n           cur->next=prev;\\n           prev=cur;\\n           cur=next;\\n       }\\n       head->next=reverseKGroup(cur, k);\\n       return prev;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length(ListNode * node)\\n    {\\n        int count=0;\\n        while(node){\\n            count++;\\n            node=node->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       if(length(head) < k)\\n           return head;\\n       ListNode * cur=head;\\n       ListNode * prev=NULL, *next=NULL;\\n       for(int i=0; i < k; i++)\\n       {\\n           next=cur->next;\\n           cur->next=prev;\\n           prev=cur;\\n           cur=next;\\n       }\\n       head->next=reverseKGroup(cur, k);\\n       return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848333,
                "title": "easiest-solution-c-plus-plus-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint count1 = 0;\\nint length(ListNode* head){\\n    int ans = 0;\\n    ListNode* temp = head;\\n    while(temp!=NULL){\\n        ans++;\\n        temp=temp->next;\\n    }\\n    return ans;\\n}\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        count1=length(head);\\n        if(count1<k) return head;\\n        ListNode* temp = head;\\n        ListNode* nextt = NULL;\\n        ListNode* prev = NULL;\\n        int count =0;\\n        while(count<k && temp!=NULL){\\n            nextt = temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nextt;\\n            count++;\\n        }\\n        if(nextt!=NULL){\\n            head->next=reverseKGroup(nextt,k);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint count1 = 0;\\nint length(ListNode* head){\\n    int ans = 0;\\n    ListNode* temp = head;\\n    while(temp!=NULL){\\n        ans++;\\n        temp=temp->next;\\n    }\\n    return ans;\\n}\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        count1=length(head);\\n        if(count1<k) return head;\\n        ListNode* temp = head;\\n        ListNode* nextt = NULL;\\n        ListNode* prev = NULL;\\n        int count =0;\\n        while(count<k && temp!=NULL){\\n            nextt = temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nextt;\\n            count++;\\n        }\\n        if(nextt!=NULL){\\n            head->next=reverseKGroup(nextt,k);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803455,
                "title": "kotlin-easy-intuitive-reused-reverse-linked-list-function",
                "content": "# Intuition\\nFirst create a function to reverse linked list\\nthen call function (size of linked list)/k times\\n\\n# Approach\\nCreate Reverse function which accepts current node and end node\\nIn reverse function:\\n->Implement it using your approch just make prev = end and not null\\n\\nIn base function:\\n-> run while loop for linked list\\n-> run another nested while loop till i<k to find end(till when the nodes will be reversed)\\n-> then just call reverse(current, end)\\n\\n# Complexity\\n- Time complexity: O(n) \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\\n\\n        var cur = head\\n        var prev: ListNode? = null\\n        var newHead = head\\n        while(cur != null)\\n        {\\n            var i = 0\\n            var end = cur\\n            while( end != null && i < k)\\n            {\\n                end = end?.next\\n                i++\\n            }\\n            if(i == k)\\n            {\\n                if(cur == head)\\n                newHead = reverse(cur,end)\\n                else\\n                prev?.next = reverse(cur,end)\\n            }\\n            prev = cur\\n            cur = end\\n        }\\n\\n        return newHead\\n    }\\n\\n    fun reverse(cur1: ListNode?, end: ListNode?): ListNode?{\\n\\n        var prev = end\\n        var cur = cur1\\n        while(cur != end)\\n        {\\n            val temp = cur?.next\\n            cur?.next = prev\\n            prev = cur\\n            cur = temp\\n        }\\n\\n        return prev\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\\n\\n        var cur = head\\n        var prev: ListNode? = null\\n        var newHead = head\\n        while(cur != null)\\n        {\\n            var i = 0\\n            var end = cur\\n            while( end != null && i < k)\\n            {\\n                end = end?.next\\n                i++\\n            }\\n            if(i == k)\\n            {\\n                if(cur == head)\\n                newHead = reverse(cur,end)\\n                else\\n                prev?.next = reverse(cur,end)\\n            }\\n            prev = cur\\n            cur = end\\n        }\\n\\n        return newHead\\n    }\\n\\n    fun reverse(cur1: ListNode?, end: ListNode?): ListNode?{\\n\\n        var prev = end\\n        var cur = cur1\\n        while(cur != end)\\n        {\\n            val temp = cur?.next\\n            cur?.next = prev\\n            prev = cur\\n            cur = temp\\n        }\\n\\n        return prev\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795560,
                "title": "c-easiest-solution-faster-than-94-memory-and-90-speed",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode * res=new ListNode(-1);\\n        res->next=head;\\n        ListNode * prv=res;\\n        ListNode * A=head;\\n        while(A)\\n        {\\n            int c=0;\\n            ListNode * start=A;\\n            ListNode * x=A;\\n            ListNode * y=NULL;\\n            while(A && c<k)\\n            {\\n                A=A->next;\\n                c+=1;\\n            }\\n            if(c!=k)\\n            {\\n                prv->next=start;\\n                break;\\n            }\\n            while(x!=A)\\n            {\\n                ListNode * nxt=x->next;\\n                x->next=y;\\n                y=x;\\n                x=nxt;\\n            }\\n            prv->next=y;\\n            prv=start;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode * res=new ListNode(-1);\\n        res->next=head;\\n        ListNode * prv=res;\\n        ListNode * A=head;\\n        while(A)\\n        {\\n            int c=0;\\n            ListNode * start=A;\\n            ListNode * x=A;\\n            ListNode * y=NULL;\\n            while(A && c<k)\\n            {\\n                A=A->next;\\n                c+=1;\\n            }\\n            if(c!=k)\\n            {\\n                prv->next=start;\\n                break;\\n            }\\n            while(x!=A)\\n            {\\n                ListNode * nxt=x->next;\\n                x->next=y;\\n                y=x;\\n                x=nxt;\\n            }\\n            prv->next=y;\\n            prv=start;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787897,
                "title": "simple-approach-c-o-n-iterative-commented",
                "content": "ListNode *reverseLinkedListRec(ListNode *head) // For reversing a block of linked list in O(n)\\n{\\n\\n\\tif(head == NULL || head -> next == NULL)\\n        return head;\\n\\n    ListNode *newhead = reverseLinkedListRec(head -> next);\\n    head -> next -> next = head;\\n    head -> next = NULL;\\n\\treturn newhead;\\n}\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n\\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    if(k==1 || k==0)\\n        return head;\\n\\n    int c=1,d=0;\\n    ListNode *temp = head;\\n    ListNode *last = NULL; //for saving the last node of a k-group\\n    ListNode *fhead = NULL; //for saving the head of the linked list\\n    ListNode *newhead = NULL; // for saving the head of every new head\\n    while(temp != NULL){\\n        if(c==k){\\n            c=1;\\n            ListNode *a = temp -> next;\\n            temp -> next  = NULL;\\n            newhead = reverseLinkedListRec(head);\\n            if(last!=NULL)\\n                last -> next = newhead;\\n            if(d==0){\\n                fhead = newhead;\\n                d=1;\\n            }\\n            last = head;\\n            head = a;\\n            temp = a;\\n        } else {\\n            c++;\\n            temp = temp -> next;\\n        }\\n    }\\n\\t/* If the question has the alteration of reversing the remaining nodes if k is not a multiple of length of list\\n    if(head != NULL){\\n         newhead = reverseLinkedListRec(head);\\n\\t\\t last -> next = newhead;\\n     }\\n\\t */\\n    last -> next = head;\\n    return fhead;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "ListNode *reverseLinkedListRec(ListNode *head) // For reversing a block of linked list in O(n)\\n{\\n\\n\\tif(head == NULL || head -> next == NULL)\\n        return head;\\n\\n    ListNode *newhead = reverseLinkedListRec(head -> next);\\n    head -> next -> next = head;\\n    head -> next = NULL;\\n\\treturn newhead;\\n}\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n\\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    if(k==1 || k==0)\\n        return head;\\n\\n    int c=1,d=0;\\n    ListNode *temp = head;\\n    ListNode *last = NULL; //for saving the last node of a k-group\\n    ListNode *fhead = NULL; //for saving the head of the linked list\\n    ListNode *newhead = NULL; // for saving the head of every new head\\n    while(temp != NULL){\\n        if(c==k){\\n            c=1;\\n            ListNode *a = temp -> next;\\n            temp -> next  = NULL;\\n            newhead = reverseLinkedListRec(head);\\n            if(last!=NULL)\\n                last -> next = newhead;\\n            if(d==0){\\n                fhead = newhead;\\n                d=1;\\n            }\\n            last = head;\\n            head = a;\\n            temp = a;\\n        } else {\\n            c++;\\n            temp = temp -> next;\\n        }\\n    }\\n\\t/* If the question has the alteration of reversing the remaining nodes if k is not a multiple of length of list\\n    if(head != NULL){\\n         newhead = reverseLinkedListRec(head);\\n\\t\\t last -> next = newhead;\\n     }\\n\\t */\\n    last -> next = head;\\n    return fhead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2735575,
                "title": "java-runtime-1-ms-optimized-approach-wth-explanation",
                "content": "```\\nApproach\\n1.  we will make a variable total(length of linked list).\\n\\tAfter that will count the total length by using the while loop.\\n2.  Then we will reverse the given linked list according to size \\u2013 next \\u2013 \\n\\t(next of current element), prev \\u2013  (previous element of current),\\n\\tand current.\\n3.  Then we will decrease the total length by k after reversing the linked\\n\\t list and will check if the total length will be greater or equal to k \\n\\t then we will do the previous steps by using recursion.\\n4.  Else will link to the remaining node of the linked list.\\n    At last, we will return to the prev.\\n```\\n\\n```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int total = 0;\\n        ListNode current = head;\\n        while(current != null){\\n            total++;\\n            current = current.next;\\n        }\\n        int count = 0;\\n        ListNode prev = null;\\n        ListNode c = head;\\n        ListNode next = null;\\n        while(c != null && count < k){\\n            next = c.next;\\n            c.next = prev;\\n            prev = c;\\n            c = next;\\n            count++;\\n        }\\n        total -= k;\\n        if(total >= k){\\n            head.next = reverseKGroup(next,k);\\n        }\\n        else{\\n            head.next = next;\\n        }\\n        return prev; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nApproach\\n1.  we will make a variable total(length of linked list).\\n\\tAfter that will count the total length by using the while loop.\\n2.  Then we will reverse the given linked list according to size \\u2013 next \\u2013 \\n\\t(next of current element), prev \\u2013  (previous element of current),\\n\\tand current.\\n3.  Then we will decrease the total length by k after reversing the linked\\n\\t list and will check if the total length will be greater or equal to k \\n\\t then we will do the previous steps by using recursion.\\n4.  Else will link to the remaining node of the linked list.\\n    At last, we will return to the prev.\\n```\n```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int total = 0;\\n        ListNode current = head;\\n        while(current != null){\\n            total++;\\n            current = current.next;\\n        }\\n        int count = 0;\\n        ListNode prev = null;\\n        ListNode c = head;\\n        ListNode next = null;\\n        while(c != null && count < k){\\n            next = c.next;\\n            c.next = prev;\\n            prev = c;\\n            c = next;\\n            count++;\\n        }\\n        total -= k;\\n        if(total >= k){\\n            head.next = reverseKGroup(next,k);\\n        }\\n        else{\\n            head.next = next;\\n        }\\n        return prev; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711571,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverseKGroup(ListNode* head, int k) {\\n    \\n   ListNode* currCheck = head;\\n    \\n    for(int i = 0; i < k; i++)\\n    {\\n        if(currCheck == NULL)\\n            return head;\\n        \\n        currCheck = currCheck->next;\\n    }\\n\\n    ListNode* curr = head;\\n    ListNode* prev = NULL;\\n    ListNode* nxt = NULL;\\n    \\n    for(int i = 0; i < k; i++)\\n    {\\n        nxt = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = nxt;\\n        \\n    }\\n    head->next = reverseKGroup(curr, k);\\n    \\n    return prev;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverseKGroup(ListNode* head, int k) {\\n    \\n   ListNode* currCheck = head;\\n    \\n    for(int i = 0; i < k; i++)\\n    {\\n        if(currCheck == NULL)\\n            return head;\\n        \\n        currCheck = currCheck->next;\\n    }\\n\\n    ListNode* curr = head;\\n    ListNode* prev = NULL;\\n    ListNode* nxt = NULL;\\n    \\n    for(int i = 0; i < k; i++)\\n    {\\n        nxt = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = nxt;\\n        \\n    }\\n    head->next = reverseKGroup(curr, k);\\n    \\n    return prev;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667374,
                "title": "c-recursion-easy-to-understand-solution",
                "content": "class Solution {\\npublic:\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    ListNode* reverse_node(ListNode* head, int k, int len)\\n    {\\n\\t// check the condition if length is less than k return head. \\n        if(len < k)\\n        {\\n            return head;\\n        }\\n\\t\\t// take count variable to reverse the linked list till size k and break the loop when the count reaches size == k\\n        int count = 0;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n\\t\\t// simple code to reverse linked list.\\n        while(curr != NULL && count < k)\\n        {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\t\\t//  here we will call recursion with (length- k) size and assign value to head next (here head is   the last node of reverse list) and connect the linked list. \\n        head->next = reverse_node(next,k,len-k);\\n\\t\\t// return prev which is actual  head of the linked list.\\n        return prev;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       // first we will count the size of linked list. \\n        int len = 0;\\n        ListNode* temp = head;\\n        while(temp != NULL)\\n        {\\n            len++;\\n            temp = temp->next;\\n        }\\n\\t\\t// again assigning the value of head to temparory list.\\n        temp = head;\\n\\t\\t// call the function (reverse_node) with linked list, length of linked list and size k. \\n       return reverse_node(temp,k,len);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    ListNode* reverse_node(ListNode* head, int k, int len)\\n    {\\n\\t// check the condition if length is less than k return head. \\n        if(len < k)\\n        {\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2612686,
                "title": "unsafe-no-double-traverse-no-recursive-rust-code-with-o-1-of-space-and-o-n-of-time",
                "content": "Ok, first I think that leetcode should change the definition of ListNode and use RefCell. RefCell encapsulates unsafe code. You really need unsafe code here as you need to keep mutable pointers while changing the list at the same time. Otherwise, you need to traverse the list multiple times which is even worse. Recursion is not acceptable as it uses O(n/k) of memory. So here is my try on unsafe Rust. Happy to hear why it might go wrong.\\n\\n```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\n#[inline(always)]\\npub fn get_reversed_k_group(\\n    mut head: Option<Box<ListNode>>,\\n    k: i32,\\n) -> (Option<Box<ListNode>>, Option<Box<ListNode>>, bool) {\\n    // loop k times and reverse the list while looping\\n    // return the head of reversed list and the next node not yet reversed\\n    let mut prev = None;\\n    for _ in 0..k {\\n        if head.is_none() {\\n            // not enough nodes to reverse\\n            return (prev, head, false);\\n        }\\n        let next = head.as_mut().unwrap().next.take();\\n        head.as_mut().unwrap().next = prev;\\n        prev = head;\\n        head = next;\\n    }\\n    (prev, head, true)\\n}\\n\\n#[inline(always)]\\npub fn get_reversed_k_group_if_possible(\\n    mut head: Option<Box<ListNode>>,\\n    k: i32,\\n) -> (Option<Box<ListNode>>, Option<Box<ListNode>>) {\\n    // loop k times and reverse the list while looping\\n    // return the head of reversed list and the next node not yet reversed\\n    if k <= 1 {\\n        let next = head.as_mut().unwrap().next.take();\\n        return (head, next);\\n    }\\n    let (start_of_reversed, next, was_enough_items) = get_reversed_k_group(head, k);\\n    if was_enough_items {\\n        return (start_of_reversed, next);\\n    } else {\\n        let (start_of_reversed_back, _, _) = get_reversed_k_group(start_of_reversed, k);\\n        return (start_of_reversed_back, None);\\n    }\\n}\\n\\n\\n\\n\\n\\nimpl Solution {\\n\\tpub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n\\t\\t// this will have unsafe code as we need to keep a pointer to the last node of the reversed list\\n\\t\\tlet mut head = head;\\n\\t\\tif k <= 1 {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tif head.is_none() {\\n\\t\\t\\treturn None;\\n\\t\\t}\\n\\t\\tlet mut global_head = None;\\n\\t\\t// get raw pointer to head List Node\\n\\t\\tlet mut prev_last_node_in_reversed_list: *mut ListNode = &mut **head.as_mut().unwrap();\\n\\t\\tlet mut i = 0;\\n\\n\\t\\tloop {\\n\\t\\t\\tlet last_node_in_reversed_list: *mut ListNode = &mut **head.as_mut().unwrap();\\n\\n\\t\\t\\tlet (start_of_reversed, next) = get_reversed_k_group_if_possible(head, k);\\n\\t\\t\\tif global_head.is_none() {\\n\\t\\t\\t\\tglobal_head = start_of_reversed;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif i >= 1 {\\n\\t\\t\\t\\t\\tunsafe {\\n\\t\\t\\t\\t\\t\\t(*prev_last_node_in_reversed_list).next = start_of_reversed;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif next.is_none() {\\n\\t\\t\\t\\treturn global_head;\\n\\t\\t\\t}\\n\\t\\t\\thead = next;\\n\\t\\t\\tprev_last_node_in_reversed_list = last_node_in_reversed_list;\\n\\t\\t\\ti += 1\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\n#[inline(always)]\\npub fn get_reversed_k_group(\\n    mut head: Option<Box<ListNode>>,\\n    k: i32,\\n) -> (Option<Box<ListNode>>, Option<Box<ListNode>>, bool) {\\n    // loop k times and reverse the list while looping\\n    // return the head of reversed list and the next node not yet reversed\\n    let mut prev = None;\\n    for _ in 0..k {\\n        if head.is_none() {\\n            // not enough nodes to reverse\\n            return (prev, head, false);\\n        }\\n        let next = head.as_mut().unwrap().next.take();\\n        head.as_mut().unwrap().next = prev;\\n        prev = head;\\n        head = next;\\n    }\\n    (prev, head, true)\\n}\\n\\n#[inline(always)]\\npub fn get_reversed_k_group_if_possible(\\n    mut head: Option<Box<ListNode>>,\\n    k: i32,\\n) -> (Option<Box<ListNode>>, Option<Box<ListNode>>) {\\n    // loop k times and reverse the list while looping\\n    // return the head of reversed list and the next node not yet reversed\\n    if k <= 1 {\\n        let next = head.as_mut().unwrap().next.take();\\n        return (head, next);\\n    }\\n    let (start_of_reversed, next, was_enough_items) = get_reversed_k_group(head, k);\\n    if was_enough_items {\\n        return (start_of_reversed, next);\\n    } else {\\n        let (start_of_reversed_back, _, _) = get_reversed_k_group(start_of_reversed, k);\\n        return (start_of_reversed_back, None);\\n    }\\n}\\n\\n\\n\\n\\n\\nimpl Solution {\\n\\tpub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n\\t\\t// this will have unsafe code as we need to keep a pointer to the last node of the reversed list\\n\\t\\tlet mut head = head;\\n\\t\\tif k <= 1 {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tif head.is_none() {\\n\\t\\t\\treturn None;\\n\\t\\t}\\n\\t\\tlet mut global_head = None;\\n\\t\\t// get raw pointer to head List Node\\n\\t\\tlet mut prev_last_node_in_reversed_list: *mut ListNode = &mut **head.as_mut().unwrap();\\n\\t\\tlet mut i = 0;\\n\\n\\t\\tloop {\\n\\t\\t\\tlet last_node_in_reversed_list: *mut ListNode = &mut **head.as_mut().unwrap();\\n\\n\\t\\t\\tlet (start_of_reversed, next) = get_reversed_k_group_if_possible(head, k);\\n\\t\\t\\tif global_head.is_none() {\\n\\t\\t\\t\\tglobal_head = start_of_reversed;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif i >= 1 {\\n\\t\\t\\t\\t\\tunsafe {\\n\\t\\t\\t\\t\\t\\t(*prev_last_node_in_reversed_list).next = start_of_reversed;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif next.is_none() {\\n\\t\\t\\t\\treturn global_head;\\n\\t\\t\\t}\\n\\t\\t\\thead = next;\\n\\t\\t\\tprev_last_node_in_reversed_list = last_node_in_reversed_list;\\n\\t\\t\\ti += 1\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2598218,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k)\\n    {\\n        ListNode *h=head;\\n        int K=k;\\n        while(K--)\\n        {\\n            if(h==NULL) return head;\\n            h=h->next;\\n        }\\n        \\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        K=k;\\n        while(K--)\\n        {\\n            ListNode* nextNode = curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nextNode;\\n        }\\n        head->next=reverseKGroup(curr,k);\\n        return prev;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k)\\n    {\\n        ListNode *h=head;\\n        int K=k;\\n        while(K--)\\n        {\\n            if(h==NULL) return head;\\n            h=h->next;\\n        }\\n        \\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        K=k;\\n        while(K--)\\n        {\\n            ListNode* nextNode = curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nextNode;\\n        }\\n        head->next=reverseKGroup(curr,k);\\n        return prev;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593476,
                "title": "86-faster-simple-k-reverse-in-o-n-time",
                "content": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = temp = head\\n        nxt = None\\n        prev = None\\n        count = 0\\n\\n        # check if next count is equal to k\\n        while temp and count<k:\\n            temp = temp.next\\n            count += 1\\n        if count < k: \\n            return curr\\n\\n        # if k nodes then reverse\\n        count = 0\\n        while curr and count<k:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n            count += 1\\n\\n        # reverse next k\\n        if nxt :\\n            head.next = self.reverseKGroup(nxt, k)\\n\\n        return prev\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = temp = head\\n        nxt = None\\n        prev = None\\n        count = 0\\n\\n        # check if next count is equal to k\\n        while temp and count<k:\\n            temp = temp.next\\n            count += 1\\n        if count < k: \\n            return curr\\n\\n        # if k nodes then reverse\\n        count = 0\\n        while curr and count<k:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n            count += 1\\n\\n        # reverse next k\\n        if nxt :\\n            head.next = self.reverseKGroup(nxt, k)\\n\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566486,
                "title": "based-on-253-reverse-linked-list-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int length(ListNode * head)\\n{\\n    int len=0;\\n    while(head!=NULL){\\n        \\n        len++;\\n        head=head->next;\\n    }\\n    return len;\\n}\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *next=NULL;\\n         if(length(head) < k)\\n   {\\n       return head;\\n       //reverse ki maa ki aankh\\n   }\\n        for(int i=0;i<k;i++)\\n        {\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        head->next=reverseKGroup(curr,k);\\n        return prev;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2445505,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=2BCT3UEVkng",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=2BCT3UEVkng",
                "codeTag": "Unknown"
            },
            {
                "id": 2430932,
                "title": "c-accepted-best-approach-with-steps-explanation-easy-to-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Upvote if you like it!!!!***\\n\\n**Approach:**\\n\\nThe following steps are needed to arrive at the desired output. \\n\\n1. Create a dummy node. Point next to this node to head of the linked list provided.\\nIterate through the given linked list to get the length of the list.\\n2. Create three pointer pre,cur and nex to reverse each group. Why? If we observe output, we can see that we have to reverse each group, apart from modifying links of group.\\n3. Iterate through the linked list until the length of list to be processed is greater than and equal to given k.\\n4. For each iteration, point cur to pre->next and nex to nex->next.\\n5. Start nested iteration for length of k.\\n6. For each iteration, modify links as following steps:-\\n\\t\\t* cur->next = nex->next\\n\\t\\t* nex->next = pre->next\\n\\t\\t* pre->next = nex\\n\\t\\t* nex = cur->next\\n\\t\\t* Move pre to cur and reduce length by k.\\n7. At the end return dummy->next.\\n\\n**Dry run:**\\n\\n![image](https://assets.leetcode.com/users/images/555638ce-0be2-4a18-aaca-761ec92a0daa_1660591800.5138576.jpeg)\\n\\n**Code:-** \\n```\\nclass Solution {\\npublic:\\n    int listLength(ListNode* head){\\n        int len=0;\\n        while(head!=NULL){\\n            len++;\\n            head=head->next;\\n        }\\n        return len;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len=listLength(head);\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        ListNode* curr;\\n        ListNode* nex;\\n        \\n        while(len>=k){\\n            curr=prev->next;\\n            nex=curr->next;\\n            for(int i=1;i<k;i++){\\n                curr->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=curr->next;\\n            }\\n            prev=curr;\\n            len-=k;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int listLength(ListNode* head){\\n        int len=0;\\n        while(head!=NULL){\\n            len++;\\n            head=head->next;\\n        }\\n        return len;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len=listLength(head);\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        ListNode* curr;\\n        ListNode* nex;\\n        \\n        while(len>=k){\\n            curr=prev->next;\\n            nex=curr->next;\\n            for(int i=1;i<k;i++){\\n                curr->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=curr->next;\\n            }\\n            prev=curr;\\n            len-=k;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337808,
                "title": "simple-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public ListNode solve(ListNode head, int k, int n) {\\n        if(n<k) return head;      \\n        int i=0;\\n        ListNode temp=head, prev=null, next=null;\\n        while(i++<k) {\\n            next=temp.next;\\n            temp.next=prev;\\n            prev=temp;\\n            temp=next;\\n        }\\n        head.next= solve(temp,k, n-k);\\n        return prev;\\n    }\\n    \\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(k==1) return head;\\n        int n=0;\\n        ListNode temp=head;\\n        while(temp!=null) {\\n            temp=temp.next;\\n            n++;\\n        }\\n        return solve(head, k, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode solve(ListNode head, int k, int n) {\\n        if(n<k) return head;      \\n        int i=0;\\n        ListNode temp=head, prev=null, next=null;\\n        while(i++<k) {\\n            next=temp.next;\\n            temp.next=prev;\\n            prev=temp;\\n            temp=next;\\n        }\\n        head.next= solve(temp,k, n-k);\\n        return prev;\\n    }\\n    \\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(k==1) return head;\\n        int n=0;\\n        ListNode temp=head;\\n        while(temp!=null) {\\n            temp=temp.next;\\n            n++;\\n        }\\n        return solve(head, k, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177670,
                "title": "beginner-friendly-shortest-code-c-stack",
                "content": "Please **upvote** if it helped you to understand\\n\\n **Approach** :   \\n \\n**STEP 01**  :::     Traverse every k distance and keep inserting them in stack . \\n**STEP 02**  :::     Untill stack is empty pop & keep updating the values in linked list which is already in reversed form (  *Due to Stack* )\\n\\n**NOTE** :  *I have just shared my approach for the beginners ! You can definitely try with constant space*\\n\\nHere is the simple code : \\n\\n\\n```\\nListNode *reverseKGroup(ListNode *head, int k)\\n    {\\n        ListNode *fast = head, *slow = head;\\n        stack<int> st;\\n        while (fast){\\n            for (int i = 0; i < k; i++){\\n                if (fast) st.push(fast->val);\\n                else return head;\\n                fast = fast->next;\\n            }\\n            while (!st.empty()){\\n                slow->val = st.top();\\n                st.pop();\\n                slow = slow->next;\\n            }\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nListNode *reverseKGroup(ListNode *head, int k)\\n    {\\n        ListNode *fast = head, *slow = head;\\n        stack<int> st;\\n        while (fast){\\n            for (int i = 0; i < k; i++){\\n                if (fast) st.push(fast->val);\\n                else return head;\\n                fast = fast->next;\\n            }\\n            while (!st.empty()){\\n                slow->val = st.top();\\n                st.pop();\\n                slow = slow->next;\\n            }\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2066151,
                "title": "easy-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || k==1) return head;\\n        \\n        ListNode *dummy=new ListNode(0);\\n        dummy->next=head;\\n        \\n        ListNode *curr=dummy , *nex=dummy , *prev=dummy;\\n        int count=0;\\n        \\n        while(curr->next!=NULL){\\n            curr=curr->next;    //compute the length of LL\\n            count++;\\n        }\\n        \\n        while(count>=k){\\n            curr=prev->next;          //operations to reverse the LL in group of size k\\n            nex=curr->next;\\n            for(int i=1;i<k;i++){\\n                curr->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=curr->next;\\n            }\\n            prev=curr;        //move prev to curr and reduce length by k\\n            count-=k;\\n        }\\n        return dummy->next;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || k==1) return head;\\n        \\n        ListNode *dummy=new ListNode(0);\\n        dummy->next=head;\\n        \\n        ListNode *curr=dummy , *nex=dummy , *prev=dummy;\\n        int count=0;\\n        \\n        while(curr->next!=NULL){\\n            curr=curr->next;    //compute the length of LL\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2033880,
                "title": "python-iteration-recursion-all-variants",
                "content": "**Approach 1: Iterative**\\nThis has a time complexity of `O(N)` and space complexity of `O(1)`\\n```\\nclass Solution:\\n\\tdef reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n\\t\\tif not head or not head.next or k == 1: return head\\n\\n\\t\\tdummy = ListNode(-1, head)\\n\\t\\tgroupPrev = dummy\\n\\t\\twhile True:\\n\\t\\t\\t# Get kth node of the group\\n\\t\\t\\tkth = self.getKth(groupPrev, k)\\n\\t\\t\\tif not kth: break\\n\\t\\t\\tgroupNext = kth.next\\n\\n\\t\\t\\t# Reverse Group\\n\\t\\t\\tprev, curr = groupNext, groupPrev.next\\n\\t\\t\\twhile curr != groupNext:\\n\\t\\t\\t\\tcurr.next, prev, curr = prev, curr, curr.next\\n\\n\\t\\t\\t# Move groupPrev pointer to the next group position(node before next group)\\n\\t\\t\\tgroupPrev.next, groupPrev = kth, groupPrev.next\\n\\n\\t\\treturn dummy.next\\n\\n    def getKth(self, curr: ListNode, k: int) -> ListNode:\\n\\t\\twhile curr and k > 0:\\n\\t\\t\\tcurr = curr.next\\n\\t\\t\\tk -= 1\\n\\t\\treturn curr\\n```\\n\\n\\n**Approach 2: Recursive**\\nThis has a time complexity of `O(N)` and space complexity of `O(N/k)`\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n\\n        # Check if k group size is valid\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n            \\n        # Reverse k nodes\\n        prev, curr = None, head\\n        for _ in range(k):\\n            curr.next, prev, curr = prev, curr, curr.next\\n        \\n        # Recursively solve for the remaining list\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\\n\\n\\n**Variant 1: Reverse the remaining nodes as well**\\nGiven: `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8` and `k=3`\\nResult: `3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 8 -> 7`\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n            \\n        # Reverse k nodes and if there is no current node left we simply return the previous node\\n        prev, curr = None, head\\n        for _ in range(k):\\n\\t\\t\\tif not curr: return prev\\n            curr.next, prev, curr = prev, curr, curr.next\\n        \\n        # Recursively solve for the remaining list\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\\n\\n\\n**Variant 2: Reverse nodes in alternate groups of k size**\\nGiven: `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9` and `k=3`\\nResult: `3 -> 2 -> 1 -> 4 -> 5 -> 6 -> 9 -> 8 -> 7`\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n\\t\\t\\n\\t\\t# Check if k group size is valid\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n            \\n        # Reverse k nodes\\n        prev, curr = None, head\\n        for _ in range(k):\\n            curr.next, prev, curr = prev, curr, curr.next\\n\\t\\t\\n\\t\\t# Point head.next to the remaining list\\n\\t\\thead.next = curr\\n\\t\\t\\n\\t\\t# Skip next k nodes\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tcurr = curr.next\\n        \\n        # Recursively solve for the remaining list\\n\\t\\tif curr: curr.next = self.reverseKGroup(curr.next, k)\\n        return prev\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n\\tdef reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n\\t\\tif not head or not head.next or k == 1: return head\\n\\n\\t\\tdummy = ListNode(-1, head)\\n\\t\\tgroupPrev = dummy\\n\\t\\twhile True:\\n\\t\\t\\t# Get kth node of the group\\n\\t\\t\\tkth = self.getKth(groupPrev, k)\\n\\t\\t\\tif not kth: break\\n\\t\\t\\tgroupNext = kth.next\\n\\n\\t\\t\\t# Reverse Group\\n\\t\\t\\tprev, curr = groupNext, groupPrev.next\\n\\t\\t\\twhile curr != groupNext:\\n\\t\\t\\t\\tcurr.next, prev, curr = prev, curr, curr.next\\n\\n\\t\\t\\t# Move groupPrev pointer to the next group position(node before next group)\\n\\t\\t\\tgroupPrev.next, groupPrev = kth, groupPrev.next\\n\\n\\t\\treturn dummy.next\\n\\n    def getKth(self, curr: ListNode, k: int) -> ListNode:\\n\\t\\twhile curr and k > 0:\\n\\t\\t\\tcurr = curr.next\\n\\t\\t\\tk -= 1\\n\\t\\treturn curr\\n```\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n\\n        # Check if k group size is valid\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n            \\n        # Reverse k nodes\\n        prev, curr = None, head\\n        for _ in range(k):\\n            curr.next, prev, curr = prev, curr, curr.next\\n        \\n        # Recursively solve for the remaining list\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n            \\n        # Reverse k nodes and if there is no current node left we simply return the previous node\\n        prev, curr = None, head\\n        for _ in range(k):\\n\\t\\t\\tif not curr: return prev\\n            curr.next, prev, curr = prev, curr, curr.next\\n        \\n        # Recursively solve for the remaining list\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n\\t\\t\\n\\t\\t# Check if k group size is valid\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n            \\n        # Reverse k nodes\\n        prev, curr = None, head\\n        for _ in range(k):\\n            curr.next, prev, curr = prev, curr, curr.next\\n\\t\\t\\n\\t\\t# Point head.next to the remaining list\\n\\t\\thead.next = curr\\n\\t\\t\\n\\t\\t# Skip next k nodes\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tcurr = curr.next\\n        \\n        # Recursively solve for the remaining list\\n\\t\\tif curr: curr.next = self.reverseKGroup(curr.next, k)\\n        return prev\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565061,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567351,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1741989,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567812,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1566356,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1568842,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1569766,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567342,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1576658,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1573202,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1565061,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567351,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1741989,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567812,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1566356,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1568842,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1569766,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567342,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1576658,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1573202,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1895029,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1568843,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1569762,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1572951,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1568844,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1568845,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1567294,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1939776,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1930640,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1739295,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1572629,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 1572515,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 1571063,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 1571064,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 1572103,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 1571930,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 2062924,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 2055841,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 2052967,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 2048698,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 2047730,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 2030651,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 2018197,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1993036,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1984742,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1982930,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1949331,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1892920,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1867422,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1862969,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1857201,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1851233,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1834744,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1806565,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1803237,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1795466,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1791978,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1790635,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1783637,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1780679,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1773737,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1769419,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1760986,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1759434,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1758576,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1729687,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1717832,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1689427,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1682266,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1678311,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Valid Palindrome",
        "question_content": "<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>\n\n<p>Given a string <code>s</code>, return <code>true</code><em> if it is a <strong>palindrome</strong>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A man, a plan, a canal: Panama&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;amanaplanacanalpanama&quot; is a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;race a car&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;raceacar&quot; is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; &quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s is an empty string &quot;&quot; after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of printable ASCII characters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3165353,
                "title": "beats-96-9-well-explained-code-in-java",
                "content": "\\n\\n# Approach\\nThis code is an implementation of a solution to determine if a given string is a palindrome. A string is considered a palindrome if it reads the same forwards and backwards, ignoring spaces, punctuation, and letter casing.\\n\\nThe approach used in this solution is a two-pointer technique, where two pointers are maintained, one at the start of the string and the other at the end of the string. The two pointers move towards each other until they meet in the middle of the string.\\n\\nAt each iteration of the while loop, the characters pointed to by the start and last pointers are checked. If either of the characters is not a letter or digit (e.g., a space or punctuation), the pointer is moved one step to the right (for start) or one step to the left (for last) until a letter or digit is found.\\n\\nIf both characters are letters or digits, they are converted to lowercase and compared. If they are not equal, the function returns false, as the string is not a palindrome. If they are equal, both pointers are moved one step to the right and left, respectively.\\n\\nThe while loop continues until the start pointer is greater than the last pointer, indicating that all the characters have been checked and that the string is a palindrome. The function then returns true.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the length of the string. This is because, in the worst case, all characters in the string need to be checked once, so the number of operations is proportional to the length of the string.\\n\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is O(1), as no additional data structures are used, and only a constant amount of memory is required for the start and last pointers and a few variables.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        if (s.isEmpty()) {\\n        \\treturn true;\\n        }\\n        int start = 0;\\n        int last = s.length() - 1;\\n        while(start <= last) {\\n        \\tchar currFirst = s.charAt(start);\\n        \\tchar currLast = s.charAt(last);\\n        \\tif (!Character.isLetterOrDigit(currFirst )) {\\n        \\t\\tstart++;\\n        \\t} else if(!Character.isLetterOrDigit(currLast)) {\\n        \\t\\tlast--;\\n        \\t} else {\\n        \\t\\tif (Character.toLowerCase(currFirst) != Character.toLowerCase(currLast)) {\\n        \\t\\t\\treturn false;\\n        \\t\\t}\\n        \\t\\tstart++;\\n        \\t\\tlast--;\\n        \\t}\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/b12cb9bd-d3f5-43f8-aa22-9ddd4e30f15a_1675966495.975759.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        if (s.isEmpty()) {\\n        \\treturn true;\\n        }\\n        int start = 0;\\n        int last = s.length() - 1;\\n        while(start <= last) {\\n        \\tchar currFirst = s.charAt(start);\\n        \\tchar currLast = s.charAt(last);\\n        \\tif (!Character.isLetterOrDigit(currFirst )) {\\n        \\t\\tstart++;\\n        \\t} else if(!Character.isLetterOrDigit(currLast)) {\\n        \\t\\tlast--;\\n        \\t} else {\\n        \\t\\tif (Character.toLowerCase(currFirst) != Character.toLowerCase(currLast)) {\\n        \\t\\t\\treturn false;\\n        \\t\\t}\\n        \\t\\tstart++;\\n        \\t\\tlast--;\\n        \\t}\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40029,
                "title": "accepted-pretty-java-solution-271ms",
                "content": "    public class Solution {\\n        public boolean isPalindrome(String s) {\\n            if (s.isEmpty()) {\\n            \\treturn true;\\n            }\\n            int head = 0, tail = s.length() - 1;\\n            char cHead, cTail;\\n            while(head <= tail) {\\n            \\tcHead = s.charAt(head);\\n            \\tcTail = s.charAt(tail);\\n            \\tif (!Character.isLetterOrDigit(cHead)) {\\n            \\t\\thead++;\\n            \\t} else if(!Character.isLetterOrDigit(cTail)) {\\n            \\t\\ttail--;\\n            \\t} else {\\n            \\t\\tif (Character.toLowerCase(cHead) != Character.toLowerCase(cTail)) {\\n            \\t\\t\\treturn false;\\n            \\t\\t}\\n            \\t\\thead++;\\n            \\t\\ttail--;\\n            \\t}\\n            }\\n            \\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isPalindrome(String s) {\\n            if (s.isEmpty()) {\\n            \\treturn true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 39982,
                "title": "python-in-place-two-pointer-solution",
                "content": "        \\n    def isPalindrome(self, s):\\n        l, r = 0, len(s)-1\\n        while l < r:\\n            while l < r and not s[l].isalnum():\\n                l += 1\\n            while l <r and not s[r].isalnum():\\n                r -= 1\\n            if s[l].lower() != s[r].lower():\\n                return False\\n            l +=1; r -= 1\\n        return True",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "        \\n    def isPalindrome(self, s):\\n        l, r = 0, len(s)-1\\n        while l < r:\\n            while l < r and not s[l].isalnum():\\n                l += 1\\n            while l <r and not s[r].isalnum():\\n                r -= 1\\n            if s[l].lower() != s[r].lower():\\n                return False\\n            l +=1; r -= 1\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 40048,
                "title": "here-s-a-clean-c-solution",
                "content": "    bool isPalindrome(string s) {\\n        for (int i = 0, j = s.size() - 1; i < j; i++, j--) { // Move 2 pointers from each end until they collide\\n            while (isalnum(s[i]) == false && i < j) i++; // Increment left pointer if not alphanumeric\\n            while (isalnum(s[j]) == false && i < j) j--; // Decrement right pointer if no alphanumeric\\n            if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    bool isPalindrome(string s) {\\n        for (int i = 0, j = s.size() - 1; i < j; i++, j--) { // Move 2 pointers from each end until they collide\\n            while (isalnum(s[i]) == false && i < j) i++; // Increment left pointer if not alphanumeric\\n            while (isalnum(s[j]) == false && i < j) j--; // Decrement right pointer if no alphanumeric\\n            if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39981,
                "title": "my-three-line-java-solution",
                "content": "    public class Solution {\\n        public boolean isPalindrome(String s) {\\n            String actual = s.replaceAll(\"[^A-Za-z0-9]\", \"\").toLowerCase();\\n            String rev = new StringBuffer(actual).reverse().toString();\\n            return actual.equals(rev);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isPalindrome(String s) {\\n            String actual = s.replaceAll(\"[^A-Za-z0-9]\", \"\").toLowerCase();\\n            String rev = new StringBuffer(actual).reverse().toString();\\n            return actual.equals(rev);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3572960,
                "title": "super-clean-c-easy-code-with-explanation-o-n",
                "content": "# Intuition\\nBy reading the question you may think that first we need to convert the string to desired form and then check if its a valid palindrome or not.\\n\\nBut all of that is just distraction you can check valid palindrome by simply using two pointers no need to convert.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nIf a character is not alphanumeric we can simply ignore it and update our pointer to next character (for both pointers)\\n\\nand then we check by converting the alphanumeric character to lowercase (tolower() function on numbers has no change)\\nif those two are not equal then return false(not palindrome)\\nelse update both pointers and continue.\\n\\nFinally after all checking if reach at last then string must be a valid palindrome so return true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$ since only use two pointers\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       int start=0;\\n       int end=s.size()-1;\\n       while(start<=end){\\n           if(!isalnum(s[start])){start++; continue;}\\n           if(!isalnum(s[end])){end--;continue;}\\n           if(tolower(s[start])!=tolower(s[end]))return false;\\n           else{\\n               start++;\\n               end--;\\n           }\\n       }\\n       return true;\\n}\\n};\\n```\\n## PS - Please upvote (bottom left) if this solution was helpful :) It motivates me to write more solutions\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       int start=0;\\n       int end=s.size()-1;\\n       while(start<=end){\\n           if(!isalnum(s[start])){start++; continue;}\\n           if(!isalnum(s[end])){end--;continue;}\\n           if(tolower(s[start])!=tolower(s[end]))return false;\\n           else{\\n               start++;\\n               end--;\\n           }\\n       }\\n       return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40335,
                "title": "c-two-pointers",
                "content": "I think this problem, if asked at an interview, is to test whether a candidate is able to handle all edge cases systematically and write clean codes :-)\\n\\nTo avoid using `if-else` to handle lowercase and uppercase letters, I call `tolower` to convert all of them to lower case ones before comparison. And `tolower` will not change a number.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.size(), l = 0, r = n - 1;\\n        while (l < r) {\\n            while (l < r && !isalnum(s[l])) {\\n                l++;\\n            }\\n            while (l < r && !isalnum(s[r])) {\\n                r--;\\n            }\\n            if (tolower(s[l++]) != tolower(s[r--])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.size(), l = 0, r = n - 1;\\n        while (l < r) {\\n            while (l < r && !isalnum(s[l])) {\\n                l++;\\n            }\\n            while (l < r && !isalnum(s[r])) {\\n                r--;\\n            }\\n            if (tolower(s[l++]) != tolower(s[r--])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40291,
                "title": "java-9ms-solution-with-some-of-my-thoughts",
                "content": "My thoughts on this problem is that the interviewers are not looking at a solution using Regex, it would be too trivial, plus it would take O(n) space to save the new trimmed string.  I would just use plain two points to traverse the string and compare them ignore case.  It is O(n) time and O(1) space guaranteed and no expensive string concatenation is required.\\n\\n    public class Solution {\\n        public boolean isPalindrome(String s) {\\n            int start = 0; \\n            int end = s.length() - 1;\\n            while(start <= end) {\\n                while(start <= end && !Character.isLetterOrDigit(s.charAt(start))) {\\n                    start++;\\n                }\\n                while(start <= end && !Character.isLetterOrDigit(s.charAt(end))) {\\n                    end--;\\n                }\\n                if(start <= end && Character.toLowerCase(s.charAt(start)) != Character.toLowerCase(s.charAt(end))) {\\n                    return false;\\n                }\\n                start++;\\n                end--;\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n        public boolean isPalindrome(String s) {\\n            int start = 0; \\n            int end = s.length() - 1;\\n            while(start <= end) {\\n                while(start <= end && !Character.isLetterOrDigit(s.charAt(start))) {\\n                    start++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2743562,
                "title": "java-o-n-solution-easy-understanding",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase().replaceAll(\"[^a-z0-9]\", \"\");\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while(i <= j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**Please upvote if you found this helpful.**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase().replaceAll(\"[^a-z0-9]\", \"\");\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while(i <= j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350929,
                "title": "solution-in-python-3-beats-100-two-lines-o-1-solution-as-well",
                "content": "*Solution 1:  Two Lines*\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n    \\ts = [i for i in s.lower() if i.isalnum()]\\n    \\treturn s == s[::-1]\\n```\\n\\n\\n*Solution 2:  O(1) space (two-pointer)*\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n    \\ti, j = 0, len(s) - 1\\n    \\twhile i < j:\\n    \\t\\ta, b = s[i].lower(), s[j].lower()\\n    \\t\\tif a.isalnum() and b.isalnum():\\n    \\t\\t\\tif a != b: return False\\n    \\t\\t\\telse:\\n    \\t\\t\\t\\ti, j = i + 1, j - 1\\n    \\t\\t\\t\\tcontinue\\n    \\t\\ti, j = i + (not a.isalnum()), j - (not b.isalnum())\\n    \\treturn True\\n\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n    \\ts = [i for i in s.lower() if i.isalnum()]\\n    \\treturn s == s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458911,
                "title": "easy-c-two-pointers-o-n-solution",
                "content": "```\\n    bool isPalindrome(string s) {\\n        int left = 0, right = s.length()-1;\\n        while(left<right)\\n        {\\n            if(!isalnum(s[left])) left++;\\n            else if(!isalnum(s[right])) right--;\\n            else if(tolower(s[left])!=tolower(s[right])) return false;\\n            else {left++; right--;}\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    bool isPalindrome(string s) {\\n        int left = 0, right = s.length()-1;\\n        while(left<right)\\n        {\\n            if(!isalnum(s[left])) left++;\\n            else if(!isalnum(s[right])) right--;\\n            else if(tolower(s[left])!=tolower(s[right])) return false;\\n            else {left++; right--;}\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40261,
                "title": "passed-clean-c-code",
                "content": "    bool isPalindrome(string s) {\\n\\t\\tint start=0, end=s.length()-1;\\n\\t\\twhile(start<end) {\\n\\t\\t\\tif (!isalnum(s[start])) start++;\\n\\t\\t\\telse if (!isalnum(s[end])) end--;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (tolower(s[start++])!=tolower(s[end--])) return false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n    }",
                "solutionTags": [],
                "code": "    bool isPalindrome(string s) {\\n\\t\\tint start=0, end=s.length()-1;\\n\\t\\twhile(start<end) {\\n\\t\\t\\tif (!isalnum(s[start])) start++;\\n\\t\\t\\telse if (!isalnum(s[end])) end--;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (tolower(s[start++])!=tolower(s[end--])) return false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 770465,
                "title": "python-two-pointers-o-n-time-o-1-space-explained",
                "content": "One way to solve this problem is to create new string with only alphanumeric symbols and then check if it is palindrome. However we need `O(n)` space for this. There is more subtle approach, using **Two Pointers** technique.\\n\\n1. Start with `beg = 0` and `end = len(s) - 1`, the first and the last symbols of string `s`.\\n2. Now, we are going to move iterator `beg` only to the right and iterator `end` only to the left. Let us move them, until we reach alphanumeric symbols, using `isalnum()` function.\\n3. Compare these two symbols. We are happy, if they are equal, or it is the same letter in different capitalization, for example `q` and `Q`. How to check this case? Make both symbols capitalized, using `.upper()` and compare them.\\n4. In opposite case, immidietly return `False`.\\n5. If we reached the end of or program and we did not return `False`, then we need to return `True`.\\n\\n**Complexity**: Time complexity is `O(n)`, because we move `beg` only to the right and `end` only to the left, until they meet. Space complexity is `O(1)`, we just use a couple of additional variables.\\n\\n```\\nclass Solution:\\n    def isPalindrome(self, s):\\n        beg, end = 0, len(s) - 1\\n        while beg <= end:\\n            while not s[beg].isalnum() and beg < end: beg += 1\\n            while not s[end].isalnum() and beg < end: end -= 1\\n            if s[beg] == s[end] or s[beg].upper() == s[end].upper():\\n                beg, end = beg + 1, end - 1\\n            else:\\n                return False\\n        return True\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s):\\n        beg, end = 0, len(s) - 1\\n        while beg <= end:\\n            while not s[beg].isalnum() and beg < end: beg += 1\\n            while not s[end].isalnum() and beg < end: end -= 1\\n            if s[beg] == s[end] or s[beg].upper() == s[end].upper():\\n                beg, end = beg + 1, end - 1\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554098,
                "title": "simple-javascript-soluton",
                "content": "Runtime: 64 ms, faster than 91.75% of JavaScript online submissions for Valid Palindrome.\\nMemory Usage: 36.5 MB, less than 100.00% of JavaScript online \\n```\\nconst isPalindrome = s => {\\n  s = s.toLowerCase().replace(/[^a-z0-9]/gi,\\'\\');\\n  for (let i = 0, j = s.length - 1; i <= j; i++, j--) {\\n    if (s.charAt(i) !== s.charAt(j)) return false;\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isPalindrome = s => {\\n  s = s.toLowerCase().replace(/[^a-z0-9]/gi,\\'\\');\\n  for (let i = 0, j = s.length - 1; i <= j; i++, j--) {\\n    if (s.charAt(i) !== s.charAt(j)) return false;\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40094,
                "title": "challenge-me-shortest-possible-answer-in-python-for-valid-palindrome-life-is-short-we-need-python",
                "content": "    class Solution:\\n    def isPalindrome(self, s):\\n        newS= [i.lower() for i in s if i.isalnum()]\\n        return newS == newS[::-1]\\n        #return newS[:len(newS)/2] == newS[(len(newS)+1)/2:][::-1]  # This one is better, but too long",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    def isPalindrome(self, s):\\n        newS= [i.lower() for i in s if i.isalnum()]\\n        return newS == newS[::-1]\\n        #return newS[:len(newS)/2] == newS[(len(newS)+1)/2:][::-1]  # This one is better, but too long",
                "codeTag": "Java"
            },
            {
                "id": 39993,
                "title": "3ms-java-solution-beat-100-of-java-solution",
                "content": "simply build an array that map all possible char into integer(if not alphanumeric,mark it as zero)\\n\\nthis will help to speed up the process a lot.\\n\\n    private static final char[]charMap = new char[256];\\n    static{\\n        for(int i=0;i<10;i++){\\n            charMap[i+'0'] = (char)(1+i);  // numeric\\n        }\\n        for(int i=0;i<26;i++){\\n            charMap[i+'a'] = charMap[i+'A'] = (char)(11+i);  //alphabetic, ignore cases\\n        }\\n    }\\n    public boolean isPalindrome(String s) {\\n        char[]pChars = s.toCharArray();\\n        int start = 0,end=pChars.length-1;\\n        char cS,cE;\\n        while(start<end){\\n            cS = charMap[pChars[start]];\\n            cE = charMap[pChars[end]];\\n            if(cS!=0 && cE!=0){\\n                if(cS!=cE)return false;\\n                start++;\\n                end--;\\n            }else{\\n                if(cS==0)start++;\\n                if(cE==0)end--;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "simply build an array that map all possible char into integer(if not alphanumeric,mark it as zero)\\n\\nthis will help to speed up the process a lot.\\n\\n    private static final char[]charMap = new char[256];\\n    static{\\n        for(int i=0;i<10;i++){\\n            charMap[i+'0'] = (char)(1+i);  // numeric\\n        }\\n        for(int i=0;i<26;i++){\\n            charMap[i+'a'] = charMap[i+'A'] = (char)(11+i);  //alphabetic, ignore cases\\n        }\\n    }\\n    public boolean isPalindrome(String s) {\\n        char[]pChars = s.toCharArray();\\n        int start = 0,end=pChars.length-1;\\n        char cS,cE;\\n        while(start<end){\\n            cS = charMap[pChars[start]];\\n            cE = charMap[pChars[end]];\\n            if(cS!=0 && cE!=0){\\n                if(cS!=cE)return false;\\n                start++;\\n                end--;\\n            }else{\\n                if(cS==0)start++;\\n                if(cE==0)end--;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1353337,
                "title": "c-simple-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int l=0,r=s.size()-1;\\n        while(l<r)\\n        {\\n            if(!isalnum(s[l]))\\n                l++;\\n            else if(!isalnum(s[r]))\\n                r--;\\n            else if(tolower(s[l])!=tolower(s[r]))\\n                return false;\\n            else\\n            {\\n                l++;\\n                r--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**If you like it , Do upvote\\nHappy Coding;**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int l=0,r=s.size()-1;\\n        while(l<r)\\n        {\\n            if(!isalnum(s[l]))\\n                l++;\\n            else if(!isalnum(s[r]))\\n                r--;\\n            else if(tolower(s[l])!=tolower(s[r]))\\n                return false;\\n            else\\n            {\\n                l++;\\n                r--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40238,
                "title": "128ms-100-javascript-solution-super-easy-to-understand",
                "content": "    /**\\n     * @param {string} s\\n     * @return {boolean}\\n     */\\n    var isPalindrome = function(input) {\\n        var start = 0\\n        var end = input.length - 1\\n        while (start < end) {\\n            var s = input.charCodeAt(start)\\n            var e = input.charCodeAt(end)\\n        \\n            if (!isLetter(s)) {\\n                start++\\n                continue\\n            }\\n            if (!isLetter(e)) {\\n                end--\\n                continue\\n            }\\n        \\n            if (toLowerCase(s) !== toLowerCase(e)) {\\n                return false \\n            } \\n            start++\\n            end--\\n      }\\n      return true\\n    };\\n    \\n    var isLetter = function(code) {\\n        if (((code >= 48) && (code <= 57))  // numbers\\n        || ((code >= 65) && (code <= 90))  // uppercase\\n        || ((code >= 97) && (code <= 122))) {  // lowercase\\n            return true\\n        }\\n        else {\\n            return false\\n        }\\n    }\\n    \\n    var toLowerCase = function(code) {\\n        if (code >= 65 && code <= 90) {\\n            return code + 32    \\n        }\\n        else {\\n            return code\\n        }\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * @param {string} s\\n     * @return {boolean}\\n     */\\n    var isPalindrome = function(input) {\\n        var start = 0\\n        var end = input.length - 1\\n        while (start < end) {\\n            var s = input.charCodeAt(start)\\n            var e = input.charCodeAt(end)\\n        \\n            if (!isLetter(s)) {\\n                start++\\n                continue\\n            }\\n            if (!isLetter(e)) {\\n                end--\\n                continue\\n            }\\n        \\n            if (toLowerCase(s) !== toLowerCase(e)) {\\n                return false \\n            } \\n            start++\\n            end--\\n      }\\n      return true\\n    };\\n    \\n    var isLetter = function(code) {\\n        if (((code >= 48) && (code <= 57))  // numbers\\n        || ((code >= 65) && (code <= 90))  // uppercase\\n        || ((code >= 97) && (code <= 122))) {  // lowercase\\n            return true\\n        }\\n        else {\\n            return false\\n        }\\n    }\\n    \\n    var toLowerCase = function(code) {\\n        if (code >= 65 && code <= 90) {\\n            return code + 32    \\n        }\\n        else {\\n            return code\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1496675,
                "title": "java-tc-o-n-sc-o-1-one-pass-solution-using-two-pointers",
                "content": "```java\\n/**\\n * One Pass Solution using two pointers\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input string.\\n */\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\\n                left++;\\n            }\\n            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\\n                right--;\\n            }\\n\\n            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {\\n                return false;\\n            }\\n\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Palindrome questions on LeetCode:\\n- [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/discuss/1539190/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Two-Optimized-solutions-with-Early-Exit-Condition)\\n- [9. Palindrome Number](https://leetcode.com/problems/palindrome-number/discuss/1527951/Java-or-TC:-O((log10-N)2)-or-SC:-O(1)-or-Optimal-Reverse-Half-and-Compare)\\n- [266. Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/discuss/1527941/Java-or-TC:-O(N)-or-SC:-O(N)-or-Early-Exit-and-Space-Optimized-HashSet-solution)\\n- [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/1527948/Java-or-TC:-O(N*(N2)!)-or-SC:-O(N)-or-Optimal-Backtracking-using-CountMap)\\n- [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/discuss/1539193/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Optimized-solution-for-continuous-repeating-chars)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```java\\n/**\\n * One Pass Solution using two pointers\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input string.\\n */\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\\n                left++;\\n            }\\n            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\\n                right--;\\n            }\\n\\n            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {\\n                return false;\\n            }\\n\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151720,
                "title": "python3-o-n-time-o-1-space-well-explained",
                "content": "The idea is to hold two pointers and compare the outermost two characters moving inwards until we meet in the middle. We skip over non-alpha-numeric chracters and compare the lowercase versions of the letters/numbers when we do our comparisons.\\n\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # i starts at beginning of s and j starts at the end         \\n        i, j = 0, len(s) - 1\\n        # While i is still before j        \\n        while i < j:\\n            # If i is not an alpha-numeric character then advance i            \\n            if not s[i].isalnum():\\n                i += 1\\n            # If j is not an alpha-numeric character then advance i\\n            elif not s[j].isalnum():\\n                j -= 1\\n            # Both i and j are alpha-numeric characters at this point so if they do not match return the fact that input was non-palendromic\\n            elif s[i].lower() != s[j].lower():\\n                return False\\n            # Otherwise characters matched and we should look at the next pair of characters\\n            else:\\n                i, j = i + 1, j - 1\\n        # The entire stirng was verified and we return the fact that the input string was palendromic         \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # i starts at beginning of s and j starts at the end         \\n        i, j = 0, len(s) - 1\\n        # While i is still before j        \\n        while i < j:\\n            # If i is not an alpha-numeric character then advance i            \\n            if not s[i].isalnum():\\n                i += 1\\n            # If j is not an alpha-numeric character then advance i\\n            elif not s[j].isalnum():\\n                j -= 1\\n            # Both i and j are alpha-numeric characters at this point so if they do not match return the fact that input was non-palendromic\\n            elif s[i].lower() != s[j].lower():\\n                return False\\n            # Otherwise characters matched and we should look at the next pair of characters\\n            else:\\n                i, j = i + 1, j - 1\\n        # The entire stirng was verified and we return the fact that the input string was palendromic         \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970824,
                "title": "java-runtime-2ms-beats-99-64",
                "content": "# Intuition\\nMy initial approach to solving this problem involves determining whether a given string is a palindrome after removing non-alphanumeric characters and ignoring case sensitivity.\\n\\n# Approach\\nTo achieve this, I utilize a two-pointer approach. The pointers start from the beginning and the end of the string, and they move towards each other. At each step, I examine the characters at both pointers. If either character is not an alphanumeric character, I adjust the pointer accordingly. If both characters are alphanumeric, I compare them while ignoring case sensitivity. If they are not equal, the string cannot be a palindrome, and I return `false`. Otherwise, I continue moving the pointers closer to each other. If the pointers cross paths, the string has been successfully determined to be a palindrome.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm iterates through the string once, and at each step, it performs constant time operations. Thus, the time complexity is linear with respect to the length of the string.\\n\\n- Space complexity: O(1)\\n  The algorithm utilizes a constant amount of additional memory space for variables, leading to a constant space complexity.\\n\\n# Code\\n```java\\nclass Solution {\\n   public boolean isPalindrome(String s) {\\n        if (s.isEmpty()) {\\n            return true;\\n        }\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            char leftChar = s.charAt(left);\\n            char rightChar = s.charAt(right);\\n\\n            if (!Character.isLetterOrDigit(leftChar)) {\\n                left++;\\n            } else if (!Character.isLetterOrDigit(rightChar)) {\\n                right--;\\n            } else {\\n                if (Character.toLowerCase(leftChar) != Character.toLowerCase(rightChar)) {\\n                    return false;\\n                }\\n                left++;\\n                right--;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n   public boolean isPalindrome(String s) {\\n        if (s.isEmpty()) {\\n            return true;\\n        }\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            char leftChar = s.charAt(left);\\n            char rightChar = s.charAt(right);\\n\\n            if (!Character.isLetterOrDigit(leftChar)) {\\n                left++;\\n            } else if (!Character.isLetterOrDigit(rightChar)) {\\n                right--;\\n            } else {\\n                if (Character.toLowerCase(leftChar) != Character.toLowerCase(rightChar)) {\\n                    return false;\\n                }\\n                left++;\\n                right--;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652672,
                "title": "2-simple-python-solutions-two-pointers-approach-beats-99-99",
                "content": "# Intuition\\nThe code aims to determine whether a given string is a palindrome or not. A palindrome is a string that reads the same forwards and backwards. The code uses two pointers, l and r, to traverse the string from the beginning and end simultaneously. It skips non-alphanumeric characters and compares the corresponding characters at l and r positions. If at any point the characters are not equal, the string is not a palindrome. If the pointers meet or cross each other, the string is a palindrome.\\n\\n# Approach\\n1. Initialize l and r as the left and right pointers.\\n2. While l is less than r:\\n    1. Increment l until it points to an alphanumeric character.\\n    2. Decrement r until it points to an alphanumeric character.\\n    3. If l becomes greater than r, return True as the string is a palindrome.\\n    4. Compare characters at l and r (case-insensitive):\\n        1. If they are not equal, return False as the string is not a palindrome.\\n        2. If they are equal, increment l and decrement r.\\n3. Return True if the loop completes without finding any mismatch.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n\\nSolution 1: (Two Pointers | Beats 99.99%)\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        l = 0\\n        r = len(s) - 1\\n        \\n        while l < r:\\n            \\n            while l < r and s[l].isalnum() == False: \\n                l += 1\\n            while r > l and s[r].isalnum() == False: \\n                r -= 1\\n            if l > r or s[l].lower() != s[r].lower():\\n                return False\\n            else:\\n                l += 1\\n                r -= 1\\n        return True\\n                    \\n```\\n\\nSolution 2: (Simple two liner)\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s = [char.lower() for char in s if char.isalnum()]\\n        return s == s[::-1]\\n```\\n\\nPlease \"Upvote\" if you find it useful.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        l = 0\\n        r = len(s) - 1\\n        \\n        while l < r:\\n            \\n            while l < r and s[l].isalnum() == False: \\n                l += 1\\n            while r > l and s[r].isalnum() == False: \\n                r -= 1\\n            if l > r or s[l].lower() != s[r].lower():\\n                return False\\n            else:\\n                l += 1\\n                r -= 1\\n        return True\\n                    \\n```\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s = [char.lower() for char in s if char.isalnum()]\\n        return s == s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994185,
                "title": "my-3-lines-code-of-java-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconvert all String to Lowercase and reverse the String  and then check\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing replaceAll and reverse Methods of String\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public boolean isPalindrome(String s) {\\n        // convert Strign s to lowerCase with regex\\n        String tempString = s.replaceAll(\"[^A-Za-z0-9]\", \"\").toLowerCase();\\n        // Reverse the tempString \\n        String rev = new StringBuffer(tempString).reverse().toString();\\n        // check tempString to rev String \\n        return tempString.equals(rev);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean isPalindrome(String s) {\\n        // convert Strign s to lowerCase with regex\\n        String tempString = s.replaceAll(\"[^A-Za-z0-9]\", \"\").toLowerCase();\\n        // Reverse the tempString \\n        String rev = new StringBuffer(tempString).reverse().toString();\\n        // check tempString to rev String \\n        return tempString.equals(rev);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894440,
                "title": "trivial-two-line-solution-normalize-then-compare",
                "content": "First, we lower every character and exclude all non-alphanumeric ones.\\nSecond, we compare the result to its reversed version using `SequenceEqual`.\\n```csharp\\npublic bool IsPalindrome(string s)\\n{    \\n    var clean = s.ToLower().Where(x => char.IsLetterOrDigit(x));\\n    return clean.Reverse().SequenceEqual(clean);\\n}\\n```\\nThere is no need to convert the enumerable to an array or a string.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic bool IsPalindrome(string s)\\n{    \\n    var clean = s.ToLower().Where(x => char.IsLetterOrDigit(x));\\n    return clean.Reverse().SequenceEqual(clean);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1161779,
                "title": "3-different-approach-95-faster",
                "content": "* 95% Faster\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string curr = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n            if((s[i] >= \\'a\\' && s[i] <= \\'z\\') || (s[i] >= \\'A\\' && s[i] <= \\'Z\\') || (s[i] >= \\'0\\' && s[i] <= \\'9\\'))\\n                curr += s[i];\\n        \\n        transform(curr.begin(),curr.end(), curr.begin(), :: tolower);\\n        int i = 0, j = curr.size() - 1;\\n        while(i <= j)\\n        {\\n            if(curr[i] != curr[j])\\n                return false;\\n            i++; j--;\\n        }\\n        return true;   \\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string curr1 = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n            if((s[i] >= \\'a\\' && s[i] <= \\'z\\') || (s[i] >= \\'A\\' && s[i] <= \\'Z\\') || (s[i] >= \\'0\\' && s[i] <= \\'9\\'))\\n                curr1 += s[i];\\n        \\n\\t\\ttransform(curr1.begin(),curr1.end(), curr1.begin(), :: tolower);\\n        string curr2 = curr1;\\n        reverse(curr2.begin(), curr2.end());\\n        if(curr1 == curr2)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string curr = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n            if(isalnum(s[i]))\\n                curr.push_back(s[i]);\\n        transform(curr.begin(),curr.end(),curr.begin(), :: tolower);\\n        int i = 0, j = curr.size() - 1;\\n        while(i <= j)\\n        {\\n            if(curr[i] != curr[j])\\n                return false;\\n            i++; j--;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string curr = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n            if((s[i] >= \\'a\\' && s[i] <= \\'z\\') || (s[i] >= \\'A\\' && s[i] <= \\'Z\\') || (s[i] >= \\'0\\' && s[i] <= \\'9\\'))\\n                curr += s[i];\\n        \\n        transform(curr.begin(),curr.end(), curr.begin(), :: tolower);\\n        int i = 0, j = curr.size() - 1;\\n        while(i <= j)\\n        {\\n            if(curr[i] != curr[j])\\n                return false;\\n            i++; j--;\\n        }\\n        return true;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string curr1 = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n            if((s[i] >= \\'a\\' && s[i] <= \\'z\\') || (s[i] >= \\'A\\' && s[i] <= \\'Z\\') || (s[i] >= \\'0\\' && s[i] <= \\'9\\'))\\n                curr1 += s[i];\\n        \\n\\t\\ttransform(curr1.begin(),curr1.end(), curr1.begin(), :: tolower);\\n        string curr2 = curr1;\\n        reverse(curr2.begin(), curr2.end());\\n        if(curr1 == curr2)\\n            return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string curr = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n            if(isalnum(s[i]))\\n                curr.push_back(s[i]);\\n        transform(curr.begin(),curr.end(),curr.begin(), :: tolower);\\n        int i = 0, j = curr.size() - 1;\\n        while(i <= j)\\n        {\\n            if(curr[i] != curr[j])\\n                return false;\\n            i++; j--;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122549,
                "title": "regexp-two-liner-faster-approach",
                "content": "# Code\\n```\\nvar isPalindrome = function(s) {\\n    let newStr = s.replace(/[^a-z0-9]/gi,\"\").toLowerCase();\\n    return newStr.split(\"\").reverse().join(\"\") === newStr ? true : false;\\n};\\n```\\n\\nPlease Upvote If you like my approach towards solution.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(s) {\\n    let newStr = s.replace(/[^a-z0-9]/gi,\"\").toLowerCase();\\n    return newStr.split(\"\").reverse().join(\"\") === newStr ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2438656,
                "title": "very-easy-100-fully-explained-java-c-python-js-python3",
                "content": "# **Java Solution:**\\nRuntime: 1 ms, faster than 99.93% of Java online submissions for Valid Palindrome.\\nMemory Usage: 42.2 MB, less than 96.18% of Java online submissions for Valid Palindrome.\\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        // Base case\\n        if(s==null)  return false;\\n        // Take in lowercase character...\\n        s = s.toLowerCase();\\n        // Initialize two pointer variables, left and right and point them with the two ends of the input string...\\n        int left = 0;\\n        int right = s.length()-1;\\n        // Traverse all elements through the loop...\\n        while(left<right){\\n            // Move the left pointer to right so it points to a alphanumeric character...\\n            while(left<right && !((s.charAt(left)>=\\'a\\' && s.charAt(left)<=\\'z\\') || (s.charAt(left)>=\\'0\\'&&s.charAt(left)<=\\'9\\'))){\\n                left++;\\n            }\\n            // Similarly move right pointer to left so it also points to a alphanumeric character...\\n            while(left<right && !((s.charAt(right)>=\\'a\\' && s.charAt(right)<=\\'z\\') || (s.charAt(right)>=\\'0\\'&&s.charAt(right)<=\\'9\\'))){\\n                right--;\\n            }\\n            // Check if both the characters are same...\\n            // If it is not equal then the string is not a valid palindrome, hence return false...\\n            if(s.charAt(left) != s.charAt(right)){\\n                return false;\\n            }\\n            // If same, then continue to next iteration and move both pointers to point to next alphanumeric character till left < right...\\n            left++;\\n            right--;\\n        }\\n        // After loop finishes, the string is said to be palindrome, hence return true...\\n        return true;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 2 ms, faster than 93.25% of C++ online submissions for Valid Palindrome.\\nMemory Usage: 7.1 MB, less than 90.69% of C++ online submissions for Valid Palindrome.\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        // Base Case...\\n        if(s.empty())  return true;\\n        // Initialize two pointer variables, left and right and point them with the two ends of the input string...\\n        int left = 0, right = s.length() - 1;\\n        // Traverse all elements through the loop...\\n        while(left < right) {\\n            // if both the characters are same...\\n            // Continue to next iteration and move both pointers to point to next alphanumeric character till left < right...\\n            if(tolower(s[left]) == tolower(s[right])) {\\n                left++;\\n                right--;\\n            }\\n            // Move the left pointer to right so it points to a alphanumeric character...\\n            else if(!isalpha(s[left]) && !isdigit(s[left])) {\\n                left++;\\n            }\\n            // Similarly move right pointer to left so it also points to a alphanumeric character...\\n            else if(!isalpha(s[right]) && !isdigit(s[right])) {\\n                right--;\\n            }\\n            // Otherwise return false...\\n            else{\\n                return false;\\n            }\\n        }\\n        // After loop finishes, the string is said to be palindrome, hence return true...\\n        return true;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n        # Initialize two pointer variables, left and right and point them with the two ends of the input string...\\n        left, right = 0, len(s) - 1\\n        # Traverse all elements through the loop...\\n        while left < right:\\n            # Move the left pointer to right so it points to a alphanumeric character...\\n            while left < right and not s[left].isalnum():\\n                left += 1\\n            # Similarly move right pointer to left so it also points to a alphanumeric character...\\n            while left < right and not s[right].isalnum():\\n                right -= 1\\n            # Check if both the characters are same...\\n            # If it is not equal then the string is not a valid palindrome, hence return false...\\n            if s[left].lower() != s[right].lower():\\n                return False\\n            # If same, then continue to next iteration and move both pointers to point to next alphanumeric character till left < right...\\n            left, right = left + 1, right - 1\\n        # After loop finishes, the string is said to be palindrome, hence return true...\\n        return True\\n```\\n        \\n# **JavaScript Solution:**\\n```\\nvar isPalindrome = function(s) {\\n    // Base case\\n    if(s==null)  return false;\\n    // Take in lowercase character...\\n    s = s.toLowerCase();\\n    // Initialize two pointer variables, left and right and point them with the two ends of the input string...\\n    let left = 0;\\n    let right = s.length - 1;\\n    // Traverse all elements through the loop...\\n    while(left < right){\\n        // Move the left pointer to right so it points to a alphanumeric character...\\n        while(left < right && !((s.charAt(left) >= \\'a\\' && s.charAt(left) <= \\'z\\') || (s.charAt(left) >= \\'0\\' && s.charAt(left) <= \\'9\\'))){\\n            left++;\\n        }\\n        // Similarly move right pointer to left so it also points to a alphanumeric character...\\n        while(left < right && !((s.charAt(right) >= \\'a\\' && s.charAt(right) <= \\'z\\') || (s.charAt(right) >= \\'0\\' && s.charAt(right) <= \\'9\\'))){\\n            right--;\\n        }\\n        // Check if both the characters are same...\\n        // If it is not equal then the string is not a valid palindrome, hence return false...\\n        if(s.charAt(left) != s.charAt(right)){\\n            return false;\\n        }\\n        // If same, then continue to next iteration and move both pointers to point to next alphanumeric character till left < right...\\n        left++;\\n        right--;\\n    }\\n    // After loop finishes, the string is said to be palindrome, hence return true...\\n    return true;\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # Initialize two pointer variables, left and right and point them with the two ends of the input string...\\n        left, right = 0, len(s) - 1\\n        # Traverse all elements through the loop...\\n        while left < right:\\n            # Move the left pointer to right so it points to a alphanumeric character...\\n            while left < right and not s[left].isalnum():\\n                left += 1\\n            # Similarly move right pointer to left so it also points to a alphanumeric character...\\n            while left < right and not s[right].isalnum():\\n                right -= 1\\n            # Check if both the characters are same...\\n            # If it is not equal then the string is not a valid palindrome, hence return false...\\n            if s[left].lower() != s[right].lower():\\n                return False\\n            # If same, then continue to next iteration and move both pointers to point to next alphanumeric character till left < right...\\n            left, right = left + 1, right - 1\\n        # After loop finishes, the string is said to be palindrome, hence return true...\\n        return True\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        // Base case\\n        if(s==null)  return false;\\n        // Take in lowercase character...\\n        s = s.toLowerCase();\\n        // Initialize two pointer variables, left and right and point them with the two ends of the input string...\\n        int left = 0;\\n        int right = s.length()-1;\\n        // Traverse all elements through the loop...\\n        while(left<right){\\n            // Move the left pointer to right so it points to a alphanumeric character...\\n            while(left<right && !((s.charAt(left)>=\\'a\\' && s.charAt(left)<=\\'z\\') || (s.charAt(left)>=\\'0\\'&&s.charAt(left)<=\\'9\\'))){\\n                left++;\\n            }\\n            // Similarly move right pointer to left so it also points to a alphanumeric character...\\n            while(left<right && !((s.charAt(right)>=\\'a\\' && s.charAt(right)<=\\'z\\') || (s.charAt(right)>=\\'0\\'&&s.charAt(right)<=\\'9\\'))){\\n                right--;\\n            }\\n            // Check if both the characters are same...\\n            // If it is not equal then the string is not a valid palindrome, hence return false...\\n            if(s.charAt(left) != s.charAt(right)){\\n                return false;\\n            }\\n            // If same, then continue to next iteration and move both pointers to point to next alphanumeric character till left < right...\\n            left++;\\n            right--;\\n        }\\n        // After loop finishes, the string is said to be palindrome, hence return true...\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        // Base Case...\\n        if(s.empty())  return true;\\n        // Initialize two pointer variables, left and right and point them with the two ends of the input string...\\n        int left = 0, right = s.length() - 1;\\n        // Traverse all elements through the loop...\\n        while(left < right) {\\n            // if both the characters are same...\\n            // Continue to next iteration and move both pointers to point to next alphanumeric character till left < right...\\n            if(tolower(s[left]) == tolower(s[right])) {\\n                left++;\\n                right--;\\n            }\\n            // Move the left pointer to right so it points to a alphanumeric character...\\n            else if(!isalpha(s[left]) && !isdigit(s[left])) {\\n                left++;\\n            }\\n            // Similarly move right pointer to left so it also points to a alphanumeric character...\\n            else if(!isalpha(s[right]) && !isdigit(s[right])) {\\n                right--;\\n            }\\n            // Otherwise return false...\\n            else{\\n                return false;\\n            }\\n        }\\n        // After loop finishes, the string is said to be palindrome, hence return true...\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n        # Initialize two pointer variables, left and right and point them with the two ends of the input string...\\n        left, right = 0, len(s) - 1\\n        # Traverse all elements through the loop...\\n        while left < right:\\n            # Move the left pointer to right so it points to a alphanumeric character...\\n            while left < right and not s[left].isalnum():\\n                left += 1\\n            # Similarly move right pointer to left so it also points to a alphanumeric character...\\n            while left < right and not s[right].isalnum():\\n                right -= 1\\n            # Check if both the characters are same...\\n            # If it is not equal then the string is not a valid palindrome, hence return false...\\n            if s[left].lower() != s[right].lower():\\n                return False\\n            # If same, then continue to next iteration and move both pointers to point to next alphanumeric character till left < right...\\n            left, right = left + 1, right - 1\\n        # After loop finishes, the string is said to be palindrome, hence return true...\\n        return True\\n```\n```\\nvar isPalindrome = function(s) {\\n    // Base case\\n    if(s==null)  return false;\\n    // Take in lowercase character...\\n    s = s.toLowerCase();\\n    // Initialize two pointer variables, left and right and point them with the two ends of the input string...\\n    let left = 0;\\n    let right = s.length - 1;\\n    // Traverse all elements through the loop...\\n    while(left < right){\\n        // Move the left pointer to right so it points to a alphanumeric character...\\n        while(left < right && !((s.charAt(left) >= \\'a\\' && s.charAt(left) <= \\'z\\') || (s.charAt(left) >= \\'0\\' && s.charAt(left) <= \\'9\\'))){\\n            left++;\\n        }\\n        // Similarly move right pointer to left so it also points to a alphanumeric character...\\n        while(left < right && !((s.charAt(right) >= \\'a\\' && s.charAt(right) <= \\'z\\') || (s.charAt(right) >= \\'0\\' && s.charAt(right) <= \\'9\\'))){\\n            right--;\\n        }\\n        // Check if both the characters are same...\\n        // If it is not equal then the string is not a valid palindrome, hence return false...\\n        if(s.charAt(left) != s.charAt(right)){\\n            return false;\\n        }\\n        // If same, then continue to next iteration and move both pointers to point to next alphanumeric character till left < right...\\n        left++;\\n        right--;\\n    }\\n    // After loop finishes, the string is said to be palindrome, hence return true...\\n    return true;\\n};\\n```\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # Initialize two pointer variables, left and right and point them with the two ends of the input string...\\n        left, right = 0, len(s) - 1\\n        # Traverse all elements through the loop...\\n        while left < right:\\n            # Move the left pointer to right so it points to a alphanumeric character...\\n            while left < right and not s[left].isalnum():\\n                left += 1\\n            # Similarly move right pointer to left so it also points to a alphanumeric character...\\n            while left < right and not s[right].isalnum():\\n                right -= 1\\n            # Check if both the characters are same...\\n            # If it is not equal then the string is not a valid palindrome, hence return false...\\n            if s[left].lower() != s[right].lower():\\n                return False\\n            # If same, then continue to next iteration and move both pointers to point to next alphanumeric character till left < right...\\n            left, right = left + 1, right - 1\\n        # After loop finishes, the string is said to be palindrome, hence return true...\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081229,
                "title": "java-simple-check-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        int left = 0;\\n        int right = s.length()-1;\\n        \\n        while (left < right){\\n            char c1 = s.charAt(left);\\n            char c2 = s.charAt(right);\\n            \\n            //if c1 is not valid then move forward\\n            if (!Character.isLetterOrDigit(c1)) left++;\\n            // if c2 is not valid move backward\\n            else if (!Character.isLetterOrDigit(c2)) right--;\\n            // otherwise compare\\n            else{\\n                if (Character.toLowerCase(c1) != Character.toLowerCase(c2)) return false;    \\n                left++;\\n                right--;    \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        int left = 0;\\n        int right = s.length()-1;\\n        \\n        while (left < right){\\n            char c1 = s.charAt(left);\\n            char c2 = s.charAt(right);\\n            \\n            //if c1 is not valid then move forward\\n            if (!Character.isLetterOrDigit(c1)) left++;\\n            // if c2 is not valid move backward\\n            else if (!Character.isLetterOrDigit(c2)) right--;\\n            // otherwise compare\\n            else{\\n                if (Character.toLowerCase(c1) != Character.toLowerCase(c2)) return false;    \\n                left++;\\n                right--;    \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40142,
                "title": "c-solution-9-lines-4ms-using-pointer",
                "content": "    bool isPalindrome(char* s) {\\n        int len = strlen(s);\\n        if(!len) return true;\\n        char *p1 = s, *p2 = s + len - 1;\\n        while(p1 < p2){\\n            if(!isalnum(*p1)){p1++;continue;}\\n            if(!isalnum(*p2)){p2--;continue;}\\n            if(tolower(*p1++) != tolower(*p2--)) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    bool isPalindrome(char* s) {\\n        int len = strlen(s);\\n        if(!len) return true;\\n        char *p1 = s, *p2 = s + len - 1;\\n        while(p1 < p2){\\n            if(!isalnum(*p1)){p1++;continue;}\\n            if(!isalnum(*p2)){p2--;continue;}\\n            if(tolower(*p1++) != tolower(*p2--)) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3864359,
                "title": "python-3-two-solutions-beats-99-33ms",
                "content": "```python3 []\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s = [c.lower() for c in s if c.isalnum()]\\n        return all (s[i] == s[~i] for i in range(len(s)//2))\\n```\\n```python3 []\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            while i < j and not s[i].isalnum(): i += 1\\n            while i < j and not s[j].isalnum(): j -= 1\\n\\n            if s[i].lower() != s[j].lower(): return False\\n            i += 1\\n            j -= 1\\n\\n        return True\\n```\\nOperator **~** is the bitwise NOT operator (`~x == -x-1` => `~0 == -1` => `~1 == -2` and etc). It performs [logical negation](https://en.wikipedia.org/wiki/Negation) on a given number by flipping all of its bits:\\n![not.gif](https://assets.leetcode.com/users/images/e85a01e6-8b18-419b-a5e6-d2d7ddba9ecd_1691563189.9074256.gif)\\n\\n![Screenshot 2023-08-04 at 22.24.01.png](https://assets.leetcode.com/users/images/f00cfabe-0d1e-41ff-b073-05cf874122b6_1691177105.102351.png)\\n\\n### Bonus: problems to practise using operator ~\\n[344. Reverse String](https://leetcode.com/problems/reverse-string/description/)\\n```python3 []\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s)//2):\\n            s[i], s[~i] = s[~i], s[i]\\n```\\n[1572. Matrix Diagonal Sum](https://leetcode.com/problems/matrix-diagonal-sum/description/)\\n~ using to traverse by matrix antidiagonal (the second diagonal)\\n```python3 []\\nclass Solution:\\n    def diagonalSum(self, mat: List[List[int]]) -> int:\\n        res = 0\\n        for i in range(len(mat)):\\n            res = res + mat[i][i] + mat[i][~i]\\n\\n        if (len(mat)) % 2:\\n            mid = len(mat)//2\\n            res -= mat[mid][mid]\\n        \\n        return res\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s = [c.lower() for c in s if c.isalnum()]\\n        return all (s[i] == s[~i] for i in range(len(s)//2))\\n```\n```python3 []\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            while i < j and not s[i].isalnum(): i += 1\\n            while i < j and not s[j].isalnum(): j -= 1\\n\\n            if s[i].lower() != s[j].lower(): return False\\n            i += 1\\n            j -= 1\\n\\n        return True\\n```\n```python3 []\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s)//2):\\n            s[i], s[~i] = s[~i], s[i]\\n```\n```python3 []\\nclass Solution:\\n    def diagonalSum(self, mat: List[List[int]]) -> int:\\n        res = 0\\n        for i in range(len(mat)):\\n            res = res + mat[i][i] + mat[i][~i]\\n\\n        if (len(mat)) % 2:\\n            mid = len(mat)//2\\n            res -= mat[mid][mid]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40095,
                "title": "any-other-easy-solution-beside-using-regex",
                "content": "    s=s.toLowerCase();\\n\\t\\ts=s.replaceAll(\"[^0-9a-zA-Z]\", \"\");\\n\\t\\tchar c[]=s.toCharArray();\\n\\t\\tint counthead=0,counttail=s.length()-1;\\n\\t\\twhile(counthead<=s.length()-1&&counttail>=0){\\n\\t\\t\\tif(c[counthead]!=c[counttail]) return false;\\n\\t\\t\\tcounthead++;\\n\\t\\t\\tcounttail--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\nI have tried normal way but it is complex to judge if a char is not alphanumeric",
                "solutionTags": [],
                "code": "    s=s.toLowerCase();\\n\\t\\ts=s.replaceAll(\"[^0-9a-zA-Z]\", \"\");\\n\\t\\tchar c[]=s.toCharArray();\\n\\t\\tint counthead=0,counttail=s.length()-1;\\n\\t\\twhile(counthead<=s.length()-1&&counttail>=0){\\n\\t\\t\\tif(c[counthead]!=c[counttail]) return false;\\n\\t\\t\\tcounthead++;\\n\\t\\t\\tcounttail--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\nI have tried normal way but it is complex to judge if a char is not alphanumeric",
                "codeTag": "Unknown"
            },
            {
                "id": 1975477,
                "title": "go-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Valid Palindrome.\\nMemory Usage: 2.8 MB, less than 71.27% of Go online submissions for Valid Palindrome.\\n\\n```\\nfunc isPalindrome(s string) bool {\\n    f := func(r rune) rune {\\n        if !unicode.IsLetter(r) && !unicode.IsNumber(r) {\\n            return -1\\n        }\\n        \\n        return unicode.ToLower(r)\\n    }\\n    s = strings.Map(f, s)\\n    \\n    i, j := 0, len(s)-1\\n    \\n    for i < j {\\n        if s[i] != s[j] {\\n            return false\\n        }\\n        \\n        i = i+1\\n        j = j-1\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPalindrome(s string) bool {\\n    f := func(r rune) rune {\\n        if !unicode.IsLetter(r) && !unicode.IsNumber(r) {\\n            return -1\\n        }\\n        \\n        return unicode.ToLower(r)\\n    }\\n    s = strings.Map(f, s)\\n    \\n    i, j := 0, len(s)-1\\n    \\n    for i < j {\\n        if s[i] != s[j] {\\n            return false\\n        }\\n        \\n        i = i+1\\n        j = j-1\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40385,
                "title": "neat-o-n-o-1-solution-with-isalnum",
                "content": "    class Solution {\\n    public:\\n    \\tbool isPalindrome(string s) {\\n    \\n    \\t\\tint i = 0, j = s.size() - 1;\\n    \\t\\twhile(i < j)\\n    \\t\\t{\\n    \\t\\t\\twhile(i < j && !isalnum(s[i])) i++;\\n    \\t\\t\\twhile(i < j && !isalnum(s[j])) j--;\\n    \\t\\t\\tif (toupper(s[i])!=toupper(s[j]))\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\ti++;j--;\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tbool isPalindrome(string s) {\\n    \\n    \\t\\tint i = 0, j = s.size() - 1;\\n    \\t\\twhile(i < j)\\n    \\t\\t{\\n    \\t\\t\\twhile(i < j && !isalnum(s[i])) i++;\\n    \\t\\t\\twhile(i < j && !isalnum(s[j])) j--;\\n    \\t\\t\\tif (toupper(s[i])!=toupper(s[j]))\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\ti++;j--;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3117119,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int start=0, end=s.length()-1;\\n\\t    while(start<end) {\\n\\t\\tif (!isalnum(s[start])) start++;\\n\\t\\telse if (!isalnum(s[end])) end--;\\n\\t\\telse {\\n\\t\\t\\tif (tolower(s[start++])!=tolower(s[end--]))\\n                return false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int start=0, end=s.length()-1;\\n\\t    while(start<end) {\\n\\t\\tif (!isalnum(s[start])) start++;\\n\\t\\telse if (!isalnum(s[end])) end--;\\n\\t\\telse {\\n\\t\\t\\tif (tolower(s[start++])!=tolower(s[end--]))\\n                return false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396796,
                "title": "python-98-time",
                "content": "```\\n\\'\\'\\'\\nhttps://leetcode.com/problems/valid-palindrome/submissions/\\nRuntime: 40 ms, faster than 98.66% of Python3 online submissions for Valid Palindrome.\\nMemory Usage: 15.2 MB, less than 9.52% of Python3 online submissions for Valid Palindrome.\\n\\'\\'\\'\\nimport re\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s = re.sub(\"[^a-z0-9]\",\\'\\',s.lower())\\n        return s == \\'\\'.join(reversed(s))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\'\\'\\'\\nhttps://leetcode.com/problems/valid-palindrome/submissions/\\nRuntime: 40 ms, faster than 98.66% of Python3 online submissions for Valid Palindrome.\\nMemory Usage: 15.2 MB, less than 9.52% of Python3 online submissions for Valid Palindrome.\\n\\'\\'\\'\\nimport re\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s = re.sub(\"[^a-z0-9]\",\\'\\',s.lower())\\n        return s == \\'\\'.join(reversed(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524673,
                "title": "c-java-python-javascript-simple-code-easy-to-understand",
                "content": "# Intuition:\\nThe idea behind this solution is to use two pointers, one starting from the left end of the string (`left`) and the other starting from the right end of the string (`right`). We iterate through the string until the two pointers meet in the middle.\\n\\n# Approach:\\n1. Initialize the `left` pointer to 0 (indicating the start of the string) and the `right` pointer to `s.length()-1` (indicating the end of the string).\\n2. Iterate while `left < right`:\\n   - If `s[left]` is not an alphanumeric character, increment `left` by 1 and move to the next character.\\n   - If `s[right]` is not an alphanumeric character, decrement `right` by 1 and move to the previous character.\\n   - If the lowercase of `s[left]` is not equal to the lowercase of `s[right]`, the string is not a palindrome. Return `false`.\\n   - If the characters are equal, increment `left` by 1 and decrement `right` by 1 to continue checking the next pair of characters.\\n3. If the loop completes without returning `false`, it means the string is a palindrome. Return `true`.\\n\\n# Complexity:\\n- The time complexity of this solution is O(n), where n is the length of the input string `s`. We iterate through the string once.\\n- The space complexity is O(1) because we are using a constant amount of extra space for the pointers and temporary variables.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n        int left = 0, right = s.length()-1;\\n        while(left<right)\\n        {   \\n            if(!isalnum(s[left])) \\n                left++;\\n            else if(!isalnum(s[right])) \\n                right--;\\n            else if(tolower(s[left])!=tolower(s[right])) \\n                return false;\\n            else {\\n                left++; \\n                right--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while (left < right) {\\n            if (!Character.isLetterOrDigit(s.charAt(left)))\\n                left++;\\n            else if (!Character.isLetterOrDigit(s.charAt(right)))\\n                right--;\\n            else if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)))\\n                return false;\\n            else {\\n                left++;\\n                right--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            if not s[left].isalnum():\\n                left += 1\\n            elif not s[right].isalnum():\\n                right -= 1\\n            elif s[left].lower() != s[right].lower():\\n                return False\\n            else:\\n                left += 1\\n                right -= 1\\n        return True\\n\\n```\\n---\\n# JavaScript\\n```\\nvar isPalindrome = function(s){\\n    let left = 0, right = s.length - 1;\\n    while (left < right) {\\n        if (!isAlphaNumeric(s[left]))\\n            left++;\\n        else if (!isAlphaNumeric(s[right]))\\n            right--;\\n        else if (s[left].toLowerCase() !== s[right].toLowerCase())\\n            return false;\\n        else {\\n            left++;\\n            right--;\\n        }\\n    }\\n    return true;\\n}\\n\\nfunction isAlphaNumeric(char) {\\n    const code = char.charCodeAt(0);\\n    return (code >= 48 && code <= 57) || (code >= 65 && code <= 90) || (code >= 97 && code <= 122);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n        int left = 0, right = s.length()-1;\\n        while(left<right)\\n        {   \\n            if(!isalnum(s[left])) \\n                left++;\\n            else if(!isalnum(s[right])) \\n                right--;\\n            else if(tolower(s[left])!=tolower(s[right])) \\n                return false;\\n            else {\\n                left++; \\n                right--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while (left < right) {\\n            if (!Character.isLetterOrDigit(s.charAt(left)))\\n                left++;\\n            else if (!Character.isLetterOrDigit(s.charAt(right)))\\n                right--;\\n            else if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)))\\n                return false;\\n            else {\\n                left++;\\n                right--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            if not s[left].isalnum():\\n                left += 1\\n            elif not s[right].isalnum():\\n                right -= 1\\n            elif s[left].lower() != s[right].lower():\\n                return False\\n            else:\\n                left += 1\\n                right -= 1\\n        return True\\n\\n```\n```\\nvar isPalindrome = function(s){\\n    let left = 0, right = s.length - 1;\\n    while (left < right) {\\n        if (!isAlphaNumeric(s[left]))\\n            left++;\\n        else if (!isAlphaNumeric(s[right]))\\n            right--;\\n        else if (s[left].toLowerCase() !== s[right].toLowerCase())\\n            return false;\\n        else {\\n            left++;\\n            right--;\\n        }\\n    }\\n    return true;\\n}\\n\\nfunction isAlphaNumeric(char) {\\n    const code = char.charCodeAt(0);\\n    return (code >= 48 && code <= 57) || (code >= 65 && code <= 90) || (code >= 97 && code <= 122);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526271,
                "title": "rust-iterator-solution",
                "content": "```\\nimpl Solution {\\n    pub fn is_palindrome(s: String) -> bool {\\n        let mut iter = s\\n            .chars()\\n            .filter(|c| c.is_alphanumeric())\\n            .map(|c| c.to_ascii_lowercase());\\n\\n        iter.clone().eq(iter.rev())\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_palindrome(s: String) -> bool {\\n        let mut iter = s\\n            .chars()\\n            .filter(|c| c.is_alphanumeric())\\n            .map(|c| c.to_ascii_lowercase());\\n\\n        iter.clone().eq(iter.rev())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3129826,
                "title": "java-simplest-approach",
                "content": "\\n\\n# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The time complexity of this code is  O(n)   , where n is the length of the input string. This is because the code loops through the input string once to create the ans string, and then loops through the ans string once to create the ans2 string.\\n\\n \\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The space complexity of this code is also O(n), where n is the length of the input string. This is because the code creates two new strings, ans and ans2, both of which can be up to the length of the input string.\\n\\n\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/71427381-8c26-4a94-ac6c-b7ab92b87c4b_1675946617.617776.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n\\n        String ans = \"\";\\n\\n        for(int i =0; i < s.length();i++){\\n\\n            //Check if charAt(i) is between \\'A\\' to \\'Z\\' then convert it to lower case and add it to ans\\n\\n            if(s.charAt(i) >= \\'A\\' && s.charAt(i) <= \\'Z\\'){\\n                ans += Character.toLowerCase(s.charAt(i));\\n            }\\n\\n            //Check if charAt(i) is between \\'a\\' to \\'z\\' then add it to ans\\n\\n            else if(s.charAt(i) >= \\'a\\' && s.charAt(i) <= \\'z\\'){\\n                ans += s.charAt(i);\\n            }\\n\\n             //Check if charAt(i) is between \\'1\\' to \\'9\\' then add it to ans\\n\\n            else if(s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\'){\\n                ans += s.charAt(i);\\n            }\\n        }\\n\\n        //Now Reverse the ans string \\n\\n        String ans2 = \"\";\\n\\n        for(int i = 0; i < ans.length();i++){\\n\\n            ans2 = ans.charAt(i) + ans2;\\n        }\\n\\n        //after reversing check if ans is equal to ans2 then it is a palindrome string\\n\\n        if(ans.equals(ans2)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n\\n        String ans = \"\";\\n\\n        for(int i =0; i < s.length();i++){\\n\\n            //Check if charAt(i) is between \\'A\\' to \\'Z\\' then convert it to lower case and add it to ans\\n\\n            if(s.charAt(i) >= \\'A\\' && s.charAt(i) <= \\'Z\\'){\\n                ans += Character.toLowerCase(s.charAt(i));\\n            }\\n\\n            //Check if charAt(i) is between \\'a\\' to \\'z\\' then add it to ans\\n\\n            else if(s.charAt(i) >= \\'a\\' && s.charAt(i) <= \\'z\\'){\\n                ans += s.charAt(i);\\n            }\\n\\n             //Check if charAt(i) is between \\'1\\' to \\'9\\' then add it to ans\\n\\n            else if(s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\'){\\n                ans += s.charAt(i);\\n            }\\n        }\\n\\n        //Now Reverse the ans string \\n\\n        String ans2 = \"\";\\n\\n        for(int i = 0; i < ans.length();i++){\\n\\n            ans2 = ans.charAt(i) + ans2;\\n        }\\n\\n        //after reversing check if ans is equal to ans2 then it is a palindrome string\\n\\n        if(ans.equals(ans2)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935338,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the *s*.\\n    //   - space: O(1), only constant space is used.\\n\\n    func isPalindrome(_ s: String) -> Bool {\\n        guard !s.isEmpty else { return true }\\n\\n        let s = Array(s)\\n        var i = 0\\n        var j = s.count - 1\\n\\n        while i < j {\\n            if !s[i].isLetter, !s[i].isNumber { i += 1; continue }\\n\\n            if !s[j].isLetter, !s[j].isNumber { j -= 1; continue }\\n\\n            guard s[i].lowercased() == s[j].lowercased() else { return false }\\n            i += 1\\n            j -= 1\\n        }\\n\\n        return true\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the *s*.\\n    //   - space: O(1), only constant space is used.\\n\\n    func isPalindrome(_ s: String) -> Bool {\\n        guard !s.isEmpty else { return true }\\n\\n        let s = Array(s)\\n        var i = 0\\n        var j = s.count - 1\\n\\n        while i < j {\\n            if !s[i].isLetter, !s[i].isNumber { i += 1; continue }\\n\\n            if !s[j].isLetter, !s[j].isNumber { j -= 1; continue }\\n\\n            guard s[i].lowercased() == s[j].lowercased() else { return false }\\n            i += 1\\n            j -= 1\\n        }\\n\\n        return true\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40215,
                "title": "two-lines-in-java",
                "content": "    s=s.toLowerCase().replaceAll(\"[^a-z0-9]\", \"\");\\n    return new StringBuilder(s).reverse().toString().equals(s);",
                "solutionTags": [],
                "code": "    s=s.toLowerCase().replaceAll(\"[^a-z0-9]\", \"\");\\n    return new StringBuilder(s).reverse().toString().equals(s);",
                "codeTag": "Unknown"
            },
            {
                "id": 40003,
                "title": "simple-79-ms-python-solution",
                "content": "    class Solution:\\n        # @param s, a string\\n        # @return a boolean\\n        def isPalindrome(self, s):\\n            s = \"\".join([c.lower() for c in s if c.isalnum()])\\n            return s == s[::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param s, a string\\n        # @return a boolean\\n        def isPalindrome(self, s):\\n            s = \"\".join([c.lower() for c in s if c.isalnum()])\\n            return s == s[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 1571681,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        l=\"\"\\n        for i in s:\\n            if i.isalpha():\\n                l=l+i.lower()\\n                \\n            if i.isnumeric():\\n                l=l+i\\n        #print(l)\\n        if(l==l[::-1]):\\n            return(True)\\n        \\n        return(False)\\n```\\nIf u understood the code...then plz UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        l=\"\"\\n        for i in s:\\n            if i.isalpha():\\n                l=l+i.lower()\\n                \\n            if i.isnumeric():\\n                l=l+i\\n        #print(l)\\n        if(l==l[::-1]):\\n            return(True)\\n        \\n        return(False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443979,
                "title": "javascript-solutions-using-two-pointers-and-reverse-method-with-explanations",
                "content": "\\nI\\'ve included below multiple solutions: \"naive\" strategy of cleaning the string and then using a reverse method from a standard lib and two slightly different solutions which employ the two pointers technique.\\n\\nPlease comment with any feedback and/or corrections.  Thank you for reading my work! :)\\n\\n### Solutions\\n\\n<details>\\n <summary>Using a reverse method (naive)</summary>\\n\\n#### Plain English Explanation\\n\\nThe solution below is straightforward and concise, however, the purpose of this\\nexercise is to gain experience with applying a particular technique, explained\\nfurther in the second solution and as such, it is probably in your best interest\\nto focus on that one when preparing for interviews.\\n\\nBoth solutions utilize a regular expression to assist with our task,\\nspecifically to validate if a character is or is not an alphanumeric character,\\nmeaning anything besides `!@#$%^&*()-<>:\"?` for example. We can replace invalid\\ncharacters with an empty string or perform a test on each char and skip it\\n(increment `left` or decrement `right`).\\n\\nAfter cleaning the string, we split it into individual characters which\\ndepending on language, typically returns an array. Next, we call a `reverse`\\nmethod on the character array and join the result into a string.\\n\\nThe last step is to return an expression which:\\n\\n1. calls a `toLowerCase` method on the cleaned string and reversedAndCleaned\\n   string\\n2. check for equality\\n\\n#### Code\\n\\n```javascript\\n/**\\n *\\n * @param {string} s\\n * @return {boolean}\\n *\\n * Runtime: 68ms\\n * Memory: 38.6 MB\\n *\\n */\\nvar isPalindrome = function(s) {\\n  var cleaned = s.replace(/\\\\W/g, \"\");\\n  var reversedAndCleaned = cleaned\\n    .split(\"\")\\n    .reverse()\\n    .join(\"\");\\n\\n  return cleaned.toLowerCase() == reversedAndCleaned.toLowerCase();\\n};\\n```\\n\\n#### Complexity Analysis\\n\\n| Resource | Complexity |\\n| :------- | :--------- |\\n| Time     | $O(n)$     |\\n| Space    | $O(n)$     |\\n\\n</details>\\n\\n<details>\\n <summary>Two Pointers</summary>\\n\\n#### Plain English Explanation\\n\\nAs mentioned in the first solution, we perform some similar steps in this\\nsolution to get a cleaned string and we will not repeat those steps in this\\ncommentary.\\n\\nRather than reversing the entire character array followed by comparing\\nindividual characters, we can apply the two pointers technique by checking for\\ninequality of each character.\\n\\nSince the directions state that an empty string is `true`, we include a check\\nfor that. Next, we create `cleaned` by converting each char in `s` into an array\\nof lowercase characters and replacing all NON alphanumeric characters with an\\nempty string. The regular expression `/\\\\W/gm` is like saying \"match any NON-word\\ncharacter\".\\n\\nWe loop while the condition `i < j` holds true (our pointers converge towards\\nthe center but we do not want them to pass each other) and check if the\\n$cleaned^i$ value is not equal to the $cleaned^j$ value, indicating an INVALID\\npalindrome.\\n\\nIf the above check is not true, we increment `i` and decrement `j`, both by 1 to\\nprocess the next two chars. If we exhaust the loop we can safely return true as\\nthis is a valid palindrome.\\n\\n#### Code\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @return {boolean}\\n *\\n * Runtime: 68ms\\n * Memory: 38.6 MB\\n */\\nvar isPalindrome = function(s) {\\n  if (s.length == 0) {\\n    return true;\\n  }\\n\\n  const regex = /\\\\W/gm;\\n  const cleaned = [...s.toLowerCase().replace(regex, \"\")];\\n\\n  let i = 0;\\n  let j = cleaned.length - 1;\\n\\n  while (i < j) {\\n    if (cleaned[i] != cleaned[j]) {\\n      return false;\\n    }\\n\\n    i++;\\n    j--;\\n  }\\n\\n  return true;\\n};\\n```\\n\\n### Alternative Solution Using two pointers\\n\\nThe solution below is a bit more verbose however I believe reading multiple\\nsolutions to the same problem is beneficial to the learner.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n  // if s.length == 0 return true\\n  if (s.length == 0) {\\n    return true;\\n  }\\n\\n  let left = 0;\\n  let right = s.length - 1;\\n\\n  while (left < right) {\\n    // First, ensure chars at left and right pointers are both \"valid\"\\n    // meaning they are alphanumeric\\n    if (isLetterOrDigit(s[left]) == false) {\\n      left++;\\n      continue;\\n    }\\n\\n    if (isLetterOrDigit(s[right]) == false) {\\n      right--;\\n      continue;\\n    }\\n\\n    // Once we have valid chars, we must compare them for equality.\\n    // if they are not equal, return false\\n    if (s[left].toLowerCase() !== s[right].toLowerCase()) {\\n      return false;\\n    }\\n\\n    // continue manipulating pointers inward\\n    left++;\\n    right--;\\n  }\\n\\n  // if the program reaches this point we can safely return true\\n  return true;\\n};\\n\\n/**\\n * Java-esque function which returns a boolean indicating if\\n * a given char is either a letter or a digit.\\n */\\nconst isLetterOrDigit = function(ch) {\\n  // ^[a-zA-Z0-9_]\\n  // NOT letters or digits\\n  const regexp = /\\\\W/;\\n\\n  return !regexp.test(ch);\\n};\\n```\\n\\n#### Complexity Analysis\\n\\n| Resource | Complexity |\\n| :------- | :--------- |\\n| Time     | $O(n)$     |\\n| Space    | $O(n)$     |\\n\\n</details>\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```javascript\\n/**\\n *\\n * @param {string} s\\n * @return {boolean}\\n *\\n * Runtime: 68ms\\n * Memory: 38.6 MB\\n *\\n */\\nvar isPalindrome = function(s) {\\n  var cleaned = s.replace(/\\\\W/g, \"\");\\n  var reversedAndCleaned = cleaned\\n    .split(\"\")\\n    .reverse()\\n    .join(\"\");\\n\\n  return cleaned.toLowerCase() == reversedAndCleaned.toLowerCase();\\n};\\n```\n```javascript\\n/**\\n * @param {string} s\\n * @return {boolean}\\n *\\n * Runtime: 68ms\\n * Memory: 38.6 MB\\n */\\nvar isPalindrome = function(s) {\\n  if (s.length == 0) {\\n    return true;\\n  }\\n\\n  const regex = /\\\\W/gm;\\n  const cleaned = [...s.toLowerCase().replace(regex, \"\")];\\n\\n  let i = 0;\\n  let j = cleaned.length - 1;\\n\\n  while (i < j) {\\n    if (cleaned[i] != cleaned[j]) {\\n      return false;\\n    }\\n\\n    i++;\\n    j--;\\n  }\\n\\n  return true;\\n};\\n```\n```javascript\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n  // if s.length == 0 return true\\n  if (s.length == 0) {\\n    return true;\\n  }\\n\\n  let left = 0;\\n  let right = s.length - 1;\\n\\n  while (left < right) {\\n    // First, ensure chars at left and right pointers are both \"valid\"\\n    // meaning they are alphanumeric\\n    if (isLetterOrDigit(s[left]) == false) {\\n      left++;\\n      continue;\\n    }\\n\\n    if (isLetterOrDigit(s[right]) == false) {\\n      right--;\\n      continue;\\n    }\\n\\n    // Once we have valid chars, we must compare them for equality.\\n    // if they are not equal, return false\\n    if (s[left].toLowerCase() !== s[right].toLowerCase()) {\\n      return false;\\n    }\\n\\n    // continue manipulating pointers inward\\n    left++;\\n    right--;\\n  }\\n\\n  // if the program reaches this point we can safely return true\\n  return true;\\n};\\n\\n/**\\n * Java-esque function which returns a boolean indicating if\\n * a given char is either a letter or a digit.\\n */\\nconst isLetterOrDigit = function(ch) {\\n  // ^[a-zA-Z0-9_]\\n  // NOT letters or digits\\n  const regexp = /\\\\W/;\\n\\n  return !regexp.test(ch);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501287,
                "title": "best-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\\n        int j = str.length() -1;\\n\\n        for (int i = 0; i < str.length() -1 ; i++) {\\n            if (str.charAt(i) != str.charAt(j)){\\n                    return false;\\n            }\\n            j--;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\\n        int j = str.length() -1;\\n\\n        for (int i = 0; i < str.length() -1 ; i++) {\\n            if (str.charAt(i) != str.charAt(j)){\\n                    return false;\\n            }\\n            j--;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263712,
                "title": "easiest-java-solution-ever-exsisted-is-here",
                "content": "# Intuition\\nMORE EASY SOLUTION CANNOT EXISTS \\nHERE I am presenting JAVA CODE C++ will have almost similar code\\n\\n\\n# Approach\\nJust smile and solve and have fun\\n\\n# Complexity\\n- Time complexity :) just O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.StringTokenizer;\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        String s2=\"\";\\n        StringTokenizer st=new StringTokenizer(s, \" ?./*_`-+[\\'$]=&():$#@!^}{;,\\\\\"|\\\\\\\\\");\\n        while(st.hasMoreTokens())\\n        {\\n            s2+=\"\"+st.nextToken();\\n        }\\n        s2=s2.trim();\\n        s2=s2.toLowerCase();\\n        StringBuffer sb=new StringBuffer(s2);\\n        if(s2.equals(\"\"+sb.reverse()))\\n        return true;\\n        return false;\\n        \\n    }\\n}//IF YOU LIKED PLEASE UPVOTE \\n//THANK YOU FOR SEEING IT.\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nimport java.util.StringTokenizer;\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        String s2=\"\";\\n        StringTokenizer st=new StringTokenizer(s, \" ?./*_`-+[\\'$]=&():$#@!^}{;,\\\\\"|\\\\\\\\\");\\n        while(st.hasMoreTokens())\\n        {\\n            s2+=\"\"+st.nextToken();\\n        }\\n        s2=s2.trim();\\n        s2=s2.toLowerCase();\\n        StringBuffer sb=new StringBuffer(s2);\\n        if(s2.equals(\"\"+sb.reverse()))\\n        return true;\\n        return false;\\n        \\n    }\\n}//IF YOU LIKED PLEASE UPVOTE \\n//THANK YOU FOR SEEING IT.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691805,
                "title": "using-two-pointer-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = size(s);\\n        \\n        if(n == 1) return true; // if string size 1 then simple return true if symbol is present no need worry about we don\\'t need remove question ask return \\n        //true or false\\n        \\n        string str = \"\";\\n        for(int i=0; i<n; i++) if(isalnum(s[i])) str +=s[i]; // only put number and char not any symbol\\n        \\n        // converting whole string into uppercase\\n        transform(str.begin(), str.end(), str.begin(), ::toupper);\\n        \\n        int i=0,j=size(str)-1;\\n        \\n        while(i<j) {\\n            if(str[i] != str[j]) return false; // checking where two char are not same then return false\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = size(s);\\n        \\n        if(n == 1) return true; // if string size 1 then simple return true if symbol is present no need worry about we don\\'t need remove question ask return \\n        //true or false\\n        \\n        string str = \"\";\\n        for(int i=0; i<n; i++) if(isalnum(s[i])) str +=s[i]; // only put number and char not any symbol\\n        \\n        // converting whole string into uppercase\\n        transform(str.begin(), str.end(), str.begin(), ::toupper);\\n        \\n        int i=0,j=size(str)-1;\\n        \\n        while(i<j) {\\n            if(str[i] != str[j]) return false; // checking where two char are not same then return false\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264513,
                "title": "kotlin-1-line",
                "content": "```\\nfun isPalindrome(s: String) = s.filter { it.isLetterOrDigit() }.run { equals(reversed(), true) }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun isPalindrome(s: String) = s.filter { it.isLetterOrDigit() }.run { equals(reversed(), true) }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 521420,
                "title": "go",
                "content": "```\\nfunc isPalindrome(s string) bool {\\n    i, j := 0, len(s)-1\\n    for i < j {\\n        if !isValid(s[i]) {\\n            i++\\n            continue\\n        }\\n        if !isValid(s[j]) {\\n            j--\\n            continue\\n        }\\n        if !strings.EqualFold(string(s[i]), string(s[j])) {\\n            return false\\n        }\\n        i++\\n        j--\\n    }\\n    return true\\n}\\n\\nfunc isValid(a byte) bool {\\n    if (a >= \\'a\\' && a <= \\'z\\') || (a >= \\'A\\' && a <= \\'Z\\') || (a >= \\'0\\' && a <= \\'9\\') {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isPalindrome(s string) bool {\\n    i, j := 0, len(s)-1\\n    for i < j {\\n        if !isValid(s[i]) {\\n            i++\\n            continue\\n        }\\n        if !isValid(s[j]) {\\n            j--\\n            continue\\n        }\\n        if !strings.EqualFold(string(s[i]), string(s[j])) {\\n            return false\\n        }\\n        i++\\n        j--\\n    }\\n    return true\\n}\\n\\nfunc isValid(a byte) bool {\\n    if (a >= \\'a\\' && a <= \\'z\\') || (a >= \\'A\\' && a <= \\'Z\\') || (a >= \\'0\\' && a <= \\'9\\') {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442728,
                "title": "simple-swift-solution",
                "content": "``` swift\\nfunc isPalindrome(_ s: String) -> Bool {\\n    let A = Array(s)\\n    var i = 0, j = A.count - 1\\n    while i < j {\\n        if !A[i].isLetter && !A[i].isNumber {\\n            i += 1\\n        } else if !A[j].isLetter && !A[j].isNumber {\\n            j -= 1\\n        } else if String(A[i]).lowercased() == String(A[j]).lowercased() {\\n            i += 1; j -= 1;\\n        } else {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "``` swift\\nfunc isPalindrome(_ s: String) -> Bool {\\n    let A = Array(s)\\n    var i = 0, j = A.count - 1\\n    while i < j {\\n        if !A[i].isLetter && !A[i].isNumber {\\n            i += 1\\n        } else if !A[j].isLetter && !A[j].isNumber {\\n            j -= 1\\n        } else if String(A[i]).lowercased() == String(A[j]).lowercased() {\\n            i += 1; j -= 1;\\n        } else {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287186,
                "title": "c-while",
                "content": "```\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        var n = s.Length;\\n        var left = 0;\\n        var right = n - 1;\\n\\n        while (left < right) {\\n            if (!char.IsLetterOrDigit(s[left])) {\\n                left++;\\n            } else if (!char.IsLetterOrDigit(s[right])) {\\n                right--;\\n            } else {\\n                if (char.ToLower(s[left]) != char.ToLower(s[right])) {\\n                    return false;\\n                }\\n                left++;\\n                right--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        var n = s.Length;\\n        var left = 0;\\n        var right = n - 1;\\n\\n        while (left < right) {\\n            if (!char.IsLetterOrDigit(s[left])) {\\n                left++;\\n            } else if (!char.IsLetterOrDigit(s[right])) {\\n                right--;\\n            } else {\\n                if (char.ToLower(s[left]) != char.ToLower(s[right])) {\\n                    return false;\\n                }\\n                left++;\\n                right--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40284,
                "title": "javascript-solution-if-anyone-is-interested",
                "content": "\\n    var isPalindrome = function(s) {\\n        var strippedString = s.replace(/\\\\W/g, '');\\n        var reversedString = strippedString.split('').reverse().join('');\\n        \\n        return strippedString.toLowerCase() == reversedString.toLowerCase();\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n    var isPalindrome = function(s) {\\n        var strippedString = s.replace(/\\\\W/g, '');\\n        var reversedString = strippedString.split('').reverse().join('');\\n        \\n        return strippedString.toLowerCase() == reversedString.toLowerCase();\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 40298,
                "title": "a-python-solution-in-two-lines",
                "content": "This is a pythonic solution, and indeed, it's a cheat\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a boolean\\n        def isPalindrome(self, s):\\n            s = filter(str.isalnum, s.lower())\\n            return s == s[::-1]",
                "solutionTags": [],
                "code": "This is a pythonic solution, and indeed, it's a cheat\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a boolean\\n        def isPalindrome(self, s):\\n            s = filter(str.isalnum, s.lower())\\n            return s == s[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 3800813,
                "title": "two-pointer-c-clean-code",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int start = 0;\\n        int end = s.size()-1;\\n        while(start<=end){\\n            if(!isalnum(s[start])){\\n                start++;\\n                continue;\\n            }if(!isalnum(s[end])){\\n                end--;\\n                continue;\\n            }if(tolower(s[start]) != tolower(s[end])){\\n                return false;\\n            }else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int start = 0;\\n        int end = s.size()-1;\\n        while(start<=end){\\n            if(!isalnum(s[start])){\\n                start++;\\n                continue;\\n            }if(!isalnum(s[end])){\\n                end--;\\n                continue;\\n            }if(tolower(s[start]) != tolower(s[end])){\\n                return false;\\n            }else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342603,
                "title": "trippy-s-version-is-here-short-easy-self-explanatory",
                "content": "# Intuition\\nMORE EASY SOLUTION CANNOT EXISTS \\n\\n\\n# Approach\\nJust smile and solve and have fun\\n\\n# Complexity\\n- Time complexity :) just O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.StringTokenizer;\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        String s2=\"\";\\n        StringTokenizer st=new StringTokenizer(s, \" ?./*_`-+[\\'$]=&():$#@!^}{;,\\\\\"|\\\\\\\\\");\\n        while(st.hasMoreTokens())\\n        {\\n            s2+=\"\"+st.nextToken();\\n        }\\n        s2=s2.trim();\\n        s2=s2.toLowerCase();\\n        StringBuffer sb=new StringBuffer(s2);\\n        if(s2.equals(\"\"+sb.reverse()))\\n        return true;\\n        return false;\\n        \\n    }\\n}//IF YOU LIKED PLEASE UPVOTE \\n//THANK YOU FOR SEEING IT.\\n//LOVE FOR YOU \\u2764\\uFE0F\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nimport java.util.StringTokenizer;\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        String s2=\"\";\\n        StringTokenizer st=new StringTokenizer(s, \" ?./*_`-+[\\'$]=&():$#@!^}{;,\\\\\"|\\\\\\\\\");\\n        while(st.hasMoreTokens())\\n        {\\n            s2+=\"\"+st.nextToken();\\n        }\\n        s2=s2.trim();\\n        s2=s2.toLowerCase();\\n        StringBuffer sb=new StringBuffer(s2);\\n        if(s2.equals(\"\"+sb.reverse()))\\n        return true;\\n        return false;\\n        \\n    }\\n}//IF YOU LIKED PLEASE UPVOTE \\n//THANK YOU FOR SEEING IT.\\n//LOVE FOR YOU \\u2764\\uFE0F\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024037,
                "title": "python-regex-explained-beats-99",
                "content": "### Upvote if it helps!\\n\\n# The REGEX:\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s explain the REGEX expression:\\n- ```re.sub(pattern, replaceString)```: *all matching occurrences of the specified pattern are replaced by the replace string (here the empty string because we want to remove).*\\n\\n- Let\\'s explain the **pattern**:\\n    - ``` [^ ] ```: *Matches a single character not present in the list below.*\\n    - ```a-zA-Z```: *Matches all the upper case **and** lower case letters.*\\n    - ```0-9```: *Matches the numbers.*\\n    - ```\\\\s+```: *Matches a string of non-whitespace characters*. \\n        - *Do not forget to add a leading ```\\\\```, the first one *\"ask\"* Python not to interpret the next one.*\\n\\n- Finally, the pattern matches all non-alphanumeric characters and ```re.sub()``` allows us to remove all the occurences from the string.\\n- ```new_s[::-1]``` is used to reverse the string.\\n\\n\\n# Code:\\n```\\nimport re\\n\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n        new_s = re.sub(r\"[^a-zA-Z0-9\\\\\\\\s+]\", \"\", s).lower()\\n        return new_s == new_s[::-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```re.sub(pattern, replaceString)```\n``` [^ ] ```\n```a-zA-Z```\n```0-9```\n```\\\\s+```\n```\\\\```\n```re.sub()```\n```new_s[::-1]```\n```\\nimport re\\n\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n        new_s = re.sub(r\"[^a-zA-Z0-9\\\\\\\\s+]\", \"\", s).lower()\\n        return new_s == new_s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721777,
                "title": "c-easy-approach-optimised-palindrome",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int left = 0, right = s.size()-1;\\n        \\n        while(left < right) {\\n            if(ispunct(s[left]) || s[left] == \\' \\'){ // Checking left element is having any symbols, if yes increment left.\\n                left++;\\n                continue;\\n            } \\n            else if(ispunct(s[right]) || s[right] == \\' \\'){ // Checking right element is having any symbols, if yes decrement right.\\n                right--;\\n                continue;\\n            }\\n            else if(tolower(s[left]) != tolower(s[right])){ \\n                // If left char element is not equal to right char element return false. \\n                // Because it is not a palindrome.\\n                \\n                return false;\\n            }\\n            else { \\n                // If if(ispunct(s[left])) and else-if(ispunct(s[right])) check failed, then the current left and right are not symbols. \\n                // If (tolower(s[left]) != tolower(s[right])) also failed, the current left and right char are same.\\n                // So, we are still in a palindrome assumption. Just increment left and decrement right.\\n                \\n                left++;\\n                right--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nPlease **UpVote**, if you understood the problem.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int left = 0, right = s.size()-1;\\n        \\n        while(left < right) {\\n            if(ispunct(s[left]) || s[left] == \\' \\'){ // Checking left element is having any symbols, if yes increment left.\\n                left++;\\n                continue;\\n            } \\n            else if(ispunct(s[right]) || s[right] == \\' \\'){ // Checking right element is having any symbols, if yes decrement right.\\n                right--;\\n                continue;\\n            }\\n            else if(tolower(s[left]) != tolower(s[right])){ \\n                // If left char element is not equal to right char element return false. \\n                // Because it is not a palindrome.\\n                \\n                return false;\\n            }\\n            else { \\n                // If if(ispunct(s[left])) and else-if(ispunct(s[right])) check failed, then the current left and right are not symbols. \\n                // If (tolower(s[left]) != tolower(s[right])) also failed, the current left and right char are same.\\n                // So, we are still in a palindrome assumption. Just increment left and decrement right.\\n                \\n                left++;\\n                right--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437348,
                "title": "2-best-swift-solutions-easy-to-understand",
                "content": "# First solution using Two Pointers\\n\\n## Approach\\nFirstly, the function converts the string to lowercase and filters out all non-alphanumeric characters using the `filter` method. \\n\\nThen, it initializes two pointer variables `left` and `right` at the two ends of the filtered array. The `left` pointer starts from the first index, and the `right` pointer starts from the last index. \\n\\nIn the while loop, it checks if the value at the `left` pointer is equal to the value at the `right` pointer. If they are not equal, the function immediately returns `false` since the string is *not a palindrome*. If they are equal, the `left` pointer increments by 1 and the `right` pointer decrements by 1. The loop continues until the `left` pointer is greater than or equal to the `right` pointer.\\n\\nIf the loop completes without finding any non-matching characters, the function returns `true`, indicating that the given string *is a palindrome*. \\n\\n## Complexity\\nThe *time complexity* of the provided solution is $$O(n)$$, where $$n$$ is the length of the input string.\\n\\nThe *space complexity* of the solution is also $$O(n)$$. This is because the function creates a new array by filtering out non-alphanumeric characters from the input string.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func isPalindrome(_ s: String) -> Bool {\\n        let s = Array(s.lowercased().filter { $0.isLetter || $0.isNumber })\\n        var left = 0\\n        var right = s.count - 1\\n\\n        while left <= right {\\n            if s[left] != s[right] { return false }\\n            left += 1\\n            right -= 1\\n        }\\n        \\n        return true\\n    }\\n}\\n```\\n\\n\\n---\\n\\n\\n# Second solution using Reversed()\\n\\n## Approach\\nFirstly, the function converts the input string to lowercase and filters out all non-alphanumeric characters using the `filter` method of a string in Swift.\\n\\nThen, it creates a new string by reversing the filtered string using the `reversed()` method and passing the result to the `String()` initializer. The `reversed()` method returns a reversed collection of the elements in the original string, and the `String()` initializer creates a new string from the reversed collection.\\n\\nFinally, the function compares the reversed string with the original filtered string using the `==` operator. If they are equal, the function returns `true` indicating that the given string is a palindrome. If they are not equal, the function returns `false`.\\n\\n## Complexity\\nThis solution has a time complexity of $$O(n)$$ and a space complexity of $$O(n)$$, where $$n$$ is the length of the input string.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func isPalindrome(_ s: String) -> Bool {\\n        let s = s.lowercased().filter { $0.isLetter || $0.isNumber }\\n        return s == String(s.reversed())\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/4dd237d1-d5e1-409b-8e25-32993740b4f2_1681977849.1999822.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Two Pointers",
                    "String"
                ],
                "code": "```swift\\nclass Solution {\\n    func isPalindrome(_ s: String) -> Bool {\\n        let s = Array(s.lowercased().filter { $0.isLetter || $0.isNumber })\\n        var left = 0\\n        var right = s.count - 1\\n\\n        while left <= right {\\n            if s[left] != s[right] { return false }\\n            left += 1\\n            right -= 1\\n        }\\n        \\n        return true\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func isPalindrome(_ s: String) -> Bool {\\n        let s = s.lowercased().filter { $0.isLetter || $0.isNumber }\\n        return s == String(s.reversed())\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770882,
                "title": "c-o-n-time-o-1-space-seen-in-interviews-before",
                "content": "```\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        int i = 0;\\n        int j = s.Length-1;\\n        s = s.ToLower();\\n        while (i < j){\\n            if (!char.IsLetterOrDigit(s[i]))\\n                i++;\\n            else if (!char.IsLetterOrDigit(s[j]))\\n                j--;\\n            else if (s[i++] != s[j--])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        int i = 0;\\n        int j = s.Length-1;\\n        s = s.ToLower();\\n        while (i < j){\\n            if (!char.IsLetterOrDigit(s[i]))\\n                i++;\\n            else if (!char.IsLetterOrDigit(s[j]))\\n                j--;\\n            else if (s[i++] != s[j--])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40336,
                "title": "another-accepted-java-solution",
                "content": "    public class Solution {\\n        public boolean isPalindrome(String s) {\\n            if (s == null) return false;\\n            \\n            s = s.toLowerCase();\\n            \\n            int n = s.length(), i = 0, j = n - 1;\\n            \\n            char[] chars = s.toCharArray();\\n            \\n            while (i < j) {\\n                // skip any non-alphanumeric character\\n                while (i < n && !Character.isLetterOrDigit(chars[i])) { i++; }\\n                while (j >= 0 && !Character.isLetterOrDigit(chars[j])) { j--; }\\n                \\n                if (i < j && chars[i++] != chars[j--]) {\\n                    return false;\\n                }\\n            }\\n            \\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isPalindrome(String s) {\\n            if (s == null) return false;\\n            \\n            s = s.toLowerCase();\\n            \\n            int n = s.length(), i = 0, j = n - 1;\\n            \\n            char[] chars = s.toCharArray();\\n            \\n            while (i < j) {\\n                // skip any non-alphanumeric character\\n                while (i < n && !Character.isLetterOrDigit(chars[i])) { i++; }",
                "codeTag": "Java"
            },
            {
                "id": 3359681,
                "title": "c-esay-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n           string str;\\n        for(int i=0;i<s.size();i++) {\\n            if(isupper(s[i])) {\\n                s[i] = tolower(s[i]);\\n            }\\n            if(isalnum(s[i])) {\\n                str.push_back(s[i]);\\n            }\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n           string str;\\n        for(int i=0;i<s.size();i++) {\\n            if(isupper(s[i])) {\\n                s[i] = tolower(s[i]);\\n            }\\n            if(isalnum(s[i])) {\\n                str.push_back(s[i]);\\n            }\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195912,
                "title": "with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe function takes a string s as input and returns a boolean value indicating whether the string is a palindrome or not.\\n\\nTo check for palindrome, we first remove all non-alphanumeric characters and convert the string to lowercase. We can achieve this using a list comprehension to create a new string with only the alphanumeric characters in s, and then applying the lower() method to convert the string to lowercase.\\n\\nFinally, we check if the resulting string is equal to its reverse using the slicing notation s[::-1]. This creates a new string that is the reverse of s, which we then compare to the original string using the == operator.\\n\\nThe time complexity of this solution is O(n), where n is the length of the input string. This is because we iterate over the string once to remove non-alphanumeric characters, and then compare it to its reverse using slicing, which also takes O(n) time. The space complexity is also O(n), since we create a new string to store the alphanumeric characters.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # Convert to lowercase and remove non-alphanumeric characters\\n        s = \\'\\'.join(c for c in s if c.isalnum()).lower()\\n        # Check if string is equal to its reverse\\n        return s == s[::-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # Convert to lowercase and remove non-alphanumeric characters\\n        s = \\'\\'.join(c for c in s if c.isalnum()).lower()\\n        # Check if string is equal to its reverse\\n        return s == s[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770670,
                "title": "valid-palindrome-java-solution-easy-recursion",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n\\t//Removing all the non-Alphanumeric characters\\n        String temp = s.replaceAll(\"[^A-Za-z0-9]\", \"\"); // \"A man, a plan, a canal: Panama\" ----> \"AmanaplanacanalPanama\"\\n\\t//Converting All UpperCase character to lowercase\\t\\n        temp = temp.toLowerCase(); //\"AmanaplanacanalPanama\" --->\"amanaplanacanalpanama\"\\n\\t//Calling Helper Function with String temp, first index i.e. 0 and last index i.e. temp.length()-1\\n        return isPalindromeHelper(temp,0,temp.length()-1);\\n    }\\n\\t\\n\\t//we are comparing First and last index character of string e.g \"racecar\" -->first index char is \\'r\\' and last index char is also \\'r\\' which is equal \\n    //now from first index+1 to last index-1 i.e. \"aceca\" recursion will handle or give us the answer\\n\\t//if the characters are not equal e.g \"abcecb\" first index char is \\'a\\' which is not equal to last index char i.e. \\'b\\' simply return false\\n    public boolean isPalindromeHelper(String s, int firstIndex, int lastIndex){\\n\\t\\n\\t//BASE CASE:- if we have only single character in string e.g. \"a\" it is always palindrome so return true and also return true if firstIndex > lastIndex\\n\\t//that mean we have checked all the characters that\\'s why our firstIndex cross the lastIndex value\\n        if(firstIndex>=lastIndex)\\n            return true;\\n\\t\\t\\t\\n\\t//our task --> check if firstIndex character is not equal to lastindex character simply return false\\t\\n        if(s.charAt(firstIndex)!=s.charAt(lastIndex))\\n            return false;\\n\\t//if firstIndex character and lastindex character is equal recursion will handle from firstIndex+1 to lastIndex-1 \\t\\t\\n\\t\\t return isPalindromeHelper(s,firstIndex+1,lastIndex-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n\\t//Removing all the non-Alphanumeric characters\\n        String temp = s.replaceAll(\"[^A-Za-z0-9]\", \"\"); // \"A man, a plan, a canal: Panama\" ----> \"AmanaplanacanalPanama\"\\n\\t//Converting All UpperCase character to lowercase\\t\\n        temp = temp.toLowerCase(); //\"AmanaplanacanalPanama\" --->\"amanaplanacanalpanama\"\\n\\t//Calling Helper Function with String temp, first index i.e. 0 and last index i.e. temp.length()-1\\n        return isPalindromeHelper(temp,0,temp.length()-1);\\n    }\\n\\t\\n\\t//we are comparing First and last index character of string e.g \"racecar\" -->first index char is \\'r\\' and last index char is also \\'r\\' which is equal \\n    //now from first index+1 to last index-1 i.e. \"aceca\" recursion will handle or give us the answer\\n\\t//if the characters are not equal e.g \"abcecb\" first index char is \\'a\\' which is not equal to last index char i.e. \\'b\\' simply return false\\n    public boolean isPalindromeHelper(String s, int firstIndex, int lastIndex){\\n\\t\\n\\t//BASE CASE:- if we have only single character in string e.g. \"a\" it is always palindrome so return true and also return true if firstIndex > lastIndex\\n\\t//that mean we have checked all the characters that\\'s why our firstIndex cross the lastIndex value\\n        if(firstIndex>=lastIndex)\\n            return true;\\n\\t\\t\\t\\n\\t//our task --> check if firstIndex character is not equal to lastindex character simply return false\\t\\n        if(s.charAt(firstIndex)!=s.charAt(lastIndex))\\n            return false;\\n\\t//if firstIndex character and lastindex character is equal recursion will handle from firstIndex+1 to lastIndex-1 \\t\\t\\n\\t\\t return isPalindromeHelper(s,firstIndex+1,lastIndex-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760220,
                "title": "two-pointers-solution-98-93",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    let newStr = s.toLowerCase().replace(/[^0-9a-z]/g, \"\");\\n    let left = 0, right = newStr.length-1;\\n    \\n    while(left < right){\\n        if(newStr[left] !== newStr[right]) return false\\n        left++\\n        right--\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    let newStr = s.toLowerCase().replace(/[^0-9a-z]/g, \"\");\\n    let left = 0, right = newStr.length-1;\\n    \\n    while(left < right){\\n        if(newStr[left] !== newStr[right]) return false\\n        left++\\n        right--\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2661691,
                "title": "python-3-simple-isnumeric-isalpha-easy-to-understand",
                "content": "- This method uses `isalpha()` and `isnumeric()` to check if its a valid character\\n- If it is, it will add it to the new string: `a`\\n- Return true if `a` is equal to itself reversed (`a[::-1]`)\\n- Retrun false if it isnt\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = \"\"\\n        for x in s:\\n            if x.isalpha(): a += x.lower()\\n            if x.isnumeric(): a += x\\n        return a == a[::-1]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "- This method uses `isalpha()` and `isnumeric()` to check if its a valid character\\n- If it is, it will add it to the new string: `a`\\n- Return true if `a` is equal to itself reversed (`a[::-1]`)\\n- Retrun false if it isnt\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = \"\"\\n        for x in s:\\n            if x.isalpha(): a += x.lower()\\n            if x.isnumeric(): a += x\\n        return a == a[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 2586405,
                "title": "c-easy-solution-beginners-friendly-easy-to-understand-o-n",
                "content": "**Simple Approch** \\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string res ;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] >= \\'a\\' and s[i] <=\\'z\\'){\\n                res += s[i];\\n            }\\n            else if(s[i] >= \\'A\\' and s[i] <=\\'Z\\'){\\n                res += (s[i] + 32);\\n            }\\n            else if(s[i] >= 48 and s[i]<= 57){\\n                res += s[i];\\n            }\\n        }\\n        \\n        string ans = res ;\\n        reverse(ans.begin(),ans.end());\\n        \\n        if(ans==res) return true;\\n        else return false;\\n    }\\n};\\n```\\n\\n**Do Up Vote if You Like the Solution !!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string res ;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] >= \\'a\\' and s[i] <=\\'z\\'){\\n                res += s[i];\\n            }\\n            else if(s[i] >= \\'A\\' and s[i] <=\\'Z\\'){\\n                res += (s[i] + 32);\\n            }\\n            else if(s[i] >= 48 and s[i]<= 57){\\n                res += s[i];\\n            }\\n        }\\n        \\n        string ans = res ;\\n        reverse(ans.begin(),ans.end());\\n        \\n        if(ans==res) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275557,
                "title": "easy-solution-in-c-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::tolower);\\n        string str = \"\";\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                str += s[i];\\n            }\\n        }\\n        string str2 = str;\\n        reverse(str.begin(),str.end());\\n        return str == str2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::tolower);\\n        string str = \"\";\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                str += s[i];\\n            }\\n        }\\n        string str2 = str;\\n        reverse(str.begin(),str.end());\\n        return str == str2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133870,
                "title": "rust-doubleendediterator-solution",
                "content": "```\\nimpl Solution {\\n    pub fn is_palindrome(s: String) -> bool {\\n        let mut chars = s.chars().filter(|c| c.is_alphanumeric());\\n        while let (Some(c1), Some(c2)) = (chars.next(), chars.next_back()) {\\n            if !c1.eq_ignore_ascii_case(&c2) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_palindrome(s: String) -> bool {\\n        let mut chars = s.chars().filter(|c| c.is_alphanumeric());\\n        while let (Some(c1), Some(c2)) = (chars.next(), chars.next_back()) {\\n            if !c1.eq_ignore_ascii_case(&c2) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 897838,
                "title": "c-solution",
                "content": "```\\nbool isPalindrome(char * s){\\n    int len = strlen(s);\\n    int low = 0, high = len - 1;\\n    \\n    while(low < high){\\n        if(isalnum(s[low]) && isalnum(s[high])) {\\n            if(tolower(s[low]) != tolower(s[high]))\\n                return false;\\n            low++;\\n            high--;\\n        }\\n        if(!isalnum(s[low]))\\n            low++;\\n        if(!isalnum(s[high]))\\n            high--;        \\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPalindrome(char * s){\\n    int len = strlen(s);\\n    int low = 0, high = len - 1;\\n    \\n    while(low < high){\\n        if(isalnum(s[low]) && isalnum(s[high])) {\\n            if(tolower(s[low]) != tolower(s[high]))\\n                return false;\\n            low++;\\n            high--;\\n        }\\n        if(!isalnum(s[low]))\\n            low++;\\n        if(!isalnum(s[high]))\\n            high--;        \\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 896071,
                "title": "javascript-2-pointers-easy-to-read-and-faster-than-95",
                "content": "```\\nfunction isPalindrome(str) {\\n  // For easy comparison, convert to lower case and replace\\n  // any non- alpha or digit character with empty string.\\n  str = str.toLowerCase().replace(/[^a-z\\\\d]/g, \\'\\');\\n  \\n  // Start pointers at beginning (i) and end (j).\\n  // Move inward until something doesn\\'t match -OR-\\n  // the two pointers either meet or pass each other.\\n  for (let i = 0, j = str.length - 1; i < j; i++, j--) {\\n    if (str[i] !== str[j]) return false;\\n  }\\n  \\n  // If the loop completed with no equality issues,\\n  // the string is a valid palindrome.\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nfunction isPalindrome(str) {\\n  // For easy comparison, convert to lower case and replace\\n  // any non- alpha or digit character with empty string.\\n  str = str.toLowerCase().replace(/[^a-z\\\\d]/g, \\'\\');\\n  \\n  // Start pointers at beginning (i) and end (j).\\n  // Move inward until something doesn\\'t match -OR-\\n  // the two pointers either meet or pass each other.\\n  for (let i = 0, j = str.length - 1; i < j; i++, j--) {\\n    if (str[i] !== str[j]) return false;\\n  }\\n  \\n  // If the loop completed with no equality issues,\\n  // the string is a valid palindrome.\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880697,
                "title": "java-easy-solution",
                "content": "```\\npublic boolean isPalindrome(String s) {\\n        \\n\\ts=s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\\n\\tint start=0;\\n\\tint end=s.length()-1;\\n\\twhile(start<end)\\n\\t{\\n\\t\\tif(s.charAt(start++)!=s.charAt(end--))\\n\\t\\t\\t\\treturn false;\\n\\t}\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isPalindrome(String s) {\\n        \\n\\ts=s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\\n\\tint start=0;\\n\\tint end=s.length()-1;\\n\\twhile(start<end)\\n\\t{\\n\\t\\tif(s.charAt(start++)!=s.charAt(end--))\\n\\t\\t\\t\\treturn false;\\n\\t}\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376336,
                "title": "a-simple-o-n-c-solution",
                "content": "A simple two-pointer linear scan C# solution.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nRuntime: 76 ms, faster than 96.76% of C# online submissions for Valid Palindrome.\\nMemory Usage: 22.2 MB, less than 76.19% of C# online submissions for Valid Palindrome.\\n\\n```\\n    public bool IsPalindrome(string s) {\\n        int start = 0;\\n        int end = s.Length - 1;\\n        \\n        while(start < end){\\n            if(!Char.IsLetterOrDigit(s[start])){\\n                start++;\\n                continue;\\n            }\\n            \\n            if(!Char.IsLetterOrDigit(s[end])){\\n                end--;\\n                continue;\\n            }\\n            \\n            if(Char.ToLower(s[start]) != Char.ToLower(s[end])){\\n                return false;\\n            }\\n            \\n            start++;\\n            end--;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool IsPalindrome(string s) {\\n        int start = 0;\\n        int end = s.Length - 1;\\n        \\n        while(start < end){\\n            if(!Char.IsLetterOrDigit(s[start])){\\n                start++;\\n                continue;\\n            }\\n            \\n            if(!Char.IsLetterOrDigit(s[end])){\\n                end--;\\n                continue;\\n            }\\n            \\n            if(Char.ToLower(s[start]) != Char.ToLower(s[end])){\\n                return false;\\n            }\\n            \\n            start++;\\n            end--;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40364,
                "title": "my-accepted-solution-in-java-which-is-concise-i-think",
                "content": "The point is knowing how to use replaceAll() method in String class.... take me a while to learn the pattern argument.\\n\\n    public class Solution {\\n        public boolean isPalindrome(String s) {\\n            s = s.toLowerCase(); // convert all to lower cases.\\n            s = s.replaceAll(\"[^a-z^0-9]+\", \"\"); // remove all non-digital and non-letter.\\n            int len = s.length();\\n            for (int i = 0; i < len; i++){\\n                if (s.charAt(i) != s.charAt(len - i - 1)){\\n                    return false;\\n                }\\n            }\\n            return true;\\n       }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isPalindrome(String s) {\\n            s = s.toLowerCase(); // convert all to lower cases.\\n            s = s.replaceAll(\"[^a-z^0-9]+\", \"\"); // remove all non-digital and non-letter.\\n            int len = s.length();\\n            for (int i = 0; i < len; i++){\\n                if (s.charAt(i) != s.charAt(len - i - 1)){\\n                    return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4048684,
                "title": "python-98-beats-very-simple",
                "content": "**if you got help from this, Plz Upvote ..it motivate me...**\\n\\n# Code\\n```\\n<!-- Optimize Code -->\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s1 = \\'\\'\\n        for c in s.lower():\\n            if c.isalnum():\\n                s1 += c\\n\\n        return True if s1==s1[::-1] else False\\n\\n============================================================\\n<!-- # Practice Code Understand -->\\n============================================================\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s1 = \\'\\'\\n        for c in s.lower():\\n            if c.isalpha() or c.isnumeric():\\n                s1 += c\\n        print(s1)\\n\\n        s = s1[::-1]\\n        return True if s1==s else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\n<!-- Optimize Code -->\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s1 = \\'\\'\\n        for c in s.lower():\\n            if c.isalnum():\\n                s1 += c\\n\\n        return True if s1==s1[::-1] else False\\n\\n============================================================\\n<!-- # Practice Code Understand -->\\n============================================================\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s1 = \\'\\'\\n        for c in s.lower():\\n            if c.isalpha() or c.isnumeric():\\n                s1 += c\\n        print(s1)\\n\\n        s = s1[::-1]\\n        return True if s1==s else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992821,
                "title": "java",
                "content": "##### Intuition\\nTime Complexity : O(N)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        //check string is empty or not\\n        if (s.isEmpty()) {\\n            return true;\\n        }\\n       // setting the pointer to first and last index of the string\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            char leftChar = s.charAt(left);\\n            char rightChar = s.charAt(right);\\n            //if the character at left side is not equal to digit or letter then skip it and move on \\n            if (!Character.isLetterOrDigit(leftChar)) {\\n                left++;\\n             //if the character at right side is not equal to digit or letter then skip it and move on \\n            } else if (!Character.isLetterOrDigit(rightChar)) {\\n                right--;\\n            } else {\\n                if (Character.toLowerCase(leftChar) != Character.toLowerCase(rightChar)) {\\n                    return false;\\n                }\\n                left++;\\n                right--;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        //check string is empty or not\\n        if (s.isEmpty()) {\\n            return true;\\n        }\\n       // setting the pointer to first and last index of the string\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            char leftChar = s.charAt(left);\\n            char rightChar = s.charAt(right);\\n            //if the character at left side is not equal to digit or letter then skip it and move on \\n            if (!Character.isLetterOrDigit(leftChar)) {\\n                left++;\\n             //if the character at right side is not equal to digit or letter then skip it and move on \\n            } else if (!Character.isLetterOrDigit(rightChar)) {\\n                right--;\\n            } else {\\n                if (Character.toLowerCase(leftChar) != Character.toLowerCase(rightChar)) {\\n                    return false;\\n                }\\n                left++;\\n                right--;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609547,
                "title": "easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int l=0,h=s.size()-1;\\n        transform(s.begin(),s.end(),s.begin(),::tolower);\\n        while(l<=h){\\n            if(!isalnum(s[l]))\\n            l++;\\n            else if(!isalnum(s[h]))\\n            h--;\\n            else if((s[l])!=(s[h]))\\n            return 0;\\n            else{\\n                l++; h--;\\n            }\\n            \\n        }\\n        return 1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int l=0,h=s.size()-1;\\n        transform(s.begin(),s.end(),s.begin(),::tolower);\\n        while(l<=h){\\n            if(!isalnum(s[l]))\\n            l++;\\n            else if(!isalnum(s[h]))\\n            h--;\\n            else if((s[l])!=(s[h]))\\n            return 0;\\n            else{\\n                l++; h--;\\n            }\\n            \\n        }\\n        return 1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40418,
                "title": "change-the-original-string-to-a-new-simple-string",
                "content": "step1: filter.  remove characters not alphanumeric  and change all letters to lower case.\\nstep2; simple string check \\n   \\n\\n     bool checkEasyString(string s){          \\n        \\tif(s.size()<=1)return true;\\n        \\tint p=0,q=s.size()-1;\\n        \\twhile(p<q)if(s[p++]!=s[q--])return false;\\n        \\treturn true;\\n        }\\n    \\n    string filter(string str0){\\n    \\tstring str;\\n    \\tchar temp;\\n    \\tfor(int i=0;i<str0.size();i++){\\n    \\t\\ttemp=str0[i];\\n    \\t\\tif('0'<=temp && temp<='9' )str.push_back(temp);\\n    \\t\\telse if('a'<=temp && temp<='z')str.push_back(temp);\\n    \\t\\telse if('A'<=temp && temp<='Z')str.push_back(temp-('A'-'a'));\\n    \\t}\\n    \\treturn str;\\n    }\\n    \\n    \\n    bool isPalindrome(string s) {\\n        return checkEasyString(filter(s));\\n    }",
                "solutionTags": [],
                "code": "step1: filter.  remove characters not alphanumeric  and change all letters to lower case.\\nstep2; simple string check \\n   \\n\\n     bool checkEasyString(string s){          \\n        \\tif(s.size()<=1)return true;\\n        \\tint p=0,q=s.size()-1;\\n        \\twhile(p<q)if(s[p++]!=s[q--])return false;\\n        \\treturn true;\\n        }\\n    \\n    string filter(string str0){\\n    \\tstring str;\\n    \\tchar temp;\\n    \\tfor(int i=0;i<str0.size();i++){\\n    \\t\\ttemp=str0[i];\\n    \\t\\tif('0'<=temp && temp<='9' )str.push_back(temp);\\n    \\t\\telse if('a'<=temp && temp<='z')str.push_back(temp);\\n    \\t\\telse if('A'<=temp && temp<='Z')str.push_back(temp-('A'-'a'));\\n    \\t}\\n    \\treturn str;\\n    }\\n    \\n    \\n    bool isPalindrome(string s) {\\n        return checkEasyString(filter(s));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3584715,
                "title": "easiest-solution-with-commented-code-regexp",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    //^a-z0-9 represents that we must find all alphanumeric char and remove it.\\n    //gi represents: g=finds all matches ; i=checks case sensitivity\\n    //.toLowerCase() converts all uppercase letters to lowercase letters.\\n    let newStr = s.replace(/[^a-z0-9]/gi,\"\").toLowerCase();\\n\\n    //if we reverse the string and it\\'s equal to the newstr then we return true\\n    //if not, then we return false.\\n    return newStr.split(\"\").reverse().join(\"\") === newStr;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    //^a-z0-9 represents that we must find all alphanumeric char and remove it.\\n    //gi represents: g=finds all matches ; i=checks case sensitivity\\n    //.toLowerCase() converts all uppercase letters to lowercase letters.\\n    let newStr = s.replace(/[^a-z0-9]/gi,\"\").toLowerCase();\\n\\n    //if we reverse the string and it\\'s equal to the newstr then we return true\\n    //if not, then we return false.\\n    return newStr.split(\"\").reverse().join(\"\") === newStr;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459984,
                "title": "beats-68-4-18-145-top-interview-question",
                "content": "# Intuition\\n*two pointers at the start and end and keep shifting as inwards as long as left < right and both the values in string falls under alphanumeric*\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code checks whether a given string `s` is a palindrome or not. The approach used is to use two pointers, `left` and `right`, starting from the beginning and end of the string respectively, and then move them towards each other until they meet in the middle.\\n\\nAt each step, we check if the character at the `left` index is alphanumeric. If it\\'s not, we move `left` one position to the right. Similarly, if the character at the `right` index is not alphanumeric, we move `right` one position to the left. \\n\\nIf both the characters at `left` and `right` indices are alphanumeric, we check if they are equal or not. If they are not equal, the string is not a palindrome and we return `False`. Otherwise, we continue moving the pointers towards each other.\\n\\nIf the pointers meet in the middle of the string and no mismatches have been found, the string is a palindrome and we return `True`.\\n\\n\\n\\n# Complexity\\n- Time complexity: \\n O(n)\\n\\n- Space complexity:\\nO(1)\\n\\nThe `time complexity` of this code is `O(n)` because we need to traverse the string once. The `space complexity` is `O(1)` because we are not using any extra data structures to store the string.\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            if not s[left].isalnum():\\n                left += 1\\n            elif not s[right].isalnum():\\n                right -= 1\\n            elif s[left].lower() != s[right].lower():\\n                return False\\n            else:\\n                left += 1\\n                right -= 1\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            if not s[left].isalnum():\\n                left += 1\\n            elif not s[right].isalnum():\\n                right -= 1\\n            elif s[left].lower() != s[right].lower():\\n                return False\\n            else:\\n                left += 1\\n                right -= 1\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432586,
                "title": "c-well-explained-two-pointer",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlphanumeric(char ch)    {\\n        if(ch >= \\'a\\' && ch <= \\'z\\')   return true;\\n        if(ch >= \\'A\\' && ch <= \\'Z\\')   return true;\\n        if(ch >= \\'0\\' && ch <= \\'9\\')  return true;\\n        return false;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        int i=0, j=s.length()-1;\\n        while(i < j)    {\\n            if( !isAlphanumeric(s[i]) ) i++;  \\n            else if( !isAlphanumeric(s[j]) ) j--;\\n            else if(tolower(s[i]) != tolower(s[j]))   return false;\\n            else    i++, j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlphanumeric(char ch)    {\\n        if(ch >= \\'a\\' && ch <= \\'z\\')   return true;\\n        if(ch >= \\'A\\' && ch <= \\'Z\\')   return true;\\n        if(ch >= \\'0\\' && ch <= \\'9\\')  return true;\\n        return false;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        int i=0, j=s.length()-1;\\n        while(i < j)    {\\n            if( !isAlphanumeric(s[i]) ) i++;  \\n            else if( !isAlphanumeric(s[j]) ) j--;\\n            else if(tolower(s[i]) != tolower(s[j]))   return false;\\n            else    i++, j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751150,
                "title": "java-runtime-3ms-faster-than-99-29-memory-usage-less-than-95-31",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        if (s == null) return false;\\n        if (s.isEmpty()) return true;\\n        s = s.toLowerCase();\\n\\n        int l = 0, r = s.length() - 1;\\n        while (l < r) {\\n            while (!Character.isLetterOrDigit(s.charAt(l))) {\\n                l++;\\n                if (l == r) return true;\\n            }\\n            while (!Character.isLetterOrDigit(s.charAt(r))) r--;\\n\\n            if (s.charAt(l) == s.charAt(r)) {\\n                l++;\\n                r--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/540caece-4de3-4f17-9cac-601a7a6c5d46_1666934746.6680977.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        if (s == null) return false;\\n        if (s.isEmpty()) return true;\\n        s = s.toLowerCase();\\n\\n        int l = 0, r = s.length() - 1;\\n        while (l < r) {\\n            while (!Character.isLetterOrDigit(s.charAt(l))) {\\n                l++;\\n                if (l == r) return true;\\n            }\\n            while (!Character.isLetterOrDigit(s.charAt(r))) r--;\\n\\n            if (s.charAt(l) == s.charAt(r)) {\\n                l++;\\n                r--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682438,
                "title": "c-easiest-way-explained-code",
                "content": "class Solution {\\npublic:\\n\\n    bool isPalindrome(string s) {\\n    int st=0;\\n        int end=s.length()-1;\\n        while(st<=end){\\n            if(!isalnum(s[st])){st++; continue;} //isalnum to check whether its alphabet or number\\n            if(!isalnum(s[end])){end--; continue;}\\n            if(tolower(s[st])!=tolower(s[end])){ //tolower to cover it into lower case incase its case sensitive\\n     return 0;\\n        }else{\\n            st++;\\n            end--;\\n        }   \\n          \\n    }\\n           return 1;\\n    }      \\n\\n****",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isPalindrome(string s) {\\n    int st=0;\\n        int end=s.length()-1;\\n        while(st<=end){\\n            if(!isalnum(s[st])){st++; continue;}",
                "codeTag": "Java"
            },
            {
                "id": 2597169,
                "title": "easy-c-solution-and-short-solution",
                "content": "**If you like it please up vote**\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string n;\\n        \\n        for( int i=0;i<s.size();i++)\\n        {\\n            if(isalnum(s[i]))\\n            {\\n                    n.push_back(tolower(s[i]));\\n                \\n            }\\n        }\\n        **If you like it please upvote**\\n        for(int i=0,j=n.size()-1;i<=j;i++,j--)\\n        {\\n            \\n               \\n            if(n[i]!=n[j])\\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string n;\\n        \\n        for( int i=0;i<s.size();i++)\\n        {\\n            if(isalnum(s[i]))\\n            {\\n                    n.push_back(tolower(s[i]));\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2414895,
                "title": "python-easy-solution",
                "content": "```\\ndef isPalindrome(self, s: str) -> bool:\\n        alnum = \"\"\\n        for letter in s:\\n            if letter.isalnum(): # checking for alphanumeric\\n                alnum += letter.lower()\\n        return alnum == alnum[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isPalindrome(self, s: str) -> bool:\\n        alnum = \"\"\\n        for letter in s:\\n            if letter.isalnum(): # checking for alphanumeric\\n                alnum += letter.lower()\\n        return alnum == alnum[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2258328,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        if (s.empty()) return true; \\n        int r = s.size()-1;\\n        int l = 0;\\n        while (l < r) {\\n            if (!isalnum(s[l])) { l++; continue; }\\n            if (!isalnum(s[r])) { r--; continue; }   \\n            if (tolower(s[l]) != tolower(s[r])) return false;\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        if (s.empty()) return true; \\n        int r = s.size()-1;\\n        int l = 0;\\n        while (l < r) {\\n            if (!isalnum(s[l])) { l++; continue; }\\n            if (!isalnum(s[r])) { r--; continue; }   \\n            if (tolower(s[l]) != tolower(s[r])) return false;\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097709,
                "title": "python-94-time-86-memory-easy",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        i,j=0,len(s)-1\\n        s=s.lower()\\n        a={\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\',\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'}\\n        while (i<=j):\\n            while i<=j and s[i] not in a:\\n                i+=1\\n            while j>=i and s[j] not in a:\\n                j-=1\\n            if i<=j and s[i]!=s[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True\\n```\\n![image](https://assets.leetcode.com/users/images/7bd0c78b-30fd-4860-84b0-2e78c5f17226_1654075284.5249462.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        i,j=0,len(s)-1\\n        s=s.lower()\\n        a={\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\',\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'}\\n        while (i<=j):\\n            while i<=j and s[i] not in a:\\n                i+=1\\n            while j>=i and s[j] not in a:\\n                j-=1\\n            if i<=j and s[i]!=s[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007864,
                "title": "python-easy-solution-2-lines",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        new_s = \\'\\'.join([char.lower() for char in s if char.isalnum()])\\n        return new_s == new_s[::-1]\\n\\n```\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        new_s = \\'\\'.join([char.lower() for char in s if char.isalnum()])\\n        return new_s == new_s[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793564,
                "title": "solution-swift-valid-palindrome-test-cases",
                "content": "```swift\\nclass Solution {\\n    func isPalindrome(_ s: String) -> Bool {\\n        let chars = [Character](s.lowercased().filter { $0.isLetter || $0.isNumber })\\n        var idxL = 0, idxR = (chars.count - 1)\\n        while idxL < idxR {\\n            if chars[idxL] != chars[idxR] { return false }\\n            idxL += 1\\n            idxR -= 1\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // \"amanaplanacanalpanama\" is a palindrome.\\n    func test0() {\\n        let value = solution.isPalindrome(\"A man, a plan, a canal: Panama\")\\n        XCTAssertTrue(value)\\n    }\\n    \\n    // \"raceacar\" is not a palindrome.\\n    func test1() {\\n        let value = solution.isPalindrome(\"race a car\")\\n        XCTAssertFalse(value)\\n    }\\n    \\n    // \\'s\\' is an empty string \"\" after removing non-alphanumeric characters.\\n    // Since an empty string reads the same forward and backward, it is a palindrome.\\n    func test2() {\\n        let value = solution.isPalindrome(\" \")\\n        XCTAssertTrue(value)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isPalindrome(_ s: String) -> Bool {\\n        let chars = [Character](s.lowercased().filter { $0.isLetter || $0.isNumber })\\n        var idxL = 0, idxR = (chars.count - 1)\\n        while idxL < idxR {\\n            if chars[idxL] != chars[idxR] { return false }\\n            idxL += 1\\n            idxR -= 1\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // \"amanaplanacanalpanama\" is a palindrome.\\n    func test0() {\\n        let value = solution.isPalindrome(\"A man, a plan, a canal: Panama\")\\n        XCTAssertTrue(value)\\n    }\\n    \\n    // \"raceacar\" is not a palindrome.\\n    func test1() {\\n        let value = solution.isPalindrome(\"race a car\")\\n        XCTAssertFalse(value)\\n    }\\n    \\n    // \\'s\\' is an empty string \"\" after removing non-alphanumeric characters.\\n    // Since an empty string reads the same forward and backward, it is a palindrome.\\n    func test2() {\\n        let value = solution.isPalindrome(\" \")\\n        XCTAssertTrue(value)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608421,
                "title": "recursive-solution-easy-to-understand",
                "content": "I have converted string to vector because strings are immutable in cpp. Thus for every recursive call, a copy of string is created, leading to MEMORY LIMIT EXCEEDED error!! Link to [tweet](https://twitter.com/pra17dod/status/1466471591869620225) \\n```\\nclass Solution {\\npublic:\\n    bool rec(vector <char> &s, int st) {\\n        if (st >= s.size()/2) return true;        \\n        if (s[st] == s[s.size() - 1 - st]) \\n            return rec(s, st + 1);\\n        else \\n            return false;\\n    }\\n    \\npublic:\\n    bool isPalindrome(string s) {\\n        vector <char> str;\\n        for (auto &i : s) {\\n            i = tolower(i); \\n            if (ispunct(i) or i == \\' \\') \\n                continue;\\n            str.push_back(i);\\n            cout << i;\\n        }\\n        return rec(str, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(vector <char> &s, int st) {\\n        if (st >= s.size()/2) return true;        \\n        if (s[st] == s[s.size() - 1 - st]) \\n            return rec(s, st + 1);\\n        else \\n            return false;\\n    }\\n    \\npublic:\\n    bool isPalindrome(string s) {\\n        vector <char> str;\\n        for (auto &i : s) {\\n            i = tolower(i); \\n            if (ispunct(i) or i == \\' \\') \\n                continue;\\n            str.push_back(i);\\n            cout << i;\\n        }\\n        return rec(str, 0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 769710,
                "title": "java-good-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replaceAll(\"[^a-zA-Z0-9]\", \"\");\\n        int len = s.length();\\n        \\n        for(int i = 0; i < len / 2; i++){\\n            String c1 = Character.toString(s.charAt(i));\\n            String c2 = Character.toString(s.charAt(len - i - 1));\\n            if(!c1.equalsIgnoreCase(c2)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replaceAll(\"[^a-zA-Z0-9]\", \"\");\\n        int len = s.length();\\n        \\n        for(int i = 0; i < len / 2; i++){\\n            String c1 = Character.toString(s.charAt(i));\\n            String c2 = Character.toString(s.charAt(len - i - 1));\\n            if(!c1.equalsIgnoreCase(c2)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704142,
                "title": "i-keep-getting-wrong-answer-on-code-that-seems-to-be-working-the-the-test-environment-and-on-local",
                "content": "This is my code. It\\'s failing on the ```\"abb\\u02BCa\"``` case. The expected result is ```True```. On my local environment and in the LeetCode test environment, my code returns ```True```. In the LeetCode submission environment, it returns ```False```, for some reason.\\n\\nI read through the documentation [here](https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-) and a similar question [here](https://leetcode.com/problems/generate-parentheses/discuss/10493/Different-answer-between-local-IDLE-and-LeetCode) for why these situations might happen in Python. However, as far as I can tell, I\\'m not using any global or static variables, I\\'m not using any class variables, and I\\'m not using any default arguments, either.\\n\\nDoes anyone have any ideas as to what\\'s going on here? Am I just missing something or is this an actual bug?\\n\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s_parsed: List[str] = [letter for letter in s.lower() if letter.isalnum()]\\n        return s_parsed == s_parsed[::-1]\\n```",
                "solutionTags": [],
                "code": "```\"abb\\u02BCa\"```\n```True```\n```True```\n```False```\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s_parsed: List[str] = [letter for letter in s.lower() if letter.isalnum()]\\n        return s_parsed == s_parsed[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613248,
                "title": "passed-2ms-easy-java-code-with-two-pointers",
                "content": "```\\n       public boolean isPalindrome(String s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n        while (left < right) {\\n            if (!Character.isLetterOrDigit(s.charAt(left))) {\\n                left++;\\n                continue;\\n            }\\n            if (!Character.isLetterOrDigit(s.charAt(right))) {\\n                right--;\\n                continue;\\n            }\\n            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n       public boolean isPalindrome(String s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n        while (left < right) {\\n            if (!Character.isLetterOrDigit(s.charAt(left))) {\\n                left++;\\n                continue;\\n            }\\n            if (!Character.isLetterOrDigit(s.charAt(right))) {\\n                right--;\\n                continue;\\n            }\\n            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 313349,
                "title": "python-simple-code-12-mb",
                "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n        one_string = \"\"\\n        for x in s:\\n            if x.isalpha() or x.isdigit():\\n                one_string += x\\n        one_string = one_string.lower()\\n        if one_string == one_string[::-1]:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n        one_string = \"\"\\n        for x in s:\\n            if x.isalpha() or x.isdigit():\\n                one_string += x\\n        one_string = one_string.lower()\\n        if one_string == one_string[::-1]:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40249,
                "title": "share-my-7ms-java-solution",
                "content": "    public class Solution {\\n        public boolean isPalindrome(String s) {\\n            for(int i = 0, j = s.length() - 1; i < j; ++i, --j) {\\n                if(!Character.isLetterOrDigit(s.charAt(i))) {\\n                    ++j;\\n                    continue;\\n                }\\n                if(!Character.isLetterOrDigit(s.charAt(j))) {\\n                    --i;\\n                    continue;\\n                }            \\n                if(Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) {\\n                    return false;\\n                } \\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isPalindrome(String s) {\\n            for(int i = 0, j = s.length() - 1; i < j; ++i, --j) {\\n                if(!Character.isLetterOrDigit(s.charAt(i))) {\\n                    ++j;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 40310,
                "title": "c-two-pointer-solution",
                "content": "        \\n    bool isPalindrome(string s) {\\n        int l=0, r=s.size()-1;\\n        while (l<r) {\\n            while (l<r && !isalnum(s[l]))\\n                l++;\\n            while (l<r && !isalnum(s[r]))\\n                r--;\\n            if (tolower(s[l])!=tolower(s[r]))\\n                return false;\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "        \\n    bool isPalindrome(string s) {\\n        int l=0, r=s.size()-1;\\n        while (l<r) {\\n            while (l<r && !isalnum(s[l]))\\n                l++;\\n            while (l<r && !isalnum(s[r]))\\n                r--;\\n            if (tolower(s[l])!=tolower(s[r]))\\n                return false;\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 40382,
                "title": "this-is-my-accepted-java-code-just-for-reference-only",
                "content": "    public class Solution {\\n        public boolean isPalindrome(String s) {\\n            s = s.toLowerCase()\\n            s = s.replaceAll(\"[^A-Z^a-z^0-9]+\", \"\");\\n            StringBuffer sb = new StringBuffer(s);\\n    \\t    sb.reverse();\\n    \\t    String reverseString = sb.toString();\\n    \\t    boolean result = s.equals(reverseString);\\n       \\t    return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isPalindrome(String s) {\\n            s = s.toLowerCase()\\n            s = s.replaceAll(\"[^A-Z^a-z^0-9]+\", \"\");\\n            StringBuffer sb = new StringBuffer(s);\\n    \\t    sb.reverse();\\n    \\t    String reverseString = sb.toString();\\n    \\t    boolean result = s.equals(reverseString);\\n       \\t    return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3977509,
                "title": "java-10000-beats-pointer-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        int low = 0 , high = s.length()-1;\\n        while(low<high){\\n           char l = s.charAt(low) , h = s.charAt(high);\\n           if(!Character.isLetterOrDigit(l)) low++;\\n           else if(!Character.isLetterOrDigit(h)) high--;\\n           else {\\n               if(Character.toLowerCase(l)!=Character.toLowerCase(h)) return false;\\n               low++; high--;\\n           }  \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        int low = 0 , high = s.length()-1;\\n        while(low<high){\\n           char l = s.charAt(low) , h = s.charAt(high);\\n           if(!Character.isLetterOrDigit(l)) low++;\\n           else if(!Character.isLetterOrDigit(h)) high--;\\n           else {\\n               if(Character.toLowerCase(l)!=Character.toLowerCase(h)) return false;\\n               low++; high--;\\n           }  \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726097,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to check whether the given string is Palindrome or not after removing the special characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, I have counted the number of characters and numeric values in the given string s and stored the value in q, then I created a char array of size q and stored all the characters and numeric values in char array and then using two pointers compared the characters from the start and end. \\nIf characters are not equal then returned false otherwise true.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n        int q=0;\\n        for(int i=0;i<s.length();i++){\\n            if((\\'a\\'<=s.charAt(i) && s.charAt(i)<=\\'z\\') || (\\'0\\'<=s.charAt(i) && s.charAt(i)<=\\'9\\')){\\n                q++;\\n            }\\n        }\\n\\n        char[] arr = new char[q];\\n\\n        int k=0;\\n        for(int i=0;i<s.length();i++){\\n            if((\\'a\\'<=s.charAt(i) && s.charAt(i)<=\\'z\\') || (\\'0\\'<=s.charAt(i) && s.charAt(i)<=\\'9\\')){\\n                arr[k++] = s.charAt(i);\\n            }\\n        }\\n        s = new String(arr);\\n        int start = 0;\\n        int end = s.length()-1;\\n        while(start<=end){\\n            if(s.charAt(start++)!=s.charAt(end--)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/f55f8fea-2d94-47ec-a99b-acb15d7ea966_1688630107.6522055.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n        int q=0;\\n        for(int i=0;i<s.length();i++){\\n            if((\\'a\\'<=s.charAt(i) && s.charAt(i)<=\\'z\\') || (\\'0\\'<=s.charAt(i) && s.charAt(i)<=\\'9\\')){\\n                q++;\\n            }\\n        }\\n\\n        char[] arr = new char[q];\\n\\n        int k=0;\\n        for(int i=0;i<s.length();i++){\\n            if((\\'a\\'<=s.charAt(i) && s.charAt(i)<=\\'z\\') || (\\'0\\'<=s.charAt(i) && s.charAt(i)<=\\'9\\')){\\n                arr[k++] = s.charAt(i);\\n            }\\n        }\\n        s = new String(arr);\\n        int start = 0;\\n        int end = s.length()-1;\\n        while(start<=end){\\n            if(s.charAt(start++)!=s.charAt(end--)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230151,
                "title": "simple-python-two-liner-solution",
                "content": "\\nThis simple two liner approach to solving this problem relies on generator comprehension to make this a quick and concise solution.\\n\\n# Code\\n```\\n# The first line of code removes all non-alphanumeric characters and converts\\n# the whole string to lowercase making it easy to reverse the string cleanly\\n# using generator comprehension and storing it in the variable \"raw\".\\n\\n# The second line of code is fairly straightforward. It finds out whether or\\n# not the reversed form of the \"raw\" variable is equal to the unreversed\\n# form of itself also using generator comprehension.\\n\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        raw = \\'\\'.join(ch for ch in s if ch.isalnum()).lower()\\n        return raw[::-1] == raw\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The first line of code removes all non-alphanumeric characters and converts\\n# the whole string to lowercase making it easy to reverse the string cleanly\\n# using generator comprehension and storing it in the variable \"raw\".\\n\\n# The second line of code is fairly straightforward. It finds out whether or\\n# not the reversed form of the \"raw\" variable is equal to the unreversed\\n# form of itself also using generator comprehension.\\n\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        raw = \\'\\'.join(ch for ch in s if ch.isalnum()).lower()\\n        return raw[::-1] == raw\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765243,
                "title": "few-lines",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = \"\"\\n        for x in [*s]:\\n            if x.isalpha(): a += x.lower()\\n            if x.isnumeric(): a += x\\n        return a == a[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = \"\"\\n        for x in [*s]:\\n            if x.isalpha(): a += x.lower()\\n            if x.isnumeric(): a += x\\n        return a == a[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573303,
                "title": "2-javascript-solutions-top-1-and-top-5-for-speed",
                "content": "## Solution 1: Reverse String \\n```js\\n// Converts string to array, reverses it, then converts back to string\\nconst reverse = (str) => {\\n    const toArr = str.split(\"\");\\n    const reversed = toArr.reverse();\\n    return reversed.join(\"\");\\n}\\n// Removes all non-alphanumeric characters and converts to lowercase\\nconst lowerTrim = (str) => {\\n    const trimmed = str.replace(/[^a-z0-9]/gi, \\'\\');\\n    return trimmed.toLowerCase();\\n\\n}\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    const alphaNum = lowerTrim(s);\\n    return alphaNum === reverse(alphaNum);\\n};\\n```\\n\\n### LeetCode Output\\nRuntime: **74 ms**, faster than **95.21%** of JavaScript online submissions for Valid Palindrome.\\nMemory Usage: **46.2 MB**, less than **48.64%** of JavaScript online submissions for Valid Palindrome.\\n\\n[Link to Submission](https://leetcode.com/submissions/detail/799279513/)\\n\\n---\\n\\n## Solution 2: Two Pointers Approach\\n```js\\n// Removes all non-alphanumeric characters and converts to lowercase\\nconst alphaNumOnly = (str) => {\\n    const alphaNum = str.replace(/[^a-z0-9]/gi, \\'\\');\\n    return alphaNum.toLowerCase();\\n}\\n\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    let str = alphaNumOnly(s);\\n    for (let i = 0, j = str.length - 1; i < j; i++, j--) {\\n      if (str[i] !== str[j]) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n};\\n```\\n\\n### LeetCode Output\\nRuntime: **62 ms**, faster than **99.59%** of JavaScript online submissions for Valid Palindrome.\\nMemory Usage: **44.2 MB**, less than **86.40%** of JavaScript online submissions for Valid Palindrome.\\n\\n[Link to Submission](https://leetcode.com/submissions/detail/809729231/)",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```js\\n// Converts string to array, reverses it, then converts back to string\\nconst reverse = (str) => {\\n    const toArr = str.split(\"\");\\n    const reversed = toArr.reverse();\\n    return reversed.join(\"\");\\n}\\n// Removes all non-alphanumeric characters and converts to lowercase\\nconst lowerTrim = (str) => {\\n    const trimmed = str.replace(/[^a-z0-9]/gi, \\'\\');\\n    return trimmed.toLowerCase();\\n\\n}\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    const alphaNum = lowerTrim(s);\\n    return alphaNum === reverse(alphaNum);\\n};\\n```\n```js\\n// Removes all non-alphanumeric characters and converts to lowercase\\nconst alphaNumOnly = (str) => {\\n    const alphaNum = str.replace(/[^a-z0-9]/gi, \\'\\');\\n    return alphaNum.toLowerCase();\\n}\\n\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    let str = alphaNumOnly(s);\\n    for (let i = 0, j = str.length - 1; i < j; i++, j--) {\\n      if (str[i] !== str[j]) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402279,
                "title": "c-solution-easy-read-with-explinations",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n          \\n        string str(\"\"); //create empty string to be treated like vector of characters\\n            \\n        if(s.size() == 0 || s.size() == 1)\\n        {\\n            return true;\\n        }\\n        \\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalnum(s[i])) //isalnum() function checks for alphanumeric characters, if found pushes into str\\n            {\\n                str.push_back(tolower(s[i])); //converts to lower case\\n            }\\n            else\\n            {\\n                continue; //skip if not alphanumeric\\n            }\\n        }\\n        \\n        int i = 0; //reference pointers for traversing the str starting from str.begin()\\n        int j = str.size() - 1; //starting from str.end()\\n        \\n        while(i <= j) // while loop to traverse both forward and backward to compare\\n        {\\n            if(str[i] != str[j]) //if any letters are not found to be a reflection of each other\\n            {\\n                return false; //return false immediatly as one mismatch disqualifies this\\n            }\\n            \\n            i++; //increment i up 1\\n            j--; //decrement j down 1 \\n        }\\n        return true; //if all matches are found return true \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n          \\n        string str(\"\"); //create empty string to be treated like vector of characters\\n            \\n        if(s.size() == 0 || s.size() == 1)\\n        {\\n            return true;\\n        }\\n        \\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalnum(s[i])) //isalnum() function checks for alphanumeric characters, if found pushes into str\\n            {\\n                str.push_back(tolower(s[i])); //converts to lower case\\n            }\\n            else\\n            {\\n                continue; //skip if not alphanumeric\\n            }\\n        }\\n        \\n        int i = 0; //reference pointers for traversing the str starting from str.begin()\\n        int j = str.size() - 1; //starting from str.end()\\n        \\n        while(i <= j) // while loop to traverse both forward and backward to compare\\n        {\\n            if(str[i] != str[j]) //if any letters are not found to be a reflection of each other\\n            {\\n                return false; //return false immediatly as one mismatch disqualifies this\\n            }\\n            \\n            i++; //increment i up 1\\n            j--; //decrement j down 1 \\n        }\\n        return true; //if all matches are found return true \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291863,
                "title": "java-solution-two-pointers-with-comments",
                "content": "```\\n public boolean isPalindrome(String s) {\\n        \\n        if(s.isEmpty()){\\n            return true;\\n        }\\n        // A palindrome reads the same forwards and back so it is a classic two pointer problem\\n        // declare pointers for our left and right index\\n        int left = 0;\\n        int right = s.length() -1;\\n        \\n        while(left < right ){\\n            // the next two loops will incrment or decrement if the character is not \\n            // part of a palindrom: ie white space or punctuation\\n            if(!Character.isLetterOrDigit(s.charAt(left))){\\n                left ++;\\n            } else  if(!Character.isLetterOrDigit(s.charAt(right))){\\n                right --;\\n            }else {\\n                // now we use use pointers to compare the values at each end of the string. \\n                // if the condition is not met we can return false and exit. \\n                if(Character.toLowerCase(s.charAt(left++)) != Character.toLowerCase(s.charAt(right --))){\\n                    return false;\\n                }\\n            }            \\n           \\n        }\\n        return true;        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n public boolean isPalindrome(String s) {\\n        \\n        if(s.isEmpty()){\\n            return true;\\n        }\\n        // A palindrome reads the same forwards and back so it is a classic two pointer problem\\n        // declare pointers for our left and right index\\n        int left = 0;\\n        int right = s.length() -1;\\n        \\n        while(left < right ){\\n            // the next two loops will incrment or decrement if the character is not \\n            // part of a palindrom: ie white space or punctuation\\n            if(!Character.isLetterOrDigit(s.charAt(left))){\\n                left ++;\\n            } else  if(!Character.isLetterOrDigit(s.charAt(right))){\\n                right --;\\n            }else {\\n                // now we use use pointers to compare the values at each end of the string. \\n                // if the condition is not met we can return false and exit. \\n                if(Character.toLowerCase(s.charAt(left++)) != Character.toLowerCase(s.charAt(right --))){\\n                    return false;\\n                }\\n            }            \\n           \\n        }\\n        return true;        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089935,
                "title": "valid-palindrome-in-python-solution-92-faster",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        k = \\'\\'\\n        for i in s:\\n            if i.isalpha() or i.isdigit():\\n                k += i.lower()\\n        return k == k[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        k = \\'\\'\\n        for i in s:\\n            if i.isalpha() or i.isdigit():\\n                k += i.lower()\\n        return k == k[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787050,
                "title": "c-4-liner-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n            if(isalpha(s[i]) || isdigit(s[i]))  str+=tolower(s[i]);   // if char is alphabet or digit add into the string\\n\\t\\t\\t// to be a palindrome string must be same after being reversed\\n        return str==string(str.rbegin(),str.rend());                // compare str with reverse of str,if they both are equal it returns true otherwise false\\n    }\\n};\\n```\\n\\nIf you liked this solution, then please upvote \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n            if(isalpha(s[i]) || isdigit(s[i]))  str+=tolower(s[i]);   // if char is alphabet or digit add into the string\\n\\t\\t\\t// to be a palindrome string must be same after being reversed\\n        return str==string(str.rbegin(),str.rend());                // compare str with reverse of str,if they both are equal it returns true otherwise false\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571282,
                "title": "go-solution-with-comments",
                "content": "Let N be the length of an input string\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n```\\nfunc isPalindrome(s string) bool {\\n    left, right := 0, len(s) - 1\\n    \\n    for left < right {\\n        l := rune(s[left])\\n        r := rune(s[right])\\n        \\n        // if char at left is not a letter or digit increment the left pointer\\n        if !unicode.IsLetter(l) && !unicode.IsDigit(l) {\\n            left++\\n        } else if !unicode.IsLetter(r) && !unicode.IsNumber(r) { // if char at right is not a letter or digit decrement the right pointer\\n            right--\\n        } else if unicode.ToLower(l) == unicode.ToLower(r) { // if both are same chars increment left pointer and decrement right pointer\\n            left++\\n            right--\\n        } else { // if none of the above conditions are satisified this is not a palindrome\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPalindrome(s string) bool {\\n    left, right := 0, len(s) - 1\\n    \\n    for left < right {\\n        l := rune(s[left])\\n        r := rune(s[right])\\n        \\n        // if char at left is not a letter or digit increment the left pointer\\n        if !unicode.IsLetter(l) && !unicode.IsDigit(l) {\\n            left++\\n        } else if !unicode.IsLetter(r) && !unicode.IsNumber(r) { // if char at right is not a letter or digit decrement the right pointer\\n            right--\\n        } else if unicode.ToLower(l) == unicode.ToLower(r) { // if both are same chars increment left pointer and decrement right pointer\\n            left++\\n            right--\\n        } else { // if none of the above conditions are satisified this is not a palindrome\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447745,
                "title": "2-line-code-python-faster-than-95-88-please-upvote",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s = \\'\\'.join([char.casefold() for char in s if char.isalnum()])\\n        return s == s[::-1]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7d78b599-d827-4148-8c52-47b6feb7c355_1630913913.0839472.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s = \\'\\'.join([char.casefold() for char in s if char.isalnum()])\\n        return s == s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050100,
                "title": "simple-python-solution",
                "content": "```\\ndef isPalindrome(self, s: str) -> bool:\\n           \\n        new =\\'\\'\\n        s = s.lower() # Converts a string to all lower case\\n\\n        for i in s:\\n            if i.isalnum(): # is true if the character is an alphanumeric. Meaning alphabets or numbers only. No punctuation, no special characters\\n                new = new + i\\n\\n        return new == new[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef isPalindrome(self, s: str) -> bool:\\n           \\n        new =\\'\\'\\n        s = s.lower() # Converts a string to all lower case\\n\\n        for i in s:\\n            if i.isalnum(): # is true if the character is an alphanumeric. Meaning alphabets or numbers only. No punctuation, no special characters\\n                new = new + i\\n\\n        return new == new[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 998883,
                "title": "python3-faster-than-90-easy-to-understand",
                "content": "+1 if you likey\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s1 = \\'\\'\\n        for i in s:\\n            if i.isalnum():\\n                s1+=i.lower()\\n        \\n        return s1[::-1] == s1\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s1 = \\'\\'\\n        for i in s:\\n            if i.isalnum():\\n                s1+=i.lower()\\n        \\n        return s1[::-1] == s1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975415,
                "title": "easy-c-solution-4ms",
                "content": "### T = O(n) & S = O(1)\\n**toupper** is a function to convert lowercase letters into uppercase.\\n**isalnum** is a function to check if character is alphabet or numeric.\\n\\nI used two pointers (start & end) to iterate and compare, but the **problem** came when any other character apart from alphabet and numeric came then I used **toupper** function to compare its ASCII values in uppercase format if it exists.\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int start = 0;\\n        int n = s.size();\\n        int end = n-1;\\n        \\n        while(start<=end) {\\n\\n\\t\\twhile(start < end && !isalnum(s[start])) start++;\\n\\t\\twhile(start < end && !isalnum(s[end])) end--;\\n\\n\\t\\t//compare characters\\n\\t\\tif(toupper(s[start]) != toupper(s[end])) return false;\\n\\n\\t\\tstart++;// else\\n\\t\\tend--;\\n\\t}\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int start = 0;\\n        int n = s.size();\\n        int end = n-1;\\n        \\n        while(start<=end) {\\n\\n\\t\\twhile(start < end && !isalnum(s[start])) start++;\\n\\t\\twhile(start < end && !isalnum(s[end])) end--;\\n\\n\\t\\t//compare characters\\n\\t\\tif(toupper(s[start]) != toupper(s[end])) return false;\\n\\n\\t\\tstart++;// else\\n\\t\\tend--;\\n\\t}\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771153,
                "title": "c-two-pointer-solution",
                "content": "**Solution 1: two-pointer**\\n\\nHave two pointers pointing at the beginning and end of s, then compare charaters in pair.\\n\\nTime complexity is O(n) where n is the number of charaters in s. Space complexity is O(1).\\n```\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        \\n        if(s ==\"\" || s.Length <= 1)\\n            return true;\\n        \\n        int left = 0, right = s.Length - 1;\\n        \\n        while(left < right)\\n        {\\n\\t\\t    // don\\'t foget to check left < right\\n            while(left < right && !Char.IsLetterOrDigit(s[left]))\\n                left++;\\n            while(left < right && !Char.IsLetterOrDigit(s[right]))\\n                right--;\\n                \\n            if(left < right && Char.ToLower(s[left]) != Char.ToLower(s[right]))\\n                return false;\\n            \\n            left++;\\n            right--;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        \\n        if(s ==\"\" || s.Length <= 1)\\n            return true;\\n        \\n        int left = 0, right = s.Length - 1;\\n        \\n        while(left < right)\\n        {\\n\\t\\t    // don\\'t foget to check left < right\\n            while(left < right && !Char.IsLetterOrDigit(s[left]))\\n                left++;\\n            while(left < right && !Char.IsLetterOrDigit(s[right]))\\n                right--;\\n                \\n            if(left < right && Char.ToLower(s[left]) != Char.ToLower(s[right]))\\n                return false;\\n            \\n            left++;\\n            right--;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412797,
                "title": "swift-5-solution",
                "content": "```\\nclass Solution {\\n\\tfunc isPalindrome(_ s: String) -> Bool {\\n      var reversed = \"\"\\n\\n      for item in s.lowercased().reversed() where item.isLetter || item.isNumber {\\n          reversed.append(item)\\n      }\\n\\n      return reversed == String(reversed.reversed())\\n  }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc isPalindrome(_ s: String) -> Bool {\\n      var reversed = \"\"\\n\\n      for item in s.lowercased().reversed() where item.isLetter || item.isNumber {\\n          reversed.append(item)\\n      }\\n\\n      return reversed == String(reversed.reversed())\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400395,
                "title": "python-methods-beat-97-with-regular-expression",
                "content": "1. remove punctuation and space (beat 86%)\\n```\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n        if not s:\\n            return True\\n        \\n        # String punctuation excluded : beat 86%\\n        s = \\'\\'.join(x.lower() for x in s if x.isalnum())\\n        return s == s[::-1]\\n```\\n\\n2. regular expression(beat 97%)\\n```\\nimport re\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n\\n        if not s:\\n            return True\\n        # regular expression : beat 97%\\n        s = re.sub(\\'\\\\W+\\',\\'\\', s).lower() # remove punctuation marks and space \\n        return s == s[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n        if not s:\\n            return True\\n        \\n        # String punctuation excluded : beat 86%\\n        s = \\'\\'.join(x.lower() for x in s if x.isalnum())\\n        return s == s[::-1]\\n```\n```\\nimport re\\nclass Solution(object):\\n    def isPalindrome(self, s):\\n\\n        if not s:\\n            return True\\n        # regular expression : beat 97%\\n        s = re.sub(\\'\\\\W+\\',\\'\\', s).lower() # remove punctuation marks and space \\n        return s == s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249946,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    s = s.replace(/\\\\W+/g, \"\").toLowerCase();\\n    return s === s.split(\"\").reverse().join(\"\");\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    s = s.replace(/\\\\W+/g, \"\").toLowerCase();\\n    return s === s.split(\"\").reverse().join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249156,
                "title": "attention-please-the-string-may-include-number-it-s-0p-zero-p-not-op",
                "content": "there is a test can\\'t pass,i found it\\'s **\"0P\"(zero P) not \"OP\"**!!!my c++ 98% solution:**\\n```\\nbool isPalindrome(string s) {\\n    int length =s.size();\\n    string myString = \"\";\\n    for(int i=0;i<length;i++){\\n        if(\\'A\\'<=s[i]&&s[i]<=\\'Z\\') myString+=(s[i]+32);\\n        else if(\\'a\\'<=s[i]&&s[i]<=\\'z\\') myString+=s[i];\\n        else if(\\'0\\'<=s[i]&&s[i]<=\\'9\\') myString+=s[i];\\n    }\\n    length = myString.size();\\n    for(int i=0,j=length-1;i<j;i++,j--){\\n        if(myString[i]!=myString[j]) return false;\\n    }\\n    return true;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPalindrome(string s) {\\n    int length =s.size();\\n    string myString = \"\";\\n    for(int i=0;i<length;i++){\\n        if(\\'A\\'<=s[i]&&s[i]<=\\'Z\\') myString+=(s[i]+32);\\n        else if(\\'a\\'<=s[i]&&s[i]<=\\'z\\') myString+=s[i];\\n        else if(\\'0\\'<=s[i]&&s[i]<=\\'9\\') myString+=s[i];\\n    }\\n    length = myString.size();\\n    for(int i=0,j=length-1;i<j;i++,j--){\\n        if(myString[i]!=myString[j]) return false;\\n    }\\n    return true;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 134015,
                "title": "why-is-kotlin-so-slow",
                "content": "Hi everyone.\\nI solved this problem in Java and Kotlin to compare their performance and I was shoked that kotlin is so slow.\\nActually  Java runtime was 0 ms and Kotlin\\'s was around 200 ms.\\nCode in both cases is almost the same:\\n```class Solution {\\n    fun isPalindrome(s: String): Boolean {\\n        val lowerS = s.toLowerCase()\\n        \\n        var l = 0\\n        var r = s.length - 1\\n        \\n        while (l < r) {\\n            val lChar = lowerS[l]\\n            val rChar = lowerS[r]\\n            \\n            if ((lChar > \\'z\\' || lChar < \\'a\\') && (lChar < \\'0\\' || lChar > \\'9\\')) {\\n                l++\\n                continue\\n            }\\n            if ((rChar > \\'z\\' || rChar < \\'a\\') && (rChar < \\'0\\' || rChar > \\'9\\')) {\\n                r--\\n                continue\\n            }\\n            \\n            if (lChar != rChar)\\n                return false\\n            \\n            l++\\n            r--\\n        }\\n        \\n        return true\\n    }\\n}```\\n\\nSo my question is whe is it so sloooow?\\nIs it me or is it Kotlin?\\nI mean I assume that Kotlin may be a little bit slower because of things that are going on under the hood but such performance is redeculous.",
                "solutionTags": [],
                "code": "```class Solution {\\n    fun isPalindrome(s: String): Boolean {\\n        val lowerS = s.toLowerCase()\\n        \\n        var l = 0\\n        var r = s.length - 1\\n        \\n        while (l < r) {\\n            val lChar = lowerS[l]\\n            val rChar = lowerS[r]\\n            \\n            if ((lChar > \\'z\\' || lChar < \\'a\\') && (lChar < \\'0\\' || lChar > \\'9\\')) {\\n                l++\\n                continue\\n            }\\n            if ((rChar > \\'z\\' || rChar < \\'a\\') && (rChar < \\'0\\' || rChar > \\'9\\')) {\\n                r--\\n                continue\\n            }\\n            \\n            if (lChar != rChar)\\n                return false\\n            \\n            l++\\n            r--\\n        }\\n        \\n        return true\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 39980,
                "title": "i-think-these-two-lines-in-python-are-already-proposed",
                "content": "\\n    def isPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"                \\n        #method 1\\n        s_temp=[temp.lower() for temp in s if temp in string.ascii_letters + string.digits] \\n        \\n        #method 2\\n        s_temp=[temp.lower() for temp in s if temp.isalnum()] \\n        \\n        #method 3\\n        s_temp=''.join(temp.lower() for temp in s if temp.isalnum())\\n        \\n        return s_temp == s_temp[::-1]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n    def isPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"                \\n        #method 1\\n        s_temp=[temp.lower() for temp in s if temp in string.ascii_letters + string.digits] \\n        \\n        #method 2\\n        s_temp=[temp.lower() for temp in s if temp.isalnum()] \\n        \\n        #method 3\\n        s_temp=''.join(temp.lower() for temp in s if temp.isalnum())\\n        \\n        return s_temp == s_temp[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 40028,
                "title": "7-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int i = 0, j = s.size() - 1;\\n        while(i < j){\\n            while(i < j && !isalnum(s[i])) i++;\\n            while(i < j && !isalnum(s[j])) j--;\\n            if(tolower(s[i++]) != tolower(s[j--])) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int i = 0, j = s.size() - 1;\\n        while(i < j){\\n            while(i < j && !isalnum(s[i])) i++;\\n            while(i < j && !isalnum(s[j])) j--;\\n            if(tolower(s[i++]) != tolower(s[j--])) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40144,
                "title": "javascript-beats-91",
                "content": "I was forcecd to use regex in order to check the alphanumeric portion. Googling did not help find any alternatives, so please let me know if anyone finds any for Javascript:\\n\\n```\\nvar isPalindrome = function(s) {\\n    \\n   \\n    s = s.replace(/[^0-9a-zA-Z]+/gmi,\"\");\\n    s = s.toLowerCase();\\n    var l = 0, r = s.length - 1;\\n    console.log(s);\\n\\n    while(l<r) {\\n        if(s.charAt(l) != s.charAt(r)) {\\n            return false;\\n        }\\n        l++;\\n        r--;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(s) {\\n    \\n   \\n    s = s.replace(/[^0-9a-zA-Z]+/gmi,\"\");\\n    s = s.toLowerCase();\\n    var l = 0, r = s.length - 1;\\n    console.log(s);\\n\\n    while(l<r) {\\n        if(s.charAt(l) != s.charAt(r)) {\\n            return false;\\n        }\\n        l++;\\n        r--;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40287,
                "title": "clean-8ms-java-solution-easy-to-understand",
                "content": "\\n\\n    public boolean isPalindrome(String s) {\\n        if (s == null) {\\n            return false;\\n        }\\n        int left = 0;\\n        int right = s.length() - 1;\\n        while (left < right) {\\n            if (!isAlphanumeric(s.charAt(left))) {\\n                left++;\\n            } else if (!isAlphanumeric(s.charAt(right))) {\\n                right--;\\n            } else if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)))  {\\n                return false;\\n            } else {\\n                left++;\\n                right--;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isAlphanumeric(char c) {\\n        return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9');\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    public boolean isPalindrome(String s) {\\n        if (s == null) {\\n            return false;\\n        }\\n        int left = 0;\\n        int right = s.length() - 1;\\n        while (left < right) {\\n            if (!isAlphanumeric(s.charAt(left))) {\\n                left++;\\n            } else if (!isAlphanumeric(s.charAt(right))) {\\n                right--;\\n            } else if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)))  {\\n                return false;\\n            } else {\\n                left++;\\n                right--;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isAlphanumeric(char c) {\\n        return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9');\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 40328,
                "title": "my-short-c-code-12ms",
                "content": "Move two pointers (start & end) towards the middle, skip non alphanumeric characters, if they are not equal to each other, return false;\\n\\n    class Solution {\\n    public:\\n        bool isPalindrome(string s) {\\n            int start = 0, end = s.size()-1;\\n            while(start<end)\\n            {\\n                if(!isalnum(s[start])) ++start; // skip non alphanumerical characters\\n                else if(!isalnum(s[end])) --end;\\n                else if(tolower(s[start++]) != tolower(s[end--])) return false; // return false when nonequal is found\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(string s) {\\n            int start = 0, end = s.size()-1;\\n            while(start<end)\\n            {\\n                if(!isalnum(s[start])) ++start; // skip non alphanumerical characters\\n                else if(!isalnum(s[end])) --end;\\n                else if(tolower(s[start++]) != tolower(s[end--])) return false; // return false when nonequal is found\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 40429,
                "title": "shall-we-ignore-non-alphanumeric-characters",
                "content": "Input:\\t\"1a2\" <br/>\\nOutput:\\ttrue <br/>\\nExpected:\\tfalse <br/>\\n\\nHere is my code: I thought we need to ignore non-alphanumeric characters\\n\\n    public boolean isPalindrome(String s) {\\n        // IMPORTANT: Please reset any member data you declared, as\\n        // the same Solution instance will be reused for each test case.\\n        if(s.isEmpty()) return true;\\n        s=s.replaceAll(\"[^a-zA-Z]\", \"\");\\n        s=s.toLowerCase();\\n        int length=s.length();\\n        int i=0;\\n        int j=length-1;\\n        boolean validPadindrome=true;\\n        while(i<=j) {\\n            if(!(s.charAt(i)>='a'&&s.charAt(i)<='z')) i++;\\n            if(!(s.charAt(j)>='a'&&s.charAt(j)<='z')) j--;\\n            if(s.charAt(i)==s.charAt(j)) {\\n                i++;\\n                j--;\\n            } else {\\n                validPadindrome=false;\\n                break;\\n            }\\n        }\\n        return validPadindrome;\\n    }",
                "solutionTags": [],
                "code": "Input:\\t\"1a2\" <br/>\\nOutput:\\ttrue <br/>\\nExpected:\\tfalse <br/>\\n\\nHere is my code: I thought we need to ignore non-alphanumeric characters\\n\\n    public boolean isPalindrome(String s) {\\n        // IMPORTANT: Please reset any member data you declared, as\\n        // the same Solution instance will be reused for each test case.\\n        if(s.isEmpty()) return true;\\n        s=s.replaceAll(\"[^a-zA-Z]\", \"\");\\n        s=s.toLowerCase();\\n        int length=s.length();\\n        int i=0;\\n        int j=length-1;\\n        boolean validPadindrome=true;\\n        while(i<=j) {\\n            if(!(s.charAt(i)>='a'&&s.charAt(i)<='z')) i++;\\n            if(!(s.charAt(j)>='a'&&s.charAt(j)<='z')) j--;\\n            if(s.charAt(i)==s.charAt(j)) {\\n                i++;\\n                j--;\\n            } else {\\n                validPadindrome=false;\\n                break;\\n            }\\n        }\\n        return validPadindrome;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3883284,
                "title": "java-99-7-beat-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic  boolean isPalindrome(String s) {\\n        // int i = 0, j = s.length() - 1;\\n        // 0 9  A Z  a z\\n        \\n        char[] c = s.toCharArray();\\n        int i = 0, j = c.length - 1;\\n        // if(c.length==2){\\n        //     return c[i]==c[j]?true:false;\\n        // }\\n        while (i <=j) {\\n            if (upper(c[i])) {\\n                c[i] = tolowercase(c[i]);\\n            }\\n            if (upper(c[j])) {\\n                c[j] = tolowercase(c[j]);\\n            }\\n            i++;\\n            j--;\\n        }\\n        // 2 -1\\n        // System.out.println(Arrays.toString(c));\\n        i = 0;\\n        j = c.length - 1;\\n        while (i < j) {\\n            while (i<c.length&&!isalphanu(c[i])) {\\n                i++;\\n            }\\n            while (i<c.length&&!isalphanu(c[j])) {\\n                j--;\\n            }\\n            if(j<i){\\n                return true;\\n            }\\n            if (c[i] != c[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    public  char tolowercase(char c) {\\n        return (char) (c + 32);\\n    }\\n\\n    public  boolean isalphanu(char c) {\\n        boolean b = (c >= \\'0\\' && c <= \\'9\\') || (c >= \\'a\\' && c <= \\'z\\') ? true : false;\\n        return b;\\n    }\\n\\n    public  boolean upper(char c) {\\n        return (c >= \\'A\\' && c <= \\'Z\\') ? true : false;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\npublic  boolean isPalindrome(String s) {\\n        // int i = 0, j = s.length() - 1;\\n        // 0 9  A Z  a z\\n        \\n        char[] c = s.toCharArray();\\n        int i = 0, j = c.length - 1;\\n        // if(c.length==2){\\n        //     return c[i]==c[j]?true:false;\\n        // }\\n        while (i <=j) {\\n            if (upper(c[i])) {\\n                c[i] = tolowercase(c[i]);\\n            }\\n            if (upper(c[j])) {\\n                c[j] = tolowercase(c[j]);\\n            }\\n            i++;\\n            j--;\\n        }\\n        // 2 -1\\n        // System.out.println(Arrays.toString(c));\\n        i = 0;\\n        j = c.length - 1;\\n        while (i < j) {\\n            while (i<c.length&&!isalphanu(c[i])) {\\n                i++;\\n            }\\n            while (i<c.length&&!isalphanu(c[j])) {\\n                j--;\\n            }\\n            if(j<i){\\n                return true;\\n            }\\n            if (c[i] != c[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    public  char tolowercase(char c) {\\n        return (char) (c + 32);\\n    }\\n\\n    public  boolean isalphanu(char c) {\\n        boolean b = (c >= \\'0\\' && c <= \\'9\\') || (c >= \\'a\\' && c <= \\'z\\') ? true : false;\\n        return b;\\n    }\\n\\n    public  boolean upper(char c) {\\n        return (c >= \\'A\\' && c <= \\'Z\\') ? true : false;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513417,
                "title": "recursive-solution-c-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we were to start comparing characters of the string (after making it valid according to given conditions) and continue till they met in the middle, we would be able to successfully determine whether it is palindromic or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we will declare a new string `sol` and assign to it the valid version of the given string. In order to do so, we will convert all uppercase characters of `s` into lowercase and push it into `sol`. For lowercase characters and numbers, we will push them into `sol` as it is.\\n\\nDeclare a function `revStr` and pass to it the valid string and the integer `i` initialized to 0. If `i` is greater than or equal to half the length of `sol`, return true. Else if the character at the ith index of `sol` is NOT equal to the character found at its (length-i-1)th index, return false;\\n\\nFinally, call the function again, only this time with `i` = `i`+1.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool revStr(string& sol, int i){\\n        int len=sol.length();\\n        \\n        if(i>=len/2) return true;\\n        else if (sol[i]!=sol[len-i-1]) return false;\\n        return revStr(sol, i+1);\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string sol;\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=\\'A\\'&&s[i]<=\\'Z\\') sol.push_back(tolower(s[i]));\\n            else if(s[i]>=\\'a\\'&&s[i]<=\\'z\\'||s[i]>=\\'0\\'&&s[i]<=\\'9\\') sol.push_back(s[i]);\\n        }\\n        return revStr(sol, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool revStr(string& sol, int i){\\n        int len=sol.length();\\n        \\n        if(i>=len/2) return true;\\n        else if (sol[i]!=sol[len-i-1]) return false;\\n        return revStr(sol, i+1);\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string sol;\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=\\'A\\'&&s[i]<=\\'Z\\') sol.push_back(tolower(s[i]));\\n            else if(s[i]>=\\'a\\'&&s[i]<=\\'z\\'||s[i]>=\\'0\\'&&s[i]<=\\'9\\') sol.push_back(s[i]);\\n        }\\n        return revStr(sol, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350516,
                "title": "c-code-recursive-solution-fully-commented",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //eg string : nitin\\n    bool checkpalindrome(int i,vector<char>&ch,int n) // This function is comparing first and the last character of the string;\\n    {\\n        if(i>=n/2) //if the string is palindrome then we have to only go to half of it\\'s length\\n        return true;\\n\\n        if(ch[i]!=ch[n-i-1]) // if we get any character which is not equal to its (n-i-1) position then we return false\\n        return false;\\n        \\n        return checkpalindrome(i+1,ch,n); // call the function for i+1 ;\\n    }\\n\\n\\n\\n    bool isPalindrome(string s) {\\n        vector<char>ch; //To store the characters of a string ;\\n       for(int i=0;i<s.length();i++)\\n       {\\n             if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'0\\'&& s[i]<=\\'9\\'))// This will only store characters from a-z and 0-9\\n             ch.emplace_back(s[i]);  // Store the character into ch vector\\n             else if(s[i]>=\\'A\\' && s[i]<=\\'Z\\')// if the character is between A-Z then we have to convert it into lowercase;\\n             {\\n                 char lower=tolower(s[i]); //tolower function to convert the uppercase letter to lowercase letter;\\n                 ch.emplace_back(lower);  // Store the character into ch vector;\\n             }\\n       }\\n\\n       int len=ch.size(); // This will store the size of ch vector which will be used in above function;\\n       if(checkpalindrome(0,ch,len)==true) // If the function returns true then the string is a palindrome else not;\\n       return true;\\n       else\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //eg string : nitin\\n    bool checkpalindrome(int i,vector<char>&ch,int n) // This function is comparing first and the last character of the string;\\n    {\\n        if(i>=n/2) //if the string is palindrome then we have to only go to half of it\\'s length\\n        return true;\\n\\n        if(ch[i]!=ch[n-i-1]) // if we get any character which is not equal to its (n-i-1) position then we return false\\n        return false;\\n        \\n        return checkpalindrome(i+1,ch,n); // call the function for i+1 ;\\n    }\\n\\n\\n\\n    bool isPalindrome(string s) {\\n        vector<char>ch; //To store the characters of a string ;\\n       for(int i=0;i<s.length();i++)\\n       {\\n             if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'0\\'&& s[i]<=\\'9\\'))// This will only store characters from a-z and 0-9\\n             ch.emplace_back(s[i]);  // Store the character into ch vector\\n             else if(s[i]>=\\'A\\' && s[i]<=\\'Z\\')// if the character is between A-Z then we have to convert it into lowercase;\\n             {\\n                 char lower=tolower(s[i]); //tolower function to convert the uppercase letter to lowercase letter;\\n                 ch.emplace_back(lower);  // Store the character into ch vector;\\n             }\\n       }\\n\\n       int len=ch.size(); // This will store the size of ch vector which will be used in above function;\\n       if(checkpalindrome(0,ch,len)==true) // If the function returns true then the string is a palindrome else not;\\n       return true;\\n       else\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311331,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool isPalindrome(char * s) {\\n    char* first = s;\\n    char* last = s + strlen(s) - 1;\\n\\n    while (first <= last) {\\n        if (isalnum(*first) && isalnum(*last)) {\\n            if (tolower(*first++) != tolower(*last--)) return false;\\n        }\\n        else {\\n            if (!isalnum(*first)) ++first;\\n            if (!isalnum(*last)) --last;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nbool isPalindrome(char * s) {\\n    char* first = s;\\n    char* last = s + strlen(s) - 1;\\n\\n    while (first <= last) {\\n        if (isalnum(*first) && isalnum(*last)) {\\n            if (tolower(*first++) != tolower(*last--)) return false;\\n        }\\n        else {\\n            if (!isalnum(*first)) ++first;\\n            if (!isalnum(*last)) --last;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286942,
                "title": "c-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start one pointer from start of the string and one from end\\n- If the character is not alhpa numeric (alphabeth or number) skip it.\\n- if character matches go for next character else it is not a palindrome.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ (Traversing the string only once)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ (Constant space is used)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int start = 0, end = s.size()-1;\\n        while(start <= end){\\n            // lowercase the char\\n            char startChar =tolower(s[start]);\\n            char lastChar = tolower(s[end]);\\n\\n            // if not alpha numeric increase/decrement pointer respectiverly\\n            if(!isalnum(int(startChar))){\\n                start++;\\n                continue;\\n            }\\n            if(!isalnum(int(lastChar))){\\n                end--;\\n                continue;\\n            }\\n\\n            // if char match go for next char\\n            if(startChar==lastChar){\\n                start++;\\n                end--;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int start = 0, end = s.size()-1;\\n        while(start <= end){\\n            // lowercase the char\\n            char startChar =tolower(s[start]);\\n            char lastChar = tolower(s[end]);\\n\\n            // if not alpha numeric increase/decrement pointer respectiverly\\n            if(!isalnum(int(startChar))){\\n                start++;\\n                continue;\\n            }\\n            if(!isalnum(int(lastChar))){\\n                end--;\\n                continue;\\n            }\\n\\n            // if char match go for next char\\n            if(startChar==lastChar){\\n                start++;\\n                end--;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039149,
                "title": "typescript-beats-95-48-88-25",
                "content": "# Intuition\\nIterate through string and use two pointers(head && tail) to compare only letters and digits by ignoring unwanted charaters like spaces, commands, colons, etc.\\n\\n# Approach\\n- Lowercase the given string\\n- Iterate throught it\\n- While current letters(head & tail) is NOT alphanumeric, increase/decrease the corresponding pointers till they are alphanumeric. \\n- If we encounter two non-equal char codes, we immediately return false\\n\\nP.s.: Watch out for edge cases like \"., \", in that case the head will be greater than the string length returning iCode=NaN thus it would result in \"Infinite Loop\". Thus, if head === tail, we return \"true\" as everything before the head and after the tail is proved to be a palindrome.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nfunction isAlphanumeric(code: number) {\\n    // digits: 48-57\\n    // lowercase letters: 97-122 \\n    return ((code >= 48 && code <= 57) || (code >= 97 && code <= 122)) \\n}\\n\\nfunction isPalindrome(s: string): boolean {\\n    s = s.toLowerCase();\\n    let i = 0; \\n    let j = s.length - 1;\\n    while (i < j) {\\n        let iCode = s.charCodeAt(i);\\n        let jCode = s.charCodeAt(j);\\n\\n        while (!isAlphanumeric(iCode)) {\\n            i++\\n            if (i === j) return true\\n            iCode = s.charCodeAt(i);\\n        }\\n        while (!isAlphanumeric(jCode)) {\\n            j--\\n            if (i === j) return true\\n            jCode = s.charCodeAt(j);\\n        }\\n\\n        if (iCode !== jCode) return false\\n        \\n        i++\\n        j--\\n    }\\n\\n    return true\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isAlphanumeric(code: number) {\\n    // digits: 48-57\\n    // lowercase letters: 97-122 \\n    return ((code >= 48 && code <= 57) || (code >= 97 && code <= 122)) \\n}\\n\\nfunction isPalindrome(s: string): boolean {\\n    s = s.toLowerCase();\\n    let i = 0; \\n    let j = s.length - 1;\\n    while (i < j) {\\n        let iCode = s.charCodeAt(i);\\n        let jCode = s.charCodeAt(j);\\n\\n        while (!isAlphanumeric(iCode)) {\\n            i++\\n            if (i === j) return true\\n            iCode = s.charCodeAt(i);\\n        }\\n        while (!isAlphanumeric(jCode)) {\\n            j--\\n            if (i === j) return true\\n            jCode = s.charCodeAt(j);\\n        }\\n\\n        if (iCode !== jCode) return false\\n        \\n        i++\\n        j--\\n    }\\n\\n    return true\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2997843,
                "title": "one-pass-o-n-in-c-rust-go",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ as we are scanning the string once\\n\\n- Space complexity:\\n$$O(1)$$ as no additional container is used\\n\\n# Code in C++\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(const std::string s) {\\n        for (size_t i = 0, j = s.size() - 1; i < j; ++i, --j) {\\n            while (i < j && !std::isalnum(s[i]))\\n                ++i;\\n            while (i < j && !std::isalnum(s[j]))\\n                --j;\\n            if (i == j)\\n                break;\\n            if (std::tolower(s[i]) != std::tolower(s[j]))\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n# Code in Rust\\n```\\nimpl Solution {\\n    pub fn is_palindrome(s: String) -> bool {\\n        let iter = s.chars()\\n            .filter(|c| c.is_ascii_alphanumeric())\\n            .map(|c| c.to_ascii_lowercase());\\n        iter.clone().eq(iter.rev())\\n    }\\n}\\n```\\n\\n# Code in Go\\n```\\nfunc isPalindrome(s string) bool {\\n    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\\n        for i < j && !(unicode.IsLetter(rune(s[i])) || unicode.IsDigit(rune(s[i]))) {\\n            i++\\n        }\\n        for i < j && !(unicode.IsLetter(rune(s[j])) || unicode.IsDigit(rune(s[j]))) {\\n            j--\\n        }\\n        if i == j {\\n            break\\n        }\\n        if unicode.ToLower(rune(s[i])) != unicode.ToLower(rune(s[j])) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(const std::string s) {\\n        for (size_t i = 0, j = s.size() - 1; i < j; ++i, --j) {\\n            while (i < j && !std::isalnum(s[i]))\\n                ++i;\\n            while (i < j && !std::isalnum(s[j]))\\n                --j;\\n            if (i == j)\\n                break;\\n            if (std::tolower(s[i]) != std::tolower(s[j]))\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nimpl Solution {\\n    pub fn is_palindrome(s: String) -> bool {\\n        let iter = s.chars()\\n            .filter(|c| c.is_ascii_alphanumeric())\\n            .map(|c| c.to_ascii_lowercase());\\n        iter.clone().eq(iter.rev())\\n    }\\n}\\n```\n```\\nfunc isPalindrome(s string) bool {\\n    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\\n        for i < j && !(unicode.IsLetter(rune(s[i])) || unicode.IsDigit(rune(s[i]))) {\\n            i++\\n        }\\n        for i < j && !(unicode.IsLetter(rune(s[j])) || unicode.IsDigit(rune(s[j]))) {\\n            j--\\n        }\\n        if i == j {\\n            break\\n        }\\n        if unicode.ToLower(rune(s[i])) != unicode.ToLower(rune(s[j])) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933866,
                "title": "fast-two-pointers-solution-o-n-time",
                "content": "# Intuition\\nUse two pointers, one starting at the end of trimmed string and one starting at the beginning. While the pointer at the end minus the pointer at the beginning doesn\\'t equal zero, check to see if the chars in the trimmed string are the same.\\n\\n# Approach\\nFirst, take the original string, convert everything to lower case and send all the chars to a char array. Next, instantiate a stringbuilder to create the trimmed string that will be the possible palindrome. After that, iterate through the char array, checking at each position to see if the char is an alphanumeric. If it is, add it to the string builder. After that, initialize two ints to hold the pointer values. Then, use a while loop to increment the left pointer and decrement the right pointer while the difference between them does not equal one. Check at every step of the while loop to see if the char at the left pointer position is the same as the char at the right pointer position. If at any point they are not, return false. If the while loop completes without a false condition, return true.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n\\n        if (s.Length == 1 && char.IsLetterOrDigit(s[0]))\\n            return true;\\n\\n        char[] lowerChars = s.ToLower().ToCharArray();\\n        StringBuilder palinString = new StringBuilder();\\n\\n        foreach(char element in lowerChars)\\n        {\\n            if (char.IsLetterOrDigit(element))\\n            {\\n                palinString.Append(element);\\n            }\\n        }\\n        int rightPointer = palinString.Length - 1;\\n        int leftPointer = 0;\\n\\n        while (rightPointer - leftPointer > 0)\\n        {\\n            if (palinString[rightPointer] != palinString[leftPointer])\\n                return false;\\n            rightPointer -= 1;\\n            leftPointer += 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n\\n        if (s.Length == 1 && char.IsLetterOrDigit(s[0]))\\n            return true;\\n\\n        char[] lowerChars = s.ToLower().ToCharArray();\\n        StringBuilder palinString = new StringBuilder();\\n\\n        foreach(char element in lowerChars)\\n        {\\n            if (char.IsLetterOrDigit(element))\\n            {\\n                palinString.Append(element);\\n            }\\n        }\\n        int rightPointer = palinString.Length - 1;\\n        int leftPointer = 0;\\n\\n        while (rightPointer - leftPointer > 0)\\n        {\\n            if (palinString[rightPointer] != palinString[leftPointer])\\n                return false;\\n            rightPointer -= 1;\\n            leftPointer += 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773675,
                "title": "clean-python-code-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- 2 pointers solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- 2 pointers solution\\n- If 1 pointer isn\\'t alpha numerical, shift them left/right\\n- If both are alphanum: check\\n- return False if not the same\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        left, right = 0, len(s)-1\\n        while right > left:\\n            if not s[right].isalnum():\\n                right -= 1\\n                continue\\n            if not s[left].isalnum():\\n                left += 1\\n                continue\\n            if s[left].lower() != s[right].lower():\\n                return False\\n            right -= 1\\n            left += 1\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        left, right = 0, len(s)-1\\n        while right > left:\\n            if not s[right].isalnum():\\n                right -= 1\\n                continue\\n            if not s[left].isalnum():\\n                left += 1\\n                continue\\n            if s[left].lower() != s[right].lower():\\n                return False\\n            right -= 1\\n            left += 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542025,
                "title": "accepted-java-solution-563-ms",
                "content": "```\\npublic boolean isPalindrome(String s) {\\n        String s1 = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\\n        int len = s1.length();\\n        int start= 0;\\n        int end = len-1;\\n        while(start<end){\\n            if(s1.charAt(start) != s1.charAt(end)){\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\npublic boolean isPalindrome(String s) {\\n        String s1 = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\\n        int len = s1.length();\\n        int start= 0;\\n        int end = len-1;\\n        while(start<end){\\n            if(s1.charAt(start) != s1.charAt(end)){\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200064,
                "title": "simple-solution-easy-to-understand",
                "content": "1) remove all alphanumeric characters\\n2) convert all alpahbets into lower case\\n3) compare with help of 2 pointers just like in normal palindrome problem\\n```\\nbool isValid(char ch)\\n    {\\n        if ((ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'0\\' && ch <= \\'9\\') || (ch >= \\'A\\' && ch <= \\'Z\\'))\\n            return true;\\n            \\n        return false;\\n    }\\n    char tolowerCase(char ch)\\n    {\\n        if (ch>=\\'A\\' && ch <=\\'Z\\')\\n                ch = ch - \\'A\\' + \\'a\\';\\n        return ch;\\n    }\\n    bool isPalindrome(string s) {\\n        \\n        int n = 0;\\n        //faaltu characters pehle hi hatado\\n        for (int i = 0; i <s.length(); i++)\\n        {\\n            if (isValid(s[i]))\\n                {\\n                    s[n++] = s[i];\\n                }\\n        }\\n        //sabhi alpabets ko lower case me kardo\\n        for (int i = 0; i < n; i++)\\n        {\\n            s[i] = tolowerCase(s[i]);\\n        }\\n        //basic palindrome check karne wala function lagado\\n        int start = 0;\\n        int end = n - 1;\\n\\n        while (start <= end)\\n        {\\n            if (s[start] != s[end])\\n             return false;\\n            else\\n            {\\n                start++;\\n                end--;\\n            }\\n        }\\n    return true;\\n    }      \\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "1) remove all alphanumeric characters\\n2) convert all alpahbets into lower case\\n3) compare with help of 2 pointers just like in normal palindrome problem\\n```\\nbool isValid(char ch)\\n    {\\n        if ((ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'0\\' && ch <= \\'9\\') || (ch >= \\'A\\' && ch <= \\'Z\\'))\\n            return true;\\n            \\n        return false;\\n    }\\n    char tolowerCase(char ch)\\n    {\\n        if (ch>=\\'A\\' && ch <=\\'Z\\')\\n                ch = ch - \\'A\\' + \\'a\\';\\n        return ch;\\n    }\\n    bool isPalindrome(string s) {\\n        \\n        int n = 0;\\n        //faaltu characters pehle hi hatado\\n        for (int i = 0; i <s.length(); i++)\\n        {\\n            if (isValid(s[i]))\\n                {\\n                    s[n++] = s[i];\\n                }\\n        }\\n        //sabhi alpabets ko lower case me kardo\\n        for (int i = 0; i < n; i++)\\n        {\\n            s[i] = tolowerCase(s[i]);\\n        }\\n        //basic palindrome check karne wala function lagado\\n        int start = 0;\\n        int end = n - 1;\\n\\n        while (start <= end)\\n        {\\n            if (s[start] != s[end])\\n             return false;\\n            else\\n            {\\n                start++;\\n                end--;\\n            }\\n        }\\n    return true;\\n    }      \\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2016399,
                "title": "go-solution",
                "content": "```\\nfunc isPalindrome(s string) bool {\\n\\tstart, end := 0, len(s)-1\\n\\n\\tfor start < end {\\n\\t\\tfor start < end && !isAlphaNumeric(int(s[start])) {\\n\\t\\t\\tstart++\\n\\t\\t}\\n\\n\\t\\tfor start < end && !isAlphaNumeric(int(s[end])) {\\n\\t\\t\\tend--\\n\\t\\t}\\n\\n\\t\\tif strings.ToLower(string(s[start])) != strings.ToLower(string(s[end])) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tstart++\\n\\t\\tend--\\n\\t}\\n\\n\\treturn true\\n}\\n\\nfunc isAlphaNumeric(asciCode int) bool {\\n\\treturn (int(\\'a\\') <= asciCode && asciCode <= int(\\'z\\')) ||\\n\\t\\t(int(\\'A\\') <= asciCode && asciCode <= int(\\'Z\\')) ||\\n\\t\\t(int(\\'0\\') <= asciCode && asciCode <= int(\\'9\\'))\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```\\nfunc isPalindrome(s string) bool {\\n\\tstart, end := 0, len(s)-1\\n\\n\\tfor start < end {\\n\\t\\tfor start < end && !isAlphaNumeric(int(s[start])) {\\n\\t\\t\\tstart++\\n\\t\\t}\\n\\n\\t\\tfor start < end && !isAlphaNumeric(int(s[end])) {\\n\\t\\t\\tend--\\n\\t\\t}\\n\\n\\t\\tif strings.ToLower(string(s[start])) != strings.ToLower(string(s[end])) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tstart++\\n\\t\\tend--\\n\\t}\\n\\n\\treturn true\\n}\\n\\nfunc isAlphaNumeric(asciCode int) bool {\\n\\treturn (int(\\'a\\') <= asciCode && asciCode <= int(\\'z\\')) ||\\n\\t\\t(int(\\'A\\') <= asciCode && asciCode <= int(\\'Z\\')) ||\\n\\t\\t(int(\\'0\\') <= asciCode && asciCode <= int(\\'9\\'))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906125,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        StringBuilder v = new StringBuilder();\\n        \\n        for(int i = 0 ; i<s.length();i++){\\n           if((s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')||(s.charAt(i)>=\\'a\\'&& s.charAt(i)<=\\'z\\')                                                                                                         ||(s.charAt(i)>=\\'0\\'&&s.charAt(i)<=\\'9\\')){\\n                v.append(s.charAt(i));\\n        }\\n        }\\n             String v2=new String(v).toLowerCase();\\n        return sachMePalindromeHai(v2);\\n        \\n        \\n    \\n    }\\n    public boolean sachMePalindromeHai(String s){\\n        int survat = 0;\\n        int khatam = s.length()-1;\\n        while(survat<= khatam){\\n            if(s.charAt(survat)!=s.charAt(khatam)){\\n                return false;\\n            }\\n            survat++;\\n            khatam--;\\n        }\\n        return true;\\n    \\n    \\n}\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        StringBuilder v = new StringBuilder();\\n        \\n        for(int i = 0 ; i<s.length();i++){\\n           if((s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')||(s.charAt(i)>=\\'a\\'&& s.charAt(i)<=\\'z\\')                                                                                                         ||(s.charAt(i)>=\\'0\\'&&s.charAt(i)<=\\'9\\')){\\n                v.append(s.charAt(i));\\n        }\\n        }\\n             String v2=new String(v).toLowerCase();\\n        return sachMePalindromeHai(v2);\\n        \\n        \\n    \\n    }\\n    public boolean sachMePalindromeHai(String s){\\n        int survat = 0;\\n        int khatam = s.length()-1;\\n        while(survat<= khatam){\\n            if(s.charAt(survat)!=s.charAt(khatam)){\\n                return false;\\n            }\\n            survat++;\\n            khatam--;\\n        }\\n        return true;\\n    \\n    \\n}\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1717910,
                "title": "javascript-solution",
                "content": "Runtime: 105 ms, faster than 47.00% of JavaScript online submissions for Valid Palindrome.\\nMemory Usage: 40.6 MB, less than 85.77% of JavaScript online submissions for Valid Palindrome.\\n\\n```\\nvar isPalindrome = function(s) {\\n    s = s.replace(/[^A-Za-z0-9]/g, \\'\\').toLowerCase();\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] !== s[s.length - 1 - i]) return false;\\n    }\\n    return true;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(s) {\\n    s = s.replace(/[^A-Za-z0-9]/g, \\'\\').toLowerCase();\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] !== s[s.length - 1 - i]) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103108,
                "title": "java-simple-short-2ms-solution-beats-98",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        int start = 0, end = s.length()-1;\\n        while (start < end) {\\n            //advance until reach alphanumerical on both sides or pointers ovelap\\n            while (!Character.isLetterOrDigit(s.charAt(start)) && start < end) \\n                start++;\\n            while (!Character.isLetterOrDigit(s.charAt(end)) && start < end) \\n                end--;\\n            \\n            if (Character.toLowerCase(s.charAt(start)) != Character.toLowerCase(s.charAt(end)))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        int start = 0, end = s.length()-1;\\n        while (start < end) {\\n            //advance until reach alphanumerical on both sides or pointers ovelap\\n            while (!Character.isLetterOrDigit(s.charAt(start)) && start < end) \\n                start++;\\n            while (!Character.isLetterOrDigit(s.charAt(end)) && start < end) \\n                end--;\\n            \\n            if (Character.toLowerCase(s.charAt(start)) != Character.toLowerCase(s.charAt(end)))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935306,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s = \\'\\'.join(ch.lower() for ch in s if ch.isalnum())\\n        return s == s[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s = \\'\\'.join(ch.lower() for ch in s if ch.isalnum())\\n        return s == s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834437,
                "title": "java-simple-clean-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        // remove non-alphanumeric characters from string:\\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\");\\n        // use two pointers to compare:\\n        int left = 0;\\n        int right = s.length()-1;\\n        while (left < right) {\\n            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)))\\n                return false;\\n            left++;\\n            right--;  \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        // remove non-alphanumeric characters from string:\\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\");\\n        // use two pointers to compare:\\n        int left = 0;\\n        int right = s.length()-1;\\n        while (left < right) {\\n            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)))\\n                return false;\\n            left++;\\n            right--;  \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570249,
                "title": "python3-regex-two-lines",
                "content": "```\\nimport re\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      sanitized_string = re.sub(r\\'\\\\W+\\', \\'\\', s).lower()\\n      return sanitized_string == sanitized_string[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport re\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      sanitized_string = re.sub(r\\'\\\\W+\\', \\'\\', s).lower()\\n      return sanitized_string == sanitized_string[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342715,
                "title": "js-2-line-solution",
                "content": "```\\nvar isPalindrome = function(s) {\\n    s = s.toLowerCase().replace(/[^a-z0-9]/gi, \\'\\')\\n    return s.split(\\'\\').reverse().join(\\'\\') == s\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(s) {\\n    s = s.toLowerCase().replace(/[^a-z0-9]/gi, \\'\\')\\n    return s.split(\\'\\').reverse().join(\\'\\') == s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 321670,
                "title": "swift-e-z-solution-o-n-using-filter-front-to-back-czeching",
                "content": "```\\nclass Solution {\\n    func isPalindrome(_ s: String) -> Bool {\\n        var arr = Array(s.lowercased().filter(\"abcdefghijklmnopqrstuvwxyz0123456789\".contains))\\n        var start = 0\\n        var end = arr.count - 1\\n        while start < end {\\n            if arr[start] != arr[end] { return false }\\n            start += 1\\n            end -= 1\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func isPalindrome(_ s: String) -> Bool {\\n        var arr = Array(s.lowercased().filter(\"abcdefghijklmnopqrstuvwxyz0123456789\".contains))\\n        var start = 0\\n        var end = arr.count - 1\\n        while start < end {\\n            if arr[start] != arr[end] { return false }\\n            start += 1\\n            end -= 1\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289836,
                "title": "my-2-ms-solution-faster-than-99-37-of-java-online-submissions",
                "content": "O(n) runtime complexity and O(n) space complexity.\\n\\nTry to avoid using Java\\'s buildin methods like `String.charAt()` and `Character.isLetterOrDigit()` to improve performance.\\n\\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        if (s.isEmpty()) {\\n            return true;\\n        }\\n        char[] chars = s.toCharArray();\\n        int left = 0;\\n        int right = chars.length - 1;\\n        while (left < right) {\\n            while (!isAlphanumeric(chars[left])) {\\n                left++;\\n                if (left == right) {\\n                    return true;\\n                }\\n            }\\n\\n            while (!isAlphanumeric(chars[right])) {\\n                right--;\\n                if (left == right) {\\n                    return true;\\n                }\\n            }\\n\\n            if (lowerCase(chars[left]) != lowerCase(chars[right])) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isAlphanumeric(char c) {\\n        return \\'a\\' <= c && c <= \\'z\\'\\n            || \\'A\\' <= c && c <= \\'Z\\'\\n            || \\'0\\' <= c && c <= \\'9\\';\\n    }\\n\\n    private char lowerCase(char c) {\\n        return \\'A\\' <= c && c <= \\'Z\\' ? (char) (c - \\'A\\' + \\'a\\') : c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        if (s.isEmpty()) {\\n            return true;\\n        }\\n        char[] chars = s.toCharArray();\\n        int left = 0;\\n        int right = chars.length - 1;\\n        while (left < right) {\\n            while (!isAlphanumeric(chars[left])) {\\n                left++;\\n                if (left == right) {\\n                    return true;\\n                }\\n            }\\n\\n            while (!isAlphanumeric(chars[right])) {\\n                right--;\\n                if (left == right) {\\n                    return true;\\n                }\\n            }\\n\\n            if (lowerCase(chars[left]) != lowerCase(chars[right])) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isAlphanumeric(char c) {\\n        return \\'a\\' <= c && c <= \\'z\\'\\n            || \\'A\\' <= c && c <= \\'Z\\'\\n            || \\'0\\' <= c && c <= \\'9\\';\\n    }\\n\\n    private char lowerCase(char c) {\\n        return \\'A\\' <= c && c <= \\'Z\\' ? (char) (c - \\'A\\' + \\'a\\') : c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 120451,
                "title": "f-k-you-0p-lol",
                "content": "LOL, I don\\'t wanna talk anything about the code as the problem is very easy. What I wanna say is the freaking test case:\\n\\n```\\n\"0P\"\\n```\\n\\nIt did block me for quite a while. Finally I figured it out and slapped on my head. I felt like the author was laughing at me saying \\'Emmm silly, I just know...\\'.",
                "solutionTags": [],
                "code": "```\\n\"0P\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40149,
                "title": "9ms-c-short-solution",
                "content": "```\\n bool isPalindrome(string s) {\\n        if(s==\"\") return true;\\n        int i = 0, j = s.length()-1;\\n        while(i<j)\\n        {\\n            while(!isalnum(s[i])&&i<j) i++;\\n            while(!isalnum(s[j])&&j>i) j--;\\n            if(tolower(s[i++])!=tolower(s[j--])) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool isPalindrome(string s) {\\n        if(s==\"\") return true;\\n        int i = 0, j = s.length()-1;\\n        while(i<j)\\n        {\\n            while(!isalnum(s[i])&&i<j) i++;\\n            while(!isalnum(s[j])&&j>i) j--;\\n            if(tolower(s[i++])!=tolower(s[j--])) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40244,
                "title": "concise-c-solution",
                "content": "    public class Solution {\\n        public bool IsPalindrome(string s) {\\n            s = s.ToUpper();\\n            for(int l = 0, r = s.Length-1; l < r;){\\n                if(!char.IsLetterOrDigit(s[l])) l++;\\n                else if(!char.IsLetterOrDigit(s[r])) r--;\\n                else if(s[l++] != s[r--]) return false;\\n            }\\n            return true;    \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public bool IsPalindrome(string s) {\\n            s = s.ToUpper();\\n            for(int l = 0, r = s.Length-1; l < r;){\\n                if(!char.IsLetterOrDigit(s[l])) l++;\\n                else if(!char.IsLetterOrDigit(s[r])) r--;\\n                else if(s[l++] != s[r--]) return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 40320,
                "title": "6-lines-c-solution-4ms",
                "content": "    bool isPalindrome(char* s)\\n    {\\n      if(s==NULL || !strcmp(s,\"\")) return true;\\n    \\n      for(char* p = s + strlen(s) -1; p>s;)\\n        if(isalnum(*s) && isalnum(*p) && tolower(*(s++)) != tolower(*(p--))) return false;            \\n        else if(!isalnum(*s))  s++;\\n        else if(!isalnum(*p))  p--;\\n    \\n      return true;\\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "    bool isPalindrome(char* s)\\n    {\\n      if(s==NULL || !strcmp(s,\"\")) return true;\\n    \\n      for(char* p = s + strlen(s) -1; p>s;)\\n        if(isalnum(*s) && isalnum(*p) && tolower(*(s++)) != tolower(*(p--))) return false;            \\n        else if(!isalnum(*s))  s++;\\n        else if(!isalnum(*p))  p--;\\n    \\n      return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 40369,
                "title": "my-2-line-java-code",
                "content": "well, not counting the scaffolding ...\\n\\n        public class Solution {\\n        public boolean isPalindrome(String s) {\\n            String ss = s.toLowerCase().replaceAll(\"[^a-z0-9]\", \"\");\\n            return ss.equals(new StringBuilder(ss).reverse().toString());\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isPalindrome(String s) {\\n            String ss = s.toLowerCase().replaceAll(\"[^a-z0-9]\", \"\");\\n            return ss.equals(new StringBuilder(ss).reverse().toString());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3576698,
                "title": "simple-java-solution-step-by-step-explanation",
                "content": "# Approach\\nLet\\'s go through the code step by step:\\n\\n1. The code checks if a given string `s` is a palindrome, which means it reads the same forwards and backwards.\\n\\n2. It uses two pointers, `x` and `y`, which start from the beginning and end of the string, respectively.\\n\\n3. The code enters a loop that continues until the two pointers meet or cross each other.\\n\\n4. Inside the loop, it compares the characters at the `x`th and `y`th positions of the string.\\n\\n5. If the character at `x` is not a letter or digit, it means it\\'s a special character or whitespace. In this case, the pointer `x` moves to the next character, and the loop continues to the next iteration.\\n\\n6. Similarly, if the character at `y` is not a letter or digit, the pointer `y` moves to the previous character, and the loop continues.\\n\\n7. If both characters are valid alphanumeric characters, it compares them in a case-insensitive manner.\\n\\n8. If the characters are not equal, the string cannot be a palindrome, and the code returns `false`.\\n\\n9. If the characters are equal, it moves the pointers `x` and `y` closer to each other by incrementing `x` and decrementing `y`.\\n\\n10. Once the loop ends, it means all the characters have been compared successfully without any mismatches, and the code returns `true`, indicating that the string is a palindrome.\\n\\nIn simpler terms, the code checks if a string is a palindrome by comparing characters from the beginning and end of the string, ignoring special characters and considering case-insensitivity. If all characters match, it returns `true`; otherwise, it returns `false`.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        int x = 0;\\n        int y = s.length()-1;\\n        while (x<y){\\n            Character head = s.charAt(x);\\n            Character tail = s.charAt(y);\\n            if (!Character.isLetterOrDigit(head)){\\n                x++;\\n                continue;\\n            }\\n            if (!Character.isLetterOrDigit(tail)){\\n                y--;\\n                continue;\\n            }\\n            if (Character.toLowerCase(head) != Character.toLowerCase(tail)){\\n                return false;\\n            }\\n            x++;\\n            y--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n        int x = 0;\\n        int y = s.length()-1;\\n        while (x<y){\\n            Character head = s.charAt(x);\\n            Character tail = s.charAt(y);\\n            if (!Character.isLetterOrDigit(head)){\\n                x++;\\n                continue;\\n            }\\n            if (!Character.isLetterOrDigit(tail)){\\n                y--;\\n                continue;\\n            }\\n            if (Character.toLowerCase(head) != Character.toLowerCase(tail)){\\n                return false;\\n            }\\n            x++;\\n            y--;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484822,
                "title": "python-simple-and-beginner-friendly-different-solutions",
                "content": "# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = \\'\\' # initialize `a` variable with empty string\\n        for i in s: # iterate `s` in the for loop\\n            if i.isalnum(): # check if its `char` or not\\n                a+=i.lower() # store only `char` in a variable\\n        i =0 # initialize i =0 for starting word\\n        j =len(a)-1 # initialize i =0 for last word\\n        while i < j: \\n            if a[i] != a[j]: # if it\\'s not equle \\n                return False # than return it from this line\\n            i += 1 # if it\\'s equle increase `i`\\n            j -= 1 # and decrease `j`\\n        return True # if don\\'t work `return False` than it\\'s work\\n```\\n\\n\\nif it\\'s helpful to you plase upvote me..........................",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = \\'\\' # initialize `a` variable with empty string\\n        for i in s: # iterate `s` in the for loop\\n            if i.isalnum(): # check if its `char` or not\\n                a+=i.lower() # store only `char` in a variable\\n        i =0 # initialize i =0 for starting word\\n        j =len(a)-1 # initialize i =0 for last word\\n        while i < j: \\n            if a[i] != a[j]: # if it\\'s not equle \\n                return False # than return it from this line\\n            i += 1 # if it\\'s equle increase `i`\\n            j -= 1 # and decrease `j`\\n        return True # if don\\'t work `return False` than it\\'s work\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451411,
                "title": "easiest-c-solution-beats-91-8",
                "content": "# Intuition\\nThis is a C++ code for checking if a given string s is a palindrome or not. A palindrome is a string that reads the same forward as backward, ignoring spaces, punctuation, and capitalization.\\n\\n\\n# Approach\\nThe approach taken in this code is to create a new string newstring that contains only alphanumeric characters and all lowercase. This is done by iterating over each character of the input string s, and checking if it is an uppercase letter, lowercase letter, or a number. If it is an uppercase letter, it is converted to lowercase using ASCII value manipulation and then added to newstring. If it is a lowercase letter or a number, it is added to newstring directly. Any other character is ignored.\\n\\nAfter the new string newstring is created, the code uses two pointers, i and j, that start from the beginning and end of newstring respectively. It then iterates over the string until the pointers meet at the middle. At each iteration, it checks if the characters at i and j are equal. If they are not, it means that the string is not a palindrome and false is returned. If they are equal, the pointers are moved one step closer to the middle of the string. If the pointers meet in the middle of the string without finding any unequal characters, the string is a palindrome and true is returned.\\n\\nNote that the code includes a cout statement to print the newstring to the console, which can be used for debugging purposes.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string newstring;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] >= 65 && s[i] <= 90) {\\n                newstring.push_back(s[i] + 32);\\n            } \\n            else if(s[i] >= 97 && s[i] <= 122) {\\n                newstring.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                newstring.push_back(s[i]);\\n            }\\n        }\\n        cout << newstring;\\n        int i = 0, j = newstring.length() - 1;\\n        while(i <= j) {\\n            if(newstring[i] != newstring[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string newstring;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] >= 65 && s[i] <= 90) {\\n                newstring.push_back(s[i] + 32);\\n            } \\n            else if(s[i] >= 97 && s[i] <= 122) {\\n                newstring.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                newstring.push_back(s[i]);\\n            }\\n        }\\n        cout << newstring;\\n        int i = 0, j = newstring.length() - 1;\\n        while(i <= j) {\\n            if(newstring[i] != newstring[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1567287,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1569417,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1576700,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1574106,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1571830,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1847282,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1569767,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1569724,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1571994,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1566748,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1567287,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1569417,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1576700,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1574106,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1571830,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1847282,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1569767,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1569724,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1571994,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1566748,
                "content": [
                    {
                        "username": "akshaybapat04",
                        "content": "One of the testcases seems to be wrong ![0_1515207918122_Capture.JPG](/assets/uploads/files/1515207917534-capture.jpg)\\nAnd no, that's not OP; it's 0P (Zero-P)."
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "The description said alphanumeric stays so letter(alpha) and number(numeric) is fine. "
                    },
                    {
                        "username": "aspwell520",
                        "content": "Even we count 0~9 into consideration, could anyone answer me why 0P / P0 is palindrome?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "[@Pritam96](/Pritam96)  write  0 and 9 in single quotes like this if (s[i]>=\\'0\\' &&  s[i]<=\\'9\\')  "
                    },
                    {
                        "username": "Django3",
                        "content": "Bullshit"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@omkarkumar](/omkarkumar) thank you"
                    },
                    {
                        "username": "SortedApe",
                        "content": " I think that it\\'s because of \\'P\\' -32 == \\'0\\'"
                    },
                    {
                        "username": "Pritam96",
                        "content": "[@user1734P](/user1734P) Thanks a lot for the discussion "
                    },
                    {
                        "username": "user1734P",
                        "content": "I know this is an old comment but to help those who are confused. \\n\\nThe question specifies alphanumerical characters are included so numbers (0 to 9) are allowed in the string.\\n\\nIf you try to check 0P (Zero-P) is palidrone by reversing the string it will become P0 (P-Zero).  You\\'ll find that 0P is NOT EQUAL to P0, therefore it\\'s not a palindrone and should return false.\\n\\nAnother example is L0L (L-Zero-L), this is considered a palindrome and should return true."
                    },
                    {
                        "username": "aman_manik",
                        "content": "mine too\\uD83D\\uDE22"
                    },
                    {
                        "username": "hemantd369",
                        "content": "its alphanumeric which means string can be combinaton of character a to z and digits 0 to 9."
                    },
                    {
                        "username": "user1046K",
                        "content": "It isn\\'t wrong. The prompt says that you only remove non-alphanumeric characters. Alphanumeric characters include both letters and numbers."
                    },
                    {
                        "username": "segfal",
                        "content": "yea it caught me too, it is alpha numeric, not just alpha"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Gotta read the problem thoroughly !"
                    },
                    {
                        "username": "klearner_051",
                        "content": "you haven\\'t considered 0 as a valid character"
                    },
                    {
                        "username": "meirbnb",
                        "content": "alphanumeric.."
                    },
                    {
                        "username": "sue-may",
                        "content": "Why \".a\" return true and \"0P\" return false? Thanks for explain it."
                    },
                    {
                        "username": "Braderbell",
                        "content": "[@omkarkumar](/omkarkumar) well, that was an easy fix... just had to change 2 method calls from .isalpha() to .isalnum() thanks for the answer"
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "pnithinc",
                        "content": "I am sure you definitely found the answer for this, but still posting the answer for this so that someone with the same query gets it clarified.\\nThe \".\" in \".a\" is not alphanumeric, hence on its removal, we have \"a\" which will be a palindrome by itself.\\nThe \"0\" in \"0P\" is an alphanumeric character, we cant remove this 0 during our palindrome checking, this makes the output as false."
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "For this input : \\n\"0P\"\\nHow come the expected answer is false ? Removing 0 the string will becomes P converting to uppercase or lower case any way it\\'s a single character. And a single character is read same as forward and backwards. And hence it\\'s palindrome.\\nSo why the expected answer is false ?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\uD83D\\uDD25 \\uD83D\\uDD25 2 Line Code ||  \\uD83D\\uDE0E\\uD83D\\uDE0E challenge: Can you write the code in One line|| biggner friendly\\n\\nhttps://leetcode.com/problems/valid-palindrome/solutions/4024790/2-line-code-challenge-can-you-write-the-code-in-one-line-biggner-friendly/"
                    },
                    {
                        "username": "DatSudo",
                        "content": "Read the description carefully. It says \"alpha[numeric]\"."
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "In the question, its mentioned to remove the non-alphanumeric characters before checking if it is palindrome. So, we need to keep alphanumeric characters which are numbers and alphabets.  Except numbers and alphabets, other characters should be removed.\\n\\nif the input is 0P its reversed string will be P0 which is obviously not a palindrome. hence, its expected answer will be false."
                    },
                    {
                        "username": "AmmanChhetri",
                        "content": "it\\'s because . is not considered as alphanumeric\\nremember alphanumeric = alphabets + numbers\\n"
                    },
                    {
                        "username": "taoge0110",
                        "content": "The diff of ASCII code for \\'0\\' and \\'P\\' is 32, which is exactly the diff between the upper case and lower case, and it\\'s said we don\\'t need to think about the capitalization in the description, which hints us to just use the ASCII code. However, it doesn\\'t work when numbers are included...... "
                    },
                    {
                        "username": "omkarkumar",
                        "content": "in problem it clearly mentioned \"Alphanumeric characters include letters and numbers.\" so please consider 0 as an alphanumeric character.\\n"
                    },
                    {
                        "username": "djerril",
                        "content": "use .isalnum() instead of .isalpha() for correct result"
                    },
                    {
                        "username": "pnithinc",
                        "content": "It did spin my head around for a while too, but since the requirement is to keep all the alphanumeric characters, we can\\'t remove the 0."
                    },
                    {
                        "username": "Light_7",
                        "content": "its a valid string if it is alphanumeric no need to remove \\'0\\'"
                    },
                    {
                        "username": "seanxu889",
                        "content": "If you got problems like: 0P, 1Q, 2R, 3S... It could because you are using \"abs(temp[i] - temp[j]) == 32\" to ignore the letter case.\\n\\nBe careful about the ASCII table, because not only \\'a\\'-\\'A\\' == 32, but also \\'P\\'-\\'0\\' == 32. \\n\\nA good way to avoid problems like this is to use \"toupper(temp[i]) == toupper(temp[j])\"\\n![image](https://assets.leetcode.com/users/images/0f73349d-efa2-4d56-b6a4-f63ac6b581fa_1595702988.6429648.png)\\n"
                    },
                    {
                        "username": "ro0k1e",
                        "content": "0P is very good example"
                    },
                    {
                        "username": "keba",
                        "content": "Read the question carefully , It also includes number so when you create your new array it should also has a number "
                    },
                    {
                        "username": "surya20",
                        "content": "Shouldn\\'t \"0P\" be a valid palindrome considering only aphanumeric characters? But the test case says it is false. Please help."
                    },
                    {
                        "username": "bijendraut",
                        "content": "Read about ASCII"
                    },
                    {
                        "username": "aayushmalviya",
                        "content": "aphanumeric character is 0 to 9 and all the letter of alphabet\\nserch on google alphanumeric character"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "alpha \"NUMERIC\"...."
                    },
                    {
                        "username": "shivani_sharma",
                        "content": "Why could I be getting this error again an again\\n[![image](https://assets.leetcode.com/users/shivani_sharma/image_1577605858.png)\\n]"
                    },
                    {
                        "username": "jerryy147",
                        "content": "[@SweetBano](/SweetBano) isn\\'t that time limit exceeded? this is runtime error"
                    },
                    {
                        "username": "SweetBano",
                        "content": "Because your solution is to slow (takes too much time to give an answer), It could be because of an infinite loop, for example"
                    },
                    {
                        "username": "iamnwi",
                        "content": "A testcase containing non-alphanumeric characters such as \".../-..\\\\\" brings an error to the leetcode\\'s standard code."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "if we see in this way,he clearly mentiomed in the problem to remove only alphanumeric characters...so dont think about it...!"
                    },
                    {
                        "username": "stellari",
                        "content": "For Java, I assume using StringBuilder.reverse() rather than a loop would make the code shorter and readable. However, is that usually allowed for an interview question like this?"
                    },
                    {
                        "username": "davidtn",
                        "content": "This is 9 years late but, interviewers want to see that you understand code. Running a single line is generally an insult to them and showcases nothing."
                    },
                    {
                        "username": "davidtn",
                        "content": "[@AshutoshSingh10](/AshutoshSingh10) which operation is O(1)? The whole solution is O(n), so might doing .reverse(), where did you get O(1)?\\n\\n"
                    },
                    {
                        "username": "Varunn_027",
                        "content": "I guess its not allowed"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "By doing that you will increase time complexity from  O(1) to O(n) .\\nWell in interview  , this is allowed ( as they will be busy to judge bigger problems) ."
                    }
                ]
            },
            {
                "id": 1571831,
                "content": [
                    {
                        "username": "mitesh1612",
                        "content": "Can somebody clarify the question more as the test cases are creating some doubt!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "the question is simple as in this question we have to check for palindrome considering upper and lower case as same and simultaneously removing  special characters from space to double inverted comma .\\n\\nhope I able to explain >>>>"
                    },
                    {
                        "username": "Qichen_Gu",
                        "content": "The test case 0P (zero P) shows that digits are considered for checking a palindrome)."
                    },
                    {
                        "username": "gabbar0101",
                        "content": "How can \"0P\" be a pallindrome?\\nas in my opinion \"0P\\' != \"P0\"\\n"
                    },
                    {
                        "username": "ChinmayKadam172",
                        "content": "The question reads that you only have to consider lower and upper case characters\\nand not numbers so zero is ignored so the string becomes \"P\""
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "well the string dont contain number so it will be P and P\\nand it is low case so it is p and p is it the same\\n"
                    },
                    {
                        "username": "harshalyeole",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstring comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lowecase the string\\n2. Remove all the spaces and other chars, make it alpha numeric\\n3. store the new string\\n4. reverse the string\\n5. compare reverse string and new string\\n6. return comparison output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n86 ms\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n15.3 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # replcedstr = \\'\\'.join(e for e in s if e.isalnum()).lower()\\n        replcedstr = re.sub(\\'[^A-Za-z0-9]+\\', \\'\\', s).lower()\\n        return replcedstr[::-1] == replcedstr\\n        \\n```"
                    },
                    {
                        "username": "elzazo",
                        "content": "Time complexity is about how many comparison you do...I\\'m guessing O(5/2N) (N times to evaluate a character to replace it with lower case, N times to remove a non alpha numeric character and N/2 comparisons on the return statement). Still O(N) but high. Space complexity...it depends if a new string is created on the sub method and the lower method. If it\\'s not you algo does not waste unnecessary memory. Complexity is not about raw times and spaces but it\\'s an estimation about CPU time and memory space on theoretically infinite input."
                    },
                    {
                        "username": "Abhilash_Vadnala",
                        "content": "![image](https://assets.leetcode.com/users/abhilash_vadnala/image_1582190398.png)\\n"
                    },
                    {
                        "username": "jules3in",
                        "content": "It says \"considering only alphanumeric characters and ignoring cases\".\\n\\nAmong the test cases, \"a.\" is considered `true` while \"0P\" is considered `false`.\\n\\nDid I miss something in the description? Would anyone explain the details?\\n\\nThank you very much!"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "ignore the other character except:- alpahabet and numbers."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This question don\\'t deserve 8k downvotes"
                    },
                    {
                        "username": "kulkarniprajakta2612",
                        "content": "Case 1 is failing in editor but its working in VS. Can you please help me.\\n\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        bool isPalindrome = true;\\n            StringBuilder result = new StringBuilder();\\n\\n            // Iterate through each character in the input string\\n            foreach (char c in s)\\n            {\\n                if (char.IsLetter(c) || char.IsDigit(c))\\n                {\\n                    // Append the character to the result if it\\'s a letter or digit\\n                    result.Append(c);\\n                }\\n            }\\n            string str = result.ToString().ToLower();\\n            int len = str.Length-1;\\n            int i = 0;\\n            while (i < len / 2)\\n            {\\n                if (str[i] == str[len-1])\\n                {\\n                    i++;\\n                    len--;\\n                }\\n                else\\n                {\\n                    isPalindrome = false;\\n                    break;\\n                }\\n\\n            }\\n            return isPalindrome;\\n    }\\n}"
                    },
                    {
                        "username": "Akshay_Sodhi",
                        "content": "same issue"
                    },
                    {
                        "username": "hemantd369",
                        "content": "hey folks!!\\nEveryone misunderstood the question...\\nQue states that we have to check the alpha-numeric string which means string contains combination of characters from a to z and 0 to 9.\\nE.g.\\nab-01$$0ba\\nThe above string would reduced to ab010ba which is palindrome.\\nAnswer is true for ab-01$$0ba.\\n\\nE.g. \\n0P\\nThe above string is already is in reduced form.\\nIts answer is false because 0P is not palindrome.\\n\\nE.g. \\n0P0\\nIts answer is true as it is a palindrome.\\n"
                    },
                    {
                        "username": "hemantd369",
                        "content": "[@pawansharma9115078358](/pawansharma9115078358)  \"abb\" is not a palindrome because from backward it reads \"bba\" so clearly it is not. \"aba\" is a palindrome"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "tell me that if \"abb\" is palidrome or not . Because The expected output is showing false how?"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "class Solution:\\n     def isPalindrome(self,s:str) -> bool:\\n        import re \\n        s = re.sub(r\\'[\\\\W_]\\', \\'\\', s).lower()\\n        new_str = \\'\\'\\n\\n        for i in reversed(range(len(s))):\\n            new_str += s[i]\\n\\n        return new_str == s \\nwhat am i doing wrong here i dont get im getting a syntax error!!!!"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "You don\\'t have to do a for loop, just make a s == s[::-1]\\n"
                    },
                    {
                        "username": "Shag-Foal",
                        "content": "use equals()"
                    }
                ]
            },
            {
                "id": 1571261,
                "content": [
                    {
                        "username": "mitesh1612",
                        "content": "Can somebody clarify the question more as the test cases are creating some doubt!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "the question is simple as in this question we have to check for palindrome considering upper and lower case as same and simultaneously removing  special characters from space to double inverted comma .\\n\\nhope I able to explain >>>>"
                    },
                    {
                        "username": "Qichen_Gu",
                        "content": "The test case 0P (zero P) shows that digits are considered for checking a palindrome)."
                    },
                    {
                        "username": "gabbar0101",
                        "content": "How can \"0P\" be a pallindrome?\\nas in my opinion \"0P\\' != \"P0\"\\n"
                    },
                    {
                        "username": "ChinmayKadam172",
                        "content": "The question reads that you only have to consider lower and upper case characters\\nand not numbers so zero is ignored so the string becomes \"P\""
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "well the string dont contain number so it will be P and P\\nand it is low case so it is p and p is it the same\\n"
                    },
                    {
                        "username": "harshalyeole",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstring comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lowecase the string\\n2. Remove all the spaces and other chars, make it alpha numeric\\n3. store the new string\\n4. reverse the string\\n5. compare reverse string and new string\\n6. return comparison output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n86 ms\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n15.3 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # replcedstr = \\'\\'.join(e for e in s if e.isalnum()).lower()\\n        replcedstr = re.sub(\\'[^A-Za-z0-9]+\\', \\'\\', s).lower()\\n        return replcedstr[::-1] == replcedstr\\n        \\n```"
                    },
                    {
                        "username": "elzazo",
                        "content": "Time complexity is about how many comparison you do...I\\'m guessing O(5/2N) (N times to evaluate a character to replace it with lower case, N times to remove a non alpha numeric character and N/2 comparisons on the return statement). Still O(N) but high. Space complexity...it depends if a new string is created on the sub method and the lower method. If it\\'s not you algo does not waste unnecessary memory. Complexity is not about raw times and spaces but it\\'s an estimation about CPU time and memory space on theoretically infinite input."
                    },
                    {
                        "username": "Abhilash_Vadnala",
                        "content": "![image](https://assets.leetcode.com/users/abhilash_vadnala/image_1582190398.png)\\n"
                    },
                    {
                        "username": "jules3in",
                        "content": "It says \"considering only alphanumeric characters and ignoring cases\".\\n\\nAmong the test cases, \"a.\" is considered `true` while \"0P\" is considered `false`.\\n\\nDid I miss something in the description? Would anyone explain the details?\\n\\nThank you very much!"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "ignore the other character except:- alpahabet and numbers."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This question don\\'t deserve 8k downvotes"
                    },
                    {
                        "username": "kulkarniprajakta2612",
                        "content": "Case 1 is failing in editor but its working in VS. Can you please help me.\\n\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        bool isPalindrome = true;\\n            StringBuilder result = new StringBuilder();\\n\\n            // Iterate through each character in the input string\\n            foreach (char c in s)\\n            {\\n                if (char.IsLetter(c) || char.IsDigit(c))\\n                {\\n                    // Append the character to the result if it\\'s a letter or digit\\n                    result.Append(c);\\n                }\\n            }\\n            string str = result.ToString().ToLower();\\n            int len = str.Length-1;\\n            int i = 0;\\n            while (i < len / 2)\\n            {\\n                if (str[i] == str[len-1])\\n                {\\n                    i++;\\n                    len--;\\n                }\\n                else\\n                {\\n                    isPalindrome = false;\\n                    break;\\n                }\\n\\n            }\\n            return isPalindrome;\\n    }\\n}"
                    },
                    {
                        "username": "Akshay_Sodhi",
                        "content": "same issue"
                    },
                    {
                        "username": "hemantd369",
                        "content": "hey folks!!\\nEveryone misunderstood the question...\\nQue states that we have to check the alpha-numeric string which means string contains combination of characters from a to z and 0 to 9.\\nE.g.\\nab-01$$0ba\\nThe above string would reduced to ab010ba which is palindrome.\\nAnswer is true for ab-01$$0ba.\\n\\nE.g. \\n0P\\nThe above string is already is in reduced form.\\nIts answer is false because 0P is not palindrome.\\n\\nE.g. \\n0P0\\nIts answer is true as it is a palindrome.\\n"
                    },
                    {
                        "username": "hemantd369",
                        "content": "[@pawansharma9115078358](/pawansharma9115078358)  \"abb\" is not a palindrome because from backward it reads \"bba\" so clearly it is not. \"aba\" is a palindrome"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "tell me that if \"abb\" is palidrome or not . Because The expected output is showing false how?"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "class Solution:\\n     def isPalindrome(self,s:str) -> bool:\\n        import re \\n        s = re.sub(r\\'[\\\\W_]\\', \\'\\', s).lower()\\n        new_str = \\'\\'\\n\\n        for i in reversed(range(len(s))):\\n            new_str += s[i]\\n\\n        return new_str == s \\nwhat am i doing wrong here i dont get im getting a syntax error!!!!"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "You don\\'t have to do a for loop, just make a s == s[::-1]\\n"
                    },
                    {
                        "username": "Shag-Foal",
                        "content": "use equals()"
                    }
                ]
            },
            {
                "id": 1882770,
                "content": [
                    {
                        "username": "mitesh1612",
                        "content": "Can somebody clarify the question more as the test cases are creating some doubt!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "the question is simple as in this question we have to check for palindrome considering upper and lower case as same and simultaneously removing  special characters from space to double inverted comma .\\n\\nhope I able to explain >>>>"
                    },
                    {
                        "username": "Qichen_Gu",
                        "content": "The test case 0P (zero P) shows that digits are considered for checking a palindrome)."
                    },
                    {
                        "username": "gabbar0101",
                        "content": "How can \"0P\" be a pallindrome?\\nas in my opinion \"0P\\' != \"P0\"\\n"
                    },
                    {
                        "username": "ChinmayKadam172",
                        "content": "The question reads that you only have to consider lower and upper case characters\\nand not numbers so zero is ignored so the string becomes \"P\""
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "well the string dont contain number so it will be P and P\\nand it is low case so it is p and p is it the same\\n"
                    },
                    {
                        "username": "harshalyeole",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstring comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lowecase the string\\n2. Remove all the spaces and other chars, make it alpha numeric\\n3. store the new string\\n4. reverse the string\\n5. compare reverse string and new string\\n6. return comparison output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n86 ms\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n15.3 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # replcedstr = \\'\\'.join(e for e in s if e.isalnum()).lower()\\n        replcedstr = re.sub(\\'[^A-Za-z0-9]+\\', \\'\\', s).lower()\\n        return replcedstr[::-1] == replcedstr\\n        \\n```"
                    },
                    {
                        "username": "elzazo",
                        "content": "Time complexity is about how many comparison you do...I\\'m guessing O(5/2N) (N times to evaluate a character to replace it with lower case, N times to remove a non alpha numeric character and N/2 comparisons on the return statement). Still O(N) but high. Space complexity...it depends if a new string is created on the sub method and the lower method. If it\\'s not you algo does not waste unnecessary memory. Complexity is not about raw times and spaces but it\\'s an estimation about CPU time and memory space on theoretically infinite input."
                    },
                    {
                        "username": "Abhilash_Vadnala",
                        "content": "![image](https://assets.leetcode.com/users/abhilash_vadnala/image_1582190398.png)\\n"
                    },
                    {
                        "username": "jules3in",
                        "content": "It says \"considering only alphanumeric characters and ignoring cases\".\\n\\nAmong the test cases, \"a.\" is considered `true` while \"0P\" is considered `false`.\\n\\nDid I miss something in the description? Would anyone explain the details?\\n\\nThank you very much!"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "ignore the other character except:- alpahabet and numbers."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This question don\\'t deserve 8k downvotes"
                    },
                    {
                        "username": "kulkarniprajakta2612",
                        "content": "Case 1 is failing in editor but its working in VS. Can you please help me.\\n\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        bool isPalindrome = true;\\n            StringBuilder result = new StringBuilder();\\n\\n            // Iterate through each character in the input string\\n            foreach (char c in s)\\n            {\\n                if (char.IsLetter(c) || char.IsDigit(c))\\n                {\\n                    // Append the character to the result if it\\'s a letter or digit\\n                    result.Append(c);\\n                }\\n            }\\n            string str = result.ToString().ToLower();\\n            int len = str.Length-1;\\n            int i = 0;\\n            while (i < len / 2)\\n            {\\n                if (str[i] == str[len-1])\\n                {\\n                    i++;\\n                    len--;\\n                }\\n                else\\n                {\\n                    isPalindrome = false;\\n                    break;\\n                }\\n\\n            }\\n            return isPalindrome;\\n    }\\n}"
                    },
                    {
                        "username": "Akshay_Sodhi",
                        "content": "same issue"
                    },
                    {
                        "username": "hemantd369",
                        "content": "hey folks!!\\nEveryone misunderstood the question...\\nQue states that we have to check the alpha-numeric string which means string contains combination of characters from a to z and 0 to 9.\\nE.g.\\nab-01$$0ba\\nThe above string would reduced to ab010ba which is palindrome.\\nAnswer is true for ab-01$$0ba.\\n\\nE.g. \\n0P\\nThe above string is already is in reduced form.\\nIts answer is false because 0P is not palindrome.\\n\\nE.g. \\n0P0\\nIts answer is true as it is a palindrome.\\n"
                    },
                    {
                        "username": "hemantd369",
                        "content": "[@pawansharma9115078358](/pawansharma9115078358)  \"abb\" is not a palindrome because from backward it reads \"bba\" so clearly it is not. \"aba\" is a palindrome"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "tell me that if \"abb\" is palidrome or not . Because The expected output is showing false how?"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "class Solution:\\n     def isPalindrome(self,s:str) -> bool:\\n        import re \\n        s = re.sub(r\\'[\\\\W_]\\', \\'\\', s).lower()\\n        new_str = \\'\\'\\n\\n        for i in reversed(range(len(s))):\\n            new_str += s[i]\\n\\n        return new_str == s \\nwhat am i doing wrong here i dont get im getting a syntax error!!!!"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "You don\\'t have to do a for loop, just make a s == s[::-1]\\n"
                    },
                    {
                        "username": "Shag-Foal",
                        "content": "use equals()"
                    }
                ]
            },
            {
                "id": 1673335,
                "content": [
                    {
                        "username": "mitesh1612",
                        "content": "Can somebody clarify the question more as the test cases are creating some doubt!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "the question is simple as in this question we have to check for palindrome considering upper and lower case as same and simultaneously removing  special characters from space to double inverted comma .\\n\\nhope I able to explain >>>>"
                    },
                    {
                        "username": "Qichen_Gu",
                        "content": "The test case 0P (zero P) shows that digits are considered for checking a palindrome)."
                    },
                    {
                        "username": "gabbar0101",
                        "content": "How can \"0P\" be a pallindrome?\\nas in my opinion \"0P\\' != \"P0\"\\n"
                    },
                    {
                        "username": "ChinmayKadam172",
                        "content": "The question reads that you only have to consider lower and upper case characters\\nand not numbers so zero is ignored so the string becomes \"P\""
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "well the string dont contain number so it will be P and P\\nand it is low case so it is p and p is it the same\\n"
                    },
                    {
                        "username": "harshalyeole",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstring comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lowecase the string\\n2. Remove all the spaces and other chars, make it alpha numeric\\n3. store the new string\\n4. reverse the string\\n5. compare reverse string and new string\\n6. return comparison output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n86 ms\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n15.3 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # replcedstr = \\'\\'.join(e for e in s if e.isalnum()).lower()\\n        replcedstr = re.sub(\\'[^A-Za-z0-9]+\\', \\'\\', s).lower()\\n        return replcedstr[::-1] == replcedstr\\n        \\n```"
                    },
                    {
                        "username": "elzazo",
                        "content": "Time complexity is about how many comparison you do...I\\'m guessing O(5/2N) (N times to evaluate a character to replace it with lower case, N times to remove a non alpha numeric character and N/2 comparisons on the return statement). Still O(N) but high. Space complexity...it depends if a new string is created on the sub method and the lower method. If it\\'s not you algo does not waste unnecessary memory. Complexity is not about raw times and spaces but it\\'s an estimation about CPU time and memory space on theoretically infinite input."
                    },
                    {
                        "username": "Abhilash_Vadnala",
                        "content": "![image](https://assets.leetcode.com/users/abhilash_vadnala/image_1582190398.png)\\n"
                    },
                    {
                        "username": "jules3in",
                        "content": "It says \"considering only alphanumeric characters and ignoring cases\".\\n\\nAmong the test cases, \"a.\" is considered `true` while \"0P\" is considered `false`.\\n\\nDid I miss something in the description? Would anyone explain the details?\\n\\nThank you very much!"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "ignore the other character except:- alpahabet and numbers."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This question don\\'t deserve 8k downvotes"
                    },
                    {
                        "username": "kulkarniprajakta2612",
                        "content": "Case 1 is failing in editor but its working in VS. Can you please help me.\\n\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        bool isPalindrome = true;\\n            StringBuilder result = new StringBuilder();\\n\\n            // Iterate through each character in the input string\\n            foreach (char c in s)\\n            {\\n                if (char.IsLetter(c) || char.IsDigit(c))\\n                {\\n                    // Append the character to the result if it\\'s a letter or digit\\n                    result.Append(c);\\n                }\\n            }\\n            string str = result.ToString().ToLower();\\n            int len = str.Length-1;\\n            int i = 0;\\n            while (i < len / 2)\\n            {\\n                if (str[i] == str[len-1])\\n                {\\n                    i++;\\n                    len--;\\n                }\\n                else\\n                {\\n                    isPalindrome = false;\\n                    break;\\n                }\\n\\n            }\\n            return isPalindrome;\\n    }\\n}"
                    },
                    {
                        "username": "Akshay_Sodhi",
                        "content": "same issue"
                    },
                    {
                        "username": "hemantd369",
                        "content": "hey folks!!\\nEveryone misunderstood the question...\\nQue states that we have to check the alpha-numeric string which means string contains combination of characters from a to z and 0 to 9.\\nE.g.\\nab-01$$0ba\\nThe above string would reduced to ab010ba which is palindrome.\\nAnswer is true for ab-01$$0ba.\\n\\nE.g. \\n0P\\nThe above string is already is in reduced form.\\nIts answer is false because 0P is not palindrome.\\n\\nE.g. \\n0P0\\nIts answer is true as it is a palindrome.\\n"
                    },
                    {
                        "username": "hemantd369",
                        "content": "[@pawansharma9115078358](/pawansharma9115078358)  \"abb\" is not a palindrome because from backward it reads \"bba\" so clearly it is not. \"aba\" is a palindrome"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "tell me that if \"abb\" is palidrome or not . Because The expected output is showing false how?"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "class Solution:\\n     def isPalindrome(self,s:str) -> bool:\\n        import re \\n        s = re.sub(r\\'[\\\\W_]\\', \\'\\', s).lower()\\n        new_str = \\'\\'\\n\\n        for i in reversed(range(len(s))):\\n            new_str += s[i]\\n\\n        return new_str == s \\nwhat am i doing wrong here i dont get im getting a syntax error!!!!"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "You don\\'t have to do a for loop, just make a s == s[::-1]\\n"
                    },
                    {
                        "username": "Shag-Foal",
                        "content": "use equals()"
                    }
                ]
            },
            {
                "id": 1573459,
                "content": [
                    {
                        "username": "mitesh1612",
                        "content": "Can somebody clarify the question more as the test cases are creating some doubt!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "the question is simple as in this question we have to check for palindrome considering upper and lower case as same and simultaneously removing  special characters from space to double inverted comma .\\n\\nhope I able to explain >>>>"
                    },
                    {
                        "username": "Qichen_Gu",
                        "content": "The test case 0P (zero P) shows that digits are considered for checking a palindrome)."
                    },
                    {
                        "username": "gabbar0101",
                        "content": "How can \"0P\" be a pallindrome?\\nas in my opinion \"0P\\' != \"P0\"\\n"
                    },
                    {
                        "username": "ChinmayKadam172",
                        "content": "The question reads that you only have to consider lower and upper case characters\\nand not numbers so zero is ignored so the string becomes \"P\""
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "well the string dont contain number so it will be P and P\\nand it is low case so it is p and p is it the same\\n"
                    },
                    {
                        "username": "harshalyeole",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstring comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lowecase the string\\n2. Remove all the spaces and other chars, make it alpha numeric\\n3. store the new string\\n4. reverse the string\\n5. compare reverse string and new string\\n6. return comparison output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n86 ms\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n15.3 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # replcedstr = \\'\\'.join(e for e in s if e.isalnum()).lower()\\n        replcedstr = re.sub(\\'[^A-Za-z0-9]+\\', \\'\\', s).lower()\\n        return replcedstr[::-1] == replcedstr\\n        \\n```"
                    },
                    {
                        "username": "elzazo",
                        "content": "Time complexity is about how many comparison you do...I\\'m guessing O(5/2N) (N times to evaluate a character to replace it with lower case, N times to remove a non alpha numeric character and N/2 comparisons on the return statement). Still O(N) but high. Space complexity...it depends if a new string is created on the sub method and the lower method. If it\\'s not you algo does not waste unnecessary memory. Complexity is not about raw times and spaces but it\\'s an estimation about CPU time and memory space on theoretically infinite input."
                    },
                    {
                        "username": "Abhilash_Vadnala",
                        "content": "![image](https://assets.leetcode.com/users/abhilash_vadnala/image_1582190398.png)\\n"
                    },
                    {
                        "username": "jules3in",
                        "content": "It says \"considering only alphanumeric characters and ignoring cases\".\\n\\nAmong the test cases, \"a.\" is considered `true` while \"0P\" is considered `false`.\\n\\nDid I miss something in the description? Would anyone explain the details?\\n\\nThank you very much!"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "ignore the other character except:- alpahabet and numbers."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This question don\\'t deserve 8k downvotes"
                    },
                    {
                        "username": "kulkarniprajakta2612",
                        "content": "Case 1 is failing in editor but its working in VS. Can you please help me.\\n\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        bool isPalindrome = true;\\n            StringBuilder result = new StringBuilder();\\n\\n            // Iterate through each character in the input string\\n            foreach (char c in s)\\n            {\\n                if (char.IsLetter(c) || char.IsDigit(c))\\n                {\\n                    // Append the character to the result if it\\'s a letter or digit\\n                    result.Append(c);\\n                }\\n            }\\n            string str = result.ToString().ToLower();\\n            int len = str.Length-1;\\n            int i = 0;\\n            while (i < len / 2)\\n            {\\n                if (str[i] == str[len-1])\\n                {\\n                    i++;\\n                    len--;\\n                }\\n                else\\n                {\\n                    isPalindrome = false;\\n                    break;\\n                }\\n\\n            }\\n            return isPalindrome;\\n    }\\n}"
                    },
                    {
                        "username": "Akshay_Sodhi",
                        "content": "same issue"
                    },
                    {
                        "username": "hemantd369",
                        "content": "hey folks!!\\nEveryone misunderstood the question...\\nQue states that we have to check the alpha-numeric string which means string contains combination of characters from a to z and 0 to 9.\\nE.g.\\nab-01$$0ba\\nThe above string would reduced to ab010ba which is palindrome.\\nAnswer is true for ab-01$$0ba.\\n\\nE.g. \\n0P\\nThe above string is already is in reduced form.\\nIts answer is false because 0P is not palindrome.\\n\\nE.g. \\n0P0\\nIts answer is true as it is a palindrome.\\n"
                    },
                    {
                        "username": "hemantd369",
                        "content": "[@pawansharma9115078358](/pawansharma9115078358)  \"abb\" is not a palindrome because from backward it reads \"bba\" so clearly it is not. \"aba\" is a palindrome"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "tell me that if \"abb\" is palidrome or not . Because The expected output is showing false how?"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "class Solution:\\n     def isPalindrome(self,s:str) -> bool:\\n        import re \\n        s = re.sub(r\\'[\\\\W_]\\', \\'\\', s).lower()\\n        new_str = \\'\\'\\n\\n        for i in reversed(range(len(s))):\\n            new_str += s[i]\\n\\n        return new_str == s \\nwhat am i doing wrong here i dont get im getting a syntax error!!!!"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "You don\\'t have to do a for loop, just make a s == s[::-1]\\n"
                    },
                    {
                        "username": "Shag-Foal",
                        "content": "use equals()"
                    }
                ]
            },
            {
                "id": 1568940,
                "content": [
                    {
                        "username": "mitesh1612",
                        "content": "Can somebody clarify the question more as the test cases are creating some doubt!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "the question is simple as in this question we have to check for palindrome considering upper and lower case as same and simultaneously removing  special characters from space to double inverted comma .\\n\\nhope I able to explain >>>>"
                    },
                    {
                        "username": "Qichen_Gu",
                        "content": "The test case 0P (zero P) shows that digits are considered for checking a palindrome)."
                    },
                    {
                        "username": "gabbar0101",
                        "content": "How can \"0P\" be a pallindrome?\\nas in my opinion \"0P\\' != \"P0\"\\n"
                    },
                    {
                        "username": "ChinmayKadam172",
                        "content": "The question reads that you only have to consider lower and upper case characters\\nand not numbers so zero is ignored so the string becomes \"P\""
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "well the string dont contain number so it will be P and P\\nand it is low case so it is p and p is it the same\\n"
                    },
                    {
                        "username": "harshalyeole",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstring comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lowecase the string\\n2. Remove all the spaces and other chars, make it alpha numeric\\n3. store the new string\\n4. reverse the string\\n5. compare reverse string and new string\\n6. return comparison output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n86 ms\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n15.3 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # replcedstr = \\'\\'.join(e for e in s if e.isalnum()).lower()\\n        replcedstr = re.sub(\\'[^A-Za-z0-9]+\\', \\'\\', s).lower()\\n        return replcedstr[::-1] == replcedstr\\n        \\n```"
                    },
                    {
                        "username": "elzazo",
                        "content": "Time complexity is about how many comparison you do...I\\'m guessing O(5/2N) (N times to evaluate a character to replace it with lower case, N times to remove a non alpha numeric character and N/2 comparisons on the return statement). Still O(N) but high. Space complexity...it depends if a new string is created on the sub method and the lower method. If it\\'s not you algo does not waste unnecessary memory. Complexity is not about raw times and spaces but it\\'s an estimation about CPU time and memory space on theoretically infinite input."
                    },
                    {
                        "username": "Abhilash_Vadnala",
                        "content": "![image](https://assets.leetcode.com/users/abhilash_vadnala/image_1582190398.png)\\n"
                    },
                    {
                        "username": "jules3in",
                        "content": "It says \"considering only alphanumeric characters and ignoring cases\".\\n\\nAmong the test cases, \"a.\" is considered `true` while \"0P\" is considered `false`.\\n\\nDid I miss something in the description? Would anyone explain the details?\\n\\nThank you very much!"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "ignore the other character except:- alpahabet and numbers."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This question don\\'t deserve 8k downvotes"
                    },
                    {
                        "username": "kulkarniprajakta2612",
                        "content": "Case 1 is failing in editor but its working in VS. Can you please help me.\\n\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        bool isPalindrome = true;\\n            StringBuilder result = new StringBuilder();\\n\\n            // Iterate through each character in the input string\\n            foreach (char c in s)\\n            {\\n                if (char.IsLetter(c) || char.IsDigit(c))\\n                {\\n                    // Append the character to the result if it\\'s a letter or digit\\n                    result.Append(c);\\n                }\\n            }\\n            string str = result.ToString().ToLower();\\n            int len = str.Length-1;\\n            int i = 0;\\n            while (i < len / 2)\\n            {\\n                if (str[i] == str[len-1])\\n                {\\n                    i++;\\n                    len--;\\n                }\\n                else\\n                {\\n                    isPalindrome = false;\\n                    break;\\n                }\\n\\n            }\\n            return isPalindrome;\\n    }\\n}"
                    },
                    {
                        "username": "Akshay_Sodhi",
                        "content": "same issue"
                    },
                    {
                        "username": "hemantd369",
                        "content": "hey folks!!\\nEveryone misunderstood the question...\\nQue states that we have to check the alpha-numeric string which means string contains combination of characters from a to z and 0 to 9.\\nE.g.\\nab-01$$0ba\\nThe above string would reduced to ab010ba which is palindrome.\\nAnswer is true for ab-01$$0ba.\\n\\nE.g. \\n0P\\nThe above string is already is in reduced form.\\nIts answer is false because 0P is not palindrome.\\n\\nE.g. \\n0P0\\nIts answer is true as it is a palindrome.\\n"
                    },
                    {
                        "username": "hemantd369",
                        "content": "[@pawansharma9115078358](/pawansharma9115078358)  \"abb\" is not a palindrome because from backward it reads \"bba\" so clearly it is not. \"aba\" is a palindrome"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "tell me that if \"abb\" is palidrome or not . Because The expected output is showing false how?"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "class Solution:\\n     def isPalindrome(self,s:str) -> bool:\\n        import re \\n        s = re.sub(r\\'[\\\\W_]\\', \\'\\', s).lower()\\n        new_str = \\'\\'\\n\\n        for i in reversed(range(len(s))):\\n            new_str += s[i]\\n\\n        return new_str == s \\nwhat am i doing wrong here i dont get im getting a syntax error!!!!"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "You don\\'t have to do a for loop, just make a s == s[::-1]\\n"
                    },
                    {
                        "username": "Shag-Foal",
                        "content": "use equals()"
                    }
                ]
            },
            {
                "id": 2061878,
                "content": [
                    {
                        "username": "mitesh1612",
                        "content": "Can somebody clarify the question more as the test cases are creating some doubt!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "the question is simple as in this question we have to check for palindrome considering upper and lower case as same and simultaneously removing  special characters from space to double inverted comma .\\n\\nhope I able to explain >>>>"
                    },
                    {
                        "username": "Qichen_Gu",
                        "content": "The test case 0P (zero P) shows that digits are considered for checking a palindrome)."
                    },
                    {
                        "username": "gabbar0101",
                        "content": "How can \"0P\" be a pallindrome?\\nas in my opinion \"0P\\' != \"P0\"\\n"
                    },
                    {
                        "username": "ChinmayKadam172",
                        "content": "The question reads that you only have to consider lower and upper case characters\\nand not numbers so zero is ignored so the string becomes \"P\""
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "well the string dont contain number so it will be P and P\\nand it is low case so it is p and p is it the same\\n"
                    },
                    {
                        "username": "harshalyeole",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstring comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lowecase the string\\n2. Remove all the spaces and other chars, make it alpha numeric\\n3. store the new string\\n4. reverse the string\\n5. compare reverse string and new string\\n6. return comparison output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n86 ms\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n15.3 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # replcedstr = \\'\\'.join(e for e in s if e.isalnum()).lower()\\n        replcedstr = re.sub(\\'[^A-Za-z0-9]+\\', \\'\\', s).lower()\\n        return replcedstr[::-1] == replcedstr\\n        \\n```"
                    },
                    {
                        "username": "elzazo",
                        "content": "Time complexity is about how many comparison you do...I\\'m guessing O(5/2N) (N times to evaluate a character to replace it with lower case, N times to remove a non alpha numeric character and N/2 comparisons on the return statement). Still O(N) but high. Space complexity...it depends if a new string is created on the sub method and the lower method. If it\\'s not you algo does not waste unnecessary memory. Complexity is not about raw times and spaces but it\\'s an estimation about CPU time and memory space on theoretically infinite input."
                    },
                    {
                        "username": "Abhilash_Vadnala",
                        "content": "![image](https://assets.leetcode.com/users/abhilash_vadnala/image_1582190398.png)\\n"
                    },
                    {
                        "username": "jules3in",
                        "content": "It says \"considering only alphanumeric characters and ignoring cases\".\\n\\nAmong the test cases, \"a.\" is considered `true` while \"0P\" is considered `false`.\\n\\nDid I miss something in the description? Would anyone explain the details?\\n\\nThank you very much!"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "ignore the other character except:- alpahabet and numbers."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This question don\\'t deserve 8k downvotes"
                    },
                    {
                        "username": "kulkarniprajakta2612",
                        "content": "Case 1 is failing in editor but its working in VS. Can you please help me.\\n\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        bool isPalindrome = true;\\n            StringBuilder result = new StringBuilder();\\n\\n            // Iterate through each character in the input string\\n            foreach (char c in s)\\n            {\\n                if (char.IsLetter(c) || char.IsDigit(c))\\n                {\\n                    // Append the character to the result if it\\'s a letter or digit\\n                    result.Append(c);\\n                }\\n            }\\n            string str = result.ToString().ToLower();\\n            int len = str.Length-1;\\n            int i = 0;\\n            while (i < len / 2)\\n            {\\n                if (str[i] == str[len-1])\\n                {\\n                    i++;\\n                    len--;\\n                }\\n                else\\n                {\\n                    isPalindrome = false;\\n                    break;\\n                }\\n\\n            }\\n            return isPalindrome;\\n    }\\n}"
                    },
                    {
                        "username": "Akshay_Sodhi",
                        "content": "same issue"
                    },
                    {
                        "username": "hemantd369",
                        "content": "hey folks!!\\nEveryone misunderstood the question...\\nQue states that we have to check the alpha-numeric string which means string contains combination of characters from a to z and 0 to 9.\\nE.g.\\nab-01$$0ba\\nThe above string would reduced to ab010ba which is palindrome.\\nAnswer is true for ab-01$$0ba.\\n\\nE.g. \\n0P\\nThe above string is already is in reduced form.\\nIts answer is false because 0P is not palindrome.\\n\\nE.g. \\n0P0\\nIts answer is true as it is a palindrome.\\n"
                    },
                    {
                        "username": "hemantd369",
                        "content": "[@pawansharma9115078358](/pawansharma9115078358)  \"abb\" is not a palindrome because from backward it reads \"bba\" so clearly it is not. \"aba\" is a palindrome"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "tell me that if \"abb\" is palidrome or not . Because The expected output is showing false how?"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "class Solution:\\n     def isPalindrome(self,s:str) -> bool:\\n        import re \\n        s = re.sub(r\\'[\\\\W_]\\', \\'\\', s).lower()\\n        new_str = \\'\\'\\n\\n        for i in reversed(range(len(s))):\\n            new_str += s[i]\\n\\n        return new_str == s \\nwhat am i doing wrong here i dont get im getting a syntax error!!!!"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "You don\\'t have to do a for loop, just make a s == s[::-1]\\n"
                    },
                    {
                        "username": "Shag-Foal",
                        "content": "use equals()"
                    }
                ]
            },
            {
                "id": 2042658,
                "content": [
                    {
                        "username": "mitesh1612",
                        "content": "Can somebody clarify the question more as the test cases are creating some doubt!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "the question is simple as in this question we have to check for palindrome considering upper and lower case as same and simultaneously removing  special characters from space to double inverted comma .\\n\\nhope I able to explain >>>>"
                    },
                    {
                        "username": "Qichen_Gu",
                        "content": "The test case 0P (zero P) shows that digits are considered for checking a palindrome)."
                    },
                    {
                        "username": "gabbar0101",
                        "content": "How can \"0P\" be a pallindrome?\\nas in my opinion \"0P\\' != \"P0\"\\n"
                    },
                    {
                        "username": "ChinmayKadam172",
                        "content": "The question reads that you only have to consider lower and upper case characters\\nand not numbers so zero is ignored so the string becomes \"P\""
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "well the string dont contain number so it will be P and P\\nand it is low case so it is p and p is it the same\\n"
                    },
                    {
                        "username": "harshalyeole",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstring comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lowecase the string\\n2. Remove all the spaces and other chars, make it alpha numeric\\n3. store the new string\\n4. reverse the string\\n5. compare reverse string and new string\\n6. return comparison output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n86 ms\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n15.3 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # replcedstr = \\'\\'.join(e for e in s if e.isalnum()).lower()\\n        replcedstr = re.sub(\\'[^A-Za-z0-9]+\\', \\'\\', s).lower()\\n        return replcedstr[::-1] == replcedstr\\n        \\n```"
                    },
                    {
                        "username": "elzazo",
                        "content": "Time complexity is about how many comparison you do...I\\'m guessing O(5/2N) (N times to evaluate a character to replace it with lower case, N times to remove a non alpha numeric character and N/2 comparisons on the return statement). Still O(N) but high. Space complexity...it depends if a new string is created on the sub method and the lower method. If it\\'s not you algo does not waste unnecessary memory. Complexity is not about raw times and spaces but it\\'s an estimation about CPU time and memory space on theoretically infinite input."
                    },
                    {
                        "username": "Abhilash_Vadnala",
                        "content": "![image](https://assets.leetcode.com/users/abhilash_vadnala/image_1582190398.png)\\n"
                    },
                    {
                        "username": "jules3in",
                        "content": "It says \"considering only alphanumeric characters and ignoring cases\".\\n\\nAmong the test cases, \"a.\" is considered `true` while \"0P\" is considered `false`.\\n\\nDid I miss something in the description? Would anyone explain the details?\\n\\nThank you very much!"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "ignore the other character except:- alpahabet and numbers."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This question don\\'t deserve 8k downvotes"
                    },
                    {
                        "username": "kulkarniprajakta2612",
                        "content": "Case 1 is failing in editor but its working in VS. Can you please help me.\\n\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        bool isPalindrome = true;\\n            StringBuilder result = new StringBuilder();\\n\\n            // Iterate through each character in the input string\\n            foreach (char c in s)\\n            {\\n                if (char.IsLetter(c) || char.IsDigit(c))\\n                {\\n                    // Append the character to the result if it\\'s a letter or digit\\n                    result.Append(c);\\n                }\\n            }\\n            string str = result.ToString().ToLower();\\n            int len = str.Length-1;\\n            int i = 0;\\n            while (i < len / 2)\\n            {\\n                if (str[i] == str[len-1])\\n                {\\n                    i++;\\n                    len--;\\n                }\\n                else\\n                {\\n                    isPalindrome = false;\\n                    break;\\n                }\\n\\n            }\\n            return isPalindrome;\\n    }\\n}"
                    },
                    {
                        "username": "Akshay_Sodhi",
                        "content": "same issue"
                    },
                    {
                        "username": "hemantd369",
                        "content": "hey folks!!\\nEveryone misunderstood the question...\\nQue states that we have to check the alpha-numeric string which means string contains combination of characters from a to z and 0 to 9.\\nE.g.\\nab-01$$0ba\\nThe above string would reduced to ab010ba which is palindrome.\\nAnswer is true for ab-01$$0ba.\\n\\nE.g. \\n0P\\nThe above string is already is in reduced form.\\nIts answer is false because 0P is not palindrome.\\n\\nE.g. \\n0P0\\nIts answer is true as it is a palindrome.\\n"
                    },
                    {
                        "username": "hemantd369",
                        "content": "[@pawansharma9115078358](/pawansharma9115078358)  \"abb\" is not a palindrome because from backward it reads \"bba\" so clearly it is not. \"aba\" is a palindrome"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "tell me that if \"abb\" is palidrome or not . Because The expected output is showing false how?"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "class Solution:\\n     def isPalindrome(self,s:str) -> bool:\\n        import re \\n        s = re.sub(r\\'[\\\\W_]\\', \\'\\', s).lower()\\n        new_str = \\'\\'\\n\\n        for i in reversed(range(len(s))):\\n            new_str += s[i]\\n\\n        return new_str == s \\nwhat am i doing wrong here i dont get im getting a syntax error!!!!"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "You don\\'t have to do a for loop, just make a s == s[::-1]\\n"
                    },
                    {
                        "username": "Shag-Foal",
                        "content": "use equals()"
                    }
                ]
            },
            {
                "id": 1732138,
                "content": [
                    {
                        "username": "mitesh1612",
                        "content": "Can somebody clarify the question more as the test cases are creating some doubt!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "the question is simple as in this question we have to check for palindrome considering upper and lower case as same and simultaneously removing  special characters from space to double inverted comma .\\n\\nhope I able to explain >>>>"
                    },
                    {
                        "username": "Qichen_Gu",
                        "content": "The test case 0P (zero P) shows that digits are considered for checking a palindrome)."
                    },
                    {
                        "username": "gabbar0101",
                        "content": "How can \"0P\" be a pallindrome?\\nas in my opinion \"0P\\' != \"P0\"\\n"
                    },
                    {
                        "username": "ChinmayKadam172",
                        "content": "The question reads that you only have to consider lower and upper case characters\\nand not numbers so zero is ignored so the string becomes \"P\""
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "well the string dont contain number so it will be P and P\\nand it is low case so it is p and p is it the same\\n"
                    },
                    {
                        "username": "harshalyeole",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstring comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lowecase the string\\n2. Remove all the spaces and other chars, make it alpha numeric\\n3. store the new string\\n4. reverse the string\\n5. compare reverse string and new string\\n6. return comparison output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n86 ms\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n15.3 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # replcedstr = \\'\\'.join(e for e in s if e.isalnum()).lower()\\n        replcedstr = re.sub(\\'[^A-Za-z0-9]+\\', \\'\\', s).lower()\\n        return replcedstr[::-1] == replcedstr\\n        \\n```"
                    },
                    {
                        "username": "elzazo",
                        "content": "Time complexity is about how many comparison you do...I\\'m guessing O(5/2N) (N times to evaluate a character to replace it with lower case, N times to remove a non alpha numeric character and N/2 comparisons on the return statement). Still O(N) but high. Space complexity...it depends if a new string is created on the sub method and the lower method. If it\\'s not you algo does not waste unnecessary memory. Complexity is not about raw times and spaces but it\\'s an estimation about CPU time and memory space on theoretically infinite input."
                    },
                    {
                        "username": "Abhilash_Vadnala",
                        "content": "![image](https://assets.leetcode.com/users/abhilash_vadnala/image_1582190398.png)\\n"
                    },
                    {
                        "username": "jules3in",
                        "content": "It says \"considering only alphanumeric characters and ignoring cases\".\\n\\nAmong the test cases, \"a.\" is considered `true` while \"0P\" is considered `false`.\\n\\nDid I miss something in the description? Would anyone explain the details?\\n\\nThank you very much!"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "ignore the other character except:- alpahabet and numbers."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This question don\\'t deserve 8k downvotes"
                    },
                    {
                        "username": "kulkarniprajakta2612",
                        "content": "Case 1 is failing in editor but its working in VS. Can you please help me.\\n\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        bool isPalindrome = true;\\n            StringBuilder result = new StringBuilder();\\n\\n            // Iterate through each character in the input string\\n            foreach (char c in s)\\n            {\\n                if (char.IsLetter(c) || char.IsDigit(c))\\n                {\\n                    // Append the character to the result if it\\'s a letter or digit\\n                    result.Append(c);\\n                }\\n            }\\n            string str = result.ToString().ToLower();\\n            int len = str.Length-1;\\n            int i = 0;\\n            while (i < len / 2)\\n            {\\n                if (str[i] == str[len-1])\\n                {\\n                    i++;\\n                    len--;\\n                }\\n                else\\n                {\\n                    isPalindrome = false;\\n                    break;\\n                }\\n\\n            }\\n            return isPalindrome;\\n    }\\n}"
                    },
                    {
                        "username": "Akshay_Sodhi",
                        "content": "same issue"
                    },
                    {
                        "username": "hemantd369",
                        "content": "hey folks!!\\nEveryone misunderstood the question...\\nQue states that we have to check the alpha-numeric string which means string contains combination of characters from a to z and 0 to 9.\\nE.g.\\nab-01$$0ba\\nThe above string would reduced to ab010ba which is palindrome.\\nAnswer is true for ab-01$$0ba.\\n\\nE.g. \\n0P\\nThe above string is already is in reduced form.\\nIts answer is false because 0P is not palindrome.\\n\\nE.g. \\n0P0\\nIts answer is true as it is a palindrome.\\n"
                    },
                    {
                        "username": "hemantd369",
                        "content": "[@pawansharma9115078358](/pawansharma9115078358)  \"abb\" is not a palindrome because from backward it reads \"bba\" so clearly it is not. \"aba\" is a palindrome"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "tell me that if \"abb\" is palidrome or not . Because The expected output is showing false how?"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "class Solution:\\n     def isPalindrome(self,s:str) -> bool:\\n        import re \\n        s = re.sub(r\\'[\\\\W_]\\', \\'\\', s).lower()\\n        new_str = \\'\\'\\n\\n        for i in reversed(range(len(s))):\\n            new_str += s[i]\\n\\n        return new_str == s \\nwhat am i doing wrong here i dont get im getting a syntax error!!!!"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "You don\\'t have to do a for loop, just make a s == s[::-1]\\n"
                    },
                    {
                        "username": "Shag-Foal",
                        "content": "use equals()"
                    }
                ]
            },
            {
                "id": 1724118,
                "content": [
                    {
                        "username": "mitesh1612",
                        "content": "Can somebody clarify the question more as the test cases are creating some doubt!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "the question is simple as in this question we have to check for palindrome considering upper and lower case as same and simultaneously removing  special characters from space to double inverted comma .\\n\\nhope I able to explain >>>>"
                    },
                    {
                        "username": "Qichen_Gu",
                        "content": "The test case 0P (zero P) shows that digits are considered for checking a palindrome)."
                    },
                    {
                        "username": "gabbar0101",
                        "content": "How can \"0P\" be a pallindrome?\\nas in my opinion \"0P\\' != \"P0\"\\n"
                    },
                    {
                        "username": "ChinmayKadam172",
                        "content": "The question reads that you only have to consider lower and upper case characters\\nand not numbers so zero is ignored so the string becomes \"P\""
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "well the string dont contain number so it will be P and P\\nand it is low case so it is p and p is it the same\\n"
                    },
                    {
                        "username": "harshalyeole",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstring comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lowecase the string\\n2. Remove all the spaces and other chars, make it alpha numeric\\n3. store the new string\\n4. reverse the string\\n5. compare reverse string and new string\\n6. return comparison output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n86 ms\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n15.3 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        # replcedstr = \\'\\'.join(e for e in s if e.isalnum()).lower()\\n        replcedstr = re.sub(\\'[^A-Za-z0-9]+\\', \\'\\', s).lower()\\n        return replcedstr[::-1] == replcedstr\\n        \\n```"
                    },
                    {
                        "username": "elzazo",
                        "content": "Time complexity is about how many comparison you do...I\\'m guessing O(5/2N) (N times to evaluate a character to replace it with lower case, N times to remove a non alpha numeric character and N/2 comparisons on the return statement). Still O(N) but high. Space complexity...it depends if a new string is created on the sub method and the lower method. If it\\'s not you algo does not waste unnecessary memory. Complexity is not about raw times and spaces but it\\'s an estimation about CPU time and memory space on theoretically infinite input."
                    },
                    {
                        "username": "Abhilash_Vadnala",
                        "content": "![image](https://assets.leetcode.com/users/abhilash_vadnala/image_1582190398.png)\\n"
                    },
                    {
                        "username": "jules3in",
                        "content": "It says \"considering only alphanumeric characters and ignoring cases\".\\n\\nAmong the test cases, \"a.\" is considered `true` while \"0P\" is considered `false`.\\n\\nDid I miss something in the description? Would anyone explain the details?\\n\\nThank you very much!"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "ignore the other character except:- alpahabet and numbers."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This question don\\'t deserve 8k downvotes"
                    },
                    {
                        "username": "kulkarniprajakta2612",
                        "content": "Case 1 is failing in editor but its working in VS. Can you please help me.\\n\\npublic class Solution {\\n    public bool IsPalindrome(string s) {\\n        bool isPalindrome = true;\\n            StringBuilder result = new StringBuilder();\\n\\n            // Iterate through each character in the input string\\n            foreach (char c in s)\\n            {\\n                if (char.IsLetter(c) || char.IsDigit(c))\\n                {\\n                    // Append the character to the result if it\\'s a letter or digit\\n                    result.Append(c);\\n                }\\n            }\\n            string str = result.ToString().ToLower();\\n            int len = str.Length-1;\\n            int i = 0;\\n            while (i < len / 2)\\n            {\\n                if (str[i] == str[len-1])\\n                {\\n                    i++;\\n                    len--;\\n                }\\n                else\\n                {\\n                    isPalindrome = false;\\n                    break;\\n                }\\n\\n            }\\n            return isPalindrome;\\n    }\\n}"
                    },
                    {
                        "username": "Akshay_Sodhi",
                        "content": "same issue"
                    },
                    {
                        "username": "hemantd369",
                        "content": "hey folks!!\\nEveryone misunderstood the question...\\nQue states that we have to check the alpha-numeric string which means string contains combination of characters from a to z and 0 to 9.\\nE.g.\\nab-01$$0ba\\nThe above string would reduced to ab010ba which is palindrome.\\nAnswer is true for ab-01$$0ba.\\n\\nE.g. \\n0P\\nThe above string is already is in reduced form.\\nIts answer is false because 0P is not palindrome.\\n\\nE.g. \\n0P0\\nIts answer is true as it is a palindrome.\\n"
                    },
                    {
                        "username": "hemantd369",
                        "content": "[@pawansharma9115078358](/pawansharma9115078358)  \"abb\" is not a palindrome because from backward it reads \"bba\" so clearly it is not. \"aba\" is a palindrome"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "tell me that if \"abb\" is palidrome or not . Because The expected output is showing false how?"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "class Solution:\\n     def isPalindrome(self,s:str) -> bool:\\n        import re \\n        s = re.sub(r\\'[\\\\W_]\\', \\'\\', s).lower()\\n        new_str = \\'\\'\\n\\n        for i in reversed(range(len(s))):\\n            new_str += s[i]\\n\\n        return new_str == s \\nwhat am i doing wrong here i dont get im getting a syntax error!!!!"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "You don\\'t have to do a for loop, just make a s == s[::-1]\\n"
                    },
                    {
                        "username": "Shag-Foal",
                        "content": "use equals()"
                    }
                ]
            },
            {
                "id": 1713740,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/valid-palindrome/solutions/2902695/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "vgudhe",
                        "content": "When I write the code in Jupyter its passing the test case given in leetcode but while I am writing the same code in leetcode, its not giving the same output and failing the test case which passed in Jupyter notebook. Can anyone please say why that is happening?"
                    },
                    {
                        "username": "victoragboli",
                        "content": "This is the same issue I\\'m experiencing with the \"race a car\" test case"
                    },
                    {
                        "username": "suman979",
                        "content": "https://github.com/sumanth979/LeetCode-Challenges/blob/master/ValidPalindrome.java"
                    },
                    {
                        "username": "Google",
                        "content": "![World becomes better when you can regex][1]\\n\\n\\n  [1]: http://i.gyazo.com/7102c387f16cae4c53ad755d190252d2.gif"
                    },
                    {
                        "username": "lolhaha",
                        "content": "from the error I met\\n \"a\" return true \\n \"1a2\" return false\\n \\nI am confused about what is the rule for palindrome for this question"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it always give true for single character as the string will be same if you compare from start and end . In 1a2 if you compare first and last character they are both different ,so here the rule of palindrome voilates ...\\n\\n\\nhope it works for you "
                    },
                    {
                        "username": "domofeng",
                        "content": "considering only alphanumeric characters and ignoring cases.\\n\\nthis is what questions asked, ignoring cases\\n\\nso why \".,\" is false, come on"
                    },
                    {
                        "username": "jaxpham",
                        "content": "var isPalindrome = function(s) {\\n   s = s.replace(/[^0-9a-z]/gi, \\'\\').toLowerCase();\\n    \\n   return s === s.split(\\'\\').reverse().join(\\'\\');\\n   \\n};"
                    },
                    {
                        "username": "user9797Il",
                        "content": "C++ code\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.length();\\n        string toLowerStr = \"\";\\n        for(int i=0;i<n;i++){\\n            toLowerStr.push_back(tolower(s[i]));\\n        }\\n        string validString = \"\";\\n        for(int i=0;i<n;i++){\\n\\n           if(isalpha(toLowerStr[i]) || isdigit(toLowerStr[i])){\\n                validString.push_back(toLowerStr[i]);\\n            }\\n        }\\n\\n       int start=0,prev=validString.size()-1;\\n       while(start<prev){\\n           if(validString[start]!=validString[prev]){\\n               return false;\\n           }\\n           start++,prev--;\\n       } \\n\\n       return true;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "user4130zD",
                        "content": "s = \" \"\\nOutput = false\\n**Expected = true**\\n\\nThis should be specifically said in the description."
                    },
                    {
                        "username": "BlakeE",
                        "content": "Is there anyway to simplify the following statement?\\n\\n `if(((int)s.charAt(i) >= 48 && (int)s.charAt(i) <= 57)||((int)s.charAt(i) >= 65 && (int)s.charAt(i) <= 90)||((int)s.charAt(i) >= 97 && (int)s.charAt(i) <= 122)) //[48,57]U[65,90]U[97,122]\\n                fixed += s.toLowerCase().charAt(i);`"
                    }
                ]
            },
            {
                "id": 1639986,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/valid-palindrome/solutions/2902695/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "vgudhe",
                        "content": "When I write the code in Jupyter its passing the test case given in leetcode but while I am writing the same code in leetcode, its not giving the same output and failing the test case which passed in Jupyter notebook. Can anyone please say why that is happening?"
                    },
                    {
                        "username": "victoragboli",
                        "content": "This is the same issue I\\'m experiencing with the \"race a car\" test case"
                    },
                    {
                        "username": "suman979",
                        "content": "https://github.com/sumanth979/LeetCode-Challenges/blob/master/ValidPalindrome.java"
                    },
                    {
                        "username": "Google",
                        "content": "![World becomes better when you can regex][1]\\n\\n\\n  [1]: http://i.gyazo.com/7102c387f16cae4c53ad755d190252d2.gif"
                    },
                    {
                        "username": "lolhaha",
                        "content": "from the error I met\\n \"a\" return true \\n \"1a2\" return false\\n \\nI am confused about what is the rule for palindrome for this question"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it always give true for single character as the string will be same if you compare from start and end . In 1a2 if you compare first and last character they are both different ,so here the rule of palindrome voilates ...\\n\\n\\nhope it works for you "
                    },
                    {
                        "username": "domofeng",
                        "content": "considering only alphanumeric characters and ignoring cases.\\n\\nthis is what questions asked, ignoring cases\\n\\nso why \".,\" is false, come on"
                    },
                    {
                        "username": "jaxpham",
                        "content": "var isPalindrome = function(s) {\\n   s = s.replace(/[^0-9a-z]/gi, \\'\\').toLowerCase();\\n    \\n   return s === s.split(\\'\\').reverse().join(\\'\\');\\n   \\n};"
                    },
                    {
                        "username": "user9797Il",
                        "content": "C++ code\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.length();\\n        string toLowerStr = \"\";\\n        for(int i=0;i<n;i++){\\n            toLowerStr.push_back(tolower(s[i]));\\n        }\\n        string validString = \"\";\\n        for(int i=0;i<n;i++){\\n\\n           if(isalpha(toLowerStr[i]) || isdigit(toLowerStr[i])){\\n                validString.push_back(toLowerStr[i]);\\n            }\\n        }\\n\\n       int start=0,prev=validString.size()-1;\\n       while(start<prev){\\n           if(validString[start]!=validString[prev]){\\n               return false;\\n           }\\n           start++,prev--;\\n       } \\n\\n       return true;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "user4130zD",
                        "content": "s = \" \"\\nOutput = false\\n**Expected = true**\\n\\nThis should be specifically said in the description."
                    },
                    {
                        "username": "BlakeE",
                        "content": "Is there anyway to simplify the following statement?\\n\\n `if(((int)s.charAt(i) >= 48 && (int)s.charAt(i) <= 57)||((int)s.charAt(i) >= 65 && (int)s.charAt(i) <= 90)||((int)s.charAt(i) >= 97 && (int)s.charAt(i) <= 122)) //[48,57]U[65,90]U[97,122]\\n                fixed += s.toLowerCase().charAt(i);`"
                    }
                ]
            },
            {
                "id": 1574156,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/valid-palindrome/solutions/2902695/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "vgudhe",
                        "content": "When I write the code in Jupyter its passing the test case given in leetcode but while I am writing the same code in leetcode, its not giving the same output and failing the test case which passed in Jupyter notebook. Can anyone please say why that is happening?"
                    },
                    {
                        "username": "victoragboli",
                        "content": "This is the same issue I\\'m experiencing with the \"race a car\" test case"
                    },
                    {
                        "username": "suman979",
                        "content": "https://github.com/sumanth979/LeetCode-Challenges/blob/master/ValidPalindrome.java"
                    },
                    {
                        "username": "Google",
                        "content": "![World becomes better when you can regex][1]\\n\\n\\n  [1]: http://i.gyazo.com/7102c387f16cae4c53ad755d190252d2.gif"
                    },
                    {
                        "username": "lolhaha",
                        "content": "from the error I met\\n \"a\" return true \\n \"1a2\" return false\\n \\nI am confused about what is the rule for palindrome for this question"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it always give true for single character as the string will be same if you compare from start and end . In 1a2 if you compare first and last character they are both different ,so here the rule of palindrome voilates ...\\n\\n\\nhope it works for you "
                    },
                    {
                        "username": "domofeng",
                        "content": "considering only alphanumeric characters and ignoring cases.\\n\\nthis is what questions asked, ignoring cases\\n\\nso why \".,\" is false, come on"
                    },
                    {
                        "username": "jaxpham",
                        "content": "var isPalindrome = function(s) {\\n   s = s.replace(/[^0-9a-z]/gi, \\'\\').toLowerCase();\\n    \\n   return s === s.split(\\'\\').reverse().join(\\'\\');\\n   \\n};"
                    },
                    {
                        "username": "user9797Il",
                        "content": "C++ code\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.length();\\n        string toLowerStr = \"\";\\n        for(int i=0;i<n;i++){\\n            toLowerStr.push_back(tolower(s[i]));\\n        }\\n        string validString = \"\";\\n        for(int i=0;i<n;i++){\\n\\n           if(isalpha(toLowerStr[i]) || isdigit(toLowerStr[i])){\\n                validString.push_back(toLowerStr[i]);\\n            }\\n        }\\n\\n       int start=0,prev=validString.size()-1;\\n       while(start<prev){\\n           if(validString[start]!=validString[prev]){\\n               return false;\\n           }\\n           start++,prev--;\\n       } \\n\\n       return true;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "user4130zD",
                        "content": "s = \" \"\\nOutput = false\\n**Expected = true**\\n\\nThis should be specifically said in the description."
                    },
                    {
                        "username": "BlakeE",
                        "content": "Is there anyway to simplify the following statement?\\n\\n `if(((int)s.charAt(i) >= 48 && (int)s.charAt(i) <= 57)||((int)s.charAt(i) >= 65 && (int)s.charAt(i) <= 90)||((int)s.charAt(i) >= 97 && (int)s.charAt(i) <= 122)) //[48,57]U[65,90]U[97,122]\\n                fixed += s.toLowerCase().charAt(i);`"
                    }
                ]
            },
            {
                "id": 1571262,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/valid-palindrome/solutions/2902695/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "vgudhe",
                        "content": "When I write the code in Jupyter its passing the test case given in leetcode but while I am writing the same code in leetcode, its not giving the same output and failing the test case which passed in Jupyter notebook. Can anyone please say why that is happening?"
                    },
                    {
                        "username": "victoragboli",
                        "content": "This is the same issue I\\'m experiencing with the \"race a car\" test case"
                    },
                    {
                        "username": "suman979",
                        "content": "https://github.com/sumanth979/LeetCode-Challenges/blob/master/ValidPalindrome.java"
                    },
                    {
                        "username": "Google",
                        "content": "![World becomes better when you can regex][1]\\n\\n\\n  [1]: http://i.gyazo.com/7102c387f16cae4c53ad755d190252d2.gif"
                    },
                    {
                        "username": "lolhaha",
                        "content": "from the error I met\\n \"a\" return true \\n \"1a2\" return false\\n \\nI am confused about what is the rule for palindrome for this question"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it always give true for single character as the string will be same if you compare from start and end . In 1a2 if you compare first and last character they are both different ,so here the rule of palindrome voilates ...\\n\\n\\nhope it works for you "
                    },
                    {
                        "username": "domofeng",
                        "content": "considering only alphanumeric characters and ignoring cases.\\n\\nthis is what questions asked, ignoring cases\\n\\nso why \".,\" is false, come on"
                    },
                    {
                        "username": "jaxpham",
                        "content": "var isPalindrome = function(s) {\\n   s = s.replace(/[^0-9a-z]/gi, \\'\\').toLowerCase();\\n    \\n   return s === s.split(\\'\\').reverse().join(\\'\\');\\n   \\n};"
                    },
                    {
                        "username": "user9797Il",
                        "content": "C++ code\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.length();\\n        string toLowerStr = \"\";\\n        for(int i=0;i<n;i++){\\n            toLowerStr.push_back(tolower(s[i]));\\n        }\\n        string validString = \"\";\\n        for(int i=0;i<n;i++){\\n\\n           if(isalpha(toLowerStr[i]) || isdigit(toLowerStr[i])){\\n                validString.push_back(toLowerStr[i]);\\n            }\\n        }\\n\\n       int start=0,prev=validString.size()-1;\\n       while(start<prev){\\n           if(validString[start]!=validString[prev]){\\n               return false;\\n           }\\n           start++,prev--;\\n       } \\n\\n       return true;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "user4130zD",
                        "content": "s = \" \"\\nOutput = false\\n**Expected = true**\\n\\nThis should be specifically said in the description."
                    },
                    {
                        "username": "BlakeE",
                        "content": "Is there anyway to simplify the following statement?\\n\\n `if(((int)s.charAt(i) >= 48 && (int)s.charAt(i) <= 57)||((int)s.charAt(i) >= 65 && (int)s.charAt(i) <= 90)||((int)s.charAt(i) >= 97 && (int)s.charAt(i) <= 122)) //[48,57]U[65,90]U[97,122]\\n                fixed += s.toLowerCase().charAt(i);`"
                    }
                ]
            },
            {
                "id": 1571263,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/valid-palindrome/solutions/2902695/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "vgudhe",
                        "content": "When I write the code in Jupyter its passing the test case given in leetcode but while I am writing the same code in leetcode, its not giving the same output and failing the test case which passed in Jupyter notebook. Can anyone please say why that is happening?"
                    },
                    {
                        "username": "victoragboli",
                        "content": "This is the same issue I\\'m experiencing with the \"race a car\" test case"
                    },
                    {
                        "username": "suman979",
                        "content": "https://github.com/sumanth979/LeetCode-Challenges/blob/master/ValidPalindrome.java"
                    },
                    {
                        "username": "Google",
                        "content": "![World becomes better when you can regex][1]\\n\\n\\n  [1]: http://i.gyazo.com/7102c387f16cae4c53ad755d190252d2.gif"
                    },
                    {
                        "username": "lolhaha",
                        "content": "from the error I met\\n \"a\" return true \\n \"1a2\" return false\\n \\nI am confused about what is the rule for palindrome for this question"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it always give true for single character as the string will be same if you compare from start and end . In 1a2 if you compare first and last character they are both different ,so here the rule of palindrome voilates ...\\n\\n\\nhope it works for you "
                    },
                    {
                        "username": "domofeng",
                        "content": "considering only alphanumeric characters and ignoring cases.\\n\\nthis is what questions asked, ignoring cases\\n\\nso why \".,\" is false, come on"
                    },
                    {
                        "username": "jaxpham",
                        "content": "var isPalindrome = function(s) {\\n   s = s.replace(/[^0-9a-z]/gi, \\'\\').toLowerCase();\\n    \\n   return s === s.split(\\'\\').reverse().join(\\'\\');\\n   \\n};"
                    },
                    {
                        "username": "user9797Il",
                        "content": "C++ code\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.length();\\n        string toLowerStr = \"\";\\n        for(int i=0;i<n;i++){\\n            toLowerStr.push_back(tolower(s[i]));\\n        }\\n        string validString = \"\";\\n        for(int i=0;i<n;i++){\\n\\n           if(isalpha(toLowerStr[i]) || isdigit(toLowerStr[i])){\\n                validString.push_back(toLowerStr[i]);\\n            }\\n        }\\n\\n       int start=0,prev=validString.size()-1;\\n       while(start<prev){\\n           if(validString[start]!=validString[prev]){\\n               return false;\\n           }\\n           start++,prev--;\\n       } \\n\\n       return true;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "user4130zD",
                        "content": "s = \" \"\\nOutput = false\\n**Expected = true**\\n\\nThis should be specifically said in the description."
                    },
                    {
                        "username": "BlakeE",
                        "content": "Is there anyway to simplify the following statement?\\n\\n `if(((int)s.charAt(i) >= 48 && (int)s.charAt(i) <= 57)||((int)s.charAt(i) >= 65 && (int)s.charAt(i) <= 90)||((int)s.charAt(i) >= 97 && (int)s.charAt(i) <= 122)) //[48,57]U[65,90]U[97,122]\\n                fixed += s.toLowerCase().charAt(i);`"
                    }
                ]
            },
            {
                "id": 1568941,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/valid-palindrome/solutions/2902695/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "vgudhe",
                        "content": "When I write the code in Jupyter its passing the test case given in leetcode but while I am writing the same code in leetcode, its not giving the same output and failing the test case which passed in Jupyter notebook. Can anyone please say why that is happening?"
                    },
                    {
                        "username": "victoragboli",
                        "content": "This is the same issue I\\'m experiencing with the \"race a car\" test case"
                    },
                    {
                        "username": "suman979",
                        "content": "https://github.com/sumanth979/LeetCode-Challenges/blob/master/ValidPalindrome.java"
                    },
                    {
                        "username": "Google",
                        "content": "![World becomes better when you can regex][1]\\n\\n\\n  [1]: http://i.gyazo.com/7102c387f16cae4c53ad755d190252d2.gif"
                    },
                    {
                        "username": "lolhaha",
                        "content": "from the error I met\\n \"a\" return true \\n \"1a2\" return false\\n \\nI am confused about what is the rule for palindrome for this question"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it always give true for single character as the string will be same if you compare from start and end . In 1a2 if you compare first and last character they are both different ,so here the rule of palindrome voilates ...\\n\\n\\nhope it works for you "
                    },
                    {
                        "username": "domofeng",
                        "content": "considering only alphanumeric characters and ignoring cases.\\n\\nthis is what questions asked, ignoring cases\\n\\nso why \".,\" is false, come on"
                    },
                    {
                        "username": "jaxpham",
                        "content": "var isPalindrome = function(s) {\\n   s = s.replace(/[^0-9a-z]/gi, \\'\\').toLowerCase();\\n    \\n   return s === s.split(\\'\\').reverse().join(\\'\\');\\n   \\n};"
                    },
                    {
                        "username": "user9797Il",
                        "content": "C++ code\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.length();\\n        string toLowerStr = \"\";\\n        for(int i=0;i<n;i++){\\n            toLowerStr.push_back(tolower(s[i]));\\n        }\\n        string validString = \"\";\\n        for(int i=0;i<n;i++){\\n\\n           if(isalpha(toLowerStr[i]) || isdigit(toLowerStr[i])){\\n                validString.push_back(toLowerStr[i]);\\n            }\\n        }\\n\\n       int start=0,prev=validString.size()-1;\\n       while(start<prev){\\n           if(validString[start]!=validString[prev]){\\n               return false;\\n           }\\n           start++,prev--;\\n       } \\n\\n       return true;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "user4130zD",
                        "content": "s = \" \"\\nOutput = false\\n**Expected = true**\\n\\nThis should be specifically said in the description."
                    },
                    {
                        "username": "BlakeE",
                        "content": "Is there anyway to simplify the following statement?\\n\\n `if(((int)s.charAt(i) >= 48 && (int)s.charAt(i) <= 57)||((int)s.charAt(i) >= 65 && (int)s.charAt(i) <= 90)||((int)s.charAt(i) >= 97 && (int)s.charAt(i) <= 122)) //[48,57]U[65,90]U[97,122]\\n                fixed += s.toLowerCase().charAt(i);`"
                    }
                ]
            },
            {
                "id": 1576045,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/valid-palindrome/solutions/2902695/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "vgudhe",
                        "content": "When I write the code in Jupyter its passing the test case given in leetcode but while I am writing the same code in leetcode, its not giving the same output and failing the test case which passed in Jupyter notebook. Can anyone please say why that is happening?"
                    },
                    {
                        "username": "victoragboli",
                        "content": "This is the same issue I\\'m experiencing with the \"race a car\" test case"
                    },
                    {
                        "username": "suman979",
                        "content": "https://github.com/sumanth979/LeetCode-Challenges/blob/master/ValidPalindrome.java"
                    },
                    {
                        "username": "Google",
                        "content": "![World becomes better when you can regex][1]\\n\\n\\n  [1]: http://i.gyazo.com/7102c387f16cae4c53ad755d190252d2.gif"
                    },
                    {
                        "username": "lolhaha",
                        "content": "from the error I met\\n \"a\" return true \\n \"1a2\" return false\\n \\nI am confused about what is the rule for palindrome for this question"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it always give true for single character as the string will be same if you compare from start and end . In 1a2 if you compare first and last character they are both different ,so here the rule of palindrome voilates ...\\n\\n\\nhope it works for you "
                    },
                    {
                        "username": "domofeng",
                        "content": "considering only alphanumeric characters and ignoring cases.\\n\\nthis is what questions asked, ignoring cases\\n\\nso why \".,\" is false, come on"
                    },
                    {
                        "username": "jaxpham",
                        "content": "var isPalindrome = function(s) {\\n   s = s.replace(/[^0-9a-z]/gi, \\'\\').toLowerCase();\\n    \\n   return s === s.split(\\'\\').reverse().join(\\'\\');\\n   \\n};"
                    },
                    {
                        "username": "user9797Il",
                        "content": "C++ code\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.length();\\n        string toLowerStr = \"\";\\n        for(int i=0;i<n;i++){\\n            toLowerStr.push_back(tolower(s[i]));\\n        }\\n        string validString = \"\";\\n        for(int i=0;i<n;i++){\\n\\n           if(isalpha(toLowerStr[i]) || isdigit(toLowerStr[i])){\\n                validString.push_back(toLowerStr[i]);\\n            }\\n        }\\n\\n       int start=0,prev=validString.size()-1;\\n       while(start<prev){\\n           if(validString[start]!=validString[prev]){\\n               return false;\\n           }\\n           start++,prev--;\\n       } \\n\\n       return true;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "user4130zD",
                        "content": "s = \" \"\\nOutput = false\\n**Expected = true**\\n\\nThis should be specifically said in the description."
                    },
                    {
                        "username": "BlakeE",
                        "content": "Is there anyway to simplify the following statement?\\n\\n `if(((int)s.charAt(i) >= 48 && (int)s.charAt(i) <= 57)||((int)s.charAt(i) >= 65 && (int)s.charAt(i) <= 90)||((int)s.charAt(i) >= 97 && (int)s.charAt(i) <= 122)) //[48,57]U[65,90]U[97,122]\\n                fixed += s.toLowerCase().charAt(i);`"
                    }
                ]
            },
            {
                "id": 2075275,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/valid-palindrome/solutions/2902695/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "vgudhe",
                        "content": "When I write the code in Jupyter its passing the test case given in leetcode but while I am writing the same code in leetcode, its not giving the same output and failing the test case which passed in Jupyter notebook. Can anyone please say why that is happening?"
                    },
                    {
                        "username": "victoragboli",
                        "content": "This is the same issue I\\'m experiencing with the \"race a car\" test case"
                    },
                    {
                        "username": "suman979",
                        "content": "https://github.com/sumanth979/LeetCode-Challenges/blob/master/ValidPalindrome.java"
                    },
                    {
                        "username": "Google",
                        "content": "![World becomes better when you can regex][1]\\n\\n\\n  [1]: http://i.gyazo.com/7102c387f16cae4c53ad755d190252d2.gif"
                    },
                    {
                        "username": "lolhaha",
                        "content": "from the error I met\\n \"a\" return true \\n \"1a2\" return false\\n \\nI am confused about what is the rule for palindrome for this question"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it always give true for single character as the string will be same if you compare from start and end . In 1a2 if you compare first and last character they are both different ,so here the rule of palindrome voilates ...\\n\\n\\nhope it works for you "
                    },
                    {
                        "username": "domofeng",
                        "content": "considering only alphanumeric characters and ignoring cases.\\n\\nthis is what questions asked, ignoring cases\\n\\nso why \".,\" is false, come on"
                    },
                    {
                        "username": "jaxpham",
                        "content": "var isPalindrome = function(s) {\\n   s = s.replace(/[^0-9a-z]/gi, \\'\\').toLowerCase();\\n    \\n   return s === s.split(\\'\\').reverse().join(\\'\\');\\n   \\n};"
                    },
                    {
                        "username": "user9797Il",
                        "content": "C++ code\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.length();\\n        string toLowerStr = \"\";\\n        for(int i=0;i<n;i++){\\n            toLowerStr.push_back(tolower(s[i]));\\n        }\\n        string validString = \"\";\\n        for(int i=0;i<n;i++){\\n\\n           if(isalpha(toLowerStr[i]) || isdigit(toLowerStr[i])){\\n                validString.push_back(toLowerStr[i]);\\n            }\\n        }\\n\\n       int start=0,prev=validString.size()-1;\\n       while(start<prev){\\n           if(validString[start]!=validString[prev]){\\n               return false;\\n           }\\n           start++,prev--;\\n       } \\n\\n       return true;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "user4130zD",
                        "content": "s = \" \"\\nOutput = false\\n**Expected = true**\\n\\nThis should be specifically said in the description."
                    },
                    {
                        "username": "BlakeE",
                        "content": "Is there anyway to simplify the following statement?\\n\\n `if(((int)s.charAt(i) >= 48 && (int)s.charAt(i) <= 57)||((int)s.charAt(i) >= 65 && (int)s.charAt(i) <= 90)||((int)s.charAt(i) >= 97 && (int)s.charAt(i) <= 122)) //[48,57]U[65,90]U[97,122]\\n                fixed += s.toLowerCase().charAt(i);`"
                    }
                ]
            },
            {
                "id": 2074664,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/valid-palindrome/solutions/2902695/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "vgudhe",
                        "content": "When I write the code in Jupyter its passing the test case given in leetcode but while I am writing the same code in leetcode, its not giving the same output and failing the test case which passed in Jupyter notebook. Can anyone please say why that is happening?"
                    },
                    {
                        "username": "victoragboli",
                        "content": "This is the same issue I\\'m experiencing with the \"race a car\" test case"
                    },
                    {
                        "username": "suman979",
                        "content": "https://github.com/sumanth979/LeetCode-Challenges/blob/master/ValidPalindrome.java"
                    },
                    {
                        "username": "Google",
                        "content": "![World becomes better when you can regex][1]\\n\\n\\n  [1]: http://i.gyazo.com/7102c387f16cae4c53ad755d190252d2.gif"
                    },
                    {
                        "username": "lolhaha",
                        "content": "from the error I met\\n \"a\" return true \\n \"1a2\" return false\\n \\nI am confused about what is the rule for palindrome for this question"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it always give true for single character as the string will be same if you compare from start and end . In 1a2 if you compare first and last character they are both different ,so here the rule of palindrome voilates ...\\n\\n\\nhope it works for you "
                    },
                    {
                        "username": "domofeng",
                        "content": "considering only alphanumeric characters and ignoring cases.\\n\\nthis is what questions asked, ignoring cases\\n\\nso why \".,\" is false, come on"
                    },
                    {
                        "username": "jaxpham",
                        "content": "var isPalindrome = function(s) {\\n   s = s.replace(/[^0-9a-z]/gi, \\'\\').toLowerCase();\\n    \\n   return s === s.split(\\'\\').reverse().join(\\'\\');\\n   \\n};"
                    },
                    {
                        "username": "user9797Il",
                        "content": "C++ code\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.length();\\n        string toLowerStr = \"\";\\n        for(int i=0;i<n;i++){\\n            toLowerStr.push_back(tolower(s[i]));\\n        }\\n        string validString = \"\";\\n        for(int i=0;i<n;i++){\\n\\n           if(isalpha(toLowerStr[i]) || isdigit(toLowerStr[i])){\\n                validString.push_back(toLowerStr[i]);\\n            }\\n        }\\n\\n       int start=0,prev=validString.size()-1;\\n       while(start<prev){\\n           if(validString[start]!=validString[prev]){\\n               return false;\\n           }\\n           start++,prev--;\\n       } \\n\\n       return true;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "user4130zD",
                        "content": "s = \" \"\\nOutput = false\\n**Expected = true**\\n\\nThis should be specifically said in the description."
                    },
                    {
                        "username": "BlakeE",
                        "content": "Is there anyway to simplify the following statement?\\n\\n `if(((int)s.charAt(i) >= 48 && (int)s.charAt(i) <= 57)||((int)s.charAt(i) >= 65 && (int)s.charAt(i) <= 90)||((int)s.charAt(i) >= 97 && (int)s.charAt(i) <= 122)) //[48,57]U[65,90]U[97,122]\\n                fixed += s.toLowerCase().charAt(i);`"
                    }
                ]
            },
            {
                "id": 2073601,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/valid-palindrome/solutions/2902695/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "vgudhe",
                        "content": "When I write the code in Jupyter its passing the test case given in leetcode but while I am writing the same code in leetcode, its not giving the same output and failing the test case which passed in Jupyter notebook. Can anyone please say why that is happening?"
                    },
                    {
                        "username": "victoragboli",
                        "content": "This is the same issue I\\'m experiencing with the \"race a car\" test case"
                    },
                    {
                        "username": "suman979",
                        "content": "https://github.com/sumanth979/LeetCode-Challenges/blob/master/ValidPalindrome.java"
                    },
                    {
                        "username": "Google",
                        "content": "![World becomes better when you can regex][1]\\n\\n\\n  [1]: http://i.gyazo.com/7102c387f16cae4c53ad755d190252d2.gif"
                    },
                    {
                        "username": "lolhaha",
                        "content": "from the error I met\\n \"a\" return true \\n \"1a2\" return false\\n \\nI am confused about what is the rule for palindrome for this question"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it always give true for single character as the string will be same if you compare from start and end . In 1a2 if you compare first and last character they are both different ,so here the rule of palindrome voilates ...\\n\\n\\nhope it works for you "
                    },
                    {
                        "username": "domofeng",
                        "content": "considering only alphanumeric characters and ignoring cases.\\n\\nthis is what questions asked, ignoring cases\\n\\nso why \".,\" is false, come on"
                    },
                    {
                        "username": "jaxpham",
                        "content": "var isPalindrome = function(s) {\\n   s = s.replace(/[^0-9a-z]/gi, \\'\\').toLowerCase();\\n    \\n   return s === s.split(\\'\\').reverse().join(\\'\\');\\n   \\n};"
                    },
                    {
                        "username": "user9797Il",
                        "content": "C++ code\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int n = s.length();\\n        string toLowerStr = \"\";\\n        for(int i=0;i<n;i++){\\n            toLowerStr.push_back(tolower(s[i]));\\n        }\\n        string validString = \"\";\\n        for(int i=0;i<n;i++){\\n\\n           if(isalpha(toLowerStr[i]) || isdigit(toLowerStr[i])){\\n                validString.push_back(toLowerStr[i]);\\n            }\\n        }\\n\\n       int start=0,prev=validString.size()-1;\\n       while(start<prev){\\n           if(validString[start]!=validString[prev]){\\n               return false;\\n           }\\n           start++,prev--;\\n       } \\n\\n       return true;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "user4130zD",
                        "content": "s = \" \"\\nOutput = false\\n**Expected = true**\\n\\nThis should be specifically said in the description."
                    },
                    {
                        "username": "BlakeE",
                        "content": "Is there anyway to simplify the following statement?\\n\\n `if(((int)s.charAt(i) >= 48 && (int)s.charAt(i) <= 57)||((int)s.charAt(i) >= 65 && (int)s.charAt(i) <= 90)||((int)s.charAt(i) >= 97 && (int)s.charAt(i) <= 122)) //[48,57]U[65,90]U[97,122]\\n                fixed += s.toLowerCase().charAt(i);`"
                    }
                ]
            },
            {
                "id": 2073566,
                "content": [
                    {
                        "username": "underdogsrijan",
                        "content": "testcase no 462 is wrong, s = \"0P\" in this testcase but and expected output is false, it simply means that the question is considering \\'0\\', but it is not mentioned in question"
                    },
                    {
                        "username": "BlakeE",
                        "content": "alphanumeric means to include both letters and digits. Only remove symbols, spaces, and special chars. Digits and numbers are valid"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "bool isPalindrome(string s) {\\n         if(s==\" \")\\n         {\\n             return true;\\n         }\\n          string s1=\"\";\\n          int i=0;\\n          while(i<s.length())\\n          {   \\n              int c=s[i];\\n              if(c>=48 && c<=57)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              else if(c>=65 && c<=90)\\n              {\\n                   s1=s1+s[i];\\n              }\\n              else if(c>=97 && c<=122)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              i++;\\n          }\\n          int j=s1.length()-1;\\n          int size=s1.length()-1;\\n          i=0;\\n          int count=0;\\n          while(i<=j)\\n          {\\n               if(tolower(s1[i])!=tolower(s1[j]))\\n               {\\n                   return false;\\n               }\\n               i++;\\n               j--;\\n          }\\n          return true;\\n        \\n    } this code gives me memory limit exit ?What should i do now ? This code passes 479/485 test cases."
                    },
                    {
                        "username": "anandjha123",
                        "content": "why is it showing memory limit exceed at 479th test case"
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "even i am also getting the same and till now i haven\\'t understood why it is happening"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I'm just curious. People who have used regex to solve this, do you guys Google? Or actually memorized it before?"
                    },
                    {
                        "username": "pritam2026",
                        "content": "if u have prob in this test case \"0P\" ..then pls read this line again ---\\n removing all non-alphanumeric characters -- which means u have to take these characters in the final string 0-9 && a-z && A-Z... ...so ofc now 0P should be not a palindrome .."
                    },
                    {
                        "username": "agraavi786",
                        "content": "Class Solution {\\n    public boolean isPalindrome(String s) {\\n        String s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=Character.toLowerCase(s.charAt(i));\\n            if(\\'a\\'<=c && c<=\\'z\\' || \\'0\\'<=c && c<=\\'9\\'){\\n                s1=s1+c;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s1);\\n        if(s1.equals(sb.reverse().toString())){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\nUsing String Builder "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Why does my code keep getting Runtime Error?? Thought my function worked fine...\\n\\nfunction equals(str){\\nlet str1 = str.split(/\\\\W/).join(\"\").toLowerCase()\\nlet str2 = str1.split(\"\").reverse().join(\"\")\\nif(str1 == str2){\\n  return true\\n}else{\\nreturn false\\n}\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "Tips : \n1. Remove Non-Alphanumeric Characters: Remove non-alphanumeric characters and convert the string to lowercase.\n2. Compare Forward and Backward: Compare the modified string with its reverse to check if it's a palindrome.\n\n\nclass Solution {\n\n    public boolean isPalindrome(String s) {\n\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int start = 0;\n        int end = s.length()-1;\n\n        while(start < end){\n            if(s.charAt(start) != s.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "what should i do for memory limit exceeded ?.... i have applied correct logic and it\\'s passing on 479/485 test cases and after that it\\'s showing memory limit exceeded."
                    },
                    {
                        "username": "leto_atreides2",
                        "content": "This problem supposes using regular expression?"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I don\\'t think so. It\\'s unnecessary. You can use two pointer approach "
                    }
                ]
            },
            {
                "id": 2069780,
                "content": [
                    {
                        "username": "underdogsrijan",
                        "content": "testcase no 462 is wrong, s = \"0P\" in this testcase but and expected output is false, it simply means that the question is considering \\'0\\', but it is not mentioned in question"
                    },
                    {
                        "username": "BlakeE",
                        "content": "alphanumeric means to include both letters and digits. Only remove symbols, spaces, and special chars. Digits and numbers are valid"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "bool isPalindrome(string s) {\\n         if(s==\" \")\\n         {\\n             return true;\\n         }\\n          string s1=\"\";\\n          int i=0;\\n          while(i<s.length())\\n          {   \\n              int c=s[i];\\n              if(c>=48 && c<=57)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              else if(c>=65 && c<=90)\\n              {\\n                   s1=s1+s[i];\\n              }\\n              else if(c>=97 && c<=122)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              i++;\\n          }\\n          int j=s1.length()-1;\\n          int size=s1.length()-1;\\n          i=0;\\n          int count=0;\\n          while(i<=j)\\n          {\\n               if(tolower(s1[i])!=tolower(s1[j]))\\n               {\\n                   return false;\\n               }\\n               i++;\\n               j--;\\n          }\\n          return true;\\n        \\n    } this code gives me memory limit exit ?What should i do now ? This code passes 479/485 test cases."
                    },
                    {
                        "username": "anandjha123",
                        "content": "why is it showing memory limit exceed at 479th test case"
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "even i am also getting the same and till now i haven\\'t understood why it is happening"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I'm just curious. People who have used regex to solve this, do you guys Google? Or actually memorized it before?"
                    },
                    {
                        "username": "pritam2026",
                        "content": "if u have prob in this test case \"0P\" ..then pls read this line again ---\\n removing all non-alphanumeric characters -- which means u have to take these characters in the final string 0-9 && a-z && A-Z... ...so ofc now 0P should be not a palindrome .."
                    },
                    {
                        "username": "agraavi786",
                        "content": "Class Solution {\\n    public boolean isPalindrome(String s) {\\n        String s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=Character.toLowerCase(s.charAt(i));\\n            if(\\'a\\'<=c && c<=\\'z\\' || \\'0\\'<=c && c<=\\'9\\'){\\n                s1=s1+c;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s1);\\n        if(s1.equals(sb.reverse().toString())){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\nUsing String Builder "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Why does my code keep getting Runtime Error?? Thought my function worked fine...\\n\\nfunction equals(str){\\nlet str1 = str.split(/\\\\W/).join(\"\").toLowerCase()\\nlet str2 = str1.split(\"\").reverse().join(\"\")\\nif(str1 == str2){\\n  return true\\n}else{\\nreturn false\\n}\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "Tips : \n1. Remove Non-Alphanumeric Characters: Remove non-alphanumeric characters and convert the string to lowercase.\n2. Compare Forward and Backward: Compare the modified string with its reverse to check if it's a palindrome.\n\n\nclass Solution {\n\n    public boolean isPalindrome(String s) {\n\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int start = 0;\n        int end = s.length()-1;\n\n        while(start < end){\n            if(s.charAt(start) != s.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "what should i do for memory limit exceeded ?.... i have applied correct logic and it\\'s passing on 479/485 test cases and after that it\\'s showing memory limit exceeded."
                    },
                    {
                        "username": "leto_atreides2",
                        "content": "This problem supposes using regular expression?"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I don\\'t think so. It\\'s unnecessary. You can use two pointer approach "
                    }
                ]
            },
            {
                "id": 2069497,
                "content": [
                    {
                        "username": "underdogsrijan",
                        "content": "testcase no 462 is wrong, s = \"0P\" in this testcase but and expected output is false, it simply means that the question is considering \\'0\\', but it is not mentioned in question"
                    },
                    {
                        "username": "BlakeE",
                        "content": "alphanumeric means to include both letters and digits. Only remove symbols, spaces, and special chars. Digits and numbers are valid"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "bool isPalindrome(string s) {\\n         if(s==\" \")\\n         {\\n             return true;\\n         }\\n          string s1=\"\";\\n          int i=0;\\n          while(i<s.length())\\n          {   \\n              int c=s[i];\\n              if(c>=48 && c<=57)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              else if(c>=65 && c<=90)\\n              {\\n                   s1=s1+s[i];\\n              }\\n              else if(c>=97 && c<=122)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              i++;\\n          }\\n          int j=s1.length()-1;\\n          int size=s1.length()-1;\\n          i=0;\\n          int count=0;\\n          while(i<=j)\\n          {\\n               if(tolower(s1[i])!=tolower(s1[j]))\\n               {\\n                   return false;\\n               }\\n               i++;\\n               j--;\\n          }\\n          return true;\\n        \\n    } this code gives me memory limit exit ?What should i do now ? This code passes 479/485 test cases."
                    },
                    {
                        "username": "anandjha123",
                        "content": "why is it showing memory limit exceed at 479th test case"
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "even i am also getting the same and till now i haven\\'t understood why it is happening"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I'm just curious. People who have used regex to solve this, do you guys Google? Or actually memorized it before?"
                    },
                    {
                        "username": "pritam2026",
                        "content": "if u have prob in this test case \"0P\" ..then pls read this line again ---\\n removing all non-alphanumeric characters -- which means u have to take these characters in the final string 0-9 && a-z && A-Z... ...so ofc now 0P should be not a palindrome .."
                    },
                    {
                        "username": "agraavi786",
                        "content": "Class Solution {\\n    public boolean isPalindrome(String s) {\\n        String s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=Character.toLowerCase(s.charAt(i));\\n            if(\\'a\\'<=c && c<=\\'z\\' || \\'0\\'<=c && c<=\\'9\\'){\\n                s1=s1+c;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s1);\\n        if(s1.equals(sb.reverse().toString())){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\nUsing String Builder "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Why does my code keep getting Runtime Error?? Thought my function worked fine...\\n\\nfunction equals(str){\\nlet str1 = str.split(/\\\\W/).join(\"\").toLowerCase()\\nlet str2 = str1.split(\"\").reverse().join(\"\")\\nif(str1 == str2){\\n  return true\\n}else{\\nreturn false\\n}\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "Tips : \n1. Remove Non-Alphanumeric Characters: Remove non-alphanumeric characters and convert the string to lowercase.\n2. Compare Forward and Backward: Compare the modified string with its reverse to check if it's a palindrome.\n\n\nclass Solution {\n\n    public boolean isPalindrome(String s) {\n\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int start = 0;\n        int end = s.length()-1;\n\n        while(start < end){\n            if(s.charAt(start) != s.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "what should i do for memory limit exceeded ?.... i have applied correct logic and it\\'s passing on 479/485 test cases and after that it\\'s showing memory limit exceeded."
                    },
                    {
                        "username": "leto_atreides2",
                        "content": "This problem supposes using regular expression?"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I don\\'t think so. It\\'s unnecessary. You can use two pointer approach "
                    }
                ]
            },
            {
                "id": 2066191,
                "content": [
                    {
                        "username": "underdogsrijan",
                        "content": "testcase no 462 is wrong, s = \"0P\" in this testcase but and expected output is false, it simply means that the question is considering \\'0\\', but it is not mentioned in question"
                    },
                    {
                        "username": "BlakeE",
                        "content": "alphanumeric means to include both letters and digits. Only remove symbols, spaces, and special chars. Digits and numbers are valid"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "bool isPalindrome(string s) {\\n         if(s==\" \")\\n         {\\n             return true;\\n         }\\n          string s1=\"\";\\n          int i=0;\\n          while(i<s.length())\\n          {   \\n              int c=s[i];\\n              if(c>=48 && c<=57)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              else if(c>=65 && c<=90)\\n              {\\n                   s1=s1+s[i];\\n              }\\n              else if(c>=97 && c<=122)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              i++;\\n          }\\n          int j=s1.length()-1;\\n          int size=s1.length()-1;\\n          i=0;\\n          int count=0;\\n          while(i<=j)\\n          {\\n               if(tolower(s1[i])!=tolower(s1[j]))\\n               {\\n                   return false;\\n               }\\n               i++;\\n               j--;\\n          }\\n          return true;\\n        \\n    } this code gives me memory limit exit ?What should i do now ? This code passes 479/485 test cases."
                    },
                    {
                        "username": "anandjha123",
                        "content": "why is it showing memory limit exceed at 479th test case"
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "even i am also getting the same and till now i haven\\'t understood why it is happening"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I'm just curious. People who have used regex to solve this, do you guys Google? Or actually memorized it before?"
                    },
                    {
                        "username": "pritam2026",
                        "content": "if u have prob in this test case \"0P\" ..then pls read this line again ---\\n removing all non-alphanumeric characters -- which means u have to take these characters in the final string 0-9 && a-z && A-Z... ...so ofc now 0P should be not a palindrome .."
                    },
                    {
                        "username": "agraavi786",
                        "content": "Class Solution {\\n    public boolean isPalindrome(String s) {\\n        String s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=Character.toLowerCase(s.charAt(i));\\n            if(\\'a\\'<=c && c<=\\'z\\' || \\'0\\'<=c && c<=\\'9\\'){\\n                s1=s1+c;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s1);\\n        if(s1.equals(sb.reverse().toString())){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\nUsing String Builder "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Why does my code keep getting Runtime Error?? Thought my function worked fine...\\n\\nfunction equals(str){\\nlet str1 = str.split(/\\\\W/).join(\"\").toLowerCase()\\nlet str2 = str1.split(\"\").reverse().join(\"\")\\nif(str1 == str2){\\n  return true\\n}else{\\nreturn false\\n}\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "Tips : \n1. Remove Non-Alphanumeric Characters: Remove non-alphanumeric characters and convert the string to lowercase.\n2. Compare Forward and Backward: Compare the modified string with its reverse to check if it's a palindrome.\n\n\nclass Solution {\n\n    public boolean isPalindrome(String s) {\n\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int start = 0;\n        int end = s.length()-1;\n\n        while(start < end){\n            if(s.charAt(start) != s.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "what should i do for memory limit exceeded ?.... i have applied correct logic and it\\'s passing on 479/485 test cases and after that it\\'s showing memory limit exceeded."
                    },
                    {
                        "username": "leto_atreides2",
                        "content": "This problem supposes using regular expression?"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I don\\'t think so. It\\'s unnecessary. You can use two pointer approach "
                    }
                ]
            },
            {
                "id": 2065735,
                "content": [
                    {
                        "username": "underdogsrijan",
                        "content": "testcase no 462 is wrong, s = \"0P\" in this testcase but and expected output is false, it simply means that the question is considering \\'0\\', but it is not mentioned in question"
                    },
                    {
                        "username": "BlakeE",
                        "content": "alphanumeric means to include both letters and digits. Only remove symbols, spaces, and special chars. Digits and numbers are valid"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "bool isPalindrome(string s) {\\n         if(s==\" \")\\n         {\\n             return true;\\n         }\\n          string s1=\"\";\\n          int i=0;\\n          while(i<s.length())\\n          {   \\n              int c=s[i];\\n              if(c>=48 && c<=57)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              else if(c>=65 && c<=90)\\n              {\\n                   s1=s1+s[i];\\n              }\\n              else if(c>=97 && c<=122)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              i++;\\n          }\\n          int j=s1.length()-1;\\n          int size=s1.length()-1;\\n          i=0;\\n          int count=0;\\n          while(i<=j)\\n          {\\n               if(tolower(s1[i])!=tolower(s1[j]))\\n               {\\n                   return false;\\n               }\\n               i++;\\n               j--;\\n          }\\n          return true;\\n        \\n    } this code gives me memory limit exit ?What should i do now ? This code passes 479/485 test cases."
                    },
                    {
                        "username": "anandjha123",
                        "content": "why is it showing memory limit exceed at 479th test case"
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "even i am also getting the same and till now i haven\\'t understood why it is happening"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I'm just curious. People who have used regex to solve this, do you guys Google? Or actually memorized it before?"
                    },
                    {
                        "username": "pritam2026",
                        "content": "if u have prob in this test case \"0P\" ..then pls read this line again ---\\n removing all non-alphanumeric characters -- which means u have to take these characters in the final string 0-9 && a-z && A-Z... ...so ofc now 0P should be not a palindrome .."
                    },
                    {
                        "username": "agraavi786",
                        "content": "Class Solution {\\n    public boolean isPalindrome(String s) {\\n        String s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=Character.toLowerCase(s.charAt(i));\\n            if(\\'a\\'<=c && c<=\\'z\\' || \\'0\\'<=c && c<=\\'9\\'){\\n                s1=s1+c;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s1);\\n        if(s1.equals(sb.reverse().toString())){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\nUsing String Builder "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Why does my code keep getting Runtime Error?? Thought my function worked fine...\\n\\nfunction equals(str){\\nlet str1 = str.split(/\\\\W/).join(\"\").toLowerCase()\\nlet str2 = str1.split(\"\").reverse().join(\"\")\\nif(str1 == str2){\\n  return true\\n}else{\\nreturn false\\n}\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "Tips : \n1. Remove Non-Alphanumeric Characters: Remove non-alphanumeric characters and convert the string to lowercase.\n2. Compare Forward and Backward: Compare the modified string with its reverse to check if it's a palindrome.\n\n\nclass Solution {\n\n    public boolean isPalindrome(String s) {\n\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int start = 0;\n        int end = s.length()-1;\n\n        while(start < end){\n            if(s.charAt(start) != s.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "what should i do for memory limit exceeded ?.... i have applied correct logic and it\\'s passing on 479/485 test cases and after that it\\'s showing memory limit exceeded."
                    },
                    {
                        "username": "leto_atreides2",
                        "content": "This problem supposes using regular expression?"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I don\\'t think so. It\\'s unnecessary. You can use two pointer approach "
                    }
                ]
            },
            {
                "id": 2061900,
                "content": [
                    {
                        "username": "underdogsrijan",
                        "content": "testcase no 462 is wrong, s = \"0P\" in this testcase but and expected output is false, it simply means that the question is considering \\'0\\', but it is not mentioned in question"
                    },
                    {
                        "username": "BlakeE",
                        "content": "alphanumeric means to include both letters and digits. Only remove symbols, spaces, and special chars. Digits and numbers are valid"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "bool isPalindrome(string s) {\\n         if(s==\" \")\\n         {\\n             return true;\\n         }\\n          string s1=\"\";\\n          int i=0;\\n          while(i<s.length())\\n          {   \\n              int c=s[i];\\n              if(c>=48 && c<=57)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              else if(c>=65 && c<=90)\\n              {\\n                   s1=s1+s[i];\\n              }\\n              else if(c>=97 && c<=122)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              i++;\\n          }\\n          int j=s1.length()-1;\\n          int size=s1.length()-1;\\n          i=0;\\n          int count=0;\\n          while(i<=j)\\n          {\\n               if(tolower(s1[i])!=tolower(s1[j]))\\n               {\\n                   return false;\\n               }\\n               i++;\\n               j--;\\n          }\\n          return true;\\n        \\n    } this code gives me memory limit exit ?What should i do now ? This code passes 479/485 test cases."
                    },
                    {
                        "username": "anandjha123",
                        "content": "why is it showing memory limit exceed at 479th test case"
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "even i am also getting the same and till now i haven\\'t understood why it is happening"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I'm just curious. People who have used regex to solve this, do you guys Google? Or actually memorized it before?"
                    },
                    {
                        "username": "pritam2026",
                        "content": "if u have prob in this test case \"0P\" ..then pls read this line again ---\\n removing all non-alphanumeric characters -- which means u have to take these characters in the final string 0-9 && a-z && A-Z... ...so ofc now 0P should be not a palindrome .."
                    },
                    {
                        "username": "agraavi786",
                        "content": "Class Solution {\\n    public boolean isPalindrome(String s) {\\n        String s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=Character.toLowerCase(s.charAt(i));\\n            if(\\'a\\'<=c && c<=\\'z\\' || \\'0\\'<=c && c<=\\'9\\'){\\n                s1=s1+c;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s1);\\n        if(s1.equals(sb.reverse().toString())){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\nUsing String Builder "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Why does my code keep getting Runtime Error?? Thought my function worked fine...\\n\\nfunction equals(str){\\nlet str1 = str.split(/\\\\W/).join(\"\").toLowerCase()\\nlet str2 = str1.split(\"\").reverse().join(\"\")\\nif(str1 == str2){\\n  return true\\n}else{\\nreturn false\\n}\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "Tips : \n1. Remove Non-Alphanumeric Characters: Remove non-alphanumeric characters and convert the string to lowercase.\n2. Compare Forward and Backward: Compare the modified string with its reverse to check if it's a palindrome.\n\n\nclass Solution {\n\n    public boolean isPalindrome(String s) {\n\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int start = 0;\n        int end = s.length()-1;\n\n        while(start < end){\n            if(s.charAt(start) != s.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "what should i do for memory limit exceeded ?.... i have applied correct logic and it\\'s passing on 479/485 test cases and after that it\\'s showing memory limit exceeded."
                    },
                    {
                        "username": "leto_atreides2",
                        "content": "This problem supposes using regular expression?"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I don\\'t think so. It\\'s unnecessary. You can use two pointer approach "
                    }
                ]
            },
            {
                "id": 2056782,
                "content": [
                    {
                        "username": "underdogsrijan",
                        "content": "testcase no 462 is wrong, s = \"0P\" in this testcase but and expected output is false, it simply means that the question is considering \\'0\\', but it is not mentioned in question"
                    },
                    {
                        "username": "BlakeE",
                        "content": "alphanumeric means to include both letters and digits. Only remove symbols, spaces, and special chars. Digits and numbers are valid"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "bool isPalindrome(string s) {\\n         if(s==\" \")\\n         {\\n             return true;\\n         }\\n          string s1=\"\";\\n          int i=0;\\n          while(i<s.length())\\n          {   \\n              int c=s[i];\\n              if(c>=48 && c<=57)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              else if(c>=65 && c<=90)\\n              {\\n                   s1=s1+s[i];\\n              }\\n              else if(c>=97 && c<=122)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              i++;\\n          }\\n          int j=s1.length()-1;\\n          int size=s1.length()-1;\\n          i=0;\\n          int count=0;\\n          while(i<=j)\\n          {\\n               if(tolower(s1[i])!=tolower(s1[j]))\\n               {\\n                   return false;\\n               }\\n               i++;\\n               j--;\\n          }\\n          return true;\\n        \\n    } this code gives me memory limit exit ?What should i do now ? This code passes 479/485 test cases."
                    },
                    {
                        "username": "anandjha123",
                        "content": "why is it showing memory limit exceed at 479th test case"
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "even i am also getting the same and till now i haven\\'t understood why it is happening"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I'm just curious. People who have used regex to solve this, do you guys Google? Or actually memorized it before?"
                    },
                    {
                        "username": "pritam2026",
                        "content": "if u have prob in this test case \"0P\" ..then pls read this line again ---\\n removing all non-alphanumeric characters -- which means u have to take these characters in the final string 0-9 && a-z && A-Z... ...so ofc now 0P should be not a palindrome .."
                    },
                    {
                        "username": "agraavi786",
                        "content": "Class Solution {\\n    public boolean isPalindrome(String s) {\\n        String s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=Character.toLowerCase(s.charAt(i));\\n            if(\\'a\\'<=c && c<=\\'z\\' || \\'0\\'<=c && c<=\\'9\\'){\\n                s1=s1+c;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s1);\\n        if(s1.equals(sb.reverse().toString())){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\nUsing String Builder "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Why does my code keep getting Runtime Error?? Thought my function worked fine...\\n\\nfunction equals(str){\\nlet str1 = str.split(/\\\\W/).join(\"\").toLowerCase()\\nlet str2 = str1.split(\"\").reverse().join(\"\")\\nif(str1 == str2){\\n  return true\\n}else{\\nreturn false\\n}\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "Tips : \n1. Remove Non-Alphanumeric Characters: Remove non-alphanumeric characters and convert the string to lowercase.\n2. Compare Forward and Backward: Compare the modified string with its reverse to check if it's a palindrome.\n\n\nclass Solution {\n\n    public boolean isPalindrome(String s) {\n\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int start = 0;\n        int end = s.length()-1;\n\n        while(start < end){\n            if(s.charAt(start) != s.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "what should i do for memory limit exceeded ?.... i have applied correct logic and it\\'s passing on 479/485 test cases and after that it\\'s showing memory limit exceeded."
                    },
                    {
                        "username": "leto_atreides2",
                        "content": "This problem supposes using regular expression?"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I don\\'t think so. It\\'s unnecessary. You can use two pointer approach "
                    }
                ]
            },
            {
                "id": 2045795,
                "content": [
                    {
                        "username": "underdogsrijan",
                        "content": "testcase no 462 is wrong, s = \"0P\" in this testcase but and expected output is false, it simply means that the question is considering \\'0\\', but it is not mentioned in question"
                    },
                    {
                        "username": "BlakeE",
                        "content": "alphanumeric means to include both letters and digits. Only remove symbols, spaces, and special chars. Digits and numbers are valid"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "bool isPalindrome(string s) {\\n         if(s==\" \")\\n         {\\n             return true;\\n         }\\n          string s1=\"\";\\n          int i=0;\\n          while(i<s.length())\\n          {   \\n              int c=s[i];\\n              if(c>=48 && c<=57)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              else if(c>=65 && c<=90)\\n              {\\n                   s1=s1+s[i];\\n              }\\n              else if(c>=97 && c<=122)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              i++;\\n          }\\n          int j=s1.length()-1;\\n          int size=s1.length()-1;\\n          i=0;\\n          int count=0;\\n          while(i<=j)\\n          {\\n               if(tolower(s1[i])!=tolower(s1[j]))\\n               {\\n                   return false;\\n               }\\n               i++;\\n               j--;\\n          }\\n          return true;\\n        \\n    } this code gives me memory limit exit ?What should i do now ? This code passes 479/485 test cases."
                    },
                    {
                        "username": "anandjha123",
                        "content": "why is it showing memory limit exceed at 479th test case"
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "even i am also getting the same and till now i haven\\'t understood why it is happening"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I'm just curious. People who have used regex to solve this, do you guys Google? Or actually memorized it before?"
                    },
                    {
                        "username": "pritam2026",
                        "content": "if u have prob in this test case \"0P\" ..then pls read this line again ---\\n removing all non-alphanumeric characters -- which means u have to take these characters in the final string 0-9 && a-z && A-Z... ...so ofc now 0P should be not a palindrome .."
                    },
                    {
                        "username": "agraavi786",
                        "content": "Class Solution {\\n    public boolean isPalindrome(String s) {\\n        String s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=Character.toLowerCase(s.charAt(i));\\n            if(\\'a\\'<=c && c<=\\'z\\' || \\'0\\'<=c && c<=\\'9\\'){\\n                s1=s1+c;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s1);\\n        if(s1.equals(sb.reverse().toString())){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\nUsing String Builder "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Why does my code keep getting Runtime Error?? Thought my function worked fine...\\n\\nfunction equals(str){\\nlet str1 = str.split(/\\\\W/).join(\"\").toLowerCase()\\nlet str2 = str1.split(\"\").reverse().join(\"\")\\nif(str1 == str2){\\n  return true\\n}else{\\nreturn false\\n}\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "Tips : \n1. Remove Non-Alphanumeric Characters: Remove non-alphanumeric characters and convert the string to lowercase.\n2. Compare Forward and Backward: Compare the modified string with its reverse to check if it's a palindrome.\n\n\nclass Solution {\n\n    public boolean isPalindrome(String s) {\n\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int start = 0;\n        int end = s.length()-1;\n\n        while(start < end){\n            if(s.charAt(start) != s.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "what should i do for memory limit exceeded ?.... i have applied correct logic and it\\'s passing on 479/485 test cases and after that it\\'s showing memory limit exceeded."
                    },
                    {
                        "username": "leto_atreides2",
                        "content": "This problem supposes using regular expression?"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I don\\'t think so. It\\'s unnecessary. You can use two pointer approach "
                    }
                ]
            },
            {
                "id": 2043078,
                "content": [
                    {
                        "username": "underdogsrijan",
                        "content": "testcase no 462 is wrong, s = \"0P\" in this testcase but and expected output is false, it simply means that the question is considering \\'0\\', but it is not mentioned in question"
                    },
                    {
                        "username": "BlakeE",
                        "content": "alphanumeric means to include both letters and digits. Only remove symbols, spaces, and special chars. Digits and numbers are valid"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "bool isPalindrome(string s) {\\n         if(s==\" \")\\n         {\\n             return true;\\n         }\\n          string s1=\"\";\\n          int i=0;\\n          while(i<s.length())\\n          {   \\n              int c=s[i];\\n              if(c>=48 && c<=57)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              else if(c>=65 && c<=90)\\n              {\\n                   s1=s1+s[i];\\n              }\\n              else if(c>=97 && c<=122)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              i++;\\n          }\\n          int j=s1.length()-1;\\n          int size=s1.length()-1;\\n          i=0;\\n          int count=0;\\n          while(i<=j)\\n          {\\n               if(tolower(s1[i])!=tolower(s1[j]))\\n               {\\n                   return false;\\n               }\\n               i++;\\n               j--;\\n          }\\n          return true;\\n        \\n    } this code gives me memory limit exit ?What should i do now ? This code passes 479/485 test cases."
                    },
                    {
                        "username": "anandjha123",
                        "content": "why is it showing memory limit exceed at 479th test case"
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "even i am also getting the same and till now i haven\\'t understood why it is happening"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I'm just curious. People who have used regex to solve this, do you guys Google? Or actually memorized it before?"
                    },
                    {
                        "username": "pritam2026",
                        "content": "if u have prob in this test case \"0P\" ..then pls read this line again ---\\n removing all non-alphanumeric characters -- which means u have to take these characters in the final string 0-9 && a-z && A-Z... ...so ofc now 0P should be not a palindrome .."
                    },
                    {
                        "username": "agraavi786",
                        "content": "Class Solution {\\n    public boolean isPalindrome(String s) {\\n        String s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=Character.toLowerCase(s.charAt(i));\\n            if(\\'a\\'<=c && c<=\\'z\\' || \\'0\\'<=c && c<=\\'9\\'){\\n                s1=s1+c;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s1);\\n        if(s1.equals(sb.reverse().toString())){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\nUsing String Builder "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Why does my code keep getting Runtime Error?? Thought my function worked fine...\\n\\nfunction equals(str){\\nlet str1 = str.split(/\\\\W/).join(\"\").toLowerCase()\\nlet str2 = str1.split(\"\").reverse().join(\"\")\\nif(str1 == str2){\\n  return true\\n}else{\\nreturn false\\n}\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "Tips : \n1. Remove Non-Alphanumeric Characters: Remove non-alphanumeric characters and convert the string to lowercase.\n2. Compare Forward and Backward: Compare the modified string with its reverse to check if it's a palindrome.\n\n\nclass Solution {\n\n    public boolean isPalindrome(String s) {\n\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int start = 0;\n        int end = s.length()-1;\n\n        while(start < end){\n            if(s.charAt(start) != s.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "what should i do for memory limit exceeded ?.... i have applied correct logic and it\\'s passing on 479/485 test cases and after that it\\'s showing memory limit exceeded."
                    },
                    {
                        "username": "leto_atreides2",
                        "content": "This problem supposes using regular expression?"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I don\\'t think so. It\\'s unnecessary. You can use two pointer approach "
                    }
                ]
            },
            {
                "id": 2042970,
                "content": [
                    {
                        "username": "underdogsrijan",
                        "content": "testcase no 462 is wrong, s = \"0P\" in this testcase but and expected output is false, it simply means that the question is considering \\'0\\', but it is not mentioned in question"
                    },
                    {
                        "username": "BlakeE",
                        "content": "alphanumeric means to include both letters and digits. Only remove symbols, spaces, and special chars. Digits and numbers are valid"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "bool isPalindrome(string s) {\\n         if(s==\" \")\\n         {\\n             return true;\\n         }\\n          string s1=\"\";\\n          int i=0;\\n          while(i<s.length())\\n          {   \\n              int c=s[i];\\n              if(c>=48 && c<=57)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              else if(c>=65 && c<=90)\\n              {\\n                   s1=s1+s[i];\\n              }\\n              else if(c>=97 && c<=122)\\n              {\\n                  s1=s1+s[i];\\n              }\\n              i++;\\n          }\\n          int j=s1.length()-1;\\n          int size=s1.length()-1;\\n          i=0;\\n          int count=0;\\n          while(i<=j)\\n          {\\n               if(tolower(s1[i])!=tolower(s1[j]))\\n               {\\n                   return false;\\n               }\\n               i++;\\n               j--;\\n          }\\n          return true;\\n        \\n    } this code gives me memory limit exit ?What should i do now ? This code passes 479/485 test cases."
                    },
                    {
                        "username": "anandjha123",
                        "content": "why is it showing memory limit exceed at 479th test case"
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "even i am also getting the same and till now i haven\\'t understood why it is happening"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I'm just curious. People who have used regex to solve this, do you guys Google? Or actually memorized it before?"
                    },
                    {
                        "username": "pritam2026",
                        "content": "if u have prob in this test case \"0P\" ..then pls read this line again ---\\n removing all non-alphanumeric characters -- which means u have to take these characters in the final string 0-9 && a-z && A-Z... ...so ofc now 0P should be not a palindrome .."
                    },
                    {
                        "username": "agraavi786",
                        "content": "Class Solution {\\n    public boolean isPalindrome(String s) {\\n        String s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=Character.toLowerCase(s.charAt(i));\\n            if(\\'a\\'<=c && c<=\\'z\\' || \\'0\\'<=c && c<=\\'9\\'){\\n                s1=s1+c;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s1);\\n        if(s1.equals(sb.reverse().toString())){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\nUsing String Builder "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Why does my code keep getting Runtime Error?? Thought my function worked fine...\\n\\nfunction equals(str){\\nlet str1 = str.split(/\\\\W/).join(\"\").toLowerCase()\\nlet str2 = str1.split(\"\").reverse().join(\"\")\\nif(str1 == str2){\\n  return true\\n}else{\\nreturn false\\n}\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "Tips : \n1. Remove Non-Alphanumeric Characters: Remove non-alphanumeric characters and convert the string to lowercase.\n2. Compare Forward and Backward: Compare the modified string with its reverse to check if it's a palindrome.\n\n\nclass Solution {\n\n    public boolean isPalindrome(String s) {\n\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int start = 0;\n        int end = s.length()-1;\n\n        while(start < end){\n            if(s.charAt(start) != s.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shikharjoshi500",
                        "content": "what should i do for memory limit exceeded ?.... i have applied correct logic and it\\'s passing on 479/485 test cases and after that it\\'s showing memory limit exceeded."
                    },
                    {
                        "username": "leto_atreides2",
                        "content": "This problem supposes using regular expression?"
                    },
                    {
                        "username": "useNavigate",
                        "content": "I don\\'t think so. It\\'s unnecessary. You can use two pointer approach "
                    }
                ]
            },
            {
                "id": 2039643,
                "content": [
                    {
                        "username": "Nukealbert",
                        "content": "\"ab_a\"\\n\\ncan anyone explain, how this is palindrome?"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "underscore will be removed as it is non alphanumeric so the palindrome become\" aba\"."
                    },
                    {
                        "username": "bijendraut",
                        "content": "_ is a non-alphanumeric so it will be removed... then it will become \"aba\" which is a palindrome"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "// if(isalnum(s[i]))\\n            // return false;\\ncan i handle alphanumeric with this??\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: The question states removing all non-alphanumeric characters.  \\nNumber are allowed in the string or simple put Range[48-57] is allowed"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "TO ALL WHO ARE GETTING DIFFICULTY IN TESTCASE \"0P\"\\n\\nrite 0 and 9 in single quotes like this if (s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n\\nTHANK ME LATER;)"
                    },
                    {
                        "username": "vinaypatil11101",
                        "content": "we can use isdigit in c++"
                    },
                    {
                        "username": "aahanakulkarni12",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = \"\";\\n        if(s.length()<2){\\n            return true;\\n        }\\n        s.toLowerCase();\\n        for(int i=0;i<s.length();i++){\\n                if(Character.isAlphabetic(s.charAt(i))){\\n                str = str + s.charAt(i);\\n            }\\n        }\\n        if(str.length()<2){\\n            return true;\\n        }\\n        \\n        int left =0;\\n        int right =str.length()-1;\\n        int flag = 1;\\n        while(left<=right){\\n            if(str.charAt(left)==str.charAt(right)){\\n               flag = 0;\\n            }\\n            else{\\n                flag=1;\\n                \\n            }\\n            left++;\\n            right--;\\n        }\\n        if(flag==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n this code is failing the testcase \"aA\" but passing one where lowercase is considered same as uppercase \\nand one with even characters "
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "how to use palindrome \\n"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "Just tell how string \"abb\" is not palidrome. If we rearrange it it will be \"bab\" so,  why it expected output is false."
                    },
                    {
                        "username": "StephenYYoon",
                        "content": "The question does not state that you must check any rearrangements to be a palindrome, \"abb\" backwards  is \"bba\", \"abb\" != \"bba\""
                    },
                    {
                        "username": "rcon9494",
                        "content": "For the sake of your sanity, I recommend adding the below to the testcases before trying to submit:\n`\"0P\"`, `\".a\"`,`\"ab_a\"`\n\nGLHF!"
                    },
                    {
                        "username": "Laksh_Jain",
                        "content": "Why does using i and n-i-1 as two pointers doesn\\'t work for first Case?"
                    },
                    {
                        "username": "rajesh_9711",
                        "content": "below code show me memory limit exceed only for the case of  empty string during submit.\\nanone?\\ns = \"\";\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp = \"\";\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            if(s[i]>=\\'A\\' and s[i]<=\\'Z\\'){\\n                char ch = s[i]+32;\\n                temp = temp+ch;\\n            }\\n            else if(s[i]>=\\'a\\' and s[i]<=\\'z\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                temp = temp+s[i];\\n            }\\n\\n        }\\n        cout<<temp;\\n        int i = 0,j = temp.size()-1;\\n        while(i<=j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2039472,
                "content": [
                    {
                        "username": "Nukealbert",
                        "content": "\"ab_a\"\\n\\ncan anyone explain, how this is palindrome?"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "underscore will be removed as it is non alphanumeric so the palindrome become\" aba\"."
                    },
                    {
                        "username": "bijendraut",
                        "content": "_ is a non-alphanumeric so it will be removed... then it will become \"aba\" which is a palindrome"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "// if(isalnum(s[i]))\\n            // return false;\\ncan i handle alphanumeric with this??\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: The question states removing all non-alphanumeric characters.  \\nNumber are allowed in the string or simple put Range[48-57] is allowed"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "TO ALL WHO ARE GETTING DIFFICULTY IN TESTCASE \"0P\"\\n\\nrite 0 and 9 in single quotes like this if (s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n\\nTHANK ME LATER;)"
                    },
                    {
                        "username": "vinaypatil11101",
                        "content": "we can use isdigit in c++"
                    },
                    {
                        "username": "aahanakulkarni12",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = \"\";\\n        if(s.length()<2){\\n            return true;\\n        }\\n        s.toLowerCase();\\n        for(int i=0;i<s.length();i++){\\n                if(Character.isAlphabetic(s.charAt(i))){\\n                str = str + s.charAt(i);\\n            }\\n        }\\n        if(str.length()<2){\\n            return true;\\n        }\\n        \\n        int left =0;\\n        int right =str.length()-1;\\n        int flag = 1;\\n        while(left<=right){\\n            if(str.charAt(left)==str.charAt(right)){\\n               flag = 0;\\n            }\\n            else{\\n                flag=1;\\n                \\n            }\\n            left++;\\n            right--;\\n        }\\n        if(flag==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n this code is failing the testcase \"aA\" but passing one where lowercase is considered same as uppercase \\nand one with even characters "
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "how to use palindrome \\n"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "Just tell how string \"abb\" is not palidrome. If we rearrange it it will be \"bab\" so,  why it expected output is false."
                    },
                    {
                        "username": "StephenYYoon",
                        "content": "The question does not state that you must check any rearrangements to be a palindrome, \"abb\" backwards  is \"bba\", \"abb\" != \"bba\""
                    },
                    {
                        "username": "rcon9494",
                        "content": "For the sake of your sanity, I recommend adding the below to the testcases before trying to submit:\n`\"0P\"`, `\".a\"`,`\"ab_a\"`\n\nGLHF!"
                    },
                    {
                        "username": "Laksh_Jain",
                        "content": "Why does using i and n-i-1 as two pointers doesn\\'t work for first Case?"
                    },
                    {
                        "username": "rajesh_9711",
                        "content": "below code show me memory limit exceed only for the case of  empty string during submit.\\nanone?\\ns = \"\";\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp = \"\";\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            if(s[i]>=\\'A\\' and s[i]<=\\'Z\\'){\\n                char ch = s[i]+32;\\n                temp = temp+ch;\\n            }\\n            else if(s[i]>=\\'a\\' and s[i]<=\\'z\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                temp = temp+s[i];\\n            }\\n\\n        }\\n        cout<<temp;\\n        int i = 0,j = temp.size()-1;\\n        while(i<=j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2034692,
                "content": [
                    {
                        "username": "Nukealbert",
                        "content": "\"ab_a\"\\n\\ncan anyone explain, how this is palindrome?"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "underscore will be removed as it is non alphanumeric so the palindrome become\" aba\"."
                    },
                    {
                        "username": "bijendraut",
                        "content": "_ is a non-alphanumeric so it will be removed... then it will become \"aba\" which is a palindrome"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "// if(isalnum(s[i]))\\n            // return false;\\ncan i handle alphanumeric with this??\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: The question states removing all non-alphanumeric characters.  \\nNumber are allowed in the string or simple put Range[48-57] is allowed"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "TO ALL WHO ARE GETTING DIFFICULTY IN TESTCASE \"0P\"\\n\\nrite 0 and 9 in single quotes like this if (s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n\\nTHANK ME LATER;)"
                    },
                    {
                        "username": "vinaypatil11101",
                        "content": "we can use isdigit in c++"
                    },
                    {
                        "username": "aahanakulkarni12",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = \"\";\\n        if(s.length()<2){\\n            return true;\\n        }\\n        s.toLowerCase();\\n        for(int i=0;i<s.length();i++){\\n                if(Character.isAlphabetic(s.charAt(i))){\\n                str = str + s.charAt(i);\\n            }\\n        }\\n        if(str.length()<2){\\n            return true;\\n        }\\n        \\n        int left =0;\\n        int right =str.length()-1;\\n        int flag = 1;\\n        while(left<=right){\\n            if(str.charAt(left)==str.charAt(right)){\\n               flag = 0;\\n            }\\n            else{\\n                flag=1;\\n                \\n            }\\n            left++;\\n            right--;\\n        }\\n        if(flag==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n this code is failing the testcase \"aA\" but passing one where lowercase is considered same as uppercase \\nand one with even characters "
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "how to use palindrome \\n"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "Just tell how string \"abb\" is not palidrome. If we rearrange it it will be \"bab\" so,  why it expected output is false."
                    },
                    {
                        "username": "StephenYYoon",
                        "content": "The question does not state that you must check any rearrangements to be a palindrome, \"abb\" backwards  is \"bba\", \"abb\" != \"bba\""
                    },
                    {
                        "username": "rcon9494",
                        "content": "For the sake of your sanity, I recommend adding the below to the testcases before trying to submit:\n`\"0P\"`, `\".a\"`,`\"ab_a\"`\n\nGLHF!"
                    },
                    {
                        "username": "Laksh_Jain",
                        "content": "Why does using i and n-i-1 as two pointers doesn\\'t work for first Case?"
                    },
                    {
                        "username": "rajesh_9711",
                        "content": "below code show me memory limit exceed only for the case of  empty string during submit.\\nanone?\\ns = \"\";\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp = \"\";\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            if(s[i]>=\\'A\\' and s[i]<=\\'Z\\'){\\n                char ch = s[i]+32;\\n                temp = temp+ch;\\n            }\\n            else if(s[i]>=\\'a\\' and s[i]<=\\'z\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                temp = temp+s[i];\\n            }\\n\\n        }\\n        cout<<temp;\\n        int i = 0,j = temp.size()-1;\\n        while(i<=j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2034337,
                "content": [
                    {
                        "username": "Nukealbert",
                        "content": "\"ab_a\"\\n\\ncan anyone explain, how this is palindrome?"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "underscore will be removed as it is non alphanumeric so the palindrome become\" aba\"."
                    },
                    {
                        "username": "bijendraut",
                        "content": "_ is a non-alphanumeric so it will be removed... then it will become \"aba\" which is a palindrome"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "// if(isalnum(s[i]))\\n            // return false;\\ncan i handle alphanumeric with this??\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: The question states removing all non-alphanumeric characters.  \\nNumber are allowed in the string or simple put Range[48-57] is allowed"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "TO ALL WHO ARE GETTING DIFFICULTY IN TESTCASE \"0P\"\\n\\nrite 0 and 9 in single quotes like this if (s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n\\nTHANK ME LATER;)"
                    },
                    {
                        "username": "vinaypatil11101",
                        "content": "we can use isdigit in c++"
                    },
                    {
                        "username": "aahanakulkarni12",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = \"\";\\n        if(s.length()<2){\\n            return true;\\n        }\\n        s.toLowerCase();\\n        for(int i=0;i<s.length();i++){\\n                if(Character.isAlphabetic(s.charAt(i))){\\n                str = str + s.charAt(i);\\n            }\\n        }\\n        if(str.length()<2){\\n            return true;\\n        }\\n        \\n        int left =0;\\n        int right =str.length()-1;\\n        int flag = 1;\\n        while(left<=right){\\n            if(str.charAt(left)==str.charAt(right)){\\n               flag = 0;\\n            }\\n            else{\\n                flag=1;\\n                \\n            }\\n            left++;\\n            right--;\\n        }\\n        if(flag==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n this code is failing the testcase \"aA\" but passing one where lowercase is considered same as uppercase \\nand one with even characters "
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "how to use palindrome \\n"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "Just tell how string \"abb\" is not palidrome. If we rearrange it it will be \"bab\" so,  why it expected output is false."
                    },
                    {
                        "username": "StephenYYoon",
                        "content": "The question does not state that you must check any rearrangements to be a palindrome, \"abb\" backwards  is \"bba\", \"abb\" != \"bba\""
                    },
                    {
                        "username": "rcon9494",
                        "content": "For the sake of your sanity, I recommend adding the below to the testcases before trying to submit:\n`\"0P\"`, `\".a\"`,`\"ab_a\"`\n\nGLHF!"
                    },
                    {
                        "username": "Laksh_Jain",
                        "content": "Why does using i and n-i-1 as two pointers doesn\\'t work for first Case?"
                    },
                    {
                        "username": "rajesh_9711",
                        "content": "below code show me memory limit exceed only for the case of  empty string during submit.\\nanone?\\ns = \"\";\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp = \"\";\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            if(s[i]>=\\'A\\' and s[i]<=\\'Z\\'){\\n                char ch = s[i]+32;\\n                temp = temp+ch;\\n            }\\n            else if(s[i]>=\\'a\\' and s[i]<=\\'z\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                temp = temp+s[i];\\n            }\\n\\n        }\\n        cout<<temp;\\n        int i = 0,j = temp.size()-1;\\n        while(i<=j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2027411,
                "content": [
                    {
                        "username": "Nukealbert",
                        "content": "\"ab_a\"\\n\\ncan anyone explain, how this is palindrome?"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "underscore will be removed as it is non alphanumeric so the palindrome become\" aba\"."
                    },
                    {
                        "username": "bijendraut",
                        "content": "_ is a non-alphanumeric so it will be removed... then it will become \"aba\" which is a palindrome"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "// if(isalnum(s[i]))\\n            // return false;\\ncan i handle alphanumeric with this??\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: The question states removing all non-alphanumeric characters.  \\nNumber are allowed in the string or simple put Range[48-57] is allowed"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "TO ALL WHO ARE GETTING DIFFICULTY IN TESTCASE \"0P\"\\n\\nrite 0 and 9 in single quotes like this if (s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n\\nTHANK ME LATER;)"
                    },
                    {
                        "username": "vinaypatil11101",
                        "content": "we can use isdigit in c++"
                    },
                    {
                        "username": "aahanakulkarni12",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = \"\";\\n        if(s.length()<2){\\n            return true;\\n        }\\n        s.toLowerCase();\\n        for(int i=0;i<s.length();i++){\\n                if(Character.isAlphabetic(s.charAt(i))){\\n                str = str + s.charAt(i);\\n            }\\n        }\\n        if(str.length()<2){\\n            return true;\\n        }\\n        \\n        int left =0;\\n        int right =str.length()-1;\\n        int flag = 1;\\n        while(left<=right){\\n            if(str.charAt(left)==str.charAt(right)){\\n               flag = 0;\\n            }\\n            else{\\n                flag=1;\\n                \\n            }\\n            left++;\\n            right--;\\n        }\\n        if(flag==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n this code is failing the testcase \"aA\" but passing one where lowercase is considered same as uppercase \\nand one with even characters "
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "how to use palindrome \\n"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "Just tell how string \"abb\" is not palidrome. If we rearrange it it will be \"bab\" so,  why it expected output is false."
                    },
                    {
                        "username": "StephenYYoon",
                        "content": "The question does not state that you must check any rearrangements to be a palindrome, \"abb\" backwards  is \"bba\", \"abb\" != \"bba\""
                    },
                    {
                        "username": "rcon9494",
                        "content": "For the sake of your sanity, I recommend adding the below to the testcases before trying to submit:\n`\"0P\"`, `\".a\"`,`\"ab_a\"`\n\nGLHF!"
                    },
                    {
                        "username": "Laksh_Jain",
                        "content": "Why does using i and n-i-1 as two pointers doesn\\'t work for first Case?"
                    },
                    {
                        "username": "rajesh_9711",
                        "content": "below code show me memory limit exceed only for the case of  empty string during submit.\\nanone?\\ns = \"\";\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp = \"\";\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            if(s[i]>=\\'A\\' and s[i]<=\\'Z\\'){\\n                char ch = s[i]+32;\\n                temp = temp+ch;\\n            }\\n            else if(s[i]>=\\'a\\' and s[i]<=\\'z\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                temp = temp+s[i];\\n            }\\n\\n        }\\n        cout<<temp;\\n        int i = 0,j = temp.size()-1;\\n        while(i<=j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2023626,
                "content": [
                    {
                        "username": "Nukealbert",
                        "content": "\"ab_a\"\\n\\ncan anyone explain, how this is palindrome?"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "underscore will be removed as it is non alphanumeric so the palindrome become\" aba\"."
                    },
                    {
                        "username": "bijendraut",
                        "content": "_ is a non-alphanumeric so it will be removed... then it will become \"aba\" which is a palindrome"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "// if(isalnum(s[i]))\\n            // return false;\\ncan i handle alphanumeric with this??\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: The question states removing all non-alphanumeric characters.  \\nNumber are allowed in the string or simple put Range[48-57] is allowed"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "TO ALL WHO ARE GETTING DIFFICULTY IN TESTCASE \"0P\"\\n\\nrite 0 and 9 in single quotes like this if (s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n\\nTHANK ME LATER;)"
                    },
                    {
                        "username": "vinaypatil11101",
                        "content": "we can use isdigit in c++"
                    },
                    {
                        "username": "aahanakulkarni12",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = \"\";\\n        if(s.length()<2){\\n            return true;\\n        }\\n        s.toLowerCase();\\n        for(int i=0;i<s.length();i++){\\n                if(Character.isAlphabetic(s.charAt(i))){\\n                str = str + s.charAt(i);\\n            }\\n        }\\n        if(str.length()<2){\\n            return true;\\n        }\\n        \\n        int left =0;\\n        int right =str.length()-1;\\n        int flag = 1;\\n        while(left<=right){\\n            if(str.charAt(left)==str.charAt(right)){\\n               flag = 0;\\n            }\\n            else{\\n                flag=1;\\n                \\n            }\\n            left++;\\n            right--;\\n        }\\n        if(flag==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n this code is failing the testcase \"aA\" but passing one where lowercase is considered same as uppercase \\nand one with even characters "
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "how to use palindrome \\n"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "Just tell how string \"abb\" is not palidrome. If we rearrange it it will be \"bab\" so,  why it expected output is false."
                    },
                    {
                        "username": "StephenYYoon",
                        "content": "The question does not state that you must check any rearrangements to be a palindrome, \"abb\" backwards  is \"bba\", \"abb\" != \"bba\""
                    },
                    {
                        "username": "rcon9494",
                        "content": "For the sake of your sanity, I recommend adding the below to the testcases before trying to submit:\n`\"0P\"`, `\".a\"`,`\"ab_a\"`\n\nGLHF!"
                    },
                    {
                        "username": "Laksh_Jain",
                        "content": "Why does using i and n-i-1 as two pointers doesn\\'t work for first Case?"
                    },
                    {
                        "username": "rajesh_9711",
                        "content": "below code show me memory limit exceed only for the case of  empty string during submit.\\nanone?\\ns = \"\";\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp = \"\";\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            if(s[i]>=\\'A\\' and s[i]<=\\'Z\\'){\\n                char ch = s[i]+32;\\n                temp = temp+ch;\\n            }\\n            else if(s[i]>=\\'a\\' and s[i]<=\\'z\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                temp = temp+s[i];\\n            }\\n\\n        }\\n        cout<<temp;\\n        int i = 0,j = temp.size()-1;\\n        while(i<=j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2022854,
                "content": [
                    {
                        "username": "Nukealbert",
                        "content": "\"ab_a\"\\n\\ncan anyone explain, how this is palindrome?"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "underscore will be removed as it is non alphanumeric so the palindrome become\" aba\"."
                    },
                    {
                        "username": "bijendraut",
                        "content": "_ is a non-alphanumeric so it will be removed... then it will become \"aba\" which is a palindrome"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "// if(isalnum(s[i]))\\n            // return false;\\ncan i handle alphanumeric with this??\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: The question states removing all non-alphanumeric characters.  \\nNumber are allowed in the string or simple put Range[48-57] is allowed"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "TO ALL WHO ARE GETTING DIFFICULTY IN TESTCASE \"0P\"\\n\\nrite 0 and 9 in single quotes like this if (s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n\\nTHANK ME LATER;)"
                    },
                    {
                        "username": "vinaypatil11101",
                        "content": "we can use isdigit in c++"
                    },
                    {
                        "username": "aahanakulkarni12",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = \"\";\\n        if(s.length()<2){\\n            return true;\\n        }\\n        s.toLowerCase();\\n        for(int i=0;i<s.length();i++){\\n                if(Character.isAlphabetic(s.charAt(i))){\\n                str = str + s.charAt(i);\\n            }\\n        }\\n        if(str.length()<2){\\n            return true;\\n        }\\n        \\n        int left =0;\\n        int right =str.length()-1;\\n        int flag = 1;\\n        while(left<=right){\\n            if(str.charAt(left)==str.charAt(right)){\\n               flag = 0;\\n            }\\n            else{\\n                flag=1;\\n                \\n            }\\n            left++;\\n            right--;\\n        }\\n        if(flag==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n this code is failing the testcase \"aA\" but passing one where lowercase is considered same as uppercase \\nand one with even characters "
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "how to use palindrome \\n"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "Just tell how string \"abb\" is not palidrome. If we rearrange it it will be \"bab\" so,  why it expected output is false."
                    },
                    {
                        "username": "StephenYYoon",
                        "content": "The question does not state that you must check any rearrangements to be a palindrome, \"abb\" backwards  is \"bba\", \"abb\" != \"bba\""
                    },
                    {
                        "username": "rcon9494",
                        "content": "For the sake of your sanity, I recommend adding the below to the testcases before trying to submit:\n`\"0P\"`, `\".a\"`,`\"ab_a\"`\n\nGLHF!"
                    },
                    {
                        "username": "Laksh_Jain",
                        "content": "Why does using i and n-i-1 as two pointers doesn\\'t work for first Case?"
                    },
                    {
                        "username": "rajesh_9711",
                        "content": "below code show me memory limit exceed only for the case of  empty string during submit.\\nanone?\\ns = \"\";\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp = \"\";\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            if(s[i]>=\\'A\\' and s[i]<=\\'Z\\'){\\n                char ch = s[i]+32;\\n                temp = temp+ch;\\n            }\\n            else if(s[i]>=\\'a\\' and s[i]<=\\'z\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                temp = temp+s[i];\\n            }\\n\\n        }\\n        cout<<temp;\\n        int i = 0,j = temp.size()-1;\\n        while(i<=j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2018008,
                "content": [
                    {
                        "username": "Nukealbert",
                        "content": "\"ab_a\"\\n\\ncan anyone explain, how this is palindrome?"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "underscore will be removed as it is non alphanumeric so the palindrome become\" aba\"."
                    },
                    {
                        "username": "bijendraut",
                        "content": "_ is a non-alphanumeric so it will be removed... then it will become \"aba\" which is a palindrome"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "// if(isalnum(s[i]))\\n            // return false;\\ncan i handle alphanumeric with this??\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: The question states removing all non-alphanumeric characters.  \\nNumber are allowed in the string or simple put Range[48-57] is allowed"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "TO ALL WHO ARE GETTING DIFFICULTY IN TESTCASE \"0P\"\\n\\nrite 0 and 9 in single quotes like this if (s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n\\nTHANK ME LATER;)"
                    },
                    {
                        "username": "vinaypatil11101",
                        "content": "we can use isdigit in c++"
                    },
                    {
                        "username": "aahanakulkarni12",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = \"\";\\n        if(s.length()<2){\\n            return true;\\n        }\\n        s.toLowerCase();\\n        for(int i=0;i<s.length();i++){\\n                if(Character.isAlphabetic(s.charAt(i))){\\n                str = str + s.charAt(i);\\n            }\\n        }\\n        if(str.length()<2){\\n            return true;\\n        }\\n        \\n        int left =0;\\n        int right =str.length()-1;\\n        int flag = 1;\\n        while(left<=right){\\n            if(str.charAt(left)==str.charAt(right)){\\n               flag = 0;\\n            }\\n            else{\\n                flag=1;\\n                \\n            }\\n            left++;\\n            right--;\\n        }\\n        if(flag==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n this code is failing the testcase \"aA\" but passing one where lowercase is considered same as uppercase \\nand one with even characters "
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "how to use palindrome \\n"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "Just tell how string \"abb\" is not palidrome. If we rearrange it it will be \"bab\" so,  why it expected output is false."
                    },
                    {
                        "username": "StephenYYoon",
                        "content": "The question does not state that you must check any rearrangements to be a palindrome, \"abb\" backwards  is \"bba\", \"abb\" != \"bba\""
                    },
                    {
                        "username": "rcon9494",
                        "content": "For the sake of your sanity, I recommend adding the below to the testcases before trying to submit:\n`\"0P\"`, `\".a\"`,`\"ab_a\"`\n\nGLHF!"
                    },
                    {
                        "username": "Laksh_Jain",
                        "content": "Why does using i and n-i-1 as two pointers doesn\\'t work for first Case?"
                    },
                    {
                        "username": "rajesh_9711",
                        "content": "below code show me memory limit exceed only for the case of  empty string during submit.\\nanone?\\ns = \"\";\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp = \"\";\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            if(s[i]>=\\'A\\' and s[i]<=\\'Z\\'){\\n                char ch = s[i]+32;\\n                temp = temp+ch;\\n            }\\n            else if(s[i]>=\\'a\\' and s[i]<=\\'z\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                temp = temp+s[i];\\n            }\\n\\n        }\\n        cout<<temp;\\n        int i = 0,j = temp.size()-1;\\n        while(i<=j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2015580,
                "content": [
                    {
                        "username": "Nukealbert",
                        "content": "\"ab_a\"\\n\\ncan anyone explain, how this is palindrome?"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "underscore will be removed as it is non alphanumeric so the palindrome become\" aba\"."
                    },
                    {
                        "username": "bijendraut",
                        "content": "_ is a non-alphanumeric so it will be removed... then it will become \"aba\" which is a palindrome"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "// if(isalnum(s[i]))\\n            // return false;\\ncan i handle alphanumeric with this??\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: The question states removing all non-alphanumeric characters.  \\nNumber are allowed in the string or simple put Range[48-57] is allowed"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "TO ALL WHO ARE GETTING DIFFICULTY IN TESTCASE \"0P\"\\n\\nrite 0 and 9 in single quotes like this if (s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n\\nTHANK ME LATER;)"
                    },
                    {
                        "username": "vinaypatil11101",
                        "content": "we can use isdigit in c++"
                    },
                    {
                        "username": "aahanakulkarni12",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = \"\";\\n        if(s.length()<2){\\n            return true;\\n        }\\n        s.toLowerCase();\\n        for(int i=0;i<s.length();i++){\\n                if(Character.isAlphabetic(s.charAt(i))){\\n                str = str + s.charAt(i);\\n            }\\n        }\\n        if(str.length()<2){\\n            return true;\\n        }\\n        \\n        int left =0;\\n        int right =str.length()-1;\\n        int flag = 1;\\n        while(left<=right){\\n            if(str.charAt(left)==str.charAt(right)){\\n               flag = 0;\\n            }\\n            else{\\n                flag=1;\\n                \\n            }\\n            left++;\\n            right--;\\n        }\\n        if(flag==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n this code is failing the testcase \"aA\" but passing one where lowercase is considered same as uppercase \\nand one with even characters "
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "how to use palindrome \\n"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "Just tell how string \"abb\" is not palidrome. If we rearrange it it will be \"bab\" so,  why it expected output is false."
                    },
                    {
                        "username": "StephenYYoon",
                        "content": "The question does not state that you must check any rearrangements to be a palindrome, \"abb\" backwards  is \"bba\", \"abb\" != \"bba\""
                    },
                    {
                        "username": "rcon9494",
                        "content": "For the sake of your sanity, I recommend adding the below to the testcases before trying to submit:\n`\"0P\"`, `\".a\"`,`\"ab_a\"`\n\nGLHF!"
                    },
                    {
                        "username": "Laksh_Jain",
                        "content": "Why does using i and n-i-1 as two pointers doesn\\'t work for first Case?"
                    },
                    {
                        "username": "rajesh_9711",
                        "content": "below code show me memory limit exceed only for the case of  empty string during submit.\\nanone?\\ns = \"\";\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp = \"\";\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            if(s[i]>=\\'A\\' and s[i]<=\\'Z\\'){\\n                char ch = s[i]+32;\\n                temp = temp+ch;\\n            }\\n            else if(s[i]>=\\'a\\' and s[i]<=\\'z\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                temp = temp+s[i];\\n            }\\n\\n        }\\n        cout<<temp;\\n        int i = 0,j = temp.size()-1;\\n        while(i<=j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2014999,
                "content": [
                    {
                        "username": "Nukealbert",
                        "content": "\"ab_a\"\\n\\ncan anyone explain, how this is palindrome?"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "underscore will be removed as it is non alphanumeric so the palindrome become\" aba\"."
                    },
                    {
                        "username": "bijendraut",
                        "content": "_ is a non-alphanumeric so it will be removed... then it will become \"aba\" which is a palindrome"
                    },
                    {
                        "username": "Priyanshu9172",
                        "content": "// if(isalnum(s[i]))\\n            // return false;\\ncan i handle alphanumeric with this??\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: The question states removing all non-alphanumeric characters.  \\nNumber are allowed in the string or simple put Range[48-57] is allowed"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "TO ALL WHO ARE GETTING DIFFICULTY IN TESTCASE \"0P\"\\n\\nrite 0 and 9 in single quotes like this if (s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n\\nTHANK ME LATER;)"
                    },
                    {
                        "username": "vinaypatil11101",
                        "content": "we can use isdigit in c++"
                    },
                    {
                        "username": "aahanakulkarni12",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        String str = \"\";\\n        if(s.length()<2){\\n            return true;\\n        }\\n        s.toLowerCase();\\n        for(int i=0;i<s.length();i++){\\n                if(Character.isAlphabetic(s.charAt(i))){\\n                str = str + s.charAt(i);\\n            }\\n        }\\n        if(str.length()<2){\\n            return true;\\n        }\\n        \\n        int left =0;\\n        int right =str.length()-1;\\n        int flag = 1;\\n        while(left<=right){\\n            if(str.charAt(left)==str.charAt(right)){\\n               flag = 0;\\n            }\\n            else{\\n                flag=1;\\n                \\n            }\\n            left++;\\n            right--;\\n        }\\n        if(flag==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n this code is failing the testcase \"aA\" but passing one where lowercase is considered same as uppercase \\nand one with even characters "
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "how to use palindrome \\n"
                    },
                    {
                        "username": "pawansharma9115078358",
                        "content": "Just tell how string \"abb\" is not palidrome. If we rearrange it it will be \"bab\" so,  why it expected output is false."
                    },
                    {
                        "username": "StephenYYoon",
                        "content": "The question does not state that you must check any rearrangements to be a palindrome, \"abb\" backwards  is \"bba\", \"abb\" != \"bba\""
                    },
                    {
                        "username": "rcon9494",
                        "content": "For the sake of your sanity, I recommend adding the below to the testcases before trying to submit:\n`\"0P\"`, `\".a\"`,`\"ab_a\"`\n\nGLHF!"
                    },
                    {
                        "username": "Laksh_Jain",
                        "content": "Why does using i and n-i-1 as two pointers doesn\\'t work for first Case?"
                    },
                    {
                        "username": "rajesh_9711",
                        "content": "below code show me memory limit exceed only for the case of  empty string during submit.\\nanone?\\ns = \"\";\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp = \"\";\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            if(s[i]>=\\'A\\' and s[i]<=\\'Z\\'){\\n                char ch = s[i]+32;\\n                temp = temp+ch;\\n            }\\n            else if(s[i]>=\\'a\\' and s[i]<=\\'z\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                temp = temp+s[i];\\n            }\\n\\n        }\\n        cout<<temp;\\n        int i = 0,j = temp.size()-1;\\n        while(i<=j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2011339,
                "content": [
                    {
                        "username": "kuznetcoff777",
                        "content": "Some f*cking bug!\\n        if s == \"race a car\": return \"false\"\\n\\n\\nand even this case i get Output = true\\nHow is that even possible?????????"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "Is it okay if i make use of a regular expression?"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@neeldoshii](/neeldoshii) RegEx like /\\\\s/g (not the actual one i used)"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "as in? can you elaborate your question."
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@georgezakharov](/georgezakharov) my regards"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "All you need is a Two Pointers Approach.\nAnyway, you can use anything you want depending on your goal."
                    },
                    {
                        "username": "heyy_laddha",
                        "content": "var isPalindrome = function(s) {\\n   let newString = s.replace(/[^azAZ09]/g,\\'\\')\\n    newString = newString.toLowerCase();\\n    \\n   for(let i=0 ; i<newString.length ; i++){\\n       for(let j=newString.length-1 ; j>=0 ; j--){\\n           if(newString[i] !== newString[j]){\\n               return false\\n           }\\n       }\\n   }\\nreturn true\\n};\\nPlease someone explain why my code is not working."
                    },
                    {
                        "username": "himanshuone",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s=(\"\".join(i for i in s if i.isalnum())).lower()\\n        \\n        if s ==s[-1::-1]:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "dont post it here this is not solution tabs"
                    },
                    {
                        "username": "KingIndra",
                        "content": "..."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to compare the strings after changing to uppercase or lowercase to match all cases"
                    },
                    {
                        "username": "codeeeer",
                        "content": "Hii  \nI have use 2 pointer methord i don't know what is wrong in my code please help me\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n     string str=\"\",chk=\"\",temp=\"\";\n        for(char c: s){\n            str+= tolower(c);\n        }\n        int n=str.size();\n        for(int i=0;i<n;i++ )\n{\n    if((str[i]>=97 && str[i]<=122)|| (str[i]>=48 && str[i]<=57)) chk+=str[i];\n}   temp=chk;\n    \n         int k=0;\n         int j=s.size()-1;\n         while(k<=j){\n             if(temp[k]!=temp[j])\n                 return false; \n                k++; \n                j--;\n             }      \n         return true;\n    }\n};"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "These question take me 1 hour to complete because of one simple syntax \\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "likes and dislikes on this question is balanced as it should be \\uD83D\\uDE0C"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": " class Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"^a-zA-Z0-9-+^.:, \",\"\");\n        s.toLowerCase();\n        StringBuilder str=new StringBuilder(s);\n        str.reverse();\n        String rev=str.toString();\n        if(str.equals(rev)){\n            return true;\n        }    \n        else{\n            return false;\n        }\n    }\n}\nthis is code but it only pass 91 case out of 485 ? How to optimize the code?"
                    }
                ]
            },
            {
                "id": 2006868,
                "content": [
                    {
                        "username": "kuznetcoff777",
                        "content": "Some f*cking bug!\\n        if s == \"race a car\": return \"false\"\\n\\n\\nand even this case i get Output = true\\nHow is that even possible?????????"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "Is it okay if i make use of a regular expression?"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@neeldoshii](/neeldoshii) RegEx like /\\\\s/g (not the actual one i used)"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "as in? can you elaborate your question."
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@georgezakharov](/georgezakharov) my regards"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "All you need is a Two Pointers Approach.\nAnyway, you can use anything you want depending on your goal."
                    },
                    {
                        "username": "heyy_laddha",
                        "content": "var isPalindrome = function(s) {\\n   let newString = s.replace(/[^azAZ09]/g,\\'\\')\\n    newString = newString.toLowerCase();\\n    \\n   for(let i=0 ; i<newString.length ; i++){\\n       for(let j=newString.length-1 ; j>=0 ; j--){\\n           if(newString[i] !== newString[j]){\\n               return false\\n           }\\n       }\\n   }\\nreturn true\\n};\\nPlease someone explain why my code is not working."
                    },
                    {
                        "username": "himanshuone",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s=(\"\".join(i for i in s if i.isalnum())).lower()\\n        \\n        if s ==s[-1::-1]:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "dont post it here this is not solution tabs"
                    },
                    {
                        "username": "KingIndra",
                        "content": "..."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to compare the strings after changing to uppercase or lowercase to match all cases"
                    },
                    {
                        "username": "codeeeer",
                        "content": "Hii  \nI have use 2 pointer methord i don't know what is wrong in my code please help me\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n     string str=\"\",chk=\"\",temp=\"\";\n        for(char c: s){\n            str+= tolower(c);\n        }\n        int n=str.size();\n        for(int i=0;i<n;i++ )\n{\n    if((str[i]>=97 && str[i]<=122)|| (str[i]>=48 && str[i]<=57)) chk+=str[i];\n}   temp=chk;\n    \n         int k=0;\n         int j=s.size()-1;\n         while(k<=j){\n             if(temp[k]!=temp[j])\n                 return false; \n                k++; \n                j--;\n             }      \n         return true;\n    }\n};"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "These question take me 1 hour to complete because of one simple syntax \\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "likes and dislikes on this question is balanced as it should be \\uD83D\\uDE0C"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": " class Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"^a-zA-Z0-9-+^.:, \",\"\");\n        s.toLowerCase();\n        StringBuilder str=new StringBuilder(s);\n        str.reverse();\n        String rev=str.toString();\n        if(str.equals(rev)){\n            return true;\n        }    \n        else{\n            return false;\n        }\n    }\n}\nthis is code but it only pass 91 case out of 485 ? How to optimize the code?"
                    }
                ]
            },
            {
                "id": 2003777,
                "content": [
                    {
                        "username": "kuznetcoff777",
                        "content": "Some f*cking bug!\\n        if s == \"race a car\": return \"false\"\\n\\n\\nand even this case i get Output = true\\nHow is that even possible?????????"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "Is it okay if i make use of a regular expression?"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@neeldoshii](/neeldoshii) RegEx like /\\\\s/g (not the actual one i used)"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "as in? can you elaborate your question."
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@georgezakharov](/georgezakharov) my regards"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "All you need is a Two Pointers Approach.\nAnyway, you can use anything you want depending on your goal."
                    },
                    {
                        "username": "heyy_laddha",
                        "content": "var isPalindrome = function(s) {\\n   let newString = s.replace(/[^azAZ09]/g,\\'\\')\\n    newString = newString.toLowerCase();\\n    \\n   for(let i=0 ; i<newString.length ; i++){\\n       for(let j=newString.length-1 ; j>=0 ; j--){\\n           if(newString[i] !== newString[j]){\\n               return false\\n           }\\n       }\\n   }\\nreturn true\\n};\\nPlease someone explain why my code is not working."
                    },
                    {
                        "username": "himanshuone",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s=(\"\".join(i for i in s if i.isalnum())).lower()\\n        \\n        if s ==s[-1::-1]:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "dont post it here this is not solution tabs"
                    },
                    {
                        "username": "KingIndra",
                        "content": "..."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to compare the strings after changing to uppercase or lowercase to match all cases"
                    },
                    {
                        "username": "codeeeer",
                        "content": "Hii  \nI have use 2 pointer methord i don't know what is wrong in my code please help me\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n     string str=\"\",chk=\"\",temp=\"\";\n        for(char c: s){\n            str+= tolower(c);\n        }\n        int n=str.size();\n        for(int i=0;i<n;i++ )\n{\n    if((str[i]>=97 && str[i]<=122)|| (str[i]>=48 && str[i]<=57)) chk+=str[i];\n}   temp=chk;\n    \n         int k=0;\n         int j=s.size()-1;\n         while(k<=j){\n             if(temp[k]!=temp[j])\n                 return false; \n                k++; \n                j--;\n             }      \n         return true;\n    }\n};"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "These question take me 1 hour to complete because of one simple syntax \\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "likes and dislikes on this question is balanced as it should be \\uD83D\\uDE0C"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": " class Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"^a-zA-Z0-9-+^.:, \",\"\");\n        s.toLowerCase();\n        StringBuilder str=new StringBuilder(s);\n        str.reverse();\n        String rev=str.toString();\n        if(str.equals(rev)){\n            return true;\n        }    \n        else{\n            return false;\n        }\n    }\n}\nthis is code but it only pass 91 case out of 485 ? How to optimize the code?"
                    }
                ]
            },
            {
                "id": 2001579,
                "content": [
                    {
                        "username": "kuznetcoff777",
                        "content": "Some f*cking bug!\\n        if s == \"race a car\": return \"false\"\\n\\n\\nand even this case i get Output = true\\nHow is that even possible?????????"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "Is it okay if i make use of a regular expression?"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@neeldoshii](/neeldoshii) RegEx like /\\\\s/g (not the actual one i used)"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "as in? can you elaborate your question."
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@georgezakharov](/georgezakharov) my regards"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "All you need is a Two Pointers Approach.\nAnyway, you can use anything you want depending on your goal."
                    },
                    {
                        "username": "heyy_laddha",
                        "content": "var isPalindrome = function(s) {\\n   let newString = s.replace(/[^azAZ09]/g,\\'\\')\\n    newString = newString.toLowerCase();\\n    \\n   for(let i=0 ; i<newString.length ; i++){\\n       for(let j=newString.length-1 ; j>=0 ; j--){\\n           if(newString[i] !== newString[j]){\\n               return false\\n           }\\n       }\\n   }\\nreturn true\\n};\\nPlease someone explain why my code is not working."
                    },
                    {
                        "username": "himanshuone",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s=(\"\".join(i for i in s if i.isalnum())).lower()\\n        \\n        if s ==s[-1::-1]:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "dont post it here this is not solution tabs"
                    },
                    {
                        "username": "KingIndra",
                        "content": "..."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to compare the strings after changing to uppercase or lowercase to match all cases"
                    },
                    {
                        "username": "codeeeer",
                        "content": "Hii  \nI have use 2 pointer methord i don't know what is wrong in my code please help me\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n     string str=\"\",chk=\"\",temp=\"\";\n        for(char c: s){\n            str+= tolower(c);\n        }\n        int n=str.size();\n        for(int i=0;i<n;i++ )\n{\n    if((str[i]>=97 && str[i]<=122)|| (str[i]>=48 && str[i]<=57)) chk+=str[i];\n}   temp=chk;\n    \n         int k=0;\n         int j=s.size()-1;\n         while(k<=j){\n             if(temp[k]!=temp[j])\n                 return false; \n                k++; \n                j--;\n             }      \n         return true;\n    }\n};"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "These question take me 1 hour to complete because of one simple syntax \\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "likes and dislikes on this question is balanced as it should be \\uD83D\\uDE0C"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": " class Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"^a-zA-Z0-9-+^.:, \",\"\");\n        s.toLowerCase();\n        StringBuilder str=new StringBuilder(s);\n        str.reverse();\n        String rev=str.toString();\n        if(str.equals(rev)){\n            return true;\n        }    \n        else{\n            return false;\n        }\n    }\n}\nthis is code but it only pass 91 case out of 485 ? How to optimize the code?"
                    }
                ]
            },
            {
                "id": 1991693,
                "content": [
                    {
                        "username": "kuznetcoff777",
                        "content": "Some f*cking bug!\\n        if s == \"race a car\": return \"false\"\\n\\n\\nand even this case i get Output = true\\nHow is that even possible?????????"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "Is it okay if i make use of a regular expression?"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@neeldoshii](/neeldoshii) RegEx like /\\\\s/g (not the actual one i used)"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "as in? can you elaborate your question."
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@georgezakharov](/georgezakharov) my regards"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "All you need is a Two Pointers Approach.\nAnyway, you can use anything you want depending on your goal."
                    },
                    {
                        "username": "heyy_laddha",
                        "content": "var isPalindrome = function(s) {\\n   let newString = s.replace(/[^azAZ09]/g,\\'\\')\\n    newString = newString.toLowerCase();\\n    \\n   for(let i=0 ; i<newString.length ; i++){\\n       for(let j=newString.length-1 ; j>=0 ; j--){\\n           if(newString[i] !== newString[j]){\\n               return false\\n           }\\n       }\\n   }\\nreturn true\\n};\\nPlease someone explain why my code is not working."
                    },
                    {
                        "username": "himanshuone",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s=(\"\".join(i for i in s if i.isalnum())).lower()\\n        \\n        if s ==s[-1::-1]:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "dont post it here this is not solution tabs"
                    },
                    {
                        "username": "KingIndra",
                        "content": "..."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to compare the strings after changing to uppercase or lowercase to match all cases"
                    },
                    {
                        "username": "codeeeer",
                        "content": "Hii  \nI have use 2 pointer methord i don't know what is wrong in my code please help me\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n     string str=\"\",chk=\"\",temp=\"\";\n        for(char c: s){\n            str+= tolower(c);\n        }\n        int n=str.size();\n        for(int i=0;i<n;i++ )\n{\n    if((str[i]>=97 && str[i]<=122)|| (str[i]>=48 && str[i]<=57)) chk+=str[i];\n}   temp=chk;\n    \n         int k=0;\n         int j=s.size()-1;\n         while(k<=j){\n             if(temp[k]!=temp[j])\n                 return false; \n                k++; \n                j--;\n             }      \n         return true;\n    }\n};"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "These question take me 1 hour to complete because of one simple syntax \\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "likes and dislikes on this question is balanced as it should be \\uD83D\\uDE0C"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": " class Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"^a-zA-Z0-9-+^.:, \",\"\");\n        s.toLowerCase();\n        StringBuilder str=new StringBuilder(s);\n        str.reverse();\n        String rev=str.toString();\n        if(str.equals(rev)){\n            return true;\n        }    \n        else{\n            return false;\n        }\n    }\n}\nthis is code but it only pass 91 case out of 485 ? How to optimize the code?"
                    }
                ]
            },
            {
                "id": 1990759,
                "content": [
                    {
                        "username": "kuznetcoff777",
                        "content": "Some f*cking bug!\\n        if s == \"race a car\": return \"false\"\\n\\n\\nand even this case i get Output = true\\nHow is that even possible?????????"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "Is it okay if i make use of a regular expression?"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@neeldoshii](/neeldoshii) RegEx like /\\\\s/g (not the actual one i used)"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "as in? can you elaborate your question."
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@georgezakharov](/georgezakharov) my regards"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "All you need is a Two Pointers Approach.\nAnyway, you can use anything you want depending on your goal."
                    },
                    {
                        "username": "heyy_laddha",
                        "content": "var isPalindrome = function(s) {\\n   let newString = s.replace(/[^azAZ09]/g,\\'\\')\\n    newString = newString.toLowerCase();\\n    \\n   for(let i=0 ; i<newString.length ; i++){\\n       for(let j=newString.length-1 ; j>=0 ; j--){\\n           if(newString[i] !== newString[j]){\\n               return false\\n           }\\n       }\\n   }\\nreturn true\\n};\\nPlease someone explain why my code is not working."
                    },
                    {
                        "username": "himanshuone",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s=(\"\".join(i for i in s if i.isalnum())).lower()\\n        \\n        if s ==s[-1::-1]:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "dont post it here this is not solution tabs"
                    },
                    {
                        "username": "KingIndra",
                        "content": "..."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to compare the strings after changing to uppercase or lowercase to match all cases"
                    },
                    {
                        "username": "codeeeer",
                        "content": "Hii  \nI have use 2 pointer methord i don't know what is wrong in my code please help me\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n     string str=\"\",chk=\"\",temp=\"\";\n        for(char c: s){\n            str+= tolower(c);\n        }\n        int n=str.size();\n        for(int i=0;i<n;i++ )\n{\n    if((str[i]>=97 && str[i]<=122)|| (str[i]>=48 && str[i]<=57)) chk+=str[i];\n}   temp=chk;\n    \n         int k=0;\n         int j=s.size()-1;\n         while(k<=j){\n             if(temp[k]!=temp[j])\n                 return false; \n                k++; \n                j--;\n             }      \n         return true;\n    }\n};"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "These question take me 1 hour to complete because of one simple syntax \\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "likes and dislikes on this question is balanced as it should be \\uD83D\\uDE0C"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": " class Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"^a-zA-Z0-9-+^.:, \",\"\");\n        s.toLowerCase();\n        StringBuilder str=new StringBuilder(s);\n        str.reverse();\n        String rev=str.toString();\n        if(str.equals(rev)){\n            return true;\n        }    \n        else{\n            return false;\n        }\n    }\n}\nthis is code but it only pass 91 case out of 485 ? How to optimize the code?"
                    }
                ]
            },
            {
                "id": 1990677,
                "content": [
                    {
                        "username": "kuznetcoff777",
                        "content": "Some f*cking bug!\\n        if s == \"race a car\": return \"false\"\\n\\n\\nand even this case i get Output = true\\nHow is that even possible?????????"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "Is it okay if i make use of a regular expression?"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@neeldoshii](/neeldoshii) RegEx like /\\\\s/g (not the actual one i used)"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "as in? can you elaborate your question."
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@georgezakharov](/georgezakharov) my regards"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "All you need is a Two Pointers Approach.\nAnyway, you can use anything you want depending on your goal."
                    },
                    {
                        "username": "heyy_laddha",
                        "content": "var isPalindrome = function(s) {\\n   let newString = s.replace(/[^azAZ09]/g,\\'\\')\\n    newString = newString.toLowerCase();\\n    \\n   for(let i=0 ; i<newString.length ; i++){\\n       for(let j=newString.length-1 ; j>=0 ; j--){\\n           if(newString[i] !== newString[j]){\\n               return false\\n           }\\n       }\\n   }\\nreturn true\\n};\\nPlease someone explain why my code is not working."
                    },
                    {
                        "username": "himanshuone",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s=(\"\".join(i for i in s if i.isalnum())).lower()\\n        \\n        if s ==s[-1::-1]:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "dont post it here this is not solution tabs"
                    },
                    {
                        "username": "KingIndra",
                        "content": "..."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to compare the strings after changing to uppercase or lowercase to match all cases"
                    },
                    {
                        "username": "codeeeer",
                        "content": "Hii  \nI have use 2 pointer methord i don't know what is wrong in my code please help me\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n     string str=\"\",chk=\"\",temp=\"\";\n        for(char c: s){\n            str+= tolower(c);\n        }\n        int n=str.size();\n        for(int i=0;i<n;i++ )\n{\n    if((str[i]>=97 && str[i]<=122)|| (str[i]>=48 && str[i]<=57)) chk+=str[i];\n}   temp=chk;\n    \n         int k=0;\n         int j=s.size()-1;\n         while(k<=j){\n             if(temp[k]!=temp[j])\n                 return false; \n                k++; \n                j--;\n             }      \n         return true;\n    }\n};"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "These question take me 1 hour to complete because of one simple syntax \\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "likes and dislikes on this question is balanced as it should be \\uD83D\\uDE0C"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": " class Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"^a-zA-Z0-9-+^.:, \",\"\");\n        s.toLowerCase();\n        StringBuilder str=new StringBuilder(s);\n        str.reverse();\n        String rev=str.toString();\n        if(str.equals(rev)){\n            return true;\n        }    \n        else{\n            return false;\n        }\n    }\n}\nthis is code but it only pass 91 case out of 485 ? How to optimize the code?"
                    }
                ]
            },
            {
                "id": 1990090,
                "content": [
                    {
                        "username": "kuznetcoff777",
                        "content": "Some f*cking bug!\\n        if s == \"race a car\": return \"false\"\\n\\n\\nand even this case i get Output = true\\nHow is that even possible?????????"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "Is it okay if i make use of a regular expression?"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@neeldoshii](/neeldoshii) RegEx like /\\\\s/g (not the actual one i used)"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "as in? can you elaborate your question."
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@georgezakharov](/georgezakharov) my regards"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "All you need is a Two Pointers Approach.\nAnyway, you can use anything you want depending on your goal."
                    },
                    {
                        "username": "heyy_laddha",
                        "content": "var isPalindrome = function(s) {\\n   let newString = s.replace(/[^azAZ09]/g,\\'\\')\\n    newString = newString.toLowerCase();\\n    \\n   for(let i=0 ; i<newString.length ; i++){\\n       for(let j=newString.length-1 ; j>=0 ; j--){\\n           if(newString[i] !== newString[j]){\\n               return false\\n           }\\n       }\\n   }\\nreturn true\\n};\\nPlease someone explain why my code is not working."
                    },
                    {
                        "username": "himanshuone",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s=(\"\".join(i for i in s if i.isalnum())).lower()\\n        \\n        if s ==s[-1::-1]:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "dont post it here this is not solution tabs"
                    },
                    {
                        "username": "KingIndra",
                        "content": "..."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to compare the strings after changing to uppercase or lowercase to match all cases"
                    },
                    {
                        "username": "codeeeer",
                        "content": "Hii  \nI have use 2 pointer methord i don't know what is wrong in my code please help me\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n     string str=\"\",chk=\"\",temp=\"\";\n        for(char c: s){\n            str+= tolower(c);\n        }\n        int n=str.size();\n        for(int i=0;i<n;i++ )\n{\n    if((str[i]>=97 && str[i]<=122)|| (str[i]>=48 && str[i]<=57)) chk+=str[i];\n}   temp=chk;\n    \n         int k=0;\n         int j=s.size()-1;\n         while(k<=j){\n             if(temp[k]!=temp[j])\n                 return false; \n                k++; \n                j--;\n             }      \n         return true;\n    }\n};"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "These question take me 1 hour to complete because of one simple syntax \\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "likes and dislikes on this question is balanced as it should be \\uD83D\\uDE0C"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": " class Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"^a-zA-Z0-9-+^.:, \",\"\");\n        s.toLowerCase();\n        StringBuilder str=new StringBuilder(s);\n        str.reverse();\n        String rev=str.toString();\n        if(str.equals(rev)){\n            return true;\n        }    \n        else{\n            return false;\n        }\n    }\n}\nthis is code but it only pass 91 case out of 485 ? How to optimize the code?"
                    }
                ]
            },
            {
                "id": 1989006,
                "content": [
                    {
                        "username": "kuznetcoff777",
                        "content": "Some f*cking bug!\\n        if s == \"race a car\": return \"false\"\\n\\n\\nand even this case i get Output = true\\nHow is that even possible?????????"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "Is it okay if i make use of a regular expression?"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@neeldoshii](/neeldoshii) RegEx like /\\\\s/g (not the actual one i used)"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "as in? can you elaborate your question."
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@georgezakharov](/georgezakharov) my regards"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "All you need is a Two Pointers Approach.\nAnyway, you can use anything you want depending on your goal."
                    },
                    {
                        "username": "heyy_laddha",
                        "content": "var isPalindrome = function(s) {\\n   let newString = s.replace(/[^azAZ09]/g,\\'\\')\\n    newString = newString.toLowerCase();\\n    \\n   for(let i=0 ; i<newString.length ; i++){\\n       for(let j=newString.length-1 ; j>=0 ; j--){\\n           if(newString[i] !== newString[j]){\\n               return false\\n           }\\n       }\\n   }\\nreturn true\\n};\\nPlease someone explain why my code is not working."
                    },
                    {
                        "username": "himanshuone",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s=(\"\".join(i for i in s if i.isalnum())).lower()\\n        \\n        if s ==s[-1::-1]:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "dont post it here this is not solution tabs"
                    },
                    {
                        "username": "KingIndra",
                        "content": "..."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to compare the strings after changing to uppercase or lowercase to match all cases"
                    },
                    {
                        "username": "codeeeer",
                        "content": "Hii  \nI have use 2 pointer methord i don't know what is wrong in my code please help me\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n     string str=\"\",chk=\"\",temp=\"\";\n        for(char c: s){\n            str+= tolower(c);\n        }\n        int n=str.size();\n        for(int i=0;i<n;i++ )\n{\n    if((str[i]>=97 && str[i]<=122)|| (str[i]>=48 && str[i]<=57)) chk+=str[i];\n}   temp=chk;\n    \n         int k=0;\n         int j=s.size()-1;\n         while(k<=j){\n             if(temp[k]!=temp[j])\n                 return false; \n                k++; \n                j--;\n             }      \n         return true;\n    }\n};"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "These question take me 1 hour to complete because of one simple syntax \\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "likes and dislikes on this question is balanced as it should be \\uD83D\\uDE0C"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": " class Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"^a-zA-Z0-9-+^.:, \",\"\");\n        s.toLowerCase();\n        StringBuilder str=new StringBuilder(s);\n        str.reverse();\n        String rev=str.toString();\n        if(str.equals(rev)){\n            return true;\n        }    \n        else{\n            return false;\n        }\n    }\n}\nthis is code but it only pass 91 case out of 485 ? How to optimize the code?"
                    }
                ]
            },
            {
                "id": 1986300,
                "content": [
                    {
                        "username": "kuznetcoff777",
                        "content": "Some f*cking bug!\\n        if s == \"race a car\": return \"false\"\\n\\n\\nand even this case i get Output = true\\nHow is that even possible?????????"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "Is it okay if i make use of a regular expression?"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@neeldoshii](/neeldoshii) RegEx like /\\\\s/g (not the actual one i used)"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "as in? can you elaborate your question."
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "[@georgezakharov](/georgezakharov) my regards"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "All you need is a Two Pointers Approach.\nAnyway, you can use anything you want depending on your goal."
                    },
                    {
                        "username": "heyy_laddha",
                        "content": "var isPalindrome = function(s) {\\n   let newString = s.replace(/[^azAZ09]/g,\\'\\')\\n    newString = newString.toLowerCase();\\n    \\n   for(let i=0 ; i<newString.length ; i++){\\n       for(let j=newString.length-1 ; j>=0 ; j--){\\n           if(newString[i] !== newString[j]){\\n               return false\\n           }\\n       }\\n   }\\nreturn true\\n};\\nPlease someone explain why my code is not working."
                    },
                    {
                        "username": "himanshuone",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        s=(\"\".join(i for i in s if i.isalnum())).lower()\\n        \\n        if s ==s[-1::-1]:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "dont post it here this is not solution tabs"
                    },
                    {
                        "username": "KingIndra",
                        "content": "..."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to compare the strings after changing to uppercase or lowercase to match all cases"
                    },
                    {
                        "username": "codeeeer",
                        "content": "Hii  \nI have use 2 pointer methord i don't know what is wrong in my code please help me\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n     string str=\"\",chk=\"\",temp=\"\";\n        for(char c: s){\n            str+= tolower(c);\n        }\n        int n=str.size();\n        for(int i=0;i<n;i++ )\n{\n    if((str[i]>=97 && str[i]<=122)|| (str[i]>=48 && str[i]<=57)) chk+=str[i];\n}   temp=chk;\n    \n         int k=0;\n         int j=s.size()-1;\n         while(k<=j){\n             if(temp[k]!=temp[j])\n                 return false; \n                k++; \n                j--;\n             }      \n         return true;\n    }\n};"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "These question take me 1 hour to complete because of one simple syntax \\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "likes and dislikes on this question is balanced as it should be \\uD83D\\uDE0C"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": " class Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"^a-zA-Z0-9-+^.:, \",\"\");\n        s.toLowerCase();\n        StringBuilder str=new StringBuilder(s);\n        str.reverse();\n        String rev=str.toString();\n        if(str.equals(rev)){\n            return true;\n        }    \n        else{\n            return false;\n        }\n    }\n}\nthis is code but it only pass 91 case out of 485 ? How to optimize the code?"
                    }
                ]
            },
            {
                "id": 1980379,
                "content": [
                    {
                        "username": "Boysle",
                        "content": "\"Alphanumeric characters include letters and numbers.\" "
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "one test case is wrong \"0P \", we must use isalnum instead of isalpha then"
                    },
                    {
                        "username": "suresh37",
                        "content": "That test case is correct only. \\nas per statement, all Alphanumeric characters include letters and numbers are considered as valid\\nSo, 0P is right test case. most ppl get this TC failed by missing out this detail"
                    },
                    {
                        "username": "suresh37",
                        "content": "\"0P\" gang hit like"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since there are lot of comments regarding invalid test cases So you need to understand the question first \nThe have said remove the alphanumeric character ist..which means you should remove everything thing except A-Z,a-z and 0-9 This letters are called alphanumeric all others are non alphanumeric.\nLike **ab@a** will return true since you can remove *@* and string becomes *aba*\n**,.** In this case u should remove both characters Now string becomes **\" \"** empty which will give **true** result.\n\nONE THING YOU NEED TO CONVERT ALL UPPERCASE LETTER TO Lower CASE  AS WELL\nSO String like **AC#A** will give *aca* which will give true result "
                    },
                    {
                        "username": "vlope093",
                        "content": "\"ab@a\" seems to be an invalid test case.\\nForward reads: \"ab@a\" , but backwards reads: a@ba, which is not the same!\\nif we replace \"@\" for \"t\"  =>  \"abta\" != atba\\n\\nPlease fix this!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You don\\'t have understood the question properly The have said remove the alphanumeric character ist..which means you should remove everything thingh except **A-Z,a-z and 0-9** This letters  are called alphanumeric all others are non alphanumeric.\\nSO your Test case become *aba* after removing non alphanumeric *@*.\\nAnd *aba* is palindrome so it should return true"
                    },
                    {
                        "username": "nilsdula",
                        "content": "The example testcases should include a number because way too many people (including yours truly) have failed the 0P testcase."
                    },
                    {
                        "username": "mmtemel",
                        "content": "It says alphanumeric which means consisting of or using both letters and numerals. So 0P must return false. "
                    },
                    {
                        "username": "k_pooja",
                        "content": "can anyone help me with this code \\nit is not passing one test case\\n\\n `class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      \\n        x=s[::-1]\\n        if s.isalnum()==True and s.islower()==True:\\n            for i in range(len(s)):\\n                if s[i]==x[i]:\\n                    return True\\n        elif len(s)==1:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "vsluzky",
                        "content": "I might be wrong, but my solution is not accepted as \"0P\" with zero not letter is expected to be a false palindrome. Looks like an error in the validating case. Can you clarify?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Alphanumeric characters it mean both numeric and alpha character not just alpha character"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Hi Guys, \\n\\njust a Hint:\\n\\nYou don\\'t have to do a for loop to validate every single letter, just compare the actual string against himself but in reverse form.\\n\\n\"amanaplanacanalpanama\" == reverse form \"amanaplanacanalpanama\" in \\n\\nMore details below:\\n\\n\\n\\n\\n\\n\\n\\npython string[::-1] to reverse form.\\n\\nNote: without  non-alphanumeric characters."
                    }
                ]
            },
            {
                "id": 1974165,
                "content": [
                    {
                        "username": "Boysle",
                        "content": "\"Alphanumeric characters include letters and numbers.\" "
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "one test case is wrong \"0P \", we must use isalnum instead of isalpha then"
                    },
                    {
                        "username": "suresh37",
                        "content": "That test case is correct only. \\nas per statement, all Alphanumeric characters include letters and numbers are considered as valid\\nSo, 0P is right test case. most ppl get this TC failed by missing out this detail"
                    },
                    {
                        "username": "suresh37",
                        "content": "\"0P\" gang hit like"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since there are lot of comments regarding invalid test cases So you need to understand the question first \nThe have said remove the alphanumeric character ist..which means you should remove everything thing except A-Z,a-z and 0-9 This letters are called alphanumeric all others are non alphanumeric.\nLike **ab@a** will return true since you can remove *@* and string becomes *aba*\n**,.** In this case u should remove both characters Now string becomes **\" \"** empty which will give **true** result.\n\nONE THING YOU NEED TO CONVERT ALL UPPERCASE LETTER TO Lower CASE  AS WELL\nSO String like **AC#A** will give *aca* which will give true result "
                    },
                    {
                        "username": "vlope093",
                        "content": "\"ab@a\" seems to be an invalid test case.\\nForward reads: \"ab@a\" , but backwards reads: a@ba, which is not the same!\\nif we replace \"@\" for \"t\"  =>  \"abta\" != atba\\n\\nPlease fix this!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You don\\'t have understood the question properly The have said remove the alphanumeric character ist..which means you should remove everything thingh except **A-Z,a-z and 0-9** This letters  are called alphanumeric all others are non alphanumeric.\\nSO your Test case become *aba* after removing non alphanumeric *@*.\\nAnd *aba* is palindrome so it should return true"
                    },
                    {
                        "username": "nilsdula",
                        "content": "The example testcases should include a number because way too many people (including yours truly) have failed the 0P testcase."
                    },
                    {
                        "username": "mmtemel",
                        "content": "It says alphanumeric which means consisting of or using both letters and numerals. So 0P must return false. "
                    },
                    {
                        "username": "k_pooja",
                        "content": "can anyone help me with this code \\nit is not passing one test case\\n\\n `class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      \\n        x=s[::-1]\\n        if s.isalnum()==True and s.islower()==True:\\n            for i in range(len(s)):\\n                if s[i]==x[i]:\\n                    return True\\n        elif len(s)==1:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "vsluzky",
                        "content": "I might be wrong, but my solution is not accepted as \"0P\" with zero not letter is expected to be a false palindrome. Looks like an error in the validating case. Can you clarify?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Alphanumeric characters it mean both numeric and alpha character not just alpha character"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Hi Guys, \\n\\njust a Hint:\\n\\nYou don\\'t have to do a for loop to validate every single letter, just compare the actual string against himself but in reverse form.\\n\\n\"amanaplanacanalpanama\" == reverse form \"amanaplanacanalpanama\" in \\n\\nMore details below:\\n\\n\\n\\n\\n\\n\\n\\npython string[::-1] to reverse form.\\n\\nNote: without  non-alphanumeric characters."
                    }
                ]
            },
            {
                "id": 1969370,
                "content": [
                    {
                        "username": "Boysle",
                        "content": "\"Alphanumeric characters include letters and numbers.\" "
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "one test case is wrong \"0P \", we must use isalnum instead of isalpha then"
                    },
                    {
                        "username": "suresh37",
                        "content": "That test case is correct only. \\nas per statement, all Alphanumeric characters include letters and numbers are considered as valid\\nSo, 0P is right test case. most ppl get this TC failed by missing out this detail"
                    },
                    {
                        "username": "suresh37",
                        "content": "\"0P\" gang hit like"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since there are lot of comments regarding invalid test cases So you need to understand the question first \nThe have said remove the alphanumeric character ist..which means you should remove everything thing except A-Z,a-z and 0-9 This letters are called alphanumeric all others are non alphanumeric.\nLike **ab@a** will return true since you can remove *@* and string becomes *aba*\n**,.** In this case u should remove both characters Now string becomes **\" \"** empty which will give **true** result.\n\nONE THING YOU NEED TO CONVERT ALL UPPERCASE LETTER TO Lower CASE  AS WELL\nSO String like **AC#A** will give *aca* which will give true result "
                    },
                    {
                        "username": "vlope093",
                        "content": "\"ab@a\" seems to be an invalid test case.\\nForward reads: \"ab@a\" , but backwards reads: a@ba, which is not the same!\\nif we replace \"@\" for \"t\"  =>  \"abta\" != atba\\n\\nPlease fix this!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You don\\'t have understood the question properly The have said remove the alphanumeric character ist..which means you should remove everything thingh except **A-Z,a-z and 0-9** This letters  are called alphanumeric all others are non alphanumeric.\\nSO your Test case become *aba* after removing non alphanumeric *@*.\\nAnd *aba* is palindrome so it should return true"
                    },
                    {
                        "username": "nilsdula",
                        "content": "The example testcases should include a number because way too many people (including yours truly) have failed the 0P testcase."
                    },
                    {
                        "username": "mmtemel",
                        "content": "It says alphanumeric which means consisting of or using both letters and numerals. So 0P must return false. "
                    },
                    {
                        "username": "k_pooja",
                        "content": "can anyone help me with this code \\nit is not passing one test case\\n\\n `class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      \\n        x=s[::-1]\\n        if s.isalnum()==True and s.islower()==True:\\n            for i in range(len(s)):\\n                if s[i]==x[i]:\\n                    return True\\n        elif len(s)==1:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "vsluzky",
                        "content": "I might be wrong, but my solution is not accepted as \"0P\" with zero not letter is expected to be a false palindrome. Looks like an error in the validating case. Can you clarify?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Alphanumeric characters it mean both numeric and alpha character not just alpha character"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Hi Guys, \\n\\njust a Hint:\\n\\nYou don\\'t have to do a for loop to validate every single letter, just compare the actual string against himself but in reverse form.\\n\\n\"amanaplanacanalpanama\" == reverse form \"amanaplanacanalpanama\" in \\n\\nMore details below:\\n\\n\\n\\n\\n\\n\\n\\npython string[::-1] to reverse form.\\n\\nNote: without  non-alphanumeric characters."
                    }
                ]
            },
            {
                "id": 1964935,
                "content": [
                    {
                        "username": "Boysle",
                        "content": "\"Alphanumeric characters include letters and numbers.\" "
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "one test case is wrong \"0P \", we must use isalnum instead of isalpha then"
                    },
                    {
                        "username": "suresh37",
                        "content": "That test case is correct only. \\nas per statement, all Alphanumeric characters include letters and numbers are considered as valid\\nSo, 0P is right test case. most ppl get this TC failed by missing out this detail"
                    },
                    {
                        "username": "suresh37",
                        "content": "\"0P\" gang hit like"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since there are lot of comments regarding invalid test cases So you need to understand the question first \nThe have said remove the alphanumeric character ist..which means you should remove everything thing except A-Z,a-z and 0-9 This letters are called alphanumeric all others are non alphanumeric.\nLike **ab@a** will return true since you can remove *@* and string becomes *aba*\n**,.** In this case u should remove both characters Now string becomes **\" \"** empty which will give **true** result.\n\nONE THING YOU NEED TO CONVERT ALL UPPERCASE LETTER TO Lower CASE  AS WELL\nSO String like **AC#A** will give *aca* which will give true result "
                    },
                    {
                        "username": "vlope093",
                        "content": "\"ab@a\" seems to be an invalid test case.\\nForward reads: \"ab@a\" , but backwards reads: a@ba, which is not the same!\\nif we replace \"@\" for \"t\"  =>  \"abta\" != atba\\n\\nPlease fix this!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You don\\'t have understood the question properly The have said remove the alphanumeric character ist..which means you should remove everything thingh except **A-Z,a-z and 0-9** This letters  are called alphanumeric all others are non alphanumeric.\\nSO your Test case become *aba* after removing non alphanumeric *@*.\\nAnd *aba* is palindrome so it should return true"
                    },
                    {
                        "username": "nilsdula",
                        "content": "The example testcases should include a number because way too many people (including yours truly) have failed the 0P testcase."
                    },
                    {
                        "username": "mmtemel",
                        "content": "It says alphanumeric which means consisting of or using both letters and numerals. So 0P must return false. "
                    },
                    {
                        "username": "k_pooja",
                        "content": "can anyone help me with this code \\nit is not passing one test case\\n\\n `class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      \\n        x=s[::-1]\\n        if s.isalnum()==True and s.islower()==True:\\n            for i in range(len(s)):\\n                if s[i]==x[i]:\\n                    return True\\n        elif len(s)==1:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "vsluzky",
                        "content": "I might be wrong, but my solution is not accepted as \"0P\" with zero not letter is expected to be a false palindrome. Looks like an error in the validating case. Can you clarify?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Alphanumeric characters it mean both numeric and alpha character not just alpha character"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Hi Guys, \\n\\njust a Hint:\\n\\nYou don\\'t have to do a for loop to validate every single letter, just compare the actual string against himself but in reverse form.\\n\\n\"amanaplanacanalpanama\" == reverse form \"amanaplanacanalpanama\" in \\n\\nMore details below:\\n\\n\\n\\n\\n\\n\\n\\npython string[::-1] to reverse form.\\n\\nNote: without  non-alphanumeric characters."
                    }
                ]
            },
            {
                "id": 1964760,
                "content": [
                    {
                        "username": "Boysle",
                        "content": "\"Alphanumeric characters include letters and numbers.\" "
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "one test case is wrong \"0P \", we must use isalnum instead of isalpha then"
                    },
                    {
                        "username": "suresh37",
                        "content": "That test case is correct only. \\nas per statement, all Alphanumeric characters include letters and numbers are considered as valid\\nSo, 0P is right test case. most ppl get this TC failed by missing out this detail"
                    },
                    {
                        "username": "suresh37",
                        "content": "\"0P\" gang hit like"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since there are lot of comments regarding invalid test cases So you need to understand the question first \nThe have said remove the alphanumeric character ist..which means you should remove everything thing except A-Z,a-z and 0-9 This letters are called alphanumeric all others are non alphanumeric.\nLike **ab@a** will return true since you can remove *@* and string becomes *aba*\n**,.** In this case u should remove both characters Now string becomes **\" \"** empty which will give **true** result.\n\nONE THING YOU NEED TO CONVERT ALL UPPERCASE LETTER TO Lower CASE  AS WELL\nSO String like **AC#A** will give *aca* which will give true result "
                    },
                    {
                        "username": "vlope093",
                        "content": "\"ab@a\" seems to be an invalid test case.\\nForward reads: \"ab@a\" , but backwards reads: a@ba, which is not the same!\\nif we replace \"@\" for \"t\"  =>  \"abta\" != atba\\n\\nPlease fix this!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You don\\'t have understood the question properly The have said remove the alphanumeric character ist..which means you should remove everything thingh except **A-Z,a-z and 0-9** This letters  are called alphanumeric all others are non alphanumeric.\\nSO your Test case become *aba* after removing non alphanumeric *@*.\\nAnd *aba* is palindrome so it should return true"
                    },
                    {
                        "username": "nilsdula",
                        "content": "The example testcases should include a number because way too many people (including yours truly) have failed the 0P testcase."
                    },
                    {
                        "username": "mmtemel",
                        "content": "It says alphanumeric which means consisting of or using both letters and numerals. So 0P must return false. "
                    },
                    {
                        "username": "k_pooja",
                        "content": "can anyone help me with this code \\nit is not passing one test case\\n\\n `class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      \\n        x=s[::-1]\\n        if s.isalnum()==True and s.islower()==True:\\n            for i in range(len(s)):\\n                if s[i]==x[i]:\\n                    return True\\n        elif len(s)==1:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "vsluzky",
                        "content": "I might be wrong, but my solution is not accepted as \"0P\" with zero not letter is expected to be a false palindrome. Looks like an error in the validating case. Can you clarify?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Alphanumeric characters it mean both numeric and alpha character not just alpha character"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Hi Guys, \\n\\njust a Hint:\\n\\nYou don\\'t have to do a for loop to validate every single letter, just compare the actual string against himself but in reverse form.\\n\\n\"amanaplanacanalpanama\" == reverse form \"amanaplanacanalpanama\" in \\n\\nMore details below:\\n\\n\\n\\n\\n\\n\\n\\npython string[::-1] to reverse form.\\n\\nNote: without  non-alphanumeric characters."
                    }
                ]
            },
            {
                "id": 1964211,
                "content": [
                    {
                        "username": "Boysle",
                        "content": "\"Alphanumeric characters include letters and numbers.\" "
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "one test case is wrong \"0P \", we must use isalnum instead of isalpha then"
                    },
                    {
                        "username": "suresh37",
                        "content": "That test case is correct only. \\nas per statement, all Alphanumeric characters include letters and numbers are considered as valid\\nSo, 0P is right test case. most ppl get this TC failed by missing out this detail"
                    },
                    {
                        "username": "suresh37",
                        "content": "\"0P\" gang hit like"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since there are lot of comments regarding invalid test cases So you need to understand the question first \nThe have said remove the alphanumeric character ist..which means you should remove everything thing except A-Z,a-z and 0-9 This letters are called alphanumeric all others are non alphanumeric.\nLike **ab@a** will return true since you can remove *@* and string becomes *aba*\n**,.** In this case u should remove both characters Now string becomes **\" \"** empty which will give **true** result.\n\nONE THING YOU NEED TO CONVERT ALL UPPERCASE LETTER TO Lower CASE  AS WELL\nSO String like **AC#A** will give *aca* which will give true result "
                    },
                    {
                        "username": "vlope093",
                        "content": "\"ab@a\" seems to be an invalid test case.\\nForward reads: \"ab@a\" , but backwards reads: a@ba, which is not the same!\\nif we replace \"@\" for \"t\"  =>  \"abta\" != atba\\n\\nPlease fix this!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You don\\'t have understood the question properly The have said remove the alphanumeric character ist..which means you should remove everything thingh except **A-Z,a-z and 0-9** This letters  are called alphanumeric all others are non alphanumeric.\\nSO your Test case become *aba* after removing non alphanumeric *@*.\\nAnd *aba* is palindrome so it should return true"
                    },
                    {
                        "username": "nilsdula",
                        "content": "The example testcases should include a number because way too many people (including yours truly) have failed the 0P testcase."
                    },
                    {
                        "username": "mmtemel",
                        "content": "It says alphanumeric which means consisting of or using both letters and numerals. So 0P must return false. "
                    },
                    {
                        "username": "k_pooja",
                        "content": "can anyone help me with this code \\nit is not passing one test case\\n\\n `class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      \\n        x=s[::-1]\\n        if s.isalnum()==True and s.islower()==True:\\n            for i in range(len(s)):\\n                if s[i]==x[i]:\\n                    return True\\n        elif len(s)==1:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "vsluzky",
                        "content": "I might be wrong, but my solution is not accepted as \"0P\" with zero not letter is expected to be a false palindrome. Looks like an error in the validating case. Can you clarify?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Alphanumeric characters it mean both numeric and alpha character not just alpha character"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Hi Guys, \\n\\njust a Hint:\\n\\nYou don\\'t have to do a for loop to validate every single letter, just compare the actual string against himself but in reverse form.\\n\\n\"amanaplanacanalpanama\" == reverse form \"amanaplanacanalpanama\" in \\n\\nMore details below:\\n\\n\\n\\n\\n\\n\\n\\npython string[::-1] to reverse form.\\n\\nNote: without  non-alphanumeric characters."
                    }
                ]
            },
            {
                "id": 1963575,
                "content": [
                    {
                        "username": "Boysle",
                        "content": "\"Alphanumeric characters include letters and numbers.\" "
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "one test case is wrong \"0P \", we must use isalnum instead of isalpha then"
                    },
                    {
                        "username": "suresh37",
                        "content": "That test case is correct only. \\nas per statement, all Alphanumeric characters include letters and numbers are considered as valid\\nSo, 0P is right test case. most ppl get this TC failed by missing out this detail"
                    },
                    {
                        "username": "suresh37",
                        "content": "\"0P\" gang hit like"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since there are lot of comments regarding invalid test cases So you need to understand the question first \nThe have said remove the alphanumeric character ist..which means you should remove everything thing except A-Z,a-z and 0-9 This letters are called alphanumeric all others are non alphanumeric.\nLike **ab@a** will return true since you can remove *@* and string becomes *aba*\n**,.** In this case u should remove both characters Now string becomes **\" \"** empty which will give **true** result.\n\nONE THING YOU NEED TO CONVERT ALL UPPERCASE LETTER TO Lower CASE  AS WELL\nSO String like **AC#A** will give *aca* which will give true result "
                    },
                    {
                        "username": "vlope093",
                        "content": "\"ab@a\" seems to be an invalid test case.\\nForward reads: \"ab@a\" , but backwards reads: a@ba, which is not the same!\\nif we replace \"@\" for \"t\"  =>  \"abta\" != atba\\n\\nPlease fix this!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You don\\'t have understood the question properly The have said remove the alphanumeric character ist..which means you should remove everything thingh except **A-Z,a-z and 0-9** This letters  are called alphanumeric all others are non alphanumeric.\\nSO your Test case become *aba* after removing non alphanumeric *@*.\\nAnd *aba* is palindrome so it should return true"
                    },
                    {
                        "username": "nilsdula",
                        "content": "The example testcases should include a number because way too many people (including yours truly) have failed the 0P testcase."
                    },
                    {
                        "username": "mmtemel",
                        "content": "It says alphanumeric which means consisting of or using both letters and numerals. So 0P must return false. "
                    },
                    {
                        "username": "k_pooja",
                        "content": "can anyone help me with this code \\nit is not passing one test case\\n\\n `class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      \\n        x=s[::-1]\\n        if s.isalnum()==True and s.islower()==True:\\n            for i in range(len(s)):\\n                if s[i]==x[i]:\\n                    return True\\n        elif len(s)==1:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "vsluzky",
                        "content": "I might be wrong, but my solution is not accepted as \"0P\" with zero not letter is expected to be a false palindrome. Looks like an error in the validating case. Can you clarify?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Alphanumeric characters it mean both numeric and alpha character not just alpha character"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Hi Guys, \\n\\njust a Hint:\\n\\nYou don\\'t have to do a for loop to validate every single letter, just compare the actual string against himself but in reverse form.\\n\\n\"amanaplanacanalpanama\" == reverse form \"amanaplanacanalpanama\" in \\n\\nMore details below:\\n\\n\\n\\n\\n\\n\\n\\npython string[::-1] to reverse form.\\n\\nNote: without  non-alphanumeric characters."
                    }
                ]
            },
            {
                "id": 1963204,
                "content": [
                    {
                        "username": "Boysle",
                        "content": "\"Alphanumeric characters include letters and numbers.\" "
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "one test case is wrong \"0P \", we must use isalnum instead of isalpha then"
                    },
                    {
                        "username": "suresh37",
                        "content": "That test case is correct only. \\nas per statement, all Alphanumeric characters include letters and numbers are considered as valid\\nSo, 0P is right test case. most ppl get this TC failed by missing out this detail"
                    },
                    {
                        "username": "suresh37",
                        "content": "\"0P\" gang hit like"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since there are lot of comments regarding invalid test cases So you need to understand the question first \nThe have said remove the alphanumeric character ist..which means you should remove everything thing except A-Z,a-z and 0-9 This letters are called alphanumeric all others are non alphanumeric.\nLike **ab@a** will return true since you can remove *@* and string becomes *aba*\n**,.** In this case u should remove both characters Now string becomes **\" \"** empty which will give **true** result.\n\nONE THING YOU NEED TO CONVERT ALL UPPERCASE LETTER TO Lower CASE  AS WELL\nSO String like **AC#A** will give *aca* which will give true result "
                    },
                    {
                        "username": "vlope093",
                        "content": "\"ab@a\" seems to be an invalid test case.\\nForward reads: \"ab@a\" , but backwards reads: a@ba, which is not the same!\\nif we replace \"@\" for \"t\"  =>  \"abta\" != atba\\n\\nPlease fix this!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You don\\'t have understood the question properly The have said remove the alphanumeric character ist..which means you should remove everything thingh except **A-Z,a-z and 0-9** This letters  are called alphanumeric all others are non alphanumeric.\\nSO your Test case become *aba* after removing non alphanumeric *@*.\\nAnd *aba* is palindrome so it should return true"
                    },
                    {
                        "username": "nilsdula",
                        "content": "The example testcases should include a number because way too many people (including yours truly) have failed the 0P testcase."
                    },
                    {
                        "username": "mmtemel",
                        "content": "It says alphanumeric which means consisting of or using both letters and numerals. So 0P must return false. "
                    },
                    {
                        "username": "k_pooja",
                        "content": "can anyone help me with this code \\nit is not passing one test case\\n\\n `class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      \\n        x=s[::-1]\\n        if s.isalnum()==True and s.islower()==True:\\n            for i in range(len(s)):\\n                if s[i]==x[i]:\\n                    return True\\n        elif len(s)==1:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "vsluzky",
                        "content": "I might be wrong, but my solution is not accepted as \"0P\" with zero not letter is expected to be a false palindrome. Looks like an error in the validating case. Can you clarify?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Alphanumeric characters it mean both numeric and alpha character not just alpha character"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Hi Guys, \\n\\njust a Hint:\\n\\nYou don\\'t have to do a for loop to validate every single letter, just compare the actual string against himself but in reverse form.\\n\\n\"amanaplanacanalpanama\" == reverse form \"amanaplanacanalpanama\" in \\n\\nMore details below:\\n\\n\\n\\n\\n\\n\\n\\npython string[::-1] to reverse form.\\n\\nNote: without  non-alphanumeric characters."
                    }
                ]
            },
            {
                "id": 1959363,
                "content": [
                    {
                        "username": "Boysle",
                        "content": "\"Alphanumeric characters include letters and numbers.\" "
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "one test case is wrong \"0P \", we must use isalnum instead of isalpha then"
                    },
                    {
                        "username": "suresh37",
                        "content": "That test case is correct only. \\nas per statement, all Alphanumeric characters include letters and numbers are considered as valid\\nSo, 0P is right test case. most ppl get this TC failed by missing out this detail"
                    },
                    {
                        "username": "suresh37",
                        "content": "\"0P\" gang hit like"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since there are lot of comments regarding invalid test cases So you need to understand the question first \nThe have said remove the alphanumeric character ist..which means you should remove everything thing except A-Z,a-z and 0-9 This letters are called alphanumeric all others are non alphanumeric.\nLike **ab@a** will return true since you can remove *@* and string becomes *aba*\n**,.** In this case u should remove both characters Now string becomes **\" \"** empty which will give **true** result.\n\nONE THING YOU NEED TO CONVERT ALL UPPERCASE LETTER TO Lower CASE  AS WELL\nSO String like **AC#A** will give *aca* which will give true result "
                    },
                    {
                        "username": "vlope093",
                        "content": "\"ab@a\" seems to be an invalid test case.\\nForward reads: \"ab@a\" , but backwards reads: a@ba, which is not the same!\\nif we replace \"@\" for \"t\"  =>  \"abta\" != atba\\n\\nPlease fix this!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You don\\'t have understood the question properly The have said remove the alphanumeric character ist..which means you should remove everything thingh except **A-Z,a-z and 0-9** This letters  are called alphanumeric all others are non alphanumeric.\\nSO your Test case become *aba* after removing non alphanumeric *@*.\\nAnd *aba* is palindrome so it should return true"
                    },
                    {
                        "username": "nilsdula",
                        "content": "The example testcases should include a number because way too many people (including yours truly) have failed the 0P testcase."
                    },
                    {
                        "username": "mmtemel",
                        "content": "It says alphanumeric which means consisting of or using both letters and numerals. So 0P must return false. "
                    },
                    {
                        "username": "k_pooja",
                        "content": "can anyone help me with this code \\nit is not passing one test case\\n\\n `class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      \\n        x=s[::-1]\\n        if s.isalnum()==True and s.islower()==True:\\n            for i in range(len(s)):\\n                if s[i]==x[i]:\\n                    return True\\n        elif len(s)==1:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "vsluzky",
                        "content": "I might be wrong, but my solution is not accepted as \"0P\" with zero not letter is expected to be a false palindrome. Looks like an error in the validating case. Can you clarify?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Alphanumeric characters it mean both numeric and alpha character not just alpha character"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Hi Guys, \\n\\njust a Hint:\\n\\nYou don\\'t have to do a for loop to validate every single letter, just compare the actual string against himself but in reverse form.\\n\\n\"amanaplanacanalpanama\" == reverse form \"amanaplanacanalpanama\" in \\n\\nMore details below:\\n\\n\\n\\n\\n\\n\\n\\npython string[::-1] to reverse form.\\n\\nNote: without  non-alphanumeric characters."
                    }
                ]
            },
            {
                "id": 1956663,
                "content": [
                    {
                        "username": "Boysle",
                        "content": "\"Alphanumeric characters include letters and numbers.\" "
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "one test case is wrong \"0P \", we must use isalnum instead of isalpha then"
                    },
                    {
                        "username": "suresh37",
                        "content": "That test case is correct only. \\nas per statement, all Alphanumeric characters include letters and numbers are considered as valid\\nSo, 0P is right test case. most ppl get this TC failed by missing out this detail"
                    },
                    {
                        "username": "suresh37",
                        "content": "\"0P\" gang hit like"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since there are lot of comments regarding invalid test cases So you need to understand the question first \nThe have said remove the alphanumeric character ist..which means you should remove everything thing except A-Z,a-z and 0-9 This letters are called alphanumeric all others are non alphanumeric.\nLike **ab@a** will return true since you can remove *@* and string becomes *aba*\n**,.** In this case u should remove both characters Now string becomes **\" \"** empty which will give **true** result.\n\nONE THING YOU NEED TO CONVERT ALL UPPERCASE LETTER TO Lower CASE  AS WELL\nSO String like **AC#A** will give *aca* which will give true result "
                    },
                    {
                        "username": "vlope093",
                        "content": "\"ab@a\" seems to be an invalid test case.\\nForward reads: \"ab@a\" , but backwards reads: a@ba, which is not the same!\\nif we replace \"@\" for \"t\"  =>  \"abta\" != atba\\n\\nPlease fix this!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You don\\'t have understood the question properly The have said remove the alphanumeric character ist..which means you should remove everything thingh except **A-Z,a-z and 0-9** This letters  are called alphanumeric all others are non alphanumeric.\\nSO your Test case become *aba* after removing non alphanumeric *@*.\\nAnd *aba* is palindrome so it should return true"
                    },
                    {
                        "username": "nilsdula",
                        "content": "The example testcases should include a number because way too many people (including yours truly) have failed the 0P testcase."
                    },
                    {
                        "username": "mmtemel",
                        "content": "It says alphanumeric which means consisting of or using both letters and numerals. So 0P must return false. "
                    },
                    {
                        "username": "k_pooja",
                        "content": "can anyone help me with this code \\nit is not passing one test case\\n\\n `class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n      \\n        x=s[::-1]\\n        if s.isalnum()==True and s.islower()==True:\\n            for i in range(len(s)):\\n                if s[i]==x[i]:\\n                    return True\\n        elif len(s)==1:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "vsluzky",
                        "content": "I might be wrong, but my solution is not accepted as \"0P\" with zero not letter is expected to be a false palindrome. Looks like an error in the validating case. Can you clarify?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Alphanumeric characters it mean both numeric and alpha character not just alpha character"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Hi Guys, \\n\\njust a Hint:\\n\\nYou don\\'t have to do a for loop to validate every single letter, just compare the actual string against himself but in reverse form.\\n\\n\"amanaplanacanalpanama\" == reverse form \"amanaplanacanalpanama\" in \\n\\nMore details below:\\n\\n\\n\\n\\n\\n\\n\\npython string[::-1] to reverse form.\\n\\nNote: without  non-alphanumeric characters."
                    }
                ]
            },
            {
                "id": 1955154,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "so why is this true \"ab_a\", its case 484"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because _ underscore is not alphanumeric so you should remove this and than it's true"
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "I did this by using for loop.\nit costs more time and beats 36%.\nAs we have to remove non alphanumeric first.\nAny other way to do it using for loop with better results."
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Just remove alphanumeric first, and then compare s == s[::-1] without loop, you don\\'t need loop in this problem. "
                    },
                    {
                        "username": "thesupermanreturns",
                        "content": "can anyone please tell what is wrong with this logic. Test cases are not passing\\n//traverse using two pointers\\n//check if letter is uppercase and convert temporarily to lowercase and check\\n//if no match then false \\n//add 32 to uppercase to convert it to lowercase \\n`class Solution {\\n    public boolean isPalindrome(String s) {\\n        int first = 0, last = s.length()-1;\\n\\n        while(first < last){\\n            char f = s.charAt(first);\\n            char l = s.charAt(last);\\n            if(f<=\\'Z\\' && f>=\\'A\\'){\\n                f = (char)(f + 32);\\n            }\\n            if(l >= \\'A\\' && l <= \\'Z\\'){\\n                l = (char)(l + 32);\\n            }\\n\\n            if(( f >= \\'a\\' && f <= \\'z\\') && (l <= \\'z\\' && l >= \\'a\\')){\\n                if(f != l){\\n                    return false;\\n                } \\n               \\n            }\\n            first++;\\n            last--;\\n        }\\n        return true;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "is using regex fine or not ?"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@jyothienarendramath252](/jyothienarendramath252) thanks bro"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "it\\'s fine. but not efficient as it involves Excessive backtracking with regex matching"
                    },
                    {
                        "username": "cookieslasher",
                        "content": "Why is s=\".,\" true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "\".,\" is non-alphanumeric which will be removed. what left out is empty string \\'\\' which is palindrome as its the same string if we reverse it."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Cause they get remove and return \\u201C\\u201D and \\u201C\\u201D"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.size();i++){\\n            s[i] = tolower(s[i]);\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'A\\' && s[i]<=\\'Z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                v.push_back(s[i]);\\n            }\\n        for(int i=0;i<v.size();i++){\\n            if(v[v.size()-i-1]!=v[i]){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nmy test case 1 is failed can anyone explain this."
                    },
                    {
                        "username": "RicoRodriges",
                        "content": "why some testcases do not display \"stdout\"? its annoying, i cant debug my code here!"
                    },
                    {
                        "username": "sainath81061",
                        "content": "using System.Text.RegularExpressions;\n\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n         string pattern = \"[^a-zA-Z0-9]\";\n//Upper case string to Lower case string\n         s = s.ToLower();\n        bool b  = false;\n//Checking string is empty or not \n        if(s == \" \"){\n            b = true;\n            return b;\n        }\n         char[] chars = s.ToCharArray();\n    \n        int start = 0;\n        int end = s.Length -1;   \n//Reverse the given string \n        while(start < end)\n        {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;    \n            end--;  \n        }\n//storing the string \n        string rev = new string(chars);\n//Removing the special characters\n        s = Regex.Replace(s, pattern, \"\");\n        s  = Regex.Replace(s, @\"\\s+\", \"\");\n        rev = Regex.Replace(rev, pattern, \"\");\n        rev = Regex.Replace(rev, @\"\\s+\", \"\");\n\n//Checking the Condition given string and reverse string equal or not \n           if(s  == rev){\n            b = true;\n            return b;\n        }else{\n           return false;\n        }\n        \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY IS THIS CODE FAILING FOR \"0P\" testcase\\nPLEASE HELP;\\nint n=s.length();\\n        if(n==1)\\n        return true;\\n\\n        ArrayList<Character> al=new ArrayList<Character>();\\n        s=s.replaceAll(\"\\\\\\\\s\", \"\");\\n        s=s.toLowerCase();\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i);\\n            if(a>=97 && a<=122)\\n            al.add(s.charAt(i));\\n        }\\n        int an=al.size();\\n\\n        int start=0;\\n        int end=an-1;\\n        while(start<=end)\\n        {\\n            if(al.get(start)==al.get(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n           else\\n           return false;\\n            \\n        }\\n\\n        return true;\\n        "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "the description: ...Alphanumeric characters include letters and numbers.\\nbut!: the test case:\\n\\nWrong Answer\\n\\n480 / 485 testcases passed\\nInput\\ns =\\n\".\"\\nUse Testcase\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nwhaaaa? why the dot matters?\\n"
                    }
                ]
            },
            {
                "id": 1954275,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "so why is this true \"ab_a\", its case 484"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because _ underscore is not alphanumeric so you should remove this and than it's true"
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "I did this by using for loop.\nit costs more time and beats 36%.\nAs we have to remove non alphanumeric first.\nAny other way to do it using for loop with better results."
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Just remove alphanumeric first, and then compare s == s[::-1] without loop, you don\\'t need loop in this problem. "
                    },
                    {
                        "username": "thesupermanreturns",
                        "content": "can anyone please tell what is wrong with this logic. Test cases are not passing\\n//traverse using two pointers\\n//check if letter is uppercase and convert temporarily to lowercase and check\\n//if no match then false \\n//add 32 to uppercase to convert it to lowercase \\n`class Solution {\\n    public boolean isPalindrome(String s) {\\n        int first = 0, last = s.length()-1;\\n\\n        while(first < last){\\n            char f = s.charAt(first);\\n            char l = s.charAt(last);\\n            if(f<=\\'Z\\' && f>=\\'A\\'){\\n                f = (char)(f + 32);\\n            }\\n            if(l >= \\'A\\' && l <= \\'Z\\'){\\n                l = (char)(l + 32);\\n            }\\n\\n            if(( f >= \\'a\\' && f <= \\'z\\') && (l <= \\'z\\' && l >= \\'a\\')){\\n                if(f != l){\\n                    return false;\\n                } \\n               \\n            }\\n            first++;\\n            last--;\\n        }\\n        return true;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "is using regex fine or not ?"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@jyothienarendramath252](/jyothienarendramath252) thanks bro"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "it\\'s fine. but not efficient as it involves Excessive backtracking with regex matching"
                    },
                    {
                        "username": "cookieslasher",
                        "content": "Why is s=\".,\" true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "\".,\" is non-alphanumeric which will be removed. what left out is empty string \\'\\' which is palindrome as its the same string if we reverse it."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Cause they get remove and return \\u201C\\u201D and \\u201C\\u201D"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.size();i++){\\n            s[i] = tolower(s[i]);\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'A\\' && s[i]<=\\'Z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                v.push_back(s[i]);\\n            }\\n        for(int i=0;i<v.size();i++){\\n            if(v[v.size()-i-1]!=v[i]){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nmy test case 1 is failed can anyone explain this."
                    },
                    {
                        "username": "RicoRodriges",
                        "content": "why some testcases do not display \"stdout\"? its annoying, i cant debug my code here!"
                    },
                    {
                        "username": "sainath81061",
                        "content": "using System.Text.RegularExpressions;\n\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n         string pattern = \"[^a-zA-Z0-9]\";\n//Upper case string to Lower case string\n         s = s.ToLower();\n        bool b  = false;\n//Checking string is empty or not \n        if(s == \" \"){\n            b = true;\n            return b;\n        }\n         char[] chars = s.ToCharArray();\n    \n        int start = 0;\n        int end = s.Length -1;   \n//Reverse the given string \n        while(start < end)\n        {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;    \n            end--;  \n        }\n//storing the string \n        string rev = new string(chars);\n//Removing the special characters\n        s = Regex.Replace(s, pattern, \"\");\n        s  = Regex.Replace(s, @\"\\s+\", \"\");\n        rev = Regex.Replace(rev, pattern, \"\");\n        rev = Regex.Replace(rev, @\"\\s+\", \"\");\n\n//Checking the Condition given string and reverse string equal or not \n           if(s  == rev){\n            b = true;\n            return b;\n        }else{\n           return false;\n        }\n        \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY IS THIS CODE FAILING FOR \"0P\" testcase\\nPLEASE HELP;\\nint n=s.length();\\n        if(n==1)\\n        return true;\\n\\n        ArrayList<Character> al=new ArrayList<Character>();\\n        s=s.replaceAll(\"\\\\\\\\s\", \"\");\\n        s=s.toLowerCase();\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i);\\n            if(a>=97 && a<=122)\\n            al.add(s.charAt(i));\\n        }\\n        int an=al.size();\\n\\n        int start=0;\\n        int end=an-1;\\n        while(start<=end)\\n        {\\n            if(al.get(start)==al.get(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n           else\\n           return false;\\n            \\n        }\\n\\n        return true;\\n        "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "the description: ...Alphanumeric characters include letters and numbers.\\nbut!: the test case:\\n\\nWrong Answer\\n\\n480 / 485 testcases passed\\nInput\\ns =\\n\".\"\\nUse Testcase\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nwhaaaa? why the dot matters?\\n"
                    }
                ]
            },
            {
                "id": 1949557,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "so why is this true \"ab_a\", its case 484"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because _ underscore is not alphanumeric so you should remove this and than it's true"
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "I did this by using for loop.\nit costs more time and beats 36%.\nAs we have to remove non alphanumeric first.\nAny other way to do it using for loop with better results."
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Just remove alphanumeric first, and then compare s == s[::-1] without loop, you don\\'t need loop in this problem. "
                    },
                    {
                        "username": "thesupermanreturns",
                        "content": "can anyone please tell what is wrong with this logic. Test cases are not passing\\n//traverse using two pointers\\n//check if letter is uppercase and convert temporarily to lowercase and check\\n//if no match then false \\n//add 32 to uppercase to convert it to lowercase \\n`class Solution {\\n    public boolean isPalindrome(String s) {\\n        int first = 0, last = s.length()-1;\\n\\n        while(first < last){\\n            char f = s.charAt(first);\\n            char l = s.charAt(last);\\n            if(f<=\\'Z\\' && f>=\\'A\\'){\\n                f = (char)(f + 32);\\n            }\\n            if(l >= \\'A\\' && l <= \\'Z\\'){\\n                l = (char)(l + 32);\\n            }\\n\\n            if(( f >= \\'a\\' && f <= \\'z\\') && (l <= \\'z\\' && l >= \\'a\\')){\\n                if(f != l){\\n                    return false;\\n                } \\n               \\n            }\\n            first++;\\n            last--;\\n        }\\n        return true;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "is using regex fine or not ?"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@jyothienarendramath252](/jyothienarendramath252) thanks bro"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "it\\'s fine. but not efficient as it involves Excessive backtracking with regex matching"
                    },
                    {
                        "username": "cookieslasher",
                        "content": "Why is s=\".,\" true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "\".,\" is non-alphanumeric which will be removed. what left out is empty string \\'\\' which is palindrome as its the same string if we reverse it."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Cause they get remove and return \\u201C\\u201D and \\u201C\\u201D"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.size();i++){\\n            s[i] = tolower(s[i]);\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'A\\' && s[i]<=\\'Z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                v.push_back(s[i]);\\n            }\\n        for(int i=0;i<v.size();i++){\\n            if(v[v.size()-i-1]!=v[i]){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nmy test case 1 is failed can anyone explain this."
                    },
                    {
                        "username": "RicoRodriges",
                        "content": "why some testcases do not display \"stdout\"? its annoying, i cant debug my code here!"
                    },
                    {
                        "username": "sainath81061",
                        "content": "using System.Text.RegularExpressions;\n\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n         string pattern = \"[^a-zA-Z0-9]\";\n//Upper case string to Lower case string\n         s = s.ToLower();\n        bool b  = false;\n//Checking string is empty or not \n        if(s == \" \"){\n            b = true;\n            return b;\n        }\n         char[] chars = s.ToCharArray();\n    \n        int start = 0;\n        int end = s.Length -1;   \n//Reverse the given string \n        while(start < end)\n        {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;    \n            end--;  \n        }\n//storing the string \n        string rev = new string(chars);\n//Removing the special characters\n        s = Regex.Replace(s, pattern, \"\");\n        s  = Regex.Replace(s, @\"\\s+\", \"\");\n        rev = Regex.Replace(rev, pattern, \"\");\n        rev = Regex.Replace(rev, @\"\\s+\", \"\");\n\n//Checking the Condition given string and reverse string equal or not \n           if(s  == rev){\n            b = true;\n            return b;\n        }else{\n           return false;\n        }\n        \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY IS THIS CODE FAILING FOR \"0P\" testcase\\nPLEASE HELP;\\nint n=s.length();\\n        if(n==1)\\n        return true;\\n\\n        ArrayList<Character> al=new ArrayList<Character>();\\n        s=s.replaceAll(\"\\\\\\\\s\", \"\");\\n        s=s.toLowerCase();\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i);\\n            if(a>=97 && a<=122)\\n            al.add(s.charAt(i));\\n        }\\n        int an=al.size();\\n\\n        int start=0;\\n        int end=an-1;\\n        while(start<=end)\\n        {\\n            if(al.get(start)==al.get(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n           else\\n           return false;\\n            \\n        }\\n\\n        return true;\\n        "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "the description: ...Alphanumeric characters include letters and numbers.\\nbut!: the test case:\\n\\nWrong Answer\\n\\n480 / 485 testcases passed\\nInput\\ns =\\n\".\"\\nUse Testcase\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nwhaaaa? why the dot matters?\\n"
                    }
                ]
            },
            {
                "id": 1948047,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "so why is this true \"ab_a\", its case 484"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because _ underscore is not alphanumeric so you should remove this and than it's true"
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "I did this by using for loop.\nit costs more time and beats 36%.\nAs we have to remove non alphanumeric first.\nAny other way to do it using for loop with better results."
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Just remove alphanumeric first, and then compare s == s[::-1] without loop, you don\\'t need loop in this problem. "
                    },
                    {
                        "username": "thesupermanreturns",
                        "content": "can anyone please tell what is wrong with this logic. Test cases are not passing\\n//traverse using two pointers\\n//check if letter is uppercase and convert temporarily to lowercase and check\\n//if no match then false \\n//add 32 to uppercase to convert it to lowercase \\n`class Solution {\\n    public boolean isPalindrome(String s) {\\n        int first = 0, last = s.length()-1;\\n\\n        while(first < last){\\n            char f = s.charAt(first);\\n            char l = s.charAt(last);\\n            if(f<=\\'Z\\' && f>=\\'A\\'){\\n                f = (char)(f + 32);\\n            }\\n            if(l >= \\'A\\' && l <= \\'Z\\'){\\n                l = (char)(l + 32);\\n            }\\n\\n            if(( f >= \\'a\\' && f <= \\'z\\') && (l <= \\'z\\' && l >= \\'a\\')){\\n                if(f != l){\\n                    return false;\\n                } \\n               \\n            }\\n            first++;\\n            last--;\\n        }\\n        return true;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "is using regex fine or not ?"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@jyothienarendramath252](/jyothienarendramath252) thanks bro"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "it\\'s fine. but not efficient as it involves Excessive backtracking with regex matching"
                    },
                    {
                        "username": "cookieslasher",
                        "content": "Why is s=\".,\" true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "\".,\" is non-alphanumeric which will be removed. what left out is empty string \\'\\' which is palindrome as its the same string if we reverse it."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Cause they get remove and return \\u201C\\u201D and \\u201C\\u201D"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.size();i++){\\n            s[i] = tolower(s[i]);\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'A\\' && s[i]<=\\'Z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                v.push_back(s[i]);\\n            }\\n        for(int i=0;i<v.size();i++){\\n            if(v[v.size()-i-1]!=v[i]){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nmy test case 1 is failed can anyone explain this."
                    },
                    {
                        "username": "RicoRodriges",
                        "content": "why some testcases do not display \"stdout\"? its annoying, i cant debug my code here!"
                    },
                    {
                        "username": "sainath81061",
                        "content": "using System.Text.RegularExpressions;\n\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n         string pattern = \"[^a-zA-Z0-9]\";\n//Upper case string to Lower case string\n         s = s.ToLower();\n        bool b  = false;\n//Checking string is empty or not \n        if(s == \" \"){\n            b = true;\n            return b;\n        }\n         char[] chars = s.ToCharArray();\n    \n        int start = 0;\n        int end = s.Length -1;   \n//Reverse the given string \n        while(start < end)\n        {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;    \n            end--;  \n        }\n//storing the string \n        string rev = new string(chars);\n//Removing the special characters\n        s = Regex.Replace(s, pattern, \"\");\n        s  = Regex.Replace(s, @\"\\s+\", \"\");\n        rev = Regex.Replace(rev, pattern, \"\");\n        rev = Regex.Replace(rev, @\"\\s+\", \"\");\n\n//Checking the Condition given string and reverse string equal or not \n           if(s  == rev){\n            b = true;\n            return b;\n        }else{\n           return false;\n        }\n        \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY IS THIS CODE FAILING FOR \"0P\" testcase\\nPLEASE HELP;\\nint n=s.length();\\n        if(n==1)\\n        return true;\\n\\n        ArrayList<Character> al=new ArrayList<Character>();\\n        s=s.replaceAll(\"\\\\\\\\s\", \"\");\\n        s=s.toLowerCase();\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i);\\n            if(a>=97 && a<=122)\\n            al.add(s.charAt(i));\\n        }\\n        int an=al.size();\\n\\n        int start=0;\\n        int end=an-1;\\n        while(start<=end)\\n        {\\n            if(al.get(start)==al.get(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n           else\\n           return false;\\n            \\n        }\\n\\n        return true;\\n        "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "the description: ...Alphanumeric characters include letters and numbers.\\nbut!: the test case:\\n\\nWrong Answer\\n\\n480 / 485 testcases passed\\nInput\\ns =\\n\".\"\\nUse Testcase\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nwhaaaa? why the dot matters?\\n"
                    }
                ]
            },
            {
                "id": 1944071,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "so why is this true \"ab_a\", its case 484"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because _ underscore is not alphanumeric so you should remove this and than it's true"
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "I did this by using for loop.\nit costs more time and beats 36%.\nAs we have to remove non alphanumeric first.\nAny other way to do it using for loop with better results."
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Just remove alphanumeric first, and then compare s == s[::-1] without loop, you don\\'t need loop in this problem. "
                    },
                    {
                        "username": "thesupermanreturns",
                        "content": "can anyone please tell what is wrong with this logic. Test cases are not passing\\n//traverse using two pointers\\n//check if letter is uppercase and convert temporarily to lowercase and check\\n//if no match then false \\n//add 32 to uppercase to convert it to lowercase \\n`class Solution {\\n    public boolean isPalindrome(String s) {\\n        int first = 0, last = s.length()-1;\\n\\n        while(first < last){\\n            char f = s.charAt(first);\\n            char l = s.charAt(last);\\n            if(f<=\\'Z\\' && f>=\\'A\\'){\\n                f = (char)(f + 32);\\n            }\\n            if(l >= \\'A\\' && l <= \\'Z\\'){\\n                l = (char)(l + 32);\\n            }\\n\\n            if(( f >= \\'a\\' && f <= \\'z\\') && (l <= \\'z\\' && l >= \\'a\\')){\\n                if(f != l){\\n                    return false;\\n                } \\n               \\n            }\\n            first++;\\n            last--;\\n        }\\n        return true;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "is using regex fine or not ?"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@jyothienarendramath252](/jyothienarendramath252) thanks bro"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "it\\'s fine. but not efficient as it involves Excessive backtracking with regex matching"
                    },
                    {
                        "username": "cookieslasher",
                        "content": "Why is s=\".,\" true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "\".,\" is non-alphanumeric which will be removed. what left out is empty string \\'\\' which is palindrome as its the same string if we reverse it."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Cause they get remove and return \\u201C\\u201D and \\u201C\\u201D"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.size();i++){\\n            s[i] = tolower(s[i]);\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'A\\' && s[i]<=\\'Z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                v.push_back(s[i]);\\n            }\\n        for(int i=0;i<v.size();i++){\\n            if(v[v.size()-i-1]!=v[i]){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nmy test case 1 is failed can anyone explain this."
                    },
                    {
                        "username": "RicoRodriges",
                        "content": "why some testcases do not display \"stdout\"? its annoying, i cant debug my code here!"
                    },
                    {
                        "username": "sainath81061",
                        "content": "using System.Text.RegularExpressions;\n\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n         string pattern = \"[^a-zA-Z0-9]\";\n//Upper case string to Lower case string\n         s = s.ToLower();\n        bool b  = false;\n//Checking string is empty or not \n        if(s == \" \"){\n            b = true;\n            return b;\n        }\n         char[] chars = s.ToCharArray();\n    \n        int start = 0;\n        int end = s.Length -1;   \n//Reverse the given string \n        while(start < end)\n        {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;    \n            end--;  \n        }\n//storing the string \n        string rev = new string(chars);\n//Removing the special characters\n        s = Regex.Replace(s, pattern, \"\");\n        s  = Regex.Replace(s, @\"\\s+\", \"\");\n        rev = Regex.Replace(rev, pattern, \"\");\n        rev = Regex.Replace(rev, @\"\\s+\", \"\");\n\n//Checking the Condition given string and reverse string equal or not \n           if(s  == rev){\n            b = true;\n            return b;\n        }else{\n           return false;\n        }\n        \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY IS THIS CODE FAILING FOR \"0P\" testcase\\nPLEASE HELP;\\nint n=s.length();\\n        if(n==1)\\n        return true;\\n\\n        ArrayList<Character> al=new ArrayList<Character>();\\n        s=s.replaceAll(\"\\\\\\\\s\", \"\");\\n        s=s.toLowerCase();\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i);\\n            if(a>=97 && a<=122)\\n            al.add(s.charAt(i));\\n        }\\n        int an=al.size();\\n\\n        int start=0;\\n        int end=an-1;\\n        while(start<=end)\\n        {\\n            if(al.get(start)==al.get(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n           else\\n           return false;\\n            \\n        }\\n\\n        return true;\\n        "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "the description: ...Alphanumeric characters include letters and numbers.\\nbut!: the test case:\\n\\nWrong Answer\\n\\n480 / 485 testcases passed\\nInput\\ns =\\n\".\"\\nUse Testcase\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nwhaaaa? why the dot matters?\\n"
                    }
                ]
            },
            {
                "id": 1939519,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "so why is this true \"ab_a\", its case 484"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because _ underscore is not alphanumeric so you should remove this and than it's true"
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "I did this by using for loop.\nit costs more time and beats 36%.\nAs we have to remove non alphanumeric first.\nAny other way to do it using for loop with better results."
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Just remove alphanumeric first, and then compare s == s[::-1] without loop, you don\\'t need loop in this problem. "
                    },
                    {
                        "username": "thesupermanreturns",
                        "content": "can anyone please tell what is wrong with this logic. Test cases are not passing\\n//traverse using two pointers\\n//check if letter is uppercase and convert temporarily to lowercase and check\\n//if no match then false \\n//add 32 to uppercase to convert it to lowercase \\n`class Solution {\\n    public boolean isPalindrome(String s) {\\n        int first = 0, last = s.length()-1;\\n\\n        while(first < last){\\n            char f = s.charAt(first);\\n            char l = s.charAt(last);\\n            if(f<=\\'Z\\' && f>=\\'A\\'){\\n                f = (char)(f + 32);\\n            }\\n            if(l >= \\'A\\' && l <= \\'Z\\'){\\n                l = (char)(l + 32);\\n            }\\n\\n            if(( f >= \\'a\\' && f <= \\'z\\') && (l <= \\'z\\' && l >= \\'a\\')){\\n                if(f != l){\\n                    return false;\\n                } \\n               \\n            }\\n            first++;\\n            last--;\\n        }\\n        return true;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "is using regex fine or not ?"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@jyothienarendramath252](/jyothienarendramath252) thanks bro"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "it\\'s fine. but not efficient as it involves Excessive backtracking with regex matching"
                    },
                    {
                        "username": "cookieslasher",
                        "content": "Why is s=\".,\" true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "\".,\" is non-alphanumeric which will be removed. what left out is empty string \\'\\' which is palindrome as its the same string if we reverse it."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Cause they get remove and return \\u201C\\u201D and \\u201C\\u201D"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.size();i++){\\n            s[i] = tolower(s[i]);\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'A\\' && s[i]<=\\'Z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                v.push_back(s[i]);\\n            }\\n        for(int i=0;i<v.size();i++){\\n            if(v[v.size()-i-1]!=v[i]){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nmy test case 1 is failed can anyone explain this."
                    },
                    {
                        "username": "RicoRodriges",
                        "content": "why some testcases do not display \"stdout\"? its annoying, i cant debug my code here!"
                    },
                    {
                        "username": "sainath81061",
                        "content": "using System.Text.RegularExpressions;\n\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n         string pattern = \"[^a-zA-Z0-9]\";\n//Upper case string to Lower case string\n         s = s.ToLower();\n        bool b  = false;\n//Checking string is empty or not \n        if(s == \" \"){\n            b = true;\n            return b;\n        }\n         char[] chars = s.ToCharArray();\n    \n        int start = 0;\n        int end = s.Length -1;   \n//Reverse the given string \n        while(start < end)\n        {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;    \n            end--;  \n        }\n//storing the string \n        string rev = new string(chars);\n//Removing the special characters\n        s = Regex.Replace(s, pattern, \"\");\n        s  = Regex.Replace(s, @\"\\s+\", \"\");\n        rev = Regex.Replace(rev, pattern, \"\");\n        rev = Regex.Replace(rev, @\"\\s+\", \"\");\n\n//Checking the Condition given string and reverse string equal or not \n           if(s  == rev){\n            b = true;\n            return b;\n        }else{\n           return false;\n        }\n        \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY IS THIS CODE FAILING FOR \"0P\" testcase\\nPLEASE HELP;\\nint n=s.length();\\n        if(n==1)\\n        return true;\\n\\n        ArrayList<Character> al=new ArrayList<Character>();\\n        s=s.replaceAll(\"\\\\\\\\s\", \"\");\\n        s=s.toLowerCase();\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i);\\n            if(a>=97 && a<=122)\\n            al.add(s.charAt(i));\\n        }\\n        int an=al.size();\\n\\n        int start=0;\\n        int end=an-1;\\n        while(start<=end)\\n        {\\n            if(al.get(start)==al.get(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n           else\\n           return false;\\n            \\n        }\\n\\n        return true;\\n        "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "the description: ...Alphanumeric characters include letters and numbers.\\nbut!: the test case:\\n\\nWrong Answer\\n\\n480 / 485 testcases passed\\nInput\\ns =\\n\".\"\\nUse Testcase\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nwhaaaa? why the dot matters?\\n"
                    }
                ]
            },
            {
                "id": 1934965,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "so why is this true \"ab_a\", its case 484"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because _ underscore is not alphanumeric so you should remove this and than it's true"
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "I did this by using for loop.\nit costs more time and beats 36%.\nAs we have to remove non alphanumeric first.\nAny other way to do it using for loop with better results."
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Just remove alphanumeric first, and then compare s == s[::-1] without loop, you don\\'t need loop in this problem. "
                    },
                    {
                        "username": "thesupermanreturns",
                        "content": "can anyone please tell what is wrong with this logic. Test cases are not passing\\n//traverse using two pointers\\n//check if letter is uppercase and convert temporarily to lowercase and check\\n//if no match then false \\n//add 32 to uppercase to convert it to lowercase \\n`class Solution {\\n    public boolean isPalindrome(String s) {\\n        int first = 0, last = s.length()-1;\\n\\n        while(first < last){\\n            char f = s.charAt(first);\\n            char l = s.charAt(last);\\n            if(f<=\\'Z\\' && f>=\\'A\\'){\\n                f = (char)(f + 32);\\n            }\\n            if(l >= \\'A\\' && l <= \\'Z\\'){\\n                l = (char)(l + 32);\\n            }\\n\\n            if(( f >= \\'a\\' && f <= \\'z\\') && (l <= \\'z\\' && l >= \\'a\\')){\\n                if(f != l){\\n                    return false;\\n                } \\n               \\n            }\\n            first++;\\n            last--;\\n        }\\n        return true;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "is using regex fine or not ?"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@jyothienarendramath252](/jyothienarendramath252) thanks bro"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "it\\'s fine. but not efficient as it involves Excessive backtracking with regex matching"
                    },
                    {
                        "username": "cookieslasher",
                        "content": "Why is s=\".,\" true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "\".,\" is non-alphanumeric which will be removed. what left out is empty string \\'\\' which is palindrome as its the same string if we reverse it."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Cause they get remove and return \\u201C\\u201D and \\u201C\\u201D"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.size();i++){\\n            s[i] = tolower(s[i]);\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'A\\' && s[i]<=\\'Z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                v.push_back(s[i]);\\n            }\\n        for(int i=0;i<v.size();i++){\\n            if(v[v.size()-i-1]!=v[i]){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nmy test case 1 is failed can anyone explain this."
                    },
                    {
                        "username": "RicoRodriges",
                        "content": "why some testcases do not display \"stdout\"? its annoying, i cant debug my code here!"
                    },
                    {
                        "username": "sainath81061",
                        "content": "using System.Text.RegularExpressions;\n\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n         string pattern = \"[^a-zA-Z0-9]\";\n//Upper case string to Lower case string\n         s = s.ToLower();\n        bool b  = false;\n//Checking string is empty or not \n        if(s == \" \"){\n            b = true;\n            return b;\n        }\n         char[] chars = s.ToCharArray();\n    \n        int start = 0;\n        int end = s.Length -1;   \n//Reverse the given string \n        while(start < end)\n        {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;    \n            end--;  \n        }\n//storing the string \n        string rev = new string(chars);\n//Removing the special characters\n        s = Regex.Replace(s, pattern, \"\");\n        s  = Regex.Replace(s, @\"\\s+\", \"\");\n        rev = Regex.Replace(rev, pattern, \"\");\n        rev = Regex.Replace(rev, @\"\\s+\", \"\");\n\n//Checking the Condition given string and reverse string equal or not \n           if(s  == rev){\n            b = true;\n            return b;\n        }else{\n           return false;\n        }\n        \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY IS THIS CODE FAILING FOR \"0P\" testcase\\nPLEASE HELP;\\nint n=s.length();\\n        if(n==1)\\n        return true;\\n\\n        ArrayList<Character> al=new ArrayList<Character>();\\n        s=s.replaceAll(\"\\\\\\\\s\", \"\");\\n        s=s.toLowerCase();\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i);\\n            if(a>=97 && a<=122)\\n            al.add(s.charAt(i));\\n        }\\n        int an=al.size();\\n\\n        int start=0;\\n        int end=an-1;\\n        while(start<=end)\\n        {\\n            if(al.get(start)==al.get(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n           else\\n           return false;\\n            \\n        }\\n\\n        return true;\\n        "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "the description: ...Alphanumeric characters include letters and numbers.\\nbut!: the test case:\\n\\nWrong Answer\\n\\n480 / 485 testcases passed\\nInput\\ns =\\n\".\"\\nUse Testcase\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nwhaaaa? why the dot matters?\\n"
                    }
                ]
            },
            {
                "id": 1922200,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "so why is this true \"ab_a\", its case 484"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because _ underscore is not alphanumeric so you should remove this and than it's true"
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "I did this by using for loop.\nit costs more time and beats 36%.\nAs we have to remove non alphanumeric first.\nAny other way to do it using for loop with better results."
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Just remove alphanumeric first, and then compare s == s[::-1] without loop, you don\\'t need loop in this problem. "
                    },
                    {
                        "username": "thesupermanreturns",
                        "content": "can anyone please tell what is wrong with this logic. Test cases are not passing\\n//traverse using two pointers\\n//check if letter is uppercase and convert temporarily to lowercase and check\\n//if no match then false \\n//add 32 to uppercase to convert it to lowercase \\n`class Solution {\\n    public boolean isPalindrome(String s) {\\n        int first = 0, last = s.length()-1;\\n\\n        while(first < last){\\n            char f = s.charAt(first);\\n            char l = s.charAt(last);\\n            if(f<=\\'Z\\' && f>=\\'A\\'){\\n                f = (char)(f + 32);\\n            }\\n            if(l >= \\'A\\' && l <= \\'Z\\'){\\n                l = (char)(l + 32);\\n            }\\n\\n            if(( f >= \\'a\\' && f <= \\'z\\') && (l <= \\'z\\' && l >= \\'a\\')){\\n                if(f != l){\\n                    return false;\\n                } \\n               \\n            }\\n            first++;\\n            last--;\\n        }\\n        return true;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "is using regex fine or not ?"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@jyothienarendramath252](/jyothienarendramath252) thanks bro"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "it\\'s fine. but not efficient as it involves Excessive backtracking with regex matching"
                    },
                    {
                        "username": "cookieslasher",
                        "content": "Why is s=\".,\" true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "\".,\" is non-alphanumeric which will be removed. what left out is empty string \\'\\' which is palindrome as its the same string if we reverse it."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Cause they get remove and return \\u201C\\u201D and \\u201C\\u201D"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.size();i++){\\n            s[i] = tolower(s[i]);\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'A\\' && s[i]<=\\'Z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                v.push_back(s[i]);\\n            }\\n        for(int i=0;i<v.size();i++){\\n            if(v[v.size()-i-1]!=v[i]){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nmy test case 1 is failed can anyone explain this."
                    },
                    {
                        "username": "RicoRodriges",
                        "content": "why some testcases do not display \"stdout\"? its annoying, i cant debug my code here!"
                    },
                    {
                        "username": "sainath81061",
                        "content": "using System.Text.RegularExpressions;\n\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n         string pattern = \"[^a-zA-Z0-9]\";\n//Upper case string to Lower case string\n         s = s.ToLower();\n        bool b  = false;\n//Checking string is empty or not \n        if(s == \" \"){\n            b = true;\n            return b;\n        }\n         char[] chars = s.ToCharArray();\n    \n        int start = 0;\n        int end = s.Length -1;   \n//Reverse the given string \n        while(start < end)\n        {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;    \n            end--;  \n        }\n//storing the string \n        string rev = new string(chars);\n//Removing the special characters\n        s = Regex.Replace(s, pattern, \"\");\n        s  = Regex.Replace(s, @\"\\s+\", \"\");\n        rev = Regex.Replace(rev, pattern, \"\");\n        rev = Regex.Replace(rev, @\"\\s+\", \"\");\n\n//Checking the Condition given string and reverse string equal or not \n           if(s  == rev){\n            b = true;\n            return b;\n        }else{\n           return false;\n        }\n        \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY IS THIS CODE FAILING FOR \"0P\" testcase\\nPLEASE HELP;\\nint n=s.length();\\n        if(n==1)\\n        return true;\\n\\n        ArrayList<Character> al=new ArrayList<Character>();\\n        s=s.replaceAll(\"\\\\\\\\s\", \"\");\\n        s=s.toLowerCase();\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i);\\n            if(a>=97 && a<=122)\\n            al.add(s.charAt(i));\\n        }\\n        int an=al.size();\\n\\n        int start=0;\\n        int end=an-1;\\n        while(start<=end)\\n        {\\n            if(al.get(start)==al.get(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n           else\\n           return false;\\n            \\n        }\\n\\n        return true;\\n        "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "the description: ...Alphanumeric characters include letters and numbers.\\nbut!: the test case:\\n\\nWrong Answer\\n\\n480 / 485 testcases passed\\nInput\\ns =\\n\".\"\\nUse Testcase\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nwhaaaa? why the dot matters?\\n"
                    }
                ]
            },
            {
                "id": 1914409,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "so why is this true \"ab_a\", its case 484"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because _ underscore is not alphanumeric so you should remove this and than it's true"
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "I did this by using for loop.\nit costs more time and beats 36%.\nAs we have to remove non alphanumeric first.\nAny other way to do it using for loop with better results."
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Just remove alphanumeric first, and then compare s == s[::-1] without loop, you don\\'t need loop in this problem. "
                    },
                    {
                        "username": "thesupermanreturns",
                        "content": "can anyone please tell what is wrong with this logic. Test cases are not passing\\n//traverse using two pointers\\n//check if letter is uppercase and convert temporarily to lowercase and check\\n//if no match then false \\n//add 32 to uppercase to convert it to lowercase \\n`class Solution {\\n    public boolean isPalindrome(String s) {\\n        int first = 0, last = s.length()-1;\\n\\n        while(first < last){\\n            char f = s.charAt(first);\\n            char l = s.charAt(last);\\n            if(f<=\\'Z\\' && f>=\\'A\\'){\\n                f = (char)(f + 32);\\n            }\\n            if(l >= \\'A\\' && l <= \\'Z\\'){\\n                l = (char)(l + 32);\\n            }\\n\\n            if(( f >= \\'a\\' && f <= \\'z\\') && (l <= \\'z\\' && l >= \\'a\\')){\\n                if(f != l){\\n                    return false;\\n                } \\n               \\n            }\\n            first++;\\n            last--;\\n        }\\n        return true;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "is using regex fine or not ?"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@jyothienarendramath252](/jyothienarendramath252) thanks bro"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "it\\'s fine. but not efficient as it involves Excessive backtracking with regex matching"
                    },
                    {
                        "username": "cookieslasher",
                        "content": "Why is s=\".,\" true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "\".,\" is non-alphanumeric which will be removed. what left out is empty string \\'\\' which is palindrome as its the same string if we reverse it."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Cause they get remove and return \\u201C\\u201D and \\u201C\\u201D"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.size();i++){\\n            s[i] = tolower(s[i]);\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'A\\' && s[i]<=\\'Z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                v.push_back(s[i]);\\n            }\\n        for(int i=0;i<v.size();i++){\\n            if(v[v.size()-i-1]!=v[i]){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nmy test case 1 is failed can anyone explain this."
                    },
                    {
                        "username": "RicoRodriges",
                        "content": "why some testcases do not display \"stdout\"? its annoying, i cant debug my code here!"
                    },
                    {
                        "username": "sainath81061",
                        "content": "using System.Text.RegularExpressions;\n\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n         string pattern = \"[^a-zA-Z0-9]\";\n//Upper case string to Lower case string\n         s = s.ToLower();\n        bool b  = false;\n//Checking string is empty or not \n        if(s == \" \"){\n            b = true;\n            return b;\n        }\n         char[] chars = s.ToCharArray();\n    \n        int start = 0;\n        int end = s.Length -1;   \n//Reverse the given string \n        while(start < end)\n        {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;    \n            end--;  \n        }\n//storing the string \n        string rev = new string(chars);\n//Removing the special characters\n        s = Regex.Replace(s, pattern, \"\");\n        s  = Regex.Replace(s, @\"\\s+\", \"\");\n        rev = Regex.Replace(rev, pattern, \"\");\n        rev = Regex.Replace(rev, @\"\\s+\", \"\");\n\n//Checking the Condition given string and reverse string equal or not \n           if(s  == rev){\n            b = true;\n            return b;\n        }else{\n           return false;\n        }\n        \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY IS THIS CODE FAILING FOR \"0P\" testcase\\nPLEASE HELP;\\nint n=s.length();\\n        if(n==1)\\n        return true;\\n\\n        ArrayList<Character> al=new ArrayList<Character>();\\n        s=s.replaceAll(\"\\\\\\\\s\", \"\");\\n        s=s.toLowerCase();\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i);\\n            if(a>=97 && a<=122)\\n            al.add(s.charAt(i));\\n        }\\n        int an=al.size();\\n\\n        int start=0;\\n        int end=an-1;\\n        while(start<=end)\\n        {\\n            if(al.get(start)==al.get(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n           else\\n           return false;\\n            \\n        }\\n\\n        return true;\\n        "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "the description: ...Alphanumeric characters include letters and numbers.\\nbut!: the test case:\\n\\nWrong Answer\\n\\n480 / 485 testcases passed\\nInput\\ns =\\n\".\"\\nUse Testcase\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nwhaaaa? why the dot matters?\\n"
                    }
                ]
            },
            {
                "id": 1913927,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "so why is this true \"ab_a\", its case 484"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because _ underscore is not alphanumeric so you should remove this and than it's true"
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "I did this by using for loop.\nit costs more time and beats 36%.\nAs we have to remove non alphanumeric first.\nAny other way to do it using for loop with better results."
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Just remove alphanumeric first, and then compare s == s[::-1] without loop, you don\\'t need loop in this problem. "
                    },
                    {
                        "username": "thesupermanreturns",
                        "content": "can anyone please tell what is wrong with this logic. Test cases are not passing\\n//traverse using two pointers\\n//check if letter is uppercase and convert temporarily to lowercase and check\\n//if no match then false \\n//add 32 to uppercase to convert it to lowercase \\n`class Solution {\\n    public boolean isPalindrome(String s) {\\n        int first = 0, last = s.length()-1;\\n\\n        while(first < last){\\n            char f = s.charAt(first);\\n            char l = s.charAt(last);\\n            if(f<=\\'Z\\' && f>=\\'A\\'){\\n                f = (char)(f + 32);\\n            }\\n            if(l >= \\'A\\' && l <= \\'Z\\'){\\n                l = (char)(l + 32);\\n            }\\n\\n            if(( f >= \\'a\\' && f <= \\'z\\') && (l <= \\'z\\' && l >= \\'a\\')){\\n                if(f != l){\\n                    return false;\\n                } \\n               \\n            }\\n            first++;\\n            last--;\\n        }\\n        return true;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "is using regex fine or not ?"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@jyothienarendramath252](/jyothienarendramath252) thanks bro"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "it\\'s fine. but not efficient as it involves Excessive backtracking with regex matching"
                    },
                    {
                        "username": "cookieslasher",
                        "content": "Why is s=\".,\" true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "\".,\" is non-alphanumeric which will be removed. what left out is empty string \\'\\' which is palindrome as its the same string if we reverse it."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Cause they get remove and return \\u201C\\u201D and \\u201C\\u201D"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.size();i++){\\n            s[i] = tolower(s[i]);\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\') || (s[i]>=\\'A\\' && s[i]<=\\'Z\\') || (s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                v.push_back(s[i]);\\n            }\\n        for(int i=0;i<v.size();i++){\\n            if(v[v.size()-i-1]!=v[i]){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nmy test case 1 is failed can anyone explain this."
                    },
                    {
                        "username": "RicoRodriges",
                        "content": "why some testcases do not display \"stdout\"? its annoying, i cant debug my code here!"
                    },
                    {
                        "username": "sainath81061",
                        "content": "using System.Text.RegularExpressions;\n\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n         string pattern = \"[^a-zA-Z0-9]\";\n//Upper case string to Lower case string\n         s = s.ToLower();\n        bool b  = false;\n//Checking string is empty or not \n        if(s == \" \"){\n            b = true;\n            return b;\n        }\n         char[] chars = s.ToCharArray();\n    \n        int start = 0;\n        int end = s.Length -1;   \n//Reverse the given string \n        while(start < end)\n        {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;    \n            end--;  \n        }\n//storing the string \n        string rev = new string(chars);\n//Removing the special characters\n        s = Regex.Replace(s, pattern, \"\");\n        s  = Regex.Replace(s, @\"\\s+\", \"\");\n        rev = Regex.Replace(rev, pattern, \"\");\n        rev = Regex.Replace(rev, @\"\\s+\", \"\");\n\n//Checking the Condition given string and reverse string equal or not \n           if(s  == rev){\n            b = true;\n            return b;\n        }else{\n           return false;\n        }\n        \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY IS THIS CODE FAILING FOR \"0P\" testcase\\nPLEASE HELP;\\nint n=s.length();\\n        if(n==1)\\n        return true;\\n\\n        ArrayList<Character> al=new ArrayList<Character>();\\n        s=s.replaceAll(\"\\\\\\\\s\", \"\");\\n        s=s.toLowerCase();\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i);\\n            if(a>=97 && a<=122)\\n            al.add(s.charAt(i));\\n        }\\n        int an=al.size();\\n\\n        int start=0;\\n        int end=an-1;\\n        while(start<=end)\\n        {\\n            if(al.get(start)==al.get(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n           else\\n           return false;\\n            \\n        }\\n\\n        return true;\\n        "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "the description: ...Alphanumeric characters include letters and numbers.\\nbut!: the test case:\\n\\nWrong Answer\\n\\n480 / 485 testcases passed\\nInput\\ns =\\n\".\"\\nUse Testcase\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nwhaaaa? why the dot matters?\\n"
                    }
                ]
            },
            {
                "id": 1907324,
                "content": [
                    {
                        "username": "mohammad_ali_73",
                        "content": "easy and fast approach for this problrm\\n\\n// we will use two pointer approch \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //starting index is point as start which is point to first index\\n        int start = 0;\\n        //end is a another pointer starts from ending index\\n        int end = s.length()-1;\\n\\n        \\n        while(st<end){\\n            //check if it is alpha numaric and increment the starting pointer \\n            if(!isalnum(s[st]))\\n            st++;\\n            else\\n            //check if it is alpha numaric and decrement the ending index\\n            if(!isalnum(s[end]))\\n            end--;\\n            else\\n            //make all the elements to lower if the are not and compare if it is palindrom \\n            if(tolower(s[st])!=tolower(s[end]))\\n            return false;\\n            else{\\n                st++;\\n                end--;\\n            }\\n        }\\n        //finally if we manage to  arive here after the caclulation then it must be a valid palindrome\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "It\\'s funny, in Kotlin language swears at .lowercase(), only .toLowerCase() works."
                    },
                    {
                        "username": "formaxx",
                        "content": "better than 100% cpp solution\\n\\nclass Solution {\\npublic:\\nbool valid(char ch)\\n{\\n    if((ch>=\\'a\\'&&ch<=\\'z\\')||(ch>=\\'A\\'&&ch<=\\'Z\\')||(ch>=\\'0\\'&&ch<=\\'9\\'))\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\nchar tolower(char ch)\\n{\\n    if(ch>=\\'A\\'&&ch<=\\'Z\\')\\n    {\\n        return ch-\\'A\\'+\\'a\\';\\n    }\\n    return ch;\\n}\\nbool checkpalin(string s1)\\n{\\n    int k=s1.length();\\n    for(int i=0;i<k/2;i++)\\n    {\\n        if(s1[i]!=s1[k-i-1])\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n    bool isPalindrome(string s) \\n    {\\n         string s1=\"\";\\n  for(int i=0;i<s.length();i++)\\n  {\\n      if(valid(s[i]))\\n      {\\n          s1.push_back(s[i]);\\n      }\\n  }\\n for(int i=0;i<s1.length();i++)\\n {\\ns1[i]=tolower(s1[i]);\\n     \\n }\\n return checkpalin(s1);\\n\\n     }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gev87",
                        "content": "Some taskcase are wrong:\n\"1a2\" = > \"a\" = > true (you expect false)\n\"0P\" => \"P\" => true ((you expect false)\n\"ab2a\" = > \"aba\" => true ((you expect false)) \n\"9,8\" = > \"\" = > true (as you say in example 3 empty string = true ) . \n\n:("
                    },
                    {
                        "username": "piyushverma17",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(isalpha(s[i])) str +=tolower(s[i]);\\n            else if(isdigit(s[i])) str +=s[i];\\n        }\\n        string rev=str;\\n        reverse(rev.begin(),rev.end());\\n        return str==rev;       \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "chtejeshwar2",
                        "content": "function isPlaindrome(s){\\ns.toLowerCase();\\nlet r = s.split(\").reverse().join(\"\");\\nr.toLowerCase();\\n\\nif(r===s){\\nreturn true;\\n}\\nreturn false\\n}\\n\\nguys case 2 and case 3 are passing ....case 1 is not passing ....can anybody tell me wats wrong here please....thanks in advance...."
                    },
                    {
                        "username": "orioninthespace",
                        "content": "Whats\\'s wrong with my code. Please help. thanks.  \\n\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n       String res = s.toLowerCase();\\n       res=res.replaceAll(\"[\\\\\\\\s,:]+\",\"\");\\n       int i=0, j=res.length()-1;\\n       while(i!=j){\\n           if(res.charAt(i)!=res.charAt(j)) return false;\\n           i++;\\n           j--;\\n       }\\n       return true;\\n    }\\n} "
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You are not deleting the\"_\" sign"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Traverse string from both end - left and right\\n[ left -----> ,......................, <-------- right ]\\nif left character is not alphanumeric then move to next position left++\\nif right character is not alphanumeric then move to previos position right--\\nif both are alphanumeric then calculate their position as\\n\\n    private int getPosition(char c){\\n        if(c >=\\'a\\'){\\n            return c - \\'a\\';\\n        }else if(c >=\\'A\\'){\\n            return c - \\'A\\';\\n        }else{\\n            return c - \\'0\\' + 27;\\n        }\\n        \\n    }\\nif position not matched then return false\\notherwise continue till we crossed both pointers.\\n\\nSee solution - https://leetcode.com/problems/valid-palindrome/solutions/3450438/beats-100-easy-solution-two-pointers/\\n"
                    },
                    {
                        "username": "Paban_01",
                        "content": "// can anyone tell me what\\'s wrong with my code ???\\nclass Solution {\\npublic:\\n    bool isValid(char c){\\n    if((c>=\\'a\\' && c<=\\'z\\') || (c>=\\'A\\' && c<=\\'Z\\') || (c>=\\'0\\' && c<=\\'9\\')){\\n        return true;\\n    }\\n    return false;\\n}\\nbool isPalindrome(string s){\\n    int i=0, j=s.length()-1;\\n    while(i<j){\\n        while(!(isValid(s[i])) && i<j){\\n            i++;\\n        }\\n        while(!(isValid(s[i])) && j>i){\\n            j--;\\n        }\\n        if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n            s[i]=s[i]-\\'A\\'+\\'a\\';\\n        }\\n        if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n            s[j]=s[j]-\\'A\\'+\\'a\\'; \\n        }\\n        if(s[i]!=s[j]){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n};"
                    },
                    {
                        "username": "rohitsingh45",
                        "content": "I\\'m getting time exceeds for one of the testcases. I\\'ve gone through looping the original string and removing non-alphanumeric using multiple if-else ladder and after that again iterating the new string from end of the string to the first index and store it in a new string and at last I\\'ve compared both of them. Please help me! Thanks and Regards."
                    }
                ]
            },
            {
                "id": 1904375,
                "content": [
                    {
                        "username": "mohammad_ali_73",
                        "content": "easy and fast approach for this problrm\\n\\n// we will use two pointer approch \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //starting index is point as start which is point to first index\\n        int start = 0;\\n        //end is a another pointer starts from ending index\\n        int end = s.length()-1;\\n\\n        \\n        while(st<end){\\n            //check if it is alpha numaric and increment the starting pointer \\n            if(!isalnum(s[st]))\\n            st++;\\n            else\\n            //check if it is alpha numaric and decrement the ending index\\n            if(!isalnum(s[end]))\\n            end--;\\n            else\\n            //make all the elements to lower if the are not and compare if it is palindrom \\n            if(tolower(s[st])!=tolower(s[end]))\\n            return false;\\n            else{\\n                st++;\\n                end--;\\n            }\\n        }\\n        //finally if we manage to  arive here after the caclulation then it must be a valid palindrome\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "It\\'s funny, in Kotlin language swears at .lowercase(), only .toLowerCase() works."
                    },
                    {
                        "username": "formaxx",
                        "content": "better than 100% cpp solution\\n\\nclass Solution {\\npublic:\\nbool valid(char ch)\\n{\\n    if((ch>=\\'a\\'&&ch<=\\'z\\')||(ch>=\\'A\\'&&ch<=\\'Z\\')||(ch>=\\'0\\'&&ch<=\\'9\\'))\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\nchar tolower(char ch)\\n{\\n    if(ch>=\\'A\\'&&ch<=\\'Z\\')\\n    {\\n        return ch-\\'A\\'+\\'a\\';\\n    }\\n    return ch;\\n}\\nbool checkpalin(string s1)\\n{\\n    int k=s1.length();\\n    for(int i=0;i<k/2;i++)\\n    {\\n        if(s1[i]!=s1[k-i-1])\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n    bool isPalindrome(string s) \\n    {\\n         string s1=\"\";\\n  for(int i=0;i<s.length();i++)\\n  {\\n      if(valid(s[i]))\\n      {\\n          s1.push_back(s[i]);\\n      }\\n  }\\n for(int i=0;i<s1.length();i++)\\n {\\ns1[i]=tolower(s1[i]);\\n     \\n }\\n return checkpalin(s1);\\n\\n     }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gev87",
                        "content": "Some taskcase are wrong:\n\"1a2\" = > \"a\" = > true (you expect false)\n\"0P\" => \"P\" => true ((you expect false)\n\"ab2a\" = > \"aba\" => true ((you expect false)) \n\"9,8\" = > \"\" = > true (as you say in example 3 empty string = true ) . \n\n:("
                    },
                    {
                        "username": "piyushverma17",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(isalpha(s[i])) str +=tolower(s[i]);\\n            else if(isdigit(s[i])) str +=s[i];\\n        }\\n        string rev=str;\\n        reverse(rev.begin(),rev.end());\\n        return str==rev;       \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "chtejeshwar2",
                        "content": "function isPlaindrome(s){\\ns.toLowerCase();\\nlet r = s.split(\").reverse().join(\"\");\\nr.toLowerCase();\\n\\nif(r===s){\\nreturn true;\\n}\\nreturn false\\n}\\n\\nguys case 2 and case 3 are passing ....case 1 is not passing ....can anybody tell me wats wrong here please....thanks in advance...."
                    },
                    {
                        "username": "orioninthespace",
                        "content": "Whats\\'s wrong with my code. Please help. thanks.  \\n\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n       String res = s.toLowerCase();\\n       res=res.replaceAll(\"[\\\\\\\\s,:]+\",\"\");\\n       int i=0, j=res.length()-1;\\n       while(i!=j){\\n           if(res.charAt(i)!=res.charAt(j)) return false;\\n           i++;\\n           j--;\\n       }\\n       return true;\\n    }\\n} "
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You are not deleting the\"_\" sign"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Traverse string from both end - left and right\\n[ left -----> ,......................, <-------- right ]\\nif left character is not alphanumeric then move to next position left++\\nif right character is not alphanumeric then move to previos position right--\\nif both are alphanumeric then calculate their position as\\n\\n    private int getPosition(char c){\\n        if(c >=\\'a\\'){\\n            return c - \\'a\\';\\n        }else if(c >=\\'A\\'){\\n            return c - \\'A\\';\\n        }else{\\n            return c - \\'0\\' + 27;\\n        }\\n        \\n    }\\nif position not matched then return false\\notherwise continue till we crossed both pointers.\\n\\nSee solution - https://leetcode.com/problems/valid-palindrome/solutions/3450438/beats-100-easy-solution-two-pointers/\\n"
                    },
                    {
                        "username": "Paban_01",
                        "content": "// can anyone tell me what\\'s wrong with my code ???\\nclass Solution {\\npublic:\\n    bool isValid(char c){\\n    if((c>=\\'a\\' && c<=\\'z\\') || (c>=\\'A\\' && c<=\\'Z\\') || (c>=\\'0\\' && c<=\\'9\\')){\\n        return true;\\n    }\\n    return false;\\n}\\nbool isPalindrome(string s){\\n    int i=0, j=s.length()-1;\\n    while(i<j){\\n        while(!(isValid(s[i])) && i<j){\\n            i++;\\n        }\\n        while(!(isValid(s[i])) && j>i){\\n            j--;\\n        }\\n        if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n            s[i]=s[i]-\\'A\\'+\\'a\\';\\n        }\\n        if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n            s[j]=s[j]-\\'A\\'+\\'a\\'; \\n        }\\n        if(s[i]!=s[j]){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n};"
                    },
                    {
                        "username": "rohitsingh45",
                        "content": "I\\'m getting time exceeds for one of the testcases. I\\'ve gone through looping the original string and removing non-alphanumeric using multiple if-else ladder and after that again iterating the new string from end of the string to the first index and store it in a new string and at last I\\'ve compared both of them. Please help me! Thanks and Regards."
                    }
                ]
            },
            {
                "id": 1898481,
                "content": [
                    {
                        "username": "mohammad_ali_73",
                        "content": "easy and fast approach for this problrm\\n\\n// we will use two pointer approch \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //starting index is point as start which is point to first index\\n        int start = 0;\\n        //end is a another pointer starts from ending index\\n        int end = s.length()-1;\\n\\n        \\n        while(st<end){\\n            //check if it is alpha numaric and increment the starting pointer \\n            if(!isalnum(s[st]))\\n            st++;\\n            else\\n            //check if it is alpha numaric and decrement the ending index\\n            if(!isalnum(s[end]))\\n            end--;\\n            else\\n            //make all the elements to lower if the are not and compare if it is palindrom \\n            if(tolower(s[st])!=tolower(s[end]))\\n            return false;\\n            else{\\n                st++;\\n                end--;\\n            }\\n        }\\n        //finally if we manage to  arive here after the caclulation then it must be a valid palindrome\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "It\\'s funny, in Kotlin language swears at .lowercase(), only .toLowerCase() works."
                    },
                    {
                        "username": "formaxx",
                        "content": "better than 100% cpp solution\\n\\nclass Solution {\\npublic:\\nbool valid(char ch)\\n{\\n    if((ch>=\\'a\\'&&ch<=\\'z\\')||(ch>=\\'A\\'&&ch<=\\'Z\\')||(ch>=\\'0\\'&&ch<=\\'9\\'))\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\nchar tolower(char ch)\\n{\\n    if(ch>=\\'A\\'&&ch<=\\'Z\\')\\n    {\\n        return ch-\\'A\\'+\\'a\\';\\n    }\\n    return ch;\\n}\\nbool checkpalin(string s1)\\n{\\n    int k=s1.length();\\n    for(int i=0;i<k/2;i++)\\n    {\\n        if(s1[i]!=s1[k-i-1])\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n    bool isPalindrome(string s) \\n    {\\n         string s1=\"\";\\n  for(int i=0;i<s.length();i++)\\n  {\\n      if(valid(s[i]))\\n      {\\n          s1.push_back(s[i]);\\n      }\\n  }\\n for(int i=0;i<s1.length();i++)\\n {\\ns1[i]=tolower(s1[i]);\\n     \\n }\\n return checkpalin(s1);\\n\\n     }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gev87",
                        "content": "Some taskcase are wrong:\n\"1a2\" = > \"a\" = > true (you expect false)\n\"0P\" => \"P\" => true ((you expect false)\n\"ab2a\" = > \"aba\" => true ((you expect false)) \n\"9,8\" = > \"\" = > true (as you say in example 3 empty string = true ) . \n\n:("
                    },
                    {
                        "username": "piyushverma17",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(isalpha(s[i])) str +=tolower(s[i]);\\n            else if(isdigit(s[i])) str +=s[i];\\n        }\\n        string rev=str;\\n        reverse(rev.begin(),rev.end());\\n        return str==rev;       \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "chtejeshwar2",
                        "content": "function isPlaindrome(s){\\ns.toLowerCase();\\nlet r = s.split(\").reverse().join(\"\");\\nr.toLowerCase();\\n\\nif(r===s){\\nreturn true;\\n}\\nreturn false\\n}\\n\\nguys case 2 and case 3 are passing ....case 1 is not passing ....can anybody tell me wats wrong here please....thanks in advance...."
                    },
                    {
                        "username": "orioninthespace",
                        "content": "Whats\\'s wrong with my code. Please help. thanks.  \\n\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n       String res = s.toLowerCase();\\n       res=res.replaceAll(\"[\\\\\\\\s,:]+\",\"\");\\n       int i=0, j=res.length()-1;\\n       while(i!=j){\\n           if(res.charAt(i)!=res.charAt(j)) return false;\\n           i++;\\n           j--;\\n       }\\n       return true;\\n    }\\n} "
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You are not deleting the\"_\" sign"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Traverse string from both end - left and right\\n[ left -----> ,......................, <-------- right ]\\nif left character is not alphanumeric then move to next position left++\\nif right character is not alphanumeric then move to previos position right--\\nif both are alphanumeric then calculate their position as\\n\\n    private int getPosition(char c){\\n        if(c >=\\'a\\'){\\n            return c - \\'a\\';\\n        }else if(c >=\\'A\\'){\\n            return c - \\'A\\';\\n        }else{\\n            return c - \\'0\\' + 27;\\n        }\\n        \\n    }\\nif position not matched then return false\\notherwise continue till we crossed both pointers.\\n\\nSee solution - https://leetcode.com/problems/valid-palindrome/solutions/3450438/beats-100-easy-solution-two-pointers/\\n"
                    },
                    {
                        "username": "Paban_01",
                        "content": "// can anyone tell me what\\'s wrong with my code ???\\nclass Solution {\\npublic:\\n    bool isValid(char c){\\n    if((c>=\\'a\\' && c<=\\'z\\') || (c>=\\'A\\' && c<=\\'Z\\') || (c>=\\'0\\' && c<=\\'9\\')){\\n        return true;\\n    }\\n    return false;\\n}\\nbool isPalindrome(string s){\\n    int i=0, j=s.length()-1;\\n    while(i<j){\\n        while(!(isValid(s[i])) && i<j){\\n            i++;\\n        }\\n        while(!(isValid(s[i])) && j>i){\\n            j--;\\n        }\\n        if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n            s[i]=s[i]-\\'A\\'+\\'a\\';\\n        }\\n        if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n            s[j]=s[j]-\\'A\\'+\\'a\\'; \\n        }\\n        if(s[i]!=s[j]){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n};"
                    },
                    {
                        "username": "rohitsingh45",
                        "content": "I\\'m getting time exceeds for one of the testcases. I\\'ve gone through looping the original string and removing non-alphanumeric using multiple if-else ladder and after that again iterating the new string from end of the string to the first index and store it in a new string and at last I\\'ve compared both of them. Please help me! Thanks and Regards."
                    }
                ]
            },
            {
                "id": 1891147,
                "content": [
                    {
                        "username": "mohammad_ali_73",
                        "content": "easy and fast approach for this problrm\\n\\n// we will use two pointer approch \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //starting index is point as start which is point to first index\\n        int start = 0;\\n        //end is a another pointer starts from ending index\\n        int end = s.length()-1;\\n\\n        \\n        while(st<end){\\n            //check if it is alpha numaric and increment the starting pointer \\n            if(!isalnum(s[st]))\\n            st++;\\n            else\\n            //check if it is alpha numaric and decrement the ending index\\n            if(!isalnum(s[end]))\\n            end--;\\n            else\\n            //make all the elements to lower if the are not and compare if it is palindrom \\n            if(tolower(s[st])!=tolower(s[end]))\\n            return false;\\n            else{\\n                st++;\\n                end--;\\n            }\\n        }\\n        //finally if we manage to  arive here after the caclulation then it must be a valid palindrome\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "It\\'s funny, in Kotlin language swears at .lowercase(), only .toLowerCase() works."
                    },
                    {
                        "username": "formaxx",
                        "content": "better than 100% cpp solution\\n\\nclass Solution {\\npublic:\\nbool valid(char ch)\\n{\\n    if((ch>=\\'a\\'&&ch<=\\'z\\')||(ch>=\\'A\\'&&ch<=\\'Z\\')||(ch>=\\'0\\'&&ch<=\\'9\\'))\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\nchar tolower(char ch)\\n{\\n    if(ch>=\\'A\\'&&ch<=\\'Z\\')\\n    {\\n        return ch-\\'A\\'+\\'a\\';\\n    }\\n    return ch;\\n}\\nbool checkpalin(string s1)\\n{\\n    int k=s1.length();\\n    for(int i=0;i<k/2;i++)\\n    {\\n        if(s1[i]!=s1[k-i-1])\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n    bool isPalindrome(string s) \\n    {\\n         string s1=\"\";\\n  for(int i=0;i<s.length();i++)\\n  {\\n      if(valid(s[i]))\\n      {\\n          s1.push_back(s[i]);\\n      }\\n  }\\n for(int i=0;i<s1.length();i++)\\n {\\ns1[i]=tolower(s1[i]);\\n     \\n }\\n return checkpalin(s1);\\n\\n     }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gev87",
                        "content": "Some taskcase are wrong:\n\"1a2\" = > \"a\" = > true (you expect false)\n\"0P\" => \"P\" => true ((you expect false)\n\"ab2a\" = > \"aba\" => true ((you expect false)) \n\"9,8\" = > \"\" = > true (as you say in example 3 empty string = true ) . \n\n:("
                    },
                    {
                        "username": "piyushverma17",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(isalpha(s[i])) str +=tolower(s[i]);\\n            else if(isdigit(s[i])) str +=s[i];\\n        }\\n        string rev=str;\\n        reverse(rev.begin(),rev.end());\\n        return str==rev;       \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "chtejeshwar2",
                        "content": "function isPlaindrome(s){\\ns.toLowerCase();\\nlet r = s.split(\").reverse().join(\"\");\\nr.toLowerCase();\\n\\nif(r===s){\\nreturn true;\\n}\\nreturn false\\n}\\n\\nguys case 2 and case 3 are passing ....case 1 is not passing ....can anybody tell me wats wrong here please....thanks in advance...."
                    },
                    {
                        "username": "orioninthespace",
                        "content": "Whats\\'s wrong with my code. Please help. thanks.  \\n\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n       String res = s.toLowerCase();\\n       res=res.replaceAll(\"[\\\\\\\\s,:]+\",\"\");\\n       int i=0, j=res.length()-1;\\n       while(i!=j){\\n           if(res.charAt(i)!=res.charAt(j)) return false;\\n           i++;\\n           j--;\\n       }\\n       return true;\\n    }\\n} "
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You are not deleting the\"_\" sign"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Traverse string from both end - left and right\\n[ left -----> ,......................, <-------- right ]\\nif left character is not alphanumeric then move to next position left++\\nif right character is not alphanumeric then move to previos position right--\\nif both are alphanumeric then calculate their position as\\n\\n    private int getPosition(char c){\\n        if(c >=\\'a\\'){\\n            return c - \\'a\\';\\n        }else if(c >=\\'A\\'){\\n            return c - \\'A\\';\\n        }else{\\n            return c - \\'0\\' + 27;\\n        }\\n        \\n    }\\nif position not matched then return false\\notherwise continue till we crossed both pointers.\\n\\nSee solution - https://leetcode.com/problems/valid-palindrome/solutions/3450438/beats-100-easy-solution-two-pointers/\\n"
                    },
                    {
                        "username": "Paban_01",
                        "content": "// can anyone tell me what\\'s wrong with my code ???\\nclass Solution {\\npublic:\\n    bool isValid(char c){\\n    if((c>=\\'a\\' && c<=\\'z\\') || (c>=\\'A\\' && c<=\\'Z\\') || (c>=\\'0\\' && c<=\\'9\\')){\\n        return true;\\n    }\\n    return false;\\n}\\nbool isPalindrome(string s){\\n    int i=0, j=s.length()-1;\\n    while(i<j){\\n        while(!(isValid(s[i])) && i<j){\\n            i++;\\n        }\\n        while(!(isValid(s[i])) && j>i){\\n            j--;\\n        }\\n        if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n            s[i]=s[i]-\\'A\\'+\\'a\\';\\n        }\\n        if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n            s[j]=s[j]-\\'A\\'+\\'a\\'; \\n        }\\n        if(s[i]!=s[j]){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n};"
                    },
                    {
                        "username": "rohitsingh45",
                        "content": "I\\'m getting time exceeds for one of the testcases. I\\'ve gone through looping the original string and removing non-alphanumeric using multiple if-else ladder and after that again iterating the new string from end of the string to the first index and store it in a new string and at last I\\'ve compared both of them. Please help me! Thanks and Regards."
                    }
                ]
            },
            {
                "id": 1886835,
                "content": [
                    {
                        "username": "mohammad_ali_73",
                        "content": "easy and fast approach for this problrm\\n\\n// we will use two pointer approch \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //starting index is point as start which is point to first index\\n        int start = 0;\\n        //end is a another pointer starts from ending index\\n        int end = s.length()-1;\\n\\n        \\n        while(st<end){\\n            //check if it is alpha numaric and increment the starting pointer \\n            if(!isalnum(s[st]))\\n            st++;\\n            else\\n            //check if it is alpha numaric and decrement the ending index\\n            if(!isalnum(s[end]))\\n            end--;\\n            else\\n            //make all the elements to lower if the are not and compare if it is palindrom \\n            if(tolower(s[st])!=tolower(s[end]))\\n            return false;\\n            else{\\n                st++;\\n                end--;\\n            }\\n        }\\n        //finally if we manage to  arive here after the caclulation then it must be a valid palindrome\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "It\\'s funny, in Kotlin language swears at .lowercase(), only .toLowerCase() works."
                    },
                    {
                        "username": "formaxx",
                        "content": "better than 100% cpp solution\\n\\nclass Solution {\\npublic:\\nbool valid(char ch)\\n{\\n    if((ch>=\\'a\\'&&ch<=\\'z\\')||(ch>=\\'A\\'&&ch<=\\'Z\\')||(ch>=\\'0\\'&&ch<=\\'9\\'))\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\nchar tolower(char ch)\\n{\\n    if(ch>=\\'A\\'&&ch<=\\'Z\\')\\n    {\\n        return ch-\\'A\\'+\\'a\\';\\n    }\\n    return ch;\\n}\\nbool checkpalin(string s1)\\n{\\n    int k=s1.length();\\n    for(int i=0;i<k/2;i++)\\n    {\\n        if(s1[i]!=s1[k-i-1])\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n    bool isPalindrome(string s) \\n    {\\n         string s1=\"\";\\n  for(int i=0;i<s.length();i++)\\n  {\\n      if(valid(s[i]))\\n      {\\n          s1.push_back(s[i]);\\n      }\\n  }\\n for(int i=0;i<s1.length();i++)\\n {\\ns1[i]=tolower(s1[i]);\\n     \\n }\\n return checkpalin(s1);\\n\\n     }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gev87",
                        "content": "Some taskcase are wrong:\n\"1a2\" = > \"a\" = > true (you expect false)\n\"0P\" => \"P\" => true ((you expect false)\n\"ab2a\" = > \"aba\" => true ((you expect false)) \n\"9,8\" = > \"\" = > true (as you say in example 3 empty string = true ) . \n\n:("
                    },
                    {
                        "username": "piyushverma17",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(isalpha(s[i])) str +=tolower(s[i]);\\n            else if(isdigit(s[i])) str +=s[i];\\n        }\\n        string rev=str;\\n        reverse(rev.begin(),rev.end());\\n        return str==rev;       \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "chtejeshwar2",
                        "content": "function isPlaindrome(s){\\ns.toLowerCase();\\nlet r = s.split(\").reverse().join(\"\");\\nr.toLowerCase();\\n\\nif(r===s){\\nreturn true;\\n}\\nreturn false\\n}\\n\\nguys case 2 and case 3 are passing ....case 1 is not passing ....can anybody tell me wats wrong here please....thanks in advance...."
                    },
                    {
                        "username": "orioninthespace",
                        "content": "Whats\\'s wrong with my code. Please help. thanks.  \\n\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n       String res = s.toLowerCase();\\n       res=res.replaceAll(\"[\\\\\\\\s,:]+\",\"\");\\n       int i=0, j=res.length()-1;\\n       while(i!=j){\\n           if(res.charAt(i)!=res.charAt(j)) return false;\\n           i++;\\n           j--;\\n       }\\n       return true;\\n    }\\n} "
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You are not deleting the\"_\" sign"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Traverse string from both end - left and right\\n[ left -----> ,......................, <-------- right ]\\nif left character is not alphanumeric then move to next position left++\\nif right character is not alphanumeric then move to previos position right--\\nif both are alphanumeric then calculate their position as\\n\\n    private int getPosition(char c){\\n        if(c >=\\'a\\'){\\n            return c - \\'a\\';\\n        }else if(c >=\\'A\\'){\\n            return c - \\'A\\';\\n        }else{\\n            return c - \\'0\\' + 27;\\n        }\\n        \\n    }\\nif position not matched then return false\\notherwise continue till we crossed both pointers.\\n\\nSee solution - https://leetcode.com/problems/valid-palindrome/solutions/3450438/beats-100-easy-solution-two-pointers/\\n"
                    },
                    {
                        "username": "Paban_01",
                        "content": "// can anyone tell me what\\'s wrong with my code ???\\nclass Solution {\\npublic:\\n    bool isValid(char c){\\n    if((c>=\\'a\\' && c<=\\'z\\') || (c>=\\'A\\' && c<=\\'Z\\') || (c>=\\'0\\' && c<=\\'9\\')){\\n        return true;\\n    }\\n    return false;\\n}\\nbool isPalindrome(string s){\\n    int i=0, j=s.length()-1;\\n    while(i<j){\\n        while(!(isValid(s[i])) && i<j){\\n            i++;\\n        }\\n        while(!(isValid(s[i])) && j>i){\\n            j--;\\n        }\\n        if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n            s[i]=s[i]-\\'A\\'+\\'a\\';\\n        }\\n        if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n            s[j]=s[j]-\\'A\\'+\\'a\\'; \\n        }\\n        if(s[i]!=s[j]){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n};"
                    },
                    {
                        "username": "rohitsingh45",
                        "content": "I\\'m getting time exceeds for one of the testcases. I\\'ve gone through looping the original string and removing non-alphanumeric using multiple if-else ladder and after that again iterating the new string from end of the string to the first index and store it in a new string and at last I\\'ve compared both of them. Please help me! Thanks and Regards."
                    }
                ]
            },
            {
                "id": 1879976,
                "content": [
                    {
                        "username": "mohammad_ali_73",
                        "content": "easy and fast approach for this problrm\\n\\n// we will use two pointer approch \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //starting index is point as start which is point to first index\\n        int start = 0;\\n        //end is a another pointer starts from ending index\\n        int end = s.length()-1;\\n\\n        \\n        while(st<end){\\n            //check if it is alpha numaric and increment the starting pointer \\n            if(!isalnum(s[st]))\\n            st++;\\n            else\\n            //check if it is alpha numaric and decrement the ending index\\n            if(!isalnum(s[end]))\\n            end--;\\n            else\\n            //make all the elements to lower if the are not and compare if it is palindrom \\n            if(tolower(s[st])!=tolower(s[end]))\\n            return false;\\n            else{\\n                st++;\\n                end--;\\n            }\\n        }\\n        //finally if we manage to  arive here after the caclulation then it must be a valid palindrome\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "It\\'s funny, in Kotlin language swears at .lowercase(), only .toLowerCase() works."
                    },
                    {
                        "username": "formaxx",
                        "content": "better than 100% cpp solution\\n\\nclass Solution {\\npublic:\\nbool valid(char ch)\\n{\\n    if((ch>=\\'a\\'&&ch<=\\'z\\')||(ch>=\\'A\\'&&ch<=\\'Z\\')||(ch>=\\'0\\'&&ch<=\\'9\\'))\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\nchar tolower(char ch)\\n{\\n    if(ch>=\\'A\\'&&ch<=\\'Z\\')\\n    {\\n        return ch-\\'A\\'+\\'a\\';\\n    }\\n    return ch;\\n}\\nbool checkpalin(string s1)\\n{\\n    int k=s1.length();\\n    for(int i=0;i<k/2;i++)\\n    {\\n        if(s1[i]!=s1[k-i-1])\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n    bool isPalindrome(string s) \\n    {\\n         string s1=\"\";\\n  for(int i=0;i<s.length();i++)\\n  {\\n      if(valid(s[i]))\\n      {\\n          s1.push_back(s[i]);\\n      }\\n  }\\n for(int i=0;i<s1.length();i++)\\n {\\ns1[i]=tolower(s1[i]);\\n     \\n }\\n return checkpalin(s1);\\n\\n     }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gev87",
                        "content": "Some taskcase are wrong:\n\"1a2\" = > \"a\" = > true (you expect false)\n\"0P\" => \"P\" => true ((you expect false)\n\"ab2a\" = > \"aba\" => true ((you expect false)) \n\"9,8\" = > \"\" = > true (as you say in example 3 empty string = true ) . \n\n:("
                    },
                    {
                        "username": "piyushverma17",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(isalpha(s[i])) str +=tolower(s[i]);\\n            else if(isdigit(s[i])) str +=s[i];\\n        }\\n        string rev=str;\\n        reverse(rev.begin(),rev.end());\\n        return str==rev;       \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "chtejeshwar2",
                        "content": "function isPlaindrome(s){\\ns.toLowerCase();\\nlet r = s.split(\").reverse().join(\"\");\\nr.toLowerCase();\\n\\nif(r===s){\\nreturn true;\\n}\\nreturn false\\n}\\n\\nguys case 2 and case 3 are passing ....case 1 is not passing ....can anybody tell me wats wrong here please....thanks in advance...."
                    },
                    {
                        "username": "orioninthespace",
                        "content": "Whats\\'s wrong with my code. Please help. thanks.  \\n\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n       String res = s.toLowerCase();\\n       res=res.replaceAll(\"[\\\\\\\\s,:]+\",\"\");\\n       int i=0, j=res.length()-1;\\n       while(i!=j){\\n           if(res.charAt(i)!=res.charAt(j)) return false;\\n           i++;\\n           j--;\\n       }\\n       return true;\\n    }\\n} "
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You are not deleting the\"_\" sign"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Traverse string from both end - left and right\\n[ left -----> ,......................, <-------- right ]\\nif left character is not alphanumeric then move to next position left++\\nif right character is not alphanumeric then move to previos position right--\\nif both are alphanumeric then calculate their position as\\n\\n    private int getPosition(char c){\\n        if(c >=\\'a\\'){\\n            return c - \\'a\\';\\n        }else if(c >=\\'A\\'){\\n            return c - \\'A\\';\\n        }else{\\n            return c - \\'0\\' + 27;\\n        }\\n        \\n    }\\nif position not matched then return false\\notherwise continue till we crossed both pointers.\\n\\nSee solution - https://leetcode.com/problems/valid-palindrome/solutions/3450438/beats-100-easy-solution-two-pointers/\\n"
                    },
                    {
                        "username": "Paban_01",
                        "content": "// can anyone tell me what\\'s wrong with my code ???\\nclass Solution {\\npublic:\\n    bool isValid(char c){\\n    if((c>=\\'a\\' && c<=\\'z\\') || (c>=\\'A\\' && c<=\\'Z\\') || (c>=\\'0\\' && c<=\\'9\\')){\\n        return true;\\n    }\\n    return false;\\n}\\nbool isPalindrome(string s){\\n    int i=0, j=s.length()-1;\\n    while(i<j){\\n        while(!(isValid(s[i])) && i<j){\\n            i++;\\n        }\\n        while(!(isValid(s[i])) && j>i){\\n            j--;\\n        }\\n        if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n            s[i]=s[i]-\\'A\\'+\\'a\\';\\n        }\\n        if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n            s[j]=s[j]-\\'A\\'+\\'a\\'; \\n        }\\n        if(s[i]!=s[j]){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n};"
                    },
                    {
                        "username": "rohitsingh45",
                        "content": "I\\'m getting time exceeds for one of the testcases. I\\'ve gone through looping the original string and removing non-alphanumeric using multiple if-else ladder and after that again iterating the new string from end of the string to the first index and store it in a new string and at last I\\'ve compared both of them. Please help me! Thanks and Regards."
                    }
                ]
            },
            {
                "id": 1873495,
                "content": [
                    {
                        "username": "mohammad_ali_73",
                        "content": "easy and fast approach for this problrm\\n\\n// we will use two pointer approch \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //starting index is point as start which is point to first index\\n        int start = 0;\\n        //end is a another pointer starts from ending index\\n        int end = s.length()-1;\\n\\n        \\n        while(st<end){\\n            //check if it is alpha numaric and increment the starting pointer \\n            if(!isalnum(s[st]))\\n            st++;\\n            else\\n            //check if it is alpha numaric and decrement the ending index\\n            if(!isalnum(s[end]))\\n            end--;\\n            else\\n            //make all the elements to lower if the are not and compare if it is palindrom \\n            if(tolower(s[st])!=tolower(s[end]))\\n            return false;\\n            else{\\n                st++;\\n                end--;\\n            }\\n        }\\n        //finally if we manage to  arive here after the caclulation then it must be a valid palindrome\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "It\\'s funny, in Kotlin language swears at .lowercase(), only .toLowerCase() works."
                    },
                    {
                        "username": "formaxx",
                        "content": "better than 100% cpp solution\\n\\nclass Solution {\\npublic:\\nbool valid(char ch)\\n{\\n    if((ch>=\\'a\\'&&ch<=\\'z\\')||(ch>=\\'A\\'&&ch<=\\'Z\\')||(ch>=\\'0\\'&&ch<=\\'9\\'))\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\nchar tolower(char ch)\\n{\\n    if(ch>=\\'A\\'&&ch<=\\'Z\\')\\n    {\\n        return ch-\\'A\\'+\\'a\\';\\n    }\\n    return ch;\\n}\\nbool checkpalin(string s1)\\n{\\n    int k=s1.length();\\n    for(int i=0;i<k/2;i++)\\n    {\\n        if(s1[i]!=s1[k-i-1])\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n    bool isPalindrome(string s) \\n    {\\n         string s1=\"\";\\n  for(int i=0;i<s.length();i++)\\n  {\\n      if(valid(s[i]))\\n      {\\n          s1.push_back(s[i]);\\n      }\\n  }\\n for(int i=0;i<s1.length();i++)\\n {\\ns1[i]=tolower(s1[i]);\\n     \\n }\\n return checkpalin(s1);\\n\\n     }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gev87",
                        "content": "Some taskcase are wrong:\n\"1a2\" = > \"a\" = > true (you expect false)\n\"0P\" => \"P\" => true ((you expect false)\n\"ab2a\" = > \"aba\" => true ((you expect false)) \n\"9,8\" = > \"\" = > true (as you say in example 3 empty string = true ) . \n\n:("
                    },
                    {
                        "username": "piyushverma17",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(isalpha(s[i])) str +=tolower(s[i]);\\n            else if(isdigit(s[i])) str +=s[i];\\n        }\\n        string rev=str;\\n        reverse(rev.begin(),rev.end());\\n        return str==rev;       \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "chtejeshwar2",
                        "content": "function isPlaindrome(s){\\ns.toLowerCase();\\nlet r = s.split(\").reverse().join(\"\");\\nr.toLowerCase();\\n\\nif(r===s){\\nreturn true;\\n}\\nreturn false\\n}\\n\\nguys case 2 and case 3 are passing ....case 1 is not passing ....can anybody tell me wats wrong here please....thanks in advance...."
                    },
                    {
                        "username": "orioninthespace",
                        "content": "Whats\\'s wrong with my code. Please help. thanks.  \\n\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n       String res = s.toLowerCase();\\n       res=res.replaceAll(\"[\\\\\\\\s,:]+\",\"\");\\n       int i=0, j=res.length()-1;\\n       while(i!=j){\\n           if(res.charAt(i)!=res.charAt(j)) return false;\\n           i++;\\n           j--;\\n       }\\n       return true;\\n    }\\n} "
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You are not deleting the\"_\" sign"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Traverse string from both end - left and right\\n[ left -----> ,......................, <-------- right ]\\nif left character is not alphanumeric then move to next position left++\\nif right character is not alphanumeric then move to previos position right--\\nif both are alphanumeric then calculate their position as\\n\\n    private int getPosition(char c){\\n        if(c >=\\'a\\'){\\n            return c - \\'a\\';\\n        }else if(c >=\\'A\\'){\\n            return c - \\'A\\';\\n        }else{\\n            return c - \\'0\\' + 27;\\n        }\\n        \\n    }\\nif position not matched then return false\\notherwise continue till we crossed both pointers.\\n\\nSee solution - https://leetcode.com/problems/valid-palindrome/solutions/3450438/beats-100-easy-solution-two-pointers/\\n"
                    },
                    {
                        "username": "Paban_01",
                        "content": "// can anyone tell me what\\'s wrong with my code ???\\nclass Solution {\\npublic:\\n    bool isValid(char c){\\n    if((c>=\\'a\\' && c<=\\'z\\') || (c>=\\'A\\' && c<=\\'Z\\') || (c>=\\'0\\' && c<=\\'9\\')){\\n        return true;\\n    }\\n    return false;\\n}\\nbool isPalindrome(string s){\\n    int i=0, j=s.length()-1;\\n    while(i<j){\\n        while(!(isValid(s[i])) && i<j){\\n            i++;\\n        }\\n        while(!(isValid(s[i])) && j>i){\\n            j--;\\n        }\\n        if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n            s[i]=s[i]-\\'A\\'+\\'a\\';\\n        }\\n        if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n            s[j]=s[j]-\\'A\\'+\\'a\\'; \\n        }\\n        if(s[i]!=s[j]){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n};"
                    },
                    {
                        "username": "rohitsingh45",
                        "content": "I\\'m getting time exceeds for one of the testcases. I\\'ve gone through looping the original string and removing non-alphanumeric using multiple if-else ladder and after that again iterating the new string from end of the string to the first index and store it in a new string and at last I\\'ve compared both of them. Please help me! Thanks and Regards."
                    }
                ]
            },
            {
                "id": 1872796,
                "content": [
                    {
                        "username": "mohammad_ali_73",
                        "content": "easy and fast approach for this problrm\\n\\n// we will use two pointer approch \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //starting index is point as start which is point to first index\\n        int start = 0;\\n        //end is a another pointer starts from ending index\\n        int end = s.length()-1;\\n\\n        \\n        while(st<end){\\n            //check if it is alpha numaric and increment the starting pointer \\n            if(!isalnum(s[st]))\\n            st++;\\n            else\\n            //check if it is alpha numaric and decrement the ending index\\n            if(!isalnum(s[end]))\\n            end--;\\n            else\\n            //make all the elements to lower if the are not and compare if it is palindrom \\n            if(tolower(s[st])!=tolower(s[end]))\\n            return false;\\n            else{\\n                st++;\\n                end--;\\n            }\\n        }\\n        //finally if we manage to  arive here after the caclulation then it must be a valid palindrome\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "It\\'s funny, in Kotlin language swears at .lowercase(), only .toLowerCase() works."
                    },
                    {
                        "username": "formaxx",
                        "content": "better than 100% cpp solution\\n\\nclass Solution {\\npublic:\\nbool valid(char ch)\\n{\\n    if((ch>=\\'a\\'&&ch<=\\'z\\')||(ch>=\\'A\\'&&ch<=\\'Z\\')||(ch>=\\'0\\'&&ch<=\\'9\\'))\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\nchar tolower(char ch)\\n{\\n    if(ch>=\\'A\\'&&ch<=\\'Z\\')\\n    {\\n        return ch-\\'A\\'+\\'a\\';\\n    }\\n    return ch;\\n}\\nbool checkpalin(string s1)\\n{\\n    int k=s1.length();\\n    for(int i=0;i<k/2;i++)\\n    {\\n        if(s1[i]!=s1[k-i-1])\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n    bool isPalindrome(string s) \\n    {\\n         string s1=\"\";\\n  for(int i=0;i<s.length();i++)\\n  {\\n      if(valid(s[i]))\\n      {\\n          s1.push_back(s[i]);\\n      }\\n  }\\n for(int i=0;i<s1.length();i++)\\n {\\ns1[i]=tolower(s1[i]);\\n     \\n }\\n return checkpalin(s1);\\n\\n     }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gev87",
                        "content": "Some taskcase are wrong:\n\"1a2\" = > \"a\" = > true (you expect false)\n\"0P\" => \"P\" => true ((you expect false)\n\"ab2a\" = > \"aba\" => true ((you expect false)) \n\"9,8\" = > \"\" = > true (as you say in example 3 empty string = true ) . \n\n:("
                    },
                    {
                        "username": "piyushverma17",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(isalpha(s[i])) str +=tolower(s[i]);\\n            else if(isdigit(s[i])) str +=s[i];\\n        }\\n        string rev=str;\\n        reverse(rev.begin(),rev.end());\\n        return str==rev;       \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "chtejeshwar2",
                        "content": "function isPlaindrome(s){\\ns.toLowerCase();\\nlet r = s.split(\").reverse().join(\"\");\\nr.toLowerCase();\\n\\nif(r===s){\\nreturn true;\\n}\\nreturn false\\n}\\n\\nguys case 2 and case 3 are passing ....case 1 is not passing ....can anybody tell me wats wrong here please....thanks in advance...."
                    },
                    {
                        "username": "orioninthespace",
                        "content": "Whats\\'s wrong with my code. Please help. thanks.  \\n\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n       String res = s.toLowerCase();\\n       res=res.replaceAll(\"[\\\\\\\\s,:]+\",\"\");\\n       int i=0, j=res.length()-1;\\n       while(i!=j){\\n           if(res.charAt(i)!=res.charAt(j)) return false;\\n           i++;\\n           j--;\\n       }\\n       return true;\\n    }\\n} "
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You are not deleting the\"_\" sign"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Traverse string from both end - left and right\\n[ left -----> ,......................, <-------- right ]\\nif left character is not alphanumeric then move to next position left++\\nif right character is not alphanumeric then move to previos position right--\\nif both are alphanumeric then calculate their position as\\n\\n    private int getPosition(char c){\\n        if(c >=\\'a\\'){\\n            return c - \\'a\\';\\n        }else if(c >=\\'A\\'){\\n            return c - \\'A\\';\\n        }else{\\n            return c - \\'0\\' + 27;\\n        }\\n        \\n    }\\nif position not matched then return false\\notherwise continue till we crossed both pointers.\\n\\nSee solution - https://leetcode.com/problems/valid-palindrome/solutions/3450438/beats-100-easy-solution-two-pointers/\\n"
                    },
                    {
                        "username": "Paban_01",
                        "content": "// can anyone tell me what\\'s wrong with my code ???\\nclass Solution {\\npublic:\\n    bool isValid(char c){\\n    if((c>=\\'a\\' && c<=\\'z\\') || (c>=\\'A\\' && c<=\\'Z\\') || (c>=\\'0\\' && c<=\\'9\\')){\\n        return true;\\n    }\\n    return false;\\n}\\nbool isPalindrome(string s){\\n    int i=0, j=s.length()-1;\\n    while(i<j){\\n        while(!(isValid(s[i])) && i<j){\\n            i++;\\n        }\\n        while(!(isValid(s[i])) && j>i){\\n            j--;\\n        }\\n        if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n            s[i]=s[i]-\\'A\\'+\\'a\\';\\n        }\\n        if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n            s[j]=s[j]-\\'A\\'+\\'a\\'; \\n        }\\n        if(s[i]!=s[j]){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n};"
                    },
                    {
                        "username": "rohitsingh45",
                        "content": "I\\'m getting time exceeds for one of the testcases. I\\'ve gone through looping the original string and removing non-alphanumeric using multiple if-else ladder and after that again iterating the new string from end of the string to the first index and store it in a new string and at last I\\'ve compared both of them. Please help me! Thanks and Regards."
                    }
                ]
            },
            {
                "id": 1859591,
                "content": [
                    {
                        "username": "mohammad_ali_73",
                        "content": "easy and fast approach for this problrm\\n\\n// we will use two pointer approch \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //starting index is point as start which is point to first index\\n        int start = 0;\\n        //end is a another pointer starts from ending index\\n        int end = s.length()-1;\\n\\n        \\n        while(st<end){\\n            //check if it is alpha numaric and increment the starting pointer \\n            if(!isalnum(s[st]))\\n            st++;\\n            else\\n            //check if it is alpha numaric and decrement the ending index\\n            if(!isalnum(s[end]))\\n            end--;\\n            else\\n            //make all the elements to lower if the are not and compare if it is palindrom \\n            if(tolower(s[st])!=tolower(s[end]))\\n            return false;\\n            else{\\n                st++;\\n                end--;\\n            }\\n        }\\n        //finally if we manage to  arive here after the caclulation then it must be a valid palindrome\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "It\\'s funny, in Kotlin language swears at .lowercase(), only .toLowerCase() works."
                    },
                    {
                        "username": "formaxx",
                        "content": "better than 100% cpp solution\\n\\nclass Solution {\\npublic:\\nbool valid(char ch)\\n{\\n    if((ch>=\\'a\\'&&ch<=\\'z\\')||(ch>=\\'A\\'&&ch<=\\'Z\\')||(ch>=\\'0\\'&&ch<=\\'9\\'))\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\nchar tolower(char ch)\\n{\\n    if(ch>=\\'A\\'&&ch<=\\'Z\\')\\n    {\\n        return ch-\\'A\\'+\\'a\\';\\n    }\\n    return ch;\\n}\\nbool checkpalin(string s1)\\n{\\n    int k=s1.length();\\n    for(int i=0;i<k/2;i++)\\n    {\\n        if(s1[i]!=s1[k-i-1])\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n    bool isPalindrome(string s) \\n    {\\n         string s1=\"\";\\n  for(int i=0;i<s.length();i++)\\n  {\\n      if(valid(s[i]))\\n      {\\n          s1.push_back(s[i]);\\n      }\\n  }\\n for(int i=0;i<s1.length();i++)\\n {\\ns1[i]=tolower(s1[i]);\\n     \\n }\\n return checkpalin(s1);\\n\\n     }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gev87",
                        "content": "Some taskcase are wrong:\n\"1a2\" = > \"a\" = > true (you expect false)\n\"0P\" => \"P\" => true ((you expect false)\n\"ab2a\" = > \"aba\" => true ((you expect false)) \n\"9,8\" = > \"\" = > true (as you say in example 3 empty string = true ) . \n\n:("
                    },
                    {
                        "username": "piyushverma17",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(isalpha(s[i])) str +=tolower(s[i]);\\n            else if(isdigit(s[i])) str +=s[i];\\n        }\\n        string rev=str;\\n        reverse(rev.begin(),rev.end());\\n        return str==rev;       \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "chtejeshwar2",
                        "content": "function isPlaindrome(s){\\ns.toLowerCase();\\nlet r = s.split(\").reverse().join(\"\");\\nr.toLowerCase();\\n\\nif(r===s){\\nreturn true;\\n}\\nreturn false\\n}\\n\\nguys case 2 and case 3 are passing ....case 1 is not passing ....can anybody tell me wats wrong here please....thanks in advance...."
                    },
                    {
                        "username": "orioninthespace",
                        "content": "Whats\\'s wrong with my code. Please help. thanks.  \\n\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n       String res = s.toLowerCase();\\n       res=res.replaceAll(\"[\\\\\\\\s,:]+\",\"\");\\n       int i=0, j=res.length()-1;\\n       while(i!=j){\\n           if(res.charAt(i)!=res.charAt(j)) return false;\\n           i++;\\n           j--;\\n       }\\n       return true;\\n    }\\n} "
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You are not deleting the\"_\" sign"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Traverse string from both end - left and right\\n[ left -----> ,......................, <-------- right ]\\nif left character is not alphanumeric then move to next position left++\\nif right character is not alphanumeric then move to previos position right--\\nif both are alphanumeric then calculate their position as\\n\\n    private int getPosition(char c){\\n        if(c >=\\'a\\'){\\n            return c - \\'a\\';\\n        }else if(c >=\\'A\\'){\\n            return c - \\'A\\';\\n        }else{\\n            return c - \\'0\\' + 27;\\n        }\\n        \\n    }\\nif position not matched then return false\\notherwise continue till we crossed both pointers.\\n\\nSee solution - https://leetcode.com/problems/valid-palindrome/solutions/3450438/beats-100-easy-solution-two-pointers/\\n"
                    },
                    {
                        "username": "Paban_01",
                        "content": "// can anyone tell me what\\'s wrong with my code ???\\nclass Solution {\\npublic:\\n    bool isValid(char c){\\n    if((c>=\\'a\\' && c<=\\'z\\') || (c>=\\'A\\' && c<=\\'Z\\') || (c>=\\'0\\' && c<=\\'9\\')){\\n        return true;\\n    }\\n    return false;\\n}\\nbool isPalindrome(string s){\\n    int i=0, j=s.length()-1;\\n    while(i<j){\\n        while(!(isValid(s[i])) && i<j){\\n            i++;\\n        }\\n        while(!(isValid(s[i])) && j>i){\\n            j--;\\n        }\\n        if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n            s[i]=s[i]-\\'A\\'+\\'a\\';\\n        }\\n        if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n            s[j]=s[j]-\\'A\\'+\\'a\\'; \\n        }\\n        if(s[i]!=s[j]){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n};"
                    },
                    {
                        "username": "rohitsingh45",
                        "content": "I\\'m getting time exceeds for one of the testcases. I\\'ve gone through looping the original string and removing non-alphanumeric using multiple if-else ladder and after that again iterating the new string from end of the string to the first index and store it in a new string and at last I\\'ve compared both of them. Please help me! Thanks and Regards."
                    }
                ]
            },
            {
                "id": 1851927,
                "content": [
                    {
                        "username": "mohammad_ali_73",
                        "content": "easy and fast approach for this problrm\\n\\n// we will use two pointer approch \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //starting index is point as start which is point to first index\\n        int start = 0;\\n        //end is a another pointer starts from ending index\\n        int end = s.length()-1;\\n\\n        \\n        while(st<end){\\n            //check if it is alpha numaric and increment the starting pointer \\n            if(!isalnum(s[st]))\\n            st++;\\n            else\\n            //check if it is alpha numaric and decrement the ending index\\n            if(!isalnum(s[end]))\\n            end--;\\n            else\\n            //make all the elements to lower if the are not and compare if it is palindrom \\n            if(tolower(s[st])!=tolower(s[end]))\\n            return false;\\n            else{\\n                st++;\\n                end--;\\n            }\\n        }\\n        //finally if we manage to  arive here after the caclulation then it must be a valid palindrome\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "It\\'s funny, in Kotlin language swears at .lowercase(), only .toLowerCase() works."
                    },
                    {
                        "username": "formaxx",
                        "content": "better than 100% cpp solution\\n\\nclass Solution {\\npublic:\\nbool valid(char ch)\\n{\\n    if((ch>=\\'a\\'&&ch<=\\'z\\')||(ch>=\\'A\\'&&ch<=\\'Z\\')||(ch>=\\'0\\'&&ch<=\\'9\\'))\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\nchar tolower(char ch)\\n{\\n    if(ch>=\\'A\\'&&ch<=\\'Z\\')\\n    {\\n        return ch-\\'A\\'+\\'a\\';\\n    }\\n    return ch;\\n}\\nbool checkpalin(string s1)\\n{\\n    int k=s1.length();\\n    for(int i=0;i<k/2;i++)\\n    {\\n        if(s1[i]!=s1[k-i-1])\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n    bool isPalindrome(string s) \\n    {\\n         string s1=\"\";\\n  for(int i=0;i<s.length();i++)\\n  {\\n      if(valid(s[i]))\\n      {\\n          s1.push_back(s[i]);\\n      }\\n  }\\n for(int i=0;i<s1.length();i++)\\n {\\ns1[i]=tolower(s1[i]);\\n     \\n }\\n return checkpalin(s1);\\n\\n     }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gev87",
                        "content": "Some taskcase are wrong:\n\"1a2\" = > \"a\" = > true (you expect false)\n\"0P\" => \"P\" => true ((you expect false)\n\"ab2a\" = > \"aba\" => true ((you expect false)) \n\"9,8\" = > \"\" = > true (as you say in example 3 empty string = true ) . \n\n:("
                    },
                    {
                        "username": "piyushverma17",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(isalpha(s[i])) str +=tolower(s[i]);\\n            else if(isdigit(s[i])) str +=s[i];\\n        }\\n        string rev=str;\\n        reverse(rev.begin(),rev.end());\\n        return str==rev;       \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "chtejeshwar2",
                        "content": "function isPlaindrome(s){\\ns.toLowerCase();\\nlet r = s.split(\").reverse().join(\"\");\\nr.toLowerCase();\\n\\nif(r===s){\\nreturn true;\\n}\\nreturn false\\n}\\n\\nguys case 2 and case 3 are passing ....case 1 is not passing ....can anybody tell me wats wrong here please....thanks in advance...."
                    },
                    {
                        "username": "orioninthespace",
                        "content": "Whats\\'s wrong with my code. Please help. thanks.  \\n\\nclass Solution {\\n    public boolean isPalindrome(String s) {\\n       String res = s.toLowerCase();\\n       res=res.replaceAll(\"[\\\\\\\\s,:]+\",\"\");\\n       int i=0, j=res.length()-1;\\n       while(i!=j){\\n           if(res.charAt(i)!=res.charAt(j)) return false;\\n           i++;\\n           j--;\\n       }\\n       return true;\\n    }\\n} "
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You are not deleting the\"_\" sign"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Traverse string from both end - left and right\\n[ left -----> ,......................, <-------- right ]\\nif left character is not alphanumeric then move to next position left++\\nif right character is not alphanumeric then move to previos position right--\\nif both are alphanumeric then calculate their position as\\n\\n    private int getPosition(char c){\\n        if(c >=\\'a\\'){\\n            return c - \\'a\\';\\n        }else if(c >=\\'A\\'){\\n            return c - \\'A\\';\\n        }else{\\n            return c - \\'0\\' + 27;\\n        }\\n        \\n    }\\nif position not matched then return false\\notherwise continue till we crossed both pointers.\\n\\nSee solution - https://leetcode.com/problems/valid-palindrome/solutions/3450438/beats-100-easy-solution-two-pointers/\\n"
                    },
                    {
                        "username": "Paban_01",
                        "content": "// can anyone tell me what\\'s wrong with my code ???\\nclass Solution {\\npublic:\\n    bool isValid(char c){\\n    if((c>=\\'a\\' && c<=\\'z\\') || (c>=\\'A\\' && c<=\\'Z\\') || (c>=\\'0\\' && c<=\\'9\\')){\\n        return true;\\n    }\\n    return false;\\n}\\nbool isPalindrome(string s){\\n    int i=0, j=s.length()-1;\\n    while(i<j){\\n        while(!(isValid(s[i])) && i<j){\\n            i++;\\n        }\\n        while(!(isValid(s[i])) && j>i){\\n            j--;\\n        }\\n        if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n            s[i]=s[i]-\\'A\\'+\\'a\\';\\n        }\\n        if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n            s[j]=s[j]-\\'A\\'+\\'a\\'; \\n        }\\n        if(s[i]!=s[j]){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n};"
                    },
                    {
                        "username": "rohitsingh45",
                        "content": "I\\'m getting time exceeds for one of the testcases. I\\'ve gone through looping the original string and removing non-alphanumeric using multiple if-else ladder and after that again iterating the new string from end of the string to the first index and store it in a new string and at last I\\'ve compared both of them. Please help me! Thanks and Regards."
                    }
                ]
            },
            {
                "id": 1844244,
                "content": [
                    {
                        "username": "rohit_442",
                        "content": "time limit exceeded \\nhow to control it\\n"
                    },
                    {
                        "username": "Yoltic18",
                        "content": "hey , one question why 0P is false , i think it is true , right?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "0P is false. The code asks for alphanumeric values, so both letters and numbers allowed. Just no symbols or special chars"
                    },
                    {
                        "username": "anandakash2503",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string str = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalpha(s[i])) str += tolower(s[i]);\\n            else if(isdigit(s[i])) str += s[i];\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9437Dr",
                        "content": "Why is this not valid?\\nExpected false for \"0P\";\\n\\n```js\\nvar isPalindrome = function(s) {\\n     s = s.replace(/[^a-zA-Z]+/g, \" \").toLowerCase().replace(/\\\\s+/g, \\'\\');\\n     if(s === [...s].reverse().join(\\'\\')){\\n         return true\\n     }\\n     return false;\\n};\\n```"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "  s[j++]=s[i]+\\'a\\'; giving error while   s[j++]=s[i]+32 ; is woeking fine any ideas ??"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized and understandable code for quick reading \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n    \\n    int i =0;\\n    int j = s.size()-1;\\n\\n    while(i <j)\\n    {\\n         s[i] = tolower( s[i]);\\n         s[j] =tolower(s[j]);\\n\\n          if( !(( s[i]>47 && s[i]<58) ||( s[i]>96 && s[i]<123 ) ) )        ///skip if it is not a alpha skip\\n   {\\n       i++;\\n        continue;\\n   }\\n\\n    if( !(( s[j]>47 && s[j]<58) ||( s[j]>96 && s[j]<123 ) ) )            ///skip if it is not a alpha skip\\n   {\\n       j--;\\n        continue;\\n   }\\n\\n\\nif( s[i]!=s[j])                                                   // if condition not satisfy at any point \\n{\\n     return false;\\n}\\n\\ni++;\\nj--;\\n\\n    }\\n\\n    return true ;                                       ///if all condition will satisfy \\n\\n    } \\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vasubansalcse1121",
                        "content": "is it only me getting TLE for recursion?\\n"
                    },
                    {
                        "username": "SunnyMotwani128",
                        "content": "It was too easy from java | Easy Solution."
                    },
                    {
                        "username": "Ranu_goyal222267894",
                        "content": "all test case are passing only 1st test case are not passsing\\n"
                    },
                    {
                        "username": "inastranets",
                        "content": "Hi all!\\nmy code is behaving very diligently. On the first test, the computer prints true and the server false. With what it can be connected?\\n `class Solution {\\npublic:\\n\\t\\tbool isValid(char c) {\\n\\t\\t\\treturn (c>=\\'A\\'&&c<=\\'Z\\')||(c>=\\'a\\'&&c<=\\'z\\');\\n\\t\\t}\\n\\n    bool isPalindrome(string s) {\\n    \\tfor(int i = 0, j = static_cast<int>(s.size() - 1); i<j; ++i,--j) {\\n\\n    \\t\\twhile(i < j && !isValid(s[i])) ++ i;\\n    \\t\\twhile(j >= i && !isValid(s[j])) -- j;\\n\\n    \\t\\tif(isupper(s[i])) s[i] += 32;\\n    \\t\\tif(isupper(s[j])) s[j] += 32;\\n\\n    \\t\\tif(i == j || s[i] != s[j]) {\\n                return false;\\n        }\\n    \\t}\\n    \\treturn true;\\n    }\\n};`"
                    },
                    {
                        "username": "TharunBollam",
                        "content": "you forgot about numericals. string is alphanumeric\\n"
                    }
                ]
            },
            {
                "id": 1842839,
                "content": [
                    {
                        "username": "rohit_442",
                        "content": "time limit exceeded \\nhow to control it\\n"
                    },
                    {
                        "username": "Yoltic18",
                        "content": "hey , one question why 0P is false , i think it is true , right?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "0P is false. The code asks for alphanumeric values, so both letters and numbers allowed. Just no symbols or special chars"
                    },
                    {
                        "username": "anandakash2503",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string str = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalpha(s[i])) str += tolower(s[i]);\\n            else if(isdigit(s[i])) str += s[i];\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9437Dr",
                        "content": "Why is this not valid?\\nExpected false for \"0P\";\\n\\n```js\\nvar isPalindrome = function(s) {\\n     s = s.replace(/[^a-zA-Z]+/g, \" \").toLowerCase().replace(/\\\\s+/g, \\'\\');\\n     if(s === [...s].reverse().join(\\'\\')){\\n         return true\\n     }\\n     return false;\\n};\\n```"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "  s[j++]=s[i]+\\'a\\'; giving error while   s[j++]=s[i]+32 ; is woeking fine any ideas ??"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized and understandable code for quick reading \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n    \\n    int i =0;\\n    int j = s.size()-1;\\n\\n    while(i <j)\\n    {\\n         s[i] = tolower( s[i]);\\n         s[j] =tolower(s[j]);\\n\\n          if( !(( s[i]>47 && s[i]<58) ||( s[i]>96 && s[i]<123 ) ) )        ///skip if it is not a alpha skip\\n   {\\n       i++;\\n        continue;\\n   }\\n\\n    if( !(( s[j]>47 && s[j]<58) ||( s[j]>96 && s[j]<123 ) ) )            ///skip if it is not a alpha skip\\n   {\\n       j--;\\n        continue;\\n   }\\n\\n\\nif( s[i]!=s[j])                                                   // if condition not satisfy at any point \\n{\\n     return false;\\n}\\n\\ni++;\\nj--;\\n\\n    }\\n\\n    return true ;                                       ///if all condition will satisfy \\n\\n    } \\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vasubansalcse1121",
                        "content": "is it only me getting TLE for recursion?\\n"
                    },
                    {
                        "username": "SunnyMotwani128",
                        "content": "It was too easy from java | Easy Solution."
                    },
                    {
                        "username": "Ranu_goyal222267894",
                        "content": "all test case are passing only 1st test case are not passsing\\n"
                    },
                    {
                        "username": "inastranets",
                        "content": "Hi all!\\nmy code is behaving very diligently. On the first test, the computer prints true and the server false. With what it can be connected?\\n `class Solution {\\npublic:\\n\\t\\tbool isValid(char c) {\\n\\t\\t\\treturn (c>=\\'A\\'&&c<=\\'Z\\')||(c>=\\'a\\'&&c<=\\'z\\');\\n\\t\\t}\\n\\n    bool isPalindrome(string s) {\\n    \\tfor(int i = 0, j = static_cast<int>(s.size() - 1); i<j; ++i,--j) {\\n\\n    \\t\\twhile(i < j && !isValid(s[i])) ++ i;\\n    \\t\\twhile(j >= i && !isValid(s[j])) -- j;\\n\\n    \\t\\tif(isupper(s[i])) s[i] += 32;\\n    \\t\\tif(isupper(s[j])) s[j] += 32;\\n\\n    \\t\\tif(i == j || s[i] != s[j]) {\\n                return false;\\n        }\\n    \\t}\\n    \\treturn true;\\n    }\\n};`"
                    },
                    {
                        "username": "TharunBollam",
                        "content": "you forgot about numericals. string is alphanumeric\\n"
                    }
                ]
            },
            {
                "id": 1840747,
                "content": [
                    {
                        "username": "rohit_442",
                        "content": "time limit exceeded \\nhow to control it\\n"
                    },
                    {
                        "username": "Yoltic18",
                        "content": "hey , one question why 0P is false , i think it is true , right?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "0P is false. The code asks for alphanumeric values, so both letters and numbers allowed. Just no symbols or special chars"
                    },
                    {
                        "username": "anandakash2503",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string str = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalpha(s[i])) str += tolower(s[i]);\\n            else if(isdigit(s[i])) str += s[i];\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9437Dr",
                        "content": "Why is this not valid?\\nExpected false for \"0P\";\\n\\n```js\\nvar isPalindrome = function(s) {\\n     s = s.replace(/[^a-zA-Z]+/g, \" \").toLowerCase().replace(/\\\\s+/g, \\'\\');\\n     if(s === [...s].reverse().join(\\'\\')){\\n         return true\\n     }\\n     return false;\\n};\\n```"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "  s[j++]=s[i]+\\'a\\'; giving error while   s[j++]=s[i]+32 ; is woeking fine any ideas ??"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized and understandable code for quick reading \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n    \\n    int i =0;\\n    int j = s.size()-1;\\n\\n    while(i <j)\\n    {\\n         s[i] = tolower( s[i]);\\n         s[j] =tolower(s[j]);\\n\\n          if( !(( s[i]>47 && s[i]<58) ||( s[i]>96 && s[i]<123 ) ) )        ///skip if it is not a alpha skip\\n   {\\n       i++;\\n        continue;\\n   }\\n\\n    if( !(( s[j]>47 && s[j]<58) ||( s[j]>96 && s[j]<123 ) ) )            ///skip if it is not a alpha skip\\n   {\\n       j--;\\n        continue;\\n   }\\n\\n\\nif( s[i]!=s[j])                                                   // if condition not satisfy at any point \\n{\\n     return false;\\n}\\n\\ni++;\\nj--;\\n\\n    }\\n\\n    return true ;                                       ///if all condition will satisfy \\n\\n    } \\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vasubansalcse1121",
                        "content": "is it only me getting TLE for recursion?\\n"
                    },
                    {
                        "username": "SunnyMotwani128",
                        "content": "It was too easy from java | Easy Solution."
                    },
                    {
                        "username": "Ranu_goyal222267894",
                        "content": "all test case are passing only 1st test case are not passsing\\n"
                    },
                    {
                        "username": "inastranets",
                        "content": "Hi all!\\nmy code is behaving very diligently. On the first test, the computer prints true and the server false. With what it can be connected?\\n `class Solution {\\npublic:\\n\\t\\tbool isValid(char c) {\\n\\t\\t\\treturn (c>=\\'A\\'&&c<=\\'Z\\')||(c>=\\'a\\'&&c<=\\'z\\');\\n\\t\\t}\\n\\n    bool isPalindrome(string s) {\\n    \\tfor(int i = 0, j = static_cast<int>(s.size() - 1); i<j; ++i,--j) {\\n\\n    \\t\\twhile(i < j && !isValid(s[i])) ++ i;\\n    \\t\\twhile(j >= i && !isValid(s[j])) -- j;\\n\\n    \\t\\tif(isupper(s[i])) s[i] += 32;\\n    \\t\\tif(isupper(s[j])) s[j] += 32;\\n\\n    \\t\\tif(i == j || s[i] != s[j]) {\\n                return false;\\n        }\\n    \\t}\\n    \\treturn true;\\n    }\\n};`"
                    },
                    {
                        "username": "TharunBollam",
                        "content": "you forgot about numericals. string is alphanumeric\\n"
                    }
                ]
            },
            {
                "id": 1811953,
                "content": [
                    {
                        "username": "rohit_442",
                        "content": "time limit exceeded \\nhow to control it\\n"
                    },
                    {
                        "username": "Yoltic18",
                        "content": "hey , one question why 0P is false , i think it is true , right?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "0P is false. The code asks for alphanumeric values, so both letters and numbers allowed. Just no symbols or special chars"
                    },
                    {
                        "username": "anandakash2503",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string str = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalpha(s[i])) str += tolower(s[i]);\\n            else if(isdigit(s[i])) str += s[i];\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9437Dr",
                        "content": "Why is this not valid?\\nExpected false for \"0P\";\\n\\n```js\\nvar isPalindrome = function(s) {\\n     s = s.replace(/[^a-zA-Z]+/g, \" \").toLowerCase().replace(/\\\\s+/g, \\'\\');\\n     if(s === [...s].reverse().join(\\'\\')){\\n         return true\\n     }\\n     return false;\\n};\\n```"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "  s[j++]=s[i]+\\'a\\'; giving error while   s[j++]=s[i]+32 ; is woeking fine any ideas ??"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized and understandable code for quick reading \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n    \\n    int i =0;\\n    int j = s.size()-1;\\n\\n    while(i <j)\\n    {\\n         s[i] = tolower( s[i]);\\n         s[j] =tolower(s[j]);\\n\\n          if( !(( s[i]>47 && s[i]<58) ||( s[i]>96 && s[i]<123 ) ) )        ///skip if it is not a alpha skip\\n   {\\n       i++;\\n        continue;\\n   }\\n\\n    if( !(( s[j]>47 && s[j]<58) ||( s[j]>96 && s[j]<123 ) ) )            ///skip if it is not a alpha skip\\n   {\\n       j--;\\n        continue;\\n   }\\n\\n\\nif( s[i]!=s[j])                                                   // if condition not satisfy at any point \\n{\\n     return false;\\n}\\n\\ni++;\\nj--;\\n\\n    }\\n\\n    return true ;                                       ///if all condition will satisfy \\n\\n    } \\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vasubansalcse1121",
                        "content": "is it only me getting TLE for recursion?\\n"
                    },
                    {
                        "username": "SunnyMotwani128",
                        "content": "It was too easy from java | Easy Solution."
                    },
                    {
                        "username": "Ranu_goyal222267894",
                        "content": "all test case are passing only 1st test case are not passsing\\n"
                    },
                    {
                        "username": "inastranets",
                        "content": "Hi all!\\nmy code is behaving very diligently. On the first test, the computer prints true and the server false. With what it can be connected?\\n `class Solution {\\npublic:\\n\\t\\tbool isValid(char c) {\\n\\t\\t\\treturn (c>=\\'A\\'&&c<=\\'Z\\')||(c>=\\'a\\'&&c<=\\'z\\');\\n\\t\\t}\\n\\n    bool isPalindrome(string s) {\\n    \\tfor(int i = 0, j = static_cast<int>(s.size() - 1); i<j; ++i,--j) {\\n\\n    \\t\\twhile(i < j && !isValid(s[i])) ++ i;\\n    \\t\\twhile(j >= i && !isValid(s[j])) -- j;\\n\\n    \\t\\tif(isupper(s[i])) s[i] += 32;\\n    \\t\\tif(isupper(s[j])) s[j] += 32;\\n\\n    \\t\\tif(i == j || s[i] != s[j]) {\\n                return false;\\n        }\\n    \\t}\\n    \\treturn true;\\n    }\\n};`"
                    },
                    {
                        "username": "TharunBollam",
                        "content": "you forgot about numericals. string is alphanumeric\\n"
                    }
                ]
            },
            {
                "id": 1811112,
                "content": [
                    {
                        "username": "rohit_442",
                        "content": "time limit exceeded \\nhow to control it\\n"
                    },
                    {
                        "username": "Yoltic18",
                        "content": "hey , one question why 0P is false , i think it is true , right?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "0P is false. The code asks for alphanumeric values, so both letters and numbers allowed. Just no symbols or special chars"
                    },
                    {
                        "username": "anandakash2503",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string str = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalpha(s[i])) str += tolower(s[i]);\\n            else if(isdigit(s[i])) str += s[i];\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9437Dr",
                        "content": "Why is this not valid?\\nExpected false for \"0P\";\\n\\n```js\\nvar isPalindrome = function(s) {\\n     s = s.replace(/[^a-zA-Z]+/g, \" \").toLowerCase().replace(/\\\\s+/g, \\'\\');\\n     if(s === [...s].reverse().join(\\'\\')){\\n         return true\\n     }\\n     return false;\\n};\\n```"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "  s[j++]=s[i]+\\'a\\'; giving error while   s[j++]=s[i]+32 ; is woeking fine any ideas ??"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized and understandable code for quick reading \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n    \\n    int i =0;\\n    int j = s.size()-1;\\n\\n    while(i <j)\\n    {\\n         s[i] = tolower( s[i]);\\n         s[j] =tolower(s[j]);\\n\\n          if( !(( s[i]>47 && s[i]<58) ||( s[i]>96 && s[i]<123 ) ) )        ///skip if it is not a alpha skip\\n   {\\n       i++;\\n        continue;\\n   }\\n\\n    if( !(( s[j]>47 && s[j]<58) ||( s[j]>96 && s[j]<123 ) ) )            ///skip if it is not a alpha skip\\n   {\\n       j--;\\n        continue;\\n   }\\n\\n\\nif( s[i]!=s[j])                                                   // if condition not satisfy at any point \\n{\\n     return false;\\n}\\n\\ni++;\\nj--;\\n\\n    }\\n\\n    return true ;                                       ///if all condition will satisfy \\n\\n    } \\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vasubansalcse1121",
                        "content": "is it only me getting TLE for recursion?\\n"
                    },
                    {
                        "username": "SunnyMotwani128",
                        "content": "It was too easy from java | Easy Solution."
                    },
                    {
                        "username": "Ranu_goyal222267894",
                        "content": "all test case are passing only 1st test case are not passsing\\n"
                    },
                    {
                        "username": "inastranets",
                        "content": "Hi all!\\nmy code is behaving very diligently. On the first test, the computer prints true and the server false. With what it can be connected?\\n `class Solution {\\npublic:\\n\\t\\tbool isValid(char c) {\\n\\t\\t\\treturn (c>=\\'A\\'&&c<=\\'Z\\')||(c>=\\'a\\'&&c<=\\'z\\');\\n\\t\\t}\\n\\n    bool isPalindrome(string s) {\\n    \\tfor(int i = 0, j = static_cast<int>(s.size() - 1); i<j; ++i,--j) {\\n\\n    \\t\\twhile(i < j && !isValid(s[i])) ++ i;\\n    \\t\\twhile(j >= i && !isValid(s[j])) -- j;\\n\\n    \\t\\tif(isupper(s[i])) s[i] += 32;\\n    \\t\\tif(isupper(s[j])) s[j] += 32;\\n\\n    \\t\\tif(i == j || s[i] != s[j]) {\\n                return false;\\n        }\\n    \\t}\\n    \\treturn true;\\n    }\\n};`"
                    },
                    {
                        "username": "TharunBollam",
                        "content": "you forgot about numericals. string is alphanumeric\\n"
                    }
                ]
            },
            {
                "id": 1808633,
                "content": [
                    {
                        "username": "rohit_442",
                        "content": "time limit exceeded \\nhow to control it\\n"
                    },
                    {
                        "username": "Yoltic18",
                        "content": "hey , one question why 0P is false , i think it is true , right?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "0P is false. The code asks for alphanumeric values, so both letters and numbers allowed. Just no symbols or special chars"
                    },
                    {
                        "username": "anandakash2503",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string str = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalpha(s[i])) str += tolower(s[i]);\\n            else if(isdigit(s[i])) str += s[i];\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9437Dr",
                        "content": "Why is this not valid?\\nExpected false for \"0P\";\\n\\n```js\\nvar isPalindrome = function(s) {\\n     s = s.replace(/[^a-zA-Z]+/g, \" \").toLowerCase().replace(/\\\\s+/g, \\'\\');\\n     if(s === [...s].reverse().join(\\'\\')){\\n         return true\\n     }\\n     return false;\\n};\\n```"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "  s[j++]=s[i]+\\'a\\'; giving error while   s[j++]=s[i]+32 ; is woeking fine any ideas ??"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized and understandable code for quick reading \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n    \\n    int i =0;\\n    int j = s.size()-1;\\n\\n    while(i <j)\\n    {\\n         s[i] = tolower( s[i]);\\n         s[j] =tolower(s[j]);\\n\\n          if( !(( s[i]>47 && s[i]<58) ||( s[i]>96 && s[i]<123 ) ) )        ///skip if it is not a alpha skip\\n   {\\n       i++;\\n        continue;\\n   }\\n\\n    if( !(( s[j]>47 && s[j]<58) ||( s[j]>96 && s[j]<123 ) ) )            ///skip if it is not a alpha skip\\n   {\\n       j--;\\n        continue;\\n   }\\n\\n\\nif( s[i]!=s[j])                                                   // if condition not satisfy at any point \\n{\\n     return false;\\n}\\n\\ni++;\\nj--;\\n\\n    }\\n\\n    return true ;                                       ///if all condition will satisfy \\n\\n    } \\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vasubansalcse1121",
                        "content": "is it only me getting TLE for recursion?\\n"
                    },
                    {
                        "username": "SunnyMotwani128",
                        "content": "It was too easy from java | Easy Solution."
                    },
                    {
                        "username": "Ranu_goyal222267894",
                        "content": "all test case are passing only 1st test case are not passsing\\n"
                    },
                    {
                        "username": "inastranets",
                        "content": "Hi all!\\nmy code is behaving very diligently. On the first test, the computer prints true and the server false. With what it can be connected?\\n `class Solution {\\npublic:\\n\\t\\tbool isValid(char c) {\\n\\t\\t\\treturn (c>=\\'A\\'&&c<=\\'Z\\')||(c>=\\'a\\'&&c<=\\'z\\');\\n\\t\\t}\\n\\n    bool isPalindrome(string s) {\\n    \\tfor(int i = 0, j = static_cast<int>(s.size() - 1); i<j; ++i,--j) {\\n\\n    \\t\\twhile(i < j && !isValid(s[i])) ++ i;\\n    \\t\\twhile(j >= i && !isValid(s[j])) -- j;\\n\\n    \\t\\tif(isupper(s[i])) s[i] += 32;\\n    \\t\\tif(isupper(s[j])) s[j] += 32;\\n\\n    \\t\\tif(i == j || s[i] != s[j]) {\\n                return false;\\n        }\\n    \\t}\\n    \\treturn true;\\n    }\\n};`"
                    },
                    {
                        "username": "TharunBollam",
                        "content": "you forgot about numericals. string is alphanumeric\\n"
                    }
                ]
            },
            {
                "id": 1807649,
                "content": [
                    {
                        "username": "rohit_442",
                        "content": "time limit exceeded \\nhow to control it\\n"
                    },
                    {
                        "username": "Yoltic18",
                        "content": "hey , one question why 0P is false , i think it is true , right?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "0P is false. The code asks for alphanumeric values, so both letters and numbers allowed. Just no symbols or special chars"
                    },
                    {
                        "username": "anandakash2503",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string str = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalpha(s[i])) str += tolower(s[i]);\\n            else if(isdigit(s[i])) str += s[i];\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9437Dr",
                        "content": "Why is this not valid?\\nExpected false for \"0P\";\\n\\n```js\\nvar isPalindrome = function(s) {\\n     s = s.replace(/[^a-zA-Z]+/g, \" \").toLowerCase().replace(/\\\\s+/g, \\'\\');\\n     if(s === [...s].reverse().join(\\'\\')){\\n         return true\\n     }\\n     return false;\\n};\\n```"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "  s[j++]=s[i]+\\'a\\'; giving error while   s[j++]=s[i]+32 ; is woeking fine any ideas ??"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized and understandable code for quick reading \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n    \\n    int i =0;\\n    int j = s.size()-1;\\n\\n    while(i <j)\\n    {\\n         s[i] = tolower( s[i]);\\n         s[j] =tolower(s[j]);\\n\\n          if( !(( s[i]>47 && s[i]<58) ||( s[i]>96 && s[i]<123 ) ) )        ///skip if it is not a alpha skip\\n   {\\n       i++;\\n        continue;\\n   }\\n\\n    if( !(( s[j]>47 && s[j]<58) ||( s[j]>96 && s[j]<123 ) ) )            ///skip if it is not a alpha skip\\n   {\\n       j--;\\n        continue;\\n   }\\n\\n\\nif( s[i]!=s[j])                                                   // if condition not satisfy at any point \\n{\\n     return false;\\n}\\n\\ni++;\\nj--;\\n\\n    }\\n\\n    return true ;                                       ///if all condition will satisfy \\n\\n    } \\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vasubansalcse1121",
                        "content": "is it only me getting TLE for recursion?\\n"
                    },
                    {
                        "username": "SunnyMotwani128",
                        "content": "It was too easy from java | Easy Solution."
                    },
                    {
                        "username": "Ranu_goyal222267894",
                        "content": "all test case are passing only 1st test case are not passsing\\n"
                    },
                    {
                        "username": "inastranets",
                        "content": "Hi all!\\nmy code is behaving very diligently. On the first test, the computer prints true and the server false. With what it can be connected?\\n `class Solution {\\npublic:\\n\\t\\tbool isValid(char c) {\\n\\t\\t\\treturn (c>=\\'A\\'&&c<=\\'Z\\')||(c>=\\'a\\'&&c<=\\'z\\');\\n\\t\\t}\\n\\n    bool isPalindrome(string s) {\\n    \\tfor(int i = 0, j = static_cast<int>(s.size() - 1); i<j; ++i,--j) {\\n\\n    \\t\\twhile(i < j && !isValid(s[i])) ++ i;\\n    \\t\\twhile(j >= i && !isValid(s[j])) -- j;\\n\\n    \\t\\tif(isupper(s[i])) s[i] += 32;\\n    \\t\\tif(isupper(s[j])) s[j] += 32;\\n\\n    \\t\\tif(i == j || s[i] != s[j]) {\\n                return false;\\n        }\\n    \\t}\\n    \\treturn true;\\n    }\\n};`"
                    },
                    {
                        "username": "TharunBollam",
                        "content": "you forgot about numericals. string is alphanumeric\\n"
                    }
                ]
            },
            {
                "id": 1802127,
                "content": [
                    {
                        "username": "rohit_442",
                        "content": "time limit exceeded \\nhow to control it\\n"
                    },
                    {
                        "username": "Yoltic18",
                        "content": "hey , one question why 0P is false , i think it is true , right?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "0P is false. The code asks for alphanumeric values, so both letters and numbers allowed. Just no symbols or special chars"
                    },
                    {
                        "username": "anandakash2503",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string str = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalpha(s[i])) str += tolower(s[i]);\\n            else if(isdigit(s[i])) str += s[i];\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9437Dr",
                        "content": "Why is this not valid?\\nExpected false for \"0P\";\\n\\n```js\\nvar isPalindrome = function(s) {\\n     s = s.replace(/[^a-zA-Z]+/g, \" \").toLowerCase().replace(/\\\\s+/g, \\'\\');\\n     if(s === [...s].reverse().join(\\'\\')){\\n         return true\\n     }\\n     return false;\\n};\\n```"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "  s[j++]=s[i]+\\'a\\'; giving error while   s[j++]=s[i]+32 ; is woeking fine any ideas ??"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized and understandable code for quick reading \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n    \\n    int i =0;\\n    int j = s.size()-1;\\n\\n    while(i <j)\\n    {\\n         s[i] = tolower( s[i]);\\n         s[j] =tolower(s[j]);\\n\\n          if( !(( s[i]>47 && s[i]<58) ||( s[i]>96 && s[i]<123 ) ) )        ///skip if it is not a alpha skip\\n   {\\n       i++;\\n        continue;\\n   }\\n\\n    if( !(( s[j]>47 && s[j]<58) ||( s[j]>96 && s[j]<123 ) ) )            ///skip if it is not a alpha skip\\n   {\\n       j--;\\n        continue;\\n   }\\n\\n\\nif( s[i]!=s[j])                                                   // if condition not satisfy at any point \\n{\\n     return false;\\n}\\n\\ni++;\\nj--;\\n\\n    }\\n\\n    return true ;                                       ///if all condition will satisfy \\n\\n    } \\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vasubansalcse1121",
                        "content": "is it only me getting TLE for recursion?\\n"
                    },
                    {
                        "username": "SunnyMotwani128",
                        "content": "It was too easy from java | Easy Solution."
                    },
                    {
                        "username": "Ranu_goyal222267894",
                        "content": "all test case are passing only 1st test case are not passsing\\n"
                    },
                    {
                        "username": "inastranets",
                        "content": "Hi all!\\nmy code is behaving very diligently. On the first test, the computer prints true and the server false. With what it can be connected?\\n `class Solution {\\npublic:\\n\\t\\tbool isValid(char c) {\\n\\t\\t\\treturn (c>=\\'A\\'&&c<=\\'Z\\')||(c>=\\'a\\'&&c<=\\'z\\');\\n\\t\\t}\\n\\n    bool isPalindrome(string s) {\\n    \\tfor(int i = 0, j = static_cast<int>(s.size() - 1); i<j; ++i,--j) {\\n\\n    \\t\\twhile(i < j && !isValid(s[i])) ++ i;\\n    \\t\\twhile(j >= i && !isValid(s[j])) -- j;\\n\\n    \\t\\tif(isupper(s[i])) s[i] += 32;\\n    \\t\\tif(isupper(s[j])) s[j] += 32;\\n\\n    \\t\\tif(i == j || s[i] != s[j]) {\\n                return false;\\n        }\\n    \\t}\\n    \\treturn true;\\n    }\\n};`"
                    },
                    {
                        "username": "TharunBollam",
                        "content": "you forgot about numericals. string is alphanumeric\\n"
                    }
                ]
            },
            {
                "id": 1800328,
                "content": [
                    {
                        "username": "rohit_442",
                        "content": "time limit exceeded \\nhow to control it\\n"
                    },
                    {
                        "username": "Yoltic18",
                        "content": "hey , one question why 0P is false , i think it is true , right?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "0P is false. The code asks for alphanumeric values, so both letters and numbers allowed. Just no symbols or special chars"
                    },
                    {
                        "username": "anandakash2503",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string str = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalpha(s[i])) str += tolower(s[i]);\\n            else if(isdigit(s[i])) str += s[i];\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9437Dr",
                        "content": "Why is this not valid?\\nExpected false for \"0P\";\\n\\n```js\\nvar isPalindrome = function(s) {\\n     s = s.replace(/[^a-zA-Z]+/g, \" \").toLowerCase().replace(/\\\\s+/g, \\'\\');\\n     if(s === [...s].reverse().join(\\'\\')){\\n         return true\\n     }\\n     return false;\\n};\\n```"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "  s[j++]=s[i]+\\'a\\'; giving error while   s[j++]=s[i]+32 ; is woeking fine any ideas ??"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized and understandable code for quick reading \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n    \\n    int i =0;\\n    int j = s.size()-1;\\n\\n    while(i <j)\\n    {\\n         s[i] = tolower( s[i]);\\n         s[j] =tolower(s[j]);\\n\\n          if( !(( s[i]>47 && s[i]<58) ||( s[i]>96 && s[i]<123 ) ) )        ///skip if it is not a alpha skip\\n   {\\n       i++;\\n        continue;\\n   }\\n\\n    if( !(( s[j]>47 && s[j]<58) ||( s[j]>96 && s[j]<123 ) ) )            ///skip if it is not a alpha skip\\n   {\\n       j--;\\n        continue;\\n   }\\n\\n\\nif( s[i]!=s[j])                                                   // if condition not satisfy at any point \\n{\\n     return false;\\n}\\n\\ni++;\\nj--;\\n\\n    }\\n\\n    return true ;                                       ///if all condition will satisfy \\n\\n    } \\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vasubansalcse1121",
                        "content": "is it only me getting TLE for recursion?\\n"
                    },
                    {
                        "username": "SunnyMotwani128",
                        "content": "It was too easy from java | Easy Solution."
                    },
                    {
                        "username": "Ranu_goyal222267894",
                        "content": "all test case are passing only 1st test case are not passsing\\n"
                    },
                    {
                        "username": "inastranets",
                        "content": "Hi all!\\nmy code is behaving very diligently. On the first test, the computer prints true and the server false. With what it can be connected?\\n `class Solution {\\npublic:\\n\\t\\tbool isValid(char c) {\\n\\t\\t\\treturn (c>=\\'A\\'&&c<=\\'Z\\')||(c>=\\'a\\'&&c<=\\'z\\');\\n\\t\\t}\\n\\n    bool isPalindrome(string s) {\\n    \\tfor(int i = 0, j = static_cast<int>(s.size() - 1); i<j; ++i,--j) {\\n\\n    \\t\\twhile(i < j && !isValid(s[i])) ++ i;\\n    \\t\\twhile(j >= i && !isValid(s[j])) -- j;\\n\\n    \\t\\tif(isupper(s[i])) s[i] += 32;\\n    \\t\\tif(isupper(s[j])) s[j] += 32;\\n\\n    \\t\\tif(i == j || s[i] != s[j]) {\\n                return false;\\n        }\\n    \\t}\\n    \\treturn true;\\n    }\\n};`"
                    },
                    {
                        "username": "TharunBollam",
                        "content": "you forgot about numericals. string is alphanumeric\\n"
                    }
                ]
            },
            {
                "id": 1796964,
                "content": [
                    {
                        "username": "rohit_442",
                        "content": "time limit exceeded \\nhow to control it\\n"
                    },
                    {
                        "username": "Yoltic18",
                        "content": "hey , one question why 0P is false , i think it is true , right?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "0P is false. The code asks for alphanumeric values, so both letters and numbers allowed. Just no symbols or special chars"
                    },
                    {
                        "username": "anandakash2503",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string str = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(isalpha(s[i])) str += tolower(s[i]);\\n            else if(isdigit(s[i])) str += s[i];\\n        }\\n        string rev = str;\\n        reverse(rev.begin(), rev.end());\\n        return str == rev;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9437Dr",
                        "content": "Why is this not valid?\\nExpected false for \"0P\";\\n\\n```js\\nvar isPalindrome = function(s) {\\n     s = s.replace(/[^a-zA-Z]+/g, \" \").toLowerCase().replace(/\\\\s+/g, \\'\\');\\n     if(s === [...s].reverse().join(\\'\\')){\\n         return true\\n     }\\n     return false;\\n};\\n```"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "  s[j++]=s[i]+\\'a\\'; giving error while   s[j++]=s[i]+32 ; is woeking fine any ideas ??"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized and understandable code for quick reading \\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        \\n    \\n    int i =0;\\n    int j = s.size()-1;\\n\\n    while(i <j)\\n    {\\n         s[i] = tolower( s[i]);\\n         s[j] =tolower(s[j]);\\n\\n          if( !(( s[i]>47 && s[i]<58) ||( s[i]>96 && s[i]<123 ) ) )        ///skip if it is not a alpha skip\\n   {\\n       i++;\\n        continue;\\n   }\\n\\n    if( !(( s[j]>47 && s[j]<58) ||( s[j]>96 && s[j]<123 ) ) )            ///skip if it is not a alpha skip\\n   {\\n       j--;\\n        continue;\\n   }\\n\\n\\nif( s[i]!=s[j])                                                   // if condition not satisfy at any point \\n{\\n     return false;\\n}\\n\\ni++;\\nj--;\\n\\n    }\\n\\n    return true ;                                       ///if all condition will satisfy \\n\\n    } \\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vasubansalcse1121",
                        "content": "is it only me getting TLE for recursion?\\n"
                    },
                    {
                        "username": "SunnyMotwani128",
                        "content": "It was too easy from java | Easy Solution."
                    },
                    {
                        "username": "Ranu_goyal222267894",
                        "content": "all test case are passing only 1st test case are not passsing\\n"
                    },
                    {
                        "username": "inastranets",
                        "content": "Hi all!\\nmy code is behaving very diligently. On the first test, the computer prints true and the server false. With what it can be connected?\\n `class Solution {\\npublic:\\n\\t\\tbool isValid(char c) {\\n\\t\\t\\treturn (c>=\\'A\\'&&c<=\\'Z\\')||(c>=\\'a\\'&&c<=\\'z\\');\\n\\t\\t}\\n\\n    bool isPalindrome(string s) {\\n    \\tfor(int i = 0, j = static_cast<int>(s.size() - 1); i<j; ++i,--j) {\\n\\n    \\t\\twhile(i < j && !isValid(s[i])) ++ i;\\n    \\t\\twhile(j >= i && !isValid(s[j])) -- j;\\n\\n    \\t\\tif(isupper(s[i])) s[i] += 32;\\n    \\t\\tif(isupper(s[j])) s[j] += 32;\\n\\n    \\t\\tif(i == j || s[i] != s[j]) {\\n                return false;\\n        }\\n    \\t}\\n    \\treturn true;\\n    }\\n};`"
                    },
                    {
                        "username": "TharunBollam",
                        "content": "you forgot about numericals. string is alphanumeric\\n"
                    }
                ]
            },
            {
                "id": 1795740,
                "content": [
                    {
                        "username": "vaibh_1406",
                        "content": "Using Python 3\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        x = s.replace(\" \", \"\").lower()\\n        s = \\'\\'.join(c for c in x if c.isalnum())\\n        if s == s[::-1]:\\n            return True\\n        else:\\n            return False\\n            "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    if(s==\"\"){\\n      return true\\n    }\\n      let str1= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n                return el\\n        }\\n      }).join(\"\")\\n      let str2= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n            return el\\n    }\\n      }).reverse().join(\"\")\\n\\n   return str1==str2\\n  };\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman__7",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replace(\",\",\"\");\\n        s=s.replace(\" \",\"\");\\n        s=s.toLowerCase();\\n        s=s.replace(\":\",\"\");\\n        String rev=\"\";\\n          for(int i=s.length()-1;i>=0;i--){\\n              rev=rev+s.charAt(i);\\n          }\\n          if(s.equals(rev)){\\n              return true;\\n          }else{\\n              return false;\\n          }\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string l;\\n       int n=s.size();\\n       l=s;\\n       for (int i = 0; i < n / 2; i++)\\n                swap(l[i], l[n - i - 1]);\\n            }\\n        if(s==l) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n//this is my code what is error in this"
                    },
                    {
                        "username": "Kumar9908",
                        "content": "def isPalindrome(self, s: str) -> bool:\\n        if s is \" \":return True\\n        # new=s.replace(\":\",\"\").replace(\",\",\"\").replace(\" \",\"\")\\n        new=\"\".join(filter(str.isalnum,s))\\n        return new.lower()==new[::-1].lower()\\n\\nI have used the isalnum (alpha numerics) which in turn removes all the numerics and character like :,*- etc from string.\\nAs a beginner please do suggest better ideas and implementation of code/\\n"
                    },
                    {
                        "username": "0x666",
                        "content": "String del = \",.:;@#&_{}\\\\\\'\\\\\"[]-?!()` \";\\nits help u"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy question for those who can come up with a solution"
                    },
                    {
                        "username": "ananyaextras",
                        "content": "Why is this not working? Please explain...\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        f=s.strip().split()\\n        z=\"\"\\n        for i in f:\\n            if i.isalpha():\\n                z.join(i)\\n            else:\\n                continue\\n        x=z[::-1]\\n        if z==x:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please help me to resolve the test case,involving spaces.....please\\nclass Solution {\\npublic:\\n    string Tocheck(string s){\\n    \\n     int n;\\n     n= s.size();\\n     char ch;\\n     string f =\"\";\\n\\n     for(int i=0; i<n; i++){\\n         ch = s[i];\\nif(ch>=\\'a\\' && ch<=\\'z\\' || ch>=\\'A\\' && ch<=\\'Z\\'|| ch>=\\'0\\'&& ch<=\\'9\\'){\\n    f.push_back(ch);\\n}\\n\\n     }\\n    return f;\\n    }\\n     \\n      string toLowercase(string &s){\\n\\n     for(int j=0; j< s.size();j++){\\n\\n         if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n          s[j] = s[j] - \\'A\\' + \\'a\\';\\n         }\\n     }\\n     return s;\\n }\\n \\nbool isPalindrome(string s)\\n{\\n    int st=0;\\n    int e= s.size()-1;\\n\\n     Tocheck(s);\\n     toLowercase(s);\\n\\n    while(st<=e){\\n        if(s[st] !=s[e]){\\n           return 0;\\n        }\\n        else {\\n            st++;\\n            e--;\\n        }\\n    }\\n    return  1;\\n}  \\n    };\\n    \\n    "
                    },
                    {
                        "username": "setterwind86",
                        "content": "public static boolean isPalindrome(String s) {\\n\\n        //String sentence = \"A man, a plan, a canal: Panama\";\\n        String editedSentence = \"\";\\n        String palindrome = \"\";\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isAlphabetic(s.charAt(i))) {\\n                editedSentence = editedSentence + s.charAt(i);\\n            }\\n        }\\n        editedSentence = editedSentence.toLowerCase();\\n\\n        for (int i = editedSentence.length() - 1; i >= 0; i--) {\\n            palindrome = palindrome + editedSentence.charAt(i);\\n        }\\n\\n        if (editedSentence == palindrome) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\nThis is my solution and I don\\'t know why I am getting false even though it is a valid palindrome"
                    },
                    {
                        "username": "mayank20patel05",
                        "content": "you are just considering the alphabets, please keep apha-numeric values and remove special charactors for your editedSentence\\n"
                    }
                ]
            },
            {
                "id": 1789268,
                "content": [
                    {
                        "username": "vaibh_1406",
                        "content": "Using Python 3\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        x = s.replace(\" \", \"\").lower()\\n        s = \\'\\'.join(c for c in x if c.isalnum())\\n        if s == s[::-1]:\\n            return True\\n        else:\\n            return False\\n            "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    if(s==\"\"){\\n      return true\\n    }\\n      let str1= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n                return el\\n        }\\n      }).join(\"\")\\n      let str2= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n            return el\\n    }\\n      }).reverse().join(\"\")\\n\\n   return str1==str2\\n  };\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman__7",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replace(\",\",\"\");\\n        s=s.replace(\" \",\"\");\\n        s=s.toLowerCase();\\n        s=s.replace(\":\",\"\");\\n        String rev=\"\";\\n          for(int i=s.length()-1;i>=0;i--){\\n              rev=rev+s.charAt(i);\\n          }\\n          if(s.equals(rev)){\\n              return true;\\n          }else{\\n              return false;\\n          }\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string l;\\n       int n=s.size();\\n       l=s;\\n       for (int i = 0; i < n / 2; i++)\\n                swap(l[i], l[n - i - 1]);\\n            }\\n        if(s==l) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n//this is my code what is error in this"
                    },
                    {
                        "username": "Kumar9908",
                        "content": "def isPalindrome(self, s: str) -> bool:\\n        if s is \" \":return True\\n        # new=s.replace(\":\",\"\").replace(\",\",\"\").replace(\" \",\"\")\\n        new=\"\".join(filter(str.isalnum,s))\\n        return new.lower()==new[::-1].lower()\\n\\nI have used the isalnum (alpha numerics) which in turn removes all the numerics and character like :,*- etc from string.\\nAs a beginner please do suggest better ideas and implementation of code/\\n"
                    },
                    {
                        "username": "0x666",
                        "content": "String del = \",.:;@#&_{}\\\\\\'\\\\\"[]-?!()` \";\\nits help u"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy question for those who can come up with a solution"
                    },
                    {
                        "username": "ananyaextras",
                        "content": "Why is this not working? Please explain...\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        f=s.strip().split()\\n        z=\"\"\\n        for i in f:\\n            if i.isalpha():\\n                z.join(i)\\n            else:\\n                continue\\n        x=z[::-1]\\n        if z==x:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please help me to resolve the test case,involving spaces.....please\\nclass Solution {\\npublic:\\n    string Tocheck(string s){\\n    \\n     int n;\\n     n= s.size();\\n     char ch;\\n     string f =\"\";\\n\\n     for(int i=0; i<n; i++){\\n         ch = s[i];\\nif(ch>=\\'a\\' && ch<=\\'z\\' || ch>=\\'A\\' && ch<=\\'Z\\'|| ch>=\\'0\\'&& ch<=\\'9\\'){\\n    f.push_back(ch);\\n}\\n\\n     }\\n    return f;\\n    }\\n     \\n      string toLowercase(string &s){\\n\\n     for(int j=0; j< s.size();j++){\\n\\n         if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n          s[j] = s[j] - \\'A\\' + \\'a\\';\\n         }\\n     }\\n     return s;\\n }\\n \\nbool isPalindrome(string s)\\n{\\n    int st=0;\\n    int e= s.size()-1;\\n\\n     Tocheck(s);\\n     toLowercase(s);\\n\\n    while(st<=e){\\n        if(s[st] !=s[e]){\\n           return 0;\\n        }\\n        else {\\n            st++;\\n            e--;\\n        }\\n    }\\n    return  1;\\n}  \\n    };\\n    \\n    "
                    },
                    {
                        "username": "setterwind86",
                        "content": "public static boolean isPalindrome(String s) {\\n\\n        //String sentence = \"A man, a plan, a canal: Panama\";\\n        String editedSentence = \"\";\\n        String palindrome = \"\";\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isAlphabetic(s.charAt(i))) {\\n                editedSentence = editedSentence + s.charAt(i);\\n            }\\n        }\\n        editedSentence = editedSentence.toLowerCase();\\n\\n        for (int i = editedSentence.length() - 1; i >= 0; i--) {\\n            palindrome = palindrome + editedSentence.charAt(i);\\n        }\\n\\n        if (editedSentence == palindrome) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\nThis is my solution and I don\\'t know why I am getting false even though it is a valid palindrome"
                    },
                    {
                        "username": "mayank20patel05",
                        "content": "you are just considering the alphabets, please keep apha-numeric values and remove special charactors for your editedSentence\\n"
                    }
                ]
            },
            {
                "id": 1783186,
                "content": [
                    {
                        "username": "vaibh_1406",
                        "content": "Using Python 3\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        x = s.replace(\" \", \"\").lower()\\n        s = \\'\\'.join(c for c in x if c.isalnum())\\n        if s == s[::-1]:\\n            return True\\n        else:\\n            return False\\n            "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    if(s==\"\"){\\n      return true\\n    }\\n      let str1= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n                return el\\n        }\\n      }).join(\"\")\\n      let str2= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n            return el\\n    }\\n      }).reverse().join(\"\")\\n\\n   return str1==str2\\n  };\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman__7",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replace(\",\",\"\");\\n        s=s.replace(\" \",\"\");\\n        s=s.toLowerCase();\\n        s=s.replace(\":\",\"\");\\n        String rev=\"\";\\n          for(int i=s.length()-1;i>=0;i--){\\n              rev=rev+s.charAt(i);\\n          }\\n          if(s.equals(rev)){\\n              return true;\\n          }else{\\n              return false;\\n          }\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string l;\\n       int n=s.size();\\n       l=s;\\n       for (int i = 0; i < n / 2; i++)\\n                swap(l[i], l[n - i - 1]);\\n            }\\n        if(s==l) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n//this is my code what is error in this"
                    },
                    {
                        "username": "Kumar9908",
                        "content": "def isPalindrome(self, s: str) -> bool:\\n        if s is \" \":return True\\n        # new=s.replace(\":\",\"\").replace(\",\",\"\").replace(\" \",\"\")\\n        new=\"\".join(filter(str.isalnum,s))\\n        return new.lower()==new[::-1].lower()\\n\\nI have used the isalnum (alpha numerics) which in turn removes all the numerics and character like :,*- etc from string.\\nAs a beginner please do suggest better ideas and implementation of code/\\n"
                    },
                    {
                        "username": "0x666",
                        "content": "String del = \",.:;@#&_{}\\\\\\'\\\\\"[]-?!()` \";\\nits help u"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy question for those who can come up with a solution"
                    },
                    {
                        "username": "ananyaextras",
                        "content": "Why is this not working? Please explain...\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        f=s.strip().split()\\n        z=\"\"\\n        for i in f:\\n            if i.isalpha():\\n                z.join(i)\\n            else:\\n                continue\\n        x=z[::-1]\\n        if z==x:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please help me to resolve the test case,involving spaces.....please\\nclass Solution {\\npublic:\\n    string Tocheck(string s){\\n    \\n     int n;\\n     n= s.size();\\n     char ch;\\n     string f =\"\";\\n\\n     for(int i=0; i<n; i++){\\n         ch = s[i];\\nif(ch>=\\'a\\' && ch<=\\'z\\' || ch>=\\'A\\' && ch<=\\'Z\\'|| ch>=\\'0\\'&& ch<=\\'9\\'){\\n    f.push_back(ch);\\n}\\n\\n     }\\n    return f;\\n    }\\n     \\n      string toLowercase(string &s){\\n\\n     for(int j=0; j< s.size();j++){\\n\\n         if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n          s[j] = s[j] - \\'A\\' + \\'a\\';\\n         }\\n     }\\n     return s;\\n }\\n \\nbool isPalindrome(string s)\\n{\\n    int st=0;\\n    int e= s.size()-1;\\n\\n     Tocheck(s);\\n     toLowercase(s);\\n\\n    while(st<=e){\\n        if(s[st] !=s[e]){\\n           return 0;\\n        }\\n        else {\\n            st++;\\n            e--;\\n        }\\n    }\\n    return  1;\\n}  \\n    };\\n    \\n    "
                    },
                    {
                        "username": "setterwind86",
                        "content": "public static boolean isPalindrome(String s) {\\n\\n        //String sentence = \"A man, a plan, a canal: Panama\";\\n        String editedSentence = \"\";\\n        String palindrome = \"\";\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isAlphabetic(s.charAt(i))) {\\n                editedSentence = editedSentence + s.charAt(i);\\n            }\\n        }\\n        editedSentence = editedSentence.toLowerCase();\\n\\n        for (int i = editedSentence.length() - 1; i >= 0; i--) {\\n            palindrome = palindrome + editedSentence.charAt(i);\\n        }\\n\\n        if (editedSentence == palindrome) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\nThis is my solution and I don\\'t know why I am getting false even though it is a valid palindrome"
                    },
                    {
                        "username": "mayank20patel05",
                        "content": "you are just considering the alphabets, please keep apha-numeric values and remove special charactors for your editedSentence\\n"
                    }
                ]
            },
            {
                "id": 1782145,
                "content": [
                    {
                        "username": "vaibh_1406",
                        "content": "Using Python 3\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        x = s.replace(\" \", \"\").lower()\\n        s = \\'\\'.join(c for c in x if c.isalnum())\\n        if s == s[::-1]:\\n            return True\\n        else:\\n            return False\\n            "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    if(s==\"\"){\\n      return true\\n    }\\n      let str1= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n                return el\\n        }\\n      }).join(\"\")\\n      let str2= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n            return el\\n    }\\n      }).reverse().join(\"\")\\n\\n   return str1==str2\\n  };\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman__7",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replace(\",\",\"\");\\n        s=s.replace(\" \",\"\");\\n        s=s.toLowerCase();\\n        s=s.replace(\":\",\"\");\\n        String rev=\"\";\\n          for(int i=s.length()-1;i>=0;i--){\\n              rev=rev+s.charAt(i);\\n          }\\n          if(s.equals(rev)){\\n              return true;\\n          }else{\\n              return false;\\n          }\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string l;\\n       int n=s.size();\\n       l=s;\\n       for (int i = 0; i < n / 2; i++)\\n                swap(l[i], l[n - i - 1]);\\n            }\\n        if(s==l) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n//this is my code what is error in this"
                    },
                    {
                        "username": "Kumar9908",
                        "content": "def isPalindrome(self, s: str) -> bool:\\n        if s is \" \":return True\\n        # new=s.replace(\":\",\"\").replace(\",\",\"\").replace(\" \",\"\")\\n        new=\"\".join(filter(str.isalnum,s))\\n        return new.lower()==new[::-1].lower()\\n\\nI have used the isalnum (alpha numerics) which in turn removes all the numerics and character like :,*- etc from string.\\nAs a beginner please do suggest better ideas and implementation of code/\\n"
                    },
                    {
                        "username": "0x666",
                        "content": "String del = \",.:;@#&_{}\\\\\\'\\\\\"[]-?!()` \";\\nits help u"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy question for those who can come up with a solution"
                    },
                    {
                        "username": "ananyaextras",
                        "content": "Why is this not working? Please explain...\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        f=s.strip().split()\\n        z=\"\"\\n        for i in f:\\n            if i.isalpha():\\n                z.join(i)\\n            else:\\n                continue\\n        x=z[::-1]\\n        if z==x:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please help me to resolve the test case,involving spaces.....please\\nclass Solution {\\npublic:\\n    string Tocheck(string s){\\n    \\n     int n;\\n     n= s.size();\\n     char ch;\\n     string f =\"\";\\n\\n     for(int i=0; i<n; i++){\\n         ch = s[i];\\nif(ch>=\\'a\\' && ch<=\\'z\\' || ch>=\\'A\\' && ch<=\\'Z\\'|| ch>=\\'0\\'&& ch<=\\'9\\'){\\n    f.push_back(ch);\\n}\\n\\n     }\\n    return f;\\n    }\\n     \\n      string toLowercase(string &s){\\n\\n     for(int j=0; j< s.size();j++){\\n\\n         if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n          s[j] = s[j] - \\'A\\' + \\'a\\';\\n         }\\n     }\\n     return s;\\n }\\n \\nbool isPalindrome(string s)\\n{\\n    int st=0;\\n    int e= s.size()-1;\\n\\n     Tocheck(s);\\n     toLowercase(s);\\n\\n    while(st<=e){\\n        if(s[st] !=s[e]){\\n           return 0;\\n        }\\n        else {\\n            st++;\\n            e--;\\n        }\\n    }\\n    return  1;\\n}  \\n    };\\n    \\n    "
                    },
                    {
                        "username": "setterwind86",
                        "content": "public static boolean isPalindrome(String s) {\\n\\n        //String sentence = \"A man, a plan, a canal: Panama\";\\n        String editedSentence = \"\";\\n        String palindrome = \"\";\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isAlphabetic(s.charAt(i))) {\\n                editedSentence = editedSentence + s.charAt(i);\\n            }\\n        }\\n        editedSentence = editedSentence.toLowerCase();\\n\\n        for (int i = editedSentence.length() - 1; i >= 0; i--) {\\n            palindrome = palindrome + editedSentence.charAt(i);\\n        }\\n\\n        if (editedSentence == palindrome) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\nThis is my solution and I don\\'t know why I am getting false even though it is a valid palindrome"
                    },
                    {
                        "username": "mayank20patel05",
                        "content": "you are just considering the alphabets, please keep apha-numeric values and remove special charactors for your editedSentence\\n"
                    }
                ]
            },
            {
                "id": 1779733,
                "content": [
                    {
                        "username": "vaibh_1406",
                        "content": "Using Python 3\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        x = s.replace(\" \", \"\").lower()\\n        s = \\'\\'.join(c for c in x if c.isalnum())\\n        if s == s[::-1]:\\n            return True\\n        else:\\n            return False\\n            "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    if(s==\"\"){\\n      return true\\n    }\\n      let str1= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n                return el\\n        }\\n      }).join(\"\")\\n      let str2= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n            return el\\n    }\\n      }).reverse().join(\"\")\\n\\n   return str1==str2\\n  };\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman__7",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replace(\",\",\"\");\\n        s=s.replace(\" \",\"\");\\n        s=s.toLowerCase();\\n        s=s.replace(\":\",\"\");\\n        String rev=\"\";\\n          for(int i=s.length()-1;i>=0;i--){\\n              rev=rev+s.charAt(i);\\n          }\\n          if(s.equals(rev)){\\n              return true;\\n          }else{\\n              return false;\\n          }\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string l;\\n       int n=s.size();\\n       l=s;\\n       for (int i = 0; i < n / 2; i++)\\n                swap(l[i], l[n - i - 1]);\\n            }\\n        if(s==l) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n//this is my code what is error in this"
                    },
                    {
                        "username": "Kumar9908",
                        "content": "def isPalindrome(self, s: str) -> bool:\\n        if s is \" \":return True\\n        # new=s.replace(\":\",\"\").replace(\",\",\"\").replace(\" \",\"\")\\n        new=\"\".join(filter(str.isalnum,s))\\n        return new.lower()==new[::-1].lower()\\n\\nI have used the isalnum (alpha numerics) which in turn removes all the numerics and character like :,*- etc from string.\\nAs a beginner please do suggest better ideas and implementation of code/\\n"
                    },
                    {
                        "username": "0x666",
                        "content": "String del = \",.:;@#&_{}\\\\\\'\\\\\"[]-?!()` \";\\nits help u"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy question for those who can come up with a solution"
                    },
                    {
                        "username": "ananyaextras",
                        "content": "Why is this not working? Please explain...\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        f=s.strip().split()\\n        z=\"\"\\n        for i in f:\\n            if i.isalpha():\\n                z.join(i)\\n            else:\\n                continue\\n        x=z[::-1]\\n        if z==x:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please help me to resolve the test case,involving spaces.....please\\nclass Solution {\\npublic:\\n    string Tocheck(string s){\\n    \\n     int n;\\n     n= s.size();\\n     char ch;\\n     string f =\"\";\\n\\n     for(int i=0; i<n; i++){\\n         ch = s[i];\\nif(ch>=\\'a\\' && ch<=\\'z\\' || ch>=\\'A\\' && ch<=\\'Z\\'|| ch>=\\'0\\'&& ch<=\\'9\\'){\\n    f.push_back(ch);\\n}\\n\\n     }\\n    return f;\\n    }\\n     \\n      string toLowercase(string &s){\\n\\n     for(int j=0; j< s.size();j++){\\n\\n         if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n          s[j] = s[j] - \\'A\\' + \\'a\\';\\n         }\\n     }\\n     return s;\\n }\\n \\nbool isPalindrome(string s)\\n{\\n    int st=0;\\n    int e= s.size()-1;\\n\\n     Tocheck(s);\\n     toLowercase(s);\\n\\n    while(st<=e){\\n        if(s[st] !=s[e]){\\n           return 0;\\n        }\\n        else {\\n            st++;\\n            e--;\\n        }\\n    }\\n    return  1;\\n}  \\n    };\\n    \\n    "
                    },
                    {
                        "username": "setterwind86",
                        "content": "public static boolean isPalindrome(String s) {\\n\\n        //String sentence = \"A man, a plan, a canal: Panama\";\\n        String editedSentence = \"\";\\n        String palindrome = \"\";\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isAlphabetic(s.charAt(i))) {\\n                editedSentence = editedSentence + s.charAt(i);\\n            }\\n        }\\n        editedSentence = editedSentence.toLowerCase();\\n\\n        for (int i = editedSentence.length() - 1; i >= 0; i--) {\\n            palindrome = palindrome + editedSentence.charAt(i);\\n        }\\n\\n        if (editedSentence == palindrome) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\nThis is my solution and I don\\'t know why I am getting false even though it is a valid palindrome"
                    },
                    {
                        "username": "mayank20patel05",
                        "content": "you are just considering the alphabets, please keep apha-numeric values and remove special charactors for your editedSentence\\n"
                    }
                ]
            },
            {
                "id": 1779315,
                "content": [
                    {
                        "username": "vaibh_1406",
                        "content": "Using Python 3\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        x = s.replace(\" \", \"\").lower()\\n        s = \\'\\'.join(c for c in x if c.isalnum())\\n        if s == s[::-1]:\\n            return True\\n        else:\\n            return False\\n            "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    if(s==\"\"){\\n      return true\\n    }\\n      let str1= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n                return el\\n        }\\n      }).join(\"\")\\n      let str2= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n            return el\\n    }\\n      }).reverse().join(\"\")\\n\\n   return str1==str2\\n  };\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman__7",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replace(\",\",\"\");\\n        s=s.replace(\" \",\"\");\\n        s=s.toLowerCase();\\n        s=s.replace(\":\",\"\");\\n        String rev=\"\";\\n          for(int i=s.length()-1;i>=0;i--){\\n              rev=rev+s.charAt(i);\\n          }\\n          if(s.equals(rev)){\\n              return true;\\n          }else{\\n              return false;\\n          }\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string l;\\n       int n=s.size();\\n       l=s;\\n       for (int i = 0; i < n / 2; i++)\\n                swap(l[i], l[n - i - 1]);\\n            }\\n        if(s==l) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n//this is my code what is error in this"
                    },
                    {
                        "username": "Kumar9908",
                        "content": "def isPalindrome(self, s: str) -> bool:\\n        if s is \" \":return True\\n        # new=s.replace(\":\",\"\").replace(\",\",\"\").replace(\" \",\"\")\\n        new=\"\".join(filter(str.isalnum,s))\\n        return new.lower()==new[::-1].lower()\\n\\nI have used the isalnum (alpha numerics) which in turn removes all the numerics and character like :,*- etc from string.\\nAs a beginner please do suggest better ideas and implementation of code/\\n"
                    },
                    {
                        "username": "0x666",
                        "content": "String del = \",.:;@#&_{}\\\\\\'\\\\\"[]-?!()` \";\\nits help u"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy question for those who can come up with a solution"
                    },
                    {
                        "username": "ananyaextras",
                        "content": "Why is this not working? Please explain...\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        f=s.strip().split()\\n        z=\"\"\\n        for i in f:\\n            if i.isalpha():\\n                z.join(i)\\n            else:\\n                continue\\n        x=z[::-1]\\n        if z==x:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please help me to resolve the test case,involving spaces.....please\\nclass Solution {\\npublic:\\n    string Tocheck(string s){\\n    \\n     int n;\\n     n= s.size();\\n     char ch;\\n     string f =\"\";\\n\\n     for(int i=0; i<n; i++){\\n         ch = s[i];\\nif(ch>=\\'a\\' && ch<=\\'z\\' || ch>=\\'A\\' && ch<=\\'Z\\'|| ch>=\\'0\\'&& ch<=\\'9\\'){\\n    f.push_back(ch);\\n}\\n\\n     }\\n    return f;\\n    }\\n     \\n      string toLowercase(string &s){\\n\\n     for(int j=0; j< s.size();j++){\\n\\n         if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n          s[j] = s[j] - \\'A\\' + \\'a\\';\\n         }\\n     }\\n     return s;\\n }\\n \\nbool isPalindrome(string s)\\n{\\n    int st=0;\\n    int e= s.size()-1;\\n\\n     Tocheck(s);\\n     toLowercase(s);\\n\\n    while(st<=e){\\n        if(s[st] !=s[e]){\\n           return 0;\\n        }\\n        else {\\n            st++;\\n            e--;\\n        }\\n    }\\n    return  1;\\n}  \\n    };\\n    \\n    "
                    },
                    {
                        "username": "setterwind86",
                        "content": "public static boolean isPalindrome(String s) {\\n\\n        //String sentence = \"A man, a plan, a canal: Panama\";\\n        String editedSentence = \"\";\\n        String palindrome = \"\";\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isAlphabetic(s.charAt(i))) {\\n                editedSentence = editedSentence + s.charAt(i);\\n            }\\n        }\\n        editedSentence = editedSentence.toLowerCase();\\n\\n        for (int i = editedSentence.length() - 1; i >= 0; i--) {\\n            palindrome = palindrome + editedSentence.charAt(i);\\n        }\\n\\n        if (editedSentence == palindrome) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\nThis is my solution and I don\\'t know why I am getting false even though it is a valid palindrome"
                    },
                    {
                        "username": "mayank20patel05",
                        "content": "you are just considering the alphabets, please keep apha-numeric values and remove special charactors for your editedSentence\\n"
                    }
                ]
            },
            {
                "id": 1774237,
                "content": [
                    {
                        "username": "vaibh_1406",
                        "content": "Using Python 3\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        x = s.replace(\" \", \"\").lower()\\n        s = \\'\\'.join(c for c in x if c.isalnum())\\n        if s == s[::-1]:\\n            return True\\n        else:\\n            return False\\n            "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    if(s==\"\"){\\n      return true\\n    }\\n      let str1= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n                return el\\n        }\\n      }).join(\"\")\\n      let str2= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n            return el\\n    }\\n      }).reverse().join(\"\")\\n\\n   return str1==str2\\n  };\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman__7",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replace(\",\",\"\");\\n        s=s.replace(\" \",\"\");\\n        s=s.toLowerCase();\\n        s=s.replace(\":\",\"\");\\n        String rev=\"\";\\n          for(int i=s.length()-1;i>=0;i--){\\n              rev=rev+s.charAt(i);\\n          }\\n          if(s.equals(rev)){\\n              return true;\\n          }else{\\n              return false;\\n          }\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string l;\\n       int n=s.size();\\n       l=s;\\n       for (int i = 0; i < n / 2; i++)\\n                swap(l[i], l[n - i - 1]);\\n            }\\n        if(s==l) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n//this is my code what is error in this"
                    },
                    {
                        "username": "Kumar9908",
                        "content": "def isPalindrome(self, s: str) -> bool:\\n        if s is \" \":return True\\n        # new=s.replace(\":\",\"\").replace(\",\",\"\").replace(\" \",\"\")\\n        new=\"\".join(filter(str.isalnum,s))\\n        return new.lower()==new[::-1].lower()\\n\\nI have used the isalnum (alpha numerics) which in turn removes all the numerics and character like :,*- etc from string.\\nAs a beginner please do suggest better ideas and implementation of code/\\n"
                    },
                    {
                        "username": "0x666",
                        "content": "String del = \",.:;@#&_{}\\\\\\'\\\\\"[]-?!()` \";\\nits help u"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy question for those who can come up with a solution"
                    },
                    {
                        "username": "ananyaextras",
                        "content": "Why is this not working? Please explain...\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        f=s.strip().split()\\n        z=\"\"\\n        for i in f:\\n            if i.isalpha():\\n                z.join(i)\\n            else:\\n                continue\\n        x=z[::-1]\\n        if z==x:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please help me to resolve the test case,involving spaces.....please\\nclass Solution {\\npublic:\\n    string Tocheck(string s){\\n    \\n     int n;\\n     n= s.size();\\n     char ch;\\n     string f =\"\";\\n\\n     for(int i=0; i<n; i++){\\n         ch = s[i];\\nif(ch>=\\'a\\' && ch<=\\'z\\' || ch>=\\'A\\' && ch<=\\'Z\\'|| ch>=\\'0\\'&& ch<=\\'9\\'){\\n    f.push_back(ch);\\n}\\n\\n     }\\n    return f;\\n    }\\n     \\n      string toLowercase(string &s){\\n\\n     for(int j=0; j< s.size();j++){\\n\\n         if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n          s[j] = s[j] - \\'A\\' + \\'a\\';\\n         }\\n     }\\n     return s;\\n }\\n \\nbool isPalindrome(string s)\\n{\\n    int st=0;\\n    int e= s.size()-1;\\n\\n     Tocheck(s);\\n     toLowercase(s);\\n\\n    while(st<=e){\\n        if(s[st] !=s[e]){\\n           return 0;\\n        }\\n        else {\\n            st++;\\n            e--;\\n        }\\n    }\\n    return  1;\\n}  \\n    };\\n    \\n    "
                    },
                    {
                        "username": "setterwind86",
                        "content": "public static boolean isPalindrome(String s) {\\n\\n        //String sentence = \"A man, a plan, a canal: Panama\";\\n        String editedSentence = \"\";\\n        String palindrome = \"\";\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isAlphabetic(s.charAt(i))) {\\n                editedSentence = editedSentence + s.charAt(i);\\n            }\\n        }\\n        editedSentence = editedSentence.toLowerCase();\\n\\n        for (int i = editedSentence.length() - 1; i >= 0; i--) {\\n            palindrome = palindrome + editedSentence.charAt(i);\\n        }\\n\\n        if (editedSentence == palindrome) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\nThis is my solution and I don\\'t know why I am getting false even though it is a valid palindrome"
                    },
                    {
                        "username": "mayank20patel05",
                        "content": "you are just considering the alphabets, please keep apha-numeric values and remove special charactors for your editedSentence\\n"
                    }
                ]
            },
            {
                "id": 1771511,
                "content": [
                    {
                        "username": "vaibh_1406",
                        "content": "Using Python 3\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        x = s.replace(\" \", \"\").lower()\\n        s = \\'\\'.join(c for c in x if c.isalnum())\\n        if s == s[::-1]:\\n            return True\\n        else:\\n            return False\\n            "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    if(s==\"\"){\\n      return true\\n    }\\n      let str1= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n                return el\\n        }\\n      }).join(\"\")\\n      let str2= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n            return el\\n    }\\n      }).reverse().join(\"\")\\n\\n   return str1==str2\\n  };\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman__7",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replace(\",\",\"\");\\n        s=s.replace(\" \",\"\");\\n        s=s.toLowerCase();\\n        s=s.replace(\":\",\"\");\\n        String rev=\"\";\\n          for(int i=s.length()-1;i>=0;i--){\\n              rev=rev+s.charAt(i);\\n          }\\n          if(s.equals(rev)){\\n              return true;\\n          }else{\\n              return false;\\n          }\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string l;\\n       int n=s.size();\\n       l=s;\\n       for (int i = 0; i < n / 2; i++)\\n                swap(l[i], l[n - i - 1]);\\n            }\\n        if(s==l) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n//this is my code what is error in this"
                    },
                    {
                        "username": "Kumar9908",
                        "content": "def isPalindrome(self, s: str) -> bool:\\n        if s is \" \":return True\\n        # new=s.replace(\":\",\"\").replace(\",\",\"\").replace(\" \",\"\")\\n        new=\"\".join(filter(str.isalnum,s))\\n        return new.lower()==new[::-1].lower()\\n\\nI have used the isalnum (alpha numerics) which in turn removes all the numerics and character like :,*- etc from string.\\nAs a beginner please do suggest better ideas and implementation of code/\\n"
                    },
                    {
                        "username": "0x666",
                        "content": "String del = \",.:;@#&_{}\\\\\\'\\\\\"[]-?!()` \";\\nits help u"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy question for those who can come up with a solution"
                    },
                    {
                        "username": "ananyaextras",
                        "content": "Why is this not working? Please explain...\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        f=s.strip().split()\\n        z=\"\"\\n        for i in f:\\n            if i.isalpha():\\n                z.join(i)\\n            else:\\n                continue\\n        x=z[::-1]\\n        if z==x:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please help me to resolve the test case,involving spaces.....please\\nclass Solution {\\npublic:\\n    string Tocheck(string s){\\n    \\n     int n;\\n     n= s.size();\\n     char ch;\\n     string f =\"\";\\n\\n     for(int i=0; i<n; i++){\\n         ch = s[i];\\nif(ch>=\\'a\\' && ch<=\\'z\\' || ch>=\\'A\\' && ch<=\\'Z\\'|| ch>=\\'0\\'&& ch<=\\'9\\'){\\n    f.push_back(ch);\\n}\\n\\n     }\\n    return f;\\n    }\\n     \\n      string toLowercase(string &s){\\n\\n     for(int j=0; j< s.size();j++){\\n\\n         if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n          s[j] = s[j] - \\'A\\' + \\'a\\';\\n         }\\n     }\\n     return s;\\n }\\n \\nbool isPalindrome(string s)\\n{\\n    int st=0;\\n    int e= s.size()-1;\\n\\n     Tocheck(s);\\n     toLowercase(s);\\n\\n    while(st<=e){\\n        if(s[st] !=s[e]){\\n           return 0;\\n        }\\n        else {\\n            st++;\\n            e--;\\n        }\\n    }\\n    return  1;\\n}  \\n    };\\n    \\n    "
                    },
                    {
                        "username": "setterwind86",
                        "content": "public static boolean isPalindrome(String s) {\\n\\n        //String sentence = \"A man, a plan, a canal: Panama\";\\n        String editedSentence = \"\";\\n        String palindrome = \"\";\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isAlphabetic(s.charAt(i))) {\\n                editedSentence = editedSentence + s.charAt(i);\\n            }\\n        }\\n        editedSentence = editedSentence.toLowerCase();\\n\\n        for (int i = editedSentence.length() - 1; i >= 0; i--) {\\n            palindrome = palindrome + editedSentence.charAt(i);\\n        }\\n\\n        if (editedSentence == palindrome) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\nThis is my solution and I don\\'t know why I am getting false even though it is a valid palindrome"
                    },
                    {
                        "username": "mayank20patel05",
                        "content": "you are just considering the alphabets, please keep apha-numeric values and remove special charactors for your editedSentence\\n"
                    }
                ]
            },
            {
                "id": 1771261,
                "content": [
                    {
                        "username": "vaibh_1406",
                        "content": "Using Python 3\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        x = s.replace(\" \", \"\").lower()\\n        s = \\'\\'.join(c for c in x if c.isalnum())\\n        if s == s[::-1]:\\n            return True\\n        else:\\n            return False\\n            "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    if(s==\"\"){\\n      return true\\n    }\\n      let str1= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n                return el\\n        }\\n      }).join(\"\")\\n      let str2= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n            return el\\n    }\\n      }).reverse().join(\"\")\\n\\n   return str1==str2\\n  };\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman__7",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replace(\",\",\"\");\\n        s=s.replace(\" \",\"\");\\n        s=s.toLowerCase();\\n        s=s.replace(\":\",\"\");\\n        String rev=\"\";\\n          for(int i=s.length()-1;i>=0;i--){\\n              rev=rev+s.charAt(i);\\n          }\\n          if(s.equals(rev)){\\n              return true;\\n          }else{\\n              return false;\\n          }\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string l;\\n       int n=s.size();\\n       l=s;\\n       for (int i = 0; i < n / 2; i++)\\n                swap(l[i], l[n - i - 1]);\\n            }\\n        if(s==l) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n//this is my code what is error in this"
                    },
                    {
                        "username": "Kumar9908",
                        "content": "def isPalindrome(self, s: str) -> bool:\\n        if s is \" \":return True\\n        # new=s.replace(\":\",\"\").replace(\",\",\"\").replace(\" \",\"\")\\n        new=\"\".join(filter(str.isalnum,s))\\n        return new.lower()==new[::-1].lower()\\n\\nI have used the isalnum (alpha numerics) which in turn removes all the numerics and character like :,*- etc from string.\\nAs a beginner please do suggest better ideas and implementation of code/\\n"
                    },
                    {
                        "username": "0x666",
                        "content": "String del = \",.:;@#&_{}\\\\\\'\\\\\"[]-?!()` \";\\nits help u"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy question for those who can come up with a solution"
                    },
                    {
                        "username": "ananyaextras",
                        "content": "Why is this not working? Please explain...\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        f=s.strip().split()\\n        z=\"\"\\n        for i in f:\\n            if i.isalpha():\\n                z.join(i)\\n            else:\\n                continue\\n        x=z[::-1]\\n        if z==x:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please help me to resolve the test case,involving spaces.....please\\nclass Solution {\\npublic:\\n    string Tocheck(string s){\\n    \\n     int n;\\n     n= s.size();\\n     char ch;\\n     string f =\"\";\\n\\n     for(int i=0; i<n; i++){\\n         ch = s[i];\\nif(ch>=\\'a\\' && ch<=\\'z\\' || ch>=\\'A\\' && ch<=\\'Z\\'|| ch>=\\'0\\'&& ch<=\\'9\\'){\\n    f.push_back(ch);\\n}\\n\\n     }\\n    return f;\\n    }\\n     \\n      string toLowercase(string &s){\\n\\n     for(int j=0; j< s.size();j++){\\n\\n         if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n          s[j] = s[j] - \\'A\\' + \\'a\\';\\n         }\\n     }\\n     return s;\\n }\\n \\nbool isPalindrome(string s)\\n{\\n    int st=0;\\n    int e= s.size()-1;\\n\\n     Tocheck(s);\\n     toLowercase(s);\\n\\n    while(st<=e){\\n        if(s[st] !=s[e]){\\n           return 0;\\n        }\\n        else {\\n            st++;\\n            e--;\\n        }\\n    }\\n    return  1;\\n}  \\n    };\\n    \\n    "
                    },
                    {
                        "username": "setterwind86",
                        "content": "public static boolean isPalindrome(String s) {\\n\\n        //String sentence = \"A man, a plan, a canal: Panama\";\\n        String editedSentence = \"\";\\n        String palindrome = \"\";\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isAlphabetic(s.charAt(i))) {\\n                editedSentence = editedSentence + s.charAt(i);\\n            }\\n        }\\n        editedSentence = editedSentence.toLowerCase();\\n\\n        for (int i = editedSentence.length() - 1; i >= 0; i--) {\\n            palindrome = palindrome + editedSentence.charAt(i);\\n        }\\n\\n        if (editedSentence == palindrome) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\nThis is my solution and I don\\'t know why I am getting false even though it is a valid palindrome"
                    },
                    {
                        "username": "mayank20patel05",
                        "content": "you are just considering the alphabets, please keep apha-numeric values and remove special charactors for your editedSentence\\n"
                    }
                ]
            },
            {
                "id": 1768686,
                "content": [
                    {
                        "username": "vaibh_1406",
                        "content": "Using Python 3\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        x = s.replace(\" \", \"\").lower()\\n        s = \\'\\'.join(c for c in x if c.isalnum())\\n        if s == s[::-1]:\\n            return True\\n        else:\\n            return False\\n            "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function(s) {\\n    if(s==\"\"){\\n      return true\\n    }\\n      let str1= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n                return el\\n        }\\n      }).join(\"\")\\n      let str2= s.toLowerCase().split(\"\").filter((el)=>{\\n        if(el>=\"a\" && el<=\"z\"){\\n            return el\\n        }else if((Number(el)>=0 && Number(el)<=9) && el!=\" \"){\\n            return el\\n    }\\n      }).reverse().join(\"\")\\n\\n   return str1==str2\\n  };\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman__7",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s=s.replace(\",\",\"\");\\n        s=s.replace(\" \",\"\");\\n        s=s.toLowerCase();\\n        s=s.replace(\":\",\"\");\\n        String rev=\"\";\\n          for(int i=s.length()-1;i>=0;i--){\\n              rev=rev+s.charAt(i);\\n          }\\n          if(s.equals(rev)){\\n              return true;\\n          }else{\\n              return false;\\n          }\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n       string l;\\n       int n=s.size();\\n       l=s;\\n       for (int i = 0; i < n / 2; i++)\\n                swap(l[i], l[n - i - 1]);\\n            }\\n        if(s==l) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n//this is my code what is error in this"
                    },
                    {
                        "username": "Kumar9908",
                        "content": "def isPalindrome(self, s: str) -> bool:\\n        if s is \" \":return True\\n        # new=s.replace(\":\",\"\").replace(\",\",\"\").replace(\" \",\"\")\\n        new=\"\".join(filter(str.isalnum,s))\\n        return new.lower()==new[::-1].lower()\\n\\nI have used the isalnum (alpha numerics) which in turn removes all the numerics and character like :,*- etc from string.\\nAs a beginner please do suggest better ideas and implementation of code/\\n"
                    },
                    {
                        "username": "0x666",
                        "content": "String del = \",.:;@#&_{}\\\\\\'\\\\\"[]-?!()` \";\\nits help u"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy question for those who can come up with a solution"
                    },
                    {
                        "username": "ananyaextras",
                        "content": "Why is this not working? Please explain...\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        f=s.strip().split()\\n        z=\"\"\\n        for i in f:\\n            if i.isalpha():\\n                z.join(i)\\n            else:\\n                continue\\n        x=z[::-1]\\n        if z==x:\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please help me to resolve the test case,involving spaces.....please\\nclass Solution {\\npublic:\\n    string Tocheck(string s){\\n    \\n     int n;\\n     n= s.size();\\n     char ch;\\n     string f =\"\";\\n\\n     for(int i=0; i<n; i++){\\n         ch = s[i];\\nif(ch>=\\'a\\' && ch<=\\'z\\' || ch>=\\'A\\' && ch<=\\'Z\\'|| ch>=\\'0\\'&& ch<=\\'9\\'){\\n    f.push_back(ch);\\n}\\n\\n     }\\n    return f;\\n    }\\n     \\n      string toLowercase(string &s){\\n\\n     for(int j=0; j< s.size();j++){\\n\\n         if(s[j]>=\\'A\\' && s[j]<=\\'Z\\'){\\n          s[j] = s[j] - \\'A\\' + \\'a\\';\\n         }\\n     }\\n     return s;\\n }\\n \\nbool isPalindrome(string s)\\n{\\n    int st=0;\\n    int e= s.size()-1;\\n\\n     Tocheck(s);\\n     toLowercase(s);\\n\\n    while(st<=e){\\n        if(s[st] !=s[e]){\\n           return 0;\\n        }\\n        else {\\n            st++;\\n            e--;\\n        }\\n    }\\n    return  1;\\n}  \\n    };\\n    \\n    "
                    },
                    {
                        "username": "setterwind86",
                        "content": "public static boolean isPalindrome(String s) {\\n\\n        //String sentence = \"A man, a plan, a canal: Panama\";\\n        String editedSentence = \"\";\\n        String palindrome = \"\";\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isAlphabetic(s.charAt(i))) {\\n                editedSentence = editedSentence + s.charAt(i);\\n            }\\n        }\\n        editedSentence = editedSentence.toLowerCase();\\n\\n        for (int i = editedSentence.length() - 1; i >= 0; i--) {\\n            palindrome = palindrome + editedSentence.charAt(i);\\n        }\\n\\n        if (editedSentence == palindrome) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\nThis is my solution and I don\\'t know why I am getting false even though it is a valid palindrome"
                    },
                    {
                        "username": "mayank20patel05",
                        "content": "you are just considering the alphabets, please keep apha-numeric values and remove special charactors for your editedSentence\\n"
                    }
                ]
            },
            {
                "id": 1763859,
                "content": [
                    {
                        "username": "yuvraj_05",
                        "content": "class Solution {\\n    private:\\n    bool valid(char ch){\\n\\n        \\n            if((ch>=\\'a\\' && ch<=\\'z\\')|| (ch>=\\'A\\' && ch<=\\'Z\\') ||(ch>=\\'0\\' && ch<=\\'9\\')){\\n            return 1;\\n            }\\n            \\n                return 0;\\n            \\n        \\n    }\\n    char toLowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\')||(ch>=\\'0\\' && ch<=\\'9\\'))\\n            return ch;\\n    \\n    else{\\n        char temp= ch-\\'A\\'+\\'a\\';\\n        return temp;\\n    }\\n    }\\n    bool checkPalindrome(string a){\\n        int s=0;\\n        int e=a.length()-1;\\n        while(s<=e){\\n            if(a[s]!=a[e]){\\n                return 0;\\n            }\\n            else{\\n                s++;\\n                e--;\\n\\n\\n            }\\n              }\\n             return 1;\\n    }\\n\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp=\" \";\\n\\n        for(int j=0 ; j<s.length() ; j++){\\n            if(valid(s[j])){\\n                temp.push_back(s[j]);\\n            }\\n            \\n        }\\n        \\n    \\n     for(int j=0; j<temp.length(); j++){\\n         temp[j]=toLowerCase(temp[j]);\\n     }\\n     return checkPalindrome(temp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\nWHY  MY TEST CASE1 IS NOT PASSED"
                    },
                    {
                        "username": "Jatin5819",
                        "content": "same here bro, if u get plz let me know.."
                    },
                    {
                        "username": "MIR030",
                        "content": "Easy to understand python code\\n\\ndef isPalindrome(s):\\n    s_parsed = []\\n    for i in range(len(s)):\\n        if s[i].isalnum():\\n            s_parsed.append(s[i])\\n    s_parsed_str = \"\".join(s_parsed)\\n    s_lower = s_parsed_str.lower()\\n    s_reverse = s_lower[::-1]\\n\\n    if s_lower == s_reverse:\\n        return True\\n    return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy to understand rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sakshit7",
                        "content": "I used this loop to convert from UpperCase to LowerCase but it\\'s not working can anyone tell me my fault?? \\n\\n          for(int i=0;i<temp.length();i++){\\n             if(s[i]>=\\'A\\' && s[i]<=\\'Z\\' )\\n\\n       temp[i]=char( tolower ( temp[i]) ) ;\\n         }"
                    },
                    {
                        "username": "xvpome",
                        "content": " The loops works, dunno why it's giving you an error. You just need to say that temp = s. Anyways, instead of that, you could try this: transform(temp.begin(), temp.end(), temp.begin() , ::tolower) <- cleaner looking."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString str = sb.toString();\\n\\t\\tString reverse = sb.reverse().toString();\\n\\t\\tif (str.equals(reverse))\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "perman_1",
                        "content": "use this condition:\\n            `if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))`\\n\\n\\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string s1 = s;\\n        if(s == \"\") return true;\\n        transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\\n        int j = 0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))\\n            {\\n                s1[j] = s1[i];\\n                j++;\\n            }\\n        }\\n        s1 =  s1.substr(0, j);\\n        int len = s1.size();\\n        for(int i=0;i<len/2;i++)\\n        {\\n            if(s1[i] != s1[len-1-i]) return false;\\n        }\\n        return true;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Use this rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kartikaggarwal8520",
                        "content": " `var isPalindrome = function(s) {\\n    let arr = s.match(/\\\\w/g);\\n    let str = arr.join(\\'\\');\\n    let reverse = str.split(\\'\\').reverse().join(\\'\\');\\n    if (str.toLowerCase() === reverse.toLowerCase())\\n        return true\\n    else\\n        return false\\n};`\\n\\nThe above code is running perfectly on VS code editor but giving error when I am trying to run the code here.\\nCan anyone please help me out, what\\'s the issue here..?"
                    },
                    {
                        "username": "sjdba86",
                        "content": "when I compile this code on visual studio it returns true for testcase 94 which is \"a\" but on leetcode it returns false. any idea on what might be the problem here?\\n\\n\\n `using System.Linq;\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n      public static  Queue<string> queue = new Queue<string>();\\n        public static Stack<string> stack = new Stack<string>();\\n \\n         public bool IsPalindrome(string s)\\n        {\\n           // s = string.Concat(s.Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c)));\\n\\n            Regex rgx = new Regex(\"[^a-zA-Z0-9]\");\\n            s = rgx.Replace(s, \" \");\\n\\n            foreach (char item in s)\\n            {\\n                if (s==\" \")\\n                {\\n                    return true;\\n                }\\n                 if(char.IsLetter(item) &&!char.IsPunctuation(item))\\n                {\\n                    queue.Enqueue(char.ToLower(item).ToString());\\n                    stack.Push(char.ToLower(item).ToString());\\n                }\\n              \\n            }\\n     \\n            while (stack.Count >= 0)\\n            {\\n                var s1 = stack.Peek();\\n                var q = queue.Peek();\\n                if (stack.Count != 0 && s1 == q)\\n                {\\n                    stack.Pop();\\n                    queue.Dequeue();\\n                    if (stack.Count == 0)\\n                        return true;\\n                }\\n                else if (s1 != q)\\n                    return false;\\n            }\\n            return false;\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Recursive Solution: \\n\\nclass Solution {\\n\\n    public boolean checkPalindrome(String s, int start, int end){\\n\\n        if(start >= end)\\n           return true;\\n        if(s.charAt(start) != s.charAt(end))\\n           return false;\\n        \\n        return checkPalindrome(s,start+1,end-1);\\n\\n\\n    }\\n    public boolean isPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (!(Character.isLetterOrDigit(ch))) {\\n            continue;\\n            }\\n            sb.append(Character.toLowerCase(ch));\\n        }\\n        System.out.println(sb.toString());\\n        System.out.println(sb.length());\\n    \\n      return checkPalindrome(sb.toString(),0,sb.length()-1);\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You don\\'t need another function. Check my code:\\npublic  boolean palindrome(String s) {\\n        String st = s.toLowerCase().replaceAll(\"\\\\\\\\W\", \"\");\\n        if (st.length() < 2)\\n            return true;\\n\\n        if (st.charAt(0) != st.charAt(st.length()-1))\\n            return false;\\n        \\n        return palindrome(st.substring(1,st.length()-1));\\n    }\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "How to deal with underscores?  o_o"
                    },
                    {
                        "username": "mukadas026",
                        "content": "you have to filter out anything thats not an alphanumeric character(a-z, 0-9), which includes  \"_\", the resulting string should be \"oo\" which is a palindrome"
                    },
                    {
                        "username": "elzazo",
                        "content": "Ignore, just go for letters and digits. Everything else has not to be compared."
                    },
                    {
                        "username": "drshn_h",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int len = s.size(),i=0;\\n        string new_s = \"\";\\n        while(i<len){\\n            if(s[i]>= \\'a\\' && s[i] <= \\'z\\'){\\n                new_s.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'A\\' && s[i]<= \\'Z\\'){\\n                new_s.push_back(s[i]+(\\'a\\'-\\'A\\'));\\n            }\\n            i++;\\n        }\\n        len = new_s.size();\\n        for(i=0;i <len/2; i++ ){\\n            if(new_s[i] != new_s[len-i-1]){\\n            return false;}}\\n        return true;\\n    }\\n};`\\n\\nMy (c++) code will return true for string inputs \"0p\" & \"0Dd\" both of these strings become \"p\" & \"dd\" respectively after removing extra characters and as per definition, both of these strings are palindrome."
                    },
                    {
                        "username": "mukadas026",
                        "content": "you should not remove numbers because they are also alphanumeric(a-z, 0-9). The resulting strings for those ones should be \"0p\" and \"0dd\" which are not palindromes. You can try using a regular expression to match the conditions "
                    }
                ]
            },
            {
                "id": 1760823,
                "content": [
                    {
                        "username": "yuvraj_05",
                        "content": "class Solution {\\n    private:\\n    bool valid(char ch){\\n\\n        \\n            if((ch>=\\'a\\' && ch<=\\'z\\')|| (ch>=\\'A\\' && ch<=\\'Z\\') ||(ch>=\\'0\\' && ch<=\\'9\\')){\\n            return 1;\\n            }\\n            \\n                return 0;\\n            \\n        \\n    }\\n    char toLowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\')||(ch>=\\'0\\' && ch<=\\'9\\'))\\n            return ch;\\n    \\n    else{\\n        char temp= ch-\\'A\\'+\\'a\\';\\n        return temp;\\n    }\\n    }\\n    bool checkPalindrome(string a){\\n        int s=0;\\n        int e=a.length()-1;\\n        while(s<=e){\\n            if(a[s]!=a[e]){\\n                return 0;\\n            }\\n            else{\\n                s++;\\n                e--;\\n\\n\\n            }\\n              }\\n             return 1;\\n    }\\n\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp=\" \";\\n\\n        for(int j=0 ; j<s.length() ; j++){\\n            if(valid(s[j])){\\n                temp.push_back(s[j]);\\n            }\\n            \\n        }\\n        \\n    \\n     for(int j=0; j<temp.length(); j++){\\n         temp[j]=toLowerCase(temp[j]);\\n     }\\n     return checkPalindrome(temp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\nWHY  MY TEST CASE1 IS NOT PASSED"
                    },
                    {
                        "username": "Jatin5819",
                        "content": "same here bro, if u get plz let me know.."
                    },
                    {
                        "username": "MIR030",
                        "content": "Easy to understand python code\\n\\ndef isPalindrome(s):\\n    s_parsed = []\\n    for i in range(len(s)):\\n        if s[i].isalnum():\\n            s_parsed.append(s[i])\\n    s_parsed_str = \"\".join(s_parsed)\\n    s_lower = s_parsed_str.lower()\\n    s_reverse = s_lower[::-1]\\n\\n    if s_lower == s_reverse:\\n        return True\\n    return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy to understand rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sakshit7",
                        "content": "I used this loop to convert from UpperCase to LowerCase but it\\'s not working can anyone tell me my fault?? \\n\\n          for(int i=0;i<temp.length();i++){\\n             if(s[i]>=\\'A\\' && s[i]<=\\'Z\\' )\\n\\n       temp[i]=char( tolower ( temp[i]) ) ;\\n         }"
                    },
                    {
                        "username": "xvpome",
                        "content": " The loops works, dunno why it's giving you an error. You just need to say that temp = s. Anyways, instead of that, you could try this: transform(temp.begin(), temp.end(), temp.begin() , ::tolower) <- cleaner looking."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString str = sb.toString();\\n\\t\\tString reverse = sb.reverse().toString();\\n\\t\\tif (str.equals(reverse))\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "perman_1",
                        "content": "use this condition:\\n            `if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))`\\n\\n\\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string s1 = s;\\n        if(s == \"\") return true;\\n        transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\\n        int j = 0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))\\n            {\\n                s1[j] = s1[i];\\n                j++;\\n            }\\n        }\\n        s1 =  s1.substr(0, j);\\n        int len = s1.size();\\n        for(int i=0;i<len/2;i++)\\n        {\\n            if(s1[i] != s1[len-1-i]) return false;\\n        }\\n        return true;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Use this rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kartikaggarwal8520",
                        "content": " `var isPalindrome = function(s) {\\n    let arr = s.match(/\\\\w/g);\\n    let str = arr.join(\\'\\');\\n    let reverse = str.split(\\'\\').reverse().join(\\'\\');\\n    if (str.toLowerCase() === reverse.toLowerCase())\\n        return true\\n    else\\n        return false\\n};`\\n\\nThe above code is running perfectly on VS code editor but giving error when I am trying to run the code here.\\nCan anyone please help me out, what\\'s the issue here..?"
                    },
                    {
                        "username": "sjdba86",
                        "content": "when I compile this code on visual studio it returns true for testcase 94 which is \"a\" but on leetcode it returns false. any idea on what might be the problem here?\\n\\n\\n `using System.Linq;\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n      public static  Queue<string> queue = new Queue<string>();\\n        public static Stack<string> stack = new Stack<string>();\\n \\n         public bool IsPalindrome(string s)\\n        {\\n           // s = string.Concat(s.Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c)));\\n\\n            Regex rgx = new Regex(\"[^a-zA-Z0-9]\");\\n            s = rgx.Replace(s, \" \");\\n\\n            foreach (char item in s)\\n            {\\n                if (s==\" \")\\n                {\\n                    return true;\\n                }\\n                 if(char.IsLetter(item) &&!char.IsPunctuation(item))\\n                {\\n                    queue.Enqueue(char.ToLower(item).ToString());\\n                    stack.Push(char.ToLower(item).ToString());\\n                }\\n              \\n            }\\n     \\n            while (stack.Count >= 0)\\n            {\\n                var s1 = stack.Peek();\\n                var q = queue.Peek();\\n                if (stack.Count != 0 && s1 == q)\\n                {\\n                    stack.Pop();\\n                    queue.Dequeue();\\n                    if (stack.Count == 0)\\n                        return true;\\n                }\\n                else if (s1 != q)\\n                    return false;\\n            }\\n            return false;\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Recursive Solution: \\n\\nclass Solution {\\n\\n    public boolean checkPalindrome(String s, int start, int end){\\n\\n        if(start >= end)\\n           return true;\\n        if(s.charAt(start) != s.charAt(end))\\n           return false;\\n        \\n        return checkPalindrome(s,start+1,end-1);\\n\\n\\n    }\\n    public boolean isPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (!(Character.isLetterOrDigit(ch))) {\\n            continue;\\n            }\\n            sb.append(Character.toLowerCase(ch));\\n        }\\n        System.out.println(sb.toString());\\n        System.out.println(sb.length());\\n    \\n      return checkPalindrome(sb.toString(),0,sb.length()-1);\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You don\\'t need another function. Check my code:\\npublic  boolean palindrome(String s) {\\n        String st = s.toLowerCase().replaceAll(\"\\\\\\\\W\", \"\");\\n        if (st.length() < 2)\\n            return true;\\n\\n        if (st.charAt(0) != st.charAt(st.length()-1))\\n            return false;\\n        \\n        return palindrome(st.substring(1,st.length()-1));\\n    }\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "How to deal with underscores?  o_o"
                    },
                    {
                        "username": "mukadas026",
                        "content": "you have to filter out anything thats not an alphanumeric character(a-z, 0-9), which includes  \"_\", the resulting string should be \"oo\" which is a palindrome"
                    },
                    {
                        "username": "elzazo",
                        "content": "Ignore, just go for letters and digits. Everything else has not to be compared."
                    },
                    {
                        "username": "drshn_h",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int len = s.size(),i=0;\\n        string new_s = \"\";\\n        while(i<len){\\n            if(s[i]>= \\'a\\' && s[i] <= \\'z\\'){\\n                new_s.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'A\\' && s[i]<= \\'Z\\'){\\n                new_s.push_back(s[i]+(\\'a\\'-\\'A\\'));\\n            }\\n            i++;\\n        }\\n        len = new_s.size();\\n        for(i=0;i <len/2; i++ ){\\n            if(new_s[i] != new_s[len-i-1]){\\n            return false;}}\\n        return true;\\n    }\\n};`\\n\\nMy (c++) code will return true for string inputs \"0p\" & \"0Dd\" both of these strings become \"p\" & \"dd\" respectively after removing extra characters and as per definition, both of these strings are palindrome."
                    },
                    {
                        "username": "mukadas026",
                        "content": "you should not remove numbers because they are also alphanumeric(a-z, 0-9). The resulting strings for those ones should be \"0p\" and \"0dd\" which are not palindromes. You can try using a regular expression to match the conditions "
                    }
                ]
            },
            {
                "id": 1760732,
                "content": [
                    {
                        "username": "yuvraj_05",
                        "content": "class Solution {\\n    private:\\n    bool valid(char ch){\\n\\n        \\n            if((ch>=\\'a\\' && ch<=\\'z\\')|| (ch>=\\'A\\' && ch<=\\'Z\\') ||(ch>=\\'0\\' && ch<=\\'9\\')){\\n            return 1;\\n            }\\n            \\n                return 0;\\n            \\n        \\n    }\\n    char toLowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\')||(ch>=\\'0\\' && ch<=\\'9\\'))\\n            return ch;\\n    \\n    else{\\n        char temp= ch-\\'A\\'+\\'a\\';\\n        return temp;\\n    }\\n    }\\n    bool checkPalindrome(string a){\\n        int s=0;\\n        int e=a.length()-1;\\n        while(s<=e){\\n            if(a[s]!=a[e]){\\n                return 0;\\n            }\\n            else{\\n                s++;\\n                e--;\\n\\n\\n            }\\n              }\\n             return 1;\\n    }\\n\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp=\" \";\\n\\n        for(int j=0 ; j<s.length() ; j++){\\n            if(valid(s[j])){\\n                temp.push_back(s[j]);\\n            }\\n            \\n        }\\n        \\n    \\n     for(int j=0; j<temp.length(); j++){\\n         temp[j]=toLowerCase(temp[j]);\\n     }\\n     return checkPalindrome(temp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\nWHY  MY TEST CASE1 IS NOT PASSED"
                    },
                    {
                        "username": "Jatin5819",
                        "content": "same here bro, if u get plz let me know.."
                    },
                    {
                        "username": "MIR030",
                        "content": "Easy to understand python code\\n\\ndef isPalindrome(s):\\n    s_parsed = []\\n    for i in range(len(s)):\\n        if s[i].isalnum():\\n            s_parsed.append(s[i])\\n    s_parsed_str = \"\".join(s_parsed)\\n    s_lower = s_parsed_str.lower()\\n    s_reverse = s_lower[::-1]\\n\\n    if s_lower == s_reverse:\\n        return True\\n    return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy to understand rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sakshit7",
                        "content": "I used this loop to convert from UpperCase to LowerCase but it\\'s not working can anyone tell me my fault?? \\n\\n          for(int i=0;i<temp.length();i++){\\n             if(s[i]>=\\'A\\' && s[i]<=\\'Z\\' )\\n\\n       temp[i]=char( tolower ( temp[i]) ) ;\\n         }"
                    },
                    {
                        "username": "xvpome",
                        "content": " The loops works, dunno why it's giving you an error. You just need to say that temp = s. Anyways, instead of that, you could try this: transform(temp.begin(), temp.end(), temp.begin() , ::tolower) <- cleaner looking."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString str = sb.toString();\\n\\t\\tString reverse = sb.reverse().toString();\\n\\t\\tif (str.equals(reverse))\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "perman_1",
                        "content": "use this condition:\\n            `if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))`\\n\\n\\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string s1 = s;\\n        if(s == \"\") return true;\\n        transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\\n        int j = 0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))\\n            {\\n                s1[j] = s1[i];\\n                j++;\\n            }\\n        }\\n        s1 =  s1.substr(0, j);\\n        int len = s1.size();\\n        for(int i=0;i<len/2;i++)\\n        {\\n            if(s1[i] != s1[len-1-i]) return false;\\n        }\\n        return true;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Use this rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kartikaggarwal8520",
                        "content": " `var isPalindrome = function(s) {\\n    let arr = s.match(/\\\\w/g);\\n    let str = arr.join(\\'\\');\\n    let reverse = str.split(\\'\\').reverse().join(\\'\\');\\n    if (str.toLowerCase() === reverse.toLowerCase())\\n        return true\\n    else\\n        return false\\n};`\\n\\nThe above code is running perfectly on VS code editor but giving error when I am trying to run the code here.\\nCan anyone please help me out, what\\'s the issue here..?"
                    },
                    {
                        "username": "sjdba86",
                        "content": "when I compile this code on visual studio it returns true for testcase 94 which is \"a\" but on leetcode it returns false. any idea on what might be the problem here?\\n\\n\\n `using System.Linq;\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n      public static  Queue<string> queue = new Queue<string>();\\n        public static Stack<string> stack = new Stack<string>();\\n \\n         public bool IsPalindrome(string s)\\n        {\\n           // s = string.Concat(s.Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c)));\\n\\n            Regex rgx = new Regex(\"[^a-zA-Z0-9]\");\\n            s = rgx.Replace(s, \" \");\\n\\n            foreach (char item in s)\\n            {\\n                if (s==\" \")\\n                {\\n                    return true;\\n                }\\n                 if(char.IsLetter(item) &&!char.IsPunctuation(item))\\n                {\\n                    queue.Enqueue(char.ToLower(item).ToString());\\n                    stack.Push(char.ToLower(item).ToString());\\n                }\\n              \\n            }\\n     \\n            while (stack.Count >= 0)\\n            {\\n                var s1 = stack.Peek();\\n                var q = queue.Peek();\\n                if (stack.Count != 0 && s1 == q)\\n                {\\n                    stack.Pop();\\n                    queue.Dequeue();\\n                    if (stack.Count == 0)\\n                        return true;\\n                }\\n                else if (s1 != q)\\n                    return false;\\n            }\\n            return false;\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Recursive Solution: \\n\\nclass Solution {\\n\\n    public boolean checkPalindrome(String s, int start, int end){\\n\\n        if(start >= end)\\n           return true;\\n        if(s.charAt(start) != s.charAt(end))\\n           return false;\\n        \\n        return checkPalindrome(s,start+1,end-1);\\n\\n\\n    }\\n    public boolean isPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (!(Character.isLetterOrDigit(ch))) {\\n            continue;\\n            }\\n            sb.append(Character.toLowerCase(ch));\\n        }\\n        System.out.println(sb.toString());\\n        System.out.println(sb.length());\\n    \\n      return checkPalindrome(sb.toString(),0,sb.length()-1);\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You don\\'t need another function. Check my code:\\npublic  boolean palindrome(String s) {\\n        String st = s.toLowerCase().replaceAll(\"\\\\\\\\W\", \"\");\\n        if (st.length() < 2)\\n            return true;\\n\\n        if (st.charAt(0) != st.charAt(st.length()-1))\\n            return false;\\n        \\n        return palindrome(st.substring(1,st.length()-1));\\n    }\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "How to deal with underscores?  o_o"
                    },
                    {
                        "username": "mukadas026",
                        "content": "you have to filter out anything thats not an alphanumeric character(a-z, 0-9), which includes  \"_\", the resulting string should be \"oo\" which is a palindrome"
                    },
                    {
                        "username": "elzazo",
                        "content": "Ignore, just go for letters and digits. Everything else has not to be compared."
                    },
                    {
                        "username": "drshn_h",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int len = s.size(),i=0;\\n        string new_s = \"\";\\n        while(i<len){\\n            if(s[i]>= \\'a\\' && s[i] <= \\'z\\'){\\n                new_s.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'A\\' && s[i]<= \\'Z\\'){\\n                new_s.push_back(s[i]+(\\'a\\'-\\'A\\'));\\n            }\\n            i++;\\n        }\\n        len = new_s.size();\\n        for(i=0;i <len/2; i++ ){\\n            if(new_s[i] != new_s[len-i-1]){\\n            return false;}}\\n        return true;\\n    }\\n};`\\n\\nMy (c++) code will return true for string inputs \"0p\" & \"0Dd\" both of these strings become \"p\" & \"dd\" respectively after removing extra characters and as per definition, both of these strings are palindrome."
                    },
                    {
                        "username": "mukadas026",
                        "content": "you should not remove numbers because they are also alphanumeric(a-z, 0-9). The resulting strings for those ones should be \"0p\" and \"0dd\" which are not palindromes. You can try using a regular expression to match the conditions "
                    }
                ]
            },
            {
                "id": 1758914,
                "content": [
                    {
                        "username": "yuvraj_05",
                        "content": "class Solution {\\n    private:\\n    bool valid(char ch){\\n\\n        \\n            if((ch>=\\'a\\' && ch<=\\'z\\')|| (ch>=\\'A\\' && ch<=\\'Z\\') ||(ch>=\\'0\\' && ch<=\\'9\\')){\\n            return 1;\\n            }\\n            \\n                return 0;\\n            \\n        \\n    }\\n    char toLowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\')||(ch>=\\'0\\' && ch<=\\'9\\'))\\n            return ch;\\n    \\n    else{\\n        char temp= ch-\\'A\\'+\\'a\\';\\n        return temp;\\n    }\\n    }\\n    bool checkPalindrome(string a){\\n        int s=0;\\n        int e=a.length()-1;\\n        while(s<=e){\\n            if(a[s]!=a[e]){\\n                return 0;\\n            }\\n            else{\\n                s++;\\n                e--;\\n\\n\\n            }\\n              }\\n             return 1;\\n    }\\n\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp=\" \";\\n\\n        for(int j=0 ; j<s.length() ; j++){\\n            if(valid(s[j])){\\n                temp.push_back(s[j]);\\n            }\\n            \\n        }\\n        \\n    \\n     for(int j=0; j<temp.length(); j++){\\n         temp[j]=toLowerCase(temp[j]);\\n     }\\n     return checkPalindrome(temp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\nWHY  MY TEST CASE1 IS NOT PASSED"
                    },
                    {
                        "username": "Jatin5819",
                        "content": "same here bro, if u get plz let me know.."
                    },
                    {
                        "username": "MIR030",
                        "content": "Easy to understand python code\\n\\ndef isPalindrome(s):\\n    s_parsed = []\\n    for i in range(len(s)):\\n        if s[i].isalnum():\\n            s_parsed.append(s[i])\\n    s_parsed_str = \"\".join(s_parsed)\\n    s_lower = s_parsed_str.lower()\\n    s_reverse = s_lower[::-1]\\n\\n    if s_lower == s_reverse:\\n        return True\\n    return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy to understand rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sakshit7",
                        "content": "I used this loop to convert from UpperCase to LowerCase but it\\'s not working can anyone tell me my fault?? \\n\\n          for(int i=0;i<temp.length();i++){\\n             if(s[i]>=\\'A\\' && s[i]<=\\'Z\\' )\\n\\n       temp[i]=char( tolower ( temp[i]) ) ;\\n         }"
                    },
                    {
                        "username": "xvpome",
                        "content": " The loops works, dunno why it's giving you an error. You just need to say that temp = s. Anyways, instead of that, you could try this: transform(temp.begin(), temp.end(), temp.begin() , ::tolower) <- cleaner looking."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString str = sb.toString();\\n\\t\\tString reverse = sb.reverse().toString();\\n\\t\\tif (str.equals(reverse))\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "perman_1",
                        "content": "use this condition:\\n            `if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))`\\n\\n\\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string s1 = s;\\n        if(s == \"\") return true;\\n        transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\\n        int j = 0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))\\n            {\\n                s1[j] = s1[i];\\n                j++;\\n            }\\n        }\\n        s1 =  s1.substr(0, j);\\n        int len = s1.size();\\n        for(int i=0;i<len/2;i++)\\n        {\\n            if(s1[i] != s1[len-1-i]) return false;\\n        }\\n        return true;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Use this rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kartikaggarwal8520",
                        "content": " `var isPalindrome = function(s) {\\n    let arr = s.match(/\\\\w/g);\\n    let str = arr.join(\\'\\');\\n    let reverse = str.split(\\'\\').reverse().join(\\'\\');\\n    if (str.toLowerCase() === reverse.toLowerCase())\\n        return true\\n    else\\n        return false\\n};`\\n\\nThe above code is running perfectly on VS code editor but giving error when I am trying to run the code here.\\nCan anyone please help me out, what\\'s the issue here..?"
                    },
                    {
                        "username": "sjdba86",
                        "content": "when I compile this code on visual studio it returns true for testcase 94 which is \"a\" but on leetcode it returns false. any idea on what might be the problem here?\\n\\n\\n `using System.Linq;\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n      public static  Queue<string> queue = new Queue<string>();\\n        public static Stack<string> stack = new Stack<string>();\\n \\n         public bool IsPalindrome(string s)\\n        {\\n           // s = string.Concat(s.Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c)));\\n\\n            Regex rgx = new Regex(\"[^a-zA-Z0-9]\");\\n            s = rgx.Replace(s, \" \");\\n\\n            foreach (char item in s)\\n            {\\n                if (s==\" \")\\n                {\\n                    return true;\\n                }\\n                 if(char.IsLetter(item) &&!char.IsPunctuation(item))\\n                {\\n                    queue.Enqueue(char.ToLower(item).ToString());\\n                    stack.Push(char.ToLower(item).ToString());\\n                }\\n              \\n            }\\n     \\n            while (stack.Count >= 0)\\n            {\\n                var s1 = stack.Peek();\\n                var q = queue.Peek();\\n                if (stack.Count != 0 && s1 == q)\\n                {\\n                    stack.Pop();\\n                    queue.Dequeue();\\n                    if (stack.Count == 0)\\n                        return true;\\n                }\\n                else if (s1 != q)\\n                    return false;\\n            }\\n            return false;\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Recursive Solution: \\n\\nclass Solution {\\n\\n    public boolean checkPalindrome(String s, int start, int end){\\n\\n        if(start >= end)\\n           return true;\\n        if(s.charAt(start) != s.charAt(end))\\n           return false;\\n        \\n        return checkPalindrome(s,start+1,end-1);\\n\\n\\n    }\\n    public boolean isPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (!(Character.isLetterOrDigit(ch))) {\\n            continue;\\n            }\\n            sb.append(Character.toLowerCase(ch));\\n        }\\n        System.out.println(sb.toString());\\n        System.out.println(sb.length());\\n    \\n      return checkPalindrome(sb.toString(),0,sb.length()-1);\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You don\\'t need another function. Check my code:\\npublic  boolean palindrome(String s) {\\n        String st = s.toLowerCase().replaceAll(\"\\\\\\\\W\", \"\");\\n        if (st.length() < 2)\\n            return true;\\n\\n        if (st.charAt(0) != st.charAt(st.length()-1))\\n            return false;\\n        \\n        return palindrome(st.substring(1,st.length()-1));\\n    }\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "How to deal with underscores?  o_o"
                    },
                    {
                        "username": "mukadas026",
                        "content": "you have to filter out anything thats not an alphanumeric character(a-z, 0-9), which includes  \"_\", the resulting string should be \"oo\" which is a palindrome"
                    },
                    {
                        "username": "elzazo",
                        "content": "Ignore, just go for letters and digits. Everything else has not to be compared."
                    },
                    {
                        "username": "drshn_h",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int len = s.size(),i=0;\\n        string new_s = \"\";\\n        while(i<len){\\n            if(s[i]>= \\'a\\' && s[i] <= \\'z\\'){\\n                new_s.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'A\\' && s[i]<= \\'Z\\'){\\n                new_s.push_back(s[i]+(\\'a\\'-\\'A\\'));\\n            }\\n            i++;\\n        }\\n        len = new_s.size();\\n        for(i=0;i <len/2; i++ ){\\n            if(new_s[i] != new_s[len-i-1]){\\n            return false;}}\\n        return true;\\n    }\\n};`\\n\\nMy (c++) code will return true for string inputs \"0p\" & \"0Dd\" both of these strings become \"p\" & \"dd\" respectively after removing extra characters and as per definition, both of these strings are palindrome."
                    },
                    {
                        "username": "mukadas026",
                        "content": "you should not remove numbers because they are also alphanumeric(a-z, 0-9). The resulting strings for those ones should be \"0p\" and \"0dd\" which are not palindromes. You can try using a regular expression to match the conditions "
                    }
                ]
            },
            {
                "id": 1753176,
                "content": [
                    {
                        "username": "yuvraj_05",
                        "content": "class Solution {\\n    private:\\n    bool valid(char ch){\\n\\n        \\n            if((ch>=\\'a\\' && ch<=\\'z\\')|| (ch>=\\'A\\' && ch<=\\'Z\\') ||(ch>=\\'0\\' && ch<=\\'9\\')){\\n            return 1;\\n            }\\n            \\n                return 0;\\n            \\n        \\n    }\\n    char toLowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\')||(ch>=\\'0\\' && ch<=\\'9\\'))\\n            return ch;\\n    \\n    else{\\n        char temp= ch-\\'A\\'+\\'a\\';\\n        return temp;\\n    }\\n    }\\n    bool checkPalindrome(string a){\\n        int s=0;\\n        int e=a.length()-1;\\n        while(s<=e){\\n            if(a[s]!=a[e]){\\n                return 0;\\n            }\\n            else{\\n                s++;\\n                e--;\\n\\n\\n            }\\n              }\\n             return 1;\\n    }\\n\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp=\" \";\\n\\n        for(int j=0 ; j<s.length() ; j++){\\n            if(valid(s[j])){\\n                temp.push_back(s[j]);\\n            }\\n            \\n        }\\n        \\n    \\n     for(int j=0; j<temp.length(); j++){\\n         temp[j]=toLowerCase(temp[j]);\\n     }\\n     return checkPalindrome(temp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\nWHY  MY TEST CASE1 IS NOT PASSED"
                    },
                    {
                        "username": "Jatin5819",
                        "content": "same here bro, if u get plz let me know.."
                    },
                    {
                        "username": "MIR030",
                        "content": "Easy to understand python code\\n\\ndef isPalindrome(s):\\n    s_parsed = []\\n    for i in range(len(s)):\\n        if s[i].isalnum():\\n            s_parsed.append(s[i])\\n    s_parsed_str = \"\".join(s_parsed)\\n    s_lower = s_parsed_str.lower()\\n    s_reverse = s_lower[::-1]\\n\\n    if s_lower == s_reverse:\\n        return True\\n    return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy to understand rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sakshit7",
                        "content": "I used this loop to convert from UpperCase to LowerCase but it\\'s not working can anyone tell me my fault?? \\n\\n          for(int i=0;i<temp.length();i++){\\n             if(s[i]>=\\'A\\' && s[i]<=\\'Z\\' )\\n\\n       temp[i]=char( tolower ( temp[i]) ) ;\\n         }"
                    },
                    {
                        "username": "xvpome",
                        "content": " The loops works, dunno why it's giving you an error. You just need to say that temp = s. Anyways, instead of that, you could try this: transform(temp.begin(), temp.end(), temp.begin() , ::tolower) <- cleaner looking."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString str = sb.toString();\\n\\t\\tString reverse = sb.reverse().toString();\\n\\t\\tif (str.equals(reverse))\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "perman_1",
                        "content": "use this condition:\\n            `if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))`\\n\\n\\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string s1 = s;\\n        if(s == \"\") return true;\\n        transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\\n        int j = 0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))\\n            {\\n                s1[j] = s1[i];\\n                j++;\\n            }\\n        }\\n        s1 =  s1.substr(0, j);\\n        int len = s1.size();\\n        for(int i=0;i<len/2;i++)\\n        {\\n            if(s1[i] != s1[len-1-i]) return false;\\n        }\\n        return true;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Use this rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kartikaggarwal8520",
                        "content": " `var isPalindrome = function(s) {\\n    let arr = s.match(/\\\\w/g);\\n    let str = arr.join(\\'\\');\\n    let reverse = str.split(\\'\\').reverse().join(\\'\\');\\n    if (str.toLowerCase() === reverse.toLowerCase())\\n        return true\\n    else\\n        return false\\n};`\\n\\nThe above code is running perfectly on VS code editor but giving error when I am trying to run the code here.\\nCan anyone please help me out, what\\'s the issue here..?"
                    },
                    {
                        "username": "sjdba86",
                        "content": "when I compile this code on visual studio it returns true for testcase 94 which is \"a\" but on leetcode it returns false. any idea on what might be the problem here?\\n\\n\\n `using System.Linq;\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n      public static  Queue<string> queue = new Queue<string>();\\n        public static Stack<string> stack = new Stack<string>();\\n \\n         public bool IsPalindrome(string s)\\n        {\\n           // s = string.Concat(s.Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c)));\\n\\n            Regex rgx = new Regex(\"[^a-zA-Z0-9]\");\\n            s = rgx.Replace(s, \" \");\\n\\n            foreach (char item in s)\\n            {\\n                if (s==\" \")\\n                {\\n                    return true;\\n                }\\n                 if(char.IsLetter(item) &&!char.IsPunctuation(item))\\n                {\\n                    queue.Enqueue(char.ToLower(item).ToString());\\n                    stack.Push(char.ToLower(item).ToString());\\n                }\\n              \\n            }\\n     \\n            while (stack.Count >= 0)\\n            {\\n                var s1 = stack.Peek();\\n                var q = queue.Peek();\\n                if (stack.Count != 0 && s1 == q)\\n                {\\n                    stack.Pop();\\n                    queue.Dequeue();\\n                    if (stack.Count == 0)\\n                        return true;\\n                }\\n                else if (s1 != q)\\n                    return false;\\n            }\\n            return false;\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Recursive Solution: \\n\\nclass Solution {\\n\\n    public boolean checkPalindrome(String s, int start, int end){\\n\\n        if(start >= end)\\n           return true;\\n        if(s.charAt(start) != s.charAt(end))\\n           return false;\\n        \\n        return checkPalindrome(s,start+1,end-1);\\n\\n\\n    }\\n    public boolean isPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (!(Character.isLetterOrDigit(ch))) {\\n            continue;\\n            }\\n            sb.append(Character.toLowerCase(ch));\\n        }\\n        System.out.println(sb.toString());\\n        System.out.println(sb.length());\\n    \\n      return checkPalindrome(sb.toString(),0,sb.length()-1);\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You don\\'t need another function. Check my code:\\npublic  boolean palindrome(String s) {\\n        String st = s.toLowerCase().replaceAll(\"\\\\\\\\W\", \"\");\\n        if (st.length() < 2)\\n            return true;\\n\\n        if (st.charAt(0) != st.charAt(st.length()-1))\\n            return false;\\n        \\n        return palindrome(st.substring(1,st.length()-1));\\n    }\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "How to deal with underscores?  o_o"
                    },
                    {
                        "username": "mukadas026",
                        "content": "you have to filter out anything thats not an alphanumeric character(a-z, 0-9), which includes  \"_\", the resulting string should be \"oo\" which is a palindrome"
                    },
                    {
                        "username": "elzazo",
                        "content": "Ignore, just go for letters and digits. Everything else has not to be compared."
                    },
                    {
                        "username": "drshn_h",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int len = s.size(),i=0;\\n        string new_s = \"\";\\n        while(i<len){\\n            if(s[i]>= \\'a\\' && s[i] <= \\'z\\'){\\n                new_s.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'A\\' && s[i]<= \\'Z\\'){\\n                new_s.push_back(s[i]+(\\'a\\'-\\'A\\'));\\n            }\\n            i++;\\n        }\\n        len = new_s.size();\\n        for(i=0;i <len/2; i++ ){\\n            if(new_s[i] != new_s[len-i-1]){\\n            return false;}}\\n        return true;\\n    }\\n};`\\n\\nMy (c++) code will return true for string inputs \"0p\" & \"0Dd\" both of these strings become \"p\" & \"dd\" respectively after removing extra characters and as per definition, both of these strings are palindrome."
                    },
                    {
                        "username": "mukadas026",
                        "content": "you should not remove numbers because they are also alphanumeric(a-z, 0-9). The resulting strings for those ones should be \"0p\" and \"0dd\" which are not palindromes. You can try using a regular expression to match the conditions "
                    }
                ]
            },
            {
                "id": 1752555,
                "content": [
                    {
                        "username": "yuvraj_05",
                        "content": "class Solution {\\n    private:\\n    bool valid(char ch){\\n\\n        \\n            if((ch>=\\'a\\' && ch<=\\'z\\')|| (ch>=\\'A\\' && ch<=\\'Z\\') ||(ch>=\\'0\\' && ch<=\\'9\\')){\\n            return 1;\\n            }\\n            \\n                return 0;\\n            \\n        \\n    }\\n    char toLowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\')||(ch>=\\'0\\' && ch<=\\'9\\'))\\n            return ch;\\n    \\n    else{\\n        char temp= ch-\\'A\\'+\\'a\\';\\n        return temp;\\n    }\\n    }\\n    bool checkPalindrome(string a){\\n        int s=0;\\n        int e=a.length()-1;\\n        while(s<=e){\\n            if(a[s]!=a[e]){\\n                return 0;\\n            }\\n            else{\\n                s++;\\n                e--;\\n\\n\\n            }\\n              }\\n             return 1;\\n    }\\n\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp=\" \";\\n\\n        for(int j=0 ; j<s.length() ; j++){\\n            if(valid(s[j])){\\n                temp.push_back(s[j]);\\n            }\\n            \\n        }\\n        \\n    \\n     for(int j=0; j<temp.length(); j++){\\n         temp[j]=toLowerCase(temp[j]);\\n     }\\n     return checkPalindrome(temp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\nWHY  MY TEST CASE1 IS NOT PASSED"
                    },
                    {
                        "username": "Jatin5819",
                        "content": "same here bro, if u get plz let me know.."
                    },
                    {
                        "username": "MIR030",
                        "content": "Easy to understand python code\\n\\ndef isPalindrome(s):\\n    s_parsed = []\\n    for i in range(len(s)):\\n        if s[i].isalnum():\\n            s_parsed.append(s[i])\\n    s_parsed_str = \"\".join(s_parsed)\\n    s_lower = s_parsed_str.lower()\\n    s_reverse = s_lower[::-1]\\n\\n    if s_lower == s_reverse:\\n        return True\\n    return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy to understand rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sakshit7",
                        "content": "I used this loop to convert from UpperCase to LowerCase but it\\'s not working can anyone tell me my fault?? \\n\\n          for(int i=0;i<temp.length();i++){\\n             if(s[i]>=\\'A\\' && s[i]<=\\'Z\\' )\\n\\n       temp[i]=char( tolower ( temp[i]) ) ;\\n         }"
                    },
                    {
                        "username": "xvpome",
                        "content": " The loops works, dunno why it's giving you an error. You just need to say that temp = s. Anyways, instead of that, you could try this: transform(temp.begin(), temp.end(), temp.begin() , ::tolower) <- cleaner looking."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString str = sb.toString();\\n\\t\\tString reverse = sb.reverse().toString();\\n\\t\\tif (str.equals(reverse))\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "perman_1",
                        "content": "use this condition:\\n            `if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))`\\n\\n\\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string s1 = s;\\n        if(s == \"\") return true;\\n        transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\\n        int j = 0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))\\n            {\\n                s1[j] = s1[i];\\n                j++;\\n            }\\n        }\\n        s1 =  s1.substr(0, j);\\n        int len = s1.size();\\n        for(int i=0;i<len/2;i++)\\n        {\\n            if(s1[i] != s1[len-1-i]) return false;\\n        }\\n        return true;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Use this rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kartikaggarwal8520",
                        "content": " `var isPalindrome = function(s) {\\n    let arr = s.match(/\\\\w/g);\\n    let str = arr.join(\\'\\');\\n    let reverse = str.split(\\'\\').reverse().join(\\'\\');\\n    if (str.toLowerCase() === reverse.toLowerCase())\\n        return true\\n    else\\n        return false\\n};`\\n\\nThe above code is running perfectly on VS code editor but giving error when I am trying to run the code here.\\nCan anyone please help me out, what\\'s the issue here..?"
                    },
                    {
                        "username": "sjdba86",
                        "content": "when I compile this code on visual studio it returns true for testcase 94 which is \"a\" but on leetcode it returns false. any idea on what might be the problem here?\\n\\n\\n `using System.Linq;\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n      public static  Queue<string> queue = new Queue<string>();\\n        public static Stack<string> stack = new Stack<string>();\\n \\n         public bool IsPalindrome(string s)\\n        {\\n           // s = string.Concat(s.Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c)));\\n\\n            Regex rgx = new Regex(\"[^a-zA-Z0-9]\");\\n            s = rgx.Replace(s, \" \");\\n\\n            foreach (char item in s)\\n            {\\n                if (s==\" \")\\n                {\\n                    return true;\\n                }\\n                 if(char.IsLetter(item) &&!char.IsPunctuation(item))\\n                {\\n                    queue.Enqueue(char.ToLower(item).ToString());\\n                    stack.Push(char.ToLower(item).ToString());\\n                }\\n              \\n            }\\n     \\n            while (stack.Count >= 0)\\n            {\\n                var s1 = stack.Peek();\\n                var q = queue.Peek();\\n                if (stack.Count != 0 && s1 == q)\\n                {\\n                    stack.Pop();\\n                    queue.Dequeue();\\n                    if (stack.Count == 0)\\n                        return true;\\n                }\\n                else if (s1 != q)\\n                    return false;\\n            }\\n            return false;\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Recursive Solution: \\n\\nclass Solution {\\n\\n    public boolean checkPalindrome(String s, int start, int end){\\n\\n        if(start >= end)\\n           return true;\\n        if(s.charAt(start) != s.charAt(end))\\n           return false;\\n        \\n        return checkPalindrome(s,start+1,end-1);\\n\\n\\n    }\\n    public boolean isPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (!(Character.isLetterOrDigit(ch))) {\\n            continue;\\n            }\\n            sb.append(Character.toLowerCase(ch));\\n        }\\n        System.out.println(sb.toString());\\n        System.out.println(sb.length());\\n    \\n      return checkPalindrome(sb.toString(),0,sb.length()-1);\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You don\\'t need another function. Check my code:\\npublic  boolean palindrome(String s) {\\n        String st = s.toLowerCase().replaceAll(\"\\\\\\\\W\", \"\");\\n        if (st.length() < 2)\\n            return true;\\n\\n        if (st.charAt(0) != st.charAt(st.length()-1))\\n            return false;\\n        \\n        return palindrome(st.substring(1,st.length()-1));\\n    }\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "How to deal with underscores?  o_o"
                    },
                    {
                        "username": "mukadas026",
                        "content": "you have to filter out anything thats not an alphanumeric character(a-z, 0-9), which includes  \"_\", the resulting string should be \"oo\" which is a palindrome"
                    },
                    {
                        "username": "elzazo",
                        "content": "Ignore, just go for letters and digits. Everything else has not to be compared."
                    },
                    {
                        "username": "drshn_h",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int len = s.size(),i=0;\\n        string new_s = \"\";\\n        while(i<len){\\n            if(s[i]>= \\'a\\' && s[i] <= \\'z\\'){\\n                new_s.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'A\\' && s[i]<= \\'Z\\'){\\n                new_s.push_back(s[i]+(\\'a\\'-\\'A\\'));\\n            }\\n            i++;\\n        }\\n        len = new_s.size();\\n        for(i=0;i <len/2; i++ ){\\n            if(new_s[i] != new_s[len-i-1]){\\n            return false;}}\\n        return true;\\n    }\\n};`\\n\\nMy (c++) code will return true for string inputs \"0p\" & \"0Dd\" both of these strings become \"p\" & \"dd\" respectively after removing extra characters and as per definition, both of these strings are palindrome."
                    },
                    {
                        "username": "mukadas026",
                        "content": "you should not remove numbers because they are also alphanumeric(a-z, 0-9). The resulting strings for those ones should be \"0p\" and \"0dd\" which are not palindromes. You can try using a regular expression to match the conditions "
                    }
                ]
            },
            {
                "id": 1751435,
                "content": [
                    {
                        "username": "yuvraj_05",
                        "content": "class Solution {\\n    private:\\n    bool valid(char ch){\\n\\n        \\n            if((ch>=\\'a\\' && ch<=\\'z\\')|| (ch>=\\'A\\' && ch<=\\'Z\\') ||(ch>=\\'0\\' && ch<=\\'9\\')){\\n            return 1;\\n            }\\n            \\n                return 0;\\n            \\n        \\n    }\\n    char toLowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\')||(ch>=\\'0\\' && ch<=\\'9\\'))\\n            return ch;\\n    \\n    else{\\n        char temp= ch-\\'A\\'+\\'a\\';\\n        return temp;\\n    }\\n    }\\n    bool checkPalindrome(string a){\\n        int s=0;\\n        int e=a.length()-1;\\n        while(s<=e){\\n            if(a[s]!=a[e]){\\n                return 0;\\n            }\\n            else{\\n                s++;\\n                e--;\\n\\n\\n            }\\n              }\\n             return 1;\\n    }\\n\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp=\" \";\\n\\n        for(int j=0 ; j<s.length() ; j++){\\n            if(valid(s[j])){\\n                temp.push_back(s[j]);\\n            }\\n            \\n        }\\n        \\n    \\n     for(int j=0; j<temp.length(); j++){\\n         temp[j]=toLowerCase(temp[j]);\\n     }\\n     return checkPalindrome(temp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\nWHY  MY TEST CASE1 IS NOT PASSED"
                    },
                    {
                        "username": "Jatin5819",
                        "content": "same here bro, if u get plz let me know.."
                    },
                    {
                        "username": "MIR030",
                        "content": "Easy to understand python code\\n\\ndef isPalindrome(s):\\n    s_parsed = []\\n    for i in range(len(s)):\\n        if s[i].isalnum():\\n            s_parsed.append(s[i])\\n    s_parsed_str = \"\".join(s_parsed)\\n    s_lower = s_parsed_str.lower()\\n    s_reverse = s_lower[::-1]\\n\\n    if s_lower == s_reverse:\\n        return True\\n    return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy to understand rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sakshit7",
                        "content": "I used this loop to convert from UpperCase to LowerCase but it\\'s not working can anyone tell me my fault?? \\n\\n          for(int i=0;i<temp.length();i++){\\n             if(s[i]>=\\'A\\' && s[i]<=\\'Z\\' )\\n\\n       temp[i]=char( tolower ( temp[i]) ) ;\\n         }"
                    },
                    {
                        "username": "xvpome",
                        "content": " The loops works, dunno why it's giving you an error. You just need to say that temp = s. Anyways, instead of that, you could try this: transform(temp.begin(), temp.end(), temp.begin() , ::tolower) <- cleaner looking."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString str = sb.toString();\\n\\t\\tString reverse = sb.reverse().toString();\\n\\t\\tif (str.equals(reverse))\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "perman_1",
                        "content": "use this condition:\\n            `if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))`\\n\\n\\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string s1 = s;\\n        if(s == \"\") return true;\\n        transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\\n        int j = 0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))\\n            {\\n                s1[j] = s1[i];\\n                j++;\\n            }\\n        }\\n        s1 =  s1.substr(0, j);\\n        int len = s1.size();\\n        for(int i=0;i<len/2;i++)\\n        {\\n            if(s1[i] != s1[len-1-i]) return false;\\n        }\\n        return true;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Use this rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kartikaggarwal8520",
                        "content": " `var isPalindrome = function(s) {\\n    let arr = s.match(/\\\\w/g);\\n    let str = arr.join(\\'\\');\\n    let reverse = str.split(\\'\\').reverse().join(\\'\\');\\n    if (str.toLowerCase() === reverse.toLowerCase())\\n        return true\\n    else\\n        return false\\n};`\\n\\nThe above code is running perfectly on VS code editor but giving error when I am trying to run the code here.\\nCan anyone please help me out, what\\'s the issue here..?"
                    },
                    {
                        "username": "sjdba86",
                        "content": "when I compile this code on visual studio it returns true for testcase 94 which is \"a\" but on leetcode it returns false. any idea on what might be the problem here?\\n\\n\\n `using System.Linq;\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n      public static  Queue<string> queue = new Queue<string>();\\n        public static Stack<string> stack = new Stack<string>();\\n \\n         public bool IsPalindrome(string s)\\n        {\\n           // s = string.Concat(s.Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c)));\\n\\n            Regex rgx = new Regex(\"[^a-zA-Z0-9]\");\\n            s = rgx.Replace(s, \" \");\\n\\n            foreach (char item in s)\\n            {\\n                if (s==\" \")\\n                {\\n                    return true;\\n                }\\n                 if(char.IsLetter(item) &&!char.IsPunctuation(item))\\n                {\\n                    queue.Enqueue(char.ToLower(item).ToString());\\n                    stack.Push(char.ToLower(item).ToString());\\n                }\\n              \\n            }\\n     \\n            while (stack.Count >= 0)\\n            {\\n                var s1 = stack.Peek();\\n                var q = queue.Peek();\\n                if (stack.Count != 0 && s1 == q)\\n                {\\n                    stack.Pop();\\n                    queue.Dequeue();\\n                    if (stack.Count == 0)\\n                        return true;\\n                }\\n                else if (s1 != q)\\n                    return false;\\n            }\\n            return false;\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Recursive Solution: \\n\\nclass Solution {\\n\\n    public boolean checkPalindrome(String s, int start, int end){\\n\\n        if(start >= end)\\n           return true;\\n        if(s.charAt(start) != s.charAt(end))\\n           return false;\\n        \\n        return checkPalindrome(s,start+1,end-1);\\n\\n\\n    }\\n    public boolean isPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (!(Character.isLetterOrDigit(ch))) {\\n            continue;\\n            }\\n            sb.append(Character.toLowerCase(ch));\\n        }\\n        System.out.println(sb.toString());\\n        System.out.println(sb.length());\\n    \\n      return checkPalindrome(sb.toString(),0,sb.length()-1);\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You don\\'t need another function. Check my code:\\npublic  boolean palindrome(String s) {\\n        String st = s.toLowerCase().replaceAll(\"\\\\\\\\W\", \"\");\\n        if (st.length() < 2)\\n            return true;\\n\\n        if (st.charAt(0) != st.charAt(st.length()-1))\\n            return false;\\n        \\n        return palindrome(st.substring(1,st.length()-1));\\n    }\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "How to deal with underscores?  o_o"
                    },
                    {
                        "username": "mukadas026",
                        "content": "you have to filter out anything thats not an alphanumeric character(a-z, 0-9), which includes  \"_\", the resulting string should be \"oo\" which is a palindrome"
                    },
                    {
                        "username": "elzazo",
                        "content": "Ignore, just go for letters and digits. Everything else has not to be compared."
                    },
                    {
                        "username": "drshn_h",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int len = s.size(),i=0;\\n        string new_s = \"\";\\n        while(i<len){\\n            if(s[i]>= \\'a\\' && s[i] <= \\'z\\'){\\n                new_s.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'A\\' && s[i]<= \\'Z\\'){\\n                new_s.push_back(s[i]+(\\'a\\'-\\'A\\'));\\n            }\\n            i++;\\n        }\\n        len = new_s.size();\\n        for(i=0;i <len/2; i++ ){\\n            if(new_s[i] != new_s[len-i-1]){\\n            return false;}}\\n        return true;\\n    }\\n};`\\n\\nMy (c++) code will return true for string inputs \"0p\" & \"0Dd\" both of these strings become \"p\" & \"dd\" respectively after removing extra characters and as per definition, both of these strings are palindrome."
                    },
                    {
                        "username": "mukadas026",
                        "content": "you should not remove numbers because they are also alphanumeric(a-z, 0-9). The resulting strings for those ones should be \"0p\" and \"0dd\" which are not palindromes. You can try using a regular expression to match the conditions "
                    }
                ]
            },
            {
                "id": 1742100,
                "content": [
                    {
                        "username": "yuvraj_05",
                        "content": "class Solution {\\n    private:\\n    bool valid(char ch){\\n\\n        \\n            if((ch>=\\'a\\' && ch<=\\'z\\')|| (ch>=\\'A\\' && ch<=\\'Z\\') ||(ch>=\\'0\\' && ch<=\\'9\\')){\\n            return 1;\\n            }\\n            \\n                return 0;\\n            \\n        \\n    }\\n    char toLowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\')||(ch>=\\'0\\' && ch<=\\'9\\'))\\n            return ch;\\n    \\n    else{\\n        char temp= ch-\\'A\\'+\\'a\\';\\n        return temp;\\n    }\\n    }\\n    bool checkPalindrome(string a){\\n        int s=0;\\n        int e=a.length()-1;\\n        while(s<=e){\\n            if(a[s]!=a[e]){\\n                return 0;\\n            }\\n            else{\\n                s++;\\n                e--;\\n\\n\\n            }\\n              }\\n             return 1;\\n    }\\n\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp=\" \";\\n\\n        for(int j=0 ; j<s.length() ; j++){\\n            if(valid(s[j])){\\n                temp.push_back(s[j]);\\n            }\\n            \\n        }\\n        \\n    \\n     for(int j=0; j<temp.length(); j++){\\n         temp[j]=toLowerCase(temp[j]);\\n     }\\n     return checkPalindrome(temp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\nWHY  MY TEST CASE1 IS NOT PASSED"
                    },
                    {
                        "username": "Jatin5819",
                        "content": "same here bro, if u get plz let me know.."
                    },
                    {
                        "username": "MIR030",
                        "content": "Easy to understand python code\\n\\ndef isPalindrome(s):\\n    s_parsed = []\\n    for i in range(len(s)):\\n        if s[i].isalnum():\\n            s_parsed.append(s[i])\\n    s_parsed_str = \"\".join(s_parsed)\\n    s_lower = s_parsed_str.lower()\\n    s_reverse = s_lower[::-1]\\n\\n    if s_lower == s_reverse:\\n        return True\\n    return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy to understand rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sakshit7",
                        "content": "I used this loop to convert from UpperCase to LowerCase but it\\'s not working can anyone tell me my fault?? \\n\\n          for(int i=0;i<temp.length();i++){\\n             if(s[i]>=\\'A\\' && s[i]<=\\'Z\\' )\\n\\n       temp[i]=char( tolower ( temp[i]) ) ;\\n         }"
                    },
                    {
                        "username": "xvpome",
                        "content": " The loops works, dunno why it's giving you an error. You just need to say that temp = s. Anyways, instead of that, you could try this: transform(temp.begin(), temp.end(), temp.begin() , ::tolower) <- cleaner looking."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString str = sb.toString();\\n\\t\\tString reverse = sb.reverse().toString();\\n\\t\\tif (str.equals(reverse))\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "perman_1",
                        "content": "use this condition:\\n            `if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))`\\n\\n\\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string s1 = s;\\n        if(s == \"\") return true;\\n        transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\\n        int j = 0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))\\n            {\\n                s1[j] = s1[i];\\n                j++;\\n            }\\n        }\\n        s1 =  s1.substr(0, j);\\n        int len = s1.size();\\n        for(int i=0;i<len/2;i++)\\n        {\\n            if(s1[i] != s1[len-1-i]) return false;\\n        }\\n        return true;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Use this rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kartikaggarwal8520",
                        "content": " `var isPalindrome = function(s) {\\n    let arr = s.match(/\\\\w/g);\\n    let str = arr.join(\\'\\');\\n    let reverse = str.split(\\'\\').reverse().join(\\'\\');\\n    if (str.toLowerCase() === reverse.toLowerCase())\\n        return true\\n    else\\n        return false\\n};`\\n\\nThe above code is running perfectly on VS code editor but giving error when I am trying to run the code here.\\nCan anyone please help me out, what\\'s the issue here..?"
                    },
                    {
                        "username": "sjdba86",
                        "content": "when I compile this code on visual studio it returns true for testcase 94 which is \"a\" but on leetcode it returns false. any idea on what might be the problem here?\\n\\n\\n `using System.Linq;\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n      public static  Queue<string> queue = new Queue<string>();\\n        public static Stack<string> stack = new Stack<string>();\\n \\n         public bool IsPalindrome(string s)\\n        {\\n           // s = string.Concat(s.Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c)));\\n\\n            Regex rgx = new Regex(\"[^a-zA-Z0-9]\");\\n            s = rgx.Replace(s, \" \");\\n\\n            foreach (char item in s)\\n            {\\n                if (s==\" \")\\n                {\\n                    return true;\\n                }\\n                 if(char.IsLetter(item) &&!char.IsPunctuation(item))\\n                {\\n                    queue.Enqueue(char.ToLower(item).ToString());\\n                    stack.Push(char.ToLower(item).ToString());\\n                }\\n              \\n            }\\n     \\n            while (stack.Count >= 0)\\n            {\\n                var s1 = stack.Peek();\\n                var q = queue.Peek();\\n                if (stack.Count != 0 && s1 == q)\\n                {\\n                    stack.Pop();\\n                    queue.Dequeue();\\n                    if (stack.Count == 0)\\n                        return true;\\n                }\\n                else if (s1 != q)\\n                    return false;\\n            }\\n            return false;\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Recursive Solution: \\n\\nclass Solution {\\n\\n    public boolean checkPalindrome(String s, int start, int end){\\n\\n        if(start >= end)\\n           return true;\\n        if(s.charAt(start) != s.charAt(end))\\n           return false;\\n        \\n        return checkPalindrome(s,start+1,end-1);\\n\\n\\n    }\\n    public boolean isPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (!(Character.isLetterOrDigit(ch))) {\\n            continue;\\n            }\\n            sb.append(Character.toLowerCase(ch));\\n        }\\n        System.out.println(sb.toString());\\n        System.out.println(sb.length());\\n    \\n      return checkPalindrome(sb.toString(),0,sb.length()-1);\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You don\\'t need another function. Check my code:\\npublic  boolean palindrome(String s) {\\n        String st = s.toLowerCase().replaceAll(\"\\\\\\\\W\", \"\");\\n        if (st.length() < 2)\\n            return true;\\n\\n        if (st.charAt(0) != st.charAt(st.length()-1))\\n            return false;\\n        \\n        return palindrome(st.substring(1,st.length()-1));\\n    }\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "How to deal with underscores?  o_o"
                    },
                    {
                        "username": "mukadas026",
                        "content": "you have to filter out anything thats not an alphanumeric character(a-z, 0-9), which includes  \"_\", the resulting string should be \"oo\" which is a palindrome"
                    },
                    {
                        "username": "elzazo",
                        "content": "Ignore, just go for letters and digits. Everything else has not to be compared."
                    },
                    {
                        "username": "drshn_h",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int len = s.size(),i=0;\\n        string new_s = \"\";\\n        while(i<len){\\n            if(s[i]>= \\'a\\' && s[i] <= \\'z\\'){\\n                new_s.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'A\\' && s[i]<= \\'Z\\'){\\n                new_s.push_back(s[i]+(\\'a\\'-\\'A\\'));\\n            }\\n            i++;\\n        }\\n        len = new_s.size();\\n        for(i=0;i <len/2; i++ ){\\n            if(new_s[i] != new_s[len-i-1]){\\n            return false;}}\\n        return true;\\n    }\\n};`\\n\\nMy (c++) code will return true for string inputs \"0p\" & \"0Dd\" both of these strings become \"p\" & \"dd\" respectively after removing extra characters and as per definition, both of these strings are palindrome."
                    },
                    {
                        "username": "mukadas026",
                        "content": "you should not remove numbers because they are also alphanumeric(a-z, 0-9). The resulting strings for those ones should be \"0p\" and \"0dd\" which are not palindromes. You can try using a regular expression to match the conditions "
                    }
                ]
            },
            {
                "id": 1735904,
                "content": [
                    {
                        "username": "yuvraj_05",
                        "content": "class Solution {\\n    private:\\n    bool valid(char ch){\\n\\n        \\n            if((ch>=\\'a\\' && ch<=\\'z\\')|| (ch>=\\'A\\' && ch<=\\'Z\\') ||(ch>=\\'0\\' && ch<=\\'9\\')){\\n            return 1;\\n            }\\n            \\n                return 0;\\n            \\n        \\n    }\\n    char toLowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\')||(ch>=\\'0\\' && ch<=\\'9\\'))\\n            return ch;\\n    \\n    else{\\n        char temp= ch-\\'A\\'+\\'a\\';\\n        return temp;\\n    }\\n    }\\n    bool checkPalindrome(string a){\\n        int s=0;\\n        int e=a.length()-1;\\n        while(s<=e){\\n            if(a[s]!=a[e]){\\n                return 0;\\n            }\\n            else{\\n                s++;\\n                e--;\\n\\n\\n            }\\n              }\\n             return 1;\\n    }\\n\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp=\" \";\\n\\n        for(int j=0 ; j<s.length() ; j++){\\n            if(valid(s[j])){\\n                temp.push_back(s[j]);\\n            }\\n            \\n        }\\n        \\n    \\n     for(int j=0; j<temp.length(); j++){\\n         temp[j]=toLowerCase(temp[j]);\\n     }\\n     return checkPalindrome(temp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\nWHY  MY TEST CASE1 IS NOT PASSED"
                    },
                    {
                        "username": "Jatin5819",
                        "content": "same here bro, if u get plz let me know.."
                    },
                    {
                        "username": "MIR030",
                        "content": "Easy to understand python code\\n\\ndef isPalindrome(s):\\n    s_parsed = []\\n    for i in range(len(s)):\\n        if s[i].isalnum():\\n            s_parsed.append(s[i])\\n    s_parsed_str = \"\".join(s_parsed)\\n    s_lower = s_parsed_str.lower()\\n    s_reverse = s_lower[::-1]\\n\\n    if s_lower == s_reverse:\\n        return True\\n    return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy to understand rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sakshit7",
                        "content": "I used this loop to convert from UpperCase to LowerCase but it\\'s not working can anyone tell me my fault?? \\n\\n          for(int i=0;i<temp.length();i++){\\n             if(s[i]>=\\'A\\' && s[i]<=\\'Z\\' )\\n\\n       temp[i]=char( tolower ( temp[i]) ) ;\\n         }"
                    },
                    {
                        "username": "xvpome",
                        "content": " The loops works, dunno why it's giving you an error. You just need to say that temp = s. Anyways, instead of that, you could try this: transform(temp.begin(), temp.end(), temp.begin() , ::tolower) <- cleaner looking."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString str = sb.toString();\\n\\t\\tString reverse = sb.reverse().toString();\\n\\t\\tif (str.equals(reverse))\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "perman_1",
                        "content": "use this condition:\\n            `if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))`\\n\\n\\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string s1 = s;\\n        if(s == \"\") return true;\\n        transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\\n        int j = 0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))\\n            {\\n                s1[j] = s1[i];\\n                j++;\\n            }\\n        }\\n        s1 =  s1.substr(0, j);\\n        int len = s1.size();\\n        for(int i=0;i<len/2;i++)\\n        {\\n            if(s1[i] != s1[len-1-i]) return false;\\n        }\\n        return true;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Use this rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kartikaggarwal8520",
                        "content": " `var isPalindrome = function(s) {\\n    let arr = s.match(/\\\\w/g);\\n    let str = arr.join(\\'\\');\\n    let reverse = str.split(\\'\\').reverse().join(\\'\\');\\n    if (str.toLowerCase() === reverse.toLowerCase())\\n        return true\\n    else\\n        return false\\n};`\\n\\nThe above code is running perfectly on VS code editor but giving error when I am trying to run the code here.\\nCan anyone please help me out, what\\'s the issue here..?"
                    },
                    {
                        "username": "sjdba86",
                        "content": "when I compile this code on visual studio it returns true for testcase 94 which is \"a\" but on leetcode it returns false. any idea on what might be the problem here?\\n\\n\\n `using System.Linq;\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n      public static  Queue<string> queue = new Queue<string>();\\n        public static Stack<string> stack = new Stack<string>();\\n \\n         public bool IsPalindrome(string s)\\n        {\\n           // s = string.Concat(s.Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c)));\\n\\n            Regex rgx = new Regex(\"[^a-zA-Z0-9]\");\\n            s = rgx.Replace(s, \" \");\\n\\n            foreach (char item in s)\\n            {\\n                if (s==\" \")\\n                {\\n                    return true;\\n                }\\n                 if(char.IsLetter(item) &&!char.IsPunctuation(item))\\n                {\\n                    queue.Enqueue(char.ToLower(item).ToString());\\n                    stack.Push(char.ToLower(item).ToString());\\n                }\\n              \\n            }\\n     \\n            while (stack.Count >= 0)\\n            {\\n                var s1 = stack.Peek();\\n                var q = queue.Peek();\\n                if (stack.Count != 0 && s1 == q)\\n                {\\n                    stack.Pop();\\n                    queue.Dequeue();\\n                    if (stack.Count == 0)\\n                        return true;\\n                }\\n                else if (s1 != q)\\n                    return false;\\n            }\\n            return false;\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Recursive Solution: \\n\\nclass Solution {\\n\\n    public boolean checkPalindrome(String s, int start, int end){\\n\\n        if(start >= end)\\n           return true;\\n        if(s.charAt(start) != s.charAt(end))\\n           return false;\\n        \\n        return checkPalindrome(s,start+1,end-1);\\n\\n\\n    }\\n    public boolean isPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (!(Character.isLetterOrDigit(ch))) {\\n            continue;\\n            }\\n            sb.append(Character.toLowerCase(ch));\\n        }\\n        System.out.println(sb.toString());\\n        System.out.println(sb.length());\\n    \\n      return checkPalindrome(sb.toString(),0,sb.length()-1);\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You don\\'t need another function. Check my code:\\npublic  boolean palindrome(String s) {\\n        String st = s.toLowerCase().replaceAll(\"\\\\\\\\W\", \"\");\\n        if (st.length() < 2)\\n            return true;\\n\\n        if (st.charAt(0) != st.charAt(st.length()-1))\\n            return false;\\n        \\n        return palindrome(st.substring(1,st.length()-1));\\n    }\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "How to deal with underscores?  o_o"
                    },
                    {
                        "username": "mukadas026",
                        "content": "you have to filter out anything thats not an alphanumeric character(a-z, 0-9), which includes  \"_\", the resulting string should be \"oo\" which is a palindrome"
                    },
                    {
                        "username": "elzazo",
                        "content": "Ignore, just go for letters and digits. Everything else has not to be compared."
                    },
                    {
                        "username": "drshn_h",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int len = s.size(),i=0;\\n        string new_s = \"\";\\n        while(i<len){\\n            if(s[i]>= \\'a\\' && s[i] <= \\'z\\'){\\n                new_s.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'A\\' && s[i]<= \\'Z\\'){\\n                new_s.push_back(s[i]+(\\'a\\'-\\'A\\'));\\n            }\\n            i++;\\n        }\\n        len = new_s.size();\\n        for(i=0;i <len/2; i++ ){\\n            if(new_s[i] != new_s[len-i-1]){\\n            return false;}}\\n        return true;\\n    }\\n};`\\n\\nMy (c++) code will return true for string inputs \"0p\" & \"0Dd\" both of these strings become \"p\" & \"dd\" respectively after removing extra characters and as per definition, both of these strings are palindrome."
                    },
                    {
                        "username": "mukadas026",
                        "content": "you should not remove numbers because they are also alphanumeric(a-z, 0-9). The resulting strings for those ones should be \"0p\" and \"0dd\" which are not palindromes. You can try using a regular expression to match the conditions "
                    }
                ]
            },
            {
                "id": 1734221,
                "content": [
                    {
                        "username": "yuvraj_05",
                        "content": "class Solution {\\n    private:\\n    bool valid(char ch){\\n\\n        \\n            if((ch>=\\'a\\' && ch<=\\'z\\')|| (ch>=\\'A\\' && ch<=\\'Z\\') ||(ch>=\\'0\\' && ch<=\\'9\\')){\\n            return 1;\\n            }\\n            \\n                return 0;\\n            \\n        \\n    }\\n    char toLowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\')||(ch>=\\'0\\' && ch<=\\'9\\'))\\n            return ch;\\n    \\n    else{\\n        char temp= ch-\\'A\\'+\\'a\\';\\n        return temp;\\n    }\\n    }\\n    bool checkPalindrome(string a){\\n        int s=0;\\n        int e=a.length()-1;\\n        while(s<=e){\\n            if(a[s]!=a[e]){\\n                return 0;\\n            }\\n            else{\\n                s++;\\n                e--;\\n\\n\\n            }\\n              }\\n             return 1;\\n    }\\n\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp=\" \";\\n\\n        for(int j=0 ; j<s.length() ; j++){\\n            if(valid(s[j])){\\n                temp.push_back(s[j]);\\n            }\\n            \\n        }\\n        \\n    \\n     for(int j=0; j<temp.length(); j++){\\n         temp[j]=toLowerCase(temp[j]);\\n     }\\n     return checkPalindrome(temp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\nWHY  MY TEST CASE1 IS NOT PASSED"
                    },
                    {
                        "username": "Jatin5819",
                        "content": "same here bro, if u get plz let me know.."
                    },
                    {
                        "username": "MIR030",
                        "content": "Easy to understand python code\\n\\ndef isPalindrome(s):\\n    s_parsed = []\\n    for i in range(len(s)):\\n        if s[i].isalnum():\\n            s_parsed.append(s[i])\\n    s_parsed_str = \"\".join(s_parsed)\\n    s_lower = s_parsed_str.lower()\\n    s_reverse = s_lower[::-1]\\n\\n    if s_lower == s_reverse:\\n        return True\\n    return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy to understand rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sakshit7",
                        "content": "I used this loop to convert from UpperCase to LowerCase but it\\'s not working can anyone tell me my fault?? \\n\\n          for(int i=0;i<temp.length();i++){\\n             if(s[i]>=\\'A\\' && s[i]<=\\'Z\\' )\\n\\n       temp[i]=char( tolower ( temp[i]) ) ;\\n         }"
                    },
                    {
                        "username": "xvpome",
                        "content": " The loops works, dunno why it's giving you an error. You just need to say that temp = s. Anyways, instead of that, you could try this: transform(temp.begin(), temp.end(), temp.begin() , ::tolower) <- cleaner looking."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\\n    public boolean isPalindrome(String s) {\\n        s = s.toLowerCase();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString str = sb.toString();\\n\\t\\tString reverse = sb.reverse().toString();\\n\\t\\tif (str.equals(reverse))\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "perman_1",
                        "content": "use this condition:\\n            `if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))`\\n\\n\\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        string s1 = s;\\n        if(s == \"\") return true;\\n        transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\\n        int j = 0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if((s1[i]>=\\'A\\' && s1[i]<=\\'Z\\') || (s1[i]>=\\'a\\' && s1[i]<=\\'z\\') || (s1[i]>=\\'0\\' && s1[i]<=\\'9\\'))\\n            {\\n                s1[j] = s1[i];\\n                j++;\\n            }\\n        }\\n        s1 =  s1.substr(0, j);\\n        int len = s1.size();\\n        for(int i=0;i<len/2;i++)\\n        {\\n            if(s1[i] != s1[len-1-i]) return false;\\n        }\\n        return true;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Use this rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kartikaggarwal8520",
                        "content": " `var isPalindrome = function(s) {\\n    let arr = s.match(/\\\\w/g);\\n    let str = arr.join(\\'\\');\\n    let reverse = str.split(\\'\\').reverse().join(\\'\\');\\n    if (str.toLowerCase() === reverse.toLowerCase())\\n        return true\\n    else\\n        return false\\n};`\\n\\nThe above code is running perfectly on VS code editor but giving error when I am trying to run the code here.\\nCan anyone please help me out, what\\'s the issue here..?"
                    },
                    {
                        "username": "sjdba86",
                        "content": "when I compile this code on visual studio it returns true for testcase 94 which is \"a\" but on leetcode it returns false. any idea on what might be the problem here?\\n\\n\\n `using System.Linq;\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n      public static  Queue<string> queue = new Queue<string>();\\n        public static Stack<string> stack = new Stack<string>();\\n \\n         public bool IsPalindrome(string s)\\n        {\\n           // s = string.Concat(s.Where(c => char.IsLetterOrDigit(c) || char.IsWhiteSpace(c)));\\n\\n            Regex rgx = new Regex(\"[^a-zA-Z0-9]\");\\n            s = rgx.Replace(s, \" \");\\n\\n            foreach (char item in s)\\n            {\\n                if (s==\" \")\\n                {\\n                    return true;\\n                }\\n                 if(char.IsLetter(item) &&!char.IsPunctuation(item))\\n                {\\n                    queue.Enqueue(char.ToLower(item).ToString());\\n                    stack.Push(char.ToLower(item).ToString());\\n                }\\n              \\n            }\\n     \\n            while (stack.Count >= 0)\\n            {\\n                var s1 = stack.Peek();\\n                var q = queue.Peek();\\n                if (stack.Count != 0 && s1 == q)\\n                {\\n                    stack.Pop();\\n                    queue.Dequeue();\\n                    if (stack.Count == 0)\\n                        return true;\\n                }\\n                else if (s1 != q)\\n                    return false;\\n            }\\n            return false;\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Recursive Solution: \\n\\nclass Solution {\\n\\n    public boolean checkPalindrome(String s, int start, int end){\\n\\n        if(start >= end)\\n           return true;\\n        if(s.charAt(start) != s.charAt(end))\\n           return false;\\n        \\n        return checkPalindrome(s,start+1,end-1);\\n\\n\\n    }\\n    public boolean isPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (!(Character.isLetterOrDigit(ch))) {\\n            continue;\\n            }\\n            sb.append(Character.toLowerCase(ch));\\n        }\\n        System.out.println(sb.toString());\\n        System.out.println(sb.length());\\n    \\n      return checkPalindrome(sb.toString(),0,sb.length()-1);\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Lucianofitti",
                        "content": "You don\\'t need another function. Check my code:\\npublic  boolean palindrome(String s) {\\n        String st = s.toLowerCase().replaceAll(\"\\\\\\\\W\", \"\");\\n        if (st.length() < 2)\\n            return true;\\n\\n        if (st.charAt(0) != st.charAt(st.length()-1))\\n            return false;\\n        \\n        return palindrome(st.substring(1,st.length()-1));\\n    }\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "How to deal with underscores?  o_o"
                    },
                    {
                        "username": "mukadas026",
                        "content": "you have to filter out anything thats not an alphanumeric character(a-z, 0-9), which includes  \"_\", the resulting string should be \"oo\" which is a palindrome"
                    },
                    {
                        "username": "elzazo",
                        "content": "Ignore, just go for letters and digits. Everything else has not to be compared."
                    },
                    {
                        "username": "drshn_h",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int len = s.size(),i=0;\\n        string new_s = \"\";\\n        while(i<len){\\n            if(s[i]>= \\'a\\' && s[i] <= \\'z\\'){\\n                new_s.push_back(s[i]);\\n            }\\n            else if(s[i] >= \\'A\\' && s[i]<= \\'Z\\'){\\n                new_s.push_back(s[i]+(\\'a\\'-\\'A\\'));\\n            }\\n            i++;\\n        }\\n        len = new_s.size();\\n        for(i=0;i <len/2; i++ ){\\n            if(new_s[i] != new_s[len-i-1]){\\n            return false;}}\\n        return true;\\n    }\\n};`\\n\\nMy (c++) code will return true for string inputs \"0p\" & \"0Dd\" both of these strings become \"p\" & \"dd\" respectively after removing extra characters and as per definition, both of these strings are palindrome."
                    },
                    {
                        "username": "mukadas026",
                        "content": "you should not remove numbers because they are also alphanumeric(a-z, 0-9). The resulting strings for those ones should be \"0p\" and \"0dd\" which are not palindromes. You can try using a regular expression to match the conditions "
                    }
                ]
            },
            {
                "id": 1732840,
                "content": [
                    {
                        "username": "JisanAR",
                        "content": "what is wrong in my code:\\n\\n\\n\\nclass Solution {\\nprivate:\\nchar check_let(char lett){\\n    char let_out =  lett-\\'A\\'+\\'a\\';\\n    return let_out;}\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]>\\'A\\' && s[i]<\\'Z\\' || s[i]>\\'a\\' && s[i]>\\'z\\'){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        if(temp.size()==0){\\n            return 1;\\n        }\\n        int st = 0;\\n    int en = temp.size()-1;\\n    while(st<en){\\n        if(check_let(temp[st])==check_let(temp[en])){\\n            st++;\\n            en--;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}};"
                    },
                    {
                        "username": "deepak130797",
                        "content": "Heart of this question\\n\\n if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }\\nstring match=check;\\n    reverse(check.begin(),check.end());\\n    if(match==check)\\n    {\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": " if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "0P(zero P) IS FALSE as it will become p0 ( p zero)\nBut a. is true as it will become a \nI Was stuck in two cases \nAlphanumeric are A-Z,A-Z,0-9 we have to remove all the remaining character.\nIf u have problems understanding the function is \nhere is the link for my solution\nhttps://leetcode.com/problems/valid-palindrome/solutions/2944509/simple-easy-solution-optimized-on-time-o1-space/\n\nLink for function that is used-\nhttps://cplusplus.com/reference/cwctype/iswalnum/"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "its giving me a runtime error how can i solve this issue the error is presumptly on line 2!!!!\\n\\nclass Solution:\\n    def isPalindrome (self, s: str) -> bool:\\n        # make list of characters to remove\\n        lst = [\"(\", \"`\", \")\", \",\", \"!\", \" \", \":\", \".\", \";\", \"@\", \"#\", \"_\", \"-\", \"\\'\", \"\\\\\"\", \"{\", \"}\", \"[\", \"]\", \"?\"]\\n        # convert to lowercase\\n        s = s.lower()\\n        # loop through each character\\n        for _ in lst:\\n            # remove by splitting\\n            s = \"\".join(s.split(_))\\n\\n        # compare string with reversed string\\n        return s == s[::-1]"
                    },
                    {
                        "username": "parthgarg123",
                        "content": "why \\'b\\' is being removed in this particular testcase?   \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::toupper);\\n        for(int i=0;i<s.size();i++){\\n            if(!(s[i]>=65 && s[i]<=90 || (s[i]>=48 && s[i]<=57)))\\n            s.erase(i);\\n        }\\n        cout<<s<<endl;\\n        for(int i =0;i<s.size()/2;i++){\\n\\t        if(s[i]!=s[s.size()-i-1])\\n\\t            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\ntestcase:\\n```a.b,.```\\nmy string output is `A`"
                    },
                    {
                        "username": "raunak22",
                        "content": "i myself dealing with the same issue\n"
                    },
                    {
                        "username": "chelsye",
                        "content": " class Solution {\\n  private :\\n  bool valid( char ch){\\n    if( (ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'A\\' && ch <= \\'Z\\') || (ch >= \\'0\\' && ch <= \\'9\\') ){\\n      return 1;\\n    } \\n    return 0;\\n  }\\n  char lowerCase(char ch){\\n    if(( ch >= \\'a\\' && ch <= \\'z\\')  || (ch >= \\'0\\' && ch <= \\'9\\')){\\n      return ch;\\n    }\\n    else{\\n      char temp = ch -\\'A\\' + \\'a\\';\\n      return temp;\\n    }\\n  }\\n bool checkPalindrome(string s){\\n   int st = 0;\\n   int e = s.length() - 1;\\n   \\n   while( st <= e){\\n     if( s[st] != s[e]){\\n             return 0;\\n     }\\n     else{\\n       st ++;\\n       e --;\\n     }\\n   }\\n   return 1;\\n }\\npublic:\\n    bool isPalindrome(string s) {\\n     \\n      string temp = \"\";\\n      for(int i = 0; i< s.length(); i++){\\n        if( valid(s[i])){\\n              temp.push_back(s[i]);\\n        }\\n      }\\n      \\n      for( int j = 0; j < temp.length(); j++){\\n        temp[j] = lowerCase(temp[j]);\\n      }\\n      \\n      return checkPalindrome(temp);\\n    }\\n};"
                    },
                    {
                        "username": "chandupriya_06",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //create an empty string s1 and add only the characters and numbers to this string from original string\\n        // converting it to lower case while adding to s1\\n        // reverse s1\\n        // comparing s1 and s2 returns either 1 or zero\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])||isdigit(s[i])){\\n                s1+=tolower(s[i]);\\n            }\\n        }\\n        string s2=s1;\\n        reverse(s2.begin(),s2.end());\\n\\n    //return(s1==string(s1.rbegin(),s1.rend()));\\n    return(s2==s1);\\n    }\\n};"
                    },
                    {
                        "username": "noone_00002",
                        "content": "As it is mentioned that you don\\'t need to ignore letter and numbers in the problems \\nif((ans.charAt(i)>=\\'a\\'&& ans.charAt(i)<=\\'z\\')||(ans.charAt(i)>=\\'0\\' && ans.charAt(i)<=\\'9\\'))\\n            {\\n                temp.append(ans.charAt(i));\\n            }"
                    },
                    {
                        "username": "devrajgaur",
                        "content": "Simple C++ solution...\\n\\n\\nclass Solution {\\npublic:\\n\\n    char toLowerCase(char ch)\\n    {\\n        // converts all the upper case letters to lower case\\n        if(ch>=\\'a\\' && ch<=\\'z\\')\\n        {\\n            return ch;\\n        }\\n        else\\n        {\\n            char temp = ch - \\'A\\' + \\'a\\';\\n            return temp;\\n        }  \\n    }\\n\\n    bool isValid( char ch )\\n    {\\n        // checks each character of the string if it is valid or not\\n        if( (ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'A\\' && ch<=\\'Z\\') || (ch>=\\'0\\' && ch<=\\'9\\') )\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( isValid( s[i] ) )\\n            {\\n                str.push_back(s[i]);\\n                // if the character is valid in the string then it would be inserted in the newly created string\\n            }\\n        }\\n        int size=str.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end)\\n        {\\n            if( toLowerCase(str[start]) != toLowerCase(str[end]))\\n            {\\n                return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1728729,
                "content": [
                    {
                        "username": "JisanAR",
                        "content": "what is wrong in my code:\\n\\n\\n\\nclass Solution {\\nprivate:\\nchar check_let(char lett){\\n    char let_out =  lett-\\'A\\'+\\'a\\';\\n    return let_out;}\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]>\\'A\\' && s[i]<\\'Z\\' || s[i]>\\'a\\' && s[i]>\\'z\\'){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        if(temp.size()==0){\\n            return 1;\\n        }\\n        int st = 0;\\n    int en = temp.size()-1;\\n    while(st<en){\\n        if(check_let(temp[st])==check_let(temp[en])){\\n            st++;\\n            en--;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}};"
                    },
                    {
                        "username": "deepak130797",
                        "content": "Heart of this question\\n\\n if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }\\nstring match=check;\\n    reverse(check.begin(),check.end());\\n    if(match==check)\\n    {\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": " if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "0P(zero P) IS FALSE as it will become p0 ( p zero)\nBut a. is true as it will become a \nI Was stuck in two cases \nAlphanumeric are A-Z,A-Z,0-9 we have to remove all the remaining character.\nIf u have problems understanding the function is \nhere is the link for my solution\nhttps://leetcode.com/problems/valid-palindrome/solutions/2944509/simple-easy-solution-optimized-on-time-o1-space/\n\nLink for function that is used-\nhttps://cplusplus.com/reference/cwctype/iswalnum/"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "its giving me a runtime error how can i solve this issue the error is presumptly on line 2!!!!\\n\\nclass Solution:\\n    def isPalindrome (self, s: str) -> bool:\\n        # make list of characters to remove\\n        lst = [\"(\", \"`\", \")\", \",\", \"!\", \" \", \":\", \".\", \";\", \"@\", \"#\", \"_\", \"-\", \"\\'\", \"\\\\\"\", \"{\", \"}\", \"[\", \"]\", \"?\"]\\n        # convert to lowercase\\n        s = s.lower()\\n        # loop through each character\\n        for _ in lst:\\n            # remove by splitting\\n            s = \"\".join(s.split(_))\\n\\n        # compare string with reversed string\\n        return s == s[::-1]"
                    },
                    {
                        "username": "parthgarg123",
                        "content": "why \\'b\\' is being removed in this particular testcase?   \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::toupper);\\n        for(int i=0;i<s.size();i++){\\n            if(!(s[i]>=65 && s[i]<=90 || (s[i]>=48 && s[i]<=57)))\\n            s.erase(i);\\n        }\\n        cout<<s<<endl;\\n        for(int i =0;i<s.size()/2;i++){\\n\\t        if(s[i]!=s[s.size()-i-1])\\n\\t            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\ntestcase:\\n```a.b,.```\\nmy string output is `A`"
                    },
                    {
                        "username": "raunak22",
                        "content": "i myself dealing with the same issue\n"
                    },
                    {
                        "username": "chelsye",
                        "content": " class Solution {\\n  private :\\n  bool valid( char ch){\\n    if( (ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'A\\' && ch <= \\'Z\\') || (ch >= \\'0\\' && ch <= \\'9\\') ){\\n      return 1;\\n    } \\n    return 0;\\n  }\\n  char lowerCase(char ch){\\n    if(( ch >= \\'a\\' && ch <= \\'z\\')  || (ch >= \\'0\\' && ch <= \\'9\\')){\\n      return ch;\\n    }\\n    else{\\n      char temp = ch -\\'A\\' + \\'a\\';\\n      return temp;\\n    }\\n  }\\n bool checkPalindrome(string s){\\n   int st = 0;\\n   int e = s.length() - 1;\\n   \\n   while( st <= e){\\n     if( s[st] != s[e]){\\n             return 0;\\n     }\\n     else{\\n       st ++;\\n       e --;\\n     }\\n   }\\n   return 1;\\n }\\npublic:\\n    bool isPalindrome(string s) {\\n     \\n      string temp = \"\";\\n      for(int i = 0; i< s.length(); i++){\\n        if( valid(s[i])){\\n              temp.push_back(s[i]);\\n        }\\n      }\\n      \\n      for( int j = 0; j < temp.length(); j++){\\n        temp[j] = lowerCase(temp[j]);\\n      }\\n      \\n      return checkPalindrome(temp);\\n    }\\n};"
                    },
                    {
                        "username": "chandupriya_06",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //create an empty string s1 and add only the characters and numbers to this string from original string\\n        // converting it to lower case while adding to s1\\n        // reverse s1\\n        // comparing s1 and s2 returns either 1 or zero\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])||isdigit(s[i])){\\n                s1+=tolower(s[i]);\\n            }\\n        }\\n        string s2=s1;\\n        reverse(s2.begin(),s2.end());\\n\\n    //return(s1==string(s1.rbegin(),s1.rend()));\\n    return(s2==s1);\\n    }\\n};"
                    },
                    {
                        "username": "noone_00002",
                        "content": "As it is mentioned that you don\\'t need to ignore letter and numbers in the problems \\nif((ans.charAt(i)>=\\'a\\'&& ans.charAt(i)<=\\'z\\')||(ans.charAt(i)>=\\'0\\' && ans.charAt(i)<=\\'9\\'))\\n            {\\n                temp.append(ans.charAt(i));\\n            }"
                    },
                    {
                        "username": "devrajgaur",
                        "content": "Simple C++ solution...\\n\\n\\nclass Solution {\\npublic:\\n\\n    char toLowerCase(char ch)\\n    {\\n        // converts all the upper case letters to lower case\\n        if(ch>=\\'a\\' && ch<=\\'z\\')\\n        {\\n            return ch;\\n        }\\n        else\\n        {\\n            char temp = ch - \\'A\\' + \\'a\\';\\n            return temp;\\n        }  \\n    }\\n\\n    bool isValid( char ch )\\n    {\\n        // checks each character of the string if it is valid or not\\n        if( (ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'A\\' && ch<=\\'Z\\') || (ch>=\\'0\\' && ch<=\\'9\\') )\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( isValid( s[i] ) )\\n            {\\n                str.push_back(s[i]);\\n                // if the character is valid in the string then it would be inserted in the newly created string\\n            }\\n        }\\n        int size=str.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end)\\n        {\\n            if( toLowerCase(str[start]) != toLowerCase(str[end]))\\n            {\\n                return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1728728,
                "content": [
                    {
                        "username": "JisanAR",
                        "content": "what is wrong in my code:\\n\\n\\n\\nclass Solution {\\nprivate:\\nchar check_let(char lett){\\n    char let_out =  lett-\\'A\\'+\\'a\\';\\n    return let_out;}\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]>\\'A\\' && s[i]<\\'Z\\' || s[i]>\\'a\\' && s[i]>\\'z\\'){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        if(temp.size()==0){\\n            return 1;\\n        }\\n        int st = 0;\\n    int en = temp.size()-1;\\n    while(st<en){\\n        if(check_let(temp[st])==check_let(temp[en])){\\n            st++;\\n            en--;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}};"
                    },
                    {
                        "username": "deepak130797",
                        "content": "Heart of this question\\n\\n if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }\\nstring match=check;\\n    reverse(check.begin(),check.end());\\n    if(match==check)\\n    {\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": " if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "0P(zero P) IS FALSE as it will become p0 ( p zero)\nBut a. is true as it will become a \nI Was stuck in two cases \nAlphanumeric are A-Z,A-Z,0-9 we have to remove all the remaining character.\nIf u have problems understanding the function is \nhere is the link for my solution\nhttps://leetcode.com/problems/valid-palindrome/solutions/2944509/simple-easy-solution-optimized-on-time-o1-space/\n\nLink for function that is used-\nhttps://cplusplus.com/reference/cwctype/iswalnum/"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "its giving me a runtime error how can i solve this issue the error is presumptly on line 2!!!!\\n\\nclass Solution:\\n    def isPalindrome (self, s: str) -> bool:\\n        # make list of characters to remove\\n        lst = [\"(\", \"`\", \")\", \",\", \"!\", \" \", \":\", \".\", \";\", \"@\", \"#\", \"_\", \"-\", \"\\'\", \"\\\\\"\", \"{\", \"}\", \"[\", \"]\", \"?\"]\\n        # convert to lowercase\\n        s = s.lower()\\n        # loop through each character\\n        for _ in lst:\\n            # remove by splitting\\n            s = \"\".join(s.split(_))\\n\\n        # compare string with reversed string\\n        return s == s[::-1]"
                    },
                    {
                        "username": "parthgarg123",
                        "content": "why \\'b\\' is being removed in this particular testcase?   \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::toupper);\\n        for(int i=0;i<s.size();i++){\\n            if(!(s[i]>=65 && s[i]<=90 || (s[i]>=48 && s[i]<=57)))\\n            s.erase(i);\\n        }\\n        cout<<s<<endl;\\n        for(int i =0;i<s.size()/2;i++){\\n\\t        if(s[i]!=s[s.size()-i-1])\\n\\t            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\ntestcase:\\n```a.b,.```\\nmy string output is `A`"
                    },
                    {
                        "username": "raunak22",
                        "content": "i myself dealing with the same issue\n"
                    },
                    {
                        "username": "chelsye",
                        "content": " class Solution {\\n  private :\\n  bool valid( char ch){\\n    if( (ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'A\\' && ch <= \\'Z\\') || (ch >= \\'0\\' && ch <= \\'9\\') ){\\n      return 1;\\n    } \\n    return 0;\\n  }\\n  char lowerCase(char ch){\\n    if(( ch >= \\'a\\' && ch <= \\'z\\')  || (ch >= \\'0\\' && ch <= \\'9\\')){\\n      return ch;\\n    }\\n    else{\\n      char temp = ch -\\'A\\' + \\'a\\';\\n      return temp;\\n    }\\n  }\\n bool checkPalindrome(string s){\\n   int st = 0;\\n   int e = s.length() - 1;\\n   \\n   while( st <= e){\\n     if( s[st] != s[e]){\\n             return 0;\\n     }\\n     else{\\n       st ++;\\n       e --;\\n     }\\n   }\\n   return 1;\\n }\\npublic:\\n    bool isPalindrome(string s) {\\n     \\n      string temp = \"\";\\n      for(int i = 0; i< s.length(); i++){\\n        if( valid(s[i])){\\n              temp.push_back(s[i]);\\n        }\\n      }\\n      \\n      for( int j = 0; j < temp.length(); j++){\\n        temp[j] = lowerCase(temp[j]);\\n      }\\n      \\n      return checkPalindrome(temp);\\n    }\\n};"
                    },
                    {
                        "username": "chandupriya_06",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //create an empty string s1 and add only the characters and numbers to this string from original string\\n        // converting it to lower case while adding to s1\\n        // reverse s1\\n        // comparing s1 and s2 returns either 1 or zero\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])||isdigit(s[i])){\\n                s1+=tolower(s[i]);\\n            }\\n        }\\n        string s2=s1;\\n        reverse(s2.begin(),s2.end());\\n\\n    //return(s1==string(s1.rbegin(),s1.rend()));\\n    return(s2==s1);\\n    }\\n};"
                    },
                    {
                        "username": "noone_00002",
                        "content": "As it is mentioned that you don\\'t need to ignore letter and numbers in the problems \\nif((ans.charAt(i)>=\\'a\\'&& ans.charAt(i)<=\\'z\\')||(ans.charAt(i)>=\\'0\\' && ans.charAt(i)<=\\'9\\'))\\n            {\\n                temp.append(ans.charAt(i));\\n            }"
                    },
                    {
                        "username": "devrajgaur",
                        "content": "Simple C++ solution...\\n\\n\\nclass Solution {\\npublic:\\n\\n    char toLowerCase(char ch)\\n    {\\n        // converts all the upper case letters to lower case\\n        if(ch>=\\'a\\' && ch<=\\'z\\')\\n        {\\n            return ch;\\n        }\\n        else\\n        {\\n            char temp = ch - \\'A\\' + \\'a\\';\\n            return temp;\\n        }  \\n    }\\n\\n    bool isValid( char ch )\\n    {\\n        // checks each character of the string if it is valid or not\\n        if( (ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'A\\' && ch<=\\'Z\\') || (ch>=\\'0\\' && ch<=\\'9\\') )\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( isValid( s[i] ) )\\n            {\\n                str.push_back(s[i]);\\n                // if the character is valid in the string then it would be inserted in the newly created string\\n            }\\n        }\\n        int size=str.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end)\\n        {\\n            if( toLowerCase(str[start]) != toLowerCase(str[end]))\\n            {\\n                return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1726231,
                "content": [
                    {
                        "username": "JisanAR",
                        "content": "what is wrong in my code:\\n\\n\\n\\nclass Solution {\\nprivate:\\nchar check_let(char lett){\\n    char let_out =  lett-\\'A\\'+\\'a\\';\\n    return let_out;}\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]>\\'A\\' && s[i]<\\'Z\\' || s[i]>\\'a\\' && s[i]>\\'z\\'){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        if(temp.size()==0){\\n            return 1;\\n        }\\n        int st = 0;\\n    int en = temp.size()-1;\\n    while(st<en){\\n        if(check_let(temp[st])==check_let(temp[en])){\\n            st++;\\n            en--;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}};"
                    },
                    {
                        "username": "deepak130797",
                        "content": "Heart of this question\\n\\n if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }\\nstring match=check;\\n    reverse(check.begin(),check.end());\\n    if(match==check)\\n    {\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": " if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "0P(zero P) IS FALSE as it will become p0 ( p zero)\nBut a. is true as it will become a \nI Was stuck in two cases \nAlphanumeric are A-Z,A-Z,0-9 we have to remove all the remaining character.\nIf u have problems understanding the function is \nhere is the link for my solution\nhttps://leetcode.com/problems/valid-palindrome/solutions/2944509/simple-easy-solution-optimized-on-time-o1-space/\n\nLink for function that is used-\nhttps://cplusplus.com/reference/cwctype/iswalnum/"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "its giving me a runtime error how can i solve this issue the error is presumptly on line 2!!!!\\n\\nclass Solution:\\n    def isPalindrome (self, s: str) -> bool:\\n        # make list of characters to remove\\n        lst = [\"(\", \"`\", \")\", \",\", \"!\", \" \", \":\", \".\", \";\", \"@\", \"#\", \"_\", \"-\", \"\\'\", \"\\\\\"\", \"{\", \"}\", \"[\", \"]\", \"?\"]\\n        # convert to lowercase\\n        s = s.lower()\\n        # loop through each character\\n        for _ in lst:\\n            # remove by splitting\\n            s = \"\".join(s.split(_))\\n\\n        # compare string with reversed string\\n        return s == s[::-1]"
                    },
                    {
                        "username": "parthgarg123",
                        "content": "why \\'b\\' is being removed in this particular testcase?   \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::toupper);\\n        for(int i=0;i<s.size();i++){\\n            if(!(s[i]>=65 && s[i]<=90 || (s[i]>=48 && s[i]<=57)))\\n            s.erase(i);\\n        }\\n        cout<<s<<endl;\\n        for(int i =0;i<s.size()/2;i++){\\n\\t        if(s[i]!=s[s.size()-i-1])\\n\\t            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\ntestcase:\\n```a.b,.```\\nmy string output is `A`"
                    },
                    {
                        "username": "raunak22",
                        "content": "i myself dealing with the same issue\n"
                    },
                    {
                        "username": "chelsye",
                        "content": " class Solution {\\n  private :\\n  bool valid( char ch){\\n    if( (ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'A\\' && ch <= \\'Z\\') || (ch >= \\'0\\' && ch <= \\'9\\') ){\\n      return 1;\\n    } \\n    return 0;\\n  }\\n  char lowerCase(char ch){\\n    if(( ch >= \\'a\\' && ch <= \\'z\\')  || (ch >= \\'0\\' && ch <= \\'9\\')){\\n      return ch;\\n    }\\n    else{\\n      char temp = ch -\\'A\\' + \\'a\\';\\n      return temp;\\n    }\\n  }\\n bool checkPalindrome(string s){\\n   int st = 0;\\n   int e = s.length() - 1;\\n   \\n   while( st <= e){\\n     if( s[st] != s[e]){\\n             return 0;\\n     }\\n     else{\\n       st ++;\\n       e --;\\n     }\\n   }\\n   return 1;\\n }\\npublic:\\n    bool isPalindrome(string s) {\\n     \\n      string temp = \"\";\\n      for(int i = 0; i< s.length(); i++){\\n        if( valid(s[i])){\\n              temp.push_back(s[i]);\\n        }\\n      }\\n      \\n      for( int j = 0; j < temp.length(); j++){\\n        temp[j] = lowerCase(temp[j]);\\n      }\\n      \\n      return checkPalindrome(temp);\\n    }\\n};"
                    },
                    {
                        "username": "chandupriya_06",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //create an empty string s1 and add only the characters and numbers to this string from original string\\n        // converting it to lower case while adding to s1\\n        // reverse s1\\n        // comparing s1 and s2 returns either 1 or zero\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])||isdigit(s[i])){\\n                s1+=tolower(s[i]);\\n            }\\n        }\\n        string s2=s1;\\n        reverse(s2.begin(),s2.end());\\n\\n    //return(s1==string(s1.rbegin(),s1.rend()));\\n    return(s2==s1);\\n    }\\n};"
                    },
                    {
                        "username": "noone_00002",
                        "content": "As it is mentioned that you don\\'t need to ignore letter and numbers in the problems \\nif((ans.charAt(i)>=\\'a\\'&& ans.charAt(i)<=\\'z\\')||(ans.charAt(i)>=\\'0\\' && ans.charAt(i)<=\\'9\\'))\\n            {\\n                temp.append(ans.charAt(i));\\n            }"
                    },
                    {
                        "username": "devrajgaur",
                        "content": "Simple C++ solution...\\n\\n\\nclass Solution {\\npublic:\\n\\n    char toLowerCase(char ch)\\n    {\\n        // converts all the upper case letters to lower case\\n        if(ch>=\\'a\\' && ch<=\\'z\\')\\n        {\\n            return ch;\\n        }\\n        else\\n        {\\n            char temp = ch - \\'A\\' + \\'a\\';\\n            return temp;\\n        }  \\n    }\\n\\n    bool isValid( char ch )\\n    {\\n        // checks each character of the string if it is valid or not\\n        if( (ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'A\\' && ch<=\\'Z\\') || (ch>=\\'0\\' && ch<=\\'9\\') )\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( isValid( s[i] ) )\\n            {\\n                str.push_back(s[i]);\\n                // if the character is valid in the string then it would be inserted in the newly created string\\n            }\\n        }\\n        int size=str.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end)\\n        {\\n            if( toLowerCase(str[start]) != toLowerCase(str[end]))\\n            {\\n                return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1724099,
                "content": [
                    {
                        "username": "JisanAR",
                        "content": "what is wrong in my code:\\n\\n\\n\\nclass Solution {\\nprivate:\\nchar check_let(char lett){\\n    char let_out =  lett-\\'A\\'+\\'a\\';\\n    return let_out;}\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]>\\'A\\' && s[i]<\\'Z\\' || s[i]>\\'a\\' && s[i]>\\'z\\'){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        if(temp.size()==0){\\n            return 1;\\n        }\\n        int st = 0;\\n    int en = temp.size()-1;\\n    while(st<en){\\n        if(check_let(temp[st])==check_let(temp[en])){\\n            st++;\\n            en--;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}};"
                    },
                    {
                        "username": "deepak130797",
                        "content": "Heart of this question\\n\\n if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }\\nstring match=check;\\n    reverse(check.begin(),check.end());\\n    if(match==check)\\n    {\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": " if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "0P(zero P) IS FALSE as it will become p0 ( p zero)\nBut a. is true as it will become a \nI Was stuck in two cases \nAlphanumeric are A-Z,A-Z,0-9 we have to remove all the remaining character.\nIf u have problems understanding the function is \nhere is the link for my solution\nhttps://leetcode.com/problems/valid-palindrome/solutions/2944509/simple-easy-solution-optimized-on-time-o1-space/\n\nLink for function that is used-\nhttps://cplusplus.com/reference/cwctype/iswalnum/"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "its giving me a runtime error how can i solve this issue the error is presumptly on line 2!!!!\\n\\nclass Solution:\\n    def isPalindrome (self, s: str) -> bool:\\n        # make list of characters to remove\\n        lst = [\"(\", \"`\", \")\", \",\", \"!\", \" \", \":\", \".\", \";\", \"@\", \"#\", \"_\", \"-\", \"\\'\", \"\\\\\"\", \"{\", \"}\", \"[\", \"]\", \"?\"]\\n        # convert to lowercase\\n        s = s.lower()\\n        # loop through each character\\n        for _ in lst:\\n            # remove by splitting\\n            s = \"\".join(s.split(_))\\n\\n        # compare string with reversed string\\n        return s == s[::-1]"
                    },
                    {
                        "username": "parthgarg123",
                        "content": "why \\'b\\' is being removed in this particular testcase?   \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::toupper);\\n        for(int i=0;i<s.size();i++){\\n            if(!(s[i]>=65 && s[i]<=90 || (s[i]>=48 && s[i]<=57)))\\n            s.erase(i);\\n        }\\n        cout<<s<<endl;\\n        for(int i =0;i<s.size()/2;i++){\\n\\t        if(s[i]!=s[s.size()-i-1])\\n\\t            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\ntestcase:\\n```a.b,.```\\nmy string output is `A`"
                    },
                    {
                        "username": "raunak22",
                        "content": "i myself dealing with the same issue\n"
                    },
                    {
                        "username": "chelsye",
                        "content": " class Solution {\\n  private :\\n  bool valid( char ch){\\n    if( (ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'A\\' && ch <= \\'Z\\') || (ch >= \\'0\\' && ch <= \\'9\\') ){\\n      return 1;\\n    } \\n    return 0;\\n  }\\n  char lowerCase(char ch){\\n    if(( ch >= \\'a\\' && ch <= \\'z\\')  || (ch >= \\'0\\' && ch <= \\'9\\')){\\n      return ch;\\n    }\\n    else{\\n      char temp = ch -\\'A\\' + \\'a\\';\\n      return temp;\\n    }\\n  }\\n bool checkPalindrome(string s){\\n   int st = 0;\\n   int e = s.length() - 1;\\n   \\n   while( st <= e){\\n     if( s[st] != s[e]){\\n             return 0;\\n     }\\n     else{\\n       st ++;\\n       e --;\\n     }\\n   }\\n   return 1;\\n }\\npublic:\\n    bool isPalindrome(string s) {\\n     \\n      string temp = \"\";\\n      for(int i = 0; i< s.length(); i++){\\n        if( valid(s[i])){\\n              temp.push_back(s[i]);\\n        }\\n      }\\n      \\n      for( int j = 0; j < temp.length(); j++){\\n        temp[j] = lowerCase(temp[j]);\\n      }\\n      \\n      return checkPalindrome(temp);\\n    }\\n};"
                    },
                    {
                        "username": "chandupriya_06",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //create an empty string s1 and add only the characters and numbers to this string from original string\\n        // converting it to lower case while adding to s1\\n        // reverse s1\\n        // comparing s1 and s2 returns either 1 or zero\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])||isdigit(s[i])){\\n                s1+=tolower(s[i]);\\n            }\\n        }\\n        string s2=s1;\\n        reverse(s2.begin(),s2.end());\\n\\n    //return(s1==string(s1.rbegin(),s1.rend()));\\n    return(s2==s1);\\n    }\\n};"
                    },
                    {
                        "username": "noone_00002",
                        "content": "As it is mentioned that you don\\'t need to ignore letter and numbers in the problems \\nif((ans.charAt(i)>=\\'a\\'&& ans.charAt(i)<=\\'z\\')||(ans.charAt(i)>=\\'0\\' && ans.charAt(i)<=\\'9\\'))\\n            {\\n                temp.append(ans.charAt(i));\\n            }"
                    },
                    {
                        "username": "devrajgaur",
                        "content": "Simple C++ solution...\\n\\n\\nclass Solution {\\npublic:\\n\\n    char toLowerCase(char ch)\\n    {\\n        // converts all the upper case letters to lower case\\n        if(ch>=\\'a\\' && ch<=\\'z\\')\\n        {\\n            return ch;\\n        }\\n        else\\n        {\\n            char temp = ch - \\'A\\' + \\'a\\';\\n            return temp;\\n        }  \\n    }\\n\\n    bool isValid( char ch )\\n    {\\n        // checks each character of the string if it is valid or not\\n        if( (ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'A\\' && ch<=\\'Z\\') || (ch>=\\'0\\' && ch<=\\'9\\') )\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( isValid( s[i] ) )\\n            {\\n                str.push_back(s[i]);\\n                // if the character is valid in the string then it would be inserted in the newly created string\\n            }\\n        }\\n        int size=str.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end)\\n        {\\n            if( toLowerCase(str[start]) != toLowerCase(str[end]))\\n            {\\n                return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722340,
                "content": [
                    {
                        "username": "JisanAR",
                        "content": "what is wrong in my code:\\n\\n\\n\\nclass Solution {\\nprivate:\\nchar check_let(char lett){\\n    char let_out =  lett-\\'A\\'+\\'a\\';\\n    return let_out;}\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]>\\'A\\' && s[i]<\\'Z\\' || s[i]>\\'a\\' && s[i]>\\'z\\'){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        if(temp.size()==0){\\n            return 1;\\n        }\\n        int st = 0;\\n    int en = temp.size()-1;\\n    while(st<en){\\n        if(check_let(temp[st])==check_let(temp[en])){\\n            st++;\\n            en--;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}};"
                    },
                    {
                        "username": "deepak130797",
                        "content": "Heart of this question\\n\\n if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }\\nstring match=check;\\n    reverse(check.begin(),check.end());\\n    if(match==check)\\n    {\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": " if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "0P(zero P) IS FALSE as it will become p0 ( p zero)\nBut a. is true as it will become a \nI Was stuck in two cases \nAlphanumeric are A-Z,A-Z,0-9 we have to remove all the remaining character.\nIf u have problems understanding the function is \nhere is the link for my solution\nhttps://leetcode.com/problems/valid-palindrome/solutions/2944509/simple-easy-solution-optimized-on-time-o1-space/\n\nLink for function that is used-\nhttps://cplusplus.com/reference/cwctype/iswalnum/"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "its giving me a runtime error how can i solve this issue the error is presumptly on line 2!!!!\\n\\nclass Solution:\\n    def isPalindrome (self, s: str) -> bool:\\n        # make list of characters to remove\\n        lst = [\"(\", \"`\", \")\", \",\", \"!\", \" \", \":\", \".\", \";\", \"@\", \"#\", \"_\", \"-\", \"\\'\", \"\\\\\"\", \"{\", \"}\", \"[\", \"]\", \"?\"]\\n        # convert to lowercase\\n        s = s.lower()\\n        # loop through each character\\n        for _ in lst:\\n            # remove by splitting\\n            s = \"\".join(s.split(_))\\n\\n        # compare string with reversed string\\n        return s == s[::-1]"
                    },
                    {
                        "username": "parthgarg123",
                        "content": "why \\'b\\' is being removed in this particular testcase?   \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::toupper);\\n        for(int i=0;i<s.size();i++){\\n            if(!(s[i]>=65 && s[i]<=90 || (s[i]>=48 && s[i]<=57)))\\n            s.erase(i);\\n        }\\n        cout<<s<<endl;\\n        for(int i =0;i<s.size()/2;i++){\\n\\t        if(s[i]!=s[s.size()-i-1])\\n\\t            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\ntestcase:\\n```a.b,.```\\nmy string output is `A`"
                    },
                    {
                        "username": "raunak22",
                        "content": "i myself dealing with the same issue\n"
                    },
                    {
                        "username": "chelsye",
                        "content": " class Solution {\\n  private :\\n  bool valid( char ch){\\n    if( (ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'A\\' && ch <= \\'Z\\') || (ch >= \\'0\\' && ch <= \\'9\\') ){\\n      return 1;\\n    } \\n    return 0;\\n  }\\n  char lowerCase(char ch){\\n    if(( ch >= \\'a\\' && ch <= \\'z\\')  || (ch >= \\'0\\' && ch <= \\'9\\')){\\n      return ch;\\n    }\\n    else{\\n      char temp = ch -\\'A\\' + \\'a\\';\\n      return temp;\\n    }\\n  }\\n bool checkPalindrome(string s){\\n   int st = 0;\\n   int e = s.length() - 1;\\n   \\n   while( st <= e){\\n     if( s[st] != s[e]){\\n             return 0;\\n     }\\n     else{\\n       st ++;\\n       e --;\\n     }\\n   }\\n   return 1;\\n }\\npublic:\\n    bool isPalindrome(string s) {\\n     \\n      string temp = \"\";\\n      for(int i = 0; i< s.length(); i++){\\n        if( valid(s[i])){\\n              temp.push_back(s[i]);\\n        }\\n      }\\n      \\n      for( int j = 0; j < temp.length(); j++){\\n        temp[j] = lowerCase(temp[j]);\\n      }\\n      \\n      return checkPalindrome(temp);\\n    }\\n};"
                    },
                    {
                        "username": "chandupriya_06",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //create an empty string s1 and add only the characters and numbers to this string from original string\\n        // converting it to lower case while adding to s1\\n        // reverse s1\\n        // comparing s1 and s2 returns either 1 or zero\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])||isdigit(s[i])){\\n                s1+=tolower(s[i]);\\n            }\\n        }\\n        string s2=s1;\\n        reverse(s2.begin(),s2.end());\\n\\n    //return(s1==string(s1.rbegin(),s1.rend()));\\n    return(s2==s1);\\n    }\\n};"
                    },
                    {
                        "username": "noone_00002",
                        "content": "As it is mentioned that you don\\'t need to ignore letter and numbers in the problems \\nif((ans.charAt(i)>=\\'a\\'&& ans.charAt(i)<=\\'z\\')||(ans.charAt(i)>=\\'0\\' && ans.charAt(i)<=\\'9\\'))\\n            {\\n                temp.append(ans.charAt(i));\\n            }"
                    },
                    {
                        "username": "devrajgaur",
                        "content": "Simple C++ solution...\\n\\n\\nclass Solution {\\npublic:\\n\\n    char toLowerCase(char ch)\\n    {\\n        // converts all the upper case letters to lower case\\n        if(ch>=\\'a\\' && ch<=\\'z\\')\\n        {\\n            return ch;\\n        }\\n        else\\n        {\\n            char temp = ch - \\'A\\' + \\'a\\';\\n            return temp;\\n        }  \\n    }\\n\\n    bool isValid( char ch )\\n    {\\n        // checks each character of the string if it is valid or not\\n        if( (ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'A\\' && ch<=\\'Z\\') || (ch>=\\'0\\' && ch<=\\'9\\') )\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( isValid( s[i] ) )\\n            {\\n                str.push_back(s[i]);\\n                // if the character is valid in the string then it would be inserted in the newly created string\\n            }\\n        }\\n        int size=str.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end)\\n        {\\n            if( toLowerCase(str[start]) != toLowerCase(str[end]))\\n            {\\n                return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1720654,
                "content": [
                    {
                        "username": "JisanAR",
                        "content": "what is wrong in my code:\\n\\n\\n\\nclass Solution {\\nprivate:\\nchar check_let(char lett){\\n    char let_out =  lett-\\'A\\'+\\'a\\';\\n    return let_out;}\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]>\\'A\\' && s[i]<\\'Z\\' || s[i]>\\'a\\' && s[i]>\\'z\\'){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        if(temp.size()==0){\\n            return 1;\\n        }\\n        int st = 0;\\n    int en = temp.size()-1;\\n    while(st<en){\\n        if(check_let(temp[st])==check_let(temp[en])){\\n            st++;\\n            en--;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}};"
                    },
                    {
                        "username": "deepak130797",
                        "content": "Heart of this question\\n\\n if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }\\nstring match=check;\\n    reverse(check.begin(),check.end());\\n    if(match==check)\\n    {\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": " if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "0P(zero P) IS FALSE as it will become p0 ( p zero)\nBut a. is true as it will become a \nI Was stuck in two cases \nAlphanumeric are A-Z,A-Z,0-9 we have to remove all the remaining character.\nIf u have problems understanding the function is \nhere is the link for my solution\nhttps://leetcode.com/problems/valid-palindrome/solutions/2944509/simple-easy-solution-optimized-on-time-o1-space/\n\nLink for function that is used-\nhttps://cplusplus.com/reference/cwctype/iswalnum/"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "its giving me a runtime error how can i solve this issue the error is presumptly on line 2!!!!\\n\\nclass Solution:\\n    def isPalindrome (self, s: str) -> bool:\\n        # make list of characters to remove\\n        lst = [\"(\", \"`\", \")\", \",\", \"!\", \" \", \":\", \".\", \";\", \"@\", \"#\", \"_\", \"-\", \"\\'\", \"\\\\\"\", \"{\", \"}\", \"[\", \"]\", \"?\"]\\n        # convert to lowercase\\n        s = s.lower()\\n        # loop through each character\\n        for _ in lst:\\n            # remove by splitting\\n            s = \"\".join(s.split(_))\\n\\n        # compare string with reversed string\\n        return s == s[::-1]"
                    },
                    {
                        "username": "parthgarg123",
                        "content": "why \\'b\\' is being removed in this particular testcase?   \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::toupper);\\n        for(int i=0;i<s.size();i++){\\n            if(!(s[i]>=65 && s[i]<=90 || (s[i]>=48 && s[i]<=57)))\\n            s.erase(i);\\n        }\\n        cout<<s<<endl;\\n        for(int i =0;i<s.size()/2;i++){\\n\\t        if(s[i]!=s[s.size()-i-1])\\n\\t            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\ntestcase:\\n```a.b,.```\\nmy string output is `A`"
                    },
                    {
                        "username": "raunak22",
                        "content": "i myself dealing with the same issue\n"
                    },
                    {
                        "username": "chelsye",
                        "content": " class Solution {\\n  private :\\n  bool valid( char ch){\\n    if( (ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'A\\' && ch <= \\'Z\\') || (ch >= \\'0\\' && ch <= \\'9\\') ){\\n      return 1;\\n    } \\n    return 0;\\n  }\\n  char lowerCase(char ch){\\n    if(( ch >= \\'a\\' && ch <= \\'z\\')  || (ch >= \\'0\\' && ch <= \\'9\\')){\\n      return ch;\\n    }\\n    else{\\n      char temp = ch -\\'A\\' + \\'a\\';\\n      return temp;\\n    }\\n  }\\n bool checkPalindrome(string s){\\n   int st = 0;\\n   int e = s.length() - 1;\\n   \\n   while( st <= e){\\n     if( s[st] != s[e]){\\n             return 0;\\n     }\\n     else{\\n       st ++;\\n       e --;\\n     }\\n   }\\n   return 1;\\n }\\npublic:\\n    bool isPalindrome(string s) {\\n     \\n      string temp = \"\";\\n      for(int i = 0; i< s.length(); i++){\\n        if( valid(s[i])){\\n              temp.push_back(s[i]);\\n        }\\n      }\\n      \\n      for( int j = 0; j < temp.length(); j++){\\n        temp[j] = lowerCase(temp[j]);\\n      }\\n      \\n      return checkPalindrome(temp);\\n    }\\n};"
                    },
                    {
                        "username": "chandupriya_06",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //create an empty string s1 and add only the characters and numbers to this string from original string\\n        // converting it to lower case while adding to s1\\n        // reverse s1\\n        // comparing s1 and s2 returns either 1 or zero\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])||isdigit(s[i])){\\n                s1+=tolower(s[i]);\\n            }\\n        }\\n        string s2=s1;\\n        reverse(s2.begin(),s2.end());\\n\\n    //return(s1==string(s1.rbegin(),s1.rend()));\\n    return(s2==s1);\\n    }\\n};"
                    },
                    {
                        "username": "noone_00002",
                        "content": "As it is mentioned that you don\\'t need to ignore letter and numbers in the problems \\nif((ans.charAt(i)>=\\'a\\'&& ans.charAt(i)<=\\'z\\')||(ans.charAt(i)>=\\'0\\' && ans.charAt(i)<=\\'9\\'))\\n            {\\n                temp.append(ans.charAt(i));\\n            }"
                    },
                    {
                        "username": "devrajgaur",
                        "content": "Simple C++ solution...\\n\\n\\nclass Solution {\\npublic:\\n\\n    char toLowerCase(char ch)\\n    {\\n        // converts all the upper case letters to lower case\\n        if(ch>=\\'a\\' && ch<=\\'z\\')\\n        {\\n            return ch;\\n        }\\n        else\\n        {\\n            char temp = ch - \\'A\\' + \\'a\\';\\n            return temp;\\n        }  \\n    }\\n\\n    bool isValid( char ch )\\n    {\\n        // checks each character of the string if it is valid or not\\n        if( (ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'A\\' && ch<=\\'Z\\') || (ch>=\\'0\\' && ch<=\\'9\\') )\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( isValid( s[i] ) )\\n            {\\n                str.push_back(s[i]);\\n                // if the character is valid in the string then it would be inserted in the newly created string\\n            }\\n        }\\n        int size=str.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end)\\n        {\\n            if( toLowerCase(str[start]) != toLowerCase(str[end]))\\n            {\\n                return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1720296,
                "content": [
                    {
                        "username": "JisanAR",
                        "content": "what is wrong in my code:\\n\\n\\n\\nclass Solution {\\nprivate:\\nchar check_let(char lett){\\n    char let_out =  lett-\\'A\\'+\\'a\\';\\n    return let_out;}\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]>\\'A\\' && s[i]<\\'Z\\' || s[i]>\\'a\\' && s[i]>\\'z\\'){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        if(temp.size()==0){\\n            return 1;\\n        }\\n        int st = 0;\\n    int en = temp.size()-1;\\n    while(st<en){\\n        if(check_let(temp[st])==check_let(temp[en])){\\n            st++;\\n            en--;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}};"
                    },
                    {
                        "username": "deepak130797",
                        "content": "Heart of this question\\n\\n if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }\\nstring match=check;\\n    reverse(check.begin(),check.end());\\n    if(match==check)\\n    {\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": " if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "0P(zero P) IS FALSE as it will become p0 ( p zero)\nBut a. is true as it will become a \nI Was stuck in two cases \nAlphanumeric are A-Z,A-Z,0-9 we have to remove all the remaining character.\nIf u have problems understanding the function is \nhere is the link for my solution\nhttps://leetcode.com/problems/valid-palindrome/solutions/2944509/simple-easy-solution-optimized-on-time-o1-space/\n\nLink for function that is used-\nhttps://cplusplus.com/reference/cwctype/iswalnum/"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "its giving me a runtime error how can i solve this issue the error is presumptly on line 2!!!!\\n\\nclass Solution:\\n    def isPalindrome (self, s: str) -> bool:\\n        # make list of characters to remove\\n        lst = [\"(\", \"`\", \")\", \",\", \"!\", \" \", \":\", \".\", \";\", \"@\", \"#\", \"_\", \"-\", \"\\'\", \"\\\\\"\", \"{\", \"}\", \"[\", \"]\", \"?\"]\\n        # convert to lowercase\\n        s = s.lower()\\n        # loop through each character\\n        for _ in lst:\\n            # remove by splitting\\n            s = \"\".join(s.split(_))\\n\\n        # compare string with reversed string\\n        return s == s[::-1]"
                    },
                    {
                        "username": "parthgarg123",
                        "content": "why \\'b\\' is being removed in this particular testcase?   \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::toupper);\\n        for(int i=0;i<s.size();i++){\\n            if(!(s[i]>=65 && s[i]<=90 || (s[i]>=48 && s[i]<=57)))\\n            s.erase(i);\\n        }\\n        cout<<s<<endl;\\n        for(int i =0;i<s.size()/2;i++){\\n\\t        if(s[i]!=s[s.size()-i-1])\\n\\t            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\ntestcase:\\n```a.b,.```\\nmy string output is `A`"
                    },
                    {
                        "username": "raunak22",
                        "content": "i myself dealing with the same issue\n"
                    },
                    {
                        "username": "chelsye",
                        "content": " class Solution {\\n  private :\\n  bool valid( char ch){\\n    if( (ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'A\\' && ch <= \\'Z\\') || (ch >= \\'0\\' && ch <= \\'9\\') ){\\n      return 1;\\n    } \\n    return 0;\\n  }\\n  char lowerCase(char ch){\\n    if(( ch >= \\'a\\' && ch <= \\'z\\')  || (ch >= \\'0\\' && ch <= \\'9\\')){\\n      return ch;\\n    }\\n    else{\\n      char temp = ch -\\'A\\' + \\'a\\';\\n      return temp;\\n    }\\n  }\\n bool checkPalindrome(string s){\\n   int st = 0;\\n   int e = s.length() - 1;\\n   \\n   while( st <= e){\\n     if( s[st] != s[e]){\\n             return 0;\\n     }\\n     else{\\n       st ++;\\n       e --;\\n     }\\n   }\\n   return 1;\\n }\\npublic:\\n    bool isPalindrome(string s) {\\n     \\n      string temp = \"\";\\n      for(int i = 0; i< s.length(); i++){\\n        if( valid(s[i])){\\n              temp.push_back(s[i]);\\n        }\\n      }\\n      \\n      for( int j = 0; j < temp.length(); j++){\\n        temp[j] = lowerCase(temp[j]);\\n      }\\n      \\n      return checkPalindrome(temp);\\n    }\\n};"
                    },
                    {
                        "username": "chandupriya_06",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //create an empty string s1 and add only the characters and numbers to this string from original string\\n        // converting it to lower case while adding to s1\\n        // reverse s1\\n        // comparing s1 and s2 returns either 1 or zero\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])||isdigit(s[i])){\\n                s1+=tolower(s[i]);\\n            }\\n        }\\n        string s2=s1;\\n        reverse(s2.begin(),s2.end());\\n\\n    //return(s1==string(s1.rbegin(),s1.rend()));\\n    return(s2==s1);\\n    }\\n};"
                    },
                    {
                        "username": "noone_00002",
                        "content": "As it is mentioned that you don\\'t need to ignore letter and numbers in the problems \\nif((ans.charAt(i)>=\\'a\\'&& ans.charAt(i)<=\\'z\\')||(ans.charAt(i)>=\\'0\\' && ans.charAt(i)<=\\'9\\'))\\n            {\\n                temp.append(ans.charAt(i));\\n            }"
                    },
                    {
                        "username": "devrajgaur",
                        "content": "Simple C++ solution...\\n\\n\\nclass Solution {\\npublic:\\n\\n    char toLowerCase(char ch)\\n    {\\n        // converts all the upper case letters to lower case\\n        if(ch>=\\'a\\' && ch<=\\'z\\')\\n        {\\n            return ch;\\n        }\\n        else\\n        {\\n            char temp = ch - \\'A\\' + \\'a\\';\\n            return temp;\\n        }  \\n    }\\n\\n    bool isValid( char ch )\\n    {\\n        // checks each character of the string if it is valid or not\\n        if( (ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'A\\' && ch<=\\'Z\\') || (ch>=\\'0\\' && ch<=\\'9\\') )\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( isValid( s[i] ) )\\n            {\\n                str.push_back(s[i]);\\n                // if the character is valid in the string then it would be inserted in the newly created string\\n            }\\n        }\\n        int size=str.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end)\\n        {\\n            if( toLowerCase(str[start]) != toLowerCase(str[end]))\\n            {\\n                return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1713911,
                "content": [
                    {
                        "username": "JisanAR",
                        "content": "what is wrong in my code:\\n\\n\\n\\nclass Solution {\\nprivate:\\nchar check_let(char lett){\\n    char let_out =  lett-\\'A\\'+\\'a\\';\\n    return let_out;}\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]>\\'A\\' && s[i]<\\'Z\\' || s[i]>\\'a\\' && s[i]>\\'z\\'){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        if(temp.size()==0){\\n            return 1;\\n        }\\n        int st = 0;\\n    int en = temp.size()-1;\\n    while(st<en){\\n        if(check_let(temp[st])==check_let(temp[en])){\\n            st++;\\n            en--;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}};"
                    },
                    {
                        "username": "deepak130797",
                        "content": "Heart of this question\\n\\n if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }\\nstring match=check;\\n    reverse(check.begin(),check.end());\\n    if(match==check)\\n    {\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": " if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "0P(zero P) IS FALSE as it will become p0 ( p zero)\nBut a. is true as it will become a \nI Was stuck in two cases \nAlphanumeric are A-Z,A-Z,0-9 we have to remove all the remaining character.\nIf u have problems understanding the function is \nhere is the link for my solution\nhttps://leetcode.com/problems/valid-palindrome/solutions/2944509/simple-easy-solution-optimized-on-time-o1-space/\n\nLink for function that is used-\nhttps://cplusplus.com/reference/cwctype/iswalnum/"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "its giving me a runtime error how can i solve this issue the error is presumptly on line 2!!!!\\n\\nclass Solution:\\n    def isPalindrome (self, s: str) -> bool:\\n        # make list of characters to remove\\n        lst = [\"(\", \"`\", \")\", \",\", \"!\", \" \", \":\", \".\", \";\", \"@\", \"#\", \"_\", \"-\", \"\\'\", \"\\\\\"\", \"{\", \"}\", \"[\", \"]\", \"?\"]\\n        # convert to lowercase\\n        s = s.lower()\\n        # loop through each character\\n        for _ in lst:\\n            # remove by splitting\\n            s = \"\".join(s.split(_))\\n\\n        # compare string with reversed string\\n        return s == s[::-1]"
                    },
                    {
                        "username": "parthgarg123",
                        "content": "why \\'b\\' is being removed in this particular testcase?   \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::toupper);\\n        for(int i=0;i<s.size();i++){\\n            if(!(s[i]>=65 && s[i]<=90 || (s[i]>=48 && s[i]<=57)))\\n            s.erase(i);\\n        }\\n        cout<<s<<endl;\\n        for(int i =0;i<s.size()/2;i++){\\n\\t        if(s[i]!=s[s.size()-i-1])\\n\\t            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\ntestcase:\\n```a.b,.```\\nmy string output is `A`"
                    },
                    {
                        "username": "raunak22",
                        "content": "i myself dealing with the same issue\n"
                    },
                    {
                        "username": "chelsye",
                        "content": " class Solution {\\n  private :\\n  bool valid( char ch){\\n    if( (ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'A\\' && ch <= \\'Z\\') || (ch >= \\'0\\' && ch <= \\'9\\') ){\\n      return 1;\\n    } \\n    return 0;\\n  }\\n  char lowerCase(char ch){\\n    if(( ch >= \\'a\\' && ch <= \\'z\\')  || (ch >= \\'0\\' && ch <= \\'9\\')){\\n      return ch;\\n    }\\n    else{\\n      char temp = ch -\\'A\\' + \\'a\\';\\n      return temp;\\n    }\\n  }\\n bool checkPalindrome(string s){\\n   int st = 0;\\n   int e = s.length() - 1;\\n   \\n   while( st <= e){\\n     if( s[st] != s[e]){\\n             return 0;\\n     }\\n     else{\\n       st ++;\\n       e --;\\n     }\\n   }\\n   return 1;\\n }\\npublic:\\n    bool isPalindrome(string s) {\\n     \\n      string temp = \"\";\\n      for(int i = 0; i< s.length(); i++){\\n        if( valid(s[i])){\\n              temp.push_back(s[i]);\\n        }\\n      }\\n      \\n      for( int j = 0; j < temp.length(); j++){\\n        temp[j] = lowerCase(temp[j]);\\n      }\\n      \\n      return checkPalindrome(temp);\\n    }\\n};"
                    },
                    {
                        "username": "chandupriya_06",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //create an empty string s1 and add only the characters and numbers to this string from original string\\n        // converting it to lower case while adding to s1\\n        // reverse s1\\n        // comparing s1 and s2 returns either 1 or zero\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])||isdigit(s[i])){\\n                s1+=tolower(s[i]);\\n            }\\n        }\\n        string s2=s1;\\n        reverse(s2.begin(),s2.end());\\n\\n    //return(s1==string(s1.rbegin(),s1.rend()));\\n    return(s2==s1);\\n    }\\n};"
                    },
                    {
                        "username": "noone_00002",
                        "content": "As it is mentioned that you don\\'t need to ignore letter and numbers in the problems \\nif((ans.charAt(i)>=\\'a\\'&& ans.charAt(i)<=\\'z\\')||(ans.charAt(i)>=\\'0\\' && ans.charAt(i)<=\\'9\\'))\\n            {\\n                temp.append(ans.charAt(i));\\n            }"
                    },
                    {
                        "username": "devrajgaur",
                        "content": "Simple C++ solution...\\n\\n\\nclass Solution {\\npublic:\\n\\n    char toLowerCase(char ch)\\n    {\\n        // converts all the upper case letters to lower case\\n        if(ch>=\\'a\\' && ch<=\\'z\\')\\n        {\\n            return ch;\\n        }\\n        else\\n        {\\n            char temp = ch - \\'A\\' + \\'a\\';\\n            return temp;\\n        }  \\n    }\\n\\n    bool isValid( char ch )\\n    {\\n        // checks each character of the string if it is valid or not\\n        if( (ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'A\\' && ch<=\\'Z\\') || (ch>=\\'0\\' && ch<=\\'9\\') )\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( isValid( s[i] ) )\\n            {\\n                str.push_back(s[i]);\\n                // if the character is valid in the string then it would be inserted in the newly created string\\n            }\\n        }\\n        int size=str.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end)\\n        {\\n            if( toLowerCase(str[start]) != toLowerCase(str[end]))\\n            {\\n                return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1708586,
                "content": [
                    {
                        "username": "JisanAR",
                        "content": "what is wrong in my code:\\n\\n\\n\\nclass Solution {\\nprivate:\\nchar check_let(char lett){\\n    char let_out =  lett-\\'A\\'+\\'a\\';\\n    return let_out;}\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]>\\'A\\' && s[i]<\\'Z\\' || s[i]>\\'a\\' && s[i]>\\'z\\'){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        if(temp.size()==0){\\n            return 1;\\n        }\\n        int st = 0;\\n    int en = temp.size()-1;\\n    while(st<en){\\n        if(check_let(temp[st])==check_let(temp[en])){\\n            st++;\\n            en--;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}};"
                    },
                    {
                        "username": "deepak130797",
                        "content": "Heart of this question\\n\\n if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }\\nstring match=check;\\n    reverse(check.begin(),check.end());\\n    if(match==check)\\n    {\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": " if(ch>=\\'A\\' && ch<=\\'Z\\' || ch>=\\'a\\' && ch<=\\'z\\' ||ch>=\\'0\\' && ch<=\\'9\\')\\n        {\\n            st[i]=tolower(st[i]);\\n            check+=st[i];\\n        }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "0P(zero P) IS FALSE as it will become p0 ( p zero)\nBut a. is true as it will become a \nI Was stuck in two cases \nAlphanumeric are A-Z,A-Z,0-9 we have to remove all the remaining character.\nIf u have problems understanding the function is \nhere is the link for my solution\nhttps://leetcode.com/problems/valid-palindrome/solutions/2944509/simple-easy-solution-optimized-on-time-o1-space/\n\nLink for function that is used-\nhttps://cplusplus.com/reference/cwctype/iswalnum/"
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "its giving me a runtime error how can i solve this issue the error is presumptly on line 2!!!!\\n\\nclass Solution:\\n    def isPalindrome (self, s: str) -> bool:\\n        # make list of characters to remove\\n        lst = [\"(\", \"`\", \")\", \",\", \"!\", \" \", \":\", \".\", \";\", \"@\", \"#\", \"_\", \"-\", \"\\'\", \"\\\\\"\", \"{\", \"}\", \"[\", \"]\", \"?\"]\\n        # convert to lowercase\\n        s = s.lower()\\n        # loop through each character\\n        for _ in lst:\\n            # remove by splitting\\n            s = \"\".join(s.split(_))\\n\\n        # compare string with reversed string\\n        return s == s[::-1]"
                    },
                    {
                        "username": "parthgarg123",
                        "content": "why \\'b\\' is being removed in this particular testcase?   \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        transform(s.begin(), s.end(), s.begin(), ::toupper);\\n        for(int i=0;i<s.size();i++){\\n            if(!(s[i]>=65 && s[i]<=90 || (s[i]>=48 && s[i]<=57)))\\n            s.erase(i);\\n        }\\n        cout<<s<<endl;\\n        for(int i =0;i<s.size()/2;i++){\\n\\t        if(s[i]!=s[s.size()-i-1])\\n\\t            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\ntestcase:\\n```a.b,.```\\nmy string output is `A`"
                    },
                    {
                        "username": "raunak22",
                        "content": "i myself dealing with the same issue\n"
                    },
                    {
                        "username": "chelsye",
                        "content": " class Solution {\\n  private :\\n  bool valid( char ch){\\n    if( (ch >= \\'a\\' && ch <= \\'z\\') || (ch >= \\'A\\' && ch <= \\'Z\\') || (ch >= \\'0\\' && ch <= \\'9\\') ){\\n      return 1;\\n    } \\n    return 0;\\n  }\\n  char lowerCase(char ch){\\n    if(( ch >= \\'a\\' && ch <= \\'z\\')  || (ch >= \\'0\\' && ch <= \\'9\\')){\\n      return ch;\\n    }\\n    else{\\n      char temp = ch -\\'A\\' + \\'a\\';\\n      return temp;\\n    }\\n  }\\n bool checkPalindrome(string s){\\n   int st = 0;\\n   int e = s.length() - 1;\\n   \\n   while( st <= e){\\n     if( s[st] != s[e]){\\n             return 0;\\n     }\\n     else{\\n       st ++;\\n       e --;\\n     }\\n   }\\n   return 1;\\n }\\npublic:\\n    bool isPalindrome(string s) {\\n     \\n      string temp = \"\";\\n      for(int i = 0; i< s.length(); i++){\\n        if( valid(s[i])){\\n              temp.push_back(s[i]);\\n        }\\n      }\\n      \\n      for( int j = 0; j < temp.length(); j++){\\n        temp[j] = lowerCase(temp[j]);\\n      }\\n      \\n      return checkPalindrome(temp);\\n    }\\n};"
                    },
                    {
                        "username": "chandupriya_06",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        //create an empty string s1 and add only the characters and numbers to this string from original string\\n        // converting it to lower case while adding to s1\\n        // reverse s1\\n        // comparing s1 and s2 returns either 1 or zero\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])||isdigit(s[i])){\\n                s1+=tolower(s[i]);\\n            }\\n        }\\n        string s2=s1;\\n        reverse(s2.begin(),s2.end());\\n\\n    //return(s1==string(s1.rbegin(),s1.rend()));\\n    return(s2==s1);\\n    }\\n};"
                    },
                    {
                        "username": "noone_00002",
                        "content": "As it is mentioned that you don\\'t need to ignore letter and numbers in the problems \\nif((ans.charAt(i)>=\\'a\\'&& ans.charAt(i)<=\\'z\\')||(ans.charAt(i)>=\\'0\\' && ans.charAt(i)<=\\'9\\'))\\n            {\\n                temp.append(ans.charAt(i));\\n            }"
                    },
                    {
                        "username": "devrajgaur",
                        "content": "Simple C++ solution...\\n\\n\\nclass Solution {\\npublic:\\n\\n    char toLowerCase(char ch)\\n    {\\n        // converts all the upper case letters to lower case\\n        if(ch>=\\'a\\' && ch<=\\'z\\')\\n        {\\n            return ch;\\n        }\\n        else\\n        {\\n            char temp = ch - \\'A\\' + \\'a\\';\\n            return temp;\\n        }  \\n    }\\n\\n    bool isValid( char ch )\\n    {\\n        // checks each character of the string if it is valid or not\\n        if( (ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'A\\' && ch<=\\'Z\\') || (ch>=\\'0\\' && ch<=\\'9\\') )\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool isPalindrome(string s) {\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( isValid( s[i] ) )\\n            {\\n                str.push_back(s[i]);\\n                // if the character is valid in the string then it would be inserted in the newly created string\\n            }\\n        }\\n        int size=str.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end)\\n        {\\n            if( toLowerCase(str[start]) != toLowerCase(str[end]))\\n            {\\n                return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1708056,
                "content": [
                    {
                        "username": "adamb321",
                        "content": "Why doesn\\'t \\\\W work in .replace. \\\\W should be equivalent to [^A-Za-z0-9_] in regular expressions.  It works on all the punctuation except for the underscore and I don\\'t know why that it is. Can someone explain to me why \\\\W doesn\\'t work on underscores when it should? \\n`let str = s.toLowerCase().replace(/\\\\W/gi, \"\");`"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Memory Limit Exceed error in last case ..."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = s.lower()\\n        i, j = 0, len(a)-1\\n        while i < j:\\n            while i < j and not a[i].isalnum():\\n                i+=1\\n            while i < j and not a[j].isalnum():\\n                j-=1\\n            if a[i] != a[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True"
                    },
                    {
                        "username": "user4311T",
                        "content": "Hmmm... \".,\" is a palindrome?\\n\\nString: \".,\"\\nOutput: false\\nExpected: true\\n\\nWho can explain?)\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s because your final string will be empty which palindromic string"
                    },
                    {
                        "username": "Namrath_Vardhan",
                        "content": "Only one test case is getting failed and its is showing memory limit exceeded, can anyone help. My code passed 479cases out of 480 \\n\\n//My code\\n\\n\\nclass Solution {\\npublic:\\nstring helper(string s){\\n    if(s.length()==0)\\n    return \"\";\\n    string str=helper(s.substr(1));\\n    if(s[0]>=\\'A\\'&&s[0]<=\\'Z\\'){\\n        int t=s[0]-\\'A\\';\\n        s[0]=\\'a\\'+t;\\n    }\\n    if(s[0]>=\\'a\\'&&s[0]<=\\'z\\'||s[0]>=\\'0\\'&&s[0]<=\\'9\\'){\\n        return s[0]+str;\\n    }\\n    return str;\\n}\\n    bool isPalindrome(string s) {\\n        string converted=helper(s);\\n        int i=0;\\n        int j=converted.size()-1;\\n        while(i<j){\\n            if(converted[i]!=converted[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "shubhubanachauhan",
                        "content": "Wrong TestCases"
                    },
                    {
                        "username": "IshitPatel",
                        "content": "Does creating a recursive check function in python create a memory exceeded exception for this program? If yes, why does it only happen in python and not something like Java, does it have to do something with how python creates a function?"
                    },
                    {
                        "username": "user2005t",
                        "content": "Kept getting the error for \"0P\". The reason is that palindrome includes both digits and alphabets. "
                    },
                    {
                        "username": "navedkhan8086",
                        "content": "class Solution {\\n    private:\\n// check character is valid or not\\n    int valid(char a){\\n        if((a >= \\'a\\' && a <= \\'z\\' ) || (a >= \\'A\\' && a <= \\'Z\\' ) || (a >= \\'0\\' && a <= \\'9\\' ) ) return 1;\\n\\n        return 0;\\n    }\\n// convert Upper case to lowercase\\n    char conlow(char x){\\n        if((x >= \\'a\\' && x <= \\'z\\' ) || (x >= \\'0\\' && x <= \\'9\\' )){\\n            return x;\\n        }\\n        else{\\n            char temp= x -\\'A\\' + \\'a\\';\\n            return temp;\\n        }\\n    }\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.length();i++){\\n            if(valid(s[i])){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n\\n        int st=0;\\n        int e=temp.length()-1;\\n\\n        while(st<=e){\\n            if(conlow(temp[st]) != conlow(temp[e]))  return false;\\n            st++;\\n            e--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Vaishnavi-More",
                        "content": "Can anyone will tell me what\\'s wrong in my code?\\n\\n `\\n\\nchar lowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'0\\' && ch<=\\'9\\')){\\n            return ch;\\n        }\\n        else if(ch>=\\'A\\' && ch<=\\'Z\\'){\\n            char temp=ch-\\'A\\'+\\'a\\';\\n            return temp;\\n        }\\n        return ch;\\n    }\\n   \\n    bool isPalindrome(string s) {\\n        int len=s.length();\\n       /* for(int i=0; i<len; i++){\\n            s[i]=lowerCase(s[i]);\\n        }*/\\n\\n        int start=0, end=len-1;\\n        while(start<=end){\\n            //Check if s[start] is alphanumeric\\n            if((!s[start]>=\\'a\\' && !s[start]<=\\'z\\') || (!s[start]>=\\'0\\' && !s[start]<=\\'9\\') || (!s[start]>=\\'A\\' && !s[start]<=\\'Z\\')){\\n                start++;\\n            }\\n\\n            //Check if s[end] is alphanumeric\\n            if((!s[end]>=\\'a\\' && !s[end]<=\\'z\\') || (!s[end]>=\\'0\\' && !s[end]<=\\'9\\')|| (!s[end]>=\\'A\\' && !s[end]<=\\'Z\\')){\\n                end--;\\n            }\\n            \\n            //chk if palindrome\\n            if(lowerCase(s[start])!=lowerCase(s[end])){\\n                return false;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n        \\n    }`\\n\\nMy all test cases are getting passed just I am getting error for testcase containing special character. \\ns =\\n\"A man, a plan, a canal: Panama\""
                    }
                ]
            },
            {
                "id": 1706165,
                "content": [
                    {
                        "username": "adamb321",
                        "content": "Why doesn\\'t \\\\W work in .replace. \\\\W should be equivalent to [^A-Za-z0-9_] in regular expressions.  It works on all the punctuation except for the underscore and I don\\'t know why that it is. Can someone explain to me why \\\\W doesn\\'t work on underscores when it should? \\n`let str = s.toLowerCase().replace(/\\\\W/gi, \"\");`"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Memory Limit Exceed error in last case ..."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = s.lower()\\n        i, j = 0, len(a)-1\\n        while i < j:\\n            while i < j and not a[i].isalnum():\\n                i+=1\\n            while i < j and not a[j].isalnum():\\n                j-=1\\n            if a[i] != a[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True"
                    },
                    {
                        "username": "user4311T",
                        "content": "Hmmm... \".,\" is a palindrome?\\n\\nString: \".,\"\\nOutput: false\\nExpected: true\\n\\nWho can explain?)\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s because your final string will be empty which palindromic string"
                    },
                    {
                        "username": "Namrath_Vardhan",
                        "content": "Only one test case is getting failed and its is showing memory limit exceeded, can anyone help. My code passed 479cases out of 480 \\n\\n//My code\\n\\n\\nclass Solution {\\npublic:\\nstring helper(string s){\\n    if(s.length()==0)\\n    return \"\";\\n    string str=helper(s.substr(1));\\n    if(s[0]>=\\'A\\'&&s[0]<=\\'Z\\'){\\n        int t=s[0]-\\'A\\';\\n        s[0]=\\'a\\'+t;\\n    }\\n    if(s[0]>=\\'a\\'&&s[0]<=\\'z\\'||s[0]>=\\'0\\'&&s[0]<=\\'9\\'){\\n        return s[0]+str;\\n    }\\n    return str;\\n}\\n    bool isPalindrome(string s) {\\n        string converted=helper(s);\\n        int i=0;\\n        int j=converted.size()-1;\\n        while(i<j){\\n            if(converted[i]!=converted[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "shubhubanachauhan",
                        "content": "Wrong TestCases"
                    },
                    {
                        "username": "IshitPatel",
                        "content": "Does creating a recursive check function in python create a memory exceeded exception for this program? If yes, why does it only happen in python and not something like Java, does it have to do something with how python creates a function?"
                    },
                    {
                        "username": "user2005t",
                        "content": "Kept getting the error for \"0P\". The reason is that palindrome includes both digits and alphabets. "
                    },
                    {
                        "username": "navedkhan8086",
                        "content": "class Solution {\\n    private:\\n// check character is valid or not\\n    int valid(char a){\\n        if((a >= \\'a\\' && a <= \\'z\\' ) || (a >= \\'A\\' && a <= \\'Z\\' ) || (a >= \\'0\\' && a <= \\'9\\' ) ) return 1;\\n\\n        return 0;\\n    }\\n// convert Upper case to lowercase\\n    char conlow(char x){\\n        if((x >= \\'a\\' && x <= \\'z\\' ) || (x >= \\'0\\' && x <= \\'9\\' )){\\n            return x;\\n        }\\n        else{\\n            char temp= x -\\'A\\' + \\'a\\';\\n            return temp;\\n        }\\n    }\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.length();i++){\\n            if(valid(s[i])){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n\\n        int st=0;\\n        int e=temp.length()-1;\\n\\n        while(st<=e){\\n            if(conlow(temp[st]) != conlow(temp[e]))  return false;\\n            st++;\\n            e--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Vaishnavi-More",
                        "content": "Can anyone will tell me what\\'s wrong in my code?\\n\\n `\\n\\nchar lowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'0\\' && ch<=\\'9\\')){\\n            return ch;\\n        }\\n        else if(ch>=\\'A\\' && ch<=\\'Z\\'){\\n            char temp=ch-\\'A\\'+\\'a\\';\\n            return temp;\\n        }\\n        return ch;\\n    }\\n   \\n    bool isPalindrome(string s) {\\n        int len=s.length();\\n       /* for(int i=0; i<len; i++){\\n            s[i]=lowerCase(s[i]);\\n        }*/\\n\\n        int start=0, end=len-1;\\n        while(start<=end){\\n            //Check if s[start] is alphanumeric\\n            if((!s[start]>=\\'a\\' && !s[start]<=\\'z\\') || (!s[start]>=\\'0\\' && !s[start]<=\\'9\\') || (!s[start]>=\\'A\\' && !s[start]<=\\'Z\\')){\\n                start++;\\n            }\\n\\n            //Check if s[end] is alphanumeric\\n            if((!s[end]>=\\'a\\' && !s[end]<=\\'z\\') || (!s[end]>=\\'0\\' && !s[end]<=\\'9\\')|| (!s[end]>=\\'A\\' && !s[end]<=\\'Z\\')){\\n                end--;\\n            }\\n            \\n            //chk if palindrome\\n            if(lowerCase(s[start])!=lowerCase(s[end])){\\n                return false;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n        \\n    }`\\n\\nMy all test cases are getting passed just I am getting error for testcase containing special character. \\ns =\\n\"A man, a plan, a canal: Panama\""
                    }
                ]
            },
            {
                "id": 1692719,
                "content": [
                    {
                        "username": "adamb321",
                        "content": "Why doesn\\'t \\\\W work in .replace. \\\\W should be equivalent to [^A-Za-z0-9_] in regular expressions.  It works on all the punctuation except for the underscore and I don\\'t know why that it is. Can someone explain to me why \\\\W doesn\\'t work on underscores when it should? \\n`let str = s.toLowerCase().replace(/\\\\W/gi, \"\");`"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Memory Limit Exceed error in last case ..."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = s.lower()\\n        i, j = 0, len(a)-1\\n        while i < j:\\n            while i < j and not a[i].isalnum():\\n                i+=1\\n            while i < j and not a[j].isalnum():\\n                j-=1\\n            if a[i] != a[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True"
                    },
                    {
                        "username": "user4311T",
                        "content": "Hmmm... \".,\" is a palindrome?\\n\\nString: \".,\"\\nOutput: false\\nExpected: true\\n\\nWho can explain?)\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s because your final string will be empty which palindromic string"
                    },
                    {
                        "username": "Namrath_Vardhan",
                        "content": "Only one test case is getting failed and its is showing memory limit exceeded, can anyone help. My code passed 479cases out of 480 \\n\\n//My code\\n\\n\\nclass Solution {\\npublic:\\nstring helper(string s){\\n    if(s.length()==0)\\n    return \"\";\\n    string str=helper(s.substr(1));\\n    if(s[0]>=\\'A\\'&&s[0]<=\\'Z\\'){\\n        int t=s[0]-\\'A\\';\\n        s[0]=\\'a\\'+t;\\n    }\\n    if(s[0]>=\\'a\\'&&s[0]<=\\'z\\'||s[0]>=\\'0\\'&&s[0]<=\\'9\\'){\\n        return s[0]+str;\\n    }\\n    return str;\\n}\\n    bool isPalindrome(string s) {\\n        string converted=helper(s);\\n        int i=0;\\n        int j=converted.size()-1;\\n        while(i<j){\\n            if(converted[i]!=converted[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "shubhubanachauhan",
                        "content": "Wrong TestCases"
                    },
                    {
                        "username": "IshitPatel",
                        "content": "Does creating a recursive check function in python create a memory exceeded exception for this program? If yes, why does it only happen in python and not something like Java, does it have to do something with how python creates a function?"
                    },
                    {
                        "username": "user2005t",
                        "content": "Kept getting the error for \"0P\". The reason is that palindrome includes both digits and alphabets. "
                    },
                    {
                        "username": "navedkhan8086",
                        "content": "class Solution {\\n    private:\\n// check character is valid or not\\n    int valid(char a){\\n        if((a >= \\'a\\' && a <= \\'z\\' ) || (a >= \\'A\\' && a <= \\'Z\\' ) || (a >= \\'0\\' && a <= \\'9\\' ) ) return 1;\\n\\n        return 0;\\n    }\\n// convert Upper case to lowercase\\n    char conlow(char x){\\n        if((x >= \\'a\\' && x <= \\'z\\' ) || (x >= \\'0\\' && x <= \\'9\\' )){\\n            return x;\\n        }\\n        else{\\n            char temp= x -\\'A\\' + \\'a\\';\\n            return temp;\\n        }\\n    }\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.length();i++){\\n            if(valid(s[i])){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n\\n        int st=0;\\n        int e=temp.length()-1;\\n\\n        while(st<=e){\\n            if(conlow(temp[st]) != conlow(temp[e]))  return false;\\n            st++;\\n            e--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Vaishnavi-More",
                        "content": "Can anyone will tell me what\\'s wrong in my code?\\n\\n `\\n\\nchar lowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'0\\' && ch<=\\'9\\')){\\n            return ch;\\n        }\\n        else if(ch>=\\'A\\' && ch<=\\'Z\\'){\\n            char temp=ch-\\'A\\'+\\'a\\';\\n            return temp;\\n        }\\n        return ch;\\n    }\\n   \\n    bool isPalindrome(string s) {\\n        int len=s.length();\\n       /* for(int i=0; i<len; i++){\\n            s[i]=lowerCase(s[i]);\\n        }*/\\n\\n        int start=0, end=len-1;\\n        while(start<=end){\\n            //Check if s[start] is alphanumeric\\n            if((!s[start]>=\\'a\\' && !s[start]<=\\'z\\') || (!s[start]>=\\'0\\' && !s[start]<=\\'9\\') || (!s[start]>=\\'A\\' && !s[start]<=\\'Z\\')){\\n                start++;\\n            }\\n\\n            //Check if s[end] is alphanumeric\\n            if((!s[end]>=\\'a\\' && !s[end]<=\\'z\\') || (!s[end]>=\\'0\\' && !s[end]<=\\'9\\')|| (!s[end]>=\\'A\\' && !s[end]<=\\'Z\\')){\\n                end--;\\n            }\\n            \\n            //chk if palindrome\\n            if(lowerCase(s[start])!=lowerCase(s[end])){\\n                return false;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n        \\n    }`\\n\\nMy all test cases are getting passed just I am getting error for testcase containing special character. \\ns =\\n\"A man, a plan, a canal: Panama\""
                    }
                ]
            },
            {
                "id": 1677745,
                "content": [
                    {
                        "username": "adamb321",
                        "content": "Why doesn\\'t \\\\W work in .replace. \\\\W should be equivalent to [^A-Za-z0-9_] in regular expressions.  It works on all the punctuation except for the underscore and I don\\'t know why that it is. Can someone explain to me why \\\\W doesn\\'t work on underscores when it should? \\n`let str = s.toLowerCase().replace(/\\\\W/gi, \"\");`"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Memory Limit Exceed error in last case ..."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = s.lower()\\n        i, j = 0, len(a)-1\\n        while i < j:\\n            while i < j and not a[i].isalnum():\\n                i+=1\\n            while i < j and not a[j].isalnum():\\n                j-=1\\n            if a[i] != a[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True"
                    },
                    {
                        "username": "user4311T",
                        "content": "Hmmm... \".,\" is a palindrome?\\n\\nString: \".,\"\\nOutput: false\\nExpected: true\\n\\nWho can explain?)\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s because your final string will be empty which palindromic string"
                    },
                    {
                        "username": "Namrath_Vardhan",
                        "content": "Only one test case is getting failed and its is showing memory limit exceeded, can anyone help. My code passed 479cases out of 480 \\n\\n//My code\\n\\n\\nclass Solution {\\npublic:\\nstring helper(string s){\\n    if(s.length()==0)\\n    return \"\";\\n    string str=helper(s.substr(1));\\n    if(s[0]>=\\'A\\'&&s[0]<=\\'Z\\'){\\n        int t=s[0]-\\'A\\';\\n        s[0]=\\'a\\'+t;\\n    }\\n    if(s[0]>=\\'a\\'&&s[0]<=\\'z\\'||s[0]>=\\'0\\'&&s[0]<=\\'9\\'){\\n        return s[0]+str;\\n    }\\n    return str;\\n}\\n    bool isPalindrome(string s) {\\n        string converted=helper(s);\\n        int i=0;\\n        int j=converted.size()-1;\\n        while(i<j){\\n            if(converted[i]!=converted[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "shubhubanachauhan",
                        "content": "Wrong TestCases"
                    },
                    {
                        "username": "IshitPatel",
                        "content": "Does creating a recursive check function in python create a memory exceeded exception for this program? If yes, why does it only happen in python and not something like Java, does it have to do something with how python creates a function?"
                    },
                    {
                        "username": "user2005t",
                        "content": "Kept getting the error for \"0P\". The reason is that palindrome includes both digits and alphabets. "
                    },
                    {
                        "username": "navedkhan8086",
                        "content": "class Solution {\\n    private:\\n// check character is valid or not\\n    int valid(char a){\\n        if((a >= \\'a\\' && a <= \\'z\\' ) || (a >= \\'A\\' && a <= \\'Z\\' ) || (a >= \\'0\\' && a <= \\'9\\' ) ) return 1;\\n\\n        return 0;\\n    }\\n// convert Upper case to lowercase\\n    char conlow(char x){\\n        if((x >= \\'a\\' && x <= \\'z\\' ) || (x >= \\'0\\' && x <= \\'9\\' )){\\n            return x;\\n        }\\n        else{\\n            char temp= x -\\'A\\' + \\'a\\';\\n            return temp;\\n        }\\n    }\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.length();i++){\\n            if(valid(s[i])){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n\\n        int st=0;\\n        int e=temp.length()-1;\\n\\n        while(st<=e){\\n            if(conlow(temp[st]) != conlow(temp[e]))  return false;\\n            st++;\\n            e--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Vaishnavi-More",
                        "content": "Can anyone will tell me what\\'s wrong in my code?\\n\\n `\\n\\nchar lowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'0\\' && ch<=\\'9\\')){\\n            return ch;\\n        }\\n        else if(ch>=\\'A\\' && ch<=\\'Z\\'){\\n            char temp=ch-\\'A\\'+\\'a\\';\\n            return temp;\\n        }\\n        return ch;\\n    }\\n   \\n    bool isPalindrome(string s) {\\n        int len=s.length();\\n       /* for(int i=0; i<len; i++){\\n            s[i]=lowerCase(s[i]);\\n        }*/\\n\\n        int start=0, end=len-1;\\n        while(start<=end){\\n            //Check if s[start] is alphanumeric\\n            if((!s[start]>=\\'a\\' && !s[start]<=\\'z\\') || (!s[start]>=\\'0\\' && !s[start]<=\\'9\\') || (!s[start]>=\\'A\\' && !s[start]<=\\'Z\\')){\\n                start++;\\n            }\\n\\n            //Check if s[end] is alphanumeric\\n            if((!s[end]>=\\'a\\' && !s[end]<=\\'z\\') || (!s[end]>=\\'0\\' && !s[end]<=\\'9\\')|| (!s[end]>=\\'A\\' && !s[end]<=\\'Z\\')){\\n                end--;\\n            }\\n            \\n            //chk if palindrome\\n            if(lowerCase(s[start])!=lowerCase(s[end])){\\n                return false;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n        \\n    }`\\n\\nMy all test cases are getting passed just I am getting error for testcase containing special character. \\ns =\\n\"A man, a plan, a canal: Panama\""
                    }
                ]
            },
            {
                "id": 1655196,
                "content": [
                    {
                        "username": "adamb321",
                        "content": "Why doesn\\'t \\\\W work in .replace. \\\\W should be equivalent to [^A-Za-z0-9_] in regular expressions.  It works on all the punctuation except for the underscore and I don\\'t know why that it is. Can someone explain to me why \\\\W doesn\\'t work on underscores when it should? \\n`let str = s.toLowerCase().replace(/\\\\W/gi, \"\");`"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Memory Limit Exceed error in last case ..."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = s.lower()\\n        i, j = 0, len(a)-1\\n        while i < j:\\n            while i < j and not a[i].isalnum():\\n                i+=1\\n            while i < j and not a[j].isalnum():\\n                j-=1\\n            if a[i] != a[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True"
                    },
                    {
                        "username": "user4311T",
                        "content": "Hmmm... \".,\" is a palindrome?\\n\\nString: \".,\"\\nOutput: false\\nExpected: true\\n\\nWho can explain?)\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s because your final string will be empty which palindromic string"
                    },
                    {
                        "username": "Namrath_Vardhan",
                        "content": "Only one test case is getting failed and its is showing memory limit exceeded, can anyone help. My code passed 479cases out of 480 \\n\\n//My code\\n\\n\\nclass Solution {\\npublic:\\nstring helper(string s){\\n    if(s.length()==0)\\n    return \"\";\\n    string str=helper(s.substr(1));\\n    if(s[0]>=\\'A\\'&&s[0]<=\\'Z\\'){\\n        int t=s[0]-\\'A\\';\\n        s[0]=\\'a\\'+t;\\n    }\\n    if(s[0]>=\\'a\\'&&s[0]<=\\'z\\'||s[0]>=\\'0\\'&&s[0]<=\\'9\\'){\\n        return s[0]+str;\\n    }\\n    return str;\\n}\\n    bool isPalindrome(string s) {\\n        string converted=helper(s);\\n        int i=0;\\n        int j=converted.size()-1;\\n        while(i<j){\\n            if(converted[i]!=converted[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "shubhubanachauhan",
                        "content": "Wrong TestCases"
                    },
                    {
                        "username": "IshitPatel",
                        "content": "Does creating a recursive check function in python create a memory exceeded exception for this program? If yes, why does it only happen in python and not something like Java, does it have to do something with how python creates a function?"
                    },
                    {
                        "username": "user2005t",
                        "content": "Kept getting the error for \"0P\". The reason is that palindrome includes both digits and alphabets. "
                    },
                    {
                        "username": "navedkhan8086",
                        "content": "class Solution {\\n    private:\\n// check character is valid or not\\n    int valid(char a){\\n        if((a >= \\'a\\' && a <= \\'z\\' ) || (a >= \\'A\\' && a <= \\'Z\\' ) || (a >= \\'0\\' && a <= \\'9\\' ) ) return 1;\\n\\n        return 0;\\n    }\\n// convert Upper case to lowercase\\n    char conlow(char x){\\n        if((x >= \\'a\\' && x <= \\'z\\' ) || (x >= \\'0\\' && x <= \\'9\\' )){\\n            return x;\\n        }\\n        else{\\n            char temp= x -\\'A\\' + \\'a\\';\\n            return temp;\\n        }\\n    }\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.length();i++){\\n            if(valid(s[i])){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n\\n        int st=0;\\n        int e=temp.length()-1;\\n\\n        while(st<=e){\\n            if(conlow(temp[st]) != conlow(temp[e]))  return false;\\n            st++;\\n            e--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Vaishnavi-More",
                        "content": "Can anyone will tell me what\\'s wrong in my code?\\n\\n `\\n\\nchar lowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'0\\' && ch<=\\'9\\')){\\n            return ch;\\n        }\\n        else if(ch>=\\'A\\' && ch<=\\'Z\\'){\\n            char temp=ch-\\'A\\'+\\'a\\';\\n            return temp;\\n        }\\n        return ch;\\n    }\\n   \\n    bool isPalindrome(string s) {\\n        int len=s.length();\\n       /* for(int i=0; i<len; i++){\\n            s[i]=lowerCase(s[i]);\\n        }*/\\n\\n        int start=0, end=len-1;\\n        while(start<=end){\\n            //Check if s[start] is alphanumeric\\n            if((!s[start]>=\\'a\\' && !s[start]<=\\'z\\') || (!s[start]>=\\'0\\' && !s[start]<=\\'9\\') || (!s[start]>=\\'A\\' && !s[start]<=\\'Z\\')){\\n                start++;\\n            }\\n\\n            //Check if s[end] is alphanumeric\\n            if((!s[end]>=\\'a\\' && !s[end]<=\\'z\\') || (!s[end]>=\\'0\\' && !s[end]<=\\'9\\')|| (!s[end]>=\\'A\\' && !s[end]<=\\'Z\\')){\\n                end--;\\n            }\\n            \\n            //chk if palindrome\\n            if(lowerCase(s[start])!=lowerCase(s[end])){\\n                return false;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n        \\n    }`\\n\\nMy all test cases are getting passed just I am getting error for testcase containing special character. \\ns =\\n\"A man, a plan, a canal: Panama\""
                    }
                ]
            },
            {
                "id": 1652745,
                "content": [
                    {
                        "username": "adamb321",
                        "content": "Why doesn\\'t \\\\W work in .replace. \\\\W should be equivalent to [^A-Za-z0-9_] in regular expressions.  It works on all the punctuation except for the underscore and I don\\'t know why that it is. Can someone explain to me why \\\\W doesn\\'t work on underscores when it should? \\n`let str = s.toLowerCase().replace(/\\\\W/gi, \"\");`"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Memory Limit Exceed error in last case ..."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = s.lower()\\n        i, j = 0, len(a)-1\\n        while i < j:\\n            while i < j and not a[i].isalnum():\\n                i+=1\\n            while i < j and not a[j].isalnum():\\n                j-=1\\n            if a[i] != a[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True"
                    },
                    {
                        "username": "user4311T",
                        "content": "Hmmm... \".,\" is a palindrome?\\n\\nString: \".,\"\\nOutput: false\\nExpected: true\\n\\nWho can explain?)\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s because your final string will be empty which palindromic string"
                    },
                    {
                        "username": "Namrath_Vardhan",
                        "content": "Only one test case is getting failed and its is showing memory limit exceeded, can anyone help. My code passed 479cases out of 480 \\n\\n//My code\\n\\n\\nclass Solution {\\npublic:\\nstring helper(string s){\\n    if(s.length()==0)\\n    return \"\";\\n    string str=helper(s.substr(1));\\n    if(s[0]>=\\'A\\'&&s[0]<=\\'Z\\'){\\n        int t=s[0]-\\'A\\';\\n        s[0]=\\'a\\'+t;\\n    }\\n    if(s[0]>=\\'a\\'&&s[0]<=\\'z\\'||s[0]>=\\'0\\'&&s[0]<=\\'9\\'){\\n        return s[0]+str;\\n    }\\n    return str;\\n}\\n    bool isPalindrome(string s) {\\n        string converted=helper(s);\\n        int i=0;\\n        int j=converted.size()-1;\\n        while(i<j){\\n            if(converted[i]!=converted[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "shubhubanachauhan",
                        "content": "Wrong TestCases"
                    },
                    {
                        "username": "IshitPatel",
                        "content": "Does creating a recursive check function in python create a memory exceeded exception for this program? If yes, why does it only happen in python and not something like Java, does it have to do something with how python creates a function?"
                    },
                    {
                        "username": "user2005t",
                        "content": "Kept getting the error for \"0P\". The reason is that palindrome includes both digits and alphabets. "
                    },
                    {
                        "username": "navedkhan8086",
                        "content": "class Solution {\\n    private:\\n// check character is valid or not\\n    int valid(char a){\\n        if((a >= \\'a\\' && a <= \\'z\\' ) || (a >= \\'A\\' && a <= \\'Z\\' ) || (a >= \\'0\\' && a <= \\'9\\' ) ) return 1;\\n\\n        return 0;\\n    }\\n// convert Upper case to lowercase\\n    char conlow(char x){\\n        if((x >= \\'a\\' && x <= \\'z\\' ) || (x >= \\'0\\' && x <= \\'9\\' )){\\n            return x;\\n        }\\n        else{\\n            char temp= x -\\'A\\' + \\'a\\';\\n            return temp;\\n        }\\n    }\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.length();i++){\\n            if(valid(s[i])){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n\\n        int st=0;\\n        int e=temp.length()-1;\\n\\n        while(st<=e){\\n            if(conlow(temp[st]) != conlow(temp[e]))  return false;\\n            st++;\\n            e--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Vaishnavi-More",
                        "content": "Can anyone will tell me what\\'s wrong in my code?\\n\\n `\\n\\nchar lowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'0\\' && ch<=\\'9\\')){\\n            return ch;\\n        }\\n        else if(ch>=\\'A\\' && ch<=\\'Z\\'){\\n            char temp=ch-\\'A\\'+\\'a\\';\\n            return temp;\\n        }\\n        return ch;\\n    }\\n   \\n    bool isPalindrome(string s) {\\n        int len=s.length();\\n       /* for(int i=0; i<len; i++){\\n            s[i]=lowerCase(s[i]);\\n        }*/\\n\\n        int start=0, end=len-1;\\n        while(start<=end){\\n            //Check if s[start] is alphanumeric\\n            if((!s[start]>=\\'a\\' && !s[start]<=\\'z\\') || (!s[start]>=\\'0\\' && !s[start]<=\\'9\\') || (!s[start]>=\\'A\\' && !s[start]<=\\'Z\\')){\\n                start++;\\n            }\\n\\n            //Check if s[end] is alphanumeric\\n            if((!s[end]>=\\'a\\' && !s[end]<=\\'z\\') || (!s[end]>=\\'0\\' && !s[end]<=\\'9\\')|| (!s[end]>=\\'A\\' && !s[end]<=\\'Z\\')){\\n                end--;\\n            }\\n            \\n            //chk if palindrome\\n            if(lowerCase(s[start])!=lowerCase(s[end])){\\n                return false;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n        \\n    }`\\n\\nMy all test cases are getting passed just I am getting error for testcase containing special character. \\ns =\\n\"A man, a plan, a canal: Panama\""
                    }
                ]
            },
            {
                "id": 1647746,
                "content": [
                    {
                        "username": "adamb321",
                        "content": "Why doesn\\'t \\\\W work in .replace. \\\\W should be equivalent to [^A-Za-z0-9_] in regular expressions.  It works on all the punctuation except for the underscore and I don\\'t know why that it is. Can someone explain to me why \\\\W doesn\\'t work on underscores when it should? \\n`let str = s.toLowerCase().replace(/\\\\W/gi, \"\");`"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Memory Limit Exceed error in last case ..."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = s.lower()\\n        i, j = 0, len(a)-1\\n        while i < j:\\n            while i < j and not a[i].isalnum():\\n                i+=1\\n            while i < j and not a[j].isalnum():\\n                j-=1\\n            if a[i] != a[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True"
                    },
                    {
                        "username": "user4311T",
                        "content": "Hmmm... \".,\" is a palindrome?\\n\\nString: \".,\"\\nOutput: false\\nExpected: true\\n\\nWho can explain?)\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s because your final string will be empty which palindromic string"
                    },
                    {
                        "username": "Namrath_Vardhan",
                        "content": "Only one test case is getting failed and its is showing memory limit exceeded, can anyone help. My code passed 479cases out of 480 \\n\\n//My code\\n\\n\\nclass Solution {\\npublic:\\nstring helper(string s){\\n    if(s.length()==0)\\n    return \"\";\\n    string str=helper(s.substr(1));\\n    if(s[0]>=\\'A\\'&&s[0]<=\\'Z\\'){\\n        int t=s[0]-\\'A\\';\\n        s[0]=\\'a\\'+t;\\n    }\\n    if(s[0]>=\\'a\\'&&s[0]<=\\'z\\'||s[0]>=\\'0\\'&&s[0]<=\\'9\\'){\\n        return s[0]+str;\\n    }\\n    return str;\\n}\\n    bool isPalindrome(string s) {\\n        string converted=helper(s);\\n        int i=0;\\n        int j=converted.size()-1;\\n        while(i<j){\\n            if(converted[i]!=converted[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "shubhubanachauhan",
                        "content": "Wrong TestCases"
                    },
                    {
                        "username": "IshitPatel",
                        "content": "Does creating a recursive check function in python create a memory exceeded exception for this program? If yes, why does it only happen in python and not something like Java, does it have to do something with how python creates a function?"
                    },
                    {
                        "username": "user2005t",
                        "content": "Kept getting the error for \"0P\". The reason is that palindrome includes both digits and alphabets. "
                    },
                    {
                        "username": "navedkhan8086",
                        "content": "class Solution {\\n    private:\\n// check character is valid or not\\n    int valid(char a){\\n        if((a >= \\'a\\' && a <= \\'z\\' ) || (a >= \\'A\\' && a <= \\'Z\\' ) || (a >= \\'0\\' && a <= \\'9\\' ) ) return 1;\\n\\n        return 0;\\n    }\\n// convert Upper case to lowercase\\n    char conlow(char x){\\n        if((x >= \\'a\\' && x <= \\'z\\' ) || (x >= \\'0\\' && x <= \\'9\\' )){\\n            return x;\\n        }\\n        else{\\n            char temp= x -\\'A\\' + \\'a\\';\\n            return temp;\\n        }\\n    }\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.length();i++){\\n            if(valid(s[i])){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n\\n        int st=0;\\n        int e=temp.length()-1;\\n\\n        while(st<=e){\\n            if(conlow(temp[st]) != conlow(temp[e]))  return false;\\n            st++;\\n            e--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Vaishnavi-More",
                        "content": "Can anyone will tell me what\\'s wrong in my code?\\n\\n `\\n\\nchar lowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'0\\' && ch<=\\'9\\')){\\n            return ch;\\n        }\\n        else if(ch>=\\'A\\' && ch<=\\'Z\\'){\\n            char temp=ch-\\'A\\'+\\'a\\';\\n            return temp;\\n        }\\n        return ch;\\n    }\\n   \\n    bool isPalindrome(string s) {\\n        int len=s.length();\\n       /* for(int i=0; i<len; i++){\\n            s[i]=lowerCase(s[i]);\\n        }*/\\n\\n        int start=0, end=len-1;\\n        while(start<=end){\\n            //Check if s[start] is alphanumeric\\n            if((!s[start]>=\\'a\\' && !s[start]<=\\'z\\') || (!s[start]>=\\'0\\' && !s[start]<=\\'9\\') || (!s[start]>=\\'A\\' && !s[start]<=\\'Z\\')){\\n                start++;\\n            }\\n\\n            //Check if s[end] is alphanumeric\\n            if((!s[end]>=\\'a\\' && !s[end]<=\\'z\\') || (!s[end]>=\\'0\\' && !s[end]<=\\'9\\')|| (!s[end]>=\\'A\\' && !s[end]<=\\'Z\\')){\\n                end--;\\n            }\\n            \\n            //chk if palindrome\\n            if(lowerCase(s[start])!=lowerCase(s[end])){\\n                return false;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n        \\n    }`\\n\\nMy all test cases are getting passed just I am getting error for testcase containing special character. \\ns =\\n\"A man, a plan, a canal: Panama\""
                    }
                ]
            },
            {
                "id": 1632299,
                "content": [
                    {
                        "username": "adamb321",
                        "content": "Why doesn\\'t \\\\W work in .replace. \\\\W should be equivalent to [^A-Za-z0-9_] in regular expressions.  It works on all the punctuation except for the underscore and I don\\'t know why that it is. Can someone explain to me why \\\\W doesn\\'t work on underscores when it should? \\n`let str = s.toLowerCase().replace(/\\\\W/gi, \"\");`"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Memory Limit Exceed error in last case ..."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = s.lower()\\n        i, j = 0, len(a)-1\\n        while i < j:\\n            while i < j and not a[i].isalnum():\\n                i+=1\\n            while i < j and not a[j].isalnum():\\n                j-=1\\n            if a[i] != a[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True"
                    },
                    {
                        "username": "user4311T",
                        "content": "Hmmm... \".,\" is a palindrome?\\n\\nString: \".,\"\\nOutput: false\\nExpected: true\\n\\nWho can explain?)\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s because your final string will be empty which palindromic string"
                    },
                    {
                        "username": "Namrath_Vardhan",
                        "content": "Only one test case is getting failed and its is showing memory limit exceeded, can anyone help. My code passed 479cases out of 480 \\n\\n//My code\\n\\n\\nclass Solution {\\npublic:\\nstring helper(string s){\\n    if(s.length()==0)\\n    return \"\";\\n    string str=helper(s.substr(1));\\n    if(s[0]>=\\'A\\'&&s[0]<=\\'Z\\'){\\n        int t=s[0]-\\'A\\';\\n        s[0]=\\'a\\'+t;\\n    }\\n    if(s[0]>=\\'a\\'&&s[0]<=\\'z\\'||s[0]>=\\'0\\'&&s[0]<=\\'9\\'){\\n        return s[0]+str;\\n    }\\n    return str;\\n}\\n    bool isPalindrome(string s) {\\n        string converted=helper(s);\\n        int i=0;\\n        int j=converted.size()-1;\\n        while(i<j){\\n            if(converted[i]!=converted[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "shubhubanachauhan",
                        "content": "Wrong TestCases"
                    },
                    {
                        "username": "IshitPatel",
                        "content": "Does creating a recursive check function in python create a memory exceeded exception for this program? If yes, why does it only happen in python and not something like Java, does it have to do something with how python creates a function?"
                    },
                    {
                        "username": "user2005t",
                        "content": "Kept getting the error for \"0P\". The reason is that palindrome includes both digits and alphabets. "
                    },
                    {
                        "username": "navedkhan8086",
                        "content": "class Solution {\\n    private:\\n// check character is valid or not\\n    int valid(char a){\\n        if((a >= \\'a\\' && a <= \\'z\\' ) || (a >= \\'A\\' && a <= \\'Z\\' ) || (a >= \\'0\\' && a <= \\'9\\' ) ) return 1;\\n\\n        return 0;\\n    }\\n// convert Upper case to lowercase\\n    char conlow(char x){\\n        if((x >= \\'a\\' && x <= \\'z\\' ) || (x >= \\'0\\' && x <= \\'9\\' )){\\n            return x;\\n        }\\n        else{\\n            char temp= x -\\'A\\' + \\'a\\';\\n            return temp;\\n        }\\n    }\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.length();i++){\\n            if(valid(s[i])){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n\\n        int st=0;\\n        int e=temp.length()-1;\\n\\n        while(st<=e){\\n            if(conlow(temp[st]) != conlow(temp[e]))  return false;\\n            st++;\\n            e--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Vaishnavi-More",
                        "content": "Can anyone will tell me what\\'s wrong in my code?\\n\\n `\\n\\nchar lowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'0\\' && ch<=\\'9\\')){\\n            return ch;\\n        }\\n        else if(ch>=\\'A\\' && ch<=\\'Z\\'){\\n            char temp=ch-\\'A\\'+\\'a\\';\\n            return temp;\\n        }\\n        return ch;\\n    }\\n   \\n    bool isPalindrome(string s) {\\n        int len=s.length();\\n       /* for(int i=0; i<len; i++){\\n            s[i]=lowerCase(s[i]);\\n        }*/\\n\\n        int start=0, end=len-1;\\n        while(start<=end){\\n            //Check if s[start] is alphanumeric\\n            if((!s[start]>=\\'a\\' && !s[start]<=\\'z\\') || (!s[start]>=\\'0\\' && !s[start]<=\\'9\\') || (!s[start]>=\\'A\\' && !s[start]<=\\'Z\\')){\\n                start++;\\n            }\\n\\n            //Check if s[end] is alphanumeric\\n            if((!s[end]>=\\'a\\' && !s[end]<=\\'z\\') || (!s[end]>=\\'0\\' && !s[end]<=\\'9\\')|| (!s[end]>=\\'A\\' && !s[end]<=\\'Z\\')){\\n                end--;\\n            }\\n            \\n            //chk if palindrome\\n            if(lowerCase(s[start])!=lowerCase(s[end])){\\n                return false;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n        \\n    }`\\n\\nMy all test cases are getting passed just I am getting error for testcase containing special character. \\ns =\\n\"A man, a plan, a canal: Panama\""
                    }
                ]
            },
            {
                "id": 1632226,
                "content": [
                    {
                        "username": "adamb321",
                        "content": "Why doesn\\'t \\\\W work in .replace. \\\\W should be equivalent to [^A-Za-z0-9_] in regular expressions.  It works on all the punctuation except for the underscore and I don\\'t know why that it is. Can someone explain to me why \\\\W doesn\\'t work on underscores when it should? \\n`let str = s.toLowerCase().replace(/\\\\W/gi, \"\");`"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Memory Limit Exceed error in last case ..."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = s.lower()\\n        i, j = 0, len(a)-1\\n        while i < j:\\n            while i < j and not a[i].isalnum():\\n                i+=1\\n            while i < j and not a[j].isalnum():\\n                j-=1\\n            if a[i] != a[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True"
                    },
                    {
                        "username": "user4311T",
                        "content": "Hmmm... \".,\" is a palindrome?\\n\\nString: \".,\"\\nOutput: false\\nExpected: true\\n\\nWho can explain?)\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s because your final string will be empty which palindromic string"
                    },
                    {
                        "username": "Namrath_Vardhan",
                        "content": "Only one test case is getting failed and its is showing memory limit exceeded, can anyone help. My code passed 479cases out of 480 \\n\\n//My code\\n\\n\\nclass Solution {\\npublic:\\nstring helper(string s){\\n    if(s.length()==0)\\n    return \"\";\\n    string str=helper(s.substr(1));\\n    if(s[0]>=\\'A\\'&&s[0]<=\\'Z\\'){\\n        int t=s[0]-\\'A\\';\\n        s[0]=\\'a\\'+t;\\n    }\\n    if(s[0]>=\\'a\\'&&s[0]<=\\'z\\'||s[0]>=\\'0\\'&&s[0]<=\\'9\\'){\\n        return s[0]+str;\\n    }\\n    return str;\\n}\\n    bool isPalindrome(string s) {\\n        string converted=helper(s);\\n        int i=0;\\n        int j=converted.size()-1;\\n        while(i<j){\\n            if(converted[i]!=converted[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "shubhubanachauhan",
                        "content": "Wrong TestCases"
                    },
                    {
                        "username": "IshitPatel",
                        "content": "Does creating a recursive check function in python create a memory exceeded exception for this program? If yes, why does it only happen in python and not something like Java, does it have to do something with how python creates a function?"
                    },
                    {
                        "username": "user2005t",
                        "content": "Kept getting the error for \"0P\". The reason is that palindrome includes both digits and alphabets. "
                    },
                    {
                        "username": "navedkhan8086",
                        "content": "class Solution {\\n    private:\\n// check character is valid or not\\n    int valid(char a){\\n        if((a >= \\'a\\' && a <= \\'z\\' ) || (a >= \\'A\\' && a <= \\'Z\\' ) || (a >= \\'0\\' && a <= \\'9\\' ) ) return 1;\\n\\n        return 0;\\n    }\\n// convert Upper case to lowercase\\n    char conlow(char x){\\n        if((x >= \\'a\\' && x <= \\'z\\' ) || (x >= \\'0\\' && x <= \\'9\\' )){\\n            return x;\\n        }\\n        else{\\n            char temp= x -\\'A\\' + \\'a\\';\\n            return temp;\\n        }\\n    }\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.length();i++){\\n            if(valid(s[i])){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n\\n        int st=0;\\n        int e=temp.length()-1;\\n\\n        while(st<=e){\\n            if(conlow(temp[st]) != conlow(temp[e]))  return false;\\n            st++;\\n            e--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Vaishnavi-More",
                        "content": "Can anyone will tell me what\\'s wrong in my code?\\n\\n `\\n\\nchar lowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'0\\' && ch<=\\'9\\')){\\n            return ch;\\n        }\\n        else if(ch>=\\'A\\' && ch<=\\'Z\\'){\\n            char temp=ch-\\'A\\'+\\'a\\';\\n            return temp;\\n        }\\n        return ch;\\n    }\\n   \\n    bool isPalindrome(string s) {\\n        int len=s.length();\\n       /* for(int i=0; i<len; i++){\\n            s[i]=lowerCase(s[i]);\\n        }*/\\n\\n        int start=0, end=len-1;\\n        while(start<=end){\\n            //Check if s[start] is alphanumeric\\n            if((!s[start]>=\\'a\\' && !s[start]<=\\'z\\') || (!s[start]>=\\'0\\' && !s[start]<=\\'9\\') || (!s[start]>=\\'A\\' && !s[start]<=\\'Z\\')){\\n                start++;\\n            }\\n\\n            //Check if s[end] is alphanumeric\\n            if((!s[end]>=\\'a\\' && !s[end]<=\\'z\\') || (!s[end]>=\\'0\\' && !s[end]<=\\'9\\')|| (!s[end]>=\\'A\\' && !s[end]<=\\'Z\\')){\\n                end--;\\n            }\\n            \\n            //chk if palindrome\\n            if(lowerCase(s[start])!=lowerCase(s[end])){\\n                return false;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n        \\n    }`\\n\\nMy all test cases are getting passed just I am getting error for testcase containing special character. \\ns =\\n\"A man, a plan, a canal: Panama\""
                    }
                ]
            },
            {
                "id": 1632092,
                "content": [
                    {
                        "username": "adamb321",
                        "content": "Why doesn\\'t \\\\W work in .replace. \\\\W should be equivalent to [^A-Za-z0-9_] in regular expressions.  It works on all the punctuation except for the underscore and I don\\'t know why that it is. Can someone explain to me why \\\\W doesn\\'t work on underscores when it should? \\n`let str = s.toLowerCase().replace(/\\\\W/gi, \"\");`"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Memory Limit Exceed error in last case ..."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        a = s.lower()\\n        i, j = 0, len(a)-1\\n        while i < j:\\n            while i < j and not a[i].isalnum():\\n                i+=1\\n            while i < j and not a[j].isalnum():\\n                j-=1\\n            if a[i] != a[j]:\\n                return False\\n            i+=1\\n            j-=1\\n        return True"
                    },
                    {
                        "username": "user4311T",
                        "content": "Hmmm... \".,\" is a palindrome?\\n\\nString: \".,\"\\nOutput: false\\nExpected: true\\n\\nWho can explain?)\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s because your final string will be empty which palindromic string"
                    },
                    {
                        "username": "Namrath_Vardhan",
                        "content": "Only one test case is getting failed and its is showing memory limit exceeded, can anyone help. My code passed 479cases out of 480 \\n\\n//My code\\n\\n\\nclass Solution {\\npublic:\\nstring helper(string s){\\n    if(s.length()==0)\\n    return \"\";\\n    string str=helper(s.substr(1));\\n    if(s[0]>=\\'A\\'&&s[0]<=\\'Z\\'){\\n        int t=s[0]-\\'A\\';\\n        s[0]=\\'a\\'+t;\\n    }\\n    if(s[0]>=\\'a\\'&&s[0]<=\\'z\\'||s[0]>=\\'0\\'&&s[0]<=\\'9\\'){\\n        return s[0]+str;\\n    }\\n    return str;\\n}\\n    bool isPalindrome(string s) {\\n        string converted=helper(s);\\n        int i=0;\\n        int j=converted.size()-1;\\n        while(i<j){\\n            if(converted[i]!=converted[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "shubhubanachauhan",
                        "content": "Wrong TestCases"
                    },
                    {
                        "username": "IshitPatel",
                        "content": "Does creating a recursive check function in python create a memory exceeded exception for this program? If yes, why does it only happen in python and not something like Java, does it have to do something with how python creates a function?"
                    },
                    {
                        "username": "user2005t",
                        "content": "Kept getting the error for \"0P\". The reason is that palindrome includes both digits and alphabets. "
                    },
                    {
                        "username": "navedkhan8086",
                        "content": "class Solution {\\n    private:\\n// check character is valid or not\\n    int valid(char a){\\n        if((a >= \\'a\\' && a <= \\'z\\' ) || (a >= \\'A\\' && a <= \\'Z\\' ) || (a >= \\'0\\' && a <= \\'9\\' ) ) return 1;\\n\\n        return 0;\\n    }\\n// convert Upper case to lowercase\\n    char conlow(char x){\\n        if((x >= \\'a\\' && x <= \\'z\\' ) || (x >= \\'0\\' && x <= \\'9\\' )){\\n            return x;\\n        }\\n        else{\\n            char temp= x -\\'A\\' + \\'a\\';\\n            return temp;\\n        }\\n    }\\npublic:\\n    bool isPalindrome(string s) {\\n        string temp;\\n        for(int i=0;i<s.length();i++){\\n            if(valid(s[i])){\\n                temp.push_back(s[i]);\\n            }\\n        }\\n\\n        int st=0;\\n        int e=temp.length()-1;\\n\\n        while(st<=e){\\n            if(conlow(temp[st]) != conlow(temp[e]))  return false;\\n            st++;\\n            e--;\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Vaishnavi-More",
                        "content": "Can anyone will tell me what\\'s wrong in my code?\\n\\n `\\n\\nchar lowerCase(char ch){\\n        if((ch>=\\'a\\' && ch<=\\'z\\') || (ch>=\\'0\\' && ch<=\\'9\\')){\\n            return ch;\\n        }\\n        else if(ch>=\\'A\\' && ch<=\\'Z\\'){\\n            char temp=ch-\\'A\\'+\\'a\\';\\n            return temp;\\n        }\\n        return ch;\\n    }\\n   \\n    bool isPalindrome(string s) {\\n        int len=s.length();\\n       /* for(int i=0; i<len; i++){\\n            s[i]=lowerCase(s[i]);\\n        }*/\\n\\n        int start=0, end=len-1;\\n        while(start<=end){\\n            //Check if s[start] is alphanumeric\\n            if((!s[start]>=\\'a\\' && !s[start]<=\\'z\\') || (!s[start]>=\\'0\\' && !s[start]<=\\'9\\') || (!s[start]>=\\'A\\' && !s[start]<=\\'Z\\')){\\n                start++;\\n            }\\n\\n            //Check if s[end] is alphanumeric\\n            if((!s[end]>=\\'a\\' && !s[end]<=\\'z\\') || (!s[end]>=\\'0\\' && !s[end]<=\\'9\\')|| (!s[end]>=\\'A\\' && !s[end]<=\\'Z\\')){\\n                end--;\\n            }\\n            \\n            //chk if palindrome\\n            if(lowerCase(s[start])!=lowerCase(s[end])){\\n                return false;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n        \\n    }`\\n\\nMy all test cases are getting passed just I am getting error for testcase containing special character. \\ns =\\n\"A man, a plan, a canal: Panama\""
                    }
                ]
            }
        ]
    },
    {
        "title": "Implement Stack using Queues",
        "question_content": "<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>\n\n<p>Implement the <code>MyStack</code> class:</p>\n\n<ul>\n\t<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>\n\t<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>\n\t<li><code>int top()</code> Returns the element on the top of the stack.</li>\n\t<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>\n</ul>\n\n<p><b>Notes:</b></p>\n\n<ul>\n\t<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&#39;s standard operations.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n<strong>Output</strong>\n[null, null, null, 2, 2, false]\n\n<strong>Explanation</strong>\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>empty</code>.</li>\n\t<li>All the calls to <code>pop</code> and <code>top</code> are valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you implement the stack using only one queue?</p>\n",
        "solutions": [
            {
                "id": 62527,
                "title": "a-simple-c-solution",
                "content": "\\tclass Stack {\\n\\tpublic:\\n\\t\\tqueue<int> que;\\n\\t\\t// Push element x onto stack.\\n\\t\\tvoid push(int x) {\\n\\t\\t\\tque.push(x);\\n\\t\\t\\tfor(int i=0;i<que.size()-1;++i){\\n\\t\\t\\t\\tque.push(que.front());\\n\\t\\t\\t\\tque.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Removes the element on top of the stack.\\n\\t\\tvoid pop() {\\n\\t\\t\\tque.pop();\\n\\t\\t}\\n\\n\\t\\t// Get the top element.\\n\\t\\tint top() {\\n\\t\\t\\treturn que.front();\\n\\t\\t}\\n\\n\\t\\t// Return whether the stack is empty.\\n\\t\\tbool empty() {\\n\\t\\t\\treturn que.empty();\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "\\tclass Stack {\\n\\tpublic:\\n\\t\\tqueue<int> que;\\n\\t\\t// Push element x onto stack.\\n\\t\\tvoid push(int x) {\\n\\t\\t\\tque.push(x);\\n\\t\\t\\tfor(int i=0;i<que.size()-1;++i){\\n\\t\\t\\t\\tque.push(que.front());\\n\\t\\t\\t\\tque.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Removes the element on top of the stack.\\n\\t\\tvoid pop() {\\n\\t\\t\\tque.pop();\\n\\t\\t}\\n\\n\\t\\t// Get the top element.\\n\\t\\tint top() {\\n\\t\\t\\treturn que.front();\\n\\t\\t}\\n\\n\\t\\t// Return whether the stack is empty.\\n\\t\\tbool empty() {\\n\\t\\t\\treturn que.empty();\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 62516,
                "title": "concise-1-queue-java-c-python",
                "content": "**Explanation:**\\n\\nJust use a queue where you *\"push to front\"* by pushing to back and then rotating the queue until the new element is at the front (i.e., size-1 times move the front element to the back).\\n\\n---\\n\\n**C++:** 0 ms\\n\\n    class Stack {\\n        queue<int> q;\\n    public:\\n        void push(int x) {\\n            q.push(x);\\n            for (int i=1; i<q.size(); i++) {\\n                q.push(q.front());\\n                q.pop();\\n            }\\n        }\\n    \\n        void pop() {\\n            q.pop();\\n        }\\n    \\n        int top() {\\n            return q.front();\\n        }\\n    \\n        bool empty() {\\n            return q.empty();\\n        }\\n    };\\n\\n---\\n\\n**Java:** 140 ms\\n\\n    class MyStack {\\n    \\n        private Queue<Integer> queue = new LinkedList<>();\\n    \\n        public void push(int x) {\\n            queue.add(x);\\n            for (int i=1; i<queue.size(); i++)\\n                queue.add(queue.remove());\\n        }\\n    \\n        public void pop() {\\n            queue.remove();\\n        }\\n    \\n        public int top() {\\n            return queue.peek();\\n        }\\n    \\n        public boolean empty() {\\n            return queue.isEmpty();\\n        }\\n    }\\n\\n---\\n\\n**Python:** 36 ms\\n\\n    class Stack:\\n    \\n        def __init__(self):\\n            self._queue = collections.deque()\\n    \\n        def push(self, x):\\n            q = self._queue\\n            q.append(x)\\n            for _ in range(len(q) - 1):\\n                q.append(q.popleft())\\n            \\n        def pop(self):\\n            return self._queue.popleft()\\n    \\n        def top(self):\\n            return self._queue[0]\\n        \\n        def empty(self):\\n            return not len(self._queue)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "**Explanation:**\\n\\nJust use a queue where you *\"push to front\"* by pushing to back and then rotating the queue until the new element is at the front (i.e., size-1 times move the front element to the back).\\n\\n---\\n\\n**C++:** 0 ms\\n\\n    class Stack {\\n        queue<int> q;\\n    public:\\n        void push(int x) {\\n            q.push(x);\\n            for (int i=1; i<q.size(); i++) {\\n                q.push(q.front());\\n                q.pop();\\n            }\\n        }\\n    \\n        void pop() {\\n            q.pop();\\n        }\\n    \\n        int top() {\\n            return q.front();\\n        }\\n    \\n        bool empty() {\\n            return q.empty();\\n        }\\n    };\\n\\n---\\n\\n**Java:** 140 ms\\n\\n    class MyStack {\\n    \\n        private Queue<Integer> queue = new LinkedList<>();\\n    \\n        public void push(int x) {\\n            queue.add(x);\\n            for (int i=1; i<queue.size(); i++)\\n                queue.add(queue.remove());\\n        }\\n    \\n        public void pop() {\\n            queue.remove();\\n        }\\n    \\n        public int top() {\\n            return queue.peek();\\n        }\\n    \\n        public boolean empty() {\\n            return queue.isEmpty();\\n        }\\n    }\\n\\n---\\n\\n**Python:** 36 ms\\n\\n    class Stack:\\n    \\n        def __init__(self):\\n            self._queue = collections.deque()\\n    \\n        def push(self, x):\\n            q = self._queue\\n            q.append(x)\\n            for _ in range(len(q) - 1):\\n                q.append(q.popleft())\\n            \\n        def pop(self):\\n            return self._queue.popleft()\\n    \\n        def top(self):\\n            return self._queue[0]\\n        \\n        def empty(self):\\n            return not len(self._queue)",
                "codeTag": "Java"
            },
            {
                "id": 62519,
                "title": "only-push-is-o-n-others-are-o-1-using-one-queue-combination-of-two-shared-solutions",
                "content": "    class MyStack \\n    {\\n        Queue<Integer> queue;\\n        \\n        public MyStack()\\n        {\\n            this.queue=new LinkedList<Integer>();\\n        }\\n        \\n        // Push element x onto stack.\\n        public void push(int x) \\n        {\\n           queue.add(x);\\n           for(int i=0;i<queue.size()-1;i++)\\n           {\\n               queue.add(queue.poll());\\n           }\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void pop() \\n        {\\n            queue.poll();\\n        }\\n    \\n        // Get the top element.\\n        public int top() \\n        {\\n            return queue.peek();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public boolean empty() \\n        {\\n            return queue.isEmpty();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    class MyStack \\n    {\\n        Queue<Integer> queue;\\n        \\n        public MyStack()\\n        {\\n            this.queue=new LinkedList<Integer>();\\n        }\\n        \\n        // Push element x onto stack.\\n        public void push(int x) \\n        {\\n           queue.add(x);\\n           for(int i=0;i<queue.size()-1;i++)\\n           {\\n               queue.add(queue.poll());\\n           }\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void pop() \\n        {\\n            queue.poll();\\n        }\\n    \\n        // Get the top element.\\n        public int top() \\n        {\\n            return queue.peek();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public boolean empty() \\n        {\\n            return queue.isEmpty();\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 62522,
                "title": "o-1-purely-with-queues",
                "content": "**Note that I truly only use the allowed queue operations.** While I use `LinkedList`, I'm not using it as such. I only use it because in Java, `Queue` is only an interface and there is no class `Queue` (see [All Known Implementing Classes](https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html)).\\n\\nWhat I do is I that I **simulate** a linked list stack purely with queues. Each queue only has two elements: an integer at the front and another queue at the back (that's where the remaining integers/queues live).\\n\\n**Yes, I know this is silly :-)**  \\nThen again, forbidding to use stacks/vectors/etc is silly to begin with. Also, it's not actually silly if you consider that it's O(1) and thus much *better* than the usual O(n) solutions (and btw I did also write [some of those](https://leetcode.com/discuss/39814/easy-java-c-python)).\\n\\n    class MyStack {\\n    \\n        private Queue queue;\\n    \\n        public void push(int x) {\\n            Queue q = new LinkedList();     // could be any queue type, see note above\\n            q.add(x);\\n            q.add(queue);\\n            queue = q;\\n        }\\n    \\n        public void pop() {\\n            queue.remove();\\n            queue = (Queue) queue.peek();\\n        }\\n    \\n        public int top() {\\n            return (int) queue.peek();\\n        }\\n    \\n        public boolean empty() {\\n            return queue == null;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Note that I truly only use the allowed queue operations.** While I use `LinkedList`, I'm not using it as such. I only use it because in Java, `Queue` is only an interface and there is no class `Queue` (see [All Known Implementing Classes](https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html)).\\n\\nWhat I do is I that I **simulate** a linked list stack purely with queues. Each queue only has two elements: an integer at the front and another queue at the back (that's where the remaining integers/queues live).\\n\\n**Yes, I know this is silly :-)**  \\nThen again, forbidding to use stacks/vectors/etc is silly to begin with. Also, it's not actually silly if you consider that it's O(1) and thus much *better* than the usual O(n) solutions (and btw I did also write [some of those](https://leetcode.com/discuss/39814/easy-java-c-python)).\\n\\n    class MyStack {\\n    \\n        private Queue queue;\\n    \\n        public void push(int x) {\\n            Queue q = new LinkedList();     // could be any queue type, see note above\\n            q.add(x);\\n            q.add(queue);\\n            queue = q;\\n        }\\n    \\n        public void pop() {\\n            queue.remove();\\n            queue = (Queue) queue.peek();\\n        }\\n    \\n        public int top() {\\n            return (int) queue.peek();\\n        }\\n    \\n        public boolean empty() {\\n            return queue == null;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 62533,
                "title": "java-solutions-about-three-ways-one-of-which-utilizes-one-queue-and-the-others-utilize-two-queues",
                "content": "First, let's see the most easiest way: one queue.\\nIn this method,  the point is that after you add one element to the queue, rotate the queue to make the tail be the head.\\n\\n    class MyStack {\\n    \\n    //one Queue solution\\n    private Queue<Integer> q = new LinkedList<Integer>();\\n    \\n    // Push element x onto stack.\\n    public void push(int x) {\\n        q.add(x);\\n        for(int i = 1; i < q.size(); i ++) { //rotate the queue to make the tail be the head\\n            q.add(q.poll());\\n        }\\n    }\\n\\n    // Removes the element on top of the stack.\\n    public void pop() {\\n        q.poll();\\n    }\\n\\n    // Get the top element.\\n    public int top() {\\n        return q.peek();        \\n    }\\n\\n    // Return whether the stack is empty.\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n    }\\n\\nThen, two queue ways.\\n\\n1  Push method is inefficient.\\n\\nwhen you push an element, choose one empty queue(whichever when both are empty) to add this element, and then push all elements of the other queue into the chosen queue. After that, the newest element is at the head of the chosen queue so that whenever you want to do pop() or top(), you always get the newest element.\\n\\nFor example,\\n\\npush(1):\\n\\n[ , ,1]    [ , , ]\\n\\npush(2):\\n\\n[ , , ]   [ ,1,2]\\n\\npush(3):\\n\\n[ 1, 2,3 ] [ , , ] \\n\\n\\n    class MyStack {\\n    //using two queue. The push is inefficient.\\n    private Queue<Integer> q1 = new LinkedList<Integer>();\\n    private Queue<Integer> q2 = new LinkedList<Integer>();\\n    public void push(int x) {\\n        if(q1.isEmpty()) {\\n            q1.add(x);\\n            for(int i = 0; i < q2.size(); i ++)\\n                q1.add(q2.poll());\\n        }else {\\n            q2.add(x);\\n            for(int i = 0; i < q1.size(); i++)\\n                q2.add(q1.poll());\\n        }\\n    }\\n    \\n    public void pop() {\\n        if(!q1.isEmpty()) \\n            q1.poll();\\n        else\\n            q2.poll();\\n    }\\n    public int top() {\\n        return q1.isEmpty() ? q2.peek() : q1.peek();\\n    }\\n    public boolean empty() {\\n        return q1.isEmpty() && q2.isEmpty();\\n    }\\n    }\\n\\n2 pop() and top() are inefficient\\n\\nWhen you push elements, choose a queue which is not empty(whichever when both are empty).\\nWhen you do pop() or top(), first pop all elements of the queue except the tail into another empty queue, and then pop the tail which is your want.\\n\\nFor example:\\n\\npush(1):\\n\\n[ , , 1] [ , , ]\\n\\npush(2):\\n\\n[ ,2,1] [ , , ]\\n\\ntop();\\n\\n[ , , 2] [ , ,1] -> [ , , ] [ ,2,1]\\n\\npop():\\n\\n[ , , 1] [ , ,2]  -> [ , ,1] [ , , ]\\n\\npush(3) :\\n \\n[ ,3,1] [ , , ]\\n\\n    class MyStack{\\n    //using two queue. The pop and top are inefficient.\\n    private Queue<Integer> q1 = new LinkedList<Integer>();\\n    private Queue<Integer> q2 = new LinkedList<Integer>();\\n    public void push(int x) {\\n        if(!q1.isEmpty()) \\n            q1.add(x);\\n        else\\n            q2.add(x);\\n    }\\n    public void pop() {\\n        if(q1.isEmpty()) {\\n            int size = q2.size();\\n            for(int i = 1; i < size; i ++) {\\n                q1.add(q2.poll());\\n            }\\n            q2.poll();\\n        }else {\\n            int size = q1.size();\\n            for(int i = 1; i < size; i ++) {\\n                q2.add(q1.poll());\\n            }\\n            q1.poll();\\n        }\\n    }\\n    public int top() {\\n        int res;\\n        if(q1.isEmpty()) {\\n            int size = q2.size();\\n            for(int i = 1; i < size; i ++) {\\n                q1.add(q2.poll());\\n            }\\n            res = q2.poll();\\n            q1.add(res);\\n        }else {\\n            int size = q1.size();\\n            for(int i = 1; i < size; i ++) {\\n                q2.add(q1.poll());\\n            }\\n            res = q1.poll();\\n            q2.add(res);\\n        }\\n        return res;\\n    }\\n    public boolean empty() {\\n        return q1.isEmpty() && q2.isEmpty();\\n    }\\n    }",
                "solutionTags": [],
                "code": "First, let's see the most easiest way: one queue.\\nIn this method,  the point is that after you add one element to the queue, rotate the queue to make the tail be the head.\\n\\n    class MyStack {\\n    \\n    //one Queue solution\\n    private Queue<Integer> q = new LinkedList<Integer>();\\n    \\n    // Push element x onto stack.\\n    public void push(int x) {\\n        q.add(x);\\n        for(int i = 1; i < q.size(); i ++) { //rotate the queue to make the tail be the head\\n            q.add(q.poll());\\n        }\\n    }\\n\\n    // Removes the element on top of the stack.\\n    public void pop() {\\n        q.poll();\\n    }\\n\\n    // Get the top element.\\n    public int top() {\\n        return q.peek();        \\n    }\\n\\n    // Return whether the stack is empty.\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n    }\\n\\nThen, two queue ways.\\n\\n1  Push method is inefficient.\\n\\nwhen you push an element, choose one empty queue(whichever when both are empty) to add this element, and then push all elements of the other queue into the chosen queue. After that, the newest element is at the head of the chosen queue so that whenever you want to do pop() or top(), you always get the newest element.\\n\\nFor example,\\n\\npush(1):\\n\\n[ , ,1]    [ , , ]\\n\\npush(2):\\n\\n[ , , ]   [ ,1,2]\\n\\npush(3):\\n\\n[ 1, 2,3 ] [ , , ] \\n\\n\\n    class MyStack {\\n    //using two queue. The push is inefficient.\\n    private Queue<Integer> q1 = new LinkedList<Integer>();\\n    private Queue<Integer> q2 = new LinkedList<Integer>();\\n    public void push(int x) {\\n        if(q1.isEmpty()) {\\n            q1.add(x);\\n            for(int i = 0; i < q2.size(); i ++)\\n                q1.add(q2.poll());\\n        }else {\\n            q2.add(x);\\n            for(int i = 0; i < q1.size(); i++)\\n                q2.add(q1.poll());\\n        }\\n    }\\n    \\n    public void pop() {\\n        if(!q1.isEmpty()) \\n            q1.poll();\\n        else\\n            q2.poll();\\n    }\\n    public int top() {\\n        return q1.isEmpty() ? q2.peek() : q1.peek();\\n    }\\n    public boolean empty() {\\n        return q1.isEmpty() && q2.isEmpty();\\n    }\\n    }\\n\\n2 pop() and top() are inefficient\\n\\nWhen you push elements, choose a queue which is not empty(whichever when both are empty).\\nWhen you do pop() or top(), first pop all elements of the queue except the tail into another empty queue, and then pop the tail which is your want.\\n\\nFor example:\\n\\npush(1):\\n\\n[ , , 1] [ , , ]\\n\\npush(2):\\n\\n[ ,2,1] [ , , ]\\n\\ntop();\\n\\n[ , , 2] [ , ,1] -> [ , , ] [ ,2,1]\\n\\npop():\\n\\n[ , , 1] [ , ,2]  -> [ , ,1] [ , , ]\\n\\npush(3) :\\n \\n[ ,3,1] [ , , ]\\n\\n    class MyStack{\\n    //using two queue. The pop and top are inefficient.\\n    private Queue<Integer> q1 = new LinkedList<Integer>();\\n    private Queue<Integer> q2 = new LinkedList<Integer>();\\n    public void push(int x) {\\n        if(!q1.isEmpty()) \\n            q1.add(x);\\n        else\\n            q2.add(x);\\n    }\\n    public void pop() {\\n        if(q1.isEmpty()) {\\n            int size = q2.size();\\n            for(int i = 1; i < size; i ++) {\\n                q1.add(q2.poll());\\n            }\\n            q2.poll();\\n        }else {\\n            int size = q1.size();\\n            for(int i = 1; i < size; i ++) {\\n                q2.add(q1.poll());\\n            }\\n            q1.poll();\\n        }\\n    }\\n    public int top() {\\n        int res;\\n        if(q1.isEmpty()) {\\n            int size = q2.size();\\n            for(int i = 1; i < size; i ++) {\\n                q1.add(q2.poll());\\n            }\\n            res = q2.poll();\\n            q1.add(res);\\n        }else {\\n            int size = q1.size();\\n            for(int i = 1; i < size; i ++) {\\n                q2.add(q1.poll());\\n            }\\n            res = q1.poll();\\n            q2.add(res);\\n        }\\n        return res;\\n    }\\n    public boolean empty() {\\n        return q1.isEmpty() && q2.isEmpty();\\n    }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 765739,
                "title": "c-100-00-2-queues-100-00-1-queue-easy-to-understand",
                "content": "***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Implement Stack using Queues.\\nMemory Usage: 7.1 MB, less than 24.45% of C++ online submissions for Implement Stack using Queues.***\\n```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front());    q1.pop();\\n        }\\n        swap(q1, q2);\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```\\n\\n***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Implement Stack using Queues.\\nMemory Usage: 6.9 MB, less than 84.44% of C++ online submissions for Implement Stack using Queues.***\\n```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    queue<int> q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        int sz = q1.size();\\n        q1.push(x);\\n        while(sz--){\\n            q1.push(q1.front());\\n            q1.pop();\\n        }\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front());    q1.pop();\\n        }\\n        swap(q1, q2);\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```\n```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    queue<int> q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        int sz = q1.size();\\n        q1.push(x);\\n        while(sz--){\\n            q1.push(q1.front());\\n            q1.pop();\\n        }\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62580,
                "title": "accepted-clean-java-solution",
                "content": "      class MyStack {\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        \\n        // Push element x onto stack.\\n        public void push(int x) {\\n            q.add(x);\\n            \\n            int n = q.size();\\n            while (n-- > 1)\\n                q.add(q.poll());\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void pop() {\\n            q.poll();\\n        }\\n    \\n        // Get the top element.\\n        public int top() {\\n            return q.peek();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public boolean empty() {\\n            return q.isEmpty();\\n        }\\n    \\n      }",
                "solutionTags": [
                    "Java"
                ],
                "code": "      class MyStack {\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        \\n        // Push element x onto stack.\\n        public void push(int x) {\\n            q.add(x);\\n            \\n            int n = q.size();\\n            while (n-- > 1)\\n                q.add(q.poll());\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void pop() {\\n            q.poll();\\n        }\\n    \\n        // Get the top element.\\n        public int top() {\\n            return q.peek();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public boolean empty() {\\n            return q.isEmpty();\\n        }\\n    \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 381976,
                "title": "python-solutions",
                "content": "# Single queue\\n\\npush executes in `O(n)` as we need to re-order the elemets so as to have the top of the stack at the front of the queue. Below two implementations. The first create a new list with the pushed element at the front and copies the old list. The old list is garbage collected. The second implementation use the same list and rotate 1 element at a time until the top of the stack is at the front.\\n\\n```python\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.queue = deque()\\n        \\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        tmp = deque([x])\\n        tmp.extend(self.queue)\\n        self.queue = tmp\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        return self.queue.popleft()\\n        \\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        return self.queue[0]\\n        \\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        return len(self.queue) == 0\\n```\\n\\n```python\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        self.q.append(x)\\n        q_len = len(self.q)\\n        while q_len > 1:\\n            self.q.append(self.q.popleft())\\n            q_len -= 1\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        return self.q.popleft()\\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        return self.q[0]\\n        \\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        return len(self.q) == 0\\n```\\n\\n# Two queues\\n\\nStreamlining the push operation to `O(1)` and trading off pop to `O(n)`.\\n\\n```python\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.q1 = deque()\\n        self.q2 = deque()\\n        self._top = None\\n        \\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        self.q1.append(x)\\n        self._top = x\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        while len(self.q1) > 1:\\n            self._top = self.q1.popleft()\\n            self.q2.append(self._top)\\n        result = self.q1.popleft()\\n        self.q1, self.q2 = self.q2, self.q1\\n        return result\\n        \\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        return self._top\\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        return len(self.q1) == 0\\n```\\n\\nStreamlining pop to `O(1)` and trading off push to `O(n)`.\\n\\n```python\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.q1 = deque()\\n        self.q2 = deque()\\n        self._top = None\\n        \\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        self.q2.append(x)\\n        self._top = x\\n        while self.q1:\\n            self.q2.append(self.q1.popleft())\\n        self.q1, self.q2 = self.q2, self.q1\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        result = self.q1.popleft()\\n        if self.q1:\\n            self._top = self.q1[0]\\n        return result\\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        return self._top\\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        return len(self.q1) == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.queue = deque()\\n        \\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        tmp = deque([x])\\n        tmp.extend(self.queue)\\n        self.queue = tmp\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        return self.queue.popleft()\\n        \\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        return self.queue[0]\\n        \\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        return len(self.queue) == 0\\n```\n```python\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        self.q.append(x)\\n        q_len = len(self.q)\\n        while q_len > 1:\\n            self.q.append(self.q.popleft())\\n            q_len -= 1\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        return self.q.popleft()\\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        return self.q[0]\\n        \\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        return len(self.q) == 0\\n```\n```python\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.q1 = deque()\\n        self.q2 = deque()\\n        self._top = None\\n        \\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        self.q1.append(x)\\n        self._top = x\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        while len(self.q1) > 1:\\n            self._top = self.q1.popleft()\\n            self.q2.append(self._top)\\n        result = self.q1.popleft()\\n        self.q1, self.q2 = self.q2, self.q1\\n        return result\\n        \\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        return self._top\\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        return len(self.q1) == 0\\n```\n```python\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.q1 = deque()\\n        self.q2 = deque()\\n        self._top = None\\n        \\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        self.q2.append(x)\\n        self._top = x\\n        while self.q1:\\n            self.q2.append(self.q1.popleft())\\n        self.q1, self.q2 = self.q2, self.q1\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        result = self.q1.popleft()\\n        if self.q1:\\n            self._top = self.q1[0]\\n        return result\\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        return self._top\\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        return len(self.q1) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969470,
                "title": "99-74-one-queue-approach",
                "content": "# Interview Guide - Implement Stack using Queues:\\n\\n## Problem Understanding\\n\\n### **Description**:  \\nThe task is to implement a stack (Last In, First Out - LIFO) using queues. The stack should support the following functions: `push`, `pop`, `top`, and `empty`. These operations should behave just as they do in a typical stack data structure.\\n\\n## Key Points to Consider\\n\\n### 1. Understand the Constraints\\n- The stack must be implemented using only standard queue operations.\\n- The integer values pushed onto the stack are between 1 and 9.\\n- There will be at most 100 calls to each of the stack\\'s functions (`push`, `pop`, `top`, and `empty`).\\n- All calls to `pop` and `top` will be made when the stack is not empty.\\n\\n### 2. Approaches to Solve the Problem\\n\\n#### Two-Queue Approach\\n- **How it Works**: Utilize two queues and move elements between them to mimic stack operations.\\n- **Time Complexity**: $$O(n)$$ for `pop` and `top`, $$O(1)$$ for `push` and `empty`.\\n- **When to Use**: Choose this approach when the frequency of `push` and `empty` operations is higher than `pop` and `top`.\\n\\n#### One-Queue Approach\\n- **How it Works**: Use a single queue and reorganize (rotate) its elements when pushing a new element.\\n- **Time Complexity**: $$O(n)$$ for `push`, $$O(1)$$ for `pop`, `top`, and `empty`.\\n- **When to Use**: Choose this approach when you expect `pop` and `top` operations to be more frequent than `push`.\\n\\n### 4. Thought Process\\n- The two-queue approach is more straightforward but involves more element transfers for `pop` and `top`.\\n- The one-queue approach requires more work during the `push` operation but makes `pop` and `top` more efficient.\\n  \\n## Conclusion\\nThe problem is a good exercise in understanding how one data structure can be implemented using another while maintaining its essential characteristics with both one-queue and two-queue approaches.\\n\\n---\\n\\n# Live Coding in Python\\nhttps://youtu.be/8cwvQWfsPfs?si=KDUxRZDvlPSljfM8\\n\\n---\\n\\n# Approach: Two-Queue Approach\\n\\n## Key Data Structures\\n- Two queues, often implemented using Python\\'s `deque` from the `collections` library.\\n\\n## Enhanced Breakdown\\n\\n### 1. Initialization:\\n- Create two empty queues, referred to as `q1` and `q2`. `q1` will serve as the main queue where new elements are pushed, while `q2` will serve as an auxiliary queue for temporary operations.\\n\\n### 2. Base Cases:\\n- For the `empty` function, directly check the length or size of `q1`. If it\\'s empty, return `True`, otherwise return `False`.\\n\\n### 3. Main Algorithm:\\n\\n#### Push Operation\\n- For the `push` operation, simply add the new element to the back (enqueue) of `q1`.\\n\\n#### Pop Operation\\n- For the `pop` operation, you need to access the last element pushed into `q1`, which is at the back.\\n- To do this, dequeue from `q1` and enqueue into `q2` until only one element remains in `q1`.\\n- The remaining element is the one to be popped. Dequeue it from `q1`.\\n\\n#### Top Operation\\n- Similar to the `pop` operation, but after accessing the last element, it should be enqueued back into `q2`.\\n\\n### 4. Wrap-up:\\n- After each `pop` and `top` operation, swap `q1` and `q2` to make `q2` the new main queue and `q1` the new auxiliary queue.\\n\\n## Complexity\\n### Time Complexity:\\n- $$O(n)$$ for the `pop` and `top` operations as you have to move $$n-1$$ elements between the two queues.\\n- $$O(1)$$ for the `push` and `empty` operations as they are direct enqueue and length check operations.\\n\\n### Space Complexity:\\n- $$O(n)$$ for storing the elements in the queues.\\n\\n---\\n\\n# Approach: One-Queue Approach\\n\\n## Key Data Structures\\n- A single queue, again best implemented using Python\\'s `deque` from the `collections` library.\\n\\n## Enhanced Breakdown\\n\\n### 1. Initialization:\\n- Create a single empty queue, referred to as `q`.\\n\\n### 2. Base Cases:\\n- Similar to the Two-Queue Approach, directly check if the queue `q` is empty for the `empty` operation.\\n\\n### 3. Main Algorithm:\\n\\n#### Push Operation\\n- Enqueue the new element at the back of `q`.\\n- To ensure that the last element can be accessed from the front, rotate the queue by dequeueing and enqueuing each element except the newly pushed element.\\n\\n#### Pop and Top Operations\\n- Simply dequeue from the front for `pop` and peek at the front for `top`.\\n\\n### 4. Wrap-up:\\n- There\\'s no need to swap or move elements for `pop` and `top`, making these operations faster compared to the Two-Queue Approach.\\n\\n## Complexity\\n### Time Complexity:\\n- $$O(n)$$ for the `push` operation due to the rotation required to bring the last element to the front.\\n- $$O(1)$$ for the `pop`, `top`, and `empty` operations.\\n\\n### Space Complexity:\\n- $$O(n)$$ for storing the elements in the queue.\\n---\\n\\n# Performance\\n\\n| Language  | Approach | Runtime (ms) | Memory (MB) |\\n|-----------|----------|--------------|-------------|\\n| Rust      | 1Q       | 0 ms         | 2.2 MB      |\\n| Go        | 1Q       | 1 ms         | 2 MB        |\\n| C++       | 1Q       | 0 ms         | 6.7 MB      |\\n| Java      | 1Q       | 0 ms         | 40.5 MB     |\\n| PHP       | 1Q       | 0 ms         | 18.8 MB     |\\n| Python3   | 1Q       | 24 ms        | 16.5 MB     |\\n| Python3   | 2Q       | 40 ms        | 16.4 MB     |\\n| JavaScript| 1Q       | 45 ms        | 41.6 MB     |\\n| C#        | 1Q       | 105 ms       | 40.7 MB     |\\n\\n![e1.png](https://assets.leetcode.com/users/images/98c5611a-ec3f-461f-991f-ed54e371f0a7_1693183396.2940588.png)\\n\\n---\\n\\n# Code One-Queue\\n``` Python []\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n        for _ in range(len(self.q) - 1):\\n            self.q.append(self.q.popleft())\\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n\\n    def top(self) -> int:\\n        return self.q[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.q) == 0\\n```\\n``` C++ []\\n#include <queue>\\n\\nclass MyStack {\\nprivate:\\n    std::queue<int> q;\\n\\npublic:\\n    MyStack() {}\\n\\n    void push(int x) {\\n        q.push(x);\\n        for (int i = 0; i < q.size() - 1; ++i) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n\\n    int pop() {\\n        int val = q.front();\\n        q.pop();\\n        return val;\\n    }\\n\\n    int top() {\\n        return q.front();\\n    }\\n\\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n```\\n``` Go []\\ntype MyStack struct {\\n    q []int\\n}\\n\\nfunc Constructor() MyStack {\\n    return MyStack{}\\n}\\n\\nfunc (this *MyStack) Push(x int) {\\n    this.q = append(this.q, x)\\n    for i := 0; i < len(this.q)-1; i++ {\\n        this.q = append(this.q, this.q[0])\\n        this.q = this.q[1:]\\n    }\\n}\\n\\nfunc (this *MyStack) Pop() int {\\n    val := this.q[0]\\n    this.q = this.q[1:]\\n    return val\\n}\\n\\nfunc (this *MyStack) Top() int {\\n    return this.q[0]\\n}\\n\\nfunc (this *MyStack) Empty() bool {\\n    return len(this.q) == 0\\n}\\n```\\n``` Rust []\\nuse std::collections::VecDeque;\\n\\npub struct MyStack {\\n    q: VecDeque<i32>,\\n}\\n\\nimpl MyStack {\\n    pub fn new() -> Self {\\n        MyStack { q: VecDeque::new() }\\n    }\\n\\n    pub fn push(&mut self, x: i32) {\\n        self.q.push_back(x);\\n        for _ in 0..self.q.len() - 1 {\\n            let val = self.q.pop_front().unwrap();\\n            self.q.push_back(val);\\n        }\\n    }\\n\\n    pub fn pop(&mut self) -> i32 {\\n        self.q.pop_front().unwrap()\\n    }\\n\\n    pub fn top(&self) -> i32 {\\n        *self.q.front().unwrap()\\n    }\\n\\n    pub fn empty(&self) -> bool {\\n        self.q.is_empty()\\n    }\\n}\\n```\\n``` Java []\\npublic class MyStack {\\n    private Queue<Integer> q;\\n\\n    public MyStack() {\\n        q = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        q.add(x);\\n        for (int i = 1; i < q.size(); i++) {\\n            q.add(q.remove());\\n        }\\n    }\\n\\n    public int pop() {\\n        return q.remove();\\n    }\\n\\n    public int top() {\\n        return q.peek();\\n    }\\n\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n```\\n``` JavaScript []\\nclass MyStack {\\n    constructor() {\\n        this.q = [];\\n    }\\n\\n    push(x) {\\n        this.q.push(x);\\n        for (let i = 0; i < this.q.length - 1; i++) {\\n            this.q.push(this.q.shift());\\n        }\\n    }\\n\\n    pop() {\\n        return this.q.shift();\\n    }\\n\\n    top() {\\n        return this.q[0];\\n    }\\n\\n    empty() {\\n        return this.q.length === 0;\\n    }\\n}\\n```\\n``` PHP []\\n\\nclass MyStack {\\n    private $q = [];\\n\\n    public function push($x) {\\n        array_push($this->q, $x);\\n        for ($i = 0; $i < count($this->q) - 1; $i++) {\\n            array_push($this->q, array_shift($this->q));\\n        }\\n    }\\n\\n    public function pop() {\\n        return array_shift($this->q);\\n    }\\n\\n    public function top() {\\n        return $this->q[0];\\n    }\\n\\n    public function empty() {\\n        return empty($this->q);\\n    }\\n}\\n\\n```\\n``` C# []\\npublic class MyStack {\\n    private Queue<int> q;\\n\\n    public MyStack() {\\n        q = new Queue<int>();\\n    }\\n\\n    public void Push(int x) {\\n        q.Enqueue(x);\\n        for (int i = 0; i < q.Count - 1; i++) {\\n            q.Enqueue(q.Dequeue());\\n        }\\n    }\\n\\n    public int Pop() {\\n        return q.Dequeue();\\n    }\\n\\n    public int Top() {\\n        return q.Peek();\\n    }\\n\\n    public bool Empty() {\\n        return q.Count == 0;\\n    }\\n}\\n```\\n\\n# Code Two-Queue\\n``` Python []\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q1 = deque()\\n        self.q2 = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q1.append(x)\\n\\n    def pop(self) -> int:\\n        while len(self.q1) > 1:\\n            self.q2.append(self.q1.popleft())\\n        \\n        popped_element = self.q1.popleft()\\n        \\n        # Swap q1 and q2\\n        self.q1, self.q2 = self.q2, self.q1\\n        \\n        return popped_element\\n\\n    def top(self) -> int:\\n        while len(self.q1) > 1:\\n            self.q2.append(self.q1.popleft())\\n        \\n        top_element = self.q1[0]\\n        \\n        self.q2.append(self.q1.popleft())\\n        \\n        # Swap q1 and q2\\n        self.q1, self.q2 = self.q2, self.q1\\n        \\n        return top_element\\n\\n    def empty(self) -> bool:\\n        return len(self.q1) == 0\\n```\\n\\nThis exercise challenges you to think critically about basic data structures like stacks and queues. Implementing a stack using queues not only tests your understanding of these structures but also your ability to creatively use one to emulate the other. The multiple approaches available serve as a lesson in computational trade-offs, essential knowledge for technical interviews and real-world problem-solving. Dive in and explore these solutions, as each has its unique learning points. Happy coding! \\uD83D\\uDE80\\uD83D\\uDCA1\\uD83C\\uDF1F",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Stack",
                    "Queue"
                ],
                "code": "``` Python []\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n        for _ in range(len(self.q) - 1):\\n            self.q.append(self.q.popleft())\\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n\\n    def top(self) -> int:\\n        return self.q[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.q) == 0\\n```\n``` C++ []\\n#include <queue>\\n\\nclass MyStack {\\nprivate:\\n    std::queue<int> q;\\n\\npublic:\\n    MyStack() {}\\n\\n    void push(int x) {\\n        q.push(x);\\n        for (int i = 0; i < q.size() - 1; ++i) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n\\n    int pop() {\\n        int val = q.front();\\n        q.pop();\\n        return val;\\n    }\\n\\n    int top() {\\n        return q.front();\\n    }\\n\\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n```\n``` Go []\\ntype MyStack struct {\\n    q []int\\n}\\n\\nfunc Constructor() MyStack {\\n    return MyStack{}\\n}\\n\\nfunc (this *MyStack) Push(x int) {\\n    this.q = append(this.q, x)\\n    for i := 0; i < len(this.q)-1; i++ {\\n        this.q = append(this.q, this.q[0])\\n        this.q = this.q[1:]\\n    }\\n}\\n\\nfunc (this *MyStack) Pop() int {\\n    val := this.q[0]\\n    this.q = this.q[1:]\\n    return val\\n}\\n\\nfunc (this *MyStack) Top() int {\\n    return this.q[0]\\n}\\n\\nfunc (this *MyStack) Empty() bool {\\n    return len(this.q) == 0\\n}\\n```\n``` Rust []\\nuse std::collections::VecDeque;\\n\\npub struct MyStack {\\n    q: VecDeque<i32>,\\n}\\n\\nimpl MyStack {\\n    pub fn new() -> Self {\\n        MyStack { q: VecDeque::new() }\\n    }\\n\\n    pub fn push(&mut self, x: i32) {\\n        self.q.push_back(x);\\n        for _ in 0..self.q.len() - 1 {\\n            let val = self.q.pop_front().unwrap();\\n            self.q.push_back(val);\\n        }\\n    }\\n\\n    pub fn pop(&mut self) -> i32 {\\n        self.q.pop_front().unwrap()\\n    }\\n\\n    pub fn top(&self) -> i32 {\\n        *self.q.front().unwrap()\\n    }\\n\\n    pub fn empty(&self) -> bool {\\n        self.q.is_empty()\\n    }\\n}\\n```\n``` Java []\\npublic class MyStack {\\n    private Queue<Integer> q;\\n\\n    public MyStack() {\\n        q = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        q.add(x);\\n        for (int i = 1; i < q.size(); i++) {\\n            q.add(q.remove());\\n        }\\n    }\\n\\n    public int pop() {\\n        return q.remove();\\n    }\\n\\n    public int top() {\\n        return q.peek();\\n    }\\n\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n```\n``` JavaScript []\\nclass MyStack {\\n    constructor() {\\n        this.q = [];\\n    }\\n\\n    push(x) {\\n        this.q.push(x);\\n        for (let i = 0; i < this.q.length - 1; i++) {\\n            this.q.push(this.q.shift());\\n        }\\n    }\\n\\n    pop() {\\n        return this.q.shift();\\n    }\\n\\n    top() {\\n        return this.q[0];\\n    }\\n\\n    empty() {\\n        return this.q.length === 0;\\n    }\\n}\\n```\n``` PHP []\\n\\nclass MyStack {\\n    private $q = [];\\n\\n    public function push($x) {\\n        array_push($this->q, $x);\\n        for ($i = 0; $i < count($this->q) - 1; $i++) {\\n            array_push($this->q, array_shift($this->q));\\n        }\\n    }\\n\\n    public function pop() {\\n        return array_shift($this->q);\\n    }\\n\\n    public function top() {\\n        return $this->q[0];\\n    }\\n\\n    public function empty() {\\n        return empty($this->q);\\n    }\\n}\\n\\n```\n``` C# []\\npublic class MyStack {\\n    private Queue<int> q;\\n\\n    public MyStack() {\\n        q = new Queue<int>();\\n    }\\n\\n    public void Push(int x) {\\n        q.Enqueue(x);\\n        for (int i = 0; i < q.Count - 1; i++) {\\n            q.Enqueue(q.Dequeue());\\n        }\\n    }\\n\\n    public int Pop() {\\n        return q.Dequeue();\\n    }\\n\\n    public int Top() {\\n        return q.Peek();\\n    }\\n\\n    public bool Empty() {\\n        return q.Count == 0;\\n    }\\n}\\n```\n``` Python []\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q1 = deque()\\n        self.q2 = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q1.append(x)\\n\\n    def pop(self) -> int:\\n        while len(self.q1) > 1:\\n            self.q2.append(self.q1.popleft())\\n        \\n        popped_element = self.q1.popleft()\\n        \\n        # Swap q1 and q2\\n        self.q1, self.q2 = self.q2, self.q1\\n        \\n        return popped_element\\n\\n    def top(self) -> int:\\n        while len(self.q1) > 1:\\n            self.q2.append(self.q1.popleft())\\n        \\n        top_element = self.q1[0]\\n        \\n        self.q2.append(self.q1.popleft())\\n        \\n        # Swap q1 and q2\\n        self.q1, self.q2 = self.q2, self.q1\\n        \\n        return top_element\\n\\n    def empty(self) -> bool:\\n        return len(self.q1) == 0\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3969572,
                "title": "1-queue-and-2-queue-both-very-easy-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust try to follow last in first out order in implementation\\n\\n`for detailed explanation you can refer to my youtube channel` \\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n# With one queue\\n\\n- **Push**: When pushing an element, it\\'s added to the back of the queue. Then, the elements are rotated within the queue so that the newly added element is moved to the front.\\n\\n- **Pop**: The front element of the queue is popped to mimic the behavior of a stack.\\n\\n- **Top**: The front element of the queue is returned as the top element of the stack.\\n\\n- **Empty**: The stack is considered empty if the underlying queue is empty.\\n\\n# Complexity\\n- Time complexity: push $$O(n)$$  rest $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```C++ []\\nclass MyStack {\\npublic:\\nqueue<int>q;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int v=q.size()-1;\\n        int i=0;\\n        while(i<v){\\n          q.push(q.front());\\n          i++;\\n          q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int p=q.front();\\n        q.pop();\\n        return p;\\n    }\\n    \\n    int top() {\\n      return q.front();  \\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\\n```java []\\n\\nclass MyStack {\\n    private Queue<Integer> q = new LinkedList<>();\\n\\n    MyStack() {\\n        \\n    }\\n\\n    void push(int x) {\\n        q.add(x);\\n        int v = q.size() - 1;\\n        int i = 0;\\n        while (i < v) {\\n            q.add(q.poll());\\n            i++;\\n        }\\n    }\\n\\n    int pop() {\\n        return q.poll();\\n    }\\n\\n    int top() {\\n        return q.peek();\\n    }\\n\\n    boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n\\n```\\n```python []\\nclass MyStack:\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n        v = len(self.q) - 1\\n        i = 0\\n        while i < v:\\n            self.q.append(self.q.popleft())\\n            i += 1\\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n\\n    def top(self) -> int:\\n        return self.q[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.q) == 0\\n\\n```\\n\\n# Code 2\\n\\n# Approach 2\\n\\n# With two queue\\n\\n- **Push**: To push an element, the code transfers all elements from `q1` to `q2` to maintain order. Then, the new element is enqueued into `q1`, and finally, elements are transferred back from `q2` to `q1`.\\n\\n- **Pop**: The front element of `q1` is dequeued and returned, simulating the pop operation of a stack.\\n\\n- **Top**: The front element of `q1` is returned without dequeuing it, representing the top of the stack.\\n\\n- **Empty**: The stack is considered empty if `q1` is empty.\\n\\n```C++ []\\nclass MyStack {\\npublic:\\n    queue<int>q1,q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        while(q1.size()>0){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        q1.push(x);\\n        while(q2.size()>0){\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n       int x=q1.front();\\n        q1.pop();\\n       return x;   \\n    }\\n    \\n    int top() {\\n       return q1.front();\\n    }\\n    \\n    bool empty() {\\n       return q1.size()==0; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Queue"
                ],
                "code": "```C++ []\\nclass MyStack {\\npublic:\\nqueue<int>q;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int v=q.size()-1;\\n        int i=0;\\n        while(i<v){\\n          q.push(q.front());\\n          i++;\\n          q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int p=q.front();\\n        q.pop();\\n        return p;\\n    }\\n    \\n    int top() {\\n      return q.front();  \\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\n```java []\\n\\nclass MyStack {\\n    private Queue<Integer> q = new LinkedList<>();\\n\\n    MyStack() {\\n        \\n    }\\n\\n    void push(int x) {\\n        q.add(x);\\n        int v = q.size() - 1;\\n        int i = 0;\\n        while (i < v) {\\n            q.add(q.poll());\\n            i++;\\n        }\\n    }\\n\\n    int pop() {\\n        return q.poll();\\n    }\\n\\n    int top() {\\n        return q.peek();\\n    }\\n\\n    boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n\\n```\n```python []\\nclass MyStack:\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n        v = len(self.q) - 1\\n        i = 0\\n        while i < v:\\n            self.q.append(self.q.popleft())\\n            i += 1\\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n\\n    def top(self) -> int:\\n        return self.q[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.q) == 0\\n\\n```\n```C++ []\\nclass MyStack {\\npublic:\\n    queue<int>q1,q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        while(q1.size()>0){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        q1.push(x);\\n        while(q2.size()>0){\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n       int x=q1.front();\\n        q1.pop();\\n       return x;   \\n    }\\n    \\n    int top() {\\n       return q1.front();\\n    }\\n    \\n    bool empty() {\\n       return q1.size()==0; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009071,
                "title": "best-possible-implementation-beats-100-c",
                "content": "\\n#  Time Complexity  (Beats 100 %)\\n*Push :* O(1)\\n*Pop  :* O(n)\\n*top  :* O(1)\\n*empty:* O(1)\\n\\nThis is the best possible implementation as no. of pop operations will always be less than or equal to push operations , so if we take O(n) time in pop() rather than push() , it will save time. We can maintain another variable to keep the top element updated and can return top element in O(1).\\n\\n\\n\\n\\n\\n```\\nclass MyStack {\\npublic:\\n \\n    queue<int> q;\\n\\n    int peek = -1;   //  maintaining the top element of stack \\n    \\n    MyStack() {\\n       \\n    }\\n    \\n    void push(int x) {\\n         peek = x;\\n        q.push(x);\\n    }\\n    \\n    \\n    int pop() {\\n        \\n       int n = q.size();\\n       n-=1; \\n       while(n--){\\n          peek = q.front();     // maintining the top element \\n           q.push(peek);\\n           q.pop();\\n       } \\n        \\n       int ret = q.front();     // storing the element to return \\n        q.pop();                // removing the element permanently\\n        \\n        return ret;\\n        \\n    }\\n    \\n    int top() {\\n        \\n     return peek ;\\n        \\n    }\\n    \\n    \\n    bool empty() {\\n        \\n        return q.size()==0;\\n    }\\n};\\n```\\n\\n\\n\\nPlease upvote if it helped : )",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n \\n    queue<int> q;\\n\\n    int peek = -1;   //  maintaining the top element of stack \\n    \\n    MyStack() {\\n       \\n    }\\n    \\n    void push(int x) {\\n         peek = x;\\n        q.push(x);\\n    }\\n    \\n    \\n    int pop() {\\n        \\n       int n = q.size();\\n       n-=1; \\n       while(n--){\\n          peek = q.front();     // maintining the top element \\n           q.push(peek);\\n           q.pop();\\n       } \\n        \\n       int ret = q.front();     // storing the element to return \\n        q.pop();                // removing the element permanently\\n        \\n        return ret;\\n        \\n    }\\n    \\n    int top() {\\n        \\n     return peek ;\\n        \\n    }\\n    \\n    \\n    bool empty() {\\n        \\n        return q.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009121,
                "title": "here-s-how-it-works-meme",
                "content": "The very common way to solve this problem, to make the compiler looks like so dumb, is just **implement stack using stack** \\uD83D\\uDE01 // But hello, look at the problem what it\\'s saying **Implement Stack using queue**. \\nI\\'m telling you if you solve this problem infront of the interviewer in this way, in the first 15 minutes, he wont say anything to you, just listen to your all the words very politely. But after this, the way he will gonna insult you, its will gonna seems like you have wasted America 15 minutes. you\\'ll say in your mind that can you please slap me instead of that.\\n\\nHere\\'s the code :-\\n```\\nclass MyStack {\\n    Stack<Integer> st;\\n    public MyStack() {\\n        st = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        st.push(x);\\n    }\\n    \\n    public int pop() {\\n        return st.pop();\\n    }\\n    \\n    public int top() {\\n        return st.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return st.size() == 0;\\n    }\\n}\\n```\\n\\nBut now Okay, Jokes apart. {Seriously that was a joke but, code still works on compiler} To the interviewer you\\'ll gonna show this :-\\n**How Stack & Queue works**\\n\\n![image](https://assets.leetcode.com/users/images/5f889bde-b110-4af7-b166-113db8b8e773_1651713329.298095.png)\\n\\n**Stack Using Queue**\\n\\n![image](https://assets.leetcode.com/users/images/731e1506-993b-4f0d-a642-c88a14337f75_1651713672.9221475.jpeg)\\n\\n\\n```\\nclass MyStack {\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        while(!q1.isEmpty()){\\n            q2.offer(q1.remove());\\n        }\\n        q1.offer(x);\\n        while(!q2.isEmpty()){\\n            q1.offer(q2.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q1.remove();\\n    }\\n    \\n    public int top() {\\n        return q1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return q1.size() == 0;\\n    }\\n}\\n```\\nANALYSIS :-\\n**Time Complexity :-**\\n**`Push :-`** O(N)\\n**`Pop :-`** O(1)\\n**`Top :-`** O(1)\\n**`Stack Size :-`** O(1)\\n\\n**Space Complexity :-** O(1)\\n\\n```\\nNow it\\'s MEME time\\n```\\n\\n<img src = \"https://assets.leetcode.com/users/images/b67b8008-414b-4bf8-98a0-354b75cb41ad_1651715647.1594052.png\" width=\"auto\" height=\"600\" border=\"10\"/>",
                "solutionTags": [],
                "code": "```\\nclass MyStack {\\n    Stack<Integer> st;\\n    public MyStack() {\\n        st = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        st.push(x);\\n    }\\n    \\n    public int pop() {\\n        return st.pop();\\n    }\\n    \\n    public int top() {\\n        return st.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return st.size() == 0;\\n    }\\n}\\n```\n```\\nclass MyStack {\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        while(!q1.isEmpty()){\\n            q2.offer(q1.remove());\\n        }\\n        q1.offer(x);\\n        while(!q2.isEmpty()){\\n            q1.offer(q2.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q1.remove();\\n    }\\n    \\n    public int top() {\\n        return q1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return q1.size() == 0;\\n    }\\n}\\n```\n```\\nNow it\\'s MEME time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978541,
                "title": "efficient-and-easy-java-solution-0ms-100-faster-than-other-solutions",
                "content": "```\\nclass MyStack {\\n\\t\\n\\tprivate Queue<Integer> queue = new LinkedList<>();\\n\\n\\tpublic void push(int x) {\\n\\t\\tqueue.add(x);\\n\\t\\tfor(int i = 1;i<queue.size();i++) {\\n\\t\\t\\tqueue.add(queue.remove());\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int pop() {\\n\\t\\treturn queue.remove();\\n\\t}\\n\\n\\tpublic int top() {\\n\\t\\treturn queue.peek();\\n\\t}\\n\\n\\tpublic boolean empty() {\\n\\t\\treturn queue.isEmpty();  \\n\\t}\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n\\t\\n\\tprivate Queue<Integer> queue = new LinkedList<>();\\n\\n\\tpublic void push(int x) {\\n\\t\\tqueue.add(x);\\n\\t\\tfor(int i = 1;i<queue.size();i++) {\\n\\t\\t\\tqueue.add(queue.remove());\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int pop() {\\n\\t\\treturn queue.remove();\\n\\t}\\n\\n\\tpublic int top() {\\n\\t\\treturn queue.peek();\\n\\t}\\n\\n\\tpublic boolean empty() {\\n\\t\\treturn queue.isEmpty();  \\n\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62665,
                "title": "c-simple-solution-to-rotate-queue-to-get-a-stack",
                "content": "    public class Stack {\\n        Queue<int> qStack = new Queue<int>();\\n    \\n        // Push element x onto stack.\\n        public void Push(int x) {\\n            qStack.Enqueue(x);\\n            for(int i = 0; i < qStack.Count - 1; i++)\\n                qStack.Enqueue(qStack.Dequeue());\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void Pop() {\\n            qStack.Dequeue();\\n        }\\n    \\n        // Get the top element.\\n        public int Top() {\\n            return qStack.Peek();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public bool Empty() {\\n            return qStack.Count == 0 ? true : false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class Stack {\\n        Queue<int> qStack = new Queue<int>();\\n    \\n        // Push element x onto stack.\\n        public void Push(int x) {\\n            qStack.Enqueue(x);\\n            for(int i = 0; i < qStack.Count - 1; i++)\\n                qStack.Enqueue(qStack.Dequeue());\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void Pop() {\\n            qStack.Dequeue();\\n        }\\n    \\n        // Get the top element.\\n        public int Top() {\\n            return qStack.Peek();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public bool Empty() {\\n            return qStack.Count == 0 ? true : false;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3969973,
                "title": "easy-solution-python3-c-c-java-with-image",
                "content": "![Screenshot 2023-08-20 065922.png](https://assets.leetcode.com/users/images/4cbf9773-3eca-4dd4-b646-58dd64798a4d_1693196637.7072523.png)\\n\\n```Python3 []\\nclass MyStack(object):\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x):\\n        self.q.append(x)\\n        \\n\\n    def pop(self):\\n        for i in range(len(self.q) - 1):\\n            self.push(self.q.popleft())\\n        return self.q.popleft()\\n        \\n\\n    def top(self):\\n        return self.q[-1]\\n        \\n\\n    def empty(self):\\n        return len(self.q) == 0\\n        \\n```\\n```python []\\nclass MyStack(object):\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x):\\n        self.q.append(x)\\n        \\n\\n    def pop(self):\\n        for i in range(len(self.q) - 1):\\n            self.push(self.q.popleft())\\n        return self.q.popleft()\\n        \\n\\n    def top(self):\\n        return self.q[-1]\\n        \\n\\n    def empty(self):\\n        return len(self.q) == 0\\n        \\n```\\n```C# []\\nclass MyStack\\n{\\n    private Queue<int> q = new Queue<int>();\\n\\n    public void Push(int x)\\n    {\\n        q.Enqueue(x);\\n    }\\n\\n    public int Pop()\\n    {\\n        int count = q.Count;\\n        for (int i = 0; i < count - 1; i++)\\n        {\\n            Push(q.Dequeue());\\n        }\\n        return q.Dequeue();\\n    }\\n\\n    public int Top()\\n    {\\n        return q.Last();\\n    }\\n\\n    public bool Empty()\\n    {\\n        return q.Count == 0;\\n    }\\n}\\n```\\n```C++ []\\nclass MyStack {\\nprivate:\\n    std::queue<int> q;\\n\\npublic:\\n    void push(int x) {\\n        q.push(x);\\n    }\\n\\n    int pop() {\\n        int count = q.size();\\n        for (int i = 0; i < count - 1; i++) {\\n            push(q.front());\\n            q.pop();\\n        }\\n        int topValue = q.front();\\n        q.pop();\\n        return topValue;\\n    }\\n\\n    int top() {\\n        return q.back();\\n    }\\n\\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n```\\n```Java []\\nclass MyStack {\\n    private Queue<Integer> q = new LinkedList<>();\\n\\n    public void push(int x) {\\n        q.add(x);\\n    }\\n\\n    public int pop() {\\n        int size = q.size();\\n        for (int i = 0; i < size - 1; i++) {\\n            push(q.remove());\\n        }\\n        return q.remove();\\n    }\\n\\n    public int top() {\\n        int size = q.size();\\n        for (int i = 0; i < size - 1; i++) {\\n            push(q.remove());\\n        }\\n        int topValue = q.remove();\\n        push(topValue);\\n        return topValue;\\n    }\\n\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```Python3 []\\nclass MyStack(object):\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x):\\n        self.q.append(x)\\n        \\n\\n    def pop(self):\\n        for i in range(len(self.q) - 1):\\n            self.push(self.q.popleft())\\n        return self.q.popleft()\\n        \\n\\n    def top(self):\\n        return self.q[-1]\\n        \\n\\n    def empty(self):\\n        return len(self.q) == 0\\n        \\n```\n```python []\\nclass MyStack(object):\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x):\\n        self.q.append(x)\\n        \\n\\n    def pop(self):\\n        for i in range(len(self.q) - 1):\\n            self.push(self.q.popleft())\\n        return self.q.popleft()\\n        \\n\\n    def top(self):\\n        return self.q[-1]\\n        \\n\\n    def empty(self):\\n        return len(self.q) == 0\\n        \\n```\n```C# []\\nclass MyStack\\n{\\n    private Queue<int> q = new Queue<int>();\\n\\n    public void Push(int x)\\n    {\\n        q.Enqueue(x);\\n    }\\n\\n    public int Pop()\\n    {\\n        int count = q.Count;\\n        for (int i = 0; i < count - 1; i++)\\n        {\\n            Push(q.Dequeue());\\n        }\\n        return q.Dequeue();\\n    }\\n\\n    public int Top()\\n    {\\n        return q.Last();\\n    }\\n\\n    public bool Empty()\\n    {\\n        return q.Count == 0;\\n    }\\n}\\n```\n```C++ []\\nclass MyStack {\\nprivate:\\n    std::queue<int> q;\\n\\npublic:\\n    void push(int x) {\\n        q.push(x);\\n    }\\n\\n    int pop() {\\n        int count = q.size();\\n        for (int i = 0; i < count - 1; i++) {\\n            push(q.front());\\n            q.pop();\\n        }\\n        int topValue = q.front();\\n        q.pop();\\n        return topValue;\\n    }\\n\\n    int top() {\\n        return q.back();\\n    }\\n\\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n```\n```Java []\\nclass MyStack {\\n    private Queue<Integer> q = new LinkedList<>();\\n\\n    public void push(int x) {\\n        q.add(x);\\n    }\\n\\n    public int pop() {\\n        int size = q.size();\\n        for (int i = 0; i < size - 1; i++) {\\n            push(q.remove());\\n        }\\n        return q.remove();\\n    }\\n\\n    public int top() {\\n        int size = q.size();\\n        for (int i = 0; i < size - 1; i++) {\\n            push(q.remove());\\n        }\\n        int topValue = q.remove();\\n        push(topValue);\\n        return topValue;\\n    }\\n\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969618,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nIn my opinion, solution with two queues is more complicated than solution with one queue.\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 250 videos as of August 28th, 2023.\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/wWnUeY1XkQg\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n---\\n\\n# Approach with one queue\\nThis is based on Python. Other might be different a bit.\\n\\n**`__init__` Method:**\\n\\n- Initialize a new instance of the `MyStack` class.\\n- Create an empty deque named `q` to store the stack elements.\\n\\n**`push` Method:**\\n\\n- Accept an integer `x` as input.\\n- Append the input integer `x` to the right end of the deque `q`.\\n- Loop for the number of times equal to the length of the deque minus one (length - 1).\\n  - In each iteration, remove an element from the left end of the deque (`popleft`) and immediately append it back to the right end.\\n- This loop ensures that the last added element is at the front of the deque, simulating the behavior of a stack.\\n\\n**`pop` Method:**\\n\\n\\n- Remove and return the element from the left end of the deque `q`.\\n- This operation effectively mimics the behavior of popping an element off the stack.\\n\\n**`top` Method:**\\n\\n- Return the element at the left end of the deque `q` without removing it.\\n- This operation provides the top element of the stack without altering the stack itself.\\n\\n**`empty` Method:**\\n\\n- Check if the length of the deque `q` is equal to 0.\\n- If the length is 0, the stack is empty, so return `True`; otherwise, return `False`.\\n\\n\\n# Complexity\\n- Time complexity:\\npop, top and empty are O(1), push is O(n)\\n\\n- Space complexity: O(n)\\n\\n```python []\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n        for _ in range(len(self.q) - 1):\\n            self.q.append(self.q.popleft())\\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n        \\n    def top(self) -> int:\\n        return self.q[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.q) == 0\\n```\\n```javascript []\\nclass MyStack {\\n    constructor() {\\n        this.q = [];\\n    }\\n\\n    push(x) {\\n        this.q.push(x);\\n        for (let i = 0; i < this.q.length - 1; i++) {\\n            this.q.push(this.q.shift());\\n        }\\n    }\\n\\n    pop() {\\n        return this.q.shift();\\n    }\\n\\n    top() {\\n        return this.q[0];\\n    }\\n\\n    empty() {\\n        return this.q.length === 0;\\n    }\\n}\\n```\\n```java []\\nclass MyStack {\\n\\n    private Queue<Integer> q;\\n\\n    public MyStack() {\\n        q = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        q.add(x);\\n        for (int i = 0; i < q.size() - 1; i++) {\\n            q.add(q.poll());\\n        }\\n    }\\n\\n    public int pop() {\\n        return q.poll();\\n    }\\n\\n    public int top() {\\n        return q.peek();\\n    }\\n\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n```\\n```C++ []\\nclass MyStack {\\nprivate:\\n    std::queue<int> q;\\n\\npublic:\\n    MyStack() {}\\n\\n    void push(int x) {\\n        q.push(x);\\n        for (int i = 0; i < q.size() - 1; i++) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n\\n    int pop() {\\n        int top = q.front();\\n        q.pop();\\n        return top;\\n    }\\n\\n    int top() {\\n        return q.front();\\n    }\\n\\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n```\\n\\n# Approach with two queues\\n\\nCertainly! Here\\'s the step-by-step algorithmic explanation for each method in the given Python code:\\n\\n**`__init__` Method:**\\n\\n- Initialize a new instance of the `MyStack` class.\\n- Create two empty deques: `q1` and `q2` to store the stack elements and assist in simulating stack operations.\\n\\n**`push` Method:**\\n\\n- Accept an integer `x` as input.\\n- Append the input integer `x` to the right end of the deque `q1`.\\n\\n**`pop` Method:**\\n\\n- While the length of `q1` is greater than 1:\\n  - Remove an element from the left end of the deque `q1` (popleft operation).\\n  - Append the removed element to the right end of the deque `q2`.\\n- Remove and return the leftmost (front) element of the deque `q1`, which effectively simulates popping an element from the stack.\\n- Swap the contents of `q1` and `q2`, making `q2` ready for future operations.\\n\\n**`top` Method:**\\n\\n- While the length of `q1` is greater than 1:\\n  - Remove an element from the left end of the deque `q1` (popleft operation).\\n  - Append the removed element to the right end of the deque `q2`.\\n- Retrieve and store the leftmost (front) element of the deque `q1`, which corresponds to the top element of the stack.\\n- Remove the top element from `q1` and immediately append it to the right end of `q2`.\\n- Swap the contents of `q1` and `q2`, restoring the original state of the deques.\\n\\n**`empty` Method:**\\n\\n- Check if the length of the deque `q1` is equal to 0.\\n- If the length is 0, the stack is empty, so return `True`; otherwise, return `False`.\\n\\n# Complexity\\n- Time complexity:\\npush and empty are O(1), pop and top are O(n)\\n\\n- Space complexity: O(n)\\n\\n```python []\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q1 = deque()\\n        self.q2 = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q1.append(x)\\n\\n    def pop(self) -> int:\\n        while len(self.q1) > 1:\\n            self.q2.append(self.q1.popleft())\\n\\n        popped_val = self.q1.popleft()\\n        self.q1, self.q2 = self.q2, self.q1\\n\\n        return popped_val\\n        \\n    def top(self) -> int:\\n        while len(self.q1) > 1:\\n            self.q2.append(self.q1.popleft())\\n\\n        top_val = self.q1[0]\\n        self.q2.append(self.q1.popleft())\\n        self.q1, self.q2 = self.q2, self.q1\\n\\n        return top_val\\n\\n    def empty(self) -> bool:\\n        return len(self.q1) == 0\\n```\\n```javascript []\\nclass MyStack {\\n    constructor() {\\n        this.q1 = [];\\n        this.q2 = [];\\n    }\\n\\n    push(x) {\\n        this.q1.push(x);\\n    }\\n\\n    pop() {\\n        while (this.q1.length > 1) {\\n            this.q2.push(this.q1.shift());\\n        }\\n\\n        const poppedVal = this.q1.shift();\\n        [this.q1, this.q2] = [this.q2, this.q1];\\n\\n        return poppedVal;\\n    }\\n\\n    top() {\\n        while (this.q1.length > 1) {\\n            this.q2.push(this.q1.shift());\\n        }\\n\\n        const topVal = this.q1[0];\\n        this.q2.push(this.q1.shift());\\n        [this.q1, this.q2] = [this.q2, this.q1];\\n\\n        return topVal;\\n    }\\n\\n    empty() {\\n        return this.q1.length === 0;\\n    }\\n}\\n```\\n```java []\\nclass MyStack {\\n\\n    private Queue<Integer> q1;\\n    private Queue<Integer> q2;\\n\\n    public MyStack() {\\n        q1 = new ArrayDeque<>();\\n        q2 = new ArrayDeque<>();\\n    }\\n\\n    public void push(int x) {\\n        q1.add(x);\\n    }\\n\\n    public int pop() {\\n        while (q1.size() > 1) {\\n            q2.add(q1.poll());\\n        }\\n\\n        int poppedVal = q1.poll();\\n        Queue<Integer> temp = q1;\\n        q1 = q2;\\n        q2 = temp;\\n\\n        return poppedVal;\\n    }\\n\\n    public int top() {\\n        while (q1.size() > 1) {\\n            q2.add(q1.poll());\\n        }\\n\\n        int topVal = q1.peek();\\n        q2.add(q1.poll());\\n        Queue<Integer> temp = q1;\\n        q1 = q2;\\n        q2 = temp;\\n\\n        return topVal;\\n    }\\n\\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n\\n```\\n```C++ []\\nclass MyStack {\\nprivate:\\n    std::queue<int> q1;\\n    std::queue<int> q2;\\n\\npublic:\\n    MyStack() {}\\n\\n    void push(int x) {\\n        q1.push(x);\\n    }\\n\\n    int pop() {\\n        while (q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n\\n        int poppedVal = q1.front();\\n        q1.pop();\\n        std::swap(q1, q2);\\n\\n        return poppedVal;\\n    }\\n\\n    int top() {\\n        while (q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n\\n        int topVal = q1.front();\\n        q2.push(q1.front());\\n        q1.pop();\\n        std::swap(q1, q2);\\n\\n        return topVal;\\n    }\\n\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n        for _ in range(len(self.q) - 1):\\n            self.q.append(self.q.popleft())\\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n        \\n    def top(self) -> int:\\n        return self.q[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.q) == 0\\n```\n```javascript []\\nclass MyStack {\\n    constructor() {\\n        this.q = [];\\n    }\\n\\n    push(x) {\\n        this.q.push(x);\\n        for (let i = 0; i < this.q.length - 1; i++) {\\n            this.q.push(this.q.shift());\\n        }\\n    }\\n\\n    pop() {\\n        return this.q.shift();\\n    }\\n\\n    top() {\\n        return this.q[0];\\n    }\\n\\n    empty() {\\n        return this.q.length === 0;\\n    }\\n}\\n```\n```java []\\nclass MyStack {\\n\\n    private Queue<Integer> q;\\n\\n    public MyStack() {\\n        q = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        q.add(x);\\n        for (int i = 0; i < q.size() - 1; i++) {\\n            q.add(q.poll());\\n        }\\n    }\\n\\n    public int pop() {\\n        return q.poll();\\n    }\\n\\n    public int top() {\\n        return q.peek();\\n    }\\n\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n```\n```C++ []\\nclass MyStack {\\nprivate:\\n    std::queue<int> q;\\n\\npublic:\\n    MyStack() {}\\n\\n    void push(int x) {\\n        q.push(x);\\n        for (int i = 0; i < q.size() - 1; i++) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n\\n    int pop() {\\n        int top = q.front();\\n        q.pop();\\n        return top;\\n    }\\n\\n    int top() {\\n        return q.front();\\n    }\\n\\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n```\n```python []\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q1 = deque()\\n        self.q2 = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q1.append(x)\\n\\n    def pop(self) -> int:\\n        while len(self.q1) > 1:\\n            self.q2.append(self.q1.popleft())\\n\\n        popped_val = self.q1.popleft()\\n        self.q1, self.q2 = self.q2, self.q1\\n\\n        return popped_val\\n        \\n    def top(self) -> int:\\n        while len(self.q1) > 1:\\n            self.q2.append(self.q1.popleft())\\n\\n        top_val = self.q1[0]\\n        self.q2.append(self.q1.popleft())\\n        self.q1, self.q2 = self.q2, self.q1\\n\\n        return top_val\\n\\n    def empty(self) -> bool:\\n        return len(self.q1) == 0\\n```\n```javascript []\\nclass MyStack {\\n    constructor() {\\n        this.q1 = [];\\n        this.q2 = [];\\n    }\\n\\n    push(x) {\\n        this.q1.push(x);\\n    }\\n\\n    pop() {\\n        while (this.q1.length > 1) {\\n            this.q2.push(this.q1.shift());\\n        }\\n\\n        const poppedVal = this.q1.shift();\\n        [this.q1, this.q2] = [this.q2, this.q1];\\n\\n        return poppedVal;\\n    }\\n\\n    top() {\\n        while (this.q1.length > 1) {\\n            this.q2.push(this.q1.shift());\\n        }\\n\\n        const topVal = this.q1[0];\\n        this.q2.push(this.q1.shift());\\n        [this.q1, this.q2] = [this.q2, this.q1];\\n\\n        return topVal;\\n    }\\n\\n    empty() {\\n        return this.q1.length === 0;\\n    }\\n}\\n```\n```java []\\nclass MyStack {\\n\\n    private Queue<Integer> q1;\\n    private Queue<Integer> q2;\\n\\n    public MyStack() {\\n        q1 = new ArrayDeque<>();\\n        q2 = new ArrayDeque<>();\\n    }\\n\\n    public void push(int x) {\\n        q1.add(x);\\n    }\\n\\n    public int pop() {\\n        while (q1.size() > 1) {\\n            q2.add(q1.poll());\\n        }\\n\\n        int poppedVal = q1.poll();\\n        Queue<Integer> temp = q1;\\n        q1 = q2;\\n        q2 = temp;\\n\\n        return poppedVal;\\n    }\\n\\n    public int top() {\\n        while (q1.size() > 1) {\\n            q2.add(q1.poll());\\n        }\\n\\n        int topVal = q1.peek();\\n        q2.add(q1.poll());\\n        Queue<Integer> temp = q1;\\n        q1 = q2;\\n        q2 = temp;\\n\\n        return topVal;\\n    }\\n\\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n\\n```\n```C++ []\\nclass MyStack {\\nprivate:\\n    std::queue<int> q1;\\n    std::queue<int> q2;\\n\\npublic:\\n    MyStack() {}\\n\\n    void push(int x) {\\n        q1.push(x);\\n    }\\n\\n    int pop() {\\n        while (q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n\\n        int poppedVal = q1.front();\\n        q1.pop();\\n        std::swap(q1, q2);\\n\\n        return poppedVal;\\n    }\\n\\n    int top() {\\n        while (q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n\\n        int topVal = q1.front();\\n        q2.push(q1.front());\\n        q1.pop();\\n        std::swap(q1, q2);\\n\\n        return topVal;\\n    }\\n\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62621,
                "title": "one-queue-java-solution",
                "content": "    class MyStack {\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        \\n        // Push element x onto stack.\\n        public void push(int x) {\\n            q.add(x);\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void pop() {\\n            int size = q.size();\\n            for(int i = 1; i < size; i++)\\n                q.add(q.remove());\\n            q.remove();\\n        }\\n    \\n        // Get the top element.\\n        public int top() {\\n            int size = q.size();\\n            for(int i = 1; i < size; i++)\\n                q.add(q.remove());\\n            int ret = q.remove();\\n            q.add(ret);\\n            return ret;\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public boolean empty() {\\n            return q.isEmpty();        \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    class MyStack {\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        \\n        // Push element x onto stack.\\n        public void push(int x) {\\n            q.add(x);\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void pop() {\\n            int size = q.size();\\n            for(int i = 1; i < size; i++)\\n                q.add(q.remove());\\n            q.remove();\\n        }\\n    \\n        // Get the top element.\\n        public int top() {\\n            int size = q.size();\\n            for(int i = 1; i < size; i++)\\n                q.add(q.remove());\\n            int ret = q.remove();\\n            q.add(ret);\\n            return ret;\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public boolean empty() {\\n            return q.isEmpty();        \\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3325377,
                "title": "100-faster-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/31b6b5da-6900-4e6a-9d6e-51b0c49c839a_1679416049.6368947.png)\\n\\n\\n# Code\\n```\\nclass MyStack {\\n\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n\\n    // Constructor initializes two queues\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n\\n    // Add a new element by pushing it onto q2 and moving all elements from q1 to q2\\n    public void push(int x) {\\n        q2.add(x);\\n\\n        // Move all elements from q1 to q2\\n        while (!q1.isEmpty()) {\\n            q2.add(q1.remove());\\n        }\\n\\n        // Move all elements from q2 back to q1 to maintain the order\\n        while (!q2.isEmpty()) {\\n            q1.add(q2.remove());\\n        }\\n    }\\n\\n    // Remove the top element from q1\\n    public int pop() {\\n        return q1.remove();\\n    }\\n\\n    // Return the top element from q1 without removing it\\n    public int top() {\\n        return q1.peek();\\n    }\\n\\n    // Check if both queues are empty, meaning the stack is empty\\n    public boolean empty() {\\n        return q1.isEmpty() && q2.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\n\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n\\n    // Constructor initializes two queues\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n\\n    // Add a new element by pushing it onto q2 and moving all elements from q1 to q2\\n    public void push(int x) {\\n        q2.add(x);\\n\\n        // Move all elements from q1 to q2\\n        while (!q1.isEmpty()) {\\n            q2.add(q1.remove());\\n        }\\n\\n        // Move all elements from q2 back to q1 to maintain the order\\n        while (!q2.isEmpty()) {\\n            q1.add(q2.remove());\\n        }\\n    }\\n\\n    // Remove the top element from q1\\n    public int pop() {\\n        return q1.remove();\\n    }\\n\\n    // Return the top element from q1 without removing it\\n    public int top() {\\n        return q1.peek();\\n    }\\n\\n    // Check if both queues are empty, meaning the stack is empty\\n    public boolean empty() {\\n        return q1.isEmpty() && q2.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010511,
                "title": "concise-solutions-with-one-and-two-queues",
                "content": "With 1 queue:\\n```c#\\npublic class MyStack {\\n    \\n    private Queue<int> q = new();\\n\\n    public void Push(int x)\\n    {\\n        q.Enqueue(x);\\n        for(int i = 0; i < q.Count - 1; i++)\\n\\t        q.Enqueue(q.Dequeue());\\n    }\\n    \\n    public int Pop() => q.Dequeue();\\n    public int Top() => q.Peek();\\n    public bool Empty() => q.Count == 0;\\n}\\n```\\n\\nWith 2 queues:\\n```c#\\npublic class MyStack {\\n    \\n    private Queue<int> q = new();\\n    private Queue<int> tq = new();\\n\\n    public void Push(int x)\\n    {\\n        int count = q.Count;\\n        for(int i = 0; i < count; i++)\\n            tq.Enqueue(q.Dequeue());\\n        q.Enqueue(x);\\n        for(int i = 0; i < count; i++)\\n            q.Enqueue(tq.Dequeue());\\n    }\\n    \\n    public int Pop() => q.Dequeue();\\n    public int Top() => q.Peek();\\n    public bool Empty() => q.Count == 0;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```c#\\npublic class MyStack {\\n    \\n    private Queue<int> q = new();\\n\\n    public void Push(int x)\\n    {\\n        q.Enqueue(x);\\n        for(int i = 0; i < q.Count - 1; i++)\\n\\t        q.Enqueue(q.Dequeue());\\n    }\\n    \\n    public int Pop() => q.Dequeue();\\n    public int Top() => q.Peek();\\n    public bool Empty() => q.Count == 0;\\n}\\n```\n```c#\\npublic class MyStack {\\n    \\n    private Queue<int> q = new();\\n    private Queue<int> tq = new();\\n\\n    public void Push(int x)\\n    {\\n        int count = q.Count;\\n        for(int i = 0; i < count; i++)\\n            tq.Enqueue(q.Dequeue());\\n        q.Enqueue(x);\\n        for(int i = 0; i < count; i++)\\n            q.Enqueue(tq.Dequeue());\\n    }\\n    \\n    public int Pop() => q.Dequeue();\\n    public int Top() => q.Peek();\\n    public bool Empty() => q.Count == 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606875,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MyStack = function() {\\n    this.inQueue = [];\\n    this.outQueue = [];\\n};\\n\\n/**\\n * Push element x onto stack. \\n * @param {number} x\\n * @return {void}\\n */\\nMyStack.prototype.push = function(x) {\\n    this.inQueue.push(x);  \\n};\\n\\n/**\\n * Removes the element on top of the stack and returns that element.\\n * @return {number}\\n */\\nMyStack.prototype.pop = function() {\\n    while(this.inQueue.length > 1){\\n        this.outQueue.push(this.inQueue.shift());\\n    }\\n    \\n    const lastItem = this.inQueue.shift();\\n    \\n    [this.inQueue, this.outQueue] = [this.outQueue, this.inQueue];\\n    \\n    return lastItem;\\n};\\n\\n/**\\n * Get the top element.\\n * @return {number}\\n */\\nMyStack.prototype.top = function() {\\n    while(this.inQueue.length > 1){\\n        this.outQueue.push(this.inQueue.shift());\\n    }\\n    // peak\\n    const lastItem = this.inQueue[0];\\n    \\n    this.outQueue.push(this.inQueue.shift());\\n    [this.inQueue, this.outQueue] = [this.outQueue, this.inQueue];\\n    \\n    return lastItem;\\n};\\n\\n/**\\n * Returns whether the stack is empty.\\n * @return {boolean}\\n */\\nMyStack.prototype.empty = function() {\\n    return this.inQueue.length === 0;\\n};\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MyStack = function() {\\n    this.inQueue = [];\\n    this.outQueue = [];\\n};\\n\\n/**\\n * Push element x onto stack. \\n * @param {number} x\\n * @return {void}\\n */\\nMyStack.prototype.push = function(x) {\\n    this.inQueue.push(x);  \\n};\\n\\n/**\\n * Removes the element on top of the stack and returns that element.\\n * @return {number}\\n */\\nMyStack.prototype.pop = function() {\\n    while(this.inQueue.length > 1){\\n        this.outQueue.push(this.inQueue.shift());\\n    }\\n    \\n    const lastItem = this.inQueue.shift();\\n    \\n    [this.inQueue, this.outQueue] = [this.outQueue, this.inQueue];\\n    \\n    return lastItem;\\n};\\n\\n/**\\n * Get the top element.\\n * @return {number}\\n */\\nMyStack.prototype.top = function() {\\n    while(this.inQueue.length > 1){\\n        this.outQueue.push(this.inQueue.shift());\\n    }\\n    // peak\\n    const lastItem = this.inQueue[0];\\n    \\n    this.outQueue.push(this.inQueue.shift());\\n    [this.inQueue, this.outQueue] = [this.outQueue, this.inQueue];\\n    \\n    return lastItem;\\n};\\n\\n/**\\n * Returns whether the stack is empty.\\n * @return {boolean}\\n */\\nMyStack.prototype.empty = function() {\\n    return this.inQueue.length === 0;\\n};\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62643,
                "title": "accepted-0ms-c-solution-with-one-queue",
                "content": "    class Stack {\\n    public:\\n        // Push element x onto stack.\\n        void push(int x) {\\n    \\t\\tnums.push(x);\\n        }\\n        // Removes the element on top of the stack.\\n        void pop() {\\n    \\t\\tif (!empty()) {\\n    \\t\\t\\tint len = nums.size();\\n    \\t\\t\\tfor (int i = 0; i != len - 1; ++i) {\\n    \\t\\t\\t\\tnums.push(nums.front());\\n    \\t\\t\\t\\tnums.pop();\\n    \\t\\t\\t}\\n    \\t\\t\\tnums.pop();\\n    \\t\\t}\\n        }\\n        // Get the top element.\\n        int top() {\\n    \\t\\treturn nums.back();\\n        }\\n        // Return whether the stack is empty.\\n        bool empty() {\\n    \\t\\treturn nums.empty();\\n        }\\n    private:\\n    \\tstd::queue<int> nums;\\n    };\\n\\nThanks for StefanPochmann to remind me that `back()` is forbidden, so the right solution should be:\\n\\n    class Stack {\\n    public:\\n        // Push element x onto stack.\\n        void push(int x) {\\n    \\t\\tint len = nums.size();\\n    \\t\\tnums.push(x);\\n    \\t\\tfor (int i = 0; i != len; ++i) {\\n    \\t\\t\\tnums.push(nums.front());\\n    \\t\\t\\tnums.pop();\\n    \\t\\t}\\n        }\\n        // Removes the element on top of the stack.\\n        void pop() {\\n    \\t\\tnums.pop();\\n        }\\n        // Get the top element.\\n        int top() {\\n    \\t\\treturn nums.front();\\n        }\\n        // Return whether the stack is empty.\\n        bool empty() {\\n    \\t\\treturn nums.empty();\\n        }\\n    private:\\n    \\tstd::queue<int> nums;\\n    };",
                "solutionTags": [],
                "code": "    class Stack {\\n    public:\\n        // Push element x onto stack.\\n        void push(int x) {\\n    \\t\\tnums.push(x);\\n        }\\n        // Removes the element on top of the stack.\\n        void pop() {\\n    \\t\\tif (!empty()) {\\n    \\t\\t\\tint len = nums.size();\\n    \\t\\t\\tfor (int i = 0; i != len - 1; ++i) {\\n    \\t\\t\\t\\tnums.push(nums.front());\\n    \\t\\t\\t\\tnums.pop();\\n    \\t\\t\\t}\\n    \\t\\t\\tnums.pop();\\n    \\t\\t}\\n        }\\n        // Get the top element.\\n        int top() {\\n    \\t\\treturn nums.back();\\n        }\\n        // Return whether the stack is empty.\\n        bool empty() {\\n    \\t\\treturn nums.empty();\\n        }\\n    private:\\n    \\tstd::queue<int> nums;\\n    };\\n\\nThanks for StefanPochmann to remind me that `back()` is forbidden, so the right solution should be:\\n\\n    class Stack {\\n    public:\\n        // Push element x onto stack.\\n        void push(int x) {\\n    \\t\\tint len = nums.size();\\n    \\t\\tnums.push(x);\\n    \\t\\tfor (int i = 0; i != len; ++i) {\\n    \\t\\t\\tnums.push(nums.front());\\n    \\t\\t\\tnums.pop();\\n    \\t\\t}\\n        }\\n        // Removes the element on top of the stack.\\n        void pop() {\\n    \\t\\tnums.pop();\\n        }\\n        // Get the top element.\\n        int top() {\\n    \\t\\treturn nums.front();\\n        }\\n        // Return whether the stack is empty.\\n        bool empty() {\\n    \\t\\treturn nums.empty();\\n        }\\n    private:\\n    \\tstd::queue<int> nums;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 2634944,
                "title": "c-100-faster-1-queue-2-queue",
                "content": "[**225. Implement Stack Using Queues**](http://)\\n\\n**1. Using 1 Queue :**\\n**`Time Complexity : O(n)`**\\n**`Space Complexity : O(n)`**\\n\\n```\\nqueue<int>q;\\n    void push(int x) {\\n        q.push(x);\\n        for(auto i=0; i<q.size()-1; i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x=q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n```\\n\\n**2. Using 2 Queue :**\\n**`Time Complexity : O(n)`**\\n**`Space Complexity : O(2*n)`**\\n***Happy Coding :)***\\n\\n```\\nqueue<int>q1, q2;\\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        if(!q1.empty()){\\n            while(q1.size()!=1){\\n                q2.push(q1.front());\\n                q1.pop();\\n            }\\n            int x=q1.front();\\n            q1.pop();\\n            return x;\\n        }\\n        while(q2.size()!=1){\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        int x=q2.front();\\n        q2.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        if(!q1.empty())return q1.back();\\n        return q2.back();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty() and q2.empty();\\n    }\\n```\\n\\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/1b6761d9-bb68-42b3-81fe-9531023c30f4_1664374574.0132003.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nqueue<int>q;\\n    void push(int x) {\\n        q.push(x);\\n        for(auto i=0; i<q.size()-1; i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x=q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n```\n```\\nqueue<int>q1, q2;\\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        if(!q1.empty()){\\n            while(q1.size()!=1){\\n                q2.push(q1.front());\\n                q1.pop();\\n            }\\n            int x=q1.front();\\n            q1.pop();\\n            return x;\\n        }\\n        while(q2.size()!=1){\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        int x=q2.front();\\n        q2.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        if(!q1.empty())return q1.back();\\n        return q2.back();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty() and q2.empty();\\n    }\\n```\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62630,
                "title": "python-solution-o-1-o-n-for-push-48ms",
                "content": "    class Stack:\\n        # initialize your data structure here.\\n        def __init__(self):\\n            self.stack = collections.deque([])\\n    \\n        # @param x, an integer\\n        # @return nothing\\n        def push(self, x):\\n            self.stack.append(x)\\n    \\n        # @return nothing\\n        def pop(self):\\n            for i in range(len(self.stack) - 1):\\n                self.stack.append(self.stack.popleft())\\n    \\n            self.stack.popleft()\\n    \\n        # @return an integer\\n        def top(self):\\n            return self.stack[-1]\\n    \\n        # @return an boolean\\n        def empty(self):\\n            return len(self.stack) == 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Stack:\\n        # initialize your data structure here.\\n        def __init__(self):\\n            self.stack = collections.deque([])\\n    \\n        # @param x, an integer\\n        # @return nothing\\n        def push(self, x):\\n            self.stack.append(x)\\n    \\n        # @return nothing\\n        def pop(self):\\n            for i in range(len(self.stack) - 1):\\n                self.stack.append(self.stack.popleft())\\n    \\n            self.stack.popleft()\\n    \\n        # @return an integer\\n        def top(self):\\n            return self.stack[-1]\\n    \\n        # @return an boolean\\n        def empty(self):\\n            return len(self.stack) == 0",
                "codeTag": "Java"
            },
            {
                "id": 3969508,
                "title": "best-easy-method-using-queue-full-explanation-well-suitable-comment",
                "content": "# Approach\\n1. Initialize two queues, q1 and q2.\\n\\n2. To push an element x into the stack:\\n - simply push it onto q1.\\n\\n3. To pop an element from the stack:\\n- Transfer the first n-1 elements from q1 to q2, where n is the current size of q1.\\n- The last element in q1 is the one to be popped. Remove and store it..\\n- Swap the names of q1 and q2 to maintain the order of elements.\\n\\n4. To get the top element of the stack, simply return the back element of q1.\\n\\n5. To check if the stack is empty, - check if q1 is empty.\\n\\n# Complexity\\n- Time complexity:\\n**Push: O(1)\\nPop: O(n)\\nTop: O(1)\\nEmpty: O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n**O(n) in the worst case for the queues\\nO(1) for other variables and function calls**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# PLEASE UPVOTE\\uD83D\\uDE4F\\uD83C\\uDFFB.\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1, q2;\\n    MyStack() {\\n        // Constructor, no initialization needed for queues\\n    }\\n    \\n    void push(int x) {\\n        // Push the new element onto q1\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        int n = q1.size();\\n        \\n        // Transfer the first n-1 elements from q1 to q2\\n        // This step leaves the last element in q1, which needs to be popped\\n        for (int i = 0; i < n - 1; i++) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        \\n        // The last element in q1 is the one to be popped\\n        int x = q1.front();\\n        q1.pop();\\n        \\n        // Swap the names of q1 and q2 to maintain order\\n        swap(q1, q2);\\n        \\n        return x;\\n    }\\n    \\n    int top() {\\n        // Return the last element in q1\\n        return q1.back();\\n    }\\n    \\n    bool empty() {\\n        // Check if q1 is empty to determine if the stack is empty\\n        return q1.empty();\\n    }\\n};\\n\\n```\\n\\n![UPVOTE.png](https://assets.leetcode.com/users/images/9d012556-b71f-45af-af40-eb064fad2de5_1693183133.723711.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q1, q2;\\n    MyStack() {\\n        // Constructor, no initialization needed for queues\\n    }\\n    \\n    void push(int x) {\\n        // Push the new element onto q1\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        int n = q1.size();\\n        \\n        // Transfer the first n-1 elements from q1 to q2\\n        // This step leaves the last element in q1, which needs to be popped\\n        for (int i = 0; i < n - 1; i++) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        \\n        // The last element in q1 is the one to be popped\\n        int x = q1.front();\\n        q1.pop();\\n        \\n        // Swap the names of q1 and q2 to maintain order\\n        swap(q1, q2);\\n        \\n        return x;\\n    }\\n    \\n    int top() {\\n        // Return the last element in q1\\n        return q1.back();\\n    }\\n    \\n    bool empty() {\\n        // Check if q1 is empty to determine if the stack is empty\\n        return q1.empty();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424116,
                "title": "100-easy-js-sol-explained-with-proper-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n- Basic **Stack Data Structure** JS approach.\\n\\n1. ***push*** ***operation*** :-\\n\\n- The push method inserts an element at the top of the stack. \\n- It uses two queues, q1 and q2, to achieve the stack behavior. \\n- When pushing an element, it moves all elements from q1 to q2, then adds the new element to q1, and finally moves all elements back from q2 to q1. \\n- This way, the new element becomes the top of the stack.\\n2. ***pop operation*** :-\\n- The pop method removes and returns the element from the top of the stack, which is the front of q1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n1. The below code implements a ***stack data structure*** approach using two queues, **q1** and **q2**. \\n2. The q1 queue acts as the primary queue for the stack, while the q2 queue acts as a temporary queue used during the push operation.\\n3. In the push operation, the code first moves all elements from q1 to q2, one by one, until q1 becomes empty. \\n4. This is done to ensure that the new element being pushed is added to an empty queue. \\n5. After adding the new element to q1, the code then moves all the elements from q2 back to q1. \\n6. This ensures that the elements in the stack are in the order they were pushed, with the most recently pushed element at the top.\\n7. The pop operation simply dequeues and returns the first element from q1, which is the top element of the stack.\\n8. The top operation returns the first element of q1, without dequeuing it.\\n9. The empty operation checks if q1 is empty and returns a boolean value accordingly.\\n\\n- Overall, this implementation provides a simple and efficient way to implement a stack using two queues.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: \\n-> push -> $$O(n)$$\\n-> pop, top, empty -> $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. ***push operation*** :-\\n- Moving all elements from q1 to q2 takes O(n) time, where n is the number of elements in the stack before the push operation.\\n- Pushing the new element to q1 takes O(1) time.\\n- Moving all elements back from q2 to q1 takes O(n) time, where n is the number of elements in q2.\\n- Overall, the time complexity of the push operation is $$O(n)$$.\\n\\n2. ***pop operation*** :-\\n\\n- The ***shift()*** method used to remove the **front** element of **q1** has a time complexity of $$O(1)$$.\\n\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the maximum size of the stack. \\n2. This is because the implementation uses two queues q1 and q2, each with a maximum size of n.\\n\\n\\n\\n# Code\\n```\\nvar MyStack = function() {\\n    \\n    this.q1 = [];\\n    this.q2 = [];  \\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMyStack.prototype.push = function(x) {\\n    \\n    while (this.q1.length !== 0) {\\n        this.q2.push(this.q1.shift());\\n    }\\n    \\n    this.q1.push(x);\\n    while (this.q2.length !== 0) {\\n        this.q1.push(this.q2.shift());\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMyStack.prototype.pop = function() {\\n    return this.q1.shift();\\n};\\n\\n/**\\n * @return {number}\\n */\\nMyStack.prototype.top = function() {\\n    return this.q1[0];\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nMyStack.prototype.empty = function() {\\n    return this.q1.length === 0;\\n};\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/c67935e2-9405-4cf0-93bb-db12a9278992_1681647580.146499.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```\\nvar MyStack = function() {\\n    \\n    this.q1 = [];\\n    this.q2 = [];  \\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMyStack.prototype.push = function(x) {\\n    \\n    while (this.q1.length !== 0) {\\n        this.q2.push(this.q1.shift());\\n    }\\n    \\n    this.q1.push(x);\\n    while (this.q2.length !== 0) {\\n        this.q1.push(this.q2.shift());\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMyStack.prototype.pop = function() {\\n    return this.q1.shift();\\n};\\n\\n/**\\n * @return {number}\\n */\\nMyStack.prototype.top = function() {\\n    return this.q1[0];\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nMyStack.prototype.empty = function() {\\n    return this.q1.length === 0;\\n};\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969850,
                "title": "c-queue-day-28",
                "content": "# Code\\n```\\n#include <queue>\\n\\nclass MyStack {\\nprivate:\\n    queue<int> q;\\npublic:\\n    MyStack() {}\\n\\n    void push(int x) {\\n        q.push(x);\\n        for (int i = 0; i < q.size() - 1; ++i) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n\\n    int pop() {\\n        int val = q.front();\\n        q.pop();\\n        return val;\\n    }\\n\\n    int top() {\\n        return q.front();\\n    }\\n\\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/35a45d6d-bfe1-46ae-8f48-896cc95e43b2_1693194781.4638863.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```\\n#include <queue>\\n\\nclass MyStack {\\nprivate:\\n    queue<int> q;\\npublic:\\n    MyStack() {}\\n\\n    void push(int x) {\\n        q.push(x);\\n        for (int i = 0; i < q.size() - 1; ++i) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n\\n    int pop() {\\n        int val = q.front();\\n        q.pop();\\n        return val;\\n    }\\n\\n    int top() {\\n        return q.front();\\n    }\\n\\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3590082,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\nqueue<int>q1,q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        while(q1.size()>1){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int ans=q1.front();\\n        q1.pop();\\n        while(!q2.empty()){\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        while(q1.size()>1){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int ans=q1.front();\\n        q1.pop();\\n        q2.push(ans);\\n        while(!q2.empty()){\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        if(q1.size()==0)\\n        return 1;\\n\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\nqueue<int>q1,q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        while(q1.size()>1){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int ans=q1.front();\\n        q1.pop();\\n        while(!q2.empty()){\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        while(q1.size()>1){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int ans=q1.front();\\n        q1.pop();\\n        q2.push(ans);\\n        while(!q2.empty()){\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        if(q1.size()==0)\\n        return 1;\\n\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227645,
                "title": "225-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also uses a deque from the collections module, but instead of using two queues, it only uses one queue. The trick is to use the push operation to move the newly added element to the front of the queue, effectively making it the top element of the stack.\\n\\nHere\\'s a step-by-step explanation of the code:\\n\\n1. The constructor initializes an empty deque.\\n\\n2. The push operation adds the element to the end of the deque and then moves it to the front by dequeuing and enqueuing all the other elements in the deque. This makes the newly added element the first element in the deque, which is the top of the stack.\\n\\n3. The pop operation simply dequeues the first element in the deque, which is the top of the stack.\\n\\n4. The top operation returns the first element in the deque, which is the top of the stack.\\n\\n5. The empty operation checks if the deque is empty and returns True or False accordingly.\\n\\nThis solution has a time complexity of O(n) for the push operation and O(1) for the pop, top, and empty operations, where n is the size of the deque. The space complexity is O(n) to store the deque.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n        # Move the newly added element to the front\\n        for _ in range(len(self.q) - 1):\\n            self.q.append(self.q.popleft())\\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n\\n    def top(self) -> int:\\n        return self.q[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.q) == 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n        # Move the newly added element to the front\\n        for _ in range(len(self.q) - 1):\\n            self.q.append(self.q.popleft())\\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n\\n    def top(self) -> int:\\n        return self.q[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.q) == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009394,
                "title": "java-100-faster-0ms",
                "content": "Kindly Upvote if you find it usefull !\\n\\n```\\nclass MyStack {\\n\\n   Queue <Integer> q = new LinkedList<>();\\n  \\n    public void push(int x) {     // Pushes element x on top of the stack\\n      q.add(x);\\n      for(int i = 1; i < q.size(); i ++)\\n        q.add(q.poll());\\n    }\\n    \\n    public int pop() {            //Removes the element on the top of the stack and returns it.\\n      return q.poll();  \\n    }\\n    \\n    public int top() {            // Returns the element on the top of the stack.\\n      return q.peek();  \\n    }\\n    \\n    public boolean empty() {      //Returns true if the stack is empty, false otherwise.\\n      return q.isEmpty();  \\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "Kindly Upvote if you find it usefull !\\n\\n```\\nclass MyStack {\\n\\n   Queue <Integer> q = new LinkedList<>();\\n  \\n    public void push(int x) {     // Pushes element x on top of the stack\\n      q.add(x);\\n      for(int i = 1; i < q.size(); i ++)\\n        q.add(q.poll());\\n    }\\n    \\n    public int pop() {            //Removes the element on the top of the stack and returns it.\\n      return q.poll();  \\n    }\\n    \\n    public int top() {            // Returns the element on the top of the stack.\\n      return q.peek();  \\n    }\\n    \\n    public boolean empty() {      //Returns true if the stack is empty, false otherwise.\\n      return q.isEmpty();  \\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 62634,
                "title": "two-queue-java-solution",
                "content": "    class MyStack {\\n        Queue<Integer> q = new LinkedList<>();\\n        Queue<Integer> tmp = new LinkedList<>();\\n        // Push element x onto stack.\\n        public void push(int x) {\\n            //pop elements in q into tmp\\n            while(!q.isEmpty()){\\n                tmp.offer(q.poll());\\n            }\\n            //add x into q\\n            q.offer(x);\\n            //pop elements in tmp into q\\n            while(!tmp.isEmpty()){\\n                q.offer(tmp.poll());\\n            }\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void pop() {\\n            q.poll();\\n        }\\n    \\n        // Get the top element.\\n        public int top() {\\n            return q.peek();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public boolean empty() {\\n            return q.isEmpty();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    class MyStack {\\n        Queue<Integer> q = new LinkedList<>();\\n        Queue<Integer> tmp = new LinkedList<>();\\n        // Push element x onto stack.\\n        public void push(int x) {\\n            //pop elements in q into tmp\\n            while(!q.isEmpty()){\\n                tmp.offer(q.poll());\\n            }\\n            //add x into q\\n            q.offer(x);\\n            //pop elements in tmp into q\\n            while(!tmp.isEmpty()){\\n                q.offer(tmp.poll());\\n            }\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void pop() {\\n            q.poll();\\n        }\\n    \\n        // Get the top element.\\n        public int top() {\\n            return q.peek();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public boolean empty() {\\n            return q.isEmpty();\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 62529,
                "title": "java-line-26-error-cannot-find-symbol-method-top-why",
                "content": "y\\nclass Stack {\\n\\n    Queue<Integer> queue1 = new LinkedList<Integer>();\\n    Queue<Integer> queue2 = new LinkedList<Integer>();\\n\\n    // Push element x onto stack.\\n    public void push(int x) {\\n        while (!queue1.isEmpty()) {\\n            int num = queue1.poll();\\n            queue2.add(num);\\n        }\\n        queue1.add(x);\\n    }\\n\\n    // Removes the element on top of the stack.\\n    public void pop() {\\n        if (!queue1.isEmpty()) {\\n            queue1.poll();\\n            return;\\n        }\\n        while (queue2.size() != 1) {\\n            int num = queue2.poll();\\n            queue1.add(num);\\n        }\\n        queue2.poll();\\n    }\\n    \\n    // Get the top element.\\n    public int top() {\\n        if (!queue1.isEmpty()) {\\n            return queue1.peek();\\n        }\\n        while (queue2.size() != 1) {\\n            int num = queue2.poll();\\n            queue1.add(num);\\n        }\\n        int num = queue2.poll();\\n        queue1.add(num);\\n        return num;\\n    }\\n\\n    // Return whether the stack is empty.\\n    public boolean empty() {\\n        return queue1.isEmpty() && queue2.isEmpty();\\n    }\\n}",
                "solutionTags": [],
                "code": "y\\nclass Stack {\\n\\n    Queue<Integer> queue1 = new LinkedList<Integer>();\\n    Queue<Integer> queue2 = new LinkedList<Integer>();\\n\\n    // Push element x onto stack.\\n    public void push(int x) {\\n        while (!queue1.isEmpty()) {\\n            int num = queue1.poll();\\n            queue2.add(num);\\n        }\\n        queue1.add(x);\\n    }\\n\\n    // Removes the element on top of the stack.\\n    public void pop() {\\n        if (!queue1.isEmpty()) {\\n            queue1.poll();\\n            return;\\n        }\\n        while (queue2.size() != 1) {\\n            int num = queue2.poll();\\n            queue1.add(num);\\n        }\\n        queue2.poll();\\n    }\\n    \\n    // Get the top element.\\n    public int top() {\\n        if (!queue1.isEmpty()) {\\n            return queue1.peek();\\n        }\\n        while (queue2.size() != 1) {\\n            int num = queue2.poll();\\n            queue1.add(num);\\n        }\\n        int num = queue2.poll();\\n        queue1.add(num);\\n        return num;\\n    }\\n\\n    // Return whether the stack is empty.\\n    public boolean empty() {\\n        return queue1.isEmpty() && queue2.isEmpty();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3867739,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java\\nclass MyStack {\\n\\n    public int top;\\n    public int[] arr;\\n    public MyStack() {\\n        top = -1;\\n        arr = new int[100];\\n    }\\n\\n    public void push(int x) {\\n        top++;\\n        arr[top] = x;\\n    }\\n\\n    public int pop() {\\n        int temp = arr[top];\\n        top--;\\n        return temp;\\n    }\\n\\n    public int top() {\\n        return arr[top];\\n    }\\n\\n    public boolean empty() {\\n        return top == -1;\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/6394db94-b4f0-4da5-8ae5-848d0fea107b_1691248377.8587062.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass MyStack {\\n\\n    public int top;\\n    public int[] arr;\\n    public MyStack() {\\n        top = -1;\\n        arr = new int[100];\\n    }\\n\\n    public void push(int x) {\\n        top++;\\n        arr[top] = x;\\n    }\\n\\n    public int pop() {\\n        int temp = arr[top];\\n        top--;\\n        return temp;\\n    }\\n\\n    public int top() {\\n        return arr[top];\\n    }\\n\\n    public boolean empty() {\\n        return top == -1;\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010782,
                "title": "c-faster-than-100-easy-and-fast-intuitive",
                "content": "**Please Upvote if you like it..  :)**\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() {   \\n        \\n    }\\n    \\n    // Pushing element onto stack\\n    void push(int x) {\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front());    q1.pop();\\n        }\\n        swap(q1, q2);\\n    }\\n    \\n    // Removing element on top of the stack and returning it\\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n    \\n    //Getting top element\\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    // Return whether the stack is empty. \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() {   \\n        \\n    }\\n    \\n    // Pushing element onto stack\\n    void push(int x) {\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front());    q1.pop();\\n        }\\n        swap(q1, q2);\\n    }\\n    \\n    // Removing element on top of the stack and returning it\\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n    \\n    //Getting top element\\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    // Return whether the stack is empty. \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010769,
                "title": "java-straight-forward-solution",
                "content": "```\\nclass MyStack {\\n    ArrayDeque<Integer> q;\\n    public MyStack() {\\n        q=new ArrayDeque<>();        \\n    }\\n    public void push(int x) {\\n        q.push(x);        \\n    }\\n    \\n    public int pop() {\\n        return q.remove();\\n    }\\n    public int top() {\\n        return q.peekFirst();\\n    }\\n    public boolean empty() {\\n        return q.isEmpty(); \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\n    ArrayDeque<Integer> q;\\n    public MyStack() {\\n        q=new ArrayDeque<>();        \\n    }\\n    public void push(int x) {\\n        q.push(x);        \\n    }\\n    \\n    public int pop() {\\n        return q.remove();\\n    }\\n    public int top() {\\n        return q.peekFirst();\\n    }\\n    public boolean empty() {\\n        return q.isEmpty(); \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 62587,
                "title": "sharing-my-javascript-solution-with-two-queues",
                "content": "    var Stack = function() {\\n        this.queue = [];\\n        this.tmp = [];\\n    };\\n    \\n    /**\\n     * @param {number} x\\n     * @returns {void}\\n     */\\n    Stack.prototype.push = function(x) {\\n        this.queue.push(x);\\n    };\\n    \\n    /**\\n     * @returns {void}\\n     */\\n    Stack.prototype.pop = function() {\\n        while (this.queue.length > 1){\\n            this.tmp.push(this.queue.shift());\\n        }\\n        this.queue.shift();\\n        this.queue = this.tmp;\\n        this.tmp = [];\\n    };\\n    \\n    /**\\n     * @returns {number}\\n     */\\n    Stack.prototype.top = function() {\\n        while (this.queue.length > 1){\\n            this.tmp.push(this.queue.shift());\\n        }\\n        var ele = this.queue.shift();\\n        this.tmp.push(ele);\\n        this.queue = this.tmp;\\n        this.tmp = [];\\n        return ele;\\n    };\\n    \\n    /**\\n     * @returns {boolean}\\n     */\\n    Stack.prototype.empty = function() {\\n        return this.queue.length === 0;\\n        \\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var Stack = function() {\\n        this.queue = [];\\n        this.tmp = [];\\n    };\\n    \\n    /**\\n     * @param {number} x\\n     * @returns {void}\\n     */\\n    Stack.prototype.push = function(x) {\\n        this.queue.push(x);\\n    };\\n    \\n    /**\\n     * @returns {void}\\n     */\\n    Stack.prototype.pop = function() {\\n        while (this.queue.length > 1){\\n            this.tmp.push(this.queue.shift());\\n        }\\n        this.queue.shift();\\n        this.queue = this.tmp;\\n        this.tmp = [];\\n    };\\n    \\n    /**\\n     * @returns {number}\\n     */\\n    Stack.prototype.top = function() {\\n        while (this.queue.length > 1){\\n            this.tmp.push(this.queue.shift());\\n        }\\n        var ele = this.queue.shift();\\n        this.tmp.push(ele);\\n        this.queue = this.tmp;\\n        this.tmp = [];\\n        return ele;\\n    };\\n    \\n    /**\\n     * @returns {boolean}\\n     */\\n    Stack.prototype.empty = function() {\\n        return this.queue.length === 0;\\n        \\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3176923,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Using two queues to implement\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Create two queues.\\nall the functions will be same, While pushing -\\nwe have to first push all the elements from q1 to q2\\nthen insert the value into q1\\nthen push all the values from q2 to q1\\n\\nhttps://www.youtube.com/watch?v=jDZQKzEtbYQ&list=PLgUwDviBIf0p4ozDR_kJJkONnb1wdx2Ma&index=75\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n          q2.push(x);\\n      while(!q1.empty()){\\n        q2.push(q1.front());\\n        q1.pop();\\n      }\\n          swap(q1,q2);\\n    }\\n    \\n    int pop() {\\n        int ans = q1.front();\\n        q1.pop();\\n        return ans;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n          q2.push(x);\\n      while(!q1.empty()){\\n        q2.push(q1.front());\\n        q1.pop();\\n      }\\n          swap(q1,q2);\\n    }\\n    \\n    int pop() {\\n        int ans = q1.front();\\n        q1.pop();\\n        return ans;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765297,
                "title": "c-queue",
                "content": "```\\nqueue<int>q;\\n    void push(int x) {\\n        q.push(x);\\n        for(auto i=0; i<q.size()-1; i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x=q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nqueue<int>q;\\n    void push(int x) {\\n        q.push(x);\\n        for(auto i=0; i<q.size()-1; i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x=q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2763138,
                "title": "easy-python-solution",
                "content": "```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n        \\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n\\n        for _ in range(len(self.q)-1):\\n            self.q.append(self.q.popleft())\\n        \\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n        \\n\\n    def top(self) -> int:\\n        return self.q[0]\\n        \\n\\n    def empty(self) -> bool:\\n        return not len(self.q)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n        \\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n\\n        for _ in range(len(self.q)-1):\\n            self.q.append(self.q.popleft())\\n        \\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n        \\n\\n    def top(self) -> int:\\n        return self.q[0]\\n        \\n\\n    def empty(self) -> bool:\\n        return not len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009931,
                "title": "c-2-approaches-using-single-double-queue-daily-leetcoding-challenge-may-day-5",
                "content": "**Please Upvote If it Helps**\\n\\n**Approach 1  : Using Single Queue**\\n\\nIn this Approach we just used single queue , and we just pushing the same queue elements above from below and remove that after inserting.\\n\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n    MyStack() \\n    {\\n        \\n    }\\n    \\n    void push(int x) \\n    {\\n        q.push(x);\\n        \\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            // reversing the sequence and delete below elements after inserting above\\n            q.push(q.front());\\n            q.pop();\\n        }\\n        \\n    }\\n    \\n    int pop() \\n    {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() \\n    {\\n        return q.front();\\n    }\\n    \\n    bool empty() \\n    {\\n        return q.empty();\\n    }\\n};\\n```\\n\\n\\n**Approach 2 : Using Double Queue**\\n\\nIn this we used 2 Queues , first for pushing the elements and other one for storing the reverse order of that queue , so we can achieve our stack operations easily.\\n\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() \\n    {\\n        \\n    }\\n    \\n    void push(int x) \\n    {\\n        q2.push(x);\\n        while(!q1.empty())\\n        {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        swap(q1,q2);\\n    }\\n    \\n    int pop() \\n    {\\n        int x = q1.front();\\n        q1.pop();\\n        return x;\\n    }\\n    \\n    int top() \\n    {\\n        return q1.front();\\n    }\\n    \\n    bool empty() \\n    {\\n        return q1.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n    MyStack() \\n    {\\n        \\n    }\\n    \\n    void push(int x) \\n    {\\n        q.push(x);\\n        \\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            // reversing the sequence and delete below elements after inserting above\\n            q.push(q.front());\\n            q.pop();\\n        }\\n        \\n    }\\n    \\n    int pop() \\n    {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() \\n    {\\n        return q.front();\\n    }\\n    \\n    bool empty() \\n    {\\n        return q.empty();\\n    }\\n};\\n```\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() \\n    {\\n        \\n    }\\n    \\n    void push(int x) \\n    {\\n        q2.push(x);\\n        while(!q1.empty())\\n        {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        swap(q1,q2);\\n    }\\n    \\n    int pop() \\n    {\\n        int x = q1.front();\\n        q1.pop();\\n        return x;\\n    }\\n    \\n    int top() \\n    {\\n        return q1.front();\\n    }\\n    \\n    bool empty() \\n    {\\n        return q1.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739187,
                "title": "easy-beginner-friendly-0ms-100-faster",
                "content": "```\\nclass MyStack {\\npublic:\\n    queue<int>q;\\n    MyStack() { }\\n    \\n    void push(int x) {\\n       \\tq.push(x);\\n\\t\\tfor(int i=0;i<q.size()-1;++i){\\n\\t\\t\\tq.push(q.front());\\n\\t\\t\\tq.pop();\\n\\t\\t}\\n    }\\n    \\n    int pop() {\\n        int item = q.front();\\n        q.pop();\\n        return item;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int>q;\\n    MyStack() { }\\n    \\n    void push(int x) {\\n       \\tq.push(x);\\n\\t\\tfor(int i=0;i<q.size()-1;++i){\\n\\t\\t\\tq.push(q.front());\\n\\t\\t\\tq.pop();\\n\\t\\t}\\n    }\\n    \\n    int pop() {\\n        int item = q.front();\\n        q.pop();\\n        return item;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62610,
                "title": "java-all-operations-o-1-solution",
                "content": "Build a recursive data structure to simulate a stack.\\nEach item in the queue is either a number or another queue. The first added element is deep withing this structure:\\n\\n    start:                  null\\n    push 1:             [1, null ]\\n    push 2:         [2, [1, null ] ] \\n    push 3:     [3, [2, [1, null ] ] ]\\n    push 4: [4, [3, [2, [1, null ] ] ] ]\\n    pop   : queue.pop-front is 4, then queue.pop-front is [3, [2, [1, null ] ] ]\\n    pop   : queue.pop-front is 3, then queue.pop-front is [2, [1, null ] ]\\n\\nAnd the code which needs a few \"unsafe\" operations in Java 5 Generics (the interface can still be type-safe though, because the structure is well-known and private):\\n\\n    class MyStack {\\n        // push to back = add(), peek = peek(), pop from front = poll(), is empty = isEmpty()\\n        private Queue<Object> queue = null;\\n        public void push(int x) {\\n            Queue deeper = queue;\\n            queue = new LinkedList<Object>();\\n            queue.add(x);\\n            queue.add(deeper);\\n        }\\n        @SuppressWarnings(\"unchecked\")\\n        public void pop() {\\n            // unused variable, just to show what's going on\\n            int x = (Integer)queue.poll();\\n            queue = (Queue<Object>)queue.poll();\\n        }\\n        public int top() {\\n            return (Integer)queue.peek();\\n        }\\n        public boolean empty() {\\n            return queue == null;\\n        }\\n    }\\n\\nThe main memory usage is still `O(n)` to store the `int` and there's one extra Queue object per item. It's actually a weird linked list implementation with a node being a queue of two items: containing data and next pointer. The recursive structure won't be a problem, because it's just pointers pointing around the heap randomly.",
                "solutionTags": [
                    "Java"
                ],
                "code": "Build a recursive data structure to simulate a stack.\\nEach item in the queue is either a number or another queue. The first added element is deep withing this structure:\\n\\n    start:                  null\\n    push 1:             [1, null ]\\n    push 2:         [2, [1, null ] ] \\n    push 3:     [3, [2, [1, null ] ] ]\\n    push 4: [4, [3, [2, [1, null ] ] ] ]\\n    pop   : queue.pop-front is 4, then queue.pop-front is [3, [2, [1, null ] ] ]\\n    pop   : queue.pop-front is 3, then queue.pop-front is [2, [1, null ] ]\\n\\nAnd the code which needs a few \"unsafe\" operations in Java 5 Generics (the interface can still be type-safe though, because the structure is well-known and private):\\n\\n    class MyStack {\\n        // push to back = add(), peek = peek(), pop from front = poll(), is empty = isEmpty()\\n        private Queue<Object> queue = null;\\n        public void push(int x) {\\n            Queue deeper = queue;\\n            queue = new LinkedList<Object>();\\n            queue.add(x);\\n            queue.add(deeper);\\n        }\\n        @SuppressWarnings(\"unchecked\")\\n        public void pop() {\\n            // unused variable, just to show what's going on\\n            int x = (Integer)queue.poll();\\n            queue = (Queue<Object>)queue.poll();\\n        }\\n        public int top() {\\n            return (Integer)queue.peek();\\n        }\\n        public boolean empty() {\\n            return queue == null;\\n        }\\n    }\\n\\nThe main memory usage is still `O(n)` to store the `int` and there's one extra Queue object per item. It's actually a weird linked list implementation with a node being a queue of two items: containing data and next pointer. The recursive structure won't be a problem, because it's just pointers pointing around the heap randomly.",
                "codeTag": "Java"
            },
            {
                "id": 2918591,
                "title": "c-solution",
                "content": "# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n    Using Two Queues\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    Push - O(1) per operation\\n    Pop - O(n) per operation\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1, q2;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        while(q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int x = q1.front();\\n        q1.pop();\\n        swap(q1, q2);\\n        return x;\\n    }\\n    \\n    int top() {\\n        while(q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int x = q1.front();\\n        q2.push(q1.front());\\n        q1.pop();\\n        swap(q1, q2);\\n        return x;\\n    }\\n    \\n    bool empty() {\\n        if(q1.empty() and q2.empty()) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\n    Using One Queue\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    Push - O(n) per operation\\n    Pop - O(1) per operation\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int len = q.size();\\n        q.push(x);\\n        while(len--) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        int x = q.front();\\n        return x;\\n    }\\n    \\n    bool empty() {\\n        if(q.empty()) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q1, q2;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        while(q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int x = q1.front();\\n        q1.pop();\\n        swap(q1, q2);\\n        return x;\\n    }\\n    \\n    int top() {\\n        while(q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int x = q1.front();\\n        q2.push(q1.front());\\n        q1.pop();\\n        swap(q1, q2);\\n        return x;\\n    }\\n    \\n    bool empty() {\\n        if(q1.empty() and q2.empty()) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\n```\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int len = q.size();\\n        q.push(x);\\n        while(len--) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        int x = q.front();\\n        return x;\\n    }\\n    \\n    bool empty() {\\n        if(q.empty()) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009225,
                "title": "c-solution-with-one-queue",
                "content": "Basically, the program orderes all of the items in the queue in the exact same order as a stack would be implemented. In order to push an item to the stack, the program pushes the item to the queue and then places the item to the beginning of the queue by cycling through the entire queue; otherwise, the other operations are the exact same as a regular queue.\\n```\\nclass MyStack {\\nprivate:\\n    queue<int> data;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        data.push(x);\\n        for (int i = 0; i < data.size() - 1; ++i) {\\n            data.push(pop());\\n        }\\n    }\\n    \\n    int pop() {\\n        int result = top();\\n        data.pop();\\n        return result;\\n    }\\n    \\n    int top() {\\n        return data.front();\\n    }\\n    \\n    bool empty() {\\n        return data.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MyStack {\\nprivate:\\n    queue<int> data;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        data.push(x);\\n        for (int i = 0; i < data.size() - 1; ++i) {\\n            data.push(pop());\\n        }\\n    }\\n    \\n    int pop() {\\n        int result = top();\\n        data.pop();\\n        return result;\\n    }\\n    \\n    int top() {\\n        return data.front();\\n    }\\n    \\n    bool empty() {\\n        return data.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615467,
                "title": "easiest-python-solution-using-deque-95-faster-and-beats-93-in-memory",
                "content": "```class MyStack:\\n\\n    def __init__(self):\\n        self.stack = deque()\\n        \\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        \\n\\n    def pop(self) -> int:\\n        return self.stack.pop()\\n        \\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n        \\n\\n    def empty(self) -> bool:\\n        if len(self.stack)>0:\\n            return False\\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class MyStack:\\n\\n    def __init__(self):\\n        self.stack = deque()\\n        \\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        \\n\\n    def pop(self) -> int:\\n        return self.stack.pop()\\n        \\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n        \\n\\n    def empty(self) -> bool:\\n        if len(self.stack)>0:\\n            return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1526552,
                "title": "easy-java-solution",
                "content": "```\\nclass MyStack {\\n\\n    Queue<Integer> q = new LinkedList<>(); \\n\\n    public void push(int x) {\\n        q.add(x);\\n        for(int i=1; i<q.size(); i++){\\n            q.add(q.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q.remove();\\n    }\\n    \\n    public int top() {\\n        return q.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n\\n    Queue<Integer> q = new LinkedList<>(); \\n\\n    public void push(int x) {\\n        q.add(x);\\n        for(int i=1; i<q.size(); i++){\\n            q.add(q.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q.remove();\\n    }\\n    \\n    public int top() {\\n        return q.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62608,
                "title": "java-solution-with-two-queues",
                "content": "class MyStack {\\n\\n\\n    Queue q1  = new LinkedList();\\n    Queue q2 = new LinkedList();\\n\\n    public void push(int x) {\\n    \\tif(!q2.isEmpty())\\n    \\t\\tq2.add(x);\\n    \\telse\\n    \\t\\tq1.add(x);\\n    }\\n\\n    // Removes the element on top of the stack.\\n    public void pop() {\\n    \\tif(!q2.isEmpty()){\\n    \\t\\twhile(q2.size()>1){\\n            \\tq1.add(q2.poll());\\n            }\\n            q2.poll();\\n    \\t}\\n    \\telse{\\n    \\t\\twhile(q1.size()>1){\\n            \\tq2.add(q1.poll());\\n            }\\n            q1.poll();\\n    \\t}\\n    \\t\\t\\n        \\n    }\\n\\n    // Get the top element.\\n    public  int top() {\\n    \\tint e = 0 ;\\n        if(!q2.isEmpty()){\\n        \\t\\n        \\twhile(q2.size()>1){\\n             \\tq1.add(q2.poll());\\n        \\t }\\n        \\t e = (int) q2.poll();\\n        \\t q1.add(e);\\n        }\\n        else\\n        {\\n        \\t\\n        \\t while(q1.size()>1){\\n              \\tq2.add(q1.poll());\\n        \\t }\\n         \\t e = (int) q1.poll();\\n         \\t q2.add(e);\\n        }\\n\\t\\treturn e;\\n    }\\n\\n    // Return whether the stack is empty.\\n    public boolean empty() {\\n        if(q1.isEmpty()&&q2.isEmpty()) return true;\\n        else return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class MyStack {\\n\\n\\n    Queue q1  = new LinkedList();\\n    Queue q2 = new LinkedList();\\n\\n    public void push(int x) {\\n    \\tif(!q2.isEmpty())\\n    \\t\\tq2.add(x);\\n    \\telse\\n    \\t\\tq1.add(x);\\n    }\\n\\n    // Removes the element on top of the stack.\\n    public void pop() {\\n    \\tif(!q2.isEmpty()){\\n    \\t\\twhile(q2.size()>1){\\n            \\tq1.add(q2.poll());\\n            }\\n            q2.poll();\\n    \\t}\\n    \\telse{\\n    \\t\\twhile(q1.size()>1){\\n            \\tq2.add(q1.poll());\\n            }\\n            q1.poll();\\n    \\t}\\n    \\t\\t\\n        \\n    }\\n\\n    // Get the top element.\\n    public  int top() {\\n    \\tint e = 0 ;\\n        if(!q2.isEmpty()){\\n        \\t\\n        \\twhile(q2.size()>1){\\n             \\tq1.add(q2.poll());\\n        \\t }\\n        \\t e = (int) q2.poll();\\n        \\t q1.add(e);\\n        }\\n        else\\n        {\\n        \\t\\n        \\t while(q1.size()>1){\\n              \\tq2.add(q1.poll());\\n        \\t }\\n         \\t e = (int) q1.poll();\\n         \\t q2.add(e);\\n        }\\n\\t\\treturn e;\\n    }\\n\\n    // Return whether the stack is empty.\\n    public boolean empty() {\\n        if(q1.isEmpty()&&q2.isEmpty()) return true;\\n        else return false;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3970959,
                "title": "c-all-three-implementations-2queues-1queue-deque-w-comments",
                "content": "Underwritten are easy codes for all the three approaches, explained with the help of comments.\\nsuggestions and comments are welcome!\\nPLEASE UPVOTE IF THIS HELPED! \\ncheers!\\n\\n# Codes\\n**DEQUE APPROACH**\\n```\\nclass MyStack {\\nprivate:\\n    deque<int>dq; //declare the deque in private scope\\npublic:\\n    MyStack() {\\n    }\\n    \\n    void push(int x) {\\n        dq.push_back(x); //in deque u can push_front or push_back (here we will push_back for stack like usage)\\n    }\\n    \\n    int pop() {\\n        int x =  dq.back(); //store the back element in a variable\\n        dq.pop_back(); //remove the back element (top of stack)\\n        return x; //return the variable\\n    }\\n    \\n    int top() {\\n        return dq.back(); \\n    }\\n    \\n    bool empty() {\\n        return dq.empty(); // check if deque is empty!\\n    }\\n};\\n```\\n\\n**SINGLE QUEUE APPROACH**\\n```\\nclass Stack {\\nprivate:\\n\\tqueue<int> q; //declare the deque in private scope\\npublic:\\n\\tvoid push(int x) {\\n\\t\\tq.push(x); //push into the queue and then \\n                   //according to the size of the queue, reverse it\\n\\t\\tfor(int i=0;i<q.size()-1;++i){\\n\\t\\t\\tq.push(q.front());\\n\\t\\t\\tq.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tvoid pop() {\\n\\t\\tq.pop();\\n\\t}\\n\\n\\tint top() {\\n\\t\\treturn q.front();  //return the front element. that would correspond to the stack.top()\\n\\t}\\n\\n\\tbool empty() {\\n\\t\\treturn q.empty(); // check if the queue is empty.\\n\\t}\\n};\\n```\\n\\n**DOUBLE QUEUE APPROACH**\\n```\\nclass MyStack {\\nprivate:\\n    queue<int> q1; //declare your queues in private scope\\n    queue<int> q2;\\npublic:\\n    MyStack() {   \\n    }\\n    \\n    void push(int x) {\\n\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front()); \\n            q1.pop();\\n        }\\n        swap(q1, q2);\\n    }\\n    \\n    int pop() {\\n        int res = top();\\n        q1.pop();\\n        return res;\\n    }\\n\\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\nprivate:\\n    deque<int>dq; //declare the deque in private scope\\npublic:\\n    MyStack() {\\n    }\\n    \\n    void push(int x) {\\n        dq.push_back(x); //in deque u can push_front or push_back (here we will push_back for stack like usage)\\n    }\\n    \\n    int pop() {\\n        int x =  dq.back(); //store the back element in a variable\\n        dq.pop_back(); //remove the back element (top of stack)\\n        return x; //return the variable\\n    }\\n    \\n    int top() {\\n        return dq.back(); \\n    }\\n    \\n    bool empty() {\\n        return dq.empty(); // check if deque is empty!\\n    }\\n};\\n```\n```\\nclass Stack {\\nprivate:\\n\\tqueue<int> q; //declare the deque in private scope\\npublic:\\n\\tvoid push(int x) {\\n\\t\\tq.push(x); //push into the queue and then \\n                   //according to the size of the queue, reverse it\\n\\t\\tfor(int i=0;i<q.size()-1;++i){\\n\\t\\t\\tq.push(q.front());\\n\\t\\t\\tq.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tvoid pop() {\\n\\t\\tq.pop();\\n\\t}\\n\\n\\tint top() {\\n\\t\\treturn q.front();  //return the front element. that would correspond to the stack.top()\\n\\t}\\n\\n\\tbool empty() {\\n\\t\\treturn q.empty(); // check if the queue is empty.\\n\\t}\\n};\\n```\n```\\nclass MyStack {\\nprivate:\\n    queue<int> q1; //declare your queues in private scope\\n    queue<int> q2;\\npublic:\\n    MyStack() {   \\n    }\\n    \\n    void push(int x) {\\n\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front()); \\n            q1.pop();\\n        }\\n        swap(q1, q2);\\n    }\\n    \\n    int pop() {\\n        int res = top();\\n        q1.pop();\\n        return res;\\n    }\\n\\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969692,
                "title": "c-priority-queue-deque-2-queues-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are solutions using queues. The TC for pop and push will be $O(1), O(n)$ (or $O(n), O(1)$) depending on the way of implementation. Using priority_queue to construct has TC $O(\\\\log n)$ both for push and pop!\\n\\nUsing deque makes everything happy $O(1)$\\n\\nFollow the rules, use 2 queues to construct for which pop has TC $O(n)$, and other methods have TC $O(1)$!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using priority_queue\\n```\\nclass MyStack {\\npublic:\\n    using int2=pair<int, int>;\\n    priority_queue<int2> pq;\\n    int counter=0;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        pq.push({counter++, x});\\n    }\\n    \\n    int pop() {\\n        int x=pq.top().second;\\n        counter--;\\n        pq.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return pq.top().second;\\n    }\\n    \\n    bool empty() {\\n        return pq.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\\n# code using deque\\n```\\nclass MyStack {\\npublic:\\n    deque<int> q;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push_back(x);\\n    }\\n    \\n    int pop() {\\n        int x=q.back();\\n        q.pop_back();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.back();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n```\\n# code using 2 queues Beats 100%\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q0, q1;\\n    int Top;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {//O(1)\\n        q0.push(x);\\n        Top=x;\\n    }\\n    \\n    int pop() {//O(n)\\n        while (q0.size() > 1) {\\n            Top = q0.front();\\n            q0.pop();\\n            q1.push(Top);\\n        }\\n        int x=q0.front();\\n        q0.pop();\\n        swap(q0, q1);\\n        return x;\\n    }\\n    \\n    int top() {//O(1)\\n        return Top;\\n    }\\n    \\n    bool empty() {//O(1)\\n        return q0.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    using int2=pair<int, int>;\\n    priority_queue<int2> pq;\\n    int counter=0;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        pq.push({counter++, x});\\n    }\\n    \\n    int pop() {\\n        int x=pq.top().second;\\n        counter--;\\n        pq.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return pq.top().second;\\n    }\\n    \\n    bool empty() {\\n        return pq.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\n```\\nclass MyStack {\\npublic:\\n    deque<int> q;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push_back(x);\\n    }\\n    \\n    int pop() {\\n        int x=q.back();\\n        q.pop_back();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.back();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n```\n```\\nclass MyStack {\\npublic:\\n    queue<int> q0, q1;\\n    int Top;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {//O(1)\\n        q0.push(x);\\n        Top=x;\\n    }\\n    \\n    int pop() {//O(n)\\n        while (q0.size() > 1) {\\n            Top = q0.front();\\n            q0.pop();\\n            q1.push(Top);\\n        }\\n        int x=q0.front();\\n        q0.pop();\\n        swap(q0, q1);\\n        return x;\\n    }\\n    \\n    int top() {//O(1)\\n        return Top;\\n    }\\n    \\n    bool empty() {//O(1)\\n        return q0.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969632,
                "title": "beats-99-23-java-users",
                "content": "# Intuition\\nWe use 2 queues to implement one stack.\\n\\n# Approach\\nWhile adding i.e. pushing into the stack is simply addind an element to the queue. While we are popping out the element we need to pop all the elements from one queue and push them into the other queue and swap to the original first queue. The left over elememt in the queue is the top element of the stack that\\'s it.\\n\\n\\n# Code\\n```\\nclass MyStack {\\n    private Queue<Integer> q1;\\n    private Queue<Integer> q2;\\n\\n    /** Initialize your data structure here. */\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n\\n    /** Push element x onto stack. */\\n    public void push(int x) {\\n        q1.add(x);\\n    }\\n\\n    /** Removes the element on top of the stack and returns that element. */\\n    public int pop() {\\n        while (q1.size() > 1) {\\n            q2.add(q1.poll());\\n        }\\n        int rst = q1.poll();\\n        swap();\\n        return rst;\\n    }\\n\\n    /** Get the top element. */\\n    public int top() {\\n        while (q1.size() > 1) {\\n            q2.add(q1.poll());\\n        }\\n        int rst = q1.poll();\\n        q2.add(rst);\\n        swap();\\n        return rst;\\n    }\\n\\n    /** Returns whether the stack is empty. */\\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n\\n    /** Swap the two queues. */\\n    private void swap() {\\n        Queue<Integer> temp = q1;\\n        q1 = q2;\\n        q2 = temp;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\n    private Queue<Integer> q1;\\n    private Queue<Integer> q2;\\n\\n    /** Initialize your data structure here. */\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n\\n    /** Push element x onto stack. */\\n    public void push(int x) {\\n        q1.add(x);\\n    }\\n\\n    /** Removes the element on top of the stack and returns that element. */\\n    public int pop() {\\n        while (q1.size() > 1) {\\n            q2.add(q1.poll());\\n        }\\n        int rst = q1.poll();\\n        swap();\\n        return rst;\\n    }\\n\\n    /** Get the top element. */\\n    public int top() {\\n        while (q1.size() > 1) {\\n            q2.add(q1.poll());\\n        }\\n        int rst = q1.poll();\\n        q2.add(rst);\\n        swap();\\n        return rst;\\n    }\\n\\n    /** Returns whether the stack is empty. */\\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n\\n    /** Swap the two queues. */\\n    private void swap() {\\n        Queue<Integer> temp = q1;\\n        q1 = q2;\\n        q2 = temp;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716275,
                "title": "c-solution-with-100-optimal-time-complexity-o-size-for-pop-o-1-for-all-other-operations",
                "content": "# Intuition\\nStack: Last-In-First-Out (LIFO)\\nQueue: First-In-First-Out (FIFO)\\n\\n# Approach\\nAchieving Last-In-First-Out (LIFO) Behavior in a Queue: Reversing the queue during element removal\\n\\n# Complexity\\n- Time complexity: O(size_of_queue) for pop & O(1) for all other operations\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(size_of_queue)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    //declared the queue Q1\\n    queue<int> Q1;\\n    MyStack()\\n    { \\n\\n    }\\n    void push(int x)\\n    {\\n        //for pushing any element we just need to pust it into the Q1\\n        Q1.push(x);\\n    }\\n    \\n    int pop()\\n    {\\n        //here is the implementation of reversing the queue\\n        int size = Q1.size();\\n        int x;\\n        while(size > 1)\\n        {\\n            x = Q1.front();\\n            Q1.pop();\\n            Q1.push(x);\\n            size--;\\n        }\\n        x = Q1.front();\\n        Q1.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return Q1.back();\\n    }\\n    \\n    bool empty() {\\n        return Q1.empty();\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Queue"
                ],
                "code": "# Intuition\\nStack: Last-In-First-Out (LIFO)\\nQueue: First-In-First-Out (FIFO)\\n\\n# Approach\\nAchieving Last-In-First-Out (LIFO) Behavior in a Queue: Reversing the queue during element removal\\n\\n# Complexity\\n- Time complexity: O(size_of_queue) for pop & O(1) for all other operations\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(size_of_queue)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    //declared the queue Q1\\n    queue<int> Q1;\\n    MyStack()\\n    { \\n\\n    }\\n    void push(int x)\\n    {\\n        //for pushing any element we just need to pust it into the Q1\\n        Q1.push(x);\\n    }\\n    \\n    int pop()\\n    {\\n        //here is the implementation of reversing the queue\\n        int size = Q1.size();\\n        int x;\\n        while(size > 1)\\n        {\\n            x = Q1.front();\\n            Q1.pop();\\n            Q1.push(x);\\n            size--;\\n        }\\n        x = Q1.front();\\n        Q1.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return Q1.back();\\n    }\\n    \\n    bool empty() {\\n        return Q1.empty();\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 3624153,
                "title": "best-o-1-solution",
                "content": "# Approach\\nUsing one queue\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ --> Push\\n$$O(1)$$ --> Pop, Top, Empty\\n\\n- Space complexity:\\n$$O(n)$$ --> Queue\\n\\n# Code\\n```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int n = q.size();\\n        q.push(x);\\n        for (int i = 0; i < n; i++) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int n = q.size();\\n        q.push(x);\\n        for (int i = 0; i < n; i++) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316599,
                "title": "100-beats-0-ms-4-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int>q;\\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++){\\n            q.push(q.front()); q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int temp=q.front();q.pop();\\n        return temp;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int>q;\\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++){\\n            q.push(q.front()); q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int temp=q.front();q.pop();\\n        return temp;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010473,
                "title": "implement-stack-using-queues-python",
                "content": "```\\nclass MyStack:\\n    def __init__(self):\\n        self.myStack=[]\\n    def push(self, x: int) -> None:\\n        self.myStack.append(x)\\n    def pop(self) -> int:\\n        top=self.myStack[-1]\\n        self.myStack=self.myStack[:-1]\\n        return top\\n    def top(self) -> int:\\n        return self.myStack[-1]\\n    def empty(self) -> bool:\\n        if len(self.myStack)==0:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass MyStack:\\n    def __init__(self):\\n        self.myStack=[]\\n    def push(self, x: int) -> None:\\n        self.myStack.append(x)\\n    def pop(self) -> int:\\n        top=self.myStack[-1]\\n        self.myStack=self.myStack[:-1]\\n        return top\\n    def top(self) -> int:\\n        return self.myStack[-1]\\n    def empty(self) -> bool:\\n        if len(self.myStack)==0:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009860,
                "title": "easy-rotate-the-queue-simple-c-solution-0ms",
                "content": "**Easy** simple use of queue. Just rotate the queue while pushing and thats it ! \\n\\n```\\nclass MyStack {\\npublic:\\n    MyStack() {\\n        \\n    }\\n    queue<int> q;\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;++i){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int e = q.front();\\n        q.pop();\\n         return e;\\n    }\\n    \\n    int top() {\\n       return q.front(); \\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    MyStack() {\\n        \\n    }\\n    queue<int> q;\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;++i){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int e = q.front();\\n        q.pop();\\n         return e;\\n    }\\n    \\n    int top() {\\n       return q.front(); \\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009726,
                "title": "java-linkedlist-100-faster-solution",
                "content": "```\\nclass MyStack {\\n    final LinkedList<Integer> nums;\\n\\n    public MyStack() {\\n        nums = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        nums.push(x);\\n    }\\n\\n    public int pop() {\\n        return nums.pop();\\n    }\\n\\n    public int top() {\\n        return nums.getFirst();\\n    }\\n\\n    public boolean empty() {\\n        return nums.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass MyStack {\\n    final LinkedList<Integer> nums;\\n\\n    public MyStack() {\\n        nums = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        nums.push(x);\\n    }\\n\\n    public int pop() {\\n        return nums.pop();\\n    }\\n\\n    public int top() {\\n        return nums.getFirst();\\n    }\\n\\n    public boolean empty() {\\n        return nums.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009308,
                "title": "python-fastest-easiest-list-99-01-solution",
                "content": "```python\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.queue=[]\\n\\n    def push(self, x: int) -> None:\\n        self.queue.append(x)\\n\\n    def pop(self) -> int:\\n        top = self.queue[-1]\\n        self.queue = self.queue[:-1]\\n        return top\\n    \\n    def top(self) -> int:\\n        return self.queue[-1]    \\n\\n    def empty(self) -> bool:\\n        return False if self.queue else True\\n```\\n\\nPlease commnet below if you have any further questions and UPVOTE if you like it!\\nAll the solutions that I\\'ve been through is archived here: https://github.com/hyeseonko/LeetCode",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Queue"
                ],
                "code": "```python\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.queue=[]\\n\\n    def push(self, x: int) -> None:\\n        self.queue.append(x)\\n\\n    def pop(self) -> int:\\n        top = self.queue[-1]\\n        self.queue = self.queue[:-1]\\n        return top\\n    \\n    def top(self) -> int:\\n        return self.queue[-1]    \\n\\n    def empty(self) -> bool:\\n        return False if self.queue else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413294,
                "title": "c-3-different-ways",
                "content": "```\\n//Approach-1 (Using doubly ended queue) -> Don\\'t do this in interview (I am just sharing an approach. The question asks for usin Queue only :-))\\nclass MyStack {\\npublic:\\n    deque<int> deq;\\n    /** Initialize your data structure here. */\\n    MyStack() {\\n        deq.clear();\\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        return deq.push_back(x);\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int top = deq.back();\\n        deq.pop_back();\\n        return top;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return deq.back();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return deq.empty();\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using 2 queues with O(n) pop)\\nclass MyStack {\\npublic:\\n    queue<int> que;\\n    int topEl = -1;\\n    /** Initialize your data structure here. */\\n    MyStack() {\\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        topEl = x;\\n        que.push(x);\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        queue<int> tempQue;\\n        int size       = que.size();\\n        int last       = -1;\\n        int secondLast = -1;\\n        while(size > 0) {\\n            int x = que.front();\\n            que.pop();\\n            if(size > 1)\\n                tempQue.push(x);\\n            secondLast = last;\\n            last = x;\\n            size--;\\n        }\\n        que   = tempQue;\\n        topEl = secondLast;\\n        return last;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return topEl;\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return que.empty();\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (Using single queue with O(n) push)\\nclass MyStack {\\npublic:\\n    queue<int> que;\\n    /** Initialize your data structure here. */\\n    MyStack() {\\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        que.push(x);\\n        for(int i = 0; i<que.size()-1; i++) {\\n            que.push(que.front());\\n            que.pop();\\n        }\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int x = que.front();\\n        que.pop();\\n        return x;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return que.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return que.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using doubly ended queue) -> Don\\'t do this in interview (I am just sharing an approach. The question asks for usin Queue only :-))\\nclass MyStack {\\npublic:\\n    deque<int> deq;\\n    /** Initialize your data structure here. */\\n    MyStack() {\\n        deq.clear();\\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        return deq.push_back(x);\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int top = deq.back();\\n        deq.pop_back();\\n        return top;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return deq.back();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return deq.empty();\\n    }\\n};\\n```\n```\\n//Approach-2 (Using 2 queues with O(n) pop)\\nclass MyStack {\\npublic:\\n    queue<int> que;\\n    int topEl = -1;\\n    /** Initialize your data structure here. */\\n    MyStack() {\\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        topEl = x;\\n        que.push(x);\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        queue<int> tempQue;\\n        int size       = que.size();\\n        int last       = -1;\\n        int secondLast = -1;\\n        while(size > 0) {\\n            int x = que.front();\\n            que.pop();\\n            if(size > 1)\\n                tempQue.push(x);\\n            secondLast = last;\\n            last = x;\\n            size--;\\n        }\\n        que   = tempQue;\\n        topEl = secondLast;\\n        return last;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return topEl;\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return que.empty();\\n    }\\n};\\n```\n```\\n//Approach-3 (Using single queue with O(n) push)\\nclass MyStack {\\npublic:\\n    queue<int> que;\\n    /** Initialize your data structure here. */\\n    MyStack() {\\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        que.push(x);\\n        for(int i = 0; i<que.size()-1; i++) {\\n            que.push(que.front());\\n            que.pop();\\n        }\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int x = que.front();\\n        que.pop();\\n        return x;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return que.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return que.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313676,
                "title": "simple-and-easy-python-solution",
                "content": "```\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.queue=deque()\\n        \\n        \\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        self.queue.append(x)\\n        \\n        for _ in range(len(self.queue)-1):\\n            self.queue.append( self.queue.popleft() )\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        return self.queue.popleft()\\n        \\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        return self.queue[0]\\n        \\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        return (not self.queue)\\n        \\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.queue=deque()\\n        \\n        \\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        self.queue.append(x)\\n        \\n        for _ in range(len(self.queue)-1):\\n            self.queue.append( self.queue.popleft() )\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        return self.queue.popleft()\\n        \\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        return self.queue[0]\\n        \\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        return (not self.queue)\\n        \\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312615,
                "title": "python-use-deque",
                "content": "```\\nclass MyStack(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.q = collections.deque()\\n        \\n\\n    def push(self, x):\\n        \"\"\"\\n        Push element x onto stack.\\n        :type x: int\\n        :rtype: None\\n        \"\"\"\\n        self.q.appendleft(x)\\n        \\n\\n    def pop(self):\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        :rtype: int\\n        \"\"\"\\n        return self.q.popleft()\\n        \\n\\n    def top(self):\\n        \"\"\"\\n        Get the top element.\\n        :rtype: int\\n        \"\"\"\\n        return self.q[0]\\n        \\n\\n    def empty(self):\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        :rtype: bool\\n        \"\"\"\\n        return not self.q\\n      \\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "solutionTags": [],
                "code": "```\\nclass MyStack(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.q = collections.deque()\\n        \\n\\n    def push(self, x):\\n        \"\"\"\\n        Push element x onto stack.\\n        :type x: int\\n        :rtype: None\\n        \"\"\"\\n        self.q.appendleft(x)\\n        \\n\\n    def pop(self):\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        :rtype: int\\n        \"\"\"\\n        return self.q.popleft()\\n        \\n\\n    def top(self):\\n        \"\"\"\\n        Get the top element.\\n        :rtype: int\\n        \"\"\"\\n        return self.q[0]\\n        \\n\\n    def empty(self):\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        :rtype: bool\\n        \"\"\"\\n        return not self.q\\n      \\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969721,
                "title": "python3-solution",
                "content": "\\n```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q=deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n\\n    def pop(self) -> int:\\n        for i in range(len(self.q)-1):\\n            self.push(self.q.popleft())\\n        return self.q.popleft()    \\n\\n    def top(self) -> int:\\n        return self.q[-1]\\n\\n    def empty(self) -> bool:\\n        return len(self.q)==0\\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q=deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n\\n    def pop(self) -> int:\\n        for i in range(len(self.q)-1):\\n            self.push(self.q.popleft())\\n        return self.q.popleft()    \\n\\n    def top(self) -> int:\\n        return self.q[-1]\\n\\n    def empty(self) -> bool:\\n        return len(self.q)==0\\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443257,
                "title": "amortized-o-1-solution",
                "content": "# Intuition\\nUSING ONLY ONE QUEUE\\n\\n# Approach\\nRemoving element from front and adding it to the back, to maintain stack order\\n\\n# Complexity\\n- Time complexity:\\nO(1) for every single operation\\n\\n- Space complexity:\\nO(n), where n is the size of queue\\n\\n# Code\\n```\\nclass MyStack {\\n Queue<Integer> q;\\n    public MyStack() {\\n       q= new LinkedList <>();\\n    }\\n    \\n    public void push(int x) {\\n        q.add(x);\\n        for(int i=0;i<q.size()-1;i++){\\n            q.add(q.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q.remove();\\n    }\\n    \\n    public int top() {\\n        return q.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return(q.isEmpty());\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```\\nPLEASE PLEASE PLEASE UPVOTE GUYS IF YOU LIKE THE SOLUTION",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n Queue<Integer> q;\\n    public MyStack() {\\n       q= new LinkedList <>();\\n    }\\n    \\n    public void push(int x) {\\n        q.add(x);\\n        for(int i=0;i<q.size()-1;i++){\\n            q.add(q.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q.remove();\\n    }\\n    \\n    public int top() {\\n        return q.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return(q.isEmpty());\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313109,
                "title": "java-solution-to-implement-a-stack-using-two-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->There are two approaches - \\n1. In which the push operation is for O(n) and pop and peek are for O(1).\\n2. Second one is Pop is for O(n).\\nWe are using the second approach int his solution where pop operation is of O(n) TC.********************\\n\\n\\n# Complexity\\n- Time complexity:\\n- Push-O(1)\\n- Pop O(n)\\n- peek O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\n    static Queue<Integer> q1;\\n        static Queue<Integer> q2;\\n\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        if(!q1.isEmpty()){\\n                q1.add(x);\\n            } else{\\n                q2.add(x);\\n            }\\n    }\\n    \\n    public int pop() {\\n        if(empty()){\\n                return -1;\\n            }\\n\\n            int top =-1;\\n            if(!q1.isEmpty()){\\n                while(!q1.isEmpty()){\\n                    top = q1.remove();\\n                    if(q1.isEmpty()){\\n                        break;\\n                    }\\n                    q2.add(top);\\n                }\\n            } else{\\n                while(!q2.isEmpty()){\\n                    top=q2.remove();\\n                    if(q2.isEmpty()){\\n                        break;\\n                    }\\n                    q1.add(top);\\n                }\\n\\n            }\\n            return top;\\n    }\\n    \\n    public int top() {\\n        \\n        if(empty()){\\n                return -1;\\n            }\\n\\n            int top =-1;\\n            if(!q1.isEmpty()){\\n                while(!q1.isEmpty()){\\n                    top = q1.remove();\\n                    q2.add(top);\\n                }\\n            } else{\\n                while(!q2.isEmpty()){\\n                    top=q2.remove();\\n                    q1.add(top);\\n                }\\n\\n            }\\n            return top;\\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty() && q2.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n    static Queue<Integer> q1;\\n        static Queue<Integer> q2;\\n\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        if(!q1.isEmpty()){\\n                q1.add(x);\\n            } else{\\n                q2.add(x);\\n            }\\n    }\\n    \\n    public int pop() {\\n        if(empty()){\\n                return -1;\\n            }\\n\\n            int top =-1;\\n            if(!q1.isEmpty()){\\n                while(!q1.isEmpty()){\\n                    top = q1.remove();\\n                    if(q1.isEmpty()){\\n                        break;\\n                    }\\n                    q2.add(top);\\n                }\\n            } else{\\n                while(!q2.isEmpty()){\\n                    top=q2.remove();\\n                    if(q2.isEmpty()){\\n                        break;\\n                    }\\n                    q1.add(top);\\n                }\\n\\n            }\\n            return top;\\n    }\\n    \\n    public int top() {\\n        \\n        if(empty()){\\n                return -1;\\n            }\\n\\n            int top =-1;\\n            if(!q1.isEmpty()){\\n                while(!q1.isEmpty()){\\n                    top = q1.remove();\\n                    q2.add(top);\\n                }\\n            } else{\\n                while(!q2.isEmpty()){\\n                    top=q2.remove();\\n                    q1.add(top);\\n                }\\n\\n            }\\n            return top;\\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty() && q2.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219080,
                "title": "implemented-using-single-queue",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i = 0; i < q.size()-1; i++) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int val = q.front();\\n        q.pop();\\n        return val;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i = 0; i < q.size()-1; i++) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int val = q.front();\\n        q.pop();\\n        return val;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172999,
                "title": "easy-to-understand-c-beats-100",
                "content": "# Intuition\\nUsing two queues to implement\\n\\n# Approach\\n1. Create two queues.\\n2. all the functions will be same, While pushing -\\n    - we have to first push all the elements from q1 to q2\\n    - then insert the value into q1\\n    - then push all the values from q2 to q1\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        while(!q1.empty()){\\n            int temp = q1.front();\\n            q1.pop();\\n            q2.push(temp);\\n        }\\n\\n        q1.push(x);\\n\\n        while(!q2.empty()){\\n            int temp = q2.front();\\n            q2.pop();\\n            q1.push(temp);\\n        }\\n\\n    }\\n    \\n    int pop() {\\n        int ans = q1.front();\\n        q1.pop();\\n        return ans;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        while(!q1.empty()){\\n            int temp = q1.front();\\n            q1.pop();\\n            q2.push(temp);\\n        }\\n\\n        q1.push(x);\\n\\n        while(!q2.empty()){\\n            int temp = q2.front();\\n            q2.pop();\\n            q1.push(temp);\\n        }\\n\\n    }\\n    \\n    int pop() {\\n        int ans = q1.front();\\n        q1.pop();\\n        return ans;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916706,
                "title": "beats-100-codedominar-solution",
                "content": "# Code\\n```\\nimport queue\\nclass MyStack:\\n    def __init__(self):\\n        self.q_primary = queue.Queue()\\n        self.q_helper = queue.Queue()\\n\\n    def push(self, x: int) -> None:\\n        self.q_primary.put(x)\\n    def pop(self) -> int:\\n        while self.q_primary.qsize() != 1:\\n            self.q_helper.put(self.q_primary.get())\\n        top = self.q_primary.get()\\n        while not self.q_helper.empty():\\n            self.q_primary.put(self.q_helper.get())\\n        return top\\n    def top(self) -> int:\\n        while self.q_primary.qsize() != 1:\\n            self.q_helper.put(self.q_primary.get())\\n        top = self.q_primary.get()\\n        while not self.q_helper.empty():\\n            self.q_primary.put(self.q_helper.get())\\n        self.q_primary.put(top)\\n        return top\\n    def empty(self) -> bool:\\n        return self.q_primary.qsize() == 0\\n        \\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport queue\\nclass MyStack:\\n    def __init__(self):\\n        self.q_primary = queue.Queue()\\n        self.q_helper = queue.Queue()\\n\\n    def push(self, x: int) -> None:\\n        self.q_primary.put(x)\\n    def pop(self) -> int:\\n        while self.q_primary.qsize() != 1:\\n            self.q_helper.put(self.q_primary.get())\\n        top = self.q_primary.get()\\n        while not self.q_helper.empty():\\n            self.q_primary.put(self.q_helper.get())\\n        return top\\n    def top(self) -> int:\\n        while self.q_primary.qsize() != 1:\\n            self.q_helper.put(self.q_primary.get())\\n        top = self.q_primary.get()\\n        while not self.q_helper.empty():\\n            self.q_primary.put(self.q_helper.get())\\n        self.q_primary.put(top)\\n        return top\\n    def empty(self) -> bool:\\n        return self.q_primary.qsize() == 0\\n        \\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009156,
                "title": "clean-code-easy",
                "content": "**Please upvote if it helped !**\\n```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    queue<int>q;\\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n       int temp=q.front();\\n        q.pop();\\n        return temp;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return q.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\nreturn q.empty();\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**Please upvote if it helped !**\\n```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    queue<int>q;\\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n       int temp=q.front();\\n        q.pop();\\n        return temp;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return q.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\nreturn q.empty();\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1839709,
                "title": "typescript-simple-easy-to-understand",
                "content": "```\\nclass MyQueue {\\n    queue;\\n    constructor() {\\n        this.queue = []\\n    }\\n    push(n: number) {\\n        this.queue.push(n)\\n    }\\n    peek(): (number | null) {\\n        return this.queue[0]\\n    }\\n    pop() {\\n        let r = this.peek();\\n        this.queue.shift()\\n        return r;\\n    }\\n    size() {\\n        return this.queue.length\\n    }\\n    isEmpth() {\\n        return this.queue.length == 0\\n    }\\n}\\n\\n\\nclass MyStack {\\n    public Q;\\n    constructor() {\\n        this.Q = new MyQueue()\\n    }\\n\\n    push(x: number): void {\\n        let l = this.Q.queue.length;\\n        this.Q.push(x)\\n        for(let i = 1; i <= l; i++) {\\n            let r = this.Q.pop();\\n            this.Q.push(r)\\n        }\\n    }\\n\\n    pop(): number {\\n        return this.Q.pop()\\n    }\\n\\n    top(): number {\\n        return this.Q.peek()\\n    }\\n\\n    empty(): boolean {\\n        return this.Q.queue.length == 0\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass MyQueue {\\n    queue;\\n    constructor() {\\n        this.queue = []\\n    }\\n    push(n: number) {\\n        this.queue.push(n)\\n    }\\n    peek(): (number | null) {\\n        return this.queue[0]\\n    }\\n    pop() {\\n        let r = this.peek();\\n        this.queue.shift()\\n        return r;\\n    }\\n    size() {\\n        return this.queue.length\\n    }\\n    isEmpth() {\\n        return this.queue.length == 0\\n    }\\n}\\n\\n\\nclass MyStack {\\n    public Q;\\n    constructor() {\\n        this.Q = new MyQueue()\\n    }\\n\\n    push(x: number): void {\\n        let l = this.Q.queue.length;\\n        this.Q.push(x)\\n        for(let i = 1; i <= l; i++) {\\n            let r = this.Q.pop();\\n            this.Q.push(r)\\n        }\\n    }\\n\\n    pop(): number {\\n        return this.Q.pop()\\n    }\\n\\n    top(): number {\\n        return this.Q.peek()\\n    }\\n\\n    empty(): boolean {\\n        return this.Q.queue.length == 0\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1711903,
                "title": "c-2-solutions-concise",
                "content": "**1 Queue**\\n```\\nclass MyStack {\\nprivate:\\n    queue<int> into;\\n    \\npublic:\\n    MyStack() {}\\n    \\n    void push(int x) {\\n        int i = 0;\\n        into.push(x);\\n        \\n        while(i < into.size() - 1){\\n            into.push(into.front());\\n            into.pop(); i++;\\n        }\\n    }\\n    \\n    int pop() {\\n        int top = into.front();\\n        into.pop();\\n        \\n        return top;\\n    }\\n    \\n    int top() {\\n        return into.front();\\n    }\\n    \\n    bool empty() {\\n        return into.empty();\\n    }\\n};\\n```\\n\\n**2 Queues**\\n```\\nclass MyStack {\\nprivate:\\n    queue<int> into, out;\\n    int front;\\n    \\npublic:\\n    MyStack() {}\\n    \\n    void push(int x) {\\n        into.push(x);\\n        front = x;\\n    }\\n    \\n    int pop() {\\n        queue<int> temp;\\n        int current;\\n        \\n        while(into.size() != 1){\\n            front = into.front();\\n            into.pop(); out.push(front);\\n        }\\n        \\n        current = into.front();\\n        into.pop();\\n        \\n        into = out; out = temp;\\n        \\n        return current;\\n    }\\n    \\n    int top() {\\n        return front;\\n    }\\n    \\n    bool empty() {\\n        return into.empty();\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MyStack {\\nprivate:\\n    queue<int> into;\\n    \\npublic:\\n    MyStack() {}\\n    \\n    void push(int x) {\\n        int i = 0;\\n        into.push(x);\\n        \\n        while(i < into.size() - 1){\\n            into.push(into.front());\\n            into.pop(); i++;\\n        }\\n    }\\n    \\n    int pop() {\\n        int top = into.front();\\n        into.pop();\\n        \\n        return top;\\n    }\\n    \\n    int top() {\\n        return into.front();\\n    }\\n    \\n    bool empty() {\\n        return into.empty();\\n    }\\n};\\n```\n```\\nclass MyStack {\\nprivate:\\n    queue<int> into, out;\\n    int front;\\n    \\npublic:\\n    MyStack() {}\\n    \\n    void push(int x) {\\n        into.push(x);\\n        front = x;\\n    }\\n    \\n    int pop() {\\n        queue<int> temp;\\n        int current;\\n        \\n        while(into.size() != 1){\\n            front = into.front();\\n            into.pop(); out.push(front);\\n        }\\n        \\n        current = into.front();\\n        into.pop();\\n        \\n        into = out; out = temp;\\n        \\n        return current;\\n    }\\n    \\n    int top() {\\n        return front;\\n    }\\n    \\n    bool empty() {\\n        return into.empty();\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1515750,
                "title": "easy-c-solution-using-1-queue-t-c-100-faster-s-c-99-9-faster",
                "content": "\\n```\\nqueue<int>q;\\n    MyStack() {}\\n    \\n    void push(int x) \\n    {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() \\n    {\\n       int val=q.front();\\n       q.pop(); \\n       return val;\\n    }\\n    \\n    int top() \\n    {\\n        return q.front();    \\n    }\\n    \\n    bool empty() \\n    {\\n      return q.size()==0;    \\n    }",
                "solutionTags": [],
                "code": "\\n```\\nqueue<int>q;\\n    MyStack() {}\\n    \\n    void push(int x) \\n    {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() \\n    {\\n       int val=q.front();\\n       q.pop(); \\n       return val;\\n    }\\n    \\n    int top() \\n    {\\n        return q.front();    \\n    }\\n    \\n    bool empty() \\n    {\\n      return q.size()==0;    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 814620,
                "title": "python-sol-by-queue-operation-w-comment",
                "content": "Python sol by queue operation.\\n\\n---\\n\\n```\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n\\t\\t\\n\\t\\t# python natively support double-ended queue\\n        self.queue = deque()\\n        \\n        \\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        \\n\\t\\t# push new element into queue\\'s tail\\n        self.queue.append(x)\\n        \\n        # make new element on the head position by rotation\\n        for _ in range(len(self.queue)-1):\\n            self.queue.append( self.queue.popleft() )\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        \\n\\t\\t# pop head element of queue\\n        return self.queue.popleft()\\n        \\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        \\n\\t\\t# return head element of queue\\n        return self.queue[0]\\n        \\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        \\n        return (not self.queue)\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about python deque](https://docs.python.org/3/library/collections.html?highlight=deque#collections.deque)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n\\t\\t\\n\\t\\t# python natively support double-ended queue\\n        self.queue = deque()\\n        \\n        \\n\\n    def push(self, x: int) -> None:\\n        \"\"\"\\n        Push element x onto stack.\\n        \"\"\"\\n        \\n\\t\\t# push new element into queue\\'s tail\\n        self.queue.append(x)\\n        \\n        # make new element on the head position by rotation\\n        for _ in range(len(self.queue)-1):\\n            self.queue.append( self.queue.popleft() )\\n        \\n\\n    def pop(self) -> int:\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        \"\"\"\\n        \\n\\t\\t# pop head element of queue\\n        return self.queue.popleft()\\n        \\n\\n    def top(self) -> int:\\n        \"\"\"\\n        Get the top element.\\n        \"\"\"\\n        \\n\\t\\t# return head element of queue\\n        return self.queue[0]\\n        \\n\\n    def empty(self) -> bool:\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        \"\"\"\\n        \\n        return (not self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570763,
                "title": "golang-1-queue-pop-o-n-push-o-1",
                "content": "```\\ntype MyStack struct {\\n\\tQueue MyQueue\\n}\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MyStack {\\n\\treturn MyStack{\\n\\t\\tQueue: MyQueue{[]int{}},\\n\\t}\\n}\\n\\n/** Push element x onto stack. */\\nfunc (this *MyStack) Push(x int) {\\n\\tthis.Queue.push(x)\\n}\\n\\n/** Removes the element on top of the stack and returns that element. */\\nfunc (this *MyStack) Pop() int {\\n\\tfor i := 0; i < this.Queue.size()-1; i++ {\\n\\t\\tthis.Queue.push(this.Queue.pop())\\n\\t}\\n\\treturn this.Queue.pop()\\n}\\n\\n/** Get the top element. */\\nfunc (this *MyStack) Top() int {\\n\\tfor i := 0; i < this.Queue.size()-1; i++ {\\n\\t\\tthis.Queue.push(this.Queue.pop())\\n\\t}\\n\\tx := this.Queue.pop()\\n\\tthis.Queue.push(x)\\n\\treturn x\\n}\\n\\n/** Returns whether the stack is empty. */\\nfunc (this *MyStack) Empty() bool {\\n\\treturn this.Queue.empty()\\n}\\n\\ntype MyQueue struct {\\n\\tData []int\\n}\\n\\nfunc (q *MyQueue) push(x int) {\\n\\tq.Data = append(q.Data, x)\\n}\\n\\nfunc (q *MyQueue) peek() int {\\n\\tif len(q.Data) > 0 {\\n\\t\\treturn q.Data[0]\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc (q *MyQueue) pop() int {\\n\\tif len(q.Data) > 0 {\\n\\t\\tx := q.Data[0]\\n\\t\\tq.Data = q.Data[1:]\\n\\t\\treturn x\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc (q *MyQueue) size() int {\\n\\treturn len(q.Data)\\n}\\n\\nfunc (q *MyQueue) empty() bool {\\n\\treturn len(q.Data) == 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype MyStack struct {\\n\\tQueue MyQueue\\n}\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MyStack {\\n\\treturn MyStack{\\n\\t\\tQueue: MyQueue{[]int{}},\\n\\t}\\n}\\n\\n/** Push element x onto stack. */\\nfunc (this *MyStack) Push(x int) {\\n\\tthis.Queue.push(x)\\n}\\n\\n/** Removes the element on top of the stack and returns that element. */\\nfunc (this *MyStack) Pop() int {\\n\\tfor i := 0; i < this.Queue.size()-1; i++ {\\n\\t\\tthis.Queue.push(this.Queue.pop())\\n\\t}\\n\\treturn this.Queue.pop()\\n}\\n\\n/** Get the top element. */\\nfunc (this *MyStack) Top() int {\\n\\tfor i := 0; i < this.Queue.size()-1; i++ {\\n\\t\\tthis.Queue.push(this.Queue.pop())\\n\\t}\\n\\tx := this.Queue.pop()\\n\\tthis.Queue.push(x)\\n\\treturn x\\n}\\n\\n/** Returns whether the stack is empty. */\\nfunc (this *MyStack) Empty() bool {\\n\\treturn this.Queue.empty()\\n}\\n\\ntype MyQueue struct {\\n\\tData []int\\n}\\n\\nfunc (q *MyQueue) push(x int) {\\n\\tq.Data = append(q.Data, x)\\n}\\n\\nfunc (q *MyQueue) peek() int {\\n\\tif len(q.Data) > 0 {\\n\\t\\treturn q.Data[0]\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc (q *MyQueue) pop() int {\\n\\tif len(q.Data) > 0 {\\n\\t\\tx := q.Data[0]\\n\\t\\tq.Data = q.Data[1:]\\n\\t\\treturn x\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc (q *MyQueue) size() int {\\n\\treturn len(q.Data)\\n}\\n\\nfunc (q *MyQueue) empty() bool {\\n\\treturn len(q.Data) == 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62575,
                "title": "c-single-queue-implementation",
                "content": "    class Stack {\\n    private:\\n    queue <int> Q;   \\n    public:\\n        // Push element x onto stack.\\n        void push(int x) {\\n            Q.push(x);\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        void pop() {\\n            \\n            for (int i=0; i<Q.size()-1; i++)\\n            {\\n                Q.push(Q.front());\\n                Q.pop();\\n            }\\n            Q.pop(); \\n        }\\n    \\n        // Get the top element.\\n        int top() {\\n            return Q.back();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        bool empty() {\\n            return Q.empty();\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class Stack {\\n    private:\\n    queue <int> Q;   \\n    public:\\n        // Push element x onto stack.\\n        void push(int x) {\\n            Q.push(x);\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        void pop() {\\n            \\n            for (int i=0; i<Q.size()-1; i++)\\n            {\\n                Q.push(Q.front());\\n                Q.pop();\\n            }\\n            Q.pop(); \\n        }\\n    \\n        // Get the top element.\\n        int top() {\\n            return Q.back();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        bool empty() {\\n            return Q.empty();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 62591,
                "title": "0ms-c-solution-avoided-using-size",
                "content": "    class Stack {\\n        public:\\n        // Push element x onto stack.\\n        void push(int x) {\\n            if( q1.empty() ){ \\n                q1.push(x);\\n                while (!q2.empty()){\\n                    q1.push(q2.front());\\n                    q2.pop();\\n                }\\n            }\\n            else{ \\n                q2.push(x); \\n                while (!q1.empty()){\\n                    q2.push(q1.front());\\n                    q1.pop();\\n                }\\n            }\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        void pop() {\\n            if (!q1.empty()) { q1.pop(); }\\n            else{ q2.pop(); }\\n        }\\n    \\n        // Get the top element.\\n        int top() {\\n            if (!q1.empty()) { return q1.front(); }\\n            else{ return q2.front(); }\\n        }\\n    \\n        // Return whether the stack is empty.\\n        bool empty() {\\n            return q1.empty() && q2.empty();\\n        }\\n    private:\\n        queue<int> q1, q2;\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class Stack {\\n        public:\\n        // Push element x onto stack.\\n        void push(int x) {\\n            if( q1.empty() ){ \\n                q1.push(x);\\n                while (!q2.empty()){\\n                    q1.push(q2.front());\\n                    q2.pop();\\n                }\\n            }\\n            else{ \\n                q2.push(x); \\n                while (!q1.empty()){\\n                    q2.push(q1.front());\\n                    q1.pop();\\n                }\\n            }\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        void pop() {\\n            if (!q1.empty()) { q1.pop(); }\\n            else{ q2.pop(); }\\n        }\\n    \\n        // Get the top element.\\n        int top() {\\n            if (!q1.empty()) { return q1.front(); }\\n            else{ return q2.front(); }\\n        }\\n    \\n        // Return whether the stack is empty.\\n        bool empty() {\\n            return q1.empty() && q2.empty();\\n        }\\n    private:\\n        queue<int> q1, q2;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 62668,
                "title": "simple-java-solution-any-improvements-to-this",
                "content": "    class MyStack {\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        // Push element x onto stack.\\n        public void push(int x) {\\n            q.add(x);\\n            for (int i = 0; i < q.size() - 1; i++) {\\n                q.add(q.remove());    \\n            }\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void pop() {\\n            q.remove();\\n        }\\n    \\n        // Get the top element.\\n        public int top() {\\n            return q.peek();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public boolean empty() {\\n            return q.isEmpty();\\n        }\\n    }\\n\\nAny suggestions as to what could be done to make this better/more efficient or is this it?",
                "solutionTags": [
                    "Java"
                ],
                "code": "    class MyStack {\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        // Push element x onto stack.\\n        public void push(int x) {\\n            q.add(x);\\n            for (int i = 0; i < q.size() - 1; i++) {\\n                q.add(q.remove());    \\n            }\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        public void pop() {\\n            q.remove();\\n        }\\n    \\n        // Get the top element.\\n        public int top() {\\n            return q.peek();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        public boolean empty() {\\n            return q.isEmpty();\\n        }\\n    }\\n\\nAny suggestions as to what could be done to make this better/more efficient or is this it?",
                "codeTag": "Java"
            },
            {
                "id": 62589,
                "title": "my-c-0ms-very-concise-and-simple",
                "content": "    class Stack {\\n    private:\\n    queue<int> q1,q2;\\n    public:\\n        // Push element x onto stack.\\n        void push(int x) {\\n            q2.push(x);\\n            while(!q1.empty()){\\n                q2.push(q1.front());\\n                q1.pop();\\n            }\\n            swap(q1,q2);\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        void pop() {\\n            if(!q1.empty())\\n            q1.pop();\\n        }\\n    \\n        // Get the top element.\\n        int top() {\\n            return q1.front();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        bool empty() {\\n            return q1.empty();\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class Stack {\\n    private:\\n    queue<int> q1,q2;\\n    public:\\n        // Push element x onto stack.\\n        void push(int x) {\\n            q2.push(x);\\n            while(!q1.empty()){\\n                q2.push(q1.front());\\n                q1.pop();\\n            }\\n            swap(q1,q2);\\n        }\\n    \\n        // Removes the element on top of the stack.\\n        void pop() {\\n            if(!q1.empty())\\n            q1.pop();\\n        }\\n    \\n        // Get the top element.\\n        int top() {\\n            return q1.front();\\n        }\\n    \\n        // Return whether the stack is empty.\\n        bool empty() {\\n            return q1.empty();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3973121,
                "title": "simple-solution-explained-with-examples-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that we want to use 2 queues..\\n\\nDuring the push operation , we will **just push the element in 1 of the queue..**\\n\\n**During pop and top operation..**\\n\\n1) We will **pop out all the elements from q1 until the size of q1 ==1** and the elements which we are popping out, **we will insert them in q2..**\\n\\n2) After the **q1 size becomes 1**, if we want to perform the pop operation, **we will just take the last element from q1 and just store in some int** and will pop that particular element from the queue\\n\\n3) Now , your q1 is empty and q2 is filled with elements, **so just do a swap operation ..that is swap(q1,q2)..**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor push operation we just push in the queue so **O(1)**,\\n\\nFor pop and top operation, we remove all the elements from q1 and push it in q2 so **O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are taking an extra queue so **O(N)**\\n# Code\\n```\\nclass MyStack {\\npublic:\\nqueue<int>a;\\nqueue<int>b;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        a.push(x);\\n    }\\n    \\n    int pop() {\\n        \\n        while(a.size()!=1)\\n        {\\n            int ele = a.front();\\n            a.pop();\\n            b.push(ele);\\n            \\n        }\\n        int val = a.front();\\n        a.pop();\\n        swap(a,b);\\n        return val;\\n    }\\n    \\n    int top() {\\n        \\n         while(a.size()!=1)\\n        {\\n            int ele = a.front();\\n            a.pop();\\n            b.push(ele);\\n            \\n        }\\n        int ans  = a.front();\\n        a.pop();\\n        b.push(ans);\\n\\n        swap(a,b);\\n        return ans;\\n\\n\\n    }\\n    \\n    bool empty() {\\n        if(a.size()==0)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\\n\\n**TIME FOR A MEME NOW** \\n\\n![WhatsApp Image 2023-08-28 at 23.50.16.jpeg](https://assets.leetcode.com/users/images/67fbbecf-fe07-446a-b6e1-e6618b6ba840_1693246862.2968225.jpeg)\\n\\n\\n# **IF YOU LIKE MY SOLUTION, PLEASE UPVOTE..**",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\nqueue<int>a;\\nqueue<int>b;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        a.push(x);\\n    }\\n    \\n    int pop() {\\n        \\n        while(a.size()!=1)\\n        {\\n            int ele = a.front();\\n            a.pop();\\n            b.push(ele);\\n            \\n        }\\n        int val = a.front();\\n        a.pop();\\n        swap(a,b);\\n        return val;\\n    }\\n    \\n    int top() {\\n        \\n         while(a.size()!=1)\\n        {\\n            int ele = a.front();\\n            a.pop();\\n            b.push(ele);\\n            \\n        }\\n        int ans  = a.front();\\n        a.pop();\\n        b.push(ans);\\n\\n        swap(a,b);\\n        return ans;\\n\\n\\n    }\\n    \\n    bool empty() {\\n        if(a.size()==0)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886450,
                "title": "used-only-single-queue-0ms-beats-100-c-easy-solution",
                "content": "\\n# Code\\n```\\nclass MyStack {\\npublic:\\n queue<int> q;\\n    MyStack() {\\n\\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0; i<q.size()-1; i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n       int a= q.front();\\n       q.pop();\\n       return a;\\n           }\\n    \\n    int top() {\\n      return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n queue<int> q;\\n    MyStack() {\\n\\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0; i<q.size()-1; i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n       int a= q.front();\\n       q.pop();\\n       return a;\\n           }\\n    \\n    int top() {\\n      return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780513,
                "title": "easy-java-solution-with-drawing-explanation",
                "content": "# Approach\\n\\n![image.png](https://assets.leetcode.com/users/images/c720c896-8b6a-4074-8ef5-61e699846297_1689629022.2350857.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexities of the methods are as follows:\\n\\n- push(int x) = offer(int x)  : O(n)\\n- pop() = poll()          : O(1)\\n- top() = peek()            : O(1)\\n- isEmpty()                 : O(1)\\n\\n=> TC = 0(n)\\n\\n# Code\\n```\\nclass MyStack {\\n\\n    Queue<Integer> q;\\n\\n    public MyStack() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        q.offer(x);\\n        for(int i=1; i<q.size(); i++){\\n            q.offer(q.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q.poll();\\n    }\\n    \\n    public int top() {\\n        return q.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\n\\n    Queue<Integer> q;\\n\\n    public MyStack() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        q.offer(x);\\n        for(int i=1; i<q.size(); i++){\\n            q.offer(q.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q.poll();\\n    }\\n    \\n    public int top() {\\n        return q.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299356,
                "title": "java-easy-solution-using-two-queues-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ni have used the pop operatin to solve the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo constract a stack using two queues (q1,q2) we need to simulate the stack operations by using queue operations.\\n*push\\n1:-if q1 is empty , enqueue E to q1\\n2:-if q1 is not empty , enqueue all elements from q1 to q2 then enqueue E to q1,and enqueue all elements from q2 back to q1.\\n*pop\\n1:-dequeqe an elements from q1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass MyStack {\\nQueue<Integer> q1;\\nQueue<Integer> q2;\\n   public MyStack() {\\n       q1=new LinkedList<>();\\n       q2=new LinkedList<>();\\n     \\n    }\\n    \\n    public void push(int x) {\\n        if(q1.size()>0){\\n        q1.add(x);}\\n        else{\\n            q2.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(empty()){\\n            return -1;\\n        }\\n        int peek=-1;\\n        if(q1.size()>0){\\n            while(q1.size()>0){\\n                peek=q1.remove();\\n                if(q1.size()==0){\\n                    break;\\n                }\\n                q2.add(peek);\\n            }\\n        }\\n        else{\\n             while(q2.size()>0){\\n                peek=q2.remove();\\n                if(q2.size()==0){\\n                    break;\\n                }\\n                q1.add(peek);\\n            }\\n        }\\n        return peek;\\n    }\\n    \\n    public int top() {\\n        int peek=-1;\\n         if(q1.size()>0){\\n            while(q1.size()>0){\\n                peek=q1.remove();\\n               \\n                q2.add(peek);\\n            }\\n        }\\n        else{\\n             while(q2.size()>0){\\n                peek=q2.remove();\\n             \\n                q1.add(peek);\\n            }\\n        }\\n        return peek;\\n        \\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty()&&q2.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\nQueue<Integer> q1;\\nQueue<Integer> q2;\\n   public MyStack() {\\n       q1=new LinkedList<>();\\n       q2=new LinkedList<>();\\n     \\n    }\\n    \\n    public void push(int x) {\\n        if(q1.size()>0){\\n        q1.add(x);}\\n        else{\\n            q2.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(empty()){\\n            return -1;\\n        }\\n        int peek=-1;\\n        if(q1.size()>0){\\n            while(q1.size()>0){\\n                peek=q1.remove();\\n                if(q1.size()==0){\\n                    break;\\n                }\\n                q2.add(peek);\\n            }\\n        }\\n        else{\\n             while(q2.size()>0){\\n                peek=q2.remove();\\n                if(q2.size()==0){\\n                    break;\\n                }\\n                q1.add(peek);\\n            }\\n        }\\n        return peek;\\n    }\\n    \\n    public int top() {\\n        int peek=-1;\\n         if(q1.size()>0){\\n            while(q1.size()>0){\\n                peek=q1.remove();\\n               \\n                q2.add(peek);\\n            }\\n        }\\n        else{\\n             while(q2.size()>0){\\n                peek=q2.remove();\\n             \\n                q1.add(peek);\\n            }\\n        }\\n        return peek;\\n        \\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty()&&q2.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051349,
                "title": "c-solution-with-only-single-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class MyStack {\\n\\n    Queue<int> q;\\n\\n    public MyStack() {\\n        q = new Queue<int>();\\n    }\\n    \\n    public void Push(int x) {\\n        q.Enqueue(x);\\n        \\n    }\\n    \\n    public int Pop() {\\n\\n        int top = -1;\\n\\n        if(q.Count > 0)\\n        {\\n            int qcount = q.Count;\\n            while(qcount>0)\\n            {\\n                int temp = q.Dequeue();\\n                if(qcount>1)\\n                {\\n                    q.Enqueue(temp);\\n                }\\n                else\\n                {\\n                    top = temp;\\n                }\\n                qcount--;\\n            }\\n        }\\n\\n        return top;\\n        \\n    }\\n    \\n    public int Top() {\\n          int top = -1;\\n\\n        if(q.Count > 0)\\n        {\\n            int qcount = q.Count;\\n            while(qcount>0)\\n            {\\n                int temp = q.Dequeue();                            \\n                q.Enqueue(temp);\\n                if(qcount == 1)\\n                {\\n                   top = temp;\\n                }\\n               \\n                qcount--;\\n            }\\n        }\\n\\n        return top;\\n        \\n    }\\n    \\n    public bool Empty() {\\n        return q.Count == 0;\\n    \\n        \\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.Push(x);\\n * int param_2 = obj.Pop();\\n * int param_3 = obj.Top();\\n * bool param_4 = obj.Empty();\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class MyStack {\\n\\n    Queue<int> q;\\n\\n    public MyStack() {\\n        q = new Queue<int>();\\n    }\\n    \\n    public void Push(int x) {\\n        q.Enqueue(x);\\n        \\n    }\\n    \\n    public int Pop() {\\n\\n        int top = -1;\\n\\n        if(q.Count > 0)\\n        {\\n            int qcount = q.Count;\\n            while(qcount>0)\\n            {\\n                int temp = q.Dequeue();\\n                if(qcount>1)\\n                {\\n                    q.Enqueue(temp);\\n                }\\n                else\\n                {\\n                    top = temp;\\n                }\\n                qcount--;\\n            }\\n        }\\n\\n        return top;\\n        \\n    }\\n    \\n    public int Top() {\\n          int top = -1;\\n\\n        if(q.Count > 0)\\n        {\\n            int qcount = q.Count;\\n            while(qcount>0)\\n            {\\n                int temp = q.Dequeue();                            \\n                q.Enqueue(temp);\\n                if(qcount == 1)\\n                {\\n                   top = temp;\\n                }\\n               \\n                qcount--;\\n            }\\n        }\\n\\n        return top;\\n        \\n    }\\n    \\n    public bool Empty() {\\n        return q.Count == 0;\\n    \\n        \\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.Push(x);\\n * int param_2 = obj.Pop();\\n * int param_3 = obj.Top();\\n * bool param_4 = obj.Empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946659,
                "title": "100-faster-easy-using-single-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\nqueue<int>q;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            q.push(top());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ans=top();\\n        q.pop();\\n        return ans;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\nqueue<int>q;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            q.push(top());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ans=top();\\n        q.pop();\\n        return ans;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945827,
                "title": "awesome-using-one-queue",
                "content": "# Using One Queue:\\n```\\nclass MyStack:\\n    def __init__(self):\\n        self.q=deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n        for i in range(len(self.q)-1):\\n            self.q.append(self.q.popleft())\\n\\n    def pop(self) -> int:\\n        if self.q:\\n            return self.q.popleft()\\n\\n    def top(self) -> int:\\n        return self.q[0]  \\n\\n    def empty(self) -> bool:\\n        return len(self.q)==0\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass MyStack:\\n    def __init__(self):\\n        self.q=deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n        for i in range(len(self.q)-1):\\n            self.q.append(self.q.popleft())\\n\\n    def pop(self) -> int:\\n        if self.q:\\n            return self.q.popleft()\\n\\n    def top(self) -> int:\\n        return self.q[0]  \\n\\n    def empty(self) -> bool:\\n        return len(self.q)==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934707,
                "title": "simple-python-solution-beats-80-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.container=[]\\n        \\n\\n    def push(self, x: int) -> None:\\n        self.container.append(x)\\n    def pop(self) -> int:\\n        return self.container.pop()\\n\\n    def top(self) -> int:\\n        return self.container[-1]\\n\\n    def empty(self) -> bool:\\n        return len(self.container)==0\\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.container=[]\\n        \\n\\n    def push(self, x: int) -> None:\\n        self.container.append(x)\\n    def pop(self) -> int:\\n        return self.container.pop()\\n\\n    def top(self) -> int:\\n        return self.container[-1]\\n\\n    def empty(self) -> bool:\\n        return len(self.container)==0\\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892278,
                "title": "beats-100-java-submissions",
                "content": "We\\'re pushing the way a stack would be pushed and then all the other functions will work the same.\\n# Code\\n```\\nclass MyStack {\\n    private Queue<Integer> queue;\\n    public MyStack() {\\n        this.queue = new LinkedList<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n      queue.add(x);\\n       for(int i=0;i<queue.size()-1;i++)\\n       {\\n           queue.add(queue.poll());\\n       }\\n    }\\n    \\n    public int pop() {\\n        return queue.poll();\\n    }\\n    \\n    public int top() {\\n        return queue.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return queue.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n    private Queue<Integer> queue;\\n    public MyStack() {\\n        this.queue = new LinkedList<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n      queue.add(x);\\n       for(int i=0;i<queue.size()-1;i++)\\n       {\\n           queue.add(queue.poll());\\n       }\\n    }\\n    \\n    public int pop() {\\n        return queue.poll();\\n    }\\n    \\n    public int top() {\\n        return queue.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return queue.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823069,
                "title": "java-2-solutions-easy",
                "content": "### **Please Upvote** :D\\n##### 1. Using 2 Queues:\\n```\\nclass MyStack {\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        q2.offer(x);\\n        while (!q1.isEmpty()) {\\n            q2.offer(q1.poll());\\n        }\\n        while (!q2.isEmpty()) {\\n            q1.offer(q2.poll());\\n        }\\n    }\\n\\n    public int pop() {\\n        return q1.poll();\\n    }\\n\\n    public int top() {\\n        return q1.peek();\\n    }\\n\\n    public boolean empty() {\\n        return q1.isEmpty() && q2.isEmpty();\\n    }\\n}\\n\\n// TC: O(m + n), SC: O(m + n)\\n```\\n\\n##### 2. Using 1 Queue:\\n```\\nclass MyStack {\\n    Queue<Integer> q;\\n\\n    public MyStack() {\\n        q = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        q.offer(x);\\n        int size = q.size();\\n        while (size-- > 1) {\\n            q.offer(q.poll());\\n        }\\n    }\\n\\n    public int pop() {\\n        return q.poll();\\n    }\\n\\n    public int top() {\\n        return q.peek();\\n    }\\n\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        q2.offer(x);\\n        while (!q1.isEmpty()) {\\n            q2.offer(q1.poll());\\n        }\\n        while (!q2.isEmpty()) {\\n            q1.offer(q2.poll());\\n        }\\n    }\\n\\n    public int pop() {\\n        return q1.poll();\\n    }\\n\\n    public int top() {\\n        return q1.peek();\\n    }\\n\\n    public boolean empty() {\\n        return q1.isEmpty() && q2.isEmpty();\\n    }\\n}\\n\\n// TC: O(m + n), SC: O(m + n)\\n```\n```\\nclass MyStack {\\n    Queue<Integer> q;\\n\\n    public MyStack() {\\n        q = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        q.offer(x);\\n        int size = q.size();\\n        while (size-- > 1) {\\n            q.offer(q.poll());\\n        }\\n    }\\n\\n    public int pop() {\\n        return q.poll();\\n    }\\n\\n    public int top() {\\n        return q.peek();\\n    }\\n\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823015,
                "title": "java-using-2-queues",
                "content": "# Code\\n```\\nclass MyStack {\\n        Queue<Integer> one;\\n        Queue<Integer> two;\\n\\n        public MyStack() {\\n            one = new LinkedList<>();\\n            two = new LinkedList<>();\\n        }\\n\\n        public void push(int x) {\\n            one.add(x);\\n        }\\n\\n        public int pop() {\\n            if (one.size() > 0) {\\n                while (one.size() > 1) {\\n                    two.add(one.poll());\\n                }\\n                return one.poll();\\n            } else {\\n                while (two.size() > 1) {\\n                    one.add(two.poll());\\n                }\\n                return two.poll();\\n            }\\n        }\\n\\n        public int top() {\\n            if (one.size() > 0) {\\n                while (one.size() > 1) {\\n                    two.add(one.poll());\\n                }\\n                two.add(one.peek());\\n                return one.poll();\\n            } else {\\n                while (two.size() > 1) {\\n                    one.add(two.poll());\\n                }\\n                one.add(two.peek());\\n                return two.poll();\\n            }\\n        }\\n\\n        public boolean empty() {\\n            return one.isEmpty() && two.isEmpty();\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n        Queue<Integer> one;\\n        Queue<Integer> two;\\n\\n        public MyStack() {\\n            one = new LinkedList<>();\\n            two = new LinkedList<>();\\n        }\\n\\n        public void push(int x) {\\n            one.add(x);\\n        }\\n\\n        public int pop() {\\n            if (one.size() > 0) {\\n                while (one.size() > 1) {\\n                    two.add(one.poll());\\n                }\\n                return one.poll();\\n            } else {\\n                while (two.size() > 1) {\\n                    one.add(two.poll());\\n                }\\n                return two.poll();\\n            }\\n        }\\n\\n        public int top() {\\n            if (one.size() > 0) {\\n                while (one.size() > 1) {\\n                    two.add(one.poll());\\n                }\\n                two.add(one.peek());\\n                return one.poll();\\n            } else {\\n                while (two.size() > 1) {\\n                    one.add(two.poll());\\n                }\\n                one.add(two.peek());\\n                return two.poll();\\n            }\\n        }\\n\\n        public boolean empty() {\\n            return one.isEmpty() && two.isEmpty();\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394497,
                "title": "c-using-two-queues-easy-to-understand-clean-solution",
                "content": "**Please Upvote if you found this helpful.**\\n\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n    \\n    MyStack() \\n    {\\n        \\n    }\\n    \\n    void push(int x) \\n    {\\n        q1.push(x);\\n    }\\n    \\n    int pop() \\n    {\\n        while(q1.size()!= 1)\\n        {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int ans= q1.front();\\n        q1.pop();\\n        while(!q2.empty())\\n        {\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return ans;\\n    }\\n    \\n    int top() \\n    {\\n        return q1.back();\\n    }\\n    \\n    bool empty() \\n    {\\n        if(q1.empty())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n    \\n    MyStack() \\n    {\\n        \\n    }\\n    \\n    void push(int x) \\n    {\\n        q1.push(x);\\n    }\\n    \\n    int pop() \\n    {\\n        while(q1.size()!= 1)\\n        {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int ans= q1.front();\\n        q1.pop();\\n        while(!q2.empty())\\n        {\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return ans;\\n    }\\n    \\n    int top() \\n    {\\n        return q1.back();\\n    }\\n    \\n    bool empty() \\n    {\\n        if(q1.empty())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089520,
                "title": "49-ms-faster-than-31-47-of-python3-online-submissions-for-implement-stack-using-queues",
                "content": "\\tdef __init__(self):\\n        self.queue = []\\n\\n    def push(self, x: int) -> None:\\n        self.queue.append(x)\\n\\n    def pop(self) -> int:\\n        return self.queue.pop()\\n\\n    def top(self) -> int:\\n        return self.queue[-1]\\n\\n    def empty(self) -> bool:\\n        return True if len(self.queue) == 0 else False",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "\\tdef __init__(self):\\n        self.queue = []\\n\\n    def push(self, x: int) -> None:\\n        self.queue.append(x)\\n\\n    def pop(self) -> int:\\n        return self.queue.pop()\\n\\n    def top(self) -> int:\\n        return self.queue[-1]\\n\\n    def empty(self) -> bool:\\n        return True if len(self.queue) == 0 else False",
                "codeTag": "Python3"
            },
            {
                "id": 2073800,
                "title": "c-double-queue-single-queue",
                "content": "****using double queue****\\n\\n    queue<int>q1,q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        swap(q1,q2);\\n    }\\n    \\n    int pop() {\\n        int ans=q1.front();\\n      q1.pop() ;\\n            return ans ;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        if(q1.size()!=0) return false;\\n        else return true ;\\n    }\\n};\\n\\n implement using single queue \\n\\n    queue<int> q1;\\n    MyStack() {\\n        \\n    }\\n    \\n   \\n    void push(int x) {\\n        int sz = q1.size();\\n        q1.push(x);\\n        while(sz--){\\n            q1.push(q1.front());\\n            q1.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n    \\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Queue"
                ],
                "code": "****using double queue****\\n\\n    queue<int>q1,q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        swap(q1,q2);\\n    }\\n    \\n    int pop() {\\n        int ans=q1.front();\\n      q1.pop() ;\\n            return ans ;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        if(q1.size()!=0) return false;\\n        else return true ;\\n    }\\n};\\n\\n implement using single queue \\n\\n    queue<int> q1;\\n    MyStack() {\\n        \\n    }\\n    \\n   \\n    void push(int x) {\\n        int sz = q1.size();\\n        q1.push(x);\\n        while(sz--){\\n            q1.push(q1.front());\\n            q1.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n    \\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2010355,
                "title": "c-1-queue-easy-solution",
                "content": "\\t\\tclass MyStack {\\n\\t\\tpublic:\\n\\t\\t\\tqueue<int>q;\\n\\t\\t\\tMyStack() {\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid push(int x) {\\n\\t\\t\\tq.push(x);\\n\\t\\t\\tfor(int i=0;i<q.size()-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tq.push(pop());\\n\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint pop() {\\n\\t\\t\\t\\tint data=top();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\treturn data;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint top() {\\n\\t\\t\\t\\treturn q.front();\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool empty() {\\n\\t\\t\\t\\treturn q.empty();\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "\\t\\tclass MyStack {\\n\\t\\tpublic:\\n\\t\\t\\tqueue<int>q;\\n\\t\\t\\tMyStack() {\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid push(int x) {\\n\\t\\t\\tq.push(x);\\n\\t\\t\\tfor(int i=0;i<q.size()-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tq.push(pop());\\n\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint pop() {\\n\\t\\t\\t\\tint data=top();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\treturn data;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint top() {\\n\\t\\t\\t\\treturn q.front();\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool empty() {\\n\\t\\t\\t\\treturn q.empty();\\n\\t\\t\\t}\\n\\t\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2010308,
                "title": "python-fastest-solution",
                "content": "```\\nfrom collections import deque\\nclass MyStack:\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        q = self.q\\n        q.append(x)\\n        for _ in range(len(q) - 1):\\n            q.append(q.popleft())\\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n\\n    def top(self) -> int:\\n        return self.q[0]\\n\\n    def empty(self) -> bool:\\n        return not self.q\\n```\\n\\nIf this worked for you kindly upvote",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass MyStack:\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x: int) -> None:\\n        q = self.q\\n        q.append(x)\\n        for _ in range(len(q) - 1):\\n            q.append(q.popleft())\\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n\\n    def top(self) -> int:\\n        return self.q[0]\\n\\n    def empty(self) -> bool:\\n        return not self.q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009523,
                "title": "c-very-easy-solution-beats-100-runtime-using-two-queues",
                "content": "Below is the implementation of stack using queues:\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        swap(q1,q2);\\n    }\\n    \\n    int pop() {\\n        int x=q1.front();\\n        q1.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        swap(q1,q2);\\n    }\\n    \\n    int pop() {\\n        int x=q1.front();\\n        q1.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009437,
                "title": "intuition-of-the-problem-and-implementation-runtime-0-ms-faster-than-100-00",
                "content": "This problem is not what  can happen in production scenario  but this could be a good brain excersice or puzzel.\\n\\nIntution : Always maintain your top of the stack in first queue. Yes this is it. Please have a look at the code. Whole code is written just to maintain this single constraint and is self explaintory.\\n\\nTrace some inputs on pen and paper and then try to write code by keeping this constraint in mind and if you are not able to then please go through the code. Comment if need any explaination.\\n\\n```\\nclass MyStack {\\n    \\n    Queue<Integer> firstQueue; \\n    Queue<Integer> secondQueue;\\n\\n    public MyStack() {\\n        firstQueue = new LinkedList<>();\\n        secondQueue = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        if(firstQueue.isEmpty())\\n            secondQueue.add(x);\\n        else {\\n            secondQueue.add(firstQueue.remove());\\n            firstQueue.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n     if(!firstQueue.isEmpty())\\n             return firstQueue.remove();\\n     else {\\n         while(secondQueue.size()>1) {\\n            firstQueue.add(secondQueue.remove());\\n         }\\n            Queue<Integer> tempQueue = firstQueue;\\n            firstQueue = secondQueue;\\n            secondQueue = tempQueue;\\n\\n         return firstQueue.remove();\\n     }\\n    }\\n    \\n    public int top() {\\n     if(!firstQueue.isEmpty())\\n             return firstQueue.peek();\\n     else {\\n         while(secondQueue.size()>1) {\\n            firstQueue.add(secondQueue.remove());\\n         }\\n            Queue<Integer> tempQueue = firstQueue;\\n            firstQueue = secondQueue;\\n            secondQueue = tempQueue;\\n\\n         return firstQueue.peek();\\n     }\\n    }\\n    \\n    public boolean empty() {\\n        return firstQueue.isEmpty()?secondQueue.isEmpty():false;\\n    }\\n}\\n\\n\\n",
                "solutionTags": [
                    "Queue"
                ],
                "code": "This problem is not what  can happen in production scenario  but this could be a good brain excersice or puzzel.\\n\\nIntution : Always maintain your top of the stack in first queue. Yes this is it. Please have a look at the code. Whole code is written just to maintain this single constraint and is self explaintory.\\n\\nTrace some inputs on pen and paper and then try to write code by keeping this constraint in mind and if you are not able to then please go through the code. Comment if need any explaination.\\n\\n```\\nclass MyStack {\\n    \\n    Queue<Integer> firstQueue; \\n    Queue<Integer> secondQueue;\\n\\n    public MyStack() {\\n        firstQueue = new LinkedList<>();\\n        secondQueue = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        if(firstQueue.isEmpty())\\n            secondQueue.add(x);\\n        else {\\n            secondQueue.add(firstQueue.remove());\\n            firstQueue.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n     if(!firstQueue.isEmpty())\\n             return firstQueue.remove();\\n     else {\\n         while(secondQueue.size()>1) {\\n            firstQueue.add(secondQueue.remove());\\n         }\\n            Queue<Integer> tempQueue = firstQueue;\\n            firstQueue = secondQueue;\\n            secondQueue = tempQueue;\\n\\n         return firstQueue.remove();\\n     }\\n    }\\n    \\n    public int top() {\\n     if(!firstQueue.isEmpty())\\n             return firstQueue.peek();\\n     else {\\n         while(secondQueue.size()>1) {\\n            firstQueue.add(secondQueue.remove());\\n         }\\n            Queue<Integer> tempQueue = firstQueue;\\n            firstQueue = secondQueue;\\n            secondQueue = tempQueue;\\n\\n         return firstQueue.peek();\\n     }\\n    }\\n    \\n    public boolean empty() {\\n        return firstQueue.isEmpty()?secondQueue.isEmpty():false;\\n    }\\n}\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2009042,
                "title": "implement-stack-using-queues-c-easysolution-100",
                "content": "i)let q1 be my stack.\\nii}if we want to push element in stack we will simply push in q1\\nii)if we want to pop an element from stack then we will have to push all the elements of q1 in new queue q2 and return top element and then again push all elements of q2 in q1.\\n      for eg. q1 : 1->2->3->4->5\\n\\t             now we have to return 5\\n\\t\\t\\t\\t q2 : 1->2->3->4\\n\\t\\t\\t\\t now pop 5 from  q1 and push all other elements from q2 to q1 again\\n\\t\\t\\t\\t q1: 1->2->3->4\\nSimilarly we can return top element \\n\\nPlease Upvote if its helpful :)\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x); \\n    }\\n    \\n    int pop() {\\n       while(q1.size()>1){\\n           q2.push(q1.front());\\n           q1.pop();\\n       } \\n       int top=q1.front();\\n        q1.pop();\\n        while(q2.size()>0){\\n           q1.push(q2.front());\\n           q2.pop();\\n       } \\n        return top;\\n    }\\n    \\n    int top() {\\n        while(q1.size()>1){\\n           q2.push(q1.front());\\n           q1.pop();\\n       } \\n       int top=q1.front();\\n        q2.push(top);\\n        q1.pop();\\n         while(q2.size()>0){\\n           q1.push(q2.front());\\n           q2.pop();\\n       } \\n        return top;\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```\\nSome of my other Solutions:\\n\\nhttps://leetcode.com/problems/partition-labels/discuss/1868704/partition-labels-on-solution-c-greedy-simple-solution\\nhttps://leetcode.com/problems/power-of-four/discuss/1799832/power-of-four-c100bit-manipualtion-easy-solution\\nhttps://leetcode.com/problems/partition-labels/discuss/1868704/partition-labels-on-solution-c-greedy-simple-solution\\nhttps://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1862025/binary-tree-level-order-traversal-queue-binary-tree-easy-solution\\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/discuss/1850726/minimum-remove-to-make-valid-parentheses-c-on-simple-logic-easy-solution\\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/discuss/1849453/maximum-number-of-vowels-in-a-substring-of-given-length-csliding-window\\nhttps://leetcode.com/problems/reverse-prefix-of-word/discuss/1840375/reverse-prefix-of-word-100-c\\nhttps://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/discuss/1826246/find-n-unique-integers-sum-up-to-zero-100-simple-solution\\nhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1814346/find-minimum-in-rotated-sorted-array-binary-search-100-ceasy-solution\\nhttps://leetcode.com/problems/is-subsequence/discuss/1811098/is-subsequence-100-c-easy-solution\\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/discuss/1808021/search-in-rotated-sorted-array-ologn-solution-simple-solution-binary-search\\nhttps://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/discuss/1799853/check-if-number-is-a-sum-of-powers-of-three-100-easy-solution\\nhttps://leetcode.com/problems/sequential-digits/discuss/1751815/sequential-digits-c-100-easy-solution\\nhttps://leetcode.com/problems/binary-gap/discuss/1749101/binary-gap-100-c-simple-solution\\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1730888/kth-largest-element-in-an-array-c-sorting-simple-solution\\nhttps://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/discuss/1726527/queries-on-number-of-points-inside-a-circle-c-simple-mathematics\\nhttps://leetcode.com/problems/integer-to-roman/discuss/1726042/integer-to-roman-c-easy-to-understand\\nhttps://leetcode.com/problems/rings-and-rods/discuss/1724149/rings-and-rods-100-c-using-hashmap\\nhttps://leetcode.com/problems/number-complement/discuss/1722669/number-compliment\\nhttps://leetcode.com/problems/find-the-duplicate-number/discuss/1809351/find-the-duplicate-number-o1-space-binary-search-easy-solution\\nhttps://leetcode.com/problems/smallest-string-with-a-given-numeric-value/discuss/1872424/Smallest-String-With-A-Given-Numeric-Value-oror-C%2B%2B-O(n)-oror-Simple-Solution-with-Explaination\\nhttps://leetcode.com/problems/broken-calculator/discuss/1875269/Broken-Calculator-oror-C%2B%2B-100-O(n)-oror-Greedy-solution-with-Explanation-oror-Easy-Simple-Solution\\nhttps://leetcode.com/problems/generate-parentheses/discuss/1875357/Generate-Parentheses-oror-C%2B%2B-recursive-Approach-with-explaination-oror-Easy-Approach\\nhttps://leetcode.com/problems/boats-to-save-people/discuss/1877923/Boats-to-Save-People-oror-c%2B%2B-Greedy-oror-two-pointers-oror-sorting-oror-easy-Solution-with-explaination\\nhttps://leetcode.com/problems/minimum-add-to-make-parentheses-valid/discuss/1901110/Minimum-Add-to-Make-Parentheses-Valid-oror-c%2B%2B-oror-100-oror-Simple-Solution-oror-String\\nhttps://leetcode.com/problems/game-of-life/discuss/1937884/Game-of-Life-oror-100-oror-C%2B%2B-oror-Matrix-IMPLEMENTATION\\nhttps://leetcode.com/problems/letter-case-permutation/discuss/2005077/Letter-Case-Permutation-oror-c%2B%2Boror-RecursionororEasy-Solution\\nhttps://leetcode.com/problems/max-number-of-k-sum-pairs/discuss/2006992/Max-Number-of-K-Sum-Pairs-oror-C%2B%2Boror-HashMapororEasy-Solution\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x); \\n    }\\n    \\n    int pop() {\\n       while(q1.size()>1){\\n           q2.push(q1.front());\\n           q1.pop();\\n       } \\n       int top=q1.front();\\n        q1.pop();\\n        while(q2.size()>0){\\n           q1.push(q2.front());\\n           q2.pop();\\n       } \\n        return top;\\n    }\\n    \\n    int top() {\\n        while(q1.size()>1){\\n           q2.push(q1.front());\\n           q1.pop();\\n       } \\n       int top=q1.front();\\n        q2.push(top);\\n        q1.pop();\\n         while(q2.size()>0){\\n           q1.push(q2.front());\\n           q2.pop();\\n       } \\n        return top;\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968439,
                "title": "c-easy-one-queue-solution",
                "content": "```\\nclass MyStack {\\nprivate:\\n    queue<int>q1;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        for(int i=0;i<q1.size()-1;i++){\\n            q1.push(q1.front());\\n            q1.pop();\\n        }}\\n    \\n    int pop() {\\n        int a=q1.front();\\n        q1.pop();\\n        return a;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\nprivate:\\n    queue<int>q1;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        for(int i=0;i<q1.size()-1;i++){\\n            q1.push(q1.front());\\n            q1.pop();\\n        }}\\n    \\n    int pop() {\\n        int a=q1.front();\\n        q1.pop();\\n        return a;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1948531,
                "title": "using-2-queues-beginner-friendly-code",
                "content": "```\\nclass MyStack {\\npublic:\\n    \\n    queue<int> q1 , q2;\\n    \\n    \\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(q1.empty()) q1.push(x);\\n        else {\\n            while(!q1.empty()){\\n                q2.push(q1.front());\\n                q1.pop();\\n            }\\n            q1.push(x);\\n            while(!q2.empty()){\\n                q1.push(q2.front());\\n                q2.pop();\\n            }\\n        }\\n    }\\n    \\n    int pop() {\\n        int top = q1.front();\\n        q1.pop();\\n        return top;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        if(q1.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    \\n    queue<int> q1 , q2;\\n    \\n    \\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(q1.empty()) q1.push(x);\\n        else {\\n            while(!q1.empty()){\\n                q2.push(q1.front());\\n                q1.pop();\\n            }\\n            q1.push(x);\\n            while(!q2.empty()){\\n                q1.push(q2.front());\\n                q2.pop();\\n            }\\n        }\\n    }\\n    \\n    int pop() {\\n        int top = q1.front();\\n        q1.pop();\\n        return top;\\n    }\\n    \\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    bool empty() {\\n        if(q1.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764790,
                "title": "python-solution-using-2-queues-runtime-96-80-memory-usage-13-9-mb-less-than-94-40",
                "content": "![image](https://assets.leetcode.com/users/images/6aefb014-4337-42aa-9050-a3e13c5dbdfe_1644649764.9614208.png)\\n\\n```\\nclass Queue:\\n    def __init__(self):\\n        self.queue = []\\n    def push(self,val):\\n        self.queue.append(val)\\n    def pop(self):\\n        return self.queue.pop(0)\\n    def top(self):\\n        return self.queue[0]\\n    \\n    def isEmpty(self):\\n        if len(self.queue)== 0:\\n            return True\\n        else:\\n            return False\\nclass MyStack:\\n    def __init__(self):\\n        self.q = Queue()\\n        self.temp = Queue()\\n    def push(self, x: int) -> None:\\n        self.temp.push(x)\\n        while not self.q.isEmpty():\\n            self.temp.push(self.q.pop())\\n        self.q,self.temp = self.temp,self.q\\n        \\n    def pop(self) -> int:\\n        return self.q.pop()\\n\\n    def top(self) -> int:\\n        return self.q.queue[0]\\n    \\n        \\n\\n    def empty(self) -> bool:\\n        return self.q.isEmpty()\\n```\\n\\n## IF ANY DOUBTS PLEASE COMMENT BELOW.",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Queue:\\n    def __init__(self):\\n        self.queue = []\\n    def push(self,val):\\n        self.queue.append(val)\\n    def pop(self):\\n        return self.queue.pop(0)\\n    def top(self):\\n        return self.queue[0]\\n    \\n    def isEmpty(self):\\n        if len(self.queue)== 0:\\n            return True\\n        else:\\n            return False\\nclass MyStack:\\n    def __init__(self):\\n        self.q = Queue()\\n        self.temp = Queue()\\n    def push(self, x: int) -> None:\\n        self.temp.push(x)\\n        while not self.q.isEmpty():\\n            self.temp.push(self.q.pop())\\n        self.q,self.temp = self.temp,self.q\\n        \\n    def pop(self) -> int:\\n        return self.q.pop()\\n\\n    def top(self) -> int:\\n        return self.q.queue[0]\\n    \\n        \\n\\n    def empty(self) -> bool:\\n        return self.q.isEmpty()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695286,
                "title": "java-two-queues-push-o-1-top-o-1-empty-o-1-pop-o-n",
                "content": "```\\npublic class MyStack {\\n\\n\\tQueue<Integer> pQueue;\\n\\tQueue<Integer> sQueue;\\n\\tInteger top;\\n\\n\\tpublic MyStack() {\\n\\t\\tpQueue = new LinkedList<Integer>();\\n\\t\\tsQueue = new LinkedList<Integer>();\\n\\t}\\n\\n\\tpublic void push(int x) {\\n\\t\\ttop = x;\\n\\t\\tpQueue.add(x);\\n\\n\\t}\\n\\n\\tpublic int pop() {\\n\\t\\tif (empty())\\n\\t\\t\\treturn -1;\\n\\t\\tswitchQueue(pQueue, sQueue);\\n\\t\\treturn sQueue.poll();\\n\\t}\\n\\n\\tpublic int top() {\\n\\t\\treturn top;\\n\\t}\\n\\n\\tpublic boolean empty() {\\n\\t\\treturn pQueue.isEmpty() && sQueue.isEmpty();\\n\\t}\\n\\n\\tprivate void switchQueue(Queue<Integer> main, Queue<Integer> sec) {\\n\\t\\tint mainS = main.size();\\n\\t\\tfor (int i = 0; i < mainS - 1; i++) {\\n\\t\\t\\ttop = main.poll();\\n\\t\\t\\tsec.add(top);\\n\\t\\t}\\n\\t\\tpQueue = sec;\\n\\t\\tsQueue = main;\\n\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\npublic class MyStack {\\n\\n\\tQueue<Integer> pQueue;\\n\\tQueue<Integer> sQueue;\\n\\tInteger top;\\n\\n\\tpublic MyStack() {\\n\\t\\tpQueue = new LinkedList<Integer>();\\n\\t\\tsQueue = new LinkedList<Integer>();\\n\\t}\\n\\n\\tpublic void push(int x) {\\n\\t\\ttop = x;\\n\\t\\tpQueue.add(x);\\n\\n\\t}\\n\\n\\tpublic int pop() {\\n\\t\\tif (empty())\\n\\t\\t\\treturn -1;\\n\\t\\tswitchQueue(pQueue, sQueue);\\n\\t\\treturn sQueue.poll();\\n\\t}\\n\\n\\tpublic int top() {\\n\\t\\treturn top;\\n\\t}\\n\\n\\tpublic boolean empty() {\\n\\t\\treturn pQueue.isEmpty() && sQueue.isEmpty();\\n\\t}\\n\\n\\tprivate void switchQueue(Queue<Integer> main, Queue<Integer> sec) {\\n\\t\\tint mainS = main.size();\\n\\t\\tfor (int i = 0; i < mainS - 1; i++) {\\n\\t\\t\\ttop = main.poll();\\n\\t\\t\\tsec.add(top);\\n\\t\\t}\\n\\t\\tpQueue = sec;\\n\\t\\tsQueue = main;\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674769,
                "title": "simple-c-solution-using-1-queue",
                "content": "```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    queue<int> q1;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n      int size=q1.size();\\n        q1.push(x);\\n      while(size--){\\n          q1.push(q1.front());\\n          q1.pop();\\n      }\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n```\\nLike the solution?\\nPlease upvote \\u30C4\\n\\nIf you can\\'t able to understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    queue<int> q1;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n      int size=q1.size();\\n        q1.push(x);\\n      while(size--){\\n          q1.push(q1.front());\\n          q1.pop();\\n      }\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return q1.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619241,
                "title": "using-a-single-queue-c",
                "content": "\\n    queue<int>que;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        que.push(x);\\n\\t\\tfor(int i=0;i<que.size()-1;++i){\\n\\t\\t\\tque.push(que.front());\\n\\t\\t\\tque.pop();\\n\\t\\t}\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int x = que.front(); \\n        que.pop(); \\n        return x; \\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return que.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return que.size() == 0; \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "\\n    queue<int>que;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        que.push(x);\\n\\t\\tfor(int i=0;i<que.size()-1;++i){\\n\\t\\t\\tque.push(que.front());\\n\\t\\t\\tque.pop();\\n\\t\\t}\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int x = que.front(); \\n        que.pop(); \\n        return x; \\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        return que.front();\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return que.size() == 0; \\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1609249,
                "title": "c-solution-using-one-queue",
                "content": "While using Queue to build a Stack, we are basically trying to do both ```enqueue()``` and ```dequeue()``` from the tail of the queue; for ```enqueue()```, it would be just like doing a normal  ```enqueue()``` which we insert the new data to the ```queue[++tail]```; but for ```dequeue()``` , suppose the queue is ```[[0],[1],[2],[3],[4]]``` we want the value from index 4, in order to do that, we need to keep getting item out from the front of the queue while adding it to the back of the queue, until the head index is now pointed to index 4 (tail index will now be pointed to index 8) , and now when we do ```dequeue()``` again this time, the value we get now is the value which at the last index position originally.\\n\\n```\\n//Zhaoqin Li\\ntypedef struct {\\n    int head, tail;\\n    int* queue;\\n} MyQueue;\\n\\ntypedef struct {\\n    int Q_size;\\n    MyQueue* Q;\\n} MyStack;\\n\\n#define MAX_STACK_SIZE 50\\nbool myStackEmpty(MyStack* obj);\\n\\nMyStack* myStackCreate() {\\n    MyStack* tempStack = (MyStack*)malloc(sizeof(MyStack));\\n    tempStack->Q = (MyQueue*)malloc(sizeof(MyQueue));\\n    tempStack->Q->queue = (int*)malloc(MAX_STACK_SIZE*sizeof(int));\\n    tempStack->Q->head = -1;\\n    tempStack->Q->tail = -1;\\n    tempStack->Q_size = 0;\\n    return tempStack;\\n}\\n\\nint myQueuepop(MyQueue* Q){\\n    int temp = Q->queue[Q->head];\\n    Q->head = (Q->head + 1) % MAX_STACK_SIZE;\\n    return temp;\\n}\\n\\nbool myQueuepush(MyQueue* Q, int val){\\n    if(Q->head == -1){\\n        Q->head = 0;\\n    }\\n    Q->tail = (Q->tail + 1) % MAX_STACK_SIZE; \\n    Q->queue[Q->tail] = val;\\n    return true;\\n}\\n\\nvoid myStackPush(MyStack* obj, int x) {\\n    myQueuepush(obj->Q, x);\\n    obj->Q_size++;\\n}\\n\\nint myStackPop(MyStack* obj) {\\n    if(myStackEmpty(obj)){\\n        return INT_MIN;\\n    }else{\\n        int i, temp;\\n        for(i=0; i<obj->Q_size-1; i++){\\n            temp = myQueuepop(obj->Q);\\n            obj->Q->tail = (obj->Q->tail + 1) % MAX_STACK_SIZE; \\n            obj->Q->queue[obj->Q->tail] = temp;\\n        }\\n        temp = myQueuepop(obj->Q);\\n        obj->Q_size--;\\n        return temp;\\n    }\\n}\\n\\nint myStackTop(MyStack* obj) {\\n    return obj->Q->queue[obj->Q->tail];\\n}\\n\\nbool myStackEmpty(MyStack* obj) {\\n    return obj->Q_size == 0;\\n}\\n\\nvoid myStackFree(MyStack* obj) {\\n    free(obj->Q->queue);\\n    free(obj->Q);\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```enqueue()```\n```dequeue()```\n```enqueue()```\n```enqueue()```\n```queue[++tail]```\n```dequeue()```\n```[[0],[1],[2],[3],[4]]```\n```dequeue()```\n```\\n//Zhaoqin Li\\ntypedef struct {\\n    int head, tail;\\n    int* queue;\\n} MyQueue;\\n\\ntypedef struct {\\n    int Q_size;\\n    MyQueue* Q;\\n} MyStack;\\n\\n#define MAX_STACK_SIZE 50\\nbool myStackEmpty(MyStack* obj);\\n\\nMyStack* myStackCreate() {\\n    MyStack* tempStack = (MyStack*)malloc(sizeof(MyStack));\\n    tempStack->Q = (MyQueue*)malloc(sizeof(MyQueue));\\n    tempStack->Q->queue = (int*)malloc(MAX_STACK_SIZE*sizeof(int));\\n    tempStack->Q->head = -1;\\n    tempStack->Q->tail = -1;\\n    tempStack->Q_size = 0;\\n    return tempStack;\\n}\\n\\nint myQueuepop(MyQueue* Q){\\n    int temp = Q->queue[Q->head];\\n    Q->head = (Q->head + 1) % MAX_STACK_SIZE;\\n    return temp;\\n}\\n\\nbool myQueuepush(MyQueue* Q, int val){\\n    if(Q->head == -1){\\n        Q->head = 0;\\n    }\\n    Q->tail = (Q->tail + 1) % MAX_STACK_SIZE; \\n    Q->queue[Q->tail] = val;\\n    return true;\\n}\\n\\nvoid myStackPush(MyStack* obj, int x) {\\n    myQueuepush(obj->Q, x);\\n    obj->Q_size++;\\n}\\n\\nint myStackPop(MyStack* obj) {\\n    if(myStackEmpty(obj)){\\n        return INT_MIN;\\n    }else{\\n        int i, temp;\\n        for(i=0; i<obj->Q_size-1; i++){\\n            temp = myQueuepop(obj->Q);\\n            obj->Q->tail = (obj->Q->tail + 1) % MAX_STACK_SIZE; \\n            obj->Q->queue[obj->Q->tail] = temp;\\n        }\\n        temp = myQueuepop(obj->Q);\\n        obj->Q_size--;\\n        return temp;\\n    }\\n}\\n\\nint myStackTop(MyStack* obj) {\\n    return obj->Q->queue[obj->Q->tail];\\n}\\n\\nbool myStackEmpty(MyStack* obj) {\\n    return obj->Q_size == 0;\\n}\\n\\nvoid myStackFree(MyStack* obj) {\\n    free(obj->Q->queue);\\n    free(obj->Q);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1587874,
                "title": "100-faster-java-easy-solution-and-clean-code",
                "content": "```\\npublic class MyStack {\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n    private int top;\\n\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        top = x;\\n        q1.add(x);\\n    }\\n\\n    public int pop() {\\n        while (q1.size() != 1){\\n            int x = q1.remove();\\n            top = x;\\n            q2.add(x);\\n        }\\n        int ans = q1.remove();\\n        Queue<Integer> tmp = q1;\\n        q1 = q2;\\n        q2 = tmp;\\n        return ans;\\n    }\\n\\n    public int top() {\\n        return top;\\n    }\\n\\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class MyStack {\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n    private int top;\\n\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n\\n    public void push(int x) {\\n        top = x;\\n        q1.add(x);\\n    }\\n\\n    public int pop() {\\n        while (q1.size() != 1){\\n            int x = q1.remove();\\n            top = x;\\n            q2.add(x);\\n        }\\n        int ans = q1.remove();\\n        Queue<Integer> tmp = q1;\\n        q1 = q2;\\n        q2 = tmp;\\n        return ans;\\n    }\\n\\n    public int top() {\\n        return top;\\n    }\\n\\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271884,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "* **Solution using 1 queue.**\\n```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    queue<int> q;\\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x)\\n    {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop()\\n    {\\n        int tmp = q.front();\\n        q.pop();\\n        return tmp;\\n    }\\n    \\n    /** Get the top element. */\\n    int top()\\n    {\\n        return q.front();    \\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty()\\n    {\\n        return q.empty();    \\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t able to understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    queue<int> q;\\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x)\\n    {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop()\\n    {\\n        int tmp = q.front();\\n        q.pop();\\n        return tmp;\\n    }\\n    \\n    /** Get the top element. */\\n    int top()\\n    {\\n        return q.front();    \\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty()\\n    {\\n        return q.empty();    \\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997588,
                "title": "python-using-two-queues-with-size-maintenance",
                "content": "```\\nfrom queue import Queue\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q1 = Queue()\\n        self.q2 = Queue()\\n        self.current_size = 0\\n        \\n\\n    def push(self, x: int) -> None:\\n        self.current_size+=1\\n        self.q2.put(x)\\n        while not(self.q1.empty()):\\n            self.q2.put(self.q1.queue[0])\\n            self.q1.get()\\n        self.q = self.q1\\n        self.q1 = self.q2\\n        self.q2 = self.q\\n        \\n\\n    def pop(self) -> int:\\n        if (self.q1.empty()):\\n            return \\n        return self.q1.get()\\n        self.current_size-=1\\n        \\n\\n    def top(self) -> int:\\n        if self.q1.empty():\\n            return\\n        return self.q1.queue[0]\\n        \\n        \\n\\n    def empty(self) -> bool:\\n        if (self.q1.empty()):\\n            return True\\n        else:\\n            return False",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nfrom queue import Queue\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q1 = Queue()\\n        self.q2 = Queue()\\n        self.current_size = 0\\n        \\n\\n    def push(self, x: int) -> None:\\n        self.current_size+=1\\n        self.q2.put(x)\\n        while not(self.q1.empty()):\\n            self.q2.put(self.q1.queue[0])\\n            self.q1.get()\\n        self.q = self.q1\\n        self.q1 = self.q2\\n        self.q2 = self.q\\n        \\n\\n    def pop(self) -> int:\\n        if (self.q1.empty()):\\n            return \\n        return self.q1.get()\\n        self.current_size-=1\\n        \\n\\n    def top(self) -> int:\\n        if self.q1.empty():\\n            return\\n        return self.q1.queue[0]\\n        \\n        \\n\\n    def empty(self) -> bool:\\n        if (self.q1.empty()):\\n            return True\\n        else:\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 777968,
                "title": "c-solution-0ms-100-faster-easy-and-clean-solution-using-two-queues",
                "content": "```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() {\\n        \\n    }\\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int x = q1.back();\\n        while(q1.size()!=1){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        q1.pop();\\n        swap(q1, q2);\\n        return x;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        int x = q1.back();\\n        return x;\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    /** Initialize your data structure here. */\\n    queue<int> q1;\\n    queue<int> q2;\\n    MyStack() {\\n        \\n    }\\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        int x = q1.back();\\n        while(q1.size()!=1){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        q1.pop();\\n        swap(q1, q2);\\n        return x;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        int x = q1.back();\\n        return x;\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383566,
                "title": "easy-c-solution-0ms-clean-code",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Implement Stack using Queues.\\nMemory Usage: 8.9 MB, less than 66.67% of C++ online submissions for Implement Stack using Queues.\\n\\n```\\n/** Initialize your data structure here. */\\n    queue<int> primary;\\n    queue<int> sec;\\n    \\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        primary.push(x);\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        \\n        int res;\\n        while(!primary.empty())\\n        {\\n            if(primary.size() == 1)\\n                res = primary.front();\\n            else\\n                sec.push(primary.front());\\n            primary.pop();\\n        }\\n        \\n        sec.swap(primary);\\n        return res;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        \\n        int res;\\n        while(!primary.empty())\\n        {\\n            if(primary.size() == 1)\\n                res = primary.front();\\n            \\n            sec.push(primary.front());\\n            primary.pop();\\n        }  \\n        \\n        sec.swap(primary);\\n        return res;\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return (primary.empty());\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Implement Stack using Queues.\\nMemory Usage: 8.9 MB, less than 66.67% of C++ online submissions for Implement Stack using Queues.\\n\\n```\\n/** Initialize your data structure here. */\\n    queue<int> primary;\\n    queue<int> sec;\\n    \\n    MyStack() {\\n        \\n    }\\n    \\n    /** Push element x onto stack. */\\n    void push(int x) {\\n        primary.push(x);\\n    }\\n    \\n    /** Removes the element on top of the stack and returns that element. */\\n    int pop() {\\n        \\n        int res;\\n        while(!primary.empty())\\n        {\\n            if(primary.size() == 1)\\n                res = primary.front();\\n            else\\n                sec.push(primary.front());\\n            primary.pop();\\n        }\\n        \\n        sec.swap(primary);\\n        return res;\\n    }\\n    \\n    /** Get the top element. */\\n    int top() {\\n        \\n        int res;\\n        while(!primary.empty())\\n        {\\n            if(primary.size() == 1)\\n                res = primary.front();\\n            \\n            sec.push(primary.front());\\n            primary.pop();\\n        }  \\n        \\n        sec.swap(primary);\\n        return res;\\n    }\\n    \\n    /** Returns whether the stack is empty. */\\n    bool empty() {\\n        return (primary.empty());\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 165352,
                "title": "python-queue-two-approaches",
                "content": "1. Make push more costly\\n```\\nfrom queue import Queue\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.items = Queue()\\n        print(\"init\")\\n\\n\\n    def push(self, x):\\n        \"\"\"\\n        Push element x onto stack.\\n        :type x: int\\n        :rtype: void\\n        \"\"\"\\n        q2 = Queue()\\n        q2.put(x)\\n        while(not self.items.empty()):\\n            q2.put(self.items.get())\\n        print(\"q2\",q2.qsize())\\n        self.items = q2\\n        print(\"q1\",self.items.qsize())\\n\\n    def pop(self):\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        :rtype: int\\n        \"\"\"\\n        return self.items.get()\\n\\n\\n    def top(self):\\n        \"\"\"\\n        Get the top element.\\n        :rtype: int\\n        \"\"\"\\n        result = self.items.get()\\n        q2 = Queue()\\n        q2.put(result)\\n        while(not self.items.empty()):\\n            print(self.items.qsize())\\n            q2.put(self.items.get())\\n        self.items = q2\\n        return result\\n\\n\\n    def empty(self):\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        :rtype: bool\\n        \"\"\"\\n        return self.items.empty()\\n```\\n2. Make pop/peep more costly\\n\\n```\\nfrom queue import Queue\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.items = Queue()\\n\\n\\n    def push(self, x):\\n        \"\"\"\\n        Push element x onto stack.\\n        :type x: int\\n        :rtype: void\\n        \"\"\"\\n        self.items.put(x)\\n\\n\\n    def pop(self):\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        :rtype: int\\n        \"\"\"\\n        q2 = Queue()\\n        while(self.items.qsize() >1):\\n            q2.put(self.items.get())\\n        result = self.items.get()\\n        self.items = q2\\n        return result\\n\\n\\n    def top(self):\\n        \"\"\"\\n        Get the top element.\\n        :rtype: int\\n        \"\"\"\\n        q2 = Queue()\\n        while(self.items.qsize() >1):\\n            q2.put(self.items.get())\\n        result = self.items.get()\\n        q2.put(result)\\n        self.items = q2\\n        return result\\n\\n\\n    def empty(self):\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        :rtype: bool\\n        \"\"\"\\n        return self.items.empty()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom queue import Queue\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.items = Queue()\\n        print(\"init\")\\n\\n\\n    def push(self, x):\\n        \"\"\"\\n        Push element x onto stack.\\n        :type x: int\\n        :rtype: void\\n        \"\"\"\\n        q2 = Queue()\\n        q2.put(x)\\n        while(not self.items.empty()):\\n            q2.put(self.items.get())\\n        print(\"q2\",q2.qsize())\\n        self.items = q2\\n        print(\"q1\",self.items.qsize())\\n\\n    def pop(self):\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        :rtype: int\\n        \"\"\"\\n        return self.items.get()\\n\\n\\n    def top(self):\\n        \"\"\"\\n        Get the top element.\\n        :rtype: int\\n        \"\"\"\\n        result = self.items.get()\\n        q2 = Queue()\\n        q2.put(result)\\n        while(not self.items.empty()):\\n            print(self.items.qsize())\\n            q2.put(self.items.get())\\n        self.items = q2\\n        return result\\n\\n\\n    def empty(self):\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        :rtype: bool\\n        \"\"\"\\n        return self.items.empty()\\n```\n```\\nfrom queue import Queue\\nclass MyStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.items = Queue()\\n\\n\\n    def push(self, x):\\n        \"\"\"\\n        Push element x onto stack.\\n        :type x: int\\n        :rtype: void\\n        \"\"\"\\n        self.items.put(x)\\n\\n\\n    def pop(self):\\n        \"\"\"\\n        Removes the element on top of the stack and returns that element.\\n        :rtype: int\\n        \"\"\"\\n        q2 = Queue()\\n        while(self.items.qsize() >1):\\n            q2.put(self.items.get())\\n        result = self.items.get()\\n        self.items = q2\\n        return result\\n\\n\\n    def top(self):\\n        \"\"\"\\n        Get the top element.\\n        :rtype: int\\n        \"\"\"\\n        q2 = Queue()\\n        while(self.items.qsize() >1):\\n            q2.put(self.items.get())\\n        result = self.items.get()\\n        q2.put(result)\\n        self.items = q2\\n        return result\\n\\n\\n    def empty(self):\\n        \"\"\"\\n        Returns whether the stack is empty.\\n        :rtype: bool\\n        \"\"\"\\n        return self.items.empty()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62539,
                "title": "javascript-one-queue",
                "content": "```javascript\\n/**\\n * Initialize your data structure here.\\n */\\nvar MyStack = function() {\\n    this.stack = []\\n};\\n\\n/**\\n * Push element x onto stack. \\n * @param {number} x\\n * @return {void}\\n */\\nMyStack.prototype.push = function(x) {\\n    this.stack.push(x)\\n};\\n\\n/**\\n * Removes the element on top of the stack and returns that element.\\n * @return {number}\\n */\\nMyStack.prototype.pop = function() {\\n    let len = this.stack.length\\n    for (let i = 1; i < len; i++) {\\n        let n = this.stack.shift()\\n        this.stack.push(n)\\n    }\\n    return this.stack.shift()\\n};\\n\\n/**\\n * Get the top element.\\n * @return {number}\\n */\\nMyStack.prototype.top = function() {\\n    let len = this.stack.length-1\\n    return this.stack[len]\\n};\\n\\n/**\\n * Returns whether the stack is empty.\\n * @return {boolean}\\n */\\nMyStack.prototype.empty = function() {\\n    return this.stack.length < 1\\n};\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = Object.create(MyStack).createNew()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Initialize your data structure here.\\n */\\nvar MyStack = function() {\\n    this.stack = []\\n};\\n\\n/**\\n * Push element x onto stack. \\n * @param {number} x\\n * @return {void}\\n */\\nMyStack.prototype.push = function(x) {\\n    this.stack.push(x)\\n};\\n\\n/**\\n * Removes the element on top of the stack and returns that element.\\n * @return {number}\\n */\\nMyStack.prototype.pop = function() {\\n    let len = this.stack.length\\n    for (let i = 1; i < len; i++) {\\n        let n = this.stack.shift()\\n        this.stack.push(n)\\n    }\\n    return this.stack.shift()\\n};\\n\\n/**\\n * Get the top element.\\n * @return {number}\\n */\\nMyStack.prototype.top = function() {\\n    let len = this.stack.length-1\\n    return this.stack[len]\\n};\\n\\n/**\\n * Returns whether the stack is empty.\\n * @return {boolean}\\n */\\nMyStack.prototype.empty = function() {\\n    return this.stack.length < 1\\n};\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = Object.create(MyStack).createNew()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62592,
                "title": "c-stl-with-only-one-queue",
                "content": "\\n    class Stack {\\n    public:\\n    queue<int> vque;\\n    void push(int x) {\\n        int n = vque.size();\\n        \\n        vque.push(x);\\n        for(int i = 0; i < n; i ++)\\n        {\\n            int n = vque.front();\\n            vque.pop();\\n            vque.push(n);\\n        }\\n    }\\n\\n    // Removes the element on top of the stack.\\n    void pop() {\\n        vque.pop();\\n    }\\n\\n    // Get the top element.\\n    int top() {\\n        return vque.front();\\n    }\\n\\n    // Return whether the stack is empty.\\n    bool empty() {\\n        return vque.empty();\\n    }\\n};",
                "solutionTags": [],
                "code": "\\n    class Stack {\\n    public:\\n    queue<int> vque;\\n    void push(int x) {\\n        int n = vque.size();\\n        \\n        vque.push(x);\\n        for(int i = 0; i < n; i ++)\\n        {\\n            int n = vque.front();\\n            vque.pop();\\n            vque.push(n);\\n        }\\n    }\\n\\n    // Removes the element on top of the stack.\\n    void pop() {\\n        vque.pop();\\n    }\\n\\n    // Get the top element.\\n    int top() {\\n        return vque.front();\\n    }\\n\\n    // Return whether the stack is empty.\\n    bool empty() {\\n        return vque.empty();\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 62660,
                "title": "accepted-solution-in-c-0ms",
                "content": "My Accepted Solution in C (0ms) - 16/16 test cases passed.\\n\\n    typedef struct {\\n        int *q;\\n        int size;\\n        int front;\\n        int rear;\\n    } Queue;\\n    typedef struct {\\n        Queue *q1;\\n        Queue *q2;\\n    } Stack;\\n    \\n    int queueIsEmpty(Queue *q) {\\n        if (q->front == -1 && q->rear == -1) {\\n            printf(\"\\\\nQUEUE is EMPTY\\\\n\");\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    int queueIsFull(Queue *q) {\\n        if (q->rear == q->size-1) {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    int queueTop(Queue *q) {\\n        if (queueIsEmpty(q)) {\\n            return -1;\\n        }\\n        return q->q[q->front];\\n    }\\n    int queuePop(Queue *q) {\\n        if (queueIsEmpty(q)) {\\n            return -1;\\n        }\\n        int item = q->q[q->front];\\n        if (q->front == q->rear) {\\n            q->front = q->rear = -1;\\n        }\\n        else {\\n            q->front++;\\n        }\\n        return item;\\n    }\\n    void queuePush(Queue *q, int val) {\\n        if (queueIsFull(q)) {\\n            printf(\"\\\\nQUEUE is FULL\\\\n\");\\n            return;\\n        }\\n        if (queueIsEmpty(q)) {\\n            q->front++;\\n            q->rear++;\\n        } else {\\n            q->rear++;\\n        }\\n        q->q[q->rear] = val;\\n    }\\n    Queue *queueCreate(int maxSize) {\\n        Queue *q = (Queue*)malloc(sizeof(Queue));\\n        q->front = q->rear = -1;\\n        q->size = maxSize;\\n        q->q = (int*)malloc(sizeof(int)*maxSize);\\n        return q;\\n    }\\n    /* Create a stack */\\n    void stackCreate(Stack *stack, int maxSize) {\\n        Stack **s = (Stack**) stack;\\n        *s = (Stack*)malloc(sizeof(Stack));\\n        (*s)->q1 = queueCreate(maxSize);\\n        (*s)->q2 = queueCreate(maxSize);\\n    }\\n    \\n    /* Push element x onto stack */\\n    void stackPush(Stack *stack, int element) {\\n        Stack **s = (Stack**) stack;\\n        queuePush((*s)->q2, element);\\n        while (!queueIsEmpty((*s)->q1)) {\\n            int item = queuePop((*s)->q1);\\n            queuePush((*s)->q2, item);\\n        }\\n        Queue *tmp = (*s)->q1;\\n        (*s)->q1 = (*s)->q2;\\n        (*s)->q2 = tmp;\\n    }\\n    \\n    /* Removes the element on top of the stack */\\n    void stackPop(Stack *stack) {\\n        Stack **s = (Stack**) stack;\\n        queuePop((*s)->q1);\\n    }\\n    \\n    /* Get the top element */\\n    int stackTop(Stack *stack) {\\n        Stack **s = (Stack**) stack;\\n        if (!queueIsEmpty((*s)->q1)) {\\n          return queueTop((*s)->q1);\\n        }\\n        return -1;\\n    }\\n    \\n    /* Return whether the stack is empty */\\n    bool stackEmpty(Stack *stack) {\\n        Stack **s = (Stack**) stack;\\n        if (queueIsEmpty((*s)->q1)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /* Destroy the stack */\\n    void stackDestroy(Stack *stack) {\\n        Stack **s = (Stack**) stack;\\n        free((*s)->q1);\\n        free((*s)->q2);\\n        free((*s));\\n    }",
                "solutionTags": [
                    "Stack",
                    "Queue"
                ],
                "code": "My Accepted Solution in C (0ms) - 16/16 test cases passed.\\n\\n    typedef struct {\\n        int *q;\\n        int size;\\n        int front;\\n        int rear;\\n    } Queue;\\n    typedef struct {\\n        Queue *q1;\\n        Queue *q2;\\n    } Stack;\\n    \\n    int queueIsEmpty(Queue *q) {\\n        if (q->front == -1 && q->rear == -1) {\\n            printf(\"\\\\nQUEUE is EMPTY\\\\n\");\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    int queueIsFull(Queue *q) {\\n        if (q->rear == q->size-1) {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    int queueTop(Queue *q) {\\n        if (queueIsEmpty(q)) {\\n            return -1;\\n        }\\n        return q->q[q->front];\\n    }\\n    int queuePop(Queue *q) {\\n        if (queueIsEmpty(q)) {\\n            return -1;\\n        }\\n        int item = q->q[q->front];\\n        if (q->front == q->rear) {\\n            q->front = q->rear = -1;\\n        }\\n        else {\\n            q->front++;\\n        }\\n        return item;\\n    }\\n    void queuePush(Queue *q, int val) {\\n        if (queueIsFull(q)) {\\n            printf(\"\\\\nQUEUE is FULL\\\\n\");\\n            return;\\n        }\\n        if (queueIsEmpty(q)) {\\n            q->front++;\\n            q->rear++;\\n        } else {\\n            q->rear++;\\n        }\\n        q->q[q->rear] = val;\\n    }\\n    Queue *queueCreate(int maxSize) {\\n        Queue *q = (Queue*)malloc(sizeof(Queue));\\n        q->front = q->rear = -1;\\n        q->size = maxSize;\\n        q->q = (int*)malloc(sizeof(int)*maxSize);\\n        return q;\\n    }\\n    /* Create a stack */\\n    void stackCreate(Stack *stack, int maxSize) {\\n        Stack **s = (Stack**) stack;\\n        *s = (Stack*)malloc(sizeof(Stack));\\n        (*s)->q1 = queueCreate(maxSize);\\n        (*s)->q2 = queueCreate(maxSize);\\n    }\\n    \\n    /* Push element x onto stack */\\n    void stackPush(Stack *stack, int element) {\\n        Stack **s = (Stack**) stack;\\n        queuePush((*s)->q2, element);\\n        while (!queueIsEmpty((*s)->q1)) {\\n            int item = queuePop((*s)->q1);\\n            queuePush((*s)->q2, item);\\n        }\\n        Queue *tmp = (*s)->q1;\\n        (*s)->q1 = (*s)->q2;\\n        (*s)->q2 = tmp;\\n    }\\n    \\n    /* Removes the element on top of the stack */\\n    void stackPop(Stack *stack) {\\n        Stack **s = (Stack**) stack;\\n        queuePop((*s)->q1);\\n    }\\n    \\n    /* Get the top element */\\n    int stackTop(Stack *stack) {\\n        Stack **s = (Stack**) stack;\\n        if (!queueIsEmpty((*s)->q1)) {\\n          return queueTop((*s)->q1);\\n        }\\n        return -1;\\n    }\\n    \\n    /* Return whether the stack is empty */\\n    bool stackEmpty(Stack *stack) {\\n        Stack **s = (Stack**) stack;\\n        if (queueIsEmpty((*s)->q1)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /* Destroy the stack */\\n    void stackDestroy(Stack *stack) {\\n        Stack **s = (Stack**) stack;\\n        free((*s)->q1);\\n        free((*s)->q2);\\n        free((*s));\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 62673,
                "title": "java-easy-understanding-solution-only-push-takes-o-n",
                "content": "The general idea is that we maintain the stack order in the queue.\\n\\nAssuming the queue \"queue\" already contains the stack order of previous push.  Then the next push(x) operation could be divided into  steps:\\n\\n1.  We create a new queue \"temp\" and offer the value x to it.\\n2.  Then we offer the values in \"queue\" into \"temp\"\\n3.  We assign \"queue\" with \"temp\" (queue=temp)\\n\\nIn this way, the queue maintains the stack order again.\\n\\n    class MyStack {\\n\\n    private Queue<Integer> queue = new ArrayDeque<>();\\n\\n    // Push element x onto stack.\\n    public void push(int x) {\\n        Queue<Integer> temp = new ArrayDeque<>();\\n        temp.offer(x);\\n        for (int i : queue) temp.offer(i);\\n        queue = temp;\\n    }\\n\\n    // Removes the element on top of the stack.\\n    public void pop() {\\n        queue.poll();\\n    }\\n\\n    // Get the top element.\\n    public int top() {\\n        return queue.peek();\\n    }\\n\\n    // Return whether the stack is empty.\\n    public boolean empty() {\\n        return queue.isEmpty();\\n    }\\n }\\n\\nHope this can help you guys!",
                "solutionTags": [],
                "code": "The general idea is that we maintain the stack order in the queue.\\n\\nAssuming the queue \"queue\" already contains the stack order of previous push.  Then the next push(x) operation could be divided into  steps:\\n\\n1.  We create a new queue \"temp\" and offer the value x to it.\\n2.  Then we offer the values in \"queue\" into \"temp\"\\n3.  We assign \"queue\" with \"temp\" (queue=temp)\\n\\nIn this way, the queue maintains the stack order again.\\n\\n    class MyStack {\\n\\n    private Queue<Integer> queue = new ArrayDeque<>();\\n\\n    // Push element x onto stack.\\n    public void push(int x) {\\n        Queue<Integer> temp = new ArrayDeque<>();\\n        temp.offer(x);\\n        for (int i : queue) temp.offer(i);\\n        queue = temp;\\n    }\\n\\n    // Removes the element on top of the stack.\\n    public void pop() {\\n        queue.poll();\\n    }\\n\\n    // Get the top element.\\n    public int top() {\\n        return queue.peek();\\n    }\\n\\n    // Return whether the stack is empty.\\n    public boolean empty() {\\n        return queue.isEmpty();\\n    }\\n }\\n\\nHope this can help you guys!",
                "codeTag": "Java"
            },
            {
                "id": 62676,
                "title": "share-my-javascript-solution-with-only-one-queue",
                "content": "I only use one queue, this is enough. when element is remove, you can push them in queue in the sometime. code like this:\\n\\n    var Stack = function() {\\n        this.queue = [];\\n    };\\n\\n    Stack.prototype.push = function(x) {\\n        this.queue.push(x);\\n    };\\n\\n    Stack.prototype.pop = function() {\\n        for (var i = 1, len = this.queue.length; i < len; i += 1) {\\n            this.queue.push(this.queue.shift());\\n        }\\n        this.queue.shift();\\n    };\\n\\n    Stack.prototype.top = function() {\\n        for (var i = 1, len = this.queue.length; i < len; i += 1) {\\n            this.queue.push(this.queue.shift());\\n        }\\n        var ele = this.queue.shift();\\n        this.queue.push(ele);\\n    \\n        return ele;\\n    };\\n\\n    Stack.prototype.empty = function() {\\n        return this.queue.length === 0 ? true : false;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "I only use one queue, this is enough. when element is remove, you can push them in queue in the sometime. code like this:\\n\\n    var Stack = function() {\\n        this.queue = [];\\n    };\\n\\n    Stack.prototype.push = function(x) {\\n        this.queue.push(x);\\n    };\\n\\n    Stack.prototype.pop = function() {\\n        for (var i = 1, len = this.queue.length; i < len; i += 1) {\\n            this.queue.push(this.queue.shift());\\n        }\\n        this.queue.shift();\\n    };\\n\\n    Stack.prototype.top = function() {\\n        for (var i = 1, len = this.queue.length; i < len; i += 1) {\\n            this.queue.push(this.queue.shift());\\n        }\\n        var ele = this.queue.shift();\\n        this.queue.push(ele);\\n    \\n        return ele;\\n    };\\n\\n    Stack.prototype.empty = function() {\\n        return this.queue.length === 0 ? true : false;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 4022045,
                "title": "implement-stack-using-queues-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\nprivate:\\n    queue<int> primary, secondary;\\npublic:\\n    MyStack() {  \\n    }\\n    void push(int x) {\\n        primary.push(x);\\n    }\\n    int pop() {\\n        while(primary.size() != 1){\\n            secondary.push(primary.front());\\n            primary.pop();\\n        }\\n        int res = primary.front();\\n        primary.pop();\\n        while(!secondary.empty()){\\n            primary.push(secondary.front());\\n            secondary.pop();\\n        }\\n        return res;\\n    }\\n    int top() {\\n        while(primary.size() != 1){\\n            secondary.push(primary.front());\\n            primary.pop();\\n        }\\n        int res = primary.front();\\n        primary.pop();\\n        secondary.push(res);\\n        while(!secondary.empty()){\\n            primary.push(secondary.front());\\n            secondary.pop();\\n        }\\n        return res;\\n    }\\n    bool empty() {\\n        return primary.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\nprivate:\\n    queue<int> primary, secondary;\\npublic:\\n    MyStack() {  \\n    }\\n    void push(int x) {\\n        primary.push(x);\\n    }\\n    int pop() {\\n        while(primary.size() != 1){\\n            secondary.push(primary.front());\\n            primary.pop();\\n        }\\n        int res = primary.front();\\n        primary.pop();\\n        while(!secondary.empty()){\\n            primary.push(secondary.front());\\n            secondary.pop();\\n        }\\n        return res;\\n    }\\n    int top() {\\n        while(primary.size() != 1){\\n            secondary.push(primary.front());\\n            primary.pop();\\n        }\\n        int res = primary.front();\\n        primary.pop();\\n        secondary.push(res);\\n        while(!secondary.empty()){\\n            primary.push(secondary.front());\\n            secondary.pop();\\n        }\\n        return res;\\n    }\\n    bool empty() {\\n        return primary.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973838,
                "title": "python-one-queue-two-approaches-easy",
                "content": "```\\nfrom queue import Queue\\n\\nclass MyStack: # Using One Queue\\n\\n    def __init__(self):\\n        self.q=Queue()\\n\\n    def push(self, x: int) -> None:\\n        self.q.put(x)\\n        for i in range(self.q.qsize()-1):\\n            self.q.put(self.q.get())\\n\\n    def pop(self) -> int:\\n        return self.q.get()\\n\\n    def top(self) -> int:\\n        return self.q.queue[0]\\n\\n    def empty(self) -> bool:\\n        return self.q.empty()\\n```\\n\\t\\t\\n```\\nclass MyStack: # Using Two Queues\\n\\n    def __init__(self):\\n        self.q1=Queue()\\n        self.q2=Queue()\\n\\n    def push(self, x: int) -> None:\\n        self.q2.put(x)\\n        while not self.q1.empty():\\n            self.q2.put(self.q1.get())\\n        self.q1,self.q2=self.q2,self.q1\\n\\n    def pop(self) -> int:\\n        return self.q1.get()\\n\\n    def top(self) -> int:\\n        return self.q1.queue[0]\\n\\n    def empty(self) -> bool:\\n        return self.q1.empty()\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nfrom queue import Queue\\n\\nclass MyStack: # Using One Queue\\n\\n    def __init__(self):\\n        self.q=Queue()\\n\\n    def push(self, x: int) -> None:\\n        self.q.put(x)\\n        for i in range(self.q.qsize()-1):\\n            self.q.put(self.q.get())\\n\\n    def pop(self) -> int:\\n        return self.q.get()\\n\\n    def top(self) -> int:\\n        return self.q.queue[0]\\n\\n    def empty(self) -> bool:\\n        return self.q.empty()\\n```\n```\\nclass MyStack: # Using Two Queues\\n\\n    def __init__(self):\\n        self.q1=Queue()\\n        self.q2=Queue()\\n\\n    def push(self, x: int) -> None:\\n        self.q2.put(x)\\n        while not self.q1.empty():\\n            self.q2.put(self.q1.get())\\n        self.q1,self.q2=self.q2,self.q1\\n\\n    def pop(self) -> int:\\n        return self.q1.get()\\n\\n    def top(self) -> int:\\n        return self.q1.queue[0]\\n\\n    def empty(self) -> bool:\\n        return self.q1.empty()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973178,
                "title": "beats-100-0-ms-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a queue using linkedlist\\n- reverse the queue and it will behaves as stack\\n- perform the operations on queue\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\n    Queue<Integer> queue;\\n\\n    public MyStack() {\\n        this.queue=new LinkedList<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n        queue.add(x);\\n        for(int i=0;i<queue.size()-1;i++)\\n            queue.add(queue.poll());\\n    }\\n    \\n    public int pop() {\\n        return queue.poll();\\n    }\\n    \\n    public int top() {\\n        return queue.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return queue.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n    Queue<Integer> queue;\\n\\n    public MyStack() {\\n        this.queue=new LinkedList<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n        queue.add(x);\\n        for(int i=0;i<queue.size()-1;i++)\\n            queue.add(queue.poll());\\n    }\\n    \\n    public int pop() {\\n        return queue.poll();\\n    }\\n    \\n    public int top() {\\n        return queue.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return queue.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972887,
                "title": "c-beats-100-o-1-pop-top-o-n-push-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: **O(n) for push operation, O(1) for other **\\n\\n- Space complexity: **O(n) Using 2 queues\\n**\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n\\n        // O(n)\\n        // if queue1 is empty simply push the element\\n        if(q1.empty()){\\n            q1.push(x);\\n        }\\n\\n        else{\\n            // transfer all elements of q1 to q2\\n            while(!q1.empty()){\\n                int data = q1.front();\\n                q1.pop();\\n                q2.push(data);\\n            }\\n            // push the element in q1\\n            q1.push(x);\\n            //transfer all elements from q2 to q1\\n            while(!q2.empty()){\\n                int val = q2.front();\\n                q2.pop();\\n                q1.push(val);\\n            }\\n        }\\n\\n    }\\n    \\n    int pop() {\\n        // O(1)\\n        // element at front is the element to be popped\\n        int element = q1.front();\\n        q1.pop();\\n        return element;\\n    }\\n    \\n    int top() {\\n        // O(1)\\n        int element = q1.front();\\n        return element;\\n    }\\n    \\n    bool empty() {\\n        if(q1.size()==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    queue<int> q2;\\n\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n\\n        // O(n)\\n        // if queue1 is empty simply push the element\\n        if(q1.empty()){\\n            q1.push(x);\\n        }\\n\\n        else{\\n            // transfer all elements of q1 to q2\\n            while(!q1.empty()){\\n                int data = q1.front();\\n                q1.pop();\\n                q2.push(data);\\n            }\\n            // push the element in q1\\n            q1.push(x);\\n            //transfer all elements from q2 to q1\\n            while(!q2.empty()){\\n                int val = q2.front();\\n                q2.pop();\\n                q1.push(val);\\n            }\\n        }\\n\\n    }\\n    \\n    int pop() {\\n        // O(1)\\n        // element at front is the element to be popped\\n        int element = q1.front();\\n        q1.pop();\\n        return element;\\n    }\\n    \\n    int top() {\\n        // O(1)\\n        int element = q1.front();\\n        return element;\\n    }\\n    \\n    bool empty() {\\n        if(q1.size()==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972562,
                "title": "implement-stack-using-queues",
                "content": "# Code\\n```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.l = []\\n    def push(self, x: int) -> None:\\n        self.l.append(x)\\n        \\n    def pop(self) -> int:\\n        return self.l.pop()\\n    def top(self) -> int:\\n        return self.l[-1]\\n        \\n    def empty(self) -> bool:\\n        return len(self.l)==0\\n\\n        \\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.l = []\\n    def push(self, x: int) -> None:\\n        self.l.append(x)\\n        \\n    def pop(self) -> int:\\n        return self.l.pop()\\n    def top(self) -> int:\\n        return self.l[-1]\\n        \\n    def empty(self) -> bool:\\n        return len(self.l)==0\\n\\n        \\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972423,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\n    queue<int>q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n    }\\n    \\n    int pop() {\\n        int popValue;\\n        int newSize=q.size()-1;\\n        while(newSize--){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n        popValue=q.front();\\n        q.pop();\\n        return popValue;\\n    }\\n    \\n    int top() {\\n        return q.back();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\n    queue<int>q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n    }\\n    \\n    int pop() {\\n        int popValue;\\n        int newSize=q.size()-1;\\n        while(newSize--){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n        popValue=q.front();\\n        q.pop();\\n        return popValue;\\n    }\\n    \\n    int top() {\\n        return q.back();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971827,
                "title": "faster-than-100-easy-approach-using-2-queue",
                "content": "![Screenshot 2023-08-28 at 6.31.29 PM.png](https://assets.leetcode.com/users/images/ec8b2d8b-1c17-41c8-bb56-d4a19e833c4f_1693227750.2707262.png)\\n# Intuition\\nPushing is the only operation which will likely cause problem , hence we need to implement queue in such a way that after inserting the last elem it should be present at first.\\n\\n# Approach\\nImplement push using recursion \\nif we implement it like - \\n```\\nvoid push(int x)  { fun(x);}\\nfun(x) \\n{\\n    if(q.size()==0)\\n    {\\n        q.push(x);\\n        return;\\n    }\\n    int d = q.front();\\n    q.pop();\\n    fun(x);\\n    q.push(d);\\n}\\n``` \\nIn above approach if we execute  - **push(1) push (2) push (3);**\\nin the queue the data will be stored like 3 1 2 instead of 3 2 1;\\nto fix this we will need another queue which will store the data;\\n```\\nvoid push(int x)  { fun(x);}\\nfun(x) \\n{\\n    if(q.size()==0)\\n    {\\n        q.push(x);\\n        return;\\n    }\\n    int d = q.front();\\n    hq.push(d);\\n    q.pop();\\n    fun(x);\\n    while(!hq.empty())\\n    {\\n        q.push(hq.front());\\n        hq.pop();\\n    }\\n}\\n```\\nThis will fix the above problem.\\n*if we write hq.push(d); after the recursion call it will lead to same problem again*\\n\\n# Complexity\\n- Time complexity:\\nEvery function except push is O(1) , push is O(N^2) since at every push after 1st push we are poping and pushing into another queue . \\n\\n- Space complexity:\\nfor push since we\\'re using 2 queue so S.C is O(N)\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n    queue<int> hq;\\n    MyStack() {\\n    }\\n    \\n    void push(int x) {\\n        fun(x);\\n    }\\n    void fun(int x)\\n    {\\n       if(q.size()==0)\\n       {\\n           q.push(x);\\n           return;\\n       }\\n       int d =q.front();\\n       q.pop();\\n       hq.push(d);\\n       fun(x);\\n       while(!hq.empty())\\n       {\\n           q.push(hq.front());\\n           hq.pop();\\n       }\\n    }\\n    int pop() {\\n        int d= q.front();\\n        q.pop();\\n        return d;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nvoid push(int x)  { fun(x);}\\nfun(x) \\n{\\n    if(q.size()==0)\\n    {\\n        q.push(x);\\n        return;\\n    }\\n    int d = q.front();\\n    q.pop();\\n    fun(x);\\n    q.push(d);\\n}\\n```\n```\\nvoid push(int x)  { fun(x);}\\nfun(x) \\n{\\n    if(q.size()==0)\\n    {\\n        q.push(x);\\n        return;\\n    }\\n    int d = q.front();\\n    hq.push(d);\\n    q.pop();\\n    fun(x);\\n    while(!hq.empty())\\n    {\\n        q.push(hq.front());\\n        hq.pop();\\n    }\\n}\\n```\n```\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n    queue<int> hq;\\n    MyStack() {\\n    }\\n    \\n    void push(int x) {\\n        fun(x);\\n    }\\n    void fun(int x)\\n    {\\n       if(q.size()==0)\\n       {\\n           q.push(x);\\n           return;\\n       }\\n       int d =q.front();\\n       q.pop();\\n       hq.push(d);\\n       fun(x);\\n       while(!hq.empty())\\n       {\\n           q.push(hq.front());\\n           hq.pop();\\n       }\\n    }\\n    int pop() {\\n        int d= q.front();\\n        q.pop();\\n        return d;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970779,
                "title": "o-ms-beats-100-of-java-users-using-two-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\n    Queue<Integer> q = new LinkedList<>();\\n    public MyStack() {\\n        \\n    }\\n    \\n    public void push(int x) {\\n        q.add(x);\\n    }\\n    \\n    public int pop() {\\n        Queue<Integer> top = new LinkedList<>();\\n        \\n        int size =  q.size();\\n\\n        for(int i =0;i<size-1;i++){\\n            top.add(q.remove());\\n        }\\n        int ans =  q.remove();\\n        \\n\\n        for(int i =0;i<size-1;i++){\\n            q.add(top.remove());\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    public int top() {\\n        Queue<Integer> top = new LinkedList<>();\\n        int size =  q.size();\\n        for(int i =0;i<size-1;i++){\\n            top.add(q.remove());\\n        }\\n        int ans =  q.peek();\\n        top.add(q.remove());\\n\\n        for(int i =0;i<size;i++){\\n            q.add(top.remove());\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean empty() {\\n        \\n        return q.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n    Queue<Integer> q = new LinkedList<>();\\n    public MyStack() {\\n        \\n    }\\n    \\n    public void push(int x) {\\n        q.add(x);\\n    }\\n    \\n    public int pop() {\\n        Queue<Integer> top = new LinkedList<>();\\n        \\n        int size =  q.size();\\n\\n        for(int i =0;i<size-1;i++){\\n            top.add(q.remove());\\n        }\\n        int ans =  q.remove();\\n        \\n\\n        for(int i =0;i<size-1;i++){\\n            q.add(top.remove());\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    public int top() {\\n        Queue<Integer> top = new LinkedList<>();\\n        int size =  q.size();\\n        for(int i =0;i<size-1;i++){\\n            top.add(q.remove());\\n        }\\n        int ans =  q.peek();\\n        top.add(q.remove());\\n\\n        for(int i =0;i<size;i++){\\n            q.add(top.remove());\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean empty() {\\n        \\n        return q.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970478,
                "title": "best-solution-on-leetcode",
                "content": "\\n# Approach\\nCheck if both q1 and q2 are non-empty before performing the operation. If either of them is empty, you might need to handle this situation based on your requirements.\\n\\nGet the front element of q2 using the front() function. This doesn\\'t remove the element from the queue; it just allows you to access it.\\n\\nPush the element obtained in step 2 into q1 using the push() function.\\n\\nRemove the front element from q2 using the pop() function. This will remove the element from the front of q2.\\nHere\\'s a pseudo-code representation of the approach:\\n\\n\\nif q2 is not empty and q1 is not empty:\\n    element_to_move = q2.front()   // Get the front element of q2\\n    q1.push(element_to_move)       // Push the element into q1\\n    q2.pop()                       // Remove the element from the front of q2\\nelse:\\n    // Handle the situation when one of the queues is empty\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n queue<int> q1,q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        while(!q1.empty())\\n        {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        q1.push(x);\\n        while(!q2.empty()){\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n       \\n    }\\n    \\n    int pop() {\\n    int val=q1.front();\\n    q1.pop();\\n    return val; \\n    }\\n    \\n    int top() {\\n       return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n queue<int> q1,q2;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        while(!q1.empty())\\n        {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        q1.push(x);\\n        while(!q2.empty()){\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n       \\n    }\\n    \\n    int pop() {\\n    int val=q1.front();\\n    q1.pop();\\n    return val; \\n    }\\n    \\n    int top() {\\n       return q1.front();\\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970409,
                "title": "implementing-a-stack-using-a-single-queue-full-explanation-mr-robot",
                "content": "---\\n\\n## Implementing a Stack Using a Single Queue in C++\\n\\n**Introduction:**\\nStacks are fundamental data structures used in programming for managing data in a last-in, first-out (LIFO) manner. In this blog post, we\\'ll delve into an interesting challenge: implementing a stack using just a single queue. We\\'ll explore an ingenious approach that leverages the power of rotations to achieve this feat.\\n\\n**Problem Statement:**\\nThe challenge is to create a stack data structure that supports the basic stack operations (`push`, `pop`, `top`, and `empty`) using only a single queue. This might sound counterintuitive, but with the right strategy, it\\'s definitely possible.\\n\\n**Approach Overview:**\\nOur approach involves simulating the stack behavior by manipulating the queue through rotations. We\\'ll maintain the top element of the stack in a separate variable and use rotations to ensure that the top element is always at the front of the queue.\\n\\n**Implementation Walkthrough:**\\nLet\\'s dive into the implementation details of each method in the `MyStack` class:\\n\\n1. **Constructor (`MyStack() {}`):**\\n   - Initialize an empty queue (`q`) to store the stack elements.\\n\\n2. **`push(int x)`:**\\n   - Enqueue element `x` into the queue.\\n   - Update the `topp` variable to hold the value of the newly pushed element.\\n   - Perform a rotation of the queue by dequeuing elements from the front and enqueuing them back. This ensures that the newly pushed element becomes the front element.\\n\\n3. **`pop()`:**\\n   - Dequeue the front element of the queue and store it in the `remo` variable.\\n   - If the queue is not empty, update the `topp` variable with the new front element.\\n   - Return the removed element.\\n\\n4. **`top()`:**\\n   - Return the value of the `topp` variable, which holds the top element of the stack.\\n\\n5. **`empty()`:**\\n   - Check if the queue is empty using the `empty()` method of the queue.\\n\\n**Algorithm Analysis:**\\nThe time complexity of the `push`, `pop`, `top`, and `empty` operations is O(n) in the worst case, where n is the number of elements in the queue. This approach is slightly less efficient than traditional stack implementations but offers a unique perspective on data manipulation.\\n\\n**Advantages and Limitations:**\\n- Advantages: This approach utilizes a single queue and is simple to understand and implement.\\n- Limitations: It might not be the most efficient solution for large queues due to the rotation process, which takes linear time.\\n\\n**Comparisons with Other Approaches:**\\nComparing this approach with the standard stack and two-queue approaches, our implementation sacrifices some efficiency for simplicity and an interesting use of rotations.\\n\\n**Use Cases and Examples:**\\nThis implementation can be useful in scenarios where you want to explore unique stack implementations. Let\\'s look at some examples:\\n\\n```cpp\\nMyStack stack;\\nstack.push(5);\\nstack.push(10);\\ncout << stack.top() << endl; // Output: 10\\nstack.pop();\\ncout << stack.top() << endl; // Output: 5\\ncout << stack.empty() << endl; // Output: 0 (false)\\n```\\n\\n**Conclusion:**\\nImplementing a stack using a single queue is a fascinating exercise that demonstrates the power of creative problem-solving. While this approach might not be the most efficient, it showcases how rotations can be used to achieve stack behavior using a unique twist on a classic data structure.\\n\\nExperiment with the code, run your own test cases, and consider how this approach aligns with different programming challenges. This implementation serves as a valuable addition to your arsenal of programming techniques.\\n\\n---\\n\\n# Code \\n```C++ []\\n#include <queue>\\n\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n    int topp = -1;\\n\\n    MyStack() {}\\n\\n    void push(int x) {\\n        q.push(x);\\n        topp = x;\\n        int size = q.size();\\n        while (size > 1) {\\n            int front = q.front();\\n            q.pop();\\n            q.push(front);\\n            size--;\\n        }\\n    }\\n\\n    int pop() {\\n        int remo = q.front();\\n        q.pop();\\n        if (!q.empty()) {\\n            topp = q.front();\\n        }\\n        return remo;\\n    }\\n\\n    int top() {\\n        return topp;\\n    }\\n\\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n```\\n```python []\\nfrom queue import Queue\\n\\nclass MyStack:\\n    def __init__(self):\\n        self.q = Queue()\\n        self.topp = -1\\n\\n    def push(self, x):\\n        self.q.put(x)\\n        self.topp = x\\n        size = self.q.qsize()\\n        while size > 1:\\n            front = self.q.get()\\n            self.q.put(front)\\n            size -= 1\\n\\n    def pop(self):\\n        remo = self.q.get()\\n        if not self.q.empty():\\n            self.topp = self.q.queue[0]\\n        return remo\\n\\n    def top(self):\\n        return self.topp\\n\\n    def empty(self):\\n        return self.q.empty()\\n\\n# Example usage\\n#stack = MyStack()\\n#stack.push(5)\\n#stack.push(10)\\n#print(stack.top())  # Output: 10\\n#stack.pop()\\n#print(stack.top())  # Output: 5\\n#print(stack.empty())  # Output: False\\n\\n```\\n```java []\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass MyStack {\\n    private Queue<Integer> q = new LinkedList<>();\\n    private int topp = -1;\\n\\n    public void push(int x) {\\n        q.offer(x);\\n        topp = x;\\n        int size = q.size();\\n        while (size > 1) {\\n            int front = q.poll();\\n            q.offer(front);\\n            size--;\\n        }\\n    }\\n\\n    public int pop() {\\n        int remo = q.poll();\\n        if (!q.isEmpty()) {\\n            topp = q.peek();\\n        }\\n        return remo;\\n    }\\n\\n    public int top() {\\n        return topp;\\n    }\\n\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n\\n// Example usage\\n//MyStack stack = new MyStack();\\n//stack.push(5);\\n//stack.push(10);\\n//System.out.println(stack.top());  // Output: 10\\n//stack.pop();\\n//System.out.println(stack.top());  // Output: 5\\n//System.out.println(stack.empty());  // Output: false\\n\\n```\\n``` ruby []\\nclass MyStack\\n    def initialize\\n        @q = []\\n        @topp = -1\\n    end\\n\\n    def push(x)\\n        @q.push(x)\\n        @topp = x\\n        (@q.length - 1).times { @q.push(@q.shift) }\\n    end\\n\\n    def pop\\n        remo = @q.shift\\n        @topp = @q[0] || -1\\n        remo\\n    end\\n\\n    def top\\n        @topp\\n    end\\n\\n    def empty\\n        @q.empty?\\n    end\\nend\\n\\n# Example usage\\n# stack = MyStack.new\\n# stack.push(5)\\n# stack.push(10)\\n# puts stack.top  # Output: 10\\n# stack.pop\\n# puts stack.top  # Output: 5\\n# puts stack.empty  # Output: false\\n```\\n``` Javascript []\\nclass MyStack {\\n    constructor() {\\n        this.q = [];\\n        this.topp = -1;\\n    }\\n\\n    push(x) {\\n        this.q.push(x);\\n        this.topp = x;\\n        for (let i = 0; i < this.q.length - 1; i++) {\\n            this.q.push(this.q.shift());\\n        }\\n    }\\n\\n    pop() {\\n        const remo = this.q.shift();\\n        if (this.q.length > 0) {\\n            this.topp = this.q[0];\\n        }\\n        return remo;\\n    }\\n\\n    top() {\\n        return this.topp;\\n    }\\n\\n    empty() {\\n        return this.q.length === 0;\\n    }\\n}\\n\\n// Example usage\\n// const stack = new MyStack();\\n// stack.push(5);\\n// stack.push(10);\\n// console.log(stack.top());  // Output: 10\\n// stack.pop();\\n// console.log(stack.top());  // Output: 5\\n// console.log(stack.empty());  // Output: false\\n\\n```\\n```C# []\\nusing System;\\nusing System.Collections.Generic;\\n\\nclass MyStack\\n{\\n    private Queue<int> q = new Queue<int>();\\n    private int topp = -1;\\n\\n    public void Push(int x)\\n    {\\n        q.Enqueue(x);\\n        topp = x;\\n        int size = q.Count;\\n        while (size > 1)\\n        {\\n            int front = q.Dequeue();\\n            q.Enqueue(front);\\n            size--;\\n        }\\n    }\\n\\n    public int Pop()\\n    {\\n        int remo = q.Dequeue();\\n        if (q.Count > 0)\\n        {\\n            topp = q.Peek();\\n        }\\n        return remo;\\n    }\\n\\n    public int Top()\\n    {\\n        return topp;\\n    }\\n\\n    public bool Empty()\\n    {\\n        return q.Count == 0;\\n    }\\n}\\n\\n// Example usage\\n// MyStack stack = new MyStack();\\n// stack.Push(5);\\n// stack.Push(10);\\n// Console.WriteLine(stack.Top());  // Output: 10\\n// stack.Pop();\\n// Console.WriteLine(stack.Top());  // Output: 5\\n// Console.WriteLine(stack.Empty());  // Output: False\\n\\n```\\n# Consider UPVOTING\\u2B06\\uFE0F\\n\\n![image.png](https://assets.leetcode.com/users/images/de68d489-b9d3-4176-9066-a662969c5907_1693204132.7746704.png)\\n\\n\\n# DROP YOUR SUGGESTIONS IN THE COMMENT\\n\\n## Keep Coding\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n -- *MR.ROBOT SIGNING OFF*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Ruby",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```cpp\\nMyStack stack;\\nstack.push(5);\\nstack.push(10);\\ncout << stack.top() << endl; // Output: 10\\nstack.pop();\\ncout << stack.top() << endl; // Output: 5\\ncout << stack.empty() << endl; // Output: 0 (false)\\n```\n```C++ []\\n#include <queue>\\n\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n    int topp = -1;\\n\\n    MyStack() {}\\n\\n    void push(int x) {\\n        q.push(x);\\n        topp = x;\\n        int size = q.size();\\n        while (size > 1) {\\n            int front = q.front();\\n            q.pop();\\n            q.push(front);\\n            size--;\\n        }\\n    }\\n\\n    int pop() {\\n        int remo = q.front();\\n        q.pop();\\n        if (!q.empty()) {\\n            topp = q.front();\\n        }\\n        return remo;\\n    }\\n\\n    int top() {\\n        return topp;\\n    }\\n\\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n```\n```python []\\nfrom queue import Queue\\n\\nclass MyStack:\\n    def __init__(self):\\n        self.q = Queue()\\n        self.topp = -1\\n\\n    def push(self, x):\\n        self.q.put(x)\\n        self.topp = x\\n        size = self.q.qsize()\\n        while size > 1:\\n            front = self.q.get()\\n            self.q.put(front)\\n            size -= 1\\n\\n    def pop(self):\\n        remo = self.q.get()\\n        if not self.q.empty():\\n            self.topp = self.q.queue[0]\\n        return remo\\n\\n    def top(self):\\n        return self.topp\\n\\n    def empty(self):\\n        return self.q.empty()\\n\\n# Example usage\\n#stack = MyStack()\\n#stack.push(5)\\n#stack.push(10)\\n#print(stack.top())  # Output: 10\\n#stack.pop()\\n#print(stack.top())  # Output: 5\\n#print(stack.empty())  # Output: False\\n\\n```\n```java []\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass MyStack {\\n    private Queue<Integer> q = new LinkedList<>();\\n    private int topp = -1;\\n\\n    public void push(int x) {\\n        q.offer(x);\\n        topp = x;\\n        int size = q.size();\\n        while (size > 1) {\\n            int front = q.poll();\\n            q.offer(front);\\n            size--;\\n        }\\n    }\\n\\n    public int pop() {\\n        int remo = q.poll();\\n        if (!q.isEmpty()) {\\n            topp = q.peek();\\n        }\\n        return remo;\\n    }\\n\\n    public int top() {\\n        return topp;\\n    }\\n\\n    public boolean empty() {\\n        return q.isEmpty();\\n    }\\n}\\n\\n// Example usage\\n//MyStack stack = new MyStack();\\n//stack.push(5);\\n//stack.push(10);\\n//System.out.println(stack.top());  // Output: 10\\n//stack.pop();\\n//System.out.println(stack.top());  // Output: 5\\n//System.out.println(stack.empty());  // Output: false\\n\\n```\n``` ruby []\\nclass MyStack\\n    def initialize\\n        @q = []\\n        @topp = -1\\n    end\\n\\n    def push(x)\\n        @q.push(x)\\n        @topp = x\\n        (@q.length - 1).times { @q.push(@q.shift) }\\n    end\\n\\n    def pop\\n        remo = @q.shift\\n        @topp = @q[0] || -1\\n        remo\\n    end\\n\\n    def top\\n        @topp\\n    end\\n\\n    def empty\\n        @q.empty?\\n    end\\nend\\n\\n# Example usage\\n# stack = MyStack.new\\n# stack.push(5)\\n# stack.push(10)\\n# puts stack.top  # Output: 10\\n# stack.pop\\n# puts stack.top  # Output: 5\\n# puts stack.empty  # Output: false\\n```\n``` Javascript []\\nclass MyStack {\\n    constructor() {\\n        this.q = [];\\n        this.topp = -1;\\n    }\\n\\n    push(x) {\\n        this.q.push(x);\\n        this.topp = x;\\n        for (let i = 0; i < this.q.length - 1; i++) {\\n            this.q.push(this.q.shift());\\n        }\\n    }\\n\\n    pop() {\\n        const remo = this.q.shift();\\n        if (this.q.length > 0) {\\n            this.topp = this.q[0];\\n        }\\n        return remo;\\n    }\\n\\n    top() {\\n        return this.topp;\\n    }\\n\\n    empty() {\\n        return this.q.length === 0;\\n    }\\n}\\n\\n// Example usage\\n// const stack = new MyStack();\\n// stack.push(5);\\n// stack.push(10);\\n// console.log(stack.top());  // Output: 10\\n// stack.pop();\\n// console.log(stack.top());  // Output: 5\\n// console.log(stack.empty());  // Output: false\\n\\n```\n```C# []\\nusing System;\\nusing System.Collections.Generic;\\n\\nclass MyStack\\n{\\n    private Queue<int> q = new Queue<int>();\\n    private int topp = -1;\\n\\n    public void Push(int x)\\n    {\\n        q.Enqueue(x);\\n        topp = x;\\n        int size = q.Count;\\n        while (size > 1)\\n        {\\n            int front = q.Dequeue();\\n            q.Enqueue(front);\\n            size--;\\n        }\\n    }\\n\\n    public int Pop()\\n    {\\n        int remo = q.Dequeue();\\n        if (q.Count > 0)\\n        {\\n            topp = q.Peek();\\n        }\\n        return remo;\\n    }\\n\\n    public int Top()\\n    {\\n        return topp;\\n    }\\n\\n    public bool Empty()\\n    {\\n        return q.Count == 0;\\n    }\\n}\\n\\n// Example usage\\n// MyStack stack = new MyStack();\\n// stack.Push(5);\\n// stack.Push(10);\\n// Console.WriteLine(stack.Top());  // Output: 10\\n// stack.Pop();\\n// Console.WriteLine(stack.Top());  // Output: 5\\n// Console.WriteLine(stack.Empty());  // Output: False\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3970034,
                "title": "fastest-solution-with-explanation",
                "content": "# Approach\\n### Push\\n### q1 -> | |   empty\\nAfter adding element \\n1\\n2\\n3\\nq will be like this  \\n\\n       q1 -> | 3 | 2 | 1 |\\n## Pop\\nwhen applying `Pop` \\ntop = 3; \\n`if(!q1.isEmpty())  q2.add(del);` by using this the front element will be not added, but del will be updated.\\nwe will return `del` element\\n### q2 -> | 2 | 1 |\\nthen again add all element to the q1\\nand updated `top`\\n### q1 -> | 2 | 1 |\\n\\n\\n## Top\\nFor this just return the Top element.\\n\\n## Empty\\nTo check if it\\'s empty or not just return if the q1 is empty or not.\\nBecause to adding all the value in the stack we add all the elements in the queue.\\nIf the queue is empty means no element is there in the stack too.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n`Hey Folks`, please upvote the solution, if it helps you.\\n\\n# Code\\n```\\nclass MyStack {\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n    int top ;\\n    int del;\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n        top = 0;\\n    }\\n    \\n    public void push(int x) {\\n        top = x;\\n        q1.add(x);\\n    }\\n    \\n    public int pop() {\\n        while(!q1.isEmpty()){\\n            del = q1.remove();\\n            if(!q1.isEmpty())    q2.add(del);\\n        }\\n        while(!q2.isEmpty()){\\n            top= q2.remove();\\n            q1.add(top);\\n        }\\n        return del;\\n    }\\n    \\n    public int top() {\\n        return top;\\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n\\n```\\nThanks Folks",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n    int top ;\\n    int del;\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n        top = 0;\\n    }\\n    \\n    public void push(int x) {\\n        top = x;\\n        q1.add(x);\\n    }\\n    \\n    public int pop() {\\n        while(!q1.isEmpty()){\\n            del = q1.remove();\\n            if(!q1.isEmpty())    q2.add(del);\\n        }\\n        while(!q2.isEmpty()){\\n            top= q2.remove();\\n            q1.add(top);\\n        }\\n        return del;\\n    }\\n    \\n    public int top() {\\n        return top;\\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969901,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar MyStack = function() {\\n    this.stack = [];\\n};\\n\\nMyStack.prototype.push = function(x) {\\n    this.stack.push(x);\\n};\\n\\nMyStack.prototype.pop = function() {\\n    if (this.stack.length === 0) {\\n        return null; // Or throw an error, as popping from an empty stack is undefined behavior\\n    }\\n    return this.stack.pop();\\n};\\n\\nMyStack.prototype.top = function() {\\n    if (this.stack.length === 0) {\\n        return null; // Or throw an error\\n    }\\n    return this.stack[this.stack.length - 1];\\n};\\n\\nMyStack.prototype.empty = function() {\\n    return this.stack.length === 0;\\n};\\n\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar MyStack = function() {\\n    this.stack = [];\\n};\\n\\nMyStack.prototype.push = function(x) {\\n    this.stack.push(x);\\n};\\n\\nMyStack.prototype.pop = function() {\\n    if (this.stack.length === 0) {\\n        return null; // Or throw an error, as popping from an empty stack is undefined behavior\\n    }\\n    return this.stack.pop();\\n};\\n\\nMyStack.prototype.top = function() {\\n    if (this.stack.length === 0) {\\n        return null; // Or throw an error\\n    }\\n    return this.stack[this.stack.length - 1];\\n};\\n\\nMyStack.prototype.empty = function() {\\n    return this.stack.length === 0;\\n};\\n\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969715,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition, approach, and complexity dicussed in detail in video solution\\nhttps://youtu.be/ytCCqELdJPA\\n\\n# Code\\nC++\\n```\\nclass MyStack {\\nprivate:\\n    queue<int> primary, secondary;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    void push(int x) {\\n        primary.push(x);\\n    }\\n    \\n    int pop() {\\n        while(primary.size() != 1){\\n            secondary.push(primary.front());\\n            primary.pop();\\n        }\\n        int res = primary.front();\\n        primary.pop();\\n        while(!secondary.empty()){\\n            primary.push(secondary.front());\\n            secondary.pop();\\n        }\\n        return res;\\n    }\\n\\n\\n    int top() {\\n        while(primary.size() != 1){\\n            secondary.push(primary.front());\\n            primary.pop();\\n        }\\n        int res = primary.front();\\n        primary.pop();\\n        secondary.push(res);\\n        while(!secondary.empty()){\\n            primary.push(secondary.front());\\n            secondary.pop();\\n        }\\n        return res;\\n    }\\n    \\n    bool empty() {\\n        return primary.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\\nJava\\n```\\nclass MyStack {\\n    private Deque<Integer> primary = null, secondary = null;\\n    public MyStack() {\\n        primary = new ArrayDeque<>();\\n        secondary = new ArrayDeque<>();\\n    }\\n    \\n    public void push(int x) {\\n        primary.offerLast(x);\\n    }\\n    \\n    public int pop() {\\n        while(primary.size() != 1){\\n            secondary.offerLast(primary.pollFirst());\\n        }\\n        int res = primary.pollFirst();\\n        while(!secondary.isEmpty()){\\n            primary.offerLast(secondary.pollFirst());\\n        }\\n        return res;\\n    }\\n    \\n    public int top() {\\n        while(primary.size() != 1){\\n            secondary.offerLast(primary.pollFirst());\\n        }\\n        int res = primary.pollFirst();\\n        secondary.offerLast(res);\\n        while(!secondary.isEmpty()){\\n            primary.offerLast(secondary.pollFirst());\\n        }\\n        return res;\\n    }\\n    \\n    public boolean empty() {\\n        return primary.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\nprivate:\\n    queue<int> primary, secondary;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    void push(int x) {\\n        primary.push(x);\\n    }\\n    \\n    int pop() {\\n        while(primary.size() != 1){\\n            secondary.push(primary.front());\\n            primary.pop();\\n        }\\n        int res = primary.front();\\n        primary.pop();\\n        while(!secondary.empty()){\\n            primary.push(secondary.front());\\n            secondary.pop();\\n        }\\n        return res;\\n    }\\n\\n\\n    int top() {\\n        while(primary.size() != 1){\\n            secondary.push(primary.front());\\n            primary.pop();\\n        }\\n        int res = primary.front();\\n        primary.pop();\\n        secondary.push(res);\\n        while(!secondary.empty()){\\n            primary.push(secondary.front());\\n            secondary.pop();\\n        }\\n        return res;\\n    }\\n    \\n    bool empty() {\\n        return primary.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```\n```\\nclass MyStack {\\n    private Deque<Integer> primary = null, secondary = null;\\n    public MyStack() {\\n        primary = new ArrayDeque<>();\\n        secondary = new ArrayDeque<>();\\n    }\\n    \\n    public void push(int x) {\\n        primary.offerLast(x);\\n    }\\n    \\n    public int pop() {\\n        while(primary.size() != 1){\\n            secondary.offerLast(primary.pollFirst());\\n        }\\n        int res = primary.pollFirst();\\n        while(!secondary.isEmpty()){\\n            primary.offerLast(secondary.pollFirst());\\n        }\\n        return res;\\n    }\\n    \\n    public int top() {\\n        while(primary.size() != 1){\\n            secondary.offerLast(primary.pollFirst());\\n        }\\n        int res = primary.pollFirst();\\n        secondary.offerLast(res);\\n        while(!secondary.isEmpty()){\\n            primary.offerLast(secondary.pollFirst());\\n        }\\n        return res;\\n    }\\n    \\n    public boolean empty() {\\n        return primary.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969698,
                "title": "3-easy-c-solutions-using-1-queue-and-2-queues-beats-100",
                "content": "# Code\\n```\\n// Using 1 queue\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    MyStack() {\\n        \\n    }\\n\\n    void push(int x) {\\n        int sz = q1.size();\\n        q1.push(x);\\n        while(sz--){\\n            q1.push(q1.front());\\n            q1.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n\\n    int top() {\\n        return q1.front();\\n    }\\n\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n\\n// Using 2 queues\\nclass MyStack {\\n    queue<int> q1, q2;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        q1 = q2;\\n        while(!q2.empty())\\n            q2.pop();\\n    }\\n    \\n    int pop() {\\n        int temp = top();\\n        q1.pop();\\n        return temp;\\n    }\\n    \\n    int top() {\\n        if(!q1.empty())\\n            return q1.front();\\n        return -1;\\n    }\\n    \\n    bool empty(){\\n        return q1.empty();\\n    }\\n};\\n\\n// Using 2 queues\\nclass MyStack {\\n    queue<int> q1, q2;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        if(!q1.empty()){\\n            while(q1.size() > 1){\\n                q2.push(q1.front());\\n                q1.pop();\\n            }\\n            int temp = q1.front();\\n            q1.pop();\\n            while(!q2.empty()){\\n                q1.push(q2.front());\\n                q2.pop();\\n            }\\n            return temp;\\n        }\\n        return -1;\\n    }\\n    \\n    int top() {\\n        if(!q1.empty()){\\n            while(q1.size() > 1){\\n                q2.push(q1.front());\\n                q1.pop();\\n            }\\n            int temp = q1.front();\\n            q2.push(temp);\\n            q1.pop();\\n            while(!q2.empty()){\\n                q1.push(q2.front());\\n                q2.pop();\\n            }\\n            return temp;\\n        }\\n        return -1;\\n    }\\n    \\n    bool empty(){\\n        if(q1.size() == 0)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```\\n// Using 1 queue\\nclass MyStack {\\npublic:\\n    queue<int> q1;\\n    MyStack() {\\n        \\n    }\\n\\n    void push(int x) {\\n        int sz = q1.size();\\n        q1.push(x);\\n        while(sz--){\\n            q1.push(q1.front());\\n            q1.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int result = top();\\n        q1.pop();\\n        return result;\\n    }\\n\\n    int top() {\\n        return q1.front();\\n    }\\n\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n\\n\\n// Using 2 queues\\nclass MyStack {\\n    queue<int> q1, q2;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q2.push(x);\\n        while(!q1.empty()){\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        q1 = q2;\\n        while(!q2.empty())\\n            q2.pop();\\n    }\\n    \\n    int pop() {\\n        int temp = top();\\n        q1.pop();\\n        return temp;\\n    }\\n    \\n    int top() {\\n        if(!q1.empty())\\n            return q1.front();\\n        return -1;\\n    }\\n    \\n    bool empty(){\\n        return q1.empty();\\n    }\\n};\\n\\n// Using 2 queues\\nclass MyStack {\\n    queue<int> q1, q2;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        if(!q1.empty()){\\n            while(q1.size() > 1){\\n                q2.push(q1.front());\\n                q1.pop();\\n            }\\n            int temp = q1.front();\\n            q1.pop();\\n            while(!q2.empty()){\\n                q1.push(q2.front());\\n                q2.pop();\\n            }\\n            return temp;\\n        }\\n        return -1;\\n    }\\n    \\n    int top() {\\n        if(!q1.empty()){\\n            while(q1.size() > 1){\\n                q2.push(q1.front());\\n                q1.pop();\\n            }\\n            int temp = q1.front();\\n            q2.push(temp);\\n            q1.pop();\\n            while(!q2.empty()){\\n                q1.push(q2.front());\\n                q2.pop();\\n            }\\n            return temp;\\n        }\\n        return -1;\\n    }\\n    \\n    bool empty(){\\n        if(q1.size() == 0)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969459,
                "title": "daily-leetcoding-challenge-august-day-28",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3921297,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\nqueue<int> q;\\n    MyStack() \\n    {\\n        \\n    }\\n    \\n    void push(int x) \\n    {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() \\n    {\\n        int val=q.front();\\n        q.pop();\\n        return val;\\n    }\\n    \\n    int top() \\n    {\\n        return q.front();\\n    }\\n    \\n    bool empty() \\n    {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\nqueue<int> q;\\n    MyStack() \\n    {\\n        \\n    }\\n    \\n    void push(int x) \\n    {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++)\\n        {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() \\n    {\\n        int val=q.front();\\n        q.pop();\\n        return val;\\n    }\\n    \\n    int top() \\n    {\\n        return q.front();\\n    }\\n    \\n    bool empty() \\n    {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870784,
                "title": "beats-100-simple-easy-to-understand-solution-using-2-queue",
                "content": "\\n\\n# Code\\n```\\nclass MyStack {\\n     Queue<Integer> q1 = new LinkedList<>();\\n     Queue<Integer> q2 = new LinkedList<>();\\n\\n    public MyStack() {\\n        \\n    }\\n    \\n    public void push(int x) {\\n        q1.add(x);\\n        while(!q2.isEmpty()){\\n            q1.add(q2.peek());\\n            q2.remove();\\n        }\\n\\n        Queue<Integer> q = q1;\\n        q1= q2;\\n        q2= q;\\n    }\\n    \\n    public int pop() {\\n        if(q2.isEmpty())\\n            return -1;\\n        return q2.remove();\\n    }\\n    \\n    public int top() {\\n        if(q2.isEmpty())\\n            return -1;\\n       return q2.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return q2.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\n     Queue<Integer> q1 = new LinkedList<>();\\n     Queue<Integer> q2 = new LinkedList<>();\\n\\n    public MyStack() {\\n        \\n    }\\n    \\n    public void push(int x) {\\n        q1.add(x);\\n        while(!q2.isEmpty()){\\n            q1.add(q2.peek());\\n            q2.remove();\\n        }\\n\\n        Queue<Integer> q = q1;\\n        q1= q2;\\n        q2= q;\\n    }\\n    \\n    public int pop() {\\n        if(q2.isEmpty())\\n            return -1;\\n        return q2.remove();\\n    }\\n    \\n    public int top() {\\n        if(q2.isEmpty())\\n            return -1;\\n       return q2.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return q2.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844412,
                "title": "c-solution-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhile pushing elements in queue reverse the order of elements so that q.front() becomes top of the stack\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(size > 0){\\n            q.push(q.front());\\n            q.pop();\\n            size--;\\n        }\\n    }\\n    \\n    int pop() {\\n        int num = q.front();\\n        q.pop();\\n        return num;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(size > 0){\\n            q.push(q.front());\\n            q.pop();\\n            size--;\\n        }\\n    }\\n    \\n    int pop() {\\n        int num = q.front();\\n        q.pop();\\n        return num;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789374,
                "title": "best-java-solution-using-1-queue-only-easy-explanation-beats-100-in-time-and-memory",
                "content": "<!-- # Intuition -->\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAdd elements in a queue then remove size-1 elements from queue and add them again.\\nBelow code is self-explanatory\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\n    Queue<Integer> q1;\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        q1.add(x);\\n        for(int i=0; i<q1.size()-1; i++){\\n            q1.add(q1.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        int removed = q1.remove();\\n        return removed;\\n    }\\n    \\n    public int top() {\\n        int peeked = q1.peek();\\n        return peeked;\\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n\\n\\n//======================Basic Approach=============================\\nclass MyStack {\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        q2.add(x);\\n        while(!q1.isEmpty()){\\n            q2.add(q1.remove());\\n        }\\n        Queue<Integer> temp = q1;\\n        q1 = q2;\\n        q2 = temp;\\n    }\\n    \\n    public int pop() {\\n        int removed = q1.remove();\\n        return removed;\\n    }\\n    \\n    public int top() {\\n        int peeked = q1.peek();\\n        return peeked;\\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\n    Queue<Integer> q1;\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        q1.add(x);\\n        for(int i=0; i<q1.size()-1; i++){\\n            q1.add(q1.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        int removed = q1.remove();\\n        return removed;\\n    }\\n    \\n    public int top() {\\n        int peeked = q1.peek();\\n        return peeked;\\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n\\n\\n//======================Basic Approach=============================\\nclass MyStack {\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n    public MyStack() {\\n        q1 = new LinkedList<>();\\n        q2 = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        q2.add(x);\\n        while(!q1.isEmpty()){\\n            q2.add(q1.remove());\\n        }\\n        Queue<Integer> temp = q1;\\n        q1 = q2;\\n        q2 = temp;\\n    }\\n    \\n    public int pop() {\\n        int removed = q1.remove();\\n        return removed;\\n    }\\n    \\n    public int top() {\\n        int peeked = q1.peek();\\n        return peeked;\\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782862,
                "title": "java-solution-1-queue",
                "content": "# Code\\n```\\nclass MyStack {\\n    Queue<Integer> queue;\\n\\n    public MyStack() {\\n        queue = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        queue.add(x);\\n        for(int i = 1; i < queue.size(); i++) {\\n            queue.add(queue.peek());\\n            queue.remove();\\n        }\\n    }\\n    \\n    public int pop() {\\n        return queue.remove();\\n    }\\n    \\n    public int top() {\\n        return queue.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return queue.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n    Queue<Integer> queue;\\n\\n    public MyStack() {\\n        queue = new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        queue.add(x);\\n        for(int i = 1; i < queue.size(); i++) {\\n            queue.add(queue.peek());\\n            queue.remove();\\n        }\\n    }\\n    \\n    public int pop() {\\n        return queue.remove();\\n    }\\n    \\n    public int top() {\\n        return queue.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return queue.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695113,
                "title": "c-easy-and-clean-code-using-1-queue",
                "content": "# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int sz=q.size();\\n        q.push(x);\\n        while(sz--){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int result=top();\\n        q.pop();\\n        return result;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int sz=q.size();\\n        q.push(x);\\n        while(sz--){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int result=top();\\n        q.pop();\\n        return result;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599737,
                "title": "c-0ms-runtime-2-queues-best-explanation",
                "content": "# Intuition\\nThe idea is to make 2 queues. One primary queue(q1) to store the elements as stack, and one queue(q2) for temporary storage required for some functions.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Initialize two queues q1 and q2 which are the primary queue and the temporary queue reslectively.\\n- For push operation, simply enqueue the number at the back of q1.\\n- For pop operation, move all elements from q1 to q2, except for the last element, which will be the top of the stack. To do this, dequeue elements from q1 and enqueue them into q2 until there is only one element left in q1. Store the required element as topElement. Dequeue the element,then enqueue all the elements from q2 to q1 and dequeue them from q2 to hold the original state. Return topElement.\\n- The top operation is similar to pop operation, the only difference is that we need enqueue the only remaining number to q2 before dequeuing it from q1.\\n- The empty function simpy checks if q1 is empty. If it is empty, it means the stack is empty.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n-O(1) for push,empty\\n -O(n) for pop,top\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n-O(no of calls)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue<int> q1,q2;\\n\\n    void push(int x) {\\n        q1.push(x);\\n    }\\n\\n    int pop() {\\n        while (q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int topElement = q1.front();\\n        q1.pop();\\n        while (!q2.empty()) {\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return topElement;\\n    }\\n\\n    int top() {\\n        while (q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int topElement = q1.front();\\n        q2.push(topElement);\\n        q1.pop();\\n        while (!q2.empty()) {\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return topElement;\\n    }\\n\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue<int> q1,q2;\\n\\n    void push(int x) {\\n        q1.push(x);\\n    }\\n\\n    int pop() {\\n        while (q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int topElement = q1.front();\\n        q1.pop();\\n        while (!q2.empty()) {\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return topElement;\\n    }\\n\\n    int top() {\\n        while (q1.size() > 1) {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        int topElement = q1.front();\\n        q2.push(topElement);\\n        q1.pop();\\n        while (!q2.empty()) {\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return topElement;\\n    }\\n\\n    bool empty() {\\n        return q1.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436445,
                "title": "python-simple-clean-used-only-queue-pop-front-and-push-rear",
                "content": "\\n# Code\\n```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def push(self, x: int) -> None:\\n        size = len(self.queue)\\n        self.queue.append(x)\\n        while size:\\n            self.queue.append(self.top())\\n            self.queue.popleft()\\n            size-=1\\n\\n    def pop(self) -> int:\\n        return self.queue.popleft()\\n\\n    def top(self) -> int:\\n        return self.queue[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue) == 0\\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def push(self, x: int) -> None:\\n        size = len(self.queue)\\n        self.queue.append(x)\\n        while size:\\n            self.queue.append(self.top())\\n            self.queue.popleft()\\n            size-=1\\n\\n    def pop(self) -> int:\\n        return self.queue.popleft()\\n\\n    def top(self) -> int:\\n        return self.queue[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue) == 0\\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407379,
                "title": "one-queue-approach-with-queue-implementation-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s consider a queue with five people: p1, p2, p3, p4, and p5. Our objective is to move p1 to the front of the queue.\\n\\nIf the person at the front of the queue, p5, leaves the queue and then rejoins it, they will have to stand at the back of the queue. So, the new order will be: p5 p1 p2 p3 p4.\\n\\nNow, suppose p4 leaves and rejoins the queue. The new order will be: p4 p5 p1 p2 p3. We repeat this process for all the people in front of p1.\\n\\nEventually, the order will become: p2 p3 p4 p5 p1, and p1 will be at the front of the queue. \\n\\n# Complexity\\n- Time complexity: push: O(N), others: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass MyQueue {\\n    constructor() {\\n        this.items = []\\n    }\\n\\n    enqueue(x) {    \\n        this.items.push(x)\\n    }\\n\\n    dequeue() {\\n        return this.items.shift()\\n    }\\n\\n    peek() {\\n        return this.items[0]\\n    }\\n\\n    isEmpty() {\\n        return this.items.length === 0\\n    }\\n\\n    size() {\\n        return this.items.length\\n    }\\n}\\n\\n\\nclass MyStack {\\n    constructor() {\\n        this.queue = new MyQueue()\\n    }\\n\\n    push(x) {\\n        this.queue.enqueue(x)\\n\\n        let size = this.queue.size()\\n        while(size > 1) {\\n            this.queue.enqueue(this.queue.dequeue())\\n            size--\\n        }\\n    }\\n\\n    pop() {\\n        return this.queue.dequeue()\\n    }\\n\\n    top() {\\n        return this.queue.peek()\\n    }\\n\\n    empty() {\\n        return this.queue.isEmpty()\\n    }\\n}\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass MyQueue {\\n    constructor() {\\n        this.items = []\\n    }\\n\\n    enqueue(x) {    \\n        this.items.push(x)\\n    }\\n\\n    dequeue() {\\n        return this.items.shift()\\n    }\\n\\n    peek() {\\n        return this.items[0]\\n    }\\n\\n    isEmpty() {\\n        return this.items.length === 0\\n    }\\n\\n    size() {\\n        return this.items.length\\n    }\\n}\\n\\n\\nclass MyStack {\\n    constructor() {\\n        this.queue = new MyQueue()\\n    }\\n\\n    push(x) {\\n        this.queue.enqueue(x)\\n\\n        let size = this.queue.size()\\n        while(size > 1) {\\n            this.queue.enqueue(this.queue.dequeue())\\n            size--\\n        }\\n    }\\n\\n    pop() {\\n        return this.queue.dequeue()\\n    }\\n\\n    top() {\\n        return this.queue.peek()\\n    }\\n\\n    empty() {\\n        return this.queue.isEmpty()\\n    }\\n}\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358448,
                "title": "best-c-solution-to-implement-stacks-using-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\npublic:\\n    queue <int> q;\\n    MyStack() {\\n    \\n    }\\n    \\n    void push(int x) {\\n        \\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++){\\n            q.push(q.front());q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int temp = q.front();q.pop();\\n        return temp;\\n    }\\n    \\n    int top() {\\n        return (q.front());\\n    }\\n    \\n    bool empty() {\\n        if(q.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n    queue <int> q;\\n    MyStack() {\\n    \\n    }\\n    \\n    void push(int x) {\\n        \\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++){\\n            q.push(q.front());q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int temp = q.front();q.pop();\\n        return temp;\\n    }\\n    \\n    int top() {\\n        return (q.front());\\n    }\\n    \\n    bool empty() {\\n        if(q.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350600,
                "title": "easy-java-solution-0ms-100",
                "content": "\\n\\n# Code\\n```\\nclass MyStack {\\n\\nQueue<Integer> q1;\\nQueue<Integer> q2;\\n    public MyStack() {\\n        q1 = new ArrayDeque<Integer>();\\n        q2 = new ArrayDeque<Integer>(); \\n    }\\n    \\n    public void push(int x) {\\n        while(!q1.isEmpty()) {\\n            q2.offer(q1.poll());\\n        }\\n\\n        q1.offer(x);\\n\\n        while(!q2.isEmpty()) {\\n            q1.offer(q2.poll());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q1.poll();\\n    }\\n    \\n    public int top() {\\n        return q1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        if(q1.isEmpty()) {\\n            return true;\\n        }\\n        return false; \\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n\\nQueue<Integer> q1;\\nQueue<Integer> q2;\\n    public MyStack() {\\n        q1 = new ArrayDeque<Integer>();\\n        q2 = new ArrayDeque<Integer>(); \\n    }\\n    \\n    public void push(int x) {\\n        while(!q1.isEmpty()) {\\n            q2.offer(q1.poll());\\n        }\\n\\n        q1.offer(x);\\n\\n        while(!q2.isEmpty()) {\\n            q1.offer(q2.poll());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q1.poll();\\n    }\\n    \\n    public int top() {\\n        return q1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        if(q1.isEmpty()) {\\n            return true;\\n        }\\n        return false; \\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327014,
                "title": "0ms-100-faster-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\n    Queue<Integer>q1;\\n    Queue<Integer>q2;\\n    public MyStack() {\\n        q1=new ArrayDeque<>();\\n        q2=new ArrayDeque<>();\\n    }\\n    \\n    public void push(int x) {\\n        while(!q1.isEmpty()){\\n            q2.offer(q1.poll());\\n            \\n        }\\n        q1.offer(x);\\n        while(!q2.isEmpty()){\\n            q1.offer(q2.poll());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q1.poll();\\n    }\\n    \\n    public int top() {\\n        return q1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        if(q1.isEmpty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n    Queue<Integer>q1;\\n    Queue<Integer>q2;\\n    public MyStack() {\\n        q1=new ArrayDeque<>();\\n        q2=new ArrayDeque<>();\\n    }\\n    \\n    public void push(int x) {\\n        while(!q1.isEmpty()){\\n            q2.offer(q1.poll());\\n            \\n        }\\n        q1.offer(x);\\n        while(!q2.isEmpty()){\\n            q1.offer(q2.poll());\\n        }\\n    }\\n    \\n    public int pop() {\\n        return q1.poll();\\n    }\\n    \\n    public int top() {\\n        return q1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        if(q1.isEmpty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321568,
                "title": "java-0ms-two-queue-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will be using to **Two Queue\\'s** in here : **Q1(primary) , Q2(secondary)**.\\n**Push** : Add data to Q1..\\n**Top** : Copy Q1 data to Q2 till only one element left in Q1(ths ur top element) then don\\'t forget to add peek element in Q2 back ,then Swap Q2<->Q1 ..\\n**Pop** : Same as top except Remove the last Element from Q1 and Swap Q2<->Q1..\\n**Empty** : Just Check if Q1 is Empty or not..\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\n    Stack<Integer> stack=new Stack<>();\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n\\n    public MyStack() {\\n        this.q1=new LinkedList<>();\\n        this.q2=new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        q1.add(x);\\n    }\\n    \\n    public int pop() {\\n        while(q1.size()>1){\\n            q2.add(q1.remove());\\n        }\\n        int pop=q1.remove();\\n        Queue<Integer> temp=q1;\\n        q1=q2;\\n        q2=temp;\\n        return pop;\\n    }\\n    \\n    public int top() {\\n        while(q1.size()>1){\\n            q2.add(q1.remove());\\n        }\\n        int top=q1.peek();\\n        q2.add(q1.remove());\\n        Queue<Integer> temp=q1;\\n        q1=q2;\\n        q2=temp;\\n        return top;\\n\\n    }\\n    \\n    public boolean empty() {\\n        if(q1.isEmpty()) return true;\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Design",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\n    Stack<Integer> stack=new Stack<>();\\n    Queue<Integer> q1;\\n    Queue<Integer> q2;\\n\\n    public MyStack() {\\n        this.q1=new LinkedList<>();\\n        this.q2=new LinkedList<>();\\n    }\\n    \\n    public void push(int x) {\\n        q1.add(x);\\n    }\\n    \\n    public int pop() {\\n        while(q1.size()>1){\\n            q2.add(q1.remove());\\n        }\\n        int pop=q1.remove();\\n        Queue<Integer> temp=q1;\\n        q1=q2;\\n        q2=temp;\\n        return pop;\\n    }\\n    \\n    public int top() {\\n        while(q1.size()>1){\\n            q2.add(q1.remove());\\n        }\\n        int top=q1.peek();\\n        q2.add(q1.remove());\\n        Queue<Integer> temp=q1;\\n        q1=q2;\\n        q2=temp;\\n        return top;\\n\\n    }\\n    \\n    public boolean empty() {\\n        if(q1.isEmpty()) return true;\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.top();\\n * boolean param_4 = obj.empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184583,
                "title": "c-cr7-is-better-than-messi",
                "content": "```\\npublic class MyStack {\\n    Queue<int> q1;\\n    Queue<int> q2;\\n    public MyStack() {\\n        q1=new();\\n        q2=new();\\n    }\\n    \\n    public void Push(int x) {\\n        while(q1.Count>0){\\n            q2.Enqueue(q1.Dequeue());\\n        }\\n        q1.Enqueue(x);\\n        while(q2.Count>0){\\n            q1.Enqueue(q2.Dequeue());\\n        }\\n    }\\n    \\n    public int Pop() {\\n        return q1.Dequeue();\\n    }\\n    \\n    public int Top() {\\n        return q1.Peek();\\n    }\\n    \\n    public bool Empty() {\\n        return q1.Count==0;\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.Push(x);\\n * int param_2 = obj.Pop();\\n * int param_3 = obj.Top();\\n * bool param_4 = obj.Empty();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MyStack {\\n    Queue<int> q1;\\n    Queue<int> q2;\\n    public MyStack() {\\n        q1=new();\\n        q2=new();\\n    }\\n    \\n    public void Push(int x) {\\n        while(q1.Count>0){\\n            q2.Enqueue(q1.Dequeue());\\n        }\\n        q1.Enqueue(x);\\n        while(q2.Count>0){\\n            q1.Enqueue(q2.Dequeue());\\n        }\\n    }\\n    \\n    public int Pop() {\\n        return q1.Dequeue();\\n    }\\n    \\n    public int Top() {\\n        return q1.Peek();\\n    }\\n    \\n    public bool Empty() {\\n        return q1.Count==0;\\n    }\\n}\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack obj = new MyStack();\\n * obj.Push(x);\\n * int param_2 = obj.Pop();\\n * int param_3 = obj.Top();\\n * bool param_4 = obj.Empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168876,
                "title": "implement-stack-using-queue-beats-77-66",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\n    queue<int> q1,q2;\\npublic:\\n    \\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        if (q1.empty())\\n        return -1;\\n        int i;\\n        int temp=q1.back();\\n        while (i<q1.size()-1)\\n        {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        q1.pop();\\n        while (!q2.empty())\\n        {\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return temp;\\n    }\\n    \\n    int top() {\\n        return q1.back();\\n    }\\n    \\n    bool empty() {\\n        if(q1.empty())\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\n    queue<int> q1,q2;\\npublic:\\n    \\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n        if (q1.empty())\\n        return -1;\\n        int i;\\n        int temp=q1.back();\\n        while (i<q1.size()-1)\\n        {\\n            q2.push(q1.front());\\n            q1.pop();\\n        }\\n        q1.pop();\\n        while (!q2.empty())\\n        {\\n            q1.push(q2.front());\\n            q2.pop();\\n        }\\n        return temp;\\n    }\\n    \\n    int top() {\\n        return q1.back();\\n    }\\n    \\n    bool empty() {\\n        if(q1.empty())\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157179,
                "title": "c-solution-0ms-run-time-100-beat-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\nqueue<int> q1,q2;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n//In this we put the element of the q1 to the q2 but not the last element of the q1.\\n        if(q1.empty())return -1;\\n        int el=q1.back();\\n        int i=0;\\n        while(i<q1.size()-1){\\n                q2.push(q1.front());\\n            \\n            q1.pop();\\n        }\\n        q1.pop();\\n       while(!q2.empty()){\\n           q1.push(q2.front());\\n           q2.pop();\\n       }\\n        return el;\\n    }\\n    \\n    int top() {\\n        return q1.back();\\n    }\\n    \\n    bool empty() {\\n        if(q1.empty()) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\nqueue<int> q1,q2;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n    }\\n    \\n    int pop() {\\n//In this we put the element of the q1 to the q2 but not the last element of the q1.\\n        if(q1.empty())return -1;\\n        int el=q1.back();\\n        int i=0;\\n        while(i<q1.size()-1){\\n                q2.push(q1.front());\\n            \\n            q1.pop();\\n        }\\n        q1.pop();\\n       while(!q2.empty()){\\n           q1.push(q2.front());\\n           q2.pop();\\n       }\\n        return el;\\n    }\\n    \\n    int top() {\\n        return q1.back();\\n    }\\n    \\n    bool empty() {\\n        if(q1.empty()) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157155,
                "title": "100-beat-zero-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyStack {\\n    queue<int>q,q1;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n    }\\n    \\n    int pop() {\\n        int i=0;\\n        while(i<q.size()-1){\\n            q1.push(q.front());\\n            q.pop();\\n        }\\n        int x=q.front();\\n        q.pop();\\n        while(!q1.empty()){\\n            q.push(q1.front());\\n            q1.pop();\\n        }\\n        return x;\\n    }\\n    \\n    int top() {\\n        // while(!q.empty()){\\n        //     q1.push(q.front());\\n        //     q.pop();\\n        // }\\n        // int x=q1.front();\\n        \\n        // while(!q1.empty()){\\n        //     q.push(q1.front());\\n        //     q1.pop();\\n        // }\\n        return q.back();\\n    }\\n    \\n    bool empty() {\\n        if(q.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyStack {\\n    queue<int>q,q1;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n    }\\n    \\n    int pop() {\\n        int i=0;\\n        while(i<q.size()-1){\\n            q1.push(q.front());\\n            q.pop();\\n        }\\n        int x=q.front();\\n        q.pop();\\n        while(!q1.empty()){\\n            q.push(q1.front());\\n            q1.pop();\\n        }\\n        return x;\\n    }\\n    \\n    int top() {\\n        // while(!q.empty()){\\n        //     q1.push(q.front());\\n        //     q.pop();\\n        // }\\n        // int x=q1.front();\\n        \\n        // while(!q1.empty()){\\n        //     q.push(q1.front());\\n        //     q1.pop();\\n        // }\\n        return q.back();\\n    }\\n    \\n    bool empty() {\\n        if(q.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112400,
                "title": "using-a-single-queue",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nPush : O(n)\\nPop : O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), since we have used a queue to implement the stack.\\n\\n# Code\\n```\\nclass MyStack {\\n\\n    // using a Single queue\\n\\n    Queue<Integer> q1 = new LinkedList<Integer>();\\n\\n    public MyStack() {\\n        \\n    }\\n    \\n\\n    public void push(int x) {\\n        \\n        //push the element\\n        q1.add(x);\\n\\n        //start pushing all the previous elements again to to the top\\n        for(int i = 0;i < q1.size() - 1; i++){\\n            q1.add(q1.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(q1.isEmpty())\\n        return -1;\\n        else\\n        return q1.remove();\\n    }\\n    \\n    public int top() {\\n        return q1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MyStack {\\n\\n    // using a Single queue\\n\\n    Queue<Integer> q1 = new LinkedList<Integer>();\\n\\n    public MyStack() {\\n        \\n    }\\n    \\n\\n    public void push(int x) {\\n        \\n        //push the element\\n        q1.add(x);\\n\\n        //start pushing all the previous elements again to to the top\\n        for(int i = 0;i < q1.size() - 1; i++){\\n            q1.add(q1.remove());\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(q1.isEmpty())\\n        return -1;\\n        else\\n        return q1.remove();\\n    }\\n    \\n    public int top() {\\n        return q1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return q1.isEmpty();\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024087,
                "title": "python-beats-80-original-idea",
                "content": "# Approach\\nIdea is to have two queues:\\n- q1 is the queue\\n- q2 is the queue in reverse\\n\\nEach time I push an element (append to the back of the q1), I clear q2 and add the elements of q1 in reverse to q2. This allows me to access the top (rightmost) element of q1 (the element we would access when calling stack.pop()) by using only the built-in functionality of a queue (i.e accessing the leftmost element) by calling q2.popleft().\\n\\n**e.g**\\nq1: 1 2 3 4 5\\nq2: 5 4 3 2 1 \\n\\nI call q2.popleft() to retrieve the rightmost element of q1.\\n\\nAfter popping, I perform the same clearing and reversal back into q1.\\n\\n**e.g**\\nq1: 1 2 3 4 5\\nq2: 5 4 3 2 1\\n\\n**q2.popleft()**\\n\\nq1: 1 2 3 4 5\\nq2: 4 3 2 1\\n\\n**Clear q1**\\nq1: \\nq2: 4 3 2 1 \\n\\n**Re-add elements to q1 in reverse**\\n\\nq1: 1 2 3 4\\nq2: 4 3 2 1 \\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\npush - O(n)\\npop - O(n)\\ntop - O(1)\\nempty = O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) -> 2 queues of length n = 2n = O(n).\\n# Code\\n```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q1 = deque()\\n        self.q2 = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q2.clear()\\n        self.q1.append(x)\\n        for i in range(len(self.q1) - 1,-1,-1):\\n            self.q2.append(self.q1[i])\\n\\n    def pop(self) -> int:\\n        num = self.q2.popleft()\\n        self.q1.clear()\\n        for i in range(len(self.q2) - 1,-1,-1):\\n            self.q1.append(self.q2[i])\\n        return num\\n\\n    def top(self) -> int:\\n        return self.q2[0]\\n\\n    def empty(self) -> bool:\\n        if len(self.q1) == 0:\\n            return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q1 = deque()\\n        self.q2 = deque()\\n\\n    def push(self, x: int) -> None:\\n        self.q2.clear()\\n        self.q1.append(x)\\n        for i in range(len(self.q1) - 1,-1,-1):\\n            self.q2.append(self.q1[i])\\n\\n    def pop(self) -> int:\\n        num = self.q2.popleft()\\n        self.q1.clear()\\n        for i in range(len(self.q2) - 1,-1,-1):\\n            self.q1.append(self.q2[i])\\n        return num\\n\\n    def top(self) -> int:\\n        return self.q2[0]\\n\\n    def empty(self) -> bool:\\n        if len(self.q1) == 0:\\n            return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863528,
                "title": "stack-using-2-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    Push and Top - O(N)\\n    Pop and Empty - O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyQueue {\\n    constructor() { \\n        this.data = [];\\n        this.front = 0;\\n        this.rear = 0;\\n    }\\n    \\n    // Add the \\'element\\' to the rear of the queue\\n    // Time: O(1)\\n    enqueue(element) {\\n        this.data[this.rear] = element;\\n        this.rear++;\\n    }\\n    \\n    isEmpty() {\\n        return this.front == this.rear;\\n    }\\n    \\n    print() {\\n        for(let i = this.front; i < this.rear; ++i)\\n            console.log(this.data[i]);\\n    }\\n    \\n    // Delete the front element and return the deleted element\\n    // Time: O(1)\\n    dequeue() {\\n        if(this.isEmpty()) {\\n            throw new Error(\"Queue Underflow\");\\n        }\\n        let frontElement = this.data[this.front];\\n        this.front++;\\n        return frontElement;\\n    }\\n    \\n    length() {\\n        return this.rear - this.front;    \\n    }\\n    \\n    // Just return the front element\\n    // Time: O(1)\\n    getFront() {\\n        if(this.isEmpty()) {\\n            throw new Error(\"Queue is Empty!\");\\n        }\\n        return this.data[this.front];\\n    }\\n}\\n\\nvar MyStack = function() {\\n    this.q1 = new MyQueue();\\n    this.q2 = new MyQueue();\\n    this.length = 0; \\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMyStack.prototype.push = function(x) {\\n    this.q1.enqueue(x);\\n    this.length++;\\n};\\n\\n/**\\n * @return {number}\\n */\\nMyStack.prototype.pop = function() {\\n    // Transfer N - 1 elements from Q1 to Q2.\\n    for(let i = 0; i < this.length - 1; ++i)\\n        this.q2.enqueue(this.q1.dequeue());\\n\\n    // Delete the last remaining element.\\n    let poppedElement = this.q1.dequeue();\\n\\n    // Transfer back the elements from Q2 to Q1.\\n    while(!this.q2.isEmpty())\\n        this.q1.enqueue(this.q2.dequeue());\\n\\n    // Decrement length by 1\\n    this.length--;\\n\\n    return poppedElement;\\n};\\n\\n/**\\n * @return {number}\\n */\\nMyStack.prototype.top = function() {\\n    // Transfer N - 1 elements from Q1 to Q2.\\n    for(let i = 0; i < this.length - 1; ++i)\\n        this.q2.enqueue(this.q1.dequeue());\\n\\n    // Get the last remaining element.\\n    let topElement = this.q1.dequeue();\\n\\n    // Transfer back the elements from Q2 to Q1.\\n    while(!this.q2.isEmpty())\\n        this.q1.enqueue(this.q2.dequeue());\\n\\n    // Enqueue the last remaining element again.\\n    this.q1.enqueue(topElement);\\n\\n    return topElement;\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nMyStack.prototype.empty = function() {\\n    return this.length == 0;\\n};\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass MyQueue {\\n    constructor() { \\n        this.data = [];\\n        this.front = 0;\\n        this.rear = 0;\\n    }\\n    \\n    // Add the \\'element\\' to the rear of the queue\\n    // Time: O(1)\\n    enqueue(element) {\\n        this.data[this.rear] = element;\\n        this.rear++;\\n    }\\n    \\n    isEmpty() {\\n        return this.front == this.rear;\\n    }\\n    \\n    print() {\\n        for(let i = this.front; i < this.rear; ++i)\\n            console.log(this.data[i]);\\n    }\\n    \\n    // Delete the front element and return the deleted element\\n    // Time: O(1)\\n    dequeue() {\\n        if(this.isEmpty()) {\\n            throw new Error(\"Queue Underflow\");\\n        }\\n        let frontElement = this.data[this.front];\\n        this.front++;\\n        return frontElement;\\n    }\\n    \\n    length() {\\n        return this.rear - this.front;    \\n    }\\n    \\n    // Just return the front element\\n    // Time: O(1)\\n    getFront() {\\n        if(this.isEmpty()) {\\n            throw new Error(\"Queue is Empty!\");\\n        }\\n        return this.data[this.front];\\n    }\\n}\\n\\nvar MyStack = function() {\\n    this.q1 = new MyQueue();\\n    this.q2 = new MyQueue();\\n    this.length = 0; \\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMyStack.prototype.push = function(x) {\\n    this.q1.enqueue(x);\\n    this.length++;\\n};\\n\\n/**\\n * @return {number}\\n */\\nMyStack.prototype.pop = function() {\\n    // Transfer N - 1 elements from Q1 to Q2.\\n    for(let i = 0; i < this.length - 1; ++i)\\n        this.q2.enqueue(this.q1.dequeue());\\n\\n    // Delete the last remaining element.\\n    let poppedElement = this.q1.dequeue();\\n\\n    // Transfer back the elements from Q2 to Q1.\\n    while(!this.q2.isEmpty())\\n        this.q1.enqueue(this.q2.dequeue());\\n\\n    // Decrement length by 1\\n    this.length--;\\n\\n    return poppedElement;\\n};\\n\\n/**\\n * @return {number}\\n */\\nMyStack.prototype.top = function() {\\n    // Transfer N - 1 elements from Q1 to Q2.\\n    for(let i = 0; i < this.length - 1; ++i)\\n        this.q2.enqueue(this.q1.dequeue());\\n\\n    // Get the last remaining element.\\n    let topElement = this.q1.dequeue();\\n\\n    // Transfer back the elements from Q2 to Q1.\\n    while(!this.q2.isEmpty())\\n        this.q1.enqueue(this.q2.dequeue());\\n\\n    // Enqueue the last remaining element again.\\n    this.q1.enqueue(topElement);\\n\\n    return topElement;\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nMyStack.prototype.empty = function() {\\n    return this.length == 0;\\n};\\n\\n/** \\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847866,
                "title": "simple-solution-using-mutablelist",
                "content": "# Intuition\\nuse methods of mutableList\\n\\n# Approach\\nInitialise a list as part of stack constructor. For each method leverage list operations.\\n\\n# Complexity\\n- Time complexity:\\nO(1) time\\n\\n- Space complexity:\\nO(n) where n depends on number of push operations\\n\\n# Code\\n```\\nclass MyStack() {\\n\\n    fun push(x: Int) {\\n        list.add(x)\\n    }\\n\\n    fun pop(): Int {\\n   return list.removeAt(list.size-1)\\n    }\\n\\n    fun top(): Int {\\n    return list.get(list.size-1)\\n    }\\n\\n    fun empty(): Boolean {\\n    return list.isEmpty()\\n    }\\n\\n    val list:MutableList<Int> = mutableListOf()\\n}\\n\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * var obj = MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass MyStack() {\\n\\n    fun push(x: Int) {\\n        list.add(x)\\n    }\\n\\n    fun pop(): Int {\\n   return list.removeAt(list.size-1)\\n    }\\n\\n    fun top(): Int {\\n    return list.get(list.size-1)\\n    }\\n\\n    fun empty(): Boolean {\\n    return list.isEmpty()\\n    }\\n\\n    val list:MutableList<Int> = mutableListOf()\\n}\\n\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * var obj = MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840596,
                "title": "c-single-queue-solution-100-fastest-solution",
                "content": "```\\nclass MyStack {\\npublic:\\n      queue<int>q;\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int temp = q.front();\\n        q.pop();\\n        return temp;\\n    }\\n    \\n    int top() {\\n        int temp=q.front();\\n        return temp;\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass MyStack {\\npublic:\\n      queue<int>q;\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0;i<q.size()-1;i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int temp = q.front();\\n        q.pop();\\n        return temp;\\n    }\\n    \\n    int top() {\\n        int temp=q.front();\\n        return temp;\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748946,
                "title": "simple-python-solution",
                "content": "# Code\\n```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n        \\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n\\n        for _ in range(len(self.q)-1):\\n            self.q.append(self.q.popleft())\\n        \\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n        \\n\\n    def top(self) -> int:\\n        return self.q[0]\\n        \\n\\n    def empty(self) -> bool:\\n        return not len(self.q)\\n        \\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n        \\n\\n    def push(self, x: int) -> None:\\n        self.q.append(x)\\n\\n        for _ in range(len(self.q)-1):\\n            self.q.append(self.q.popleft())\\n        \\n\\n    def pop(self) -> int:\\n        return self.q.popleft()\\n        \\n\\n    def top(self) -> int:\\n        return self.q[0]\\n        \\n\\n    def empty(self) -> bool:\\n        return not len(self.q)\\n        \\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2033501,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1576449,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1565226,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 2033476,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1572256,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1569033,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1566717,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 2033560,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 2033527,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1569034,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 2033501,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1576449,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1565226,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 2033476,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1572256,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1569033,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1566717,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 2033560,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 2033527,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1569034,
                "content": [
                    {
                        "username": "PolYarik",
                        "content": "This question made me upset...\\nBut I don\\'t want you to feel the same, so here are some **AI-generated jokes** for you!\\n\\n1. Why did the LeetCode coder refuse to go on a date?\\nAnswer: _Because they were busy solving problems and didn\\'t have time for a relationship!_\\n2. Why did the LeetCode coder get lost in the forest?\\nAnswer: _Because they were trying to find the shortest path!_\\n3. Why did the LeetCode coder go to the doctor?\\nAnswer: _Because they had a case of recursive thinking!_"
                    },
                    {
                        "username": "truefuego",
                        "content": "AI is getting too personal bruv."
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@AaronCodes](/AaronCodes) Because it is too real? ;(\nHehe..."
                    },
                    {
                        "username": "AaronCodes",
                        "content": "1st one isn\\'t even a  joke :("
                    },
                    {
                        "username": "stevePerry36",
                        "content": "These problems should try to teach and/or exercise useful techniques. This does the neither. If anything, it does the opposite."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "I found that almost all solutions are either push time complexity is O(n) every time, or pop time complexity is  O(n) every time.\\n\\nI wunder is there a faster solution that requires less time complexity in average?"
                    },
                    {
                        "username": "meliodasmc",
                        "content": "we can to do this with pointers and alls operations in O(1)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "[@kiart-tantasi](/kiart-tantasi) We should only access queue ops, we cannot deque from back or enque to front!"
                    },
                    {
                        "username": "kiart-tantasi",
                        "content": "linked list so it is o(1) ?"
                    },
                    {
                        "username": "yuzisserman",
                        "content": "wonder with o"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Reported for spam"
                    },
                    {
                        "username": "chrisgriffin",
                        "content": "[@AdityaBhate](/AdityaBhate) Although I appreciate your post, please don\\'t spam your link in each comment if it doesn\\'t answer the OP\\'s question."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "z3eg",
                        "content": "tomorrow problem of the day: implement set using lists. "
                    },
                    {
                        "username": "ALZ113",
                        "content": "Lets See\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A way to implement set is hashSet.\nA way to implement hashSet is hashFunction+List+CollisionsOffsets.\n\nIts not like this crazy reduction today only usefull for prooving computability with each other^^.\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "hey, how do you know that?"
                    },
                    {
                        "username": "jl4930",
                        "content": "Too Simple, A little bit naive."
                    },
                    {
                        "username": "TH0OO",
                        "content": "This question is weird.\\nUsing queue to implement stack. What's the point?\\nWhy not just use array?\\nIt's like training a fish to run, training a dog to swim...so awkward."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "It is kinda going out from your \"comfort zone\". You try to think out of box."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/implement-stack-using-queues/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\n\n  \n**Approach 2:** (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n**Approach 3:** (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Can use priority_queue? or deque?  That's an exercise to practice queue & stack!  Another one\n[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) "
                    },
                    {
                        "username": "psionl0",
                        "content": "Implementing a queue using stacks is a useful exercise. It even has an amortized O(1) run time. This problem, not so much."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@wafsinc](/wafsinc) Using pq push & pop need O(log n) time. Using 1 queue or 2 queues one needs TC for push & pop O(n), O(1) (or O(1), O(n)). Just try different data structures "
                    },
                    {
                        "username": "wafsinc",
                        "content": "Why would you want to use a priority queue in this question? Makes literally 0 sense."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "no.. use queue"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Let this be a Stack week, so that i can revise Stacks.\nBy the way, we can also implement stack with one queue."
                    },
                    {
                        "username": "peilin",
                        "content": "Hi all, my code was in Java and I encountered the problem of cannot finding the top() in line 26. And I just copied the java solution posted already, and they cannot be accepted because of the same problem. Is there a possibility that the online judgement of java solution is wrong?"
                    }
                ]
            },
            {
                "id": 1569032,
                "content": [
                    {
                        "username": "justhere4fun",
                        "content": "Error I'm getting : \"Line 15: void value not ignored as it ought to be\"\\nI wrote \"return q.pop()\" for pop function which asks to return int but judge says it should be void. When I use void then another error code occurs where it asks to return something. Errors contradict themselves."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(--size >= 0) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = q.front();\\n        q.pop();\\n        return ret;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "it should be m>1 ig instead of m>=0...\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int m = q.size();\\n        while(m>1){\\n            m--;\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I used stack .. yes I cheated , But it felt right\\uD83D\\uDE36\\uD83D\\uDE36"
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "This question isn\\'t great as there\\'s no way to enforce the use of two queues in the implementation. The follow-up question is trivial to solve in python."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "The issue is the question is asking for a specific implementation but the evaluation does not have any way of enforcing the implementation. There is a disparity between the question requirements and the evaluation method. It\\'s a good question but not suited for LeetCode which prioritises runtime and memory efficiency."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is very easy to cheat. In fact, if the editorial is unlocked LeetCode actually provides a ``COPY`` button with their solution so you don\\'t even have to select the text!\\n\\nBut if you do, the person you are really cheating is yourself."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "There is not really much of a point for them to try and enforce this. There is also nothing they can do to stop you from steeling code from another submission, or from a posted solution, or from the editorial. Unless you are complaining because you are concerned your solution may have accidently used more queues than you intended to, and therefore you didn\\'t actually solve the problem despite thinking you did. \\n\\nIf that is the issue, then sure, it sucks that they cannot automatically let you know that you in fact did only use 2 or fewer Queues. But I dont think that is the issue. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time"
                    },
                    {
                        "username": "omgupta4510",
                        "content": "[\"MyStack\",\"push\",\"pop\",\"empty\"]\\n[[],[1],[],[]] \\noutput of this testcase should be  \\n[null,null,1,true] ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Correct."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Simply use of front() ,push() & empty() functions of queue "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "I asked Barbie what her thoughts were on my solution, here were her thoughts: \\n\\n\"Hey there! First of all, great job on taking on this challenge - implementing a stack using two queues is a neat exercise in data structures. I\\'ve looked over your code, and it looks solid. A few thoughts:\\n\\nEfficiency: The pop and top operations are  O(n), where n is the number of elements in the stack. This might be okay for some scenarios, but if we frequently use these operations, there could be a performance hit.\\n\\nSimplicity: Your approach is straightforward, and I appreciate that you\\'ve separated the roles of the two queues. One always receives new elements, while the other serves as a temporary storage. This makes the logic easier to follow.\\n\\nRefactor Opportunity: There\\'s some duplicated code in the pop and top methods. Maybe you could find a way to refactor and make the code DRY (Don\\'t Repeat Yourself)?\\n\\nComments: It\\'s always a good practice to comment on the more complex parts of the code. You did some of that, but adding a bit more explanation might make it even clearer for someone new to the concept.\\n\\nKeep up the excellent work! Remember, it\\'s not just about getting the solution right; it\\'s also about continuous learning and improvement. You can do it! \\uD83D\\uDCA1\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F\""
                    },
                    {
                        "username": "neizod",
                        "content": "This is the most unnatural problem setting I\\'ve ever seen. Normally, stack is the most basic data structure to use as a basic building block for devising other complex (but useful) data structure. However, this problem ask the reversed! Not only that, the optimal solution cannot be optimized to be better $O(n)$. Just why designed this problem the way it is??????"
                    },
                    {
                        "username": "parvez_7825",
                        "content": "help me to debug this code\\n\\nclass MyStack {\\npublic:\\nqueue<int>q;\\nvoid ins(int& x){\\n    if(q.size()==0){\\n        q.push(x);\\n        return ;\\n    }\\n    int num=q.front();\\n    q.pop();\\n    ins(x);\\n    q.push(num);\\n}\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        ins(x);\\n    }\\n    \\n    int pop() {\\n       int ans=q.front();\\n       q.pop();\\n       return ans;\\n    }\\n    \\n    int top() {      \\n         return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n its failing for the test case\\n[\"MyStack\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"empty\"]\\n[[],[1],[2],[3],[],[],[],[]]"
                    }
                ]
            },
            {
                "id": 1665760,
                "content": [
                    {
                        "username": "justhere4fun",
                        "content": "Error I'm getting : \"Line 15: void value not ignored as it ought to be\"\\nI wrote \"return q.pop()\" for pop function which asks to return int but judge says it should be void. When I use void then another error code occurs where it asks to return something. Errors contradict themselves."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(--size >= 0) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = q.front();\\n        q.pop();\\n        return ret;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "it should be m>1 ig instead of m>=0...\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int m = q.size();\\n        while(m>1){\\n            m--;\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I used stack .. yes I cheated , But it felt right\\uD83D\\uDE36\\uD83D\\uDE36"
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "This question isn\\'t great as there\\'s no way to enforce the use of two queues in the implementation. The follow-up question is trivial to solve in python."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "The issue is the question is asking for a specific implementation but the evaluation does not have any way of enforcing the implementation. There is a disparity between the question requirements and the evaluation method. It\\'s a good question but not suited for LeetCode which prioritises runtime and memory efficiency."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is very easy to cheat. In fact, if the editorial is unlocked LeetCode actually provides a ``COPY`` button with their solution so you don\\'t even have to select the text!\\n\\nBut if you do, the person you are really cheating is yourself."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "There is not really much of a point for them to try and enforce this. There is also nothing they can do to stop you from steeling code from another submission, or from a posted solution, or from the editorial. Unless you are complaining because you are concerned your solution may have accidently used more queues than you intended to, and therefore you didn\\'t actually solve the problem despite thinking you did. \\n\\nIf that is the issue, then sure, it sucks that they cannot automatically let you know that you in fact did only use 2 or fewer Queues. But I dont think that is the issue. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time"
                    },
                    {
                        "username": "omgupta4510",
                        "content": "[\"MyStack\",\"push\",\"pop\",\"empty\"]\\n[[],[1],[],[]] \\noutput of this testcase should be  \\n[null,null,1,true] ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Correct."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Simply use of front() ,push() & empty() functions of queue "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "I asked Barbie what her thoughts were on my solution, here were her thoughts: \\n\\n\"Hey there! First of all, great job on taking on this challenge - implementing a stack using two queues is a neat exercise in data structures. I\\'ve looked over your code, and it looks solid. A few thoughts:\\n\\nEfficiency: The pop and top operations are  O(n), where n is the number of elements in the stack. This might be okay for some scenarios, but if we frequently use these operations, there could be a performance hit.\\n\\nSimplicity: Your approach is straightforward, and I appreciate that you\\'ve separated the roles of the two queues. One always receives new elements, while the other serves as a temporary storage. This makes the logic easier to follow.\\n\\nRefactor Opportunity: There\\'s some duplicated code in the pop and top methods. Maybe you could find a way to refactor and make the code DRY (Don\\'t Repeat Yourself)?\\n\\nComments: It\\'s always a good practice to comment on the more complex parts of the code. You did some of that, but adding a bit more explanation might make it even clearer for someone new to the concept.\\n\\nKeep up the excellent work! Remember, it\\'s not just about getting the solution right; it\\'s also about continuous learning and improvement. You can do it! \\uD83D\\uDCA1\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F\""
                    },
                    {
                        "username": "neizod",
                        "content": "This is the most unnatural problem setting I\\'ve ever seen. Normally, stack is the most basic data structure to use as a basic building block for devising other complex (but useful) data structure. However, this problem ask the reversed! Not only that, the optimal solution cannot be optimized to be better $O(n)$. Just why designed this problem the way it is??????"
                    },
                    {
                        "username": "parvez_7825",
                        "content": "help me to debug this code\\n\\nclass MyStack {\\npublic:\\nqueue<int>q;\\nvoid ins(int& x){\\n    if(q.size()==0){\\n        q.push(x);\\n        return ;\\n    }\\n    int num=q.front();\\n    q.pop();\\n    ins(x);\\n    q.push(num);\\n}\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        ins(x);\\n    }\\n    \\n    int pop() {\\n       int ans=q.front();\\n       q.pop();\\n       return ans;\\n    }\\n    \\n    int top() {      \\n         return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n its failing for the test case\\n[\"MyStack\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"empty\"]\\n[[],[1],[2],[3],[],[],[],[]]"
                    }
                ]
            },
            {
                "id": 2034615,
                "content": [
                    {
                        "username": "justhere4fun",
                        "content": "Error I'm getting : \"Line 15: void value not ignored as it ought to be\"\\nI wrote \"return q.pop()\" for pop function which asks to return int but judge says it should be void. When I use void then another error code occurs where it asks to return something. Errors contradict themselves."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(--size >= 0) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = q.front();\\n        q.pop();\\n        return ret;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "it should be m>1 ig instead of m>=0...\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int m = q.size();\\n        while(m>1){\\n            m--;\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I used stack .. yes I cheated , But it felt right\\uD83D\\uDE36\\uD83D\\uDE36"
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "This question isn\\'t great as there\\'s no way to enforce the use of two queues in the implementation. The follow-up question is trivial to solve in python."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "The issue is the question is asking for a specific implementation but the evaluation does not have any way of enforcing the implementation. There is a disparity between the question requirements and the evaluation method. It\\'s a good question but not suited for LeetCode which prioritises runtime and memory efficiency."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is very easy to cheat. In fact, if the editorial is unlocked LeetCode actually provides a ``COPY`` button with their solution so you don\\'t even have to select the text!\\n\\nBut if you do, the person you are really cheating is yourself."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "There is not really much of a point for them to try and enforce this. There is also nothing they can do to stop you from steeling code from another submission, or from a posted solution, or from the editorial. Unless you are complaining because you are concerned your solution may have accidently used more queues than you intended to, and therefore you didn\\'t actually solve the problem despite thinking you did. \\n\\nIf that is the issue, then sure, it sucks that they cannot automatically let you know that you in fact did only use 2 or fewer Queues. But I dont think that is the issue. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time"
                    },
                    {
                        "username": "omgupta4510",
                        "content": "[\"MyStack\",\"push\",\"pop\",\"empty\"]\\n[[],[1],[],[]] \\noutput of this testcase should be  \\n[null,null,1,true] ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Correct."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Simply use of front() ,push() & empty() functions of queue "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "I asked Barbie what her thoughts were on my solution, here were her thoughts: \\n\\n\"Hey there! First of all, great job on taking on this challenge - implementing a stack using two queues is a neat exercise in data structures. I\\'ve looked over your code, and it looks solid. A few thoughts:\\n\\nEfficiency: The pop and top operations are  O(n), where n is the number of elements in the stack. This might be okay for some scenarios, but if we frequently use these operations, there could be a performance hit.\\n\\nSimplicity: Your approach is straightforward, and I appreciate that you\\'ve separated the roles of the two queues. One always receives new elements, while the other serves as a temporary storage. This makes the logic easier to follow.\\n\\nRefactor Opportunity: There\\'s some duplicated code in the pop and top methods. Maybe you could find a way to refactor and make the code DRY (Don\\'t Repeat Yourself)?\\n\\nComments: It\\'s always a good practice to comment on the more complex parts of the code. You did some of that, but adding a bit more explanation might make it even clearer for someone new to the concept.\\n\\nKeep up the excellent work! Remember, it\\'s not just about getting the solution right; it\\'s also about continuous learning and improvement. You can do it! \\uD83D\\uDCA1\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F\""
                    },
                    {
                        "username": "neizod",
                        "content": "This is the most unnatural problem setting I\\'ve ever seen. Normally, stack is the most basic data structure to use as a basic building block for devising other complex (but useful) data structure. However, this problem ask the reversed! Not only that, the optimal solution cannot be optimized to be better $O(n)$. Just why designed this problem the way it is??????"
                    },
                    {
                        "username": "parvez_7825",
                        "content": "help me to debug this code\\n\\nclass MyStack {\\npublic:\\nqueue<int>q;\\nvoid ins(int& x){\\n    if(q.size()==0){\\n        q.push(x);\\n        return ;\\n    }\\n    int num=q.front();\\n    q.pop();\\n    ins(x);\\n    q.push(num);\\n}\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        ins(x);\\n    }\\n    \\n    int pop() {\\n       int ans=q.front();\\n       q.pop();\\n       return ans;\\n    }\\n    \\n    int top() {      \\n         return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n its failing for the test case\\n[\"MyStack\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"empty\"]\\n[[],[1],[2],[3],[],[],[],[]]"
                    }
                ]
            },
            {
                "id": 2034133,
                "content": [
                    {
                        "username": "justhere4fun",
                        "content": "Error I'm getting : \"Line 15: void value not ignored as it ought to be\"\\nI wrote \"return q.pop()\" for pop function which asks to return int but judge says it should be void. When I use void then another error code occurs where it asks to return something. Errors contradict themselves."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(--size >= 0) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = q.front();\\n        q.pop();\\n        return ret;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "it should be m>1 ig instead of m>=0...\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int m = q.size();\\n        while(m>1){\\n            m--;\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I used stack .. yes I cheated , But it felt right\\uD83D\\uDE36\\uD83D\\uDE36"
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "This question isn\\'t great as there\\'s no way to enforce the use of two queues in the implementation. The follow-up question is trivial to solve in python."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "The issue is the question is asking for a specific implementation but the evaluation does not have any way of enforcing the implementation. There is a disparity between the question requirements and the evaluation method. It\\'s a good question but not suited for LeetCode which prioritises runtime and memory efficiency."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is very easy to cheat. In fact, if the editorial is unlocked LeetCode actually provides a ``COPY`` button with their solution so you don\\'t even have to select the text!\\n\\nBut if you do, the person you are really cheating is yourself."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "There is not really much of a point for them to try and enforce this. There is also nothing they can do to stop you from steeling code from another submission, or from a posted solution, or from the editorial. Unless you are complaining because you are concerned your solution may have accidently used more queues than you intended to, and therefore you didn\\'t actually solve the problem despite thinking you did. \\n\\nIf that is the issue, then sure, it sucks that they cannot automatically let you know that you in fact did only use 2 or fewer Queues. But I dont think that is the issue. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time"
                    },
                    {
                        "username": "omgupta4510",
                        "content": "[\"MyStack\",\"push\",\"pop\",\"empty\"]\\n[[],[1],[],[]] \\noutput of this testcase should be  \\n[null,null,1,true] ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Correct."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Simply use of front() ,push() & empty() functions of queue "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "I asked Barbie what her thoughts were on my solution, here were her thoughts: \\n\\n\"Hey there! First of all, great job on taking on this challenge - implementing a stack using two queues is a neat exercise in data structures. I\\'ve looked over your code, and it looks solid. A few thoughts:\\n\\nEfficiency: The pop and top operations are  O(n), where n is the number of elements in the stack. This might be okay for some scenarios, but if we frequently use these operations, there could be a performance hit.\\n\\nSimplicity: Your approach is straightforward, and I appreciate that you\\'ve separated the roles of the two queues. One always receives new elements, while the other serves as a temporary storage. This makes the logic easier to follow.\\n\\nRefactor Opportunity: There\\'s some duplicated code in the pop and top methods. Maybe you could find a way to refactor and make the code DRY (Don\\'t Repeat Yourself)?\\n\\nComments: It\\'s always a good practice to comment on the more complex parts of the code. You did some of that, but adding a bit more explanation might make it even clearer for someone new to the concept.\\n\\nKeep up the excellent work! Remember, it\\'s not just about getting the solution right; it\\'s also about continuous learning and improvement. You can do it! \\uD83D\\uDCA1\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F\""
                    },
                    {
                        "username": "neizod",
                        "content": "This is the most unnatural problem setting I\\'ve ever seen. Normally, stack is the most basic data structure to use as a basic building block for devising other complex (but useful) data structure. However, this problem ask the reversed! Not only that, the optimal solution cannot be optimized to be better $O(n)$. Just why designed this problem the way it is??????"
                    },
                    {
                        "username": "parvez_7825",
                        "content": "help me to debug this code\\n\\nclass MyStack {\\npublic:\\nqueue<int>q;\\nvoid ins(int& x){\\n    if(q.size()==0){\\n        q.push(x);\\n        return ;\\n    }\\n    int num=q.front();\\n    q.pop();\\n    ins(x);\\n    q.push(num);\\n}\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        ins(x);\\n    }\\n    \\n    int pop() {\\n       int ans=q.front();\\n       q.pop();\\n       return ans;\\n    }\\n    \\n    int top() {      \\n         return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n its failing for the test case\\n[\"MyStack\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"empty\"]\\n[[],[1],[2],[3],[],[],[],[]]"
                    }
                ]
            },
            {
                "id": 2034115,
                "content": [
                    {
                        "username": "justhere4fun",
                        "content": "Error I'm getting : \"Line 15: void value not ignored as it ought to be\"\\nI wrote \"return q.pop()\" for pop function which asks to return int but judge says it should be void. When I use void then another error code occurs where it asks to return something. Errors contradict themselves."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(--size >= 0) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = q.front();\\n        q.pop();\\n        return ret;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "it should be m>1 ig instead of m>=0...\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int m = q.size();\\n        while(m>1){\\n            m--;\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I used stack .. yes I cheated , But it felt right\\uD83D\\uDE36\\uD83D\\uDE36"
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "This question isn\\'t great as there\\'s no way to enforce the use of two queues in the implementation. The follow-up question is trivial to solve in python."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "The issue is the question is asking for a specific implementation but the evaluation does not have any way of enforcing the implementation. There is a disparity between the question requirements and the evaluation method. It\\'s a good question but not suited for LeetCode which prioritises runtime and memory efficiency."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is very easy to cheat. In fact, if the editorial is unlocked LeetCode actually provides a ``COPY`` button with their solution so you don\\'t even have to select the text!\\n\\nBut if you do, the person you are really cheating is yourself."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "There is not really much of a point for them to try and enforce this. There is also nothing they can do to stop you from steeling code from another submission, or from a posted solution, or from the editorial. Unless you are complaining because you are concerned your solution may have accidently used more queues than you intended to, and therefore you didn\\'t actually solve the problem despite thinking you did. \\n\\nIf that is the issue, then sure, it sucks that they cannot automatically let you know that you in fact did only use 2 or fewer Queues. But I dont think that is the issue. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time"
                    },
                    {
                        "username": "omgupta4510",
                        "content": "[\"MyStack\",\"push\",\"pop\",\"empty\"]\\n[[],[1],[],[]] \\noutput of this testcase should be  \\n[null,null,1,true] ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Correct."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Simply use of front() ,push() & empty() functions of queue "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "I asked Barbie what her thoughts were on my solution, here were her thoughts: \\n\\n\"Hey there! First of all, great job on taking on this challenge - implementing a stack using two queues is a neat exercise in data structures. I\\'ve looked over your code, and it looks solid. A few thoughts:\\n\\nEfficiency: The pop and top operations are  O(n), where n is the number of elements in the stack. This might be okay for some scenarios, but if we frequently use these operations, there could be a performance hit.\\n\\nSimplicity: Your approach is straightforward, and I appreciate that you\\'ve separated the roles of the two queues. One always receives new elements, while the other serves as a temporary storage. This makes the logic easier to follow.\\n\\nRefactor Opportunity: There\\'s some duplicated code in the pop and top methods. Maybe you could find a way to refactor and make the code DRY (Don\\'t Repeat Yourself)?\\n\\nComments: It\\'s always a good practice to comment on the more complex parts of the code. You did some of that, but adding a bit more explanation might make it even clearer for someone new to the concept.\\n\\nKeep up the excellent work! Remember, it\\'s not just about getting the solution right; it\\'s also about continuous learning and improvement. You can do it! \\uD83D\\uDCA1\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F\""
                    },
                    {
                        "username": "neizod",
                        "content": "This is the most unnatural problem setting I\\'ve ever seen. Normally, stack is the most basic data structure to use as a basic building block for devising other complex (but useful) data structure. However, this problem ask the reversed! Not only that, the optimal solution cannot be optimized to be better $O(n)$. Just why designed this problem the way it is??????"
                    },
                    {
                        "username": "parvez_7825",
                        "content": "help me to debug this code\\n\\nclass MyStack {\\npublic:\\nqueue<int>q;\\nvoid ins(int& x){\\n    if(q.size()==0){\\n        q.push(x);\\n        return ;\\n    }\\n    int num=q.front();\\n    q.pop();\\n    ins(x);\\n    q.push(num);\\n}\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        ins(x);\\n    }\\n    \\n    int pop() {\\n       int ans=q.front();\\n       q.pop();\\n       return ans;\\n    }\\n    \\n    int top() {      \\n         return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n its failing for the test case\\n[\"MyStack\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"empty\"]\\n[[],[1],[2],[3],[],[],[],[]]"
                    }
                ]
            },
            {
                "id": 1829109,
                "content": [
                    {
                        "username": "justhere4fun",
                        "content": "Error I'm getting : \"Line 15: void value not ignored as it ought to be\"\\nI wrote \"return q.pop()\" for pop function which asks to return int but judge says it should be void. When I use void then another error code occurs where it asks to return something. Errors contradict themselves."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(--size >= 0) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = q.front();\\n        q.pop();\\n        return ret;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "it should be m>1 ig instead of m>=0...\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int m = q.size();\\n        while(m>1){\\n            m--;\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I used stack .. yes I cheated , But it felt right\\uD83D\\uDE36\\uD83D\\uDE36"
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "This question isn\\'t great as there\\'s no way to enforce the use of two queues in the implementation. The follow-up question is trivial to solve in python."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "The issue is the question is asking for a specific implementation but the evaluation does not have any way of enforcing the implementation. There is a disparity between the question requirements and the evaluation method. It\\'s a good question but not suited for LeetCode which prioritises runtime and memory efficiency."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is very easy to cheat. In fact, if the editorial is unlocked LeetCode actually provides a ``COPY`` button with their solution so you don\\'t even have to select the text!\\n\\nBut if you do, the person you are really cheating is yourself."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "There is not really much of a point for them to try and enforce this. There is also nothing they can do to stop you from steeling code from another submission, or from a posted solution, or from the editorial. Unless you are complaining because you are concerned your solution may have accidently used more queues than you intended to, and therefore you didn\\'t actually solve the problem despite thinking you did. \\n\\nIf that is the issue, then sure, it sucks that they cannot automatically let you know that you in fact did only use 2 or fewer Queues. But I dont think that is the issue. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time"
                    },
                    {
                        "username": "omgupta4510",
                        "content": "[\"MyStack\",\"push\",\"pop\",\"empty\"]\\n[[],[1],[],[]] \\noutput of this testcase should be  \\n[null,null,1,true] ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Correct."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Simply use of front() ,push() & empty() functions of queue "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "I asked Barbie what her thoughts were on my solution, here were her thoughts: \\n\\n\"Hey there! First of all, great job on taking on this challenge - implementing a stack using two queues is a neat exercise in data structures. I\\'ve looked over your code, and it looks solid. A few thoughts:\\n\\nEfficiency: The pop and top operations are  O(n), where n is the number of elements in the stack. This might be okay for some scenarios, but if we frequently use these operations, there could be a performance hit.\\n\\nSimplicity: Your approach is straightforward, and I appreciate that you\\'ve separated the roles of the two queues. One always receives new elements, while the other serves as a temporary storage. This makes the logic easier to follow.\\n\\nRefactor Opportunity: There\\'s some duplicated code in the pop and top methods. Maybe you could find a way to refactor and make the code DRY (Don\\'t Repeat Yourself)?\\n\\nComments: It\\'s always a good practice to comment on the more complex parts of the code. You did some of that, but adding a bit more explanation might make it even clearer for someone new to the concept.\\n\\nKeep up the excellent work! Remember, it\\'s not just about getting the solution right; it\\'s also about continuous learning and improvement. You can do it! \\uD83D\\uDCA1\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F\""
                    },
                    {
                        "username": "neizod",
                        "content": "This is the most unnatural problem setting I\\'ve ever seen. Normally, stack is the most basic data structure to use as a basic building block for devising other complex (but useful) data structure. However, this problem ask the reversed! Not only that, the optimal solution cannot be optimized to be better $O(n)$. Just why designed this problem the way it is??????"
                    },
                    {
                        "username": "parvez_7825",
                        "content": "help me to debug this code\\n\\nclass MyStack {\\npublic:\\nqueue<int>q;\\nvoid ins(int& x){\\n    if(q.size()==0){\\n        q.push(x);\\n        return ;\\n    }\\n    int num=q.front();\\n    q.pop();\\n    ins(x);\\n    q.push(num);\\n}\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        ins(x);\\n    }\\n    \\n    int pop() {\\n       int ans=q.front();\\n       q.pop();\\n       return ans;\\n    }\\n    \\n    int top() {      \\n         return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n its failing for the test case\\n[\"MyStack\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"empty\"]\\n[[],[1],[2],[3],[],[],[],[]]"
                    }
                ]
            },
            {
                "id": 2034404,
                "content": [
                    {
                        "username": "justhere4fun",
                        "content": "Error I'm getting : \"Line 15: void value not ignored as it ought to be\"\\nI wrote \"return q.pop()\" for pop function which asks to return int but judge says it should be void. When I use void then another error code occurs where it asks to return something. Errors contradict themselves."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(--size >= 0) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = q.front();\\n        q.pop();\\n        return ret;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "it should be m>1 ig instead of m>=0...\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int m = q.size();\\n        while(m>1){\\n            m--;\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I used stack .. yes I cheated , But it felt right\\uD83D\\uDE36\\uD83D\\uDE36"
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "This question isn\\'t great as there\\'s no way to enforce the use of two queues in the implementation. The follow-up question is trivial to solve in python."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "The issue is the question is asking for a specific implementation but the evaluation does not have any way of enforcing the implementation. There is a disparity between the question requirements and the evaluation method. It\\'s a good question but not suited for LeetCode which prioritises runtime and memory efficiency."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is very easy to cheat. In fact, if the editorial is unlocked LeetCode actually provides a ``COPY`` button with their solution so you don\\'t even have to select the text!\\n\\nBut if you do, the person you are really cheating is yourself."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "There is not really much of a point for them to try and enforce this. There is also nothing they can do to stop you from steeling code from another submission, or from a posted solution, or from the editorial. Unless you are complaining because you are concerned your solution may have accidently used more queues than you intended to, and therefore you didn\\'t actually solve the problem despite thinking you did. \\n\\nIf that is the issue, then sure, it sucks that they cannot automatically let you know that you in fact did only use 2 or fewer Queues. But I dont think that is the issue. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time"
                    },
                    {
                        "username": "omgupta4510",
                        "content": "[\"MyStack\",\"push\",\"pop\",\"empty\"]\\n[[],[1],[],[]] \\noutput of this testcase should be  \\n[null,null,1,true] ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Correct."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Simply use of front() ,push() & empty() functions of queue "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "I asked Barbie what her thoughts were on my solution, here were her thoughts: \\n\\n\"Hey there! First of all, great job on taking on this challenge - implementing a stack using two queues is a neat exercise in data structures. I\\'ve looked over your code, and it looks solid. A few thoughts:\\n\\nEfficiency: The pop and top operations are  O(n), where n is the number of elements in the stack. This might be okay for some scenarios, but if we frequently use these operations, there could be a performance hit.\\n\\nSimplicity: Your approach is straightforward, and I appreciate that you\\'ve separated the roles of the two queues. One always receives new elements, while the other serves as a temporary storage. This makes the logic easier to follow.\\n\\nRefactor Opportunity: There\\'s some duplicated code in the pop and top methods. Maybe you could find a way to refactor and make the code DRY (Don\\'t Repeat Yourself)?\\n\\nComments: It\\'s always a good practice to comment on the more complex parts of the code. You did some of that, but adding a bit more explanation might make it even clearer for someone new to the concept.\\n\\nKeep up the excellent work! Remember, it\\'s not just about getting the solution right; it\\'s also about continuous learning and improvement. You can do it! \\uD83D\\uDCA1\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F\""
                    },
                    {
                        "username": "neizod",
                        "content": "This is the most unnatural problem setting I\\'ve ever seen. Normally, stack is the most basic data structure to use as a basic building block for devising other complex (but useful) data structure. However, this problem ask the reversed! Not only that, the optimal solution cannot be optimized to be better $O(n)$. Just why designed this problem the way it is??????"
                    },
                    {
                        "username": "parvez_7825",
                        "content": "help me to debug this code\\n\\nclass MyStack {\\npublic:\\nqueue<int>q;\\nvoid ins(int& x){\\n    if(q.size()==0){\\n        q.push(x);\\n        return ;\\n    }\\n    int num=q.front();\\n    q.pop();\\n    ins(x);\\n    q.push(num);\\n}\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        ins(x);\\n    }\\n    \\n    int pop() {\\n       int ans=q.front();\\n       q.pop();\\n       return ans;\\n    }\\n    \\n    int top() {      \\n         return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n its failing for the test case\\n[\"MyStack\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"empty\"]\\n[[],[1],[2],[3],[],[],[],[]]"
                    }
                ]
            },
            {
                "id": 2034311,
                "content": [
                    {
                        "username": "justhere4fun",
                        "content": "Error I'm getting : \"Line 15: void value not ignored as it ought to be\"\\nI wrote \"return q.pop()\" for pop function which asks to return int but judge says it should be void. When I use void then another error code occurs where it asks to return something. Errors contradict themselves."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(--size >= 0) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = q.front();\\n        q.pop();\\n        return ret;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "it should be m>1 ig instead of m>=0...\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int m = q.size();\\n        while(m>1){\\n            m--;\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I used stack .. yes I cheated , But it felt right\\uD83D\\uDE36\\uD83D\\uDE36"
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "This question isn\\'t great as there\\'s no way to enforce the use of two queues in the implementation. The follow-up question is trivial to solve in python."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "The issue is the question is asking for a specific implementation but the evaluation does not have any way of enforcing the implementation. There is a disparity between the question requirements and the evaluation method. It\\'s a good question but not suited for LeetCode which prioritises runtime and memory efficiency."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is very easy to cheat. In fact, if the editorial is unlocked LeetCode actually provides a ``COPY`` button with their solution so you don\\'t even have to select the text!\\n\\nBut if you do, the person you are really cheating is yourself."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "There is not really much of a point for them to try and enforce this. There is also nothing they can do to stop you from steeling code from another submission, or from a posted solution, or from the editorial. Unless you are complaining because you are concerned your solution may have accidently used more queues than you intended to, and therefore you didn\\'t actually solve the problem despite thinking you did. \\n\\nIf that is the issue, then sure, it sucks that they cannot automatically let you know that you in fact did only use 2 or fewer Queues. But I dont think that is the issue. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time"
                    },
                    {
                        "username": "omgupta4510",
                        "content": "[\"MyStack\",\"push\",\"pop\",\"empty\"]\\n[[],[1],[],[]] \\noutput of this testcase should be  \\n[null,null,1,true] ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Correct."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Simply use of front() ,push() & empty() functions of queue "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "I asked Barbie what her thoughts were on my solution, here were her thoughts: \\n\\n\"Hey there! First of all, great job on taking on this challenge - implementing a stack using two queues is a neat exercise in data structures. I\\'ve looked over your code, and it looks solid. A few thoughts:\\n\\nEfficiency: The pop and top operations are  O(n), where n is the number of elements in the stack. This might be okay for some scenarios, but if we frequently use these operations, there could be a performance hit.\\n\\nSimplicity: Your approach is straightforward, and I appreciate that you\\'ve separated the roles of the two queues. One always receives new elements, while the other serves as a temporary storage. This makes the logic easier to follow.\\n\\nRefactor Opportunity: There\\'s some duplicated code in the pop and top methods. Maybe you could find a way to refactor and make the code DRY (Don\\'t Repeat Yourself)?\\n\\nComments: It\\'s always a good practice to comment on the more complex parts of the code. You did some of that, but adding a bit more explanation might make it even clearer for someone new to the concept.\\n\\nKeep up the excellent work! Remember, it\\'s not just about getting the solution right; it\\'s also about continuous learning and improvement. You can do it! \\uD83D\\uDCA1\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F\""
                    },
                    {
                        "username": "neizod",
                        "content": "This is the most unnatural problem setting I\\'ve ever seen. Normally, stack is the most basic data structure to use as a basic building block for devising other complex (but useful) data structure. However, this problem ask the reversed! Not only that, the optimal solution cannot be optimized to be better $O(n)$. Just why designed this problem the way it is??????"
                    },
                    {
                        "username": "parvez_7825",
                        "content": "help me to debug this code\\n\\nclass MyStack {\\npublic:\\nqueue<int>q;\\nvoid ins(int& x){\\n    if(q.size()==0){\\n        q.push(x);\\n        return ;\\n    }\\n    int num=q.front();\\n    q.pop();\\n    ins(x);\\n    q.push(num);\\n}\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        ins(x);\\n    }\\n    \\n    int pop() {\\n       int ans=q.front();\\n       q.pop();\\n       return ans;\\n    }\\n    \\n    int top() {      \\n         return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n its failing for the test case\\n[\"MyStack\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"empty\"]\\n[[],[1],[2],[3],[],[],[],[]]"
                    }
                ]
            },
            {
                "id": 2034281,
                "content": [
                    {
                        "username": "justhere4fun",
                        "content": "Error I'm getting : \"Line 15: void value not ignored as it ought to be\"\\nI wrote \"return q.pop()\" for pop function which asks to return int but judge says it should be void. When I use void then another error code occurs where it asks to return something. Errors contradict themselves."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(--size >= 0) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = q.front();\\n        q.pop();\\n        return ret;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "it should be m>1 ig instead of m>=0...\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int m = q.size();\\n        while(m>1){\\n            m--;\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I used stack .. yes I cheated , But it felt right\\uD83D\\uDE36\\uD83D\\uDE36"
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "This question isn\\'t great as there\\'s no way to enforce the use of two queues in the implementation. The follow-up question is trivial to solve in python."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "The issue is the question is asking for a specific implementation but the evaluation does not have any way of enforcing the implementation. There is a disparity between the question requirements and the evaluation method. It\\'s a good question but not suited for LeetCode which prioritises runtime and memory efficiency."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is very easy to cheat. In fact, if the editorial is unlocked LeetCode actually provides a ``COPY`` button with their solution so you don\\'t even have to select the text!\\n\\nBut if you do, the person you are really cheating is yourself."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "There is not really much of a point for them to try and enforce this. There is also nothing they can do to stop you from steeling code from another submission, or from a posted solution, or from the editorial. Unless you are complaining because you are concerned your solution may have accidently used more queues than you intended to, and therefore you didn\\'t actually solve the problem despite thinking you did. \\n\\nIf that is the issue, then sure, it sucks that they cannot automatically let you know that you in fact did only use 2 or fewer Queues. But I dont think that is the issue. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time"
                    },
                    {
                        "username": "omgupta4510",
                        "content": "[\"MyStack\",\"push\",\"pop\",\"empty\"]\\n[[],[1],[],[]] \\noutput of this testcase should be  \\n[null,null,1,true] ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Correct."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Simply use of front() ,push() & empty() functions of queue "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "I asked Barbie what her thoughts were on my solution, here were her thoughts: \\n\\n\"Hey there! First of all, great job on taking on this challenge - implementing a stack using two queues is a neat exercise in data structures. I\\'ve looked over your code, and it looks solid. A few thoughts:\\n\\nEfficiency: The pop and top operations are  O(n), where n is the number of elements in the stack. This might be okay for some scenarios, but if we frequently use these operations, there could be a performance hit.\\n\\nSimplicity: Your approach is straightforward, and I appreciate that you\\'ve separated the roles of the two queues. One always receives new elements, while the other serves as a temporary storage. This makes the logic easier to follow.\\n\\nRefactor Opportunity: There\\'s some duplicated code in the pop and top methods. Maybe you could find a way to refactor and make the code DRY (Don\\'t Repeat Yourself)?\\n\\nComments: It\\'s always a good practice to comment on the more complex parts of the code. You did some of that, but adding a bit more explanation might make it even clearer for someone new to the concept.\\n\\nKeep up the excellent work! Remember, it\\'s not just about getting the solution right; it\\'s also about continuous learning and improvement. You can do it! \\uD83D\\uDCA1\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F\""
                    },
                    {
                        "username": "neizod",
                        "content": "This is the most unnatural problem setting I\\'ve ever seen. Normally, stack is the most basic data structure to use as a basic building block for devising other complex (but useful) data structure. However, this problem ask the reversed! Not only that, the optimal solution cannot be optimized to be better $O(n)$. Just why designed this problem the way it is??????"
                    },
                    {
                        "username": "parvez_7825",
                        "content": "help me to debug this code\\n\\nclass MyStack {\\npublic:\\nqueue<int>q;\\nvoid ins(int& x){\\n    if(q.size()==0){\\n        q.push(x);\\n        return ;\\n    }\\n    int num=q.front();\\n    q.pop();\\n    ins(x);\\n    q.push(num);\\n}\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        ins(x);\\n    }\\n    \\n    int pop() {\\n       int ans=q.front();\\n       q.pop();\\n       return ans;\\n    }\\n    \\n    int top() {      \\n         return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n its failing for the test case\\n[\"MyStack\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"empty\"]\\n[[],[1],[2],[3],[],[],[],[]]"
                    }
                ]
            },
            {
                "id": 2034195,
                "content": [
                    {
                        "username": "justhere4fun",
                        "content": "Error I'm getting : \"Line 15: void value not ignored as it ought to be\"\\nI wrote \"return q.pop()\" for pop function which asks to return int but judge says it should be void. When I use void then another error code occurs where it asks to return something. Errors contradict themselves."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int size = q.size();\\n        q.push(x);\\n        \\n        while(--size >= 0) {\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = q.front();\\n        q.pop();\\n        return ret;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */\\n```"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "it should be m>1 ig instead of m>=0...\\nclass MyStack {\\n    queue<int> q;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        int m = q.size();\\n        while(m>1){\\n            m--;\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n        int x = q.front();\\n        q.pop();\\n        return x;\\n    }\\n    \\n    int top() {\\n        return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I used stack .. yes I cheated , But it felt right\\uD83D\\uDE36\\uD83D\\uDE36"
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "This question isn\\'t great as there\\'s no way to enforce the use of two queues in the implementation. The follow-up question is trivial to solve in python."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "The issue is the question is asking for a specific implementation but the evaluation does not have any way of enforcing the implementation. There is a disparity between the question requirements and the evaluation method. It\\'s a good question but not suited for LeetCode which prioritises runtime and memory efficiency."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is very easy to cheat. In fact, if the editorial is unlocked LeetCode actually provides a ``COPY`` button with their solution so you don\\'t even have to select the text!\\n\\nBut if you do, the person you are really cheating is yourself."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "There is not really much of a point for them to try and enforce this. There is also nothing they can do to stop you from steeling code from another submission, or from a posted solution, or from the editorial. Unless you are complaining because you are concerned your solution may have accidently used more queues than you intended to, and therefore you didn\\'t actually solve the problem despite thinking you did. \\n\\nIf that is the issue, then sure, it sucks that they cannot automatically let you know that you in fact did only use 2 or fewer Queues. But I dont think that is the issue. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time"
                    },
                    {
                        "username": "omgupta4510",
                        "content": "[\"MyStack\",\"push\",\"pop\",\"empty\"]\\n[[],[1],[],[]] \\noutput of this testcase should be  \\n[null,null,1,true] ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Correct."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Simply use of front() ,push() & empty() functions of queue "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "I asked Barbie what her thoughts were on my solution, here were her thoughts: \\n\\n\"Hey there! First of all, great job on taking on this challenge - implementing a stack using two queues is a neat exercise in data structures. I\\'ve looked over your code, and it looks solid. A few thoughts:\\n\\nEfficiency: The pop and top operations are  O(n), where n is the number of elements in the stack. This might be okay for some scenarios, but if we frequently use these operations, there could be a performance hit.\\n\\nSimplicity: Your approach is straightforward, and I appreciate that you\\'ve separated the roles of the two queues. One always receives new elements, while the other serves as a temporary storage. This makes the logic easier to follow.\\n\\nRefactor Opportunity: There\\'s some duplicated code in the pop and top methods. Maybe you could find a way to refactor and make the code DRY (Don\\'t Repeat Yourself)?\\n\\nComments: It\\'s always a good practice to comment on the more complex parts of the code. You did some of that, but adding a bit more explanation might make it even clearer for someone new to the concept.\\n\\nKeep up the excellent work! Remember, it\\'s not just about getting the solution right; it\\'s also about continuous learning and improvement. You can do it! \\uD83D\\uDCA1\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F\""
                    },
                    {
                        "username": "neizod",
                        "content": "This is the most unnatural problem setting I\\'ve ever seen. Normally, stack is the most basic data structure to use as a basic building block for devising other complex (but useful) data structure. However, this problem ask the reversed! Not only that, the optimal solution cannot be optimized to be better $O(n)$. Just why designed this problem the way it is??????"
                    },
                    {
                        "username": "parvez_7825",
                        "content": "help me to debug this code\\n\\nclass MyStack {\\npublic:\\nqueue<int>q;\\nvoid ins(int& x){\\n    if(q.size()==0){\\n        q.push(x);\\n        return ;\\n    }\\n    int num=q.front();\\n    q.pop();\\n    ins(x);\\n    q.push(num);\\n}\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        ins(x);\\n    }\\n    \\n    int pop() {\\n       int ans=q.front();\\n       q.pop();\\n       return ans;\\n    }\\n    \\n    int top() {      \\n         return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.size()==0;\\n    }\\n};\\n its failing for the test case\\n[\"MyStack\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"empty\"]\\n[[],[1],[2],[3],[],[],[],[]]"
                    }
                ]
            },
            {
                "id": 2033917,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Wrote an `article + solution` for those who want to learn about Queues and Stacks. \n\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/3970738/simple-lesson-on-queues-and-stacks-and-super-easy-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is such a useless way to implement a stack that I would have skipped this problem if it didn\\'t count towards the monthly total. In fact, I was tempted to just copy and paste the editorial solution. As long as you have access to arrays or linked lists, you will never need to implement a stack this way.\\n\\nI have implemented the solution in C and followed the rules given. The enqueue/dequeue operations are so basic that there is no need to write separate functions for them. https://leetcode.com/submissions/detail/1033800274/\\n\\nThis problem can also be implemented using a single queue. To pop a number, you just need to dequeue and enqueue the numbers repeatedly until you get to the the last number enqueued. For this to work you need to store the number of elements in the queue in a separate variable."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I\\'m not sure what that means. A total noob might get some practice with using queues but other than that, I doubt that they would gain much from this exercise."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Useless for programming but usefull for learning reducing problems and proving computability."
                    },
                    {
                        "username": "WeakProgrammer007",
                        "content": "This can be solved easily using one queue, what is the motive behind two queues?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Easy question and using two is propably often the first idea."
                    },
                    {
                        "username": "__Shahadat__",
                        "content": "100% beats in C++ using deque"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "**Normal person solving this problem**(aam zindagi): \nHave to implement stack using queue how would we do that.\nohhh if we mange to reverse the order of pushing element in queue.\n\n**Whereas Mentos zinadgi:**  implementing stack, ohh Ezzy just use another stack to implement it.\n\n<img src=\"https://i.imgflip.com/7x6dkh.jpg\" >"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*EASY tagged problem atleast looks good*"
                    },
                    {
                        "username": "hucancode",
                        "content": "I can\\'t imagine using a stack that has O(n) push/pop"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is a kind of silly problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@lucasscodes](/lucasscodes) These are not useful nor meaningful reductions since we have full control over the underlying primatives. \\n\\nIn fact in C the first step is create a circular buffer primative to use as a queue by hand which is by itself a easy-medium question.\\n \\nThey should have given us an API that we were required to use, not described one that we were required to create, then the question would have been be more sensible."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "aitachii",
                        "content": "O(n) works. I was expecting some magic trick that can make it O(1)."
                    },
                    {
                        "username": "lsxxc",
                        "content": "I don\\'t get the main point that this question is trying to ask can anyone simplify it "
                    }
                ]
            },
            {
                "id": 2033817,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Wrote an `article + solution` for those who want to learn about Queues and Stacks. \n\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/3970738/simple-lesson-on-queues-and-stacks-and-super-easy-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is such a useless way to implement a stack that I would have skipped this problem if it didn\\'t count towards the monthly total. In fact, I was tempted to just copy and paste the editorial solution. As long as you have access to arrays or linked lists, you will never need to implement a stack this way.\\n\\nI have implemented the solution in C and followed the rules given. The enqueue/dequeue operations are so basic that there is no need to write separate functions for them. https://leetcode.com/submissions/detail/1033800274/\\n\\nThis problem can also be implemented using a single queue. To pop a number, you just need to dequeue and enqueue the numbers repeatedly until you get to the the last number enqueued. For this to work you need to store the number of elements in the queue in a separate variable."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I\\'m not sure what that means. A total noob might get some practice with using queues but other than that, I doubt that they would gain much from this exercise."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Useless for programming but usefull for learning reducing problems and proving computability."
                    },
                    {
                        "username": "WeakProgrammer007",
                        "content": "This can be solved easily using one queue, what is the motive behind two queues?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Easy question and using two is propably often the first idea."
                    },
                    {
                        "username": "__Shahadat__",
                        "content": "100% beats in C++ using deque"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "**Normal person solving this problem**(aam zindagi): \nHave to implement stack using queue how would we do that.\nohhh if we mange to reverse the order of pushing element in queue.\n\n**Whereas Mentos zinadgi:**  implementing stack, ohh Ezzy just use another stack to implement it.\n\n<img src=\"https://i.imgflip.com/7x6dkh.jpg\" >"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*EASY tagged problem atleast looks good*"
                    },
                    {
                        "username": "hucancode",
                        "content": "I can\\'t imagine using a stack that has O(n) push/pop"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is a kind of silly problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@lucasscodes](/lucasscodes) These are not useful nor meaningful reductions since we have full control over the underlying primatives. \\n\\nIn fact in C the first step is create a circular buffer primative to use as a queue by hand which is by itself a easy-medium question.\\n \\nThey should have given us an API that we were required to use, not described one that we were required to create, then the question would have been be more sensible."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "aitachii",
                        "content": "O(n) works. I was expecting some magic trick that can make it O(1)."
                    },
                    {
                        "username": "lsxxc",
                        "content": "I don\\'t get the main point that this question is trying to ask can anyone simplify it "
                    }
                ]
            },
            {
                "id": 2033741,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Wrote an `article + solution` for those who want to learn about Queues and Stacks. \n\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/3970738/simple-lesson-on-queues-and-stacks-and-super-easy-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is such a useless way to implement a stack that I would have skipped this problem if it didn\\'t count towards the monthly total. In fact, I was tempted to just copy and paste the editorial solution. As long as you have access to arrays or linked lists, you will never need to implement a stack this way.\\n\\nI have implemented the solution in C and followed the rules given. The enqueue/dequeue operations are so basic that there is no need to write separate functions for them. https://leetcode.com/submissions/detail/1033800274/\\n\\nThis problem can also be implemented using a single queue. To pop a number, you just need to dequeue and enqueue the numbers repeatedly until you get to the the last number enqueued. For this to work you need to store the number of elements in the queue in a separate variable."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I\\'m not sure what that means. A total noob might get some practice with using queues but other than that, I doubt that they would gain much from this exercise."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Useless for programming but usefull for learning reducing problems and proving computability."
                    },
                    {
                        "username": "WeakProgrammer007",
                        "content": "This can be solved easily using one queue, what is the motive behind two queues?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Easy question and using two is propably often the first idea."
                    },
                    {
                        "username": "__Shahadat__",
                        "content": "100% beats in C++ using deque"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "**Normal person solving this problem**(aam zindagi): \nHave to implement stack using queue how would we do that.\nohhh if we mange to reverse the order of pushing element in queue.\n\n**Whereas Mentos zinadgi:**  implementing stack, ohh Ezzy just use another stack to implement it.\n\n<img src=\"https://i.imgflip.com/7x6dkh.jpg\" >"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*EASY tagged problem atleast looks good*"
                    },
                    {
                        "username": "hucancode",
                        "content": "I can\\'t imagine using a stack that has O(n) push/pop"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is a kind of silly problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@lucasscodes](/lucasscodes) These are not useful nor meaningful reductions since we have full control over the underlying primatives. \\n\\nIn fact in C the first step is create a circular buffer primative to use as a queue by hand which is by itself a easy-medium question.\\n \\nThey should have given us an API that we were required to use, not described one that we were required to create, then the question would have been be more sensible."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "aitachii",
                        "content": "O(n) works. I was expecting some magic trick that can make it O(1)."
                    },
                    {
                        "username": "lsxxc",
                        "content": "I don\\'t get the main point that this question is trying to ask can anyone simplify it "
                    }
                ]
            },
            {
                "id": 2033736,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Wrote an `article + solution` for those who want to learn about Queues and Stacks. \n\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/3970738/simple-lesson-on-queues-and-stacks-and-super-easy-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is such a useless way to implement a stack that I would have skipped this problem if it didn\\'t count towards the monthly total. In fact, I was tempted to just copy and paste the editorial solution. As long as you have access to arrays or linked lists, you will never need to implement a stack this way.\\n\\nI have implemented the solution in C and followed the rules given. The enqueue/dequeue operations are so basic that there is no need to write separate functions for them. https://leetcode.com/submissions/detail/1033800274/\\n\\nThis problem can also be implemented using a single queue. To pop a number, you just need to dequeue and enqueue the numbers repeatedly until you get to the the last number enqueued. For this to work you need to store the number of elements in the queue in a separate variable."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I\\'m not sure what that means. A total noob might get some practice with using queues but other than that, I doubt that they would gain much from this exercise."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Useless for programming but usefull for learning reducing problems and proving computability."
                    },
                    {
                        "username": "WeakProgrammer007",
                        "content": "This can be solved easily using one queue, what is the motive behind two queues?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Easy question and using two is propably often the first idea."
                    },
                    {
                        "username": "__Shahadat__",
                        "content": "100% beats in C++ using deque"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "**Normal person solving this problem**(aam zindagi): \nHave to implement stack using queue how would we do that.\nohhh if we mange to reverse the order of pushing element in queue.\n\n**Whereas Mentos zinadgi:**  implementing stack, ohh Ezzy just use another stack to implement it.\n\n<img src=\"https://i.imgflip.com/7x6dkh.jpg\" >"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*EASY tagged problem atleast looks good*"
                    },
                    {
                        "username": "hucancode",
                        "content": "I can\\'t imagine using a stack that has O(n) push/pop"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is a kind of silly problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@lucasscodes](/lucasscodes) These are not useful nor meaningful reductions since we have full control over the underlying primatives. \\n\\nIn fact in C the first step is create a circular buffer primative to use as a queue by hand which is by itself a easy-medium question.\\n \\nThey should have given us an API that we were required to use, not described one that we were required to create, then the question would have been be more sensible."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "aitachii",
                        "content": "O(n) works. I was expecting some magic trick that can make it O(1)."
                    },
                    {
                        "username": "lsxxc",
                        "content": "I don\\'t get the main point that this question is trying to ask can anyone simplify it "
                    }
                ]
            },
            {
                "id": 2033646,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Wrote an `article + solution` for those who want to learn about Queues and Stacks. \n\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/3970738/simple-lesson-on-queues-and-stacks-and-super-easy-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is such a useless way to implement a stack that I would have skipped this problem if it didn\\'t count towards the monthly total. In fact, I was tempted to just copy and paste the editorial solution. As long as you have access to arrays or linked lists, you will never need to implement a stack this way.\\n\\nI have implemented the solution in C and followed the rules given. The enqueue/dequeue operations are so basic that there is no need to write separate functions for them. https://leetcode.com/submissions/detail/1033800274/\\n\\nThis problem can also be implemented using a single queue. To pop a number, you just need to dequeue and enqueue the numbers repeatedly until you get to the the last number enqueued. For this to work you need to store the number of elements in the queue in a separate variable."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I\\'m not sure what that means. A total noob might get some practice with using queues but other than that, I doubt that they would gain much from this exercise."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Useless for programming but usefull for learning reducing problems and proving computability."
                    },
                    {
                        "username": "WeakProgrammer007",
                        "content": "This can be solved easily using one queue, what is the motive behind two queues?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Easy question and using two is propably often the first idea."
                    },
                    {
                        "username": "__Shahadat__",
                        "content": "100% beats in C++ using deque"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "**Normal person solving this problem**(aam zindagi): \nHave to implement stack using queue how would we do that.\nohhh if we mange to reverse the order of pushing element in queue.\n\n**Whereas Mentos zinadgi:**  implementing stack, ohh Ezzy just use another stack to implement it.\n\n<img src=\"https://i.imgflip.com/7x6dkh.jpg\" >"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*EASY tagged problem atleast looks good*"
                    },
                    {
                        "username": "hucancode",
                        "content": "I can\\'t imagine using a stack that has O(n) push/pop"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is a kind of silly problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@lucasscodes](/lucasscodes) These are not useful nor meaningful reductions since we have full control over the underlying primatives. \\n\\nIn fact in C the first step is create a circular buffer primative to use as a queue by hand which is by itself a easy-medium question.\\n \\nThey should have given us an API that we were required to use, not described one that we were required to create, then the question would have been be more sensible."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "aitachii",
                        "content": "O(n) works. I was expecting some magic trick that can make it O(1)."
                    },
                    {
                        "username": "lsxxc",
                        "content": "I don\\'t get the main point that this question is trying to ask can anyone simplify it "
                    }
                ]
            },
            {
                "id": 2033588,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Wrote an `article + solution` for those who want to learn about Queues and Stacks. \n\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/3970738/simple-lesson-on-queues-and-stacks-and-super-easy-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is such a useless way to implement a stack that I would have skipped this problem if it didn\\'t count towards the monthly total. In fact, I was tempted to just copy and paste the editorial solution. As long as you have access to arrays or linked lists, you will never need to implement a stack this way.\\n\\nI have implemented the solution in C and followed the rules given. The enqueue/dequeue operations are so basic that there is no need to write separate functions for them. https://leetcode.com/submissions/detail/1033800274/\\n\\nThis problem can also be implemented using a single queue. To pop a number, you just need to dequeue and enqueue the numbers repeatedly until you get to the the last number enqueued. For this to work you need to store the number of elements in the queue in a separate variable."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I\\'m not sure what that means. A total noob might get some practice with using queues but other than that, I doubt that they would gain much from this exercise."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Useless for programming but usefull for learning reducing problems and proving computability."
                    },
                    {
                        "username": "WeakProgrammer007",
                        "content": "This can be solved easily using one queue, what is the motive behind two queues?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Easy question and using two is propably often the first idea."
                    },
                    {
                        "username": "__Shahadat__",
                        "content": "100% beats in C++ using deque"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "**Normal person solving this problem**(aam zindagi): \nHave to implement stack using queue how would we do that.\nohhh if we mange to reverse the order of pushing element in queue.\n\n**Whereas Mentos zinadgi:**  implementing stack, ohh Ezzy just use another stack to implement it.\n\n<img src=\"https://i.imgflip.com/7x6dkh.jpg\" >"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*EASY tagged problem atleast looks good*"
                    },
                    {
                        "username": "hucancode",
                        "content": "I can\\'t imagine using a stack that has O(n) push/pop"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is a kind of silly problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@lucasscodes](/lucasscodes) These are not useful nor meaningful reductions since we have full control over the underlying primatives. \\n\\nIn fact in C the first step is create a circular buffer primative to use as a queue by hand which is by itself a easy-medium question.\\n \\nThey should have given us an API that we were required to use, not described one that we were required to create, then the question would have been be more sensible."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "aitachii",
                        "content": "O(n) works. I was expecting some magic trick that can make it O(1)."
                    },
                    {
                        "username": "lsxxc",
                        "content": "I don\\'t get the main point that this question is trying to ask can anyone simplify it "
                    }
                ]
            },
            {
                "id": 2033553,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Wrote an `article + solution` for those who want to learn about Queues and Stacks. \n\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/3970738/simple-lesson-on-queues-and-stacks-and-super-easy-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is such a useless way to implement a stack that I would have skipped this problem if it didn\\'t count towards the monthly total. In fact, I was tempted to just copy and paste the editorial solution. As long as you have access to arrays or linked lists, you will never need to implement a stack this way.\\n\\nI have implemented the solution in C and followed the rules given. The enqueue/dequeue operations are so basic that there is no need to write separate functions for them. https://leetcode.com/submissions/detail/1033800274/\\n\\nThis problem can also be implemented using a single queue. To pop a number, you just need to dequeue and enqueue the numbers repeatedly until you get to the the last number enqueued. For this to work you need to store the number of elements in the queue in a separate variable."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I\\'m not sure what that means. A total noob might get some practice with using queues but other than that, I doubt that they would gain much from this exercise."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Useless for programming but usefull for learning reducing problems and proving computability."
                    },
                    {
                        "username": "WeakProgrammer007",
                        "content": "This can be solved easily using one queue, what is the motive behind two queues?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Easy question and using two is propably often the first idea."
                    },
                    {
                        "username": "__Shahadat__",
                        "content": "100% beats in C++ using deque"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "**Normal person solving this problem**(aam zindagi): \nHave to implement stack using queue how would we do that.\nohhh if we mange to reverse the order of pushing element in queue.\n\n**Whereas Mentos zinadgi:**  implementing stack, ohh Ezzy just use another stack to implement it.\n\n<img src=\"https://i.imgflip.com/7x6dkh.jpg\" >"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*EASY tagged problem atleast looks good*"
                    },
                    {
                        "username": "hucancode",
                        "content": "I can\\'t imagine using a stack that has O(n) push/pop"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is a kind of silly problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@lucasscodes](/lucasscodes) These are not useful nor meaningful reductions since we have full control over the underlying primatives. \\n\\nIn fact in C the first step is create a circular buffer primative to use as a queue by hand which is by itself a easy-medium question.\\n \\nThey should have given us an API that we were required to use, not described one that we were required to create, then the question would have been be more sensible."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "aitachii",
                        "content": "O(n) works. I was expecting some magic trick that can make it O(1)."
                    },
                    {
                        "username": "lsxxc",
                        "content": "I don\\'t get the main point that this question is trying to ask can anyone simplify it "
                    }
                ]
            },
            {
                "id": 2033545,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Wrote an `article + solution` for those who want to learn about Queues and Stacks. \n\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/3970738/simple-lesson-on-queues-and-stacks-and-super-easy-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is such a useless way to implement a stack that I would have skipped this problem if it didn\\'t count towards the monthly total. In fact, I was tempted to just copy and paste the editorial solution. As long as you have access to arrays or linked lists, you will never need to implement a stack this way.\\n\\nI have implemented the solution in C and followed the rules given. The enqueue/dequeue operations are so basic that there is no need to write separate functions for them. https://leetcode.com/submissions/detail/1033800274/\\n\\nThis problem can also be implemented using a single queue. To pop a number, you just need to dequeue and enqueue the numbers repeatedly until you get to the the last number enqueued. For this to work you need to store the number of elements in the queue in a separate variable."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I\\'m not sure what that means. A total noob might get some practice with using queues but other than that, I doubt that they would gain much from this exercise."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Useless for programming but usefull for learning reducing problems and proving computability."
                    },
                    {
                        "username": "WeakProgrammer007",
                        "content": "This can be solved easily using one queue, what is the motive behind two queues?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Easy question and using two is propably often the first idea."
                    },
                    {
                        "username": "__Shahadat__",
                        "content": "100% beats in C++ using deque"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "**Normal person solving this problem**(aam zindagi): \nHave to implement stack using queue how would we do that.\nohhh if we mange to reverse the order of pushing element in queue.\n\n**Whereas Mentos zinadgi:**  implementing stack, ohh Ezzy just use another stack to implement it.\n\n<img src=\"https://i.imgflip.com/7x6dkh.jpg\" >"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*EASY tagged problem atleast looks good*"
                    },
                    {
                        "username": "hucancode",
                        "content": "I can\\'t imagine using a stack that has O(n) push/pop"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is a kind of silly problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@lucasscodes](/lucasscodes) These are not useful nor meaningful reductions since we have full control over the underlying primatives. \\n\\nIn fact in C the first step is create a circular buffer primative to use as a queue by hand which is by itself a easy-medium question.\\n \\nThey should have given us an API that we were required to use, not described one that we were required to create, then the question would have been be more sensible."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "aitachii",
                        "content": "O(n) works. I was expecting some magic trick that can make it O(1)."
                    },
                    {
                        "username": "lsxxc",
                        "content": "I don\\'t get the main point that this question is trying to ask can anyone simplify it "
                    }
                ]
            },
            {
                "id": 2033507,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Wrote an `article + solution` for those who want to learn about Queues and Stacks. \n\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/3970738/simple-lesson-on-queues-and-stacks-and-super-easy-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is such a useless way to implement a stack that I would have skipped this problem if it didn\\'t count towards the monthly total. In fact, I was tempted to just copy and paste the editorial solution. As long as you have access to arrays or linked lists, you will never need to implement a stack this way.\\n\\nI have implemented the solution in C and followed the rules given. The enqueue/dequeue operations are so basic that there is no need to write separate functions for them. https://leetcode.com/submissions/detail/1033800274/\\n\\nThis problem can also be implemented using a single queue. To pop a number, you just need to dequeue and enqueue the numbers repeatedly until you get to the the last number enqueued. For this to work you need to store the number of elements in the queue in a separate variable."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I\\'m not sure what that means. A total noob might get some practice with using queues but other than that, I doubt that they would gain much from this exercise."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Useless for programming but usefull for learning reducing problems and proving computability."
                    },
                    {
                        "username": "WeakProgrammer007",
                        "content": "This can be solved easily using one queue, what is the motive behind two queues?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Easy question and using two is propably often the first idea."
                    },
                    {
                        "username": "__Shahadat__",
                        "content": "100% beats in C++ using deque"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "**Normal person solving this problem**(aam zindagi): \nHave to implement stack using queue how would we do that.\nohhh if we mange to reverse the order of pushing element in queue.\n\n**Whereas Mentos zinadgi:**  implementing stack, ohh Ezzy just use another stack to implement it.\n\n<img src=\"https://i.imgflip.com/7x6dkh.jpg\" >"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*EASY tagged problem atleast looks good*"
                    },
                    {
                        "username": "hucancode",
                        "content": "I can\\'t imagine using a stack that has O(n) push/pop"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is a kind of silly problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@lucasscodes](/lucasscodes) These are not useful nor meaningful reductions since we have full control over the underlying primatives. \\n\\nIn fact in C the first step is create a circular buffer primative to use as a queue by hand which is by itself a easy-medium question.\\n \\nThey should have given us an API that we were required to use, not described one that we were required to create, then the question would have been be more sensible."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "aitachii",
                        "content": "O(n) works. I was expecting some magic trick that can make it O(1)."
                    },
                    {
                        "username": "lsxxc",
                        "content": "I don\\'t get the main point that this question is trying to ask can anyone simplify it "
                    }
                ]
            },
            {
                "id": 2033499,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Wrote an `article + solution` for those who want to learn about Queues and Stacks. \n\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/3970738/simple-lesson-on-queues-and-stacks-and-super-easy-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is such a useless way to implement a stack that I would have skipped this problem if it didn\\'t count towards the monthly total. In fact, I was tempted to just copy and paste the editorial solution. As long as you have access to arrays or linked lists, you will never need to implement a stack this way.\\n\\nI have implemented the solution in C and followed the rules given. The enqueue/dequeue operations are so basic that there is no need to write separate functions for them. https://leetcode.com/submissions/detail/1033800274/\\n\\nThis problem can also be implemented using a single queue. To pop a number, you just need to dequeue and enqueue the numbers repeatedly until you get to the the last number enqueued. For this to work you need to store the number of elements in the queue in a separate variable."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I\\'m not sure what that means. A total noob might get some practice with using queues but other than that, I doubt that they would gain much from this exercise."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Useless for programming but usefull for learning reducing problems and proving computability."
                    },
                    {
                        "username": "WeakProgrammer007",
                        "content": "This can be solved easily using one queue, what is the motive behind two queues?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Easy question and using two is propably often the first idea."
                    },
                    {
                        "username": "__Shahadat__",
                        "content": "100% beats in C++ using deque"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "**Normal person solving this problem**(aam zindagi): \nHave to implement stack using queue how would we do that.\nohhh if we mange to reverse the order of pushing element in queue.\n\n**Whereas Mentos zinadgi:**  implementing stack, ohh Ezzy just use another stack to implement it.\n\n<img src=\"https://i.imgflip.com/7x6dkh.jpg\" >"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*EASY tagged problem atleast looks good*"
                    },
                    {
                        "username": "hucancode",
                        "content": "I can\\'t imagine using a stack that has O(n) push/pop"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is a kind of silly problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@lucasscodes](/lucasscodes) These are not useful nor meaningful reductions since we have full control over the underlying primatives. \\n\\nIn fact in C the first step is create a circular buffer primative to use as a queue by hand which is by itself a easy-medium question.\\n \\nThey should have given us an API that we were required to use, not described one that we were required to create, then the question would have been be more sensible."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This teaches reducing problems onto each other for general computability predictions."
                    },
                    {
                        "username": "aitachii",
                        "content": "O(n) works. I was expecting some magic trick that can make it O(1)."
                    },
                    {
                        "username": "lsxxc",
                        "content": "I don\\'t get the main point that this question is trying to ask can anyone simplify it "
                    }
                ]
            },
            {
                "id": 1992017,
                "content": [
                    {
                        "username": "sjhunter86",
                        "content": "I don\\'t get the point of this question, I thought I was reading it wrong. Implementing a queue using two stacks makes sense as a question, but implementing a stack using a queue is... well... basically the same thing? I like how the follow-up asks if you can implement it using only one queue... but why would you ever need more than one queue to implement a stack? No way this was asked at a FAANG interview, lol."
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "I am not able to import queue module in Python. any solution?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to import deque:\\n```\\nfrom collections import deque\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think my O(n) push operation should really be accepted as a valid implementation of a stack..."
                    },
                    {
                        "username": "goterror",
                        "content": "Java Code \n\n`\n\n\n\nclass MyStack {\n    Queue<Integer>q = new LinkedList<>();\n    public MyStack() {\n\n    }\n    \n    public void push(int x) {\n        int size = q.size();\n        q.add(x);\n\n        for (int i = 0; i < q.size() - 1; i++) {\n            q.add(q.remove());\n        }\n    }\n    \n    public int pop() {\n        return q.remove();\n    }\n    \n    public int top() {\n        return q.peek();\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n\n`\n"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "python easy to understand code:\\n ` class MyStack: \\n\\n    def __init__(self):\\n        self.queue1 =  []\\n        self.queue2 =  []\\n\\n    def push(self, x: int) -> None:\\n        while len(self.queue1) > 0:\\n            self.queue2.append(self.queue1.pop(0))\\n        self.queue1.append(x)\\n        while len(self.queue2) > 0:\\n            self.queue1.append(self.queue2.pop(0))\\n        \\n\\n    def pop(self) -> int:\\n        return self.queue1.pop(0)\\n        \\n    def top(self) -> int:\\n        return self.queue1[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue1) == 0\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()`"
                    },
                    {
                        "username": "Mahfuz-Alam",
                        "content": "class MyStack {\\npublic:\\nqueue<int>q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        \\n    }\\n    \\n    int pop() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                break;\\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                \\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n        \\n    }\\n};"
                    },
                    {
                        "username": "novice00051",
                        "content": "Why is pop left more efficient than pop?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "The whole thing is negated by using an array"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The line should be \"Implement a last-in-first-out (LIFO) stack using **at most** two queues.\""
                    }
                ]
            },
            {
                "id": 1880724,
                "content": [
                    {
                        "username": "sjhunter86",
                        "content": "I don\\'t get the point of this question, I thought I was reading it wrong. Implementing a queue using two stacks makes sense as a question, but implementing a stack using a queue is... well... basically the same thing? I like how the follow-up asks if you can implement it using only one queue... but why would you ever need more than one queue to implement a stack? No way this was asked at a FAANG interview, lol."
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "I am not able to import queue module in Python. any solution?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to import deque:\\n```\\nfrom collections import deque\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think my O(n) push operation should really be accepted as a valid implementation of a stack..."
                    },
                    {
                        "username": "goterror",
                        "content": "Java Code \n\n`\n\n\n\nclass MyStack {\n    Queue<Integer>q = new LinkedList<>();\n    public MyStack() {\n\n    }\n    \n    public void push(int x) {\n        int size = q.size();\n        q.add(x);\n\n        for (int i = 0; i < q.size() - 1; i++) {\n            q.add(q.remove());\n        }\n    }\n    \n    public int pop() {\n        return q.remove();\n    }\n    \n    public int top() {\n        return q.peek();\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n\n`\n"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "python easy to understand code:\\n ` class MyStack: \\n\\n    def __init__(self):\\n        self.queue1 =  []\\n        self.queue2 =  []\\n\\n    def push(self, x: int) -> None:\\n        while len(self.queue1) > 0:\\n            self.queue2.append(self.queue1.pop(0))\\n        self.queue1.append(x)\\n        while len(self.queue2) > 0:\\n            self.queue1.append(self.queue2.pop(0))\\n        \\n\\n    def pop(self) -> int:\\n        return self.queue1.pop(0)\\n        \\n    def top(self) -> int:\\n        return self.queue1[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue1) == 0\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()`"
                    },
                    {
                        "username": "Mahfuz-Alam",
                        "content": "class MyStack {\\npublic:\\nqueue<int>q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        \\n    }\\n    \\n    int pop() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                break;\\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                \\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n        \\n    }\\n};"
                    },
                    {
                        "username": "novice00051",
                        "content": "Why is pop left more efficient than pop?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "The whole thing is negated by using an array"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The line should be \"Implement a last-in-first-out (LIFO) stack using **at most** two queues.\""
                    }
                ]
            },
            {
                "id": 1867566,
                "content": [
                    {
                        "username": "sjhunter86",
                        "content": "I don\\'t get the point of this question, I thought I was reading it wrong. Implementing a queue using two stacks makes sense as a question, but implementing a stack using a queue is... well... basically the same thing? I like how the follow-up asks if you can implement it using only one queue... but why would you ever need more than one queue to implement a stack? No way this was asked at a FAANG interview, lol."
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "I am not able to import queue module in Python. any solution?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to import deque:\\n```\\nfrom collections import deque\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think my O(n) push operation should really be accepted as a valid implementation of a stack..."
                    },
                    {
                        "username": "goterror",
                        "content": "Java Code \n\n`\n\n\n\nclass MyStack {\n    Queue<Integer>q = new LinkedList<>();\n    public MyStack() {\n\n    }\n    \n    public void push(int x) {\n        int size = q.size();\n        q.add(x);\n\n        for (int i = 0; i < q.size() - 1; i++) {\n            q.add(q.remove());\n        }\n    }\n    \n    public int pop() {\n        return q.remove();\n    }\n    \n    public int top() {\n        return q.peek();\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n\n`\n"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "python easy to understand code:\\n ` class MyStack: \\n\\n    def __init__(self):\\n        self.queue1 =  []\\n        self.queue2 =  []\\n\\n    def push(self, x: int) -> None:\\n        while len(self.queue1) > 0:\\n            self.queue2.append(self.queue1.pop(0))\\n        self.queue1.append(x)\\n        while len(self.queue2) > 0:\\n            self.queue1.append(self.queue2.pop(0))\\n        \\n\\n    def pop(self) -> int:\\n        return self.queue1.pop(0)\\n        \\n    def top(self) -> int:\\n        return self.queue1[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue1) == 0\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()`"
                    },
                    {
                        "username": "Mahfuz-Alam",
                        "content": "class MyStack {\\npublic:\\nqueue<int>q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        \\n    }\\n    \\n    int pop() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                break;\\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                \\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n        \\n    }\\n};"
                    },
                    {
                        "username": "novice00051",
                        "content": "Why is pop left more efficient than pop?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "The whole thing is negated by using an array"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The line should be \"Implement a last-in-first-out (LIFO) stack using **at most** two queues.\""
                    }
                ]
            },
            {
                "id": 1851481,
                "content": [
                    {
                        "username": "sjhunter86",
                        "content": "I don\\'t get the point of this question, I thought I was reading it wrong. Implementing a queue using two stacks makes sense as a question, but implementing a stack using a queue is... well... basically the same thing? I like how the follow-up asks if you can implement it using only one queue... but why would you ever need more than one queue to implement a stack? No way this was asked at a FAANG interview, lol."
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "I am not able to import queue module in Python. any solution?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to import deque:\\n```\\nfrom collections import deque\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think my O(n) push operation should really be accepted as a valid implementation of a stack..."
                    },
                    {
                        "username": "goterror",
                        "content": "Java Code \n\n`\n\n\n\nclass MyStack {\n    Queue<Integer>q = new LinkedList<>();\n    public MyStack() {\n\n    }\n    \n    public void push(int x) {\n        int size = q.size();\n        q.add(x);\n\n        for (int i = 0; i < q.size() - 1; i++) {\n            q.add(q.remove());\n        }\n    }\n    \n    public int pop() {\n        return q.remove();\n    }\n    \n    public int top() {\n        return q.peek();\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n\n`\n"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "python easy to understand code:\\n ` class MyStack: \\n\\n    def __init__(self):\\n        self.queue1 =  []\\n        self.queue2 =  []\\n\\n    def push(self, x: int) -> None:\\n        while len(self.queue1) > 0:\\n            self.queue2.append(self.queue1.pop(0))\\n        self.queue1.append(x)\\n        while len(self.queue2) > 0:\\n            self.queue1.append(self.queue2.pop(0))\\n        \\n\\n    def pop(self) -> int:\\n        return self.queue1.pop(0)\\n        \\n    def top(self) -> int:\\n        return self.queue1[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue1) == 0\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()`"
                    },
                    {
                        "username": "Mahfuz-Alam",
                        "content": "class MyStack {\\npublic:\\nqueue<int>q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        \\n    }\\n    \\n    int pop() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                break;\\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                \\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n        \\n    }\\n};"
                    },
                    {
                        "username": "novice00051",
                        "content": "Why is pop left more efficient than pop?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "The whole thing is negated by using an array"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The line should be \"Implement a last-in-first-out (LIFO) stack using **at most** two queues.\""
                    }
                ]
            },
            {
                "id": 1771034,
                "content": [
                    {
                        "username": "sjhunter86",
                        "content": "I don\\'t get the point of this question, I thought I was reading it wrong. Implementing a queue using two stacks makes sense as a question, but implementing a stack using a queue is... well... basically the same thing? I like how the follow-up asks if you can implement it using only one queue... but why would you ever need more than one queue to implement a stack? No way this was asked at a FAANG interview, lol."
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "I am not able to import queue module in Python. any solution?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to import deque:\\n```\\nfrom collections import deque\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think my O(n) push operation should really be accepted as a valid implementation of a stack..."
                    },
                    {
                        "username": "goterror",
                        "content": "Java Code \n\n`\n\n\n\nclass MyStack {\n    Queue<Integer>q = new LinkedList<>();\n    public MyStack() {\n\n    }\n    \n    public void push(int x) {\n        int size = q.size();\n        q.add(x);\n\n        for (int i = 0; i < q.size() - 1; i++) {\n            q.add(q.remove());\n        }\n    }\n    \n    public int pop() {\n        return q.remove();\n    }\n    \n    public int top() {\n        return q.peek();\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n\n`\n"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "python easy to understand code:\\n ` class MyStack: \\n\\n    def __init__(self):\\n        self.queue1 =  []\\n        self.queue2 =  []\\n\\n    def push(self, x: int) -> None:\\n        while len(self.queue1) > 0:\\n            self.queue2.append(self.queue1.pop(0))\\n        self.queue1.append(x)\\n        while len(self.queue2) > 0:\\n            self.queue1.append(self.queue2.pop(0))\\n        \\n\\n    def pop(self) -> int:\\n        return self.queue1.pop(0)\\n        \\n    def top(self) -> int:\\n        return self.queue1[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue1) == 0\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()`"
                    },
                    {
                        "username": "Mahfuz-Alam",
                        "content": "class MyStack {\\npublic:\\nqueue<int>q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        \\n    }\\n    \\n    int pop() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                break;\\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                \\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n        \\n    }\\n};"
                    },
                    {
                        "username": "novice00051",
                        "content": "Why is pop left more efficient than pop?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "The whole thing is negated by using an array"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The line should be \"Implement a last-in-first-out (LIFO) stack using **at most** two queues.\""
                    }
                ]
            },
            {
                "id": 1758567,
                "content": [
                    {
                        "username": "sjhunter86",
                        "content": "I don\\'t get the point of this question, I thought I was reading it wrong. Implementing a queue using two stacks makes sense as a question, but implementing a stack using a queue is... well... basically the same thing? I like how the follow-up asks if you can implement it using only one queue... but why would you ever need more than one queue to implement a stack? No way this was asked at a FAANG interview, lol."
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "I am not able to import queue module in Python. any solution?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to import deque:\\n```\\nfrom collections import deque\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think my O(n) push operation should really be accepted as a valid implementation of a stack..."
                    },
                    {
                        "username": "goterror",
                        "content": "Java Code \n\n`\n\n\n\nclass MyStack {\n    Queue<Integer>q = new LinkedList<>();\n    public MyStack() {\n\n    }\n    \n    public void push(int x) {\n        int size = q.size();\n        q.add(x);\n\n        for (int i = 0; i < q.size() - 1; i++) {\n            q.add(q.remove());\n        }\n    }\n    \n    public int pop() {\n        return q.remove();\n    }\n    \n    public int top() {\n        return q.peek();\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n\n`\n"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "python easy to understand code:\\n ` class MyStack: \\n\\n    def __init__(self):\\n        self.queue1 =  []\\n        self.queue2 =  []\\n\\n    def push(self, x: int) -> None:\\n        while len(self.queue1) > 0:\\n            self.queue2.append(self.queue1.pop(0))\\n        self.queue1.append(x)\\n        while len(self.queue2) > 0:\\n            self.queue1.append(self.queue2.pop(0))\\n        \\n\\n    def pop(self) -> int:\\n        return self.queue1.pop(0)\\n        \\n    def top(self) -> int:\\n        return self.queue1[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue1) == 0\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()`"
                    },
                    {
                        "username": "Mahfuz-Alam",
                        "content": "class MyStack {\\npublic:\\nqueue<int>q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        \\n    }\\n    \\n    int pop() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                break;\\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                \\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n        \\n    }\\n};"
                    },
                    {
                        "username": "novice00051",
                        "content": "Why is pop left more efficient than pop?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "The whole thing is negated by using an array"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The line should be \"Implement a last-in-first-out (LIFO) stack using **at most** two queues.\""
                    }
                ]
            },
            {
                "id": 1739885,
                "content": [
                    {
                        "username": "sjhunter86",
                        "content": "I don\\'t get the point of this question, I thought I was reading it wrong. Implementing a queue using two stacks makes sense as a question, but implementing a stack using a queue is... well... basically the same thing? I like how the follow-up asks if you can implement it using only one queue... but why would you ever need more than one queue to implement a stack? No way this was asked at a FAANG interview, lol."
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "I am not able to import queue module in Python. any solution?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to import deque:\\n```\\nfrom collections import deque\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think my O(n) push operation should really be accepted as a valid implementation of a stack..."
                    },
                    {
                        "username": "goterror",
                        "content": "Java Code \n\n`\n\n\n\nclass MyStack {\n    Queue<Integer>q = new LinkedList<>();\n    public MyStack() {\n\n    }\n    \n    public void push(int x) {\n        int size = q.size();\n        q.add(x);\n\n        for (int i = 0; i < q.size() - 1; i++) {\n            q.add(q.remove());\n        }\n    }\n    \n    public int pop() {\n        return q.remove();\n    }\n    \n    public int top() {\n        return q.peek();\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n\n`\n"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "python easy to understand code:\\n ` class MyStack: \\n\\n    def __init__(self):\\n        self.queue1 =  []\\n        self.queue2 =  []\\n\\n    def push(self, x: int) -> None:\\n        while len(self.queue1) > 0:\\n            self.queue2.append(self.queue1.pop(0))\\n        self.queue1.append(x)\\n        while len(self.queue2) > 0:\\n            self.queue1.append(self.queue2.pop(0))\\n        \\n\\n    def pop(self) -> int:\\n        return self.queue1.pop(0)\\n        \\n    def top(self) -> int:\\n        return self.queue1[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue1) == 0\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()`"
                    },
                    {
                        "username": "Mahfuz-Alam",
                        "content": "class MyStack {\\npublic:\\nqueue<int>q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        \\n    }\\n    \\n    int pop() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                break;\\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                \\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n        \\n    }\\n};"
                    },
                    {
                        "username": "novice00051",
                        "content": "Why is pop left more efficient than pop?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "The whole thing is negated by using an array"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The line should be \"Implement a last-in-first-out (LIFO) stack using **at most** two queues.\""
                    }
                ]
            },
            {
                "id": 1715098,
                "content": [
                    {
                        "username": "sjhunter86",
                        "content": "I don\\'t get the point of this question, I thought I was reading it wrong. Implementing a queue using two stacks makes sense as a question, but implementing a stack using a queue is... well... basically the same thing? I like how the follow-up asks if you can implement it using only one queue... but why would you ever need more than one queue to implement a stack? No way this was asked at a FAANG interview, lol."
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "I am not able to import queue module in Python. any solution?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to import deque:\\n```\\nfrom collections import deque\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think my O(n) push operation should really be accepted as a valid implementation of a stack..."
                    },
                    {
                        "username": "goterror",
                        "content": "Java Code \n\n`\n\n\n\nclass MyStack {\n    Queue<Integer>q = new LinkedList<>();\n    public MyStack() {\n\n    }\n    \n    public void push(int x) {\n        int size = q.size();\n        q.add(x);\n\n        for (int i = 0; i < q.size() - 1; i++) {\n            q.add(q.remove());\n        }\n    }\n    \n    public int pop() {\n        return q.remove();\n    }\n    \n    public int top() {\n        return q.peek();\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n\n`\n"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "python easy to understand code:\\n ` class MyStack: \\n\\n    def __init__(self):\\n        self.queue1 =  []\\n        self.queue2 =  []\\n\\n    def push(self, x: int) -> None:\\n        while len(self.queue1) > 0:\\n            self.queue2.append(self.queue1.pop(0))\\n        self.queue1.append(x)\\n        while len(self.queue2) > 0:\\n            self.queue1.append(self.queue2.pop(0))\\n        \\n\\n    def pop(self) -> int:\\n        return self.queue1.pop(0)\\n        \\n    def top(self) -> int:\\n        return self.queue1[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue1) == 0\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()`"
                    },
                    {
                        "username": "Mahfuz-Alam",
                        "content": "class MyStack {\\npublic:\\nqueue<int>q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        \\n    }\\n    \\n    int pop() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                break;\\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                \\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n        \\n    }\\n};"
                    },
                    {
                        "username": "novice00051",
                        "content": "Why is pop left more efficient than pop?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "The whole thing is negated by using an array"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The line should be \"Implement a last-in-first-out (LIFO) stack using **at most** two queues.\""
                    }
                ]
            },
            {
                "id": 1691060,
                "content": [
                    {
                        "username": "sjhunter86",
                        "content": "I don\\'t get the point of this question, I thought I was reading it wrong. Implementing a queue using two stacks makes sense as a question, but implementing a stack using a queue is... well... basically the same thing? I like how the follow-up asks if you can implement it using only one queue... but why would you ever need more than one queue to implement a stack? No way this was asked at a FAANG interview, lol."
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "I am not able to import queue module in Python. any solution?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to import deque:\\n```\\nfrom collections import deque\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think my O(n) push operation should really be accepted as a valid implementation of a stack..."
                    },
                    {
                        "username": "goterror",
                        "content": "Java Code \n\n`\n\n\n\nclass MyStack {\n    Queue<Integer>q = new LinkedList<>();\n    public MyStack() {\n\n    }\n    \n    public void push(int x) {\n        int size = q.size();\n        q.add(x);\n\n        for (int i = 0; i < q.size() - 1; i++) {\n            q.add(q.remove());\n        }\n    }\n    \n    public int pop() {\n        return q.remove();\n    }\n    \n    public int top() {\n        return q.peek();\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n\n`\n"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "python easy to understand code:\\n ` class MyStack: \\n\\n    def __init__(self):\\n        self.queue1 =  []\\n        self.queue2 =  []\\n\\n    def push(self, x: int) -> None:\\n        while len(self.queue1) > 0:\\n            self.queue2.append(self.queue1.pop(0))\\n        self.queue1.append(x)\\n        while len(self.queue2) > 0:\\n            self.queue1.append(self.queue2.pop(0))\\n        \\n\\n    def pop(self) -> int:\\n        return self.queue1.pop(0)\\n        \\n    def top(self) -> int:\\n        return self.queue1[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue1) == 0\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()`"
                    },
                    {
                        "username": "Mahfuz-Alam",
                        "content": "class MyStack {\\npublic:\\nqueue<int>q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        \\n    }\\n    \\n    int pop() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                break;\\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                \\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n        \\n    }\\n};"
                    },
                    {
                        "username": "novice00051",
                        "content": "Why is pop left more efficient than pop?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "The whole thing is negated by using an array"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The line should be \"Implement a last-in-first-out (LIFO) stack using **at most** two queues.\""
                    }
                ]
            },
            {
                "id": 2033949,
                "content": [
                    {
                        "username": "sjhunter86",
                        "content": "I don\\'t get the point of this question, I thought I was reading it wrong. Implementing a queue using two stacks makes sense as a question, but implementing a stack using a queue is... well... basically the same thing? I like how the follow-up asks if you can implement it using only one queue... but why would you ever need more than one queue to implement a stack? No way this was asked at a FAANG interview, lol."
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "I am not able to import queue module in Python. any solution?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to import deque:\\n```\\nfrom collections import deque\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think my O(n) push operation should really be accepted as a valid implementation of a stack..."
                    },
                    {
                        "username": "goterror",
                        "content": "Java Code \n\n`\n\n\n\nclass MyStack {\n    Queue<Integer>q = new LinkedList<>();\n    public MyStack() {\n\n    }\n    \n    public void push(int x) {\n        int size = q.size();\n        q.add(x);\n\n        for (int i = 0; i < q.size() - 1; i++) {\n            q.add(q.remove());\n        }\n    }\n    \n    public int pop() {\n        return q.remove();\n    }\n    \n    public int top() {\n        return q.peek();\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n\n`\n"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "python easy to understand code:\\n ` class MyStack: \\n\\n    def __init__(self):\\n        self.queue1 =  []\\n        self.queue2 =  []\\n\\n    def push(self, x: int) -> None:\\n        while len(self.queue1) > 0:\\n            self.queue2.append(self.queue1.pop(0))\\n        self.queue1.append(x)\\n        while len(self.queue2) > 0:\\n            self.queue1.append(self.queue2.pop(0))\\n        \\n\\n    def pop(self) -> int:\\n        return self.queue1.pop(0)\\n        \\n    def top(self) -> int:\\n        return self.queue1[0]\\n\\n    def empty(self) -> bool:\\n        return len(self.queue1) == 0\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()`"
                    },
                    {
                        "username": "Mahfuz-Alam",
                        "content": "class MyStack {\\npublic:\\nqueue<int>q1;\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        q1.push(x);\\n        \\n    }\\n    \\n    int pop() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                break;\\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    int top() {\\n        queue<int>q2;\\n        int ans;\\n        while(!q1.empty()){\\n            int val=q1.front();\\n            q1.pop();\\n            if(q1.empty()){\\n                ans=val;\\n                \\n            }\\n            q2.push(val);\\n        }\\n        q1=q2;\\n        return ans;\\n        \\n    }\\n    \\n    bool empty() {\\n        return q1.empty();\\n        \\n    }\\n};"
                    },
                    {
                        "username": "novice00051",
                        "content": "Why is pop left more efficient than pop?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/implement-stack-using-queues/solutions/2906938/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "The whole thing is negated by using an array"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The line should be \"Implement a last-in-first-out (LIFO) stack using **at most** two queues.\""
                    }
                ]
            }
        ]
    }
]