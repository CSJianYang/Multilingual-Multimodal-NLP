[
    {
        "title": "Find Consecutive Integers from a Data Stream",
        "question_content": "For a stream of integers, implement a data structure that checks if the last k integers parsed in the stream are equal to value.\nImplement the DataStream class:\n\n\tDataStream(int value, int k) Initializes the object with an empty integer stream and the two integers value and k.\n\tboolean consec(int num) Adds num to the stream of integers. Returns true if the last k integers are equal to value, and false otherwise. If there are less than k integers, the condition does not hold true, so returns false.\n\n&nbsp;\nExample 1:\n\nInput\n[\"DataStream\", \"consec\", \"consec\", \"consec\", \"consec\"]\n[[4, 3], [4], [4], [4], [3]]\nOutput\n[null, false, false, true, false]\nExplanation\nDataStream dataStream = new DataStream(4, 3); //value = 4, k = 3 \ndataStream.consec(4); // Only 1 integer is parsed, so returns False. \ndataStream.consec(4); // Only 2 integers are parsed.\n                      // Since 2 is less than k, returns False. \ndataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True. \ndataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].\n                      // Since 3 is not equal to value, it returns False.\n\n&nbsp;\nConstraints:\n\n\t1 <= value, num <= 109\n\t1 <= k <= 105\n\tAt most 105 calls will be made to consec.",
        "solutions": [
            {
                "id": 3014963,
                "title": "python-just-count-it",
                "content": "```python\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.v = value\\n        self.k = k\\n        self.n = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.v:\\n            self.n += 1\\n        else:\\n            self.n = 0\\n\\n        return self.n >= self.k\\n```\\n\\nPlease vote up if you like my solution \\uD83D\\uDE4F",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.v = value\\n        self.k = k\\n        self.n = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.v:\\n            self.n += 1\\n        else:\\n            self.n = 0\\n\\n        return self.n >= self.k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015022,
                "title": "c-o-n-to-o-1-memory-queue-count",
                "content": "We can just keep the count of numbers we have pushed till now which were of value given\\nif this number is greater than or equal to k then we can return true else it is false\\nwe will keep increasing the count of numbers equal to value and if any other number comes we will just set count as 0\\n    \\nAuxiliary Space: O(1)\\n```\\nclass DataStream {\\npublic:\\n    int val = 0, kmax = 0;\\n    int valCount = 0;\\n    DataStream(int value, int k) {\\n        val = value;\\n        kmax = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == val)\\n            valCount++;\\n        else\\n            valCount = 0;\\n        return valCount >= kmax;\\n    }\\n};\\n```\\n\\nThere can also be a variation of this question where we are asked to return true if last k values are equal(not necessarily equal to value)\\nwe can use this logic there, but I just thought of this approach and wanted to share this with you all\\n\\nFor this, we can just maintain a queue q of length k and we keep pushing the numbers in this queue and adding this number to the hashmap\\nwhenever the size exceeds k we can pop it from the queue and remove this number from hashmap\\nnow if the size of queue is less than k we will return false\\nElse, we will check the size of our hashmap, if it is 1, i.e, last k numbers pushed are same so return true\\n    \\nAuxiliary Space: O(k)\\n```\\nclass DataStream {\\npublic:\\n    int val = 0, kmax = 0;\\n    queue<int> q;\\n    unordered_map<int,int> hm;\\n    DataStream(int value, int k) {\\n        val = value;\\n        kmax = k;\\n    }\\n    \\n    bool consec(int num) {\\n        q.push(num);\\n        hm[num]++;\\n        if(q.size() > kmax){\\n            int x = q.front();\\n            q.pop();\\n            hm[x]--;\\n            if(hm[x] == 0){\\n                hm.erase(x);\\n            }\\n        }\\n        if(q.size() < kmax)\\n            return false;\\n        if(hm.size() == 1){\\n            // This part is only done to verify if the queue only has all the elements of value \"value\"\\n            for(auto it:hm){\\n                if(it.first == val)\\n                    return true;\\n                else\\n                    return false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val = 0, kmax = 0;\\n    int valCount = 0;\\n    DataStream(int value, int k) {\\n        val = value;\\n        kmax = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == val)\\n            valCount++;\\n        else\\n            valCount = 0;\\n        return valCount >= kmax;\\n    }\\n};\\n```\n```\\nclass DataStream {\\npublic:\\n    int val = 0, kmax = 0;\\n    queue<int> q;\\n    unordered_map<int,int> hm;\\n    DataStream(int value, int k) {\\n        val = value;\\n        kmax = k;\\n    }\\n    \\n    bool consec(int num) {\\n        q.push(num);\\n        hm[num]++;\\n        if(q.size() > kmax){\\n            int x = q.front();\\n            q.pop();\\n            hm[x]--;\\n            if(hm[x] == 0){\\n                hm.erase(x);\\n            }\\n        }\\n        if(q.size() < kmax)\\n            return false;\\n        if(hm.size() == 1){\\n            // This part is only done to verify if the queue only has all the elements of value \"value\"\\n            for(auto it:hm){\\n                if(it.first == val)\\n                    return true;\\n                else\\n                    return false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014918,
                "title": "o-1-space-map-c",
                "content": "# Implementation Based || O(1) Space\\n# **C++**\\n```\\nclass DataStream {\\n    int val, size, l = 0, check;\\npublic:\\n    DataStream(int value, int k) {\\n        val = value, size = check = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == val)      check--;          // if same value occurs     \\n        else                check = size;     // if stream breaks intialize it back to original Size\\n        \\n        // If there are less than k integers, the condition does not hold true \\n        // For the 1st K calls return False (as specified in the Question)\\n        if(++l < size)      return 0;         \\n        // if same value occurs k time then check==0 and if it occurs more then k then check<0\\n        return check<=0;               \\n    }\\n};\\n```\\n# Using **MAP**\\n```\\nclass DataStream {\\n    map<int, int> m1;\\n    int val, size;\\npublic:\\n    DataStream(int value, int k) {\\n        val = value, size = k;\\n        m1[value] = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val)    m1[val]--;\\n        else            m1[val] = size;\\n        return m1[val]<=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass DataStream {\\n    int val, size, l = 0, check;\\npublic:\\n    DataStream(int value, int k) {\\n        val = value, size = check = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == val)      check--;          // if same value occurs     \\n        else                check = size;     // if stream breaks intialize it back to original Size\\n        \\n        // If there are less than k integers, the condition does not hold true \\n        // For the 1st K calls return False (as specified in the Question)\\n        if(++l < size)      return 0;         \\n        // if same value occurs k time then check==0 and if it occurs more then k then check<0\\n        return check<=0;               \\n    }\\n};\\n```\n```\\nclass DataStream {\\n    map<int, int> m1;\\n    int val, size;\\npublic:\\n    DataStream(int value, int k) {\\n        val = value, size = k;\\n        m1[value] = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val)    m1[val]--;\\n        else            m1[val] = size;\\n        return m1[val]<=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015258,
                "title": "java-record-the-streak-of-same-consecutive-number",
                "content": "# Please Upvote :D\\n---\\n``` java []\\nclass DataStream {\\n    private int val, k, count;\\n    public DataStream(int value, int k) {\\n        this.val = value;\\n        this.k = k;\\n        this.count = 0;\\n    }\\n\\n    public boolean consec(int num) {\\n        // if num == val, increment the streak else set it to 0\\n        count = (num == val)? count + 1 : 0;\\n        return count >= k;\\n        \\n    }\\n}\\n\\n// TC: O(k) - let k be the number of calls made to consec()\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass DataStream {\\n    private int val, k, count;\\n    public DataStream(int value, int k) {\\n        this.val = value;\\n        this.k = k;\\n        this.count = 0;\\n    }\\n\\n    public boolean consec(int num) {\\n        // if num == val, increment the streak else set it to 0\\n        count = (num == val)? count + 1 : 0;\\n        return count >= k;\\n        \\n    }\\n}\\n\\n// TC: O(k) - let k be the number of calls made to consec()\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326511,
                "title": "c-count-and-reset-counter-fast-247ms-100",
                "content": "**TODO(heder): Insert cute cat meme to ask for up-votes. ;)**\\n\\n# Approach 1: increment counter on match otherwise reset it\\nThe idea is very simple: If the ```num``` is equal to ```value``` we increment the counter and otherwise we reset it to zero. We have a streak of ```k``` equal values if the counter is bigger than ```k```. Explaining this in plain english is already longer than the actual code. :)\\n\\n```cpp\\nclass DataStream {\\nprivate:\\n    const int value_;\\n    const int k_;\\n    int count_ = 0;\\n\\npublic:\\n    DataStream(int value, int k) : value_(value), k_(k) {\\n    }\\n    \\n    bool consec(int num) {\\n        if (num == value_) ++count_; else count_ = 0;\\n        return count_ >= k_;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the number of calls to ```consec``` then the\\n  * Time complexity is $$O(n)$$ and the \\n  * Space complexity is $$O(1)$$.\\n\\n**Pro-Tip**\\n\\nI always have a header like this in my solutions. This speeds-up I/O:\\n\\n```cpp\\n// https://leetcode.com/problems/find-consecutive-integers-from-a-data-stream/\\n// problem: 2526\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```num```\n```value```\n```k```\n```k```\n```cpp\\nclass DataStream {\\nprivate:\\n    const int value_;\\n    const int k_;\\n    int count_ = 0;\\n\\npublic:\\n    DataStream(int value, int k) : value_(value), k_(k) {\\n    }\\n    \\n    bool consec(int num) {\\n        if (num == value_) ++count_; else count_ = 0;\\n        return count_ >= k_;\\n    }\\n};\\n```\n```consec```\n```cpp\\n// https://leetcode.com/problems/find-consecutive-integers-from-a-data-stream/\\n// problem: 2526\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3015141,
                "title": "python3-record-the-last-index-of-non-value-element-in-the-data-stream",
                "content": "# Intuition\\nChecking the last `k` element in the Data Stream each time is computationally expensive and will get TLE. We need to come up with better algorithms.\\n\\n# Approach\\nGiven the objective of this problem, we don\\'t need to (physically) maintain the full Data Stream, but just need to record the last index of the element not equal to the given `value` in the Data Stream.\\n\\n# Complexity\\n- Time complexity of each operation: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity of each operation: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k\\n        self.currIdx = -1\\n        self.lastIdx = -1\\n\\n    def consec(self, num: int) -> bool:\\n        self.currIdx += 1\\n        if num != self.value:\\n            self.lastIdx = self.currIdx\\n        return self.currIdx - self.lastIdx >= self.k\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k\\n        self.currIdx = -1\\n        self.lastIdx = -1\\n\\n    def consec(self, num: int) -> bool:\\n        self.currIdx += 1\\n        if num != self.value:\\n            self.lastIdx = self.currIdx\\n        return self.currIdx - self.lastIdx >= self.k\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015672,
                "title": "c-solution-very-simple-and-easy-to-understand",
                "content": "\\n\\n```\\n/* Take a variable and keep tracking the count and reseting it when not eual to value */\\n\\nclass DataStream {\\npublic:\\n    int value;\\n    int k;\\n    int t;\\n    DataStream(int val, int K) {\\n        value = val;\\n        k = K;\\n        t = 0; \\n    }\\n    \\n    bool consec(int num) {\\n        if(num != value) {\\n            t = 0;\\n            return false;\\n        }\\n        t++;\\n        if(t >= k) return true;\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n```\\n/* Take a variable and keep tracking the count and reseting it when not eual to value */\\n\\nclass DataStream {\\npublic:\\n    int value;\\n    int k;\\n    int t;\\n    DataStream(int val, int K) {\\n        value = val;\\n        k = K;\\n        t = 0; \\n    }\\n    \\n    bool consec(int num) {\\n        if(num != value) {\\n            t = 0;\\n            return false;\\n        }\\n        t++;\\n        if(t >= k) return true;\\n        return false;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 3015315,
                "title": "2-approaches-counting-sliding-window-c",
                "content": "# Counting\\n```\\nclass DataStream {\\npublic:\\n    int v, k, cnt = 0;\\n    DataStream(int value, int key) {\\n        v = value;\\n        k = key;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num != v) cnt = 0;\\n        else cnt++;\\n        return cnt >= k;\\n    }\\n};\\n```\\n# Sliding Window\\n```\\nclass DataStream {\\npublic:\\n    int vl, k, i = 0, j = 0;\\n    vector<int> v;\\n    unordered_map<int, int> m;\\n    \\n    DataStream(int value, int key) {\\n        vl = value;\\n        k = key;\\n    }\\n    \\n    bool consec(int num) {\\n        v.push_back(num);\\n        m[num]++;\\n        j++;\\n        if(v.size() < k) return false;\\n        if(j - i == k) {\\n            int f = 0;\\n            if(m.size() == 1 && m.find(vl) != m.end()) f = 1;\\n            m[v[i]]--;\\n            if(!m[v[i]]) m.erase(v[i]);\\n            i++;\\n            if(f) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int v, k, cnt = 0;\\n    DataStream(int value, int key) {\\n        v = value;\\n        k = key;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num != v) cnt = 0;\\n        else cnt++;\\n        return cnt >= k;\\n    }\\n};\\n```\n```\\nclass DataStream {\\npublic:\\n    int vl, k, i = 0, j = 0;\\n    vector<int> v;\\n    unordered_map<int, int> m;\\n    \\n    DataStream(int value, int key) {\\n        vl = value;\\n        k = key;\\n    }\\n    \\n    bool consec(int num) {\\n        v.push_back(num);\\n        m[num]++;\\n        j++;\\n        if(v.size() < k) return false;\\n        if(j - i == k) {\\n            int f = 0;\\n            if(m.size() == 1 && m.find(vl) != m.end()) f = 1;\\n            m[v[i]]--;\\n            if(!m[v[i]]) m.erase(v[i]);\\n            i++;\\n            if(f) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015298,
                "title": "easy-c-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int val, size, count=0;\\n    DataStream(int value, int k){\\n        val = value;\\n        size = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == val)\\n            count++;    \\n        else\\n            count = 0;\\n        return count>=size;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int val, size, count=0;\\n    DataStream(int value, int k){\\n        val = value;\\n        size = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == val)\\n            count++;    \\n        else\\n            count = 0;\\n        return count>=size;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 3832663,
                "title": "100-beats-c-nothing",
                "content": "# Code\\n```\\nclass DataStream {\\npublic:\\n    int x,y,z;\\n    DataStream(int value, int k) {\\n        x = value,y = k,z=0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(x==num){\\n            z++;\\n            return (z>=y);\\n        }\\n        z = 0;\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Counting",
                    "Data Stream"
                ],
                "code": "# Code\\n```\\nclass DataStream {\\npublic:\\n    int x,y,z;\\n    DataStream(int value, int k) {\\n        x = value,y = k,z=0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(x==num){\\n            z++;\\n            return (z>=y);\\n        }\\n        z = 0;\\n        return false;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 3038626,
                "title": "c-using-continous-counting-beats-99-t-c-o-1-s-c-o-1",
                "content": "```\\n/*\\n\\tTime Complexity : O(1)\\n\\tSpace Complexity : O(1)\\n*/\\n\\nclass DataStream {\\n    int k, v;\\n    int currCount = 0;\\npublic:\\n    DataStream(int value, int k) {\\n        this->k = k;\\n        this->v = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == v){\\n            currCount++;\\n        }else{\\n            currCount = 0;\\n        }\\n        \\n        return currCount >= k;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\n/*\\n\\tTime Complexity : O(1)\\n\\tSpace Complexity : O(1)\\n*/\\n\\nclass DataStream {\\n    int k, v;\\n    int currCount = 0;\\npublic:\\n    DataStream(int value, int k) {\\n        this->k = k;\\n        this->v = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == v){\\n            currCount++;\\n        }else{\\n            currCount = 0;\\n        }\\n        \\n        return currCount >= k;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034921,
                "title": "java-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n    Queue<Integer> q=new LinkedList<>();\\n    int k;\\n    int value;\\n    public DataStream(int value, int k) {\\n        this.k=k;\\n        this.value=value;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num!=value){q.clear();return false;}\\n        if(num==value){\\n            q.add(num);\\n        }\\n        if(q.size()==k){\\n            q.poll();\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    Queue<Integer> q=new LinkedList<>();\\n    int k;\\n    int value;\\n    public DataStream(int value, int k) {\\n        this.k=k;\\n        this.value=value;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num!=value){q.clear();return false;}\\n        if(num==value){\\n            q.add(num);\\n        }\\n        if(q.size()==k){\\n            q.poll();\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030214,
                "title": "simple-c-solution-deque-leetcode-weekly-contest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need a data structure to store the stream and tell us whether last k elements are equal to a particular value. \\n\\nSo we try thinking of using a Data Structure to only store the last k occurences.\\n\\nA very good use case of this is a ReplayBuffer used in the Deep Q Network Algorithm in reinforcement learning , wherein one wants to store only the last k occurences. For more  can refer [here.](https://deeplizard.com/learn/video/Bcuj2fTH4_4)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe make use of a doubly ended queue (deque) to easily push and pop elements at front and back of the queue. \\n\\nWe have an initial counter variable size to indicate the number of elements in the deque. \\n\\nWe would also consider encoding numbers from the data stream : 1-> if number is equal to value and 0->if it is not.\\n\\nA var sum would calculate the sum of the elements in the deque. \\n\\nIf the size of deque is k and sum is k it means the data stream has last k occurences equal to the value, hence we return true.\\nThen we pop from the front to make sure the size of the deque is maintained at k. \\n\\n# Complexity\\n- Time complexity : O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass DataStream {\\n    \\n    deque<int> stream;\\n    int value , k;\\n    int size = 0, index = 0, sum = 0;\\npublic:\\n    DataStream(int value, int k) {\\n        this->value = value;\\n        this->k = k;\\n        // stream.resize(this->k,0);\\n    }\\n    \\n    bool consec(int num) {\\n        \\n        \\n        num = num==this->value ? 1 : 0;\\n        sum+=num;\\n        stream.push_back(num);\\n\\n        if(stream.size() < k) return false;\\n        \\n        if(stream.size() == k) return sum == k;\\n        \\n        int temp = stream.front();\\n        sum -= temp;\\n        stream.pop_front();\\n        \\n        return sum == k;\\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```\\n\\nDoubts are always welcome in the comments.\\n\\nPlease upvote if you found this helpful.\\nThank you",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\n    \\n    deque<int> stream;\\n    int value , k;\\n    int size = 0, index = 0, sum = 0;\\npublic:\\n    DataStream(int value, int k) {\\n        this->value = value;\\n        this->k = k;\\n        // stream.resize(this->k,0);\\n    }\\n    \\n    bool consec(int num) {\\n        \\n        \\n        num = num==this->value ? 1 : 0;\\n        sum+=num;\\n        stream.push_back(num);\\n\\n        if(stream.size() < k) return false;\\n        \\n        if(stream.size() == k) return sum == k;\\n        \\n        int temp = stream.front();\\n        sum -= temp;\\n        stream.pop_front();\\n        \\n        return sum == k;\\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020114,
                "title": "c-count-continuous-frequency",
                "content": "# Code\\n```\\nclass DataStream \\n{  \\npublic:\\n    unordered_map<int, int> mp;\\n    int K, Val;\\n    DataStream(int value, int k) \\n    {\\n        K=k;\\n        Val = value;\\n    }\\n    \\n    bool consec(int num) \\n    {\\n        bool res=false;\\n        if(num==Val) mp[Val]++; \\n        else mp[Val]=0; //whenever we get anyother number except Val our strick breaks  \\n        \\n        if(mp[Val] >= K) res=true;\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass DataStream \\n{  \\npublic:\\n    unordered_map<int, int> mp;\\n    int K, Val;\\n    DataStream(int value, int k) \\n    {\\n        K=k;\\n        Val = value;\\n    }\\n    \\n    bool consec(int num) \\n    {\\n        bool res=false;\\n        if(num==Val) mp[Val]++; \\n        else mp[Val]=0; //whenever we get anyother number except Val our strick breaks  \\n        \\n        if(mp[Val] >= K) res=true;\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017863,
                "title": "c-easy-to-understand-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n/* we can solve it by space_complexity- **O(1)**; \\n i.e. by taking only preveous variable which store the \"value and frequency\" ; */\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    vector<pair<int,int>> v;\\n    int val,kval;\\n    DataStream(int value, int k) {\\n        val=value;\\n        kval=k;\\n    }\\n    \\n    bool consec(int num) {\\n        \\n        if(v.size()==0){\\n            if(num==val)\\n            {\\n                v.push_back({num,1});\\n                if(kval==1)return true;\\n                return false;\\n            }\\n            else{\\n                v.push_back({num,0});\\n                return false;\\n            }\\n                \\n        }\\n        \\n        if(num==val){\\n            if(v[v.size()-1].first==val){\\n                v.push_back({num, v[v.size()-1].second+1});\\n                if(v[v.size()-1].second>=kval)return true;\\n                \\n                return false;\\n            }\\n            else{\\n                v.push_back({num, 1});\\n                if(kval==1)return true;\\n                return false;\\n            }\\n        }\\n        else{\\n            v.push_back({num, 0});\\n            return false;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    vector<pair<int,int>> v;\\n    int val,kval;\\n    DataStream(int value, int k) {\\n        val=value;\\n        kval=k;\\n    }\\n    \\n    bool consec(int num) {\\n        \\n        if(v.size()==0){\\n            if(num==val)\\n            {\\n                v.push_back({num,1});\\n                if(kval==1)return true;\\n                return false;\\n            }\\n            else{\\n                v.push_back({num,0});\\n                return false;\\n            }\\n                \\n        }\\n        \\n        if(num==val){\\n            if(v[v.size()-1].first==val){\\n                v.push_back({num, v[v.size()-1].second+1});\\n                if(v[v.size()-1].second>=kval)return true;\\n                \\n                return false;\\n            }\\n            else{\\n                v.push_back({num, 1});\\n                if(kval==1)return true;\\n                return false;\\n            }\\n        }\\n        else{\\n            v.push_back({num, 0});\\n            return false;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016462,
                "title": "simple-short-c-solution-pop-operation-o-n-time-complexity",
                "content": "# Intuition\\nMain idea to store the same elements in a vector. if it is a different element then we can pop all previous elements and insert the new element. So that we can ensure that all previous consecutive elements are of same type and we can simply check the size of the vector\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    \\n    int x,y;\\n    vector<int>arr;\\n    DataStream(int value, int k) \\n    {\\n        x = value;\\n        y = k;\\n    }\\n    \\n    bool consec(int num) \\n    {        \\n        while(arr.size() && arr.back()!=num) arr.pop_back();\\n        arr.push_back(num);\\n        \\n        if(num != x) return false;\\n        return (arr.size()>=y);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    \\n    int x,y;\\n    vector<int>arr;\\n    DataStream(int value, int k) \\n    {\\n        x = value;\\n        y = k;\\n    }\\n    \\n    bool consec(int num) \\n    {        \\n        while(arr.size() && arr.back()!=num) arr.pop_back();\\n        arr.push_back(num);\\n        \\n        if(num != x) return false;\\n        return (arr.size()>=y);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015703,
                "title": "c-clean-easy-to-understand-code-logical",
                "content": "![image](https://assets.leetcode.com/users/images/8e4d9dbc-1e06-44e7-8ec3-e1c4404aae62_1673121343.7287793.png)\\n\\n\\tclass DataStream {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\tint k,val,count=0;\\n\\t\\t\\tDataStream(int value, int k) {\\n\\t\\t\\t\\tthis->k=k;\\n\\t\\t\\t\\tval=value;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool consec(int num) {\\n\\t\\t\\t\\tv.push_back(num);\\n\\n\\t\\t\\t\\tif(num==val) count++;\\n\\t\\t\\t\\telse count=0;\\n\\n\\t\\t\\t\\tif(v.size()<k) return false;\\n\\t\\t\\t\\telse if(count>=k) return true;\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/8e4d9dbc-1e06-44e7-8ec3-e1c4404aae62_1673121343.7287793.png)\\n\\n\\tclass DataStream {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\tint k,val,count=0;\\n\\t\\t\\tDataStream(int value, int k) {\\n\\t\\t\\t\\tthis->k=k;\\n\\t\\t\\t\\tval=value;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool consec(int num) {\\n\\t\\t\\t\\tv.push_back(num);\\n\\n\\t\\t\\t\\tif(num==val) count++;\\n\\t\\t\\t\\telse count=0;\\n\\n\\t\\t\\t\\tif(v.size()<k) return false;\\n\\t\\t\\t\\telse if(count>=k) return true;\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t};",
                "codeTag": "Java"
            },
            {
                "id": 3015104,
                "title": "c-queue-easy",
                "content": "```\\nclass DataStream {\\npublic:\\n    queue<int> q;\\n    int x;\\n    int count = 0;\\n    int val;\\n    \\n    DataStream(int value, int k) \\n    {\\n        x = k;\\n        val = value;\\n    }\\n    \\n    bool consec(int num) \\n    {\\n        if(q.size() >= x) \\n        {\\n            int front = q.front();\\n            q.pop();\\n            if(front == val) \\n                count--;\\n        }\\n        if(num == val) \\n            count++;\\n        \\n        q.push(num);\\n        \\n        if(count == x) \\n            return true;\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    queue<int> q;\\n    int x;\\n    int count = 0;\\n    int val;\\n    \\n    DataStream(int value, int k) \\n    {\\n        x = k;\\n        val = value;\\n    }\\n    \\n    bool consec(int num) \\n    {\\n        if(q.size() >= x) \\n        {\\n            int front = q.front();\\n            q.pop();\\n            if(front == val) \\n                count--;\\n        }\\n        if(num == val) \\n            count++;\\n        \\n        q.push(num);\\n        \\n        if(count == x) \\n            return true;\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014910,
                "title": "python3-counting-solution-without-creating-queue-array",
                "content": "\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.key_ = value\\n        self.target_counter_ = k\\n        self.counter_ = 0\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.key_:\\n            self.counter_ += 1\\n            if self.counter_ == self.target_counter_:\\n                self.counter_ -= 1\\n                return True\\n        else:\\n            self.counter_ = 0\\n            return False\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.key_ = value\\n        self.target_counter_ = k\\n        self.counter_ = 0\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.key_:\\n            self.counter_ += 1\\n            if self.counter_ == self.target_counter_:\\n                self.counter_ -= 1\\n                return True\\n        else:\\n            self.counter_ = 0\\n            return False\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427164,
                "title": "easiest-sliding-window-based-solution-fully-commented",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int value=0,k=0;\\n    int i=0,j=0;\\n    vector<int>arr;\\n    int count=0;\\n    DataStream(int value, int k)//Constructor\\n    {\\n        this->value=value;\\n        this->k=k;\\n    }\\n    bool consec(int num) \\n    {\\n        int ans=false;\\n        //Calculation\\n        //Push the number in the array\\n        arr.push_back(num);\\n        if(arr[j]==value)\\n            count++;\\n        if(j-i+1<k)\\n        {\\n            j++;\\n            ans=false;\\n        }\\n        else if(j-i+1==k)//Window size reached\\n        {\\n            //Calculation->answer\\n            if(count==k)\\n                ans=true;\\n            //Undo the changes in the left window\\n            if(arr[i]==value)\\n                count--;\\n            //Slide the window  \\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int value=0,k=0;\\n    int i=0,j=0;\\n    vector<int>arr;\\n    int count=0;\\n    DataStream(int value, int k)//Constructor\\n    {\\n        this->value=value;\\n        this->k=k;\\n    }\\n    bool consec(int num) \\n    {\\n        int ans=false;\\n        //Calculation\\n        //Push the number in the array\\n        arr.push_back(num);\\n        if(arr[j]==value)\\n            count++;\\n        if(j-i+1<k)\\n        {\\n            j++;\\n            ans=false;\\n        }\\n        else if(j-i+1==k)//Window size reached\\n        {\\n            //Calculation->answer\\n            if(count==k)\\n                ans=true;\\n            //Undo the changes in the left window\\n            if(arr[i]==value)\\n                count--;\\n            //Slide the window  \\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126844,
                "title": "easy-solution-using-heap-of-size-k",
                "content": "\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int val,k;\\n    priority_queue<int>q;\\n    DataStream(int value, int k) {\\n        val=value;\\n        this->k=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=val){\\n            q = priority_queue <int>();\\n        }\\n        else{\\n            if(q.size()==k)return true;\\n            else if(q.size()<k){\\n                q.push(num);\\n            }\\n\\n        }\\n        return q.size()==k;\\n        \\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val,k;\\n    priority_queue<int>q;\\n    DataStream(int value, int k) {\\n        val=value;\\n        this->k=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=val){\\n            q = priority_queue <int>();\\n        }\\n        else{\\n            if(q.size()==k)return true;\\n            else if(q.size()<k){\\n                q.push(num);\\n            }\\n\\n        }\\n        return q.size()==k;\\n        \\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022553,
                "title": "java-c-simple-solution",
                "content": "\\n### Java\\n```\\nclass DataStream {\\n  private final int k;\\n  private final int value;\\n  private int countEquals = 0;\\n\\n  public DataStream(int value, int k) {\\n    this.k = k;\\n    this.value = value;\\n  }\\n\\n  public boolean consec(int num) {\\n    if (num == value)\\n      countEquals++;\\n    else\\n      countEquals = 0;\\n\\n    return countEquals >= k;\\n  }\\n}\\n```\\n\\n### C++\\n```\\nclass DataStream {\\n    int k;\\n    int value;\\n    int countEquals = 0;\\npublic:\\n    DataStream(int value, int k) {\\n        this->k = k;\\n        this->value = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if (num == value)\\n         countEquals++;\\n    else\\n      countEquals = 0;\\n\\n    return countEquals >= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\n  private final int k;\\n  private final int value;\\n  private int countEquals = 0;\\n\\n  public DataStream(int value, int k) {\\n    this.k = k;\\n    this.value = value;\\n  }\\n\\n  public boolean consec(int num) {\\n    if (num == value)\\n      countEquals++;\\n    else\\n      countEquals = 0;\\n\\n    return countEquals >= k;\\n  }\\n}\\n```\n```\\nclass DataStream {\\n    int k;\\n    int value;\\n    int countEquals = 0;\\npublic:\\n    DataStream(int value, int k) {\\n        this->k = k;\\n        this->value = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if (num == value)\\n         countEquals++;\\n    else\\n      countEquals = 0;\\n\\n    return countEquals >= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020410,
                "title": "consecutive-counter",
                "content": "```\\nclass DataStream {\\npublic:\\n    int val;\\n    int k;\\n    int cnt=0;\\n    \\n    DataStream(int value, int K) {\\n        val=value;\\n        k=K;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val)\\n        {\\n            cnt++;\\n            if(cnt>=k)\\n                return true;\\n            return false;\\n        }\\n        cnt=0;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val;\\n    int k;\\n    int cnt=0;\\n    \\n    DataStream(int value, int K) {\\n        val=value;\\n        k=K;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val)\\n        {\\n            cnt++;\\n            if(cnt>=k)\\n                return true;\\n            return false;\\n        }\\n        cnt=0;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018803,
                "title": "100-fastest-o-1-tc-and-sc-easy-to-understand-c-solution",
                "content": "## Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int val,k;\\n    int cnt=0;\\n    int ind=0;\\n    DataStream(int value, int key) {\\n        val= value;\\n        k= key;\\n    }\\n    \\n    bool consec(int num) {\\n        cnt++;\\n        if (num!= val){\\n            ind= cnt;\\n        }\\n        if (cnt<k)return false;\\n        if (cnt-ind <k)return false;\\n        return true;\\n        \\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation",
                    "Counting",
                    "Data Stream"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val,k;\\n    int cnt=0;\\n    int ind=0;\\n    DataStream(int value, int key) {\\n        val= value;\\n        k= key;\\n    }\\n    \\n    bool consec(int num) {\\n        cnt++;\\n        if (num!= val){\\n            ind= cnt;\\n        }\\n        if (cnt<k)return false;\\n        if (cnt-ind <k)return false;\\n        return true;\\n        \\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016635,
                "title": "c-o-1-solution",
                "content": "```\\nclass DataStream {\\npublic:\\n    int val,k,cnt;\\n    DataStream(int value, int k1) {\\n        val = value;\\n        k = k1;\\n        cnt=0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == val) cnt+=1;\\n        else cnt=0;\\n        if(cnt >= k) return true;\\n        return false;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val,k,cnt;\\n    DataStream(int value, int k1) {\\n        val = value;\\n        k = k1;\\n        cnt=0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == val) cnt+=1;\\n        else cnt=0;\\n        if(cnt >= k) return true;\\n        return false;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015682,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass DataStream {\\npublic:\\n    vector<int> nums;\\n    vector<bool> result;\\n    int len, val;\\n    DataStream(int value, int k) {\\n        nums = {};\\n        result = {};\\n        nums.push_back(value);\\n        len = k;\\n        val = value;\\n    }\\n    \\n    bool consec(int num) {\\n        int count = 0;\\n        nums.push_back(num);\\n        if(nums.size() < len){\\n            result.push_back(false);\\n            return false;\\n        }\\n        if(result.size()>0 && result[result.size()-1] == true){\\n            if(num == val){\\n                result.push_back(true);\\n                return true;\\n            }\\n            else{\\n                result.push_back(false);\\n                return false;\\n            }\\n        }\\n        if(nums.size() >= len){\\n            for(int i=nums.size()-1; i>nums.size()-len-1; i--){\\n                if(nums[i] == val){\\n                    count++;\\n                }\\n            }\\n            if(count == len){\\n                result.push_back(true);\\n                return true;\\n            }\\n        }\\n        result.push_back(false);\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    vector<int> nums;\\n    vector<bool> result;\\n    int len, val;\\n    DataStream(int value, int k) {\\n        nums = {};\\n        result = {};\\n        nums.push_back(value);\\n        len = k;\\n        val = value;\\n    }\\n    \\n    bool consec(int num) {\\n        int count = 0;\\n        nums.push_back(num);\\n        if(nums.size() < len){\\n            result.push_back(false);\\n            return false;\\n        }\\n        if(result.size()>0 && result[result.size()-1] == true){\\n            if(num == val){\\n                result.push_back(true);\\n                return true;\\n            }\\n            else{\\n                result.push_back(false);\\n                return false;\\n            }\\n        }\\n        if(nums.size() >= len){\\n            for(int i=nums.size()-1; i>nums.size()-len-1; i--){\\n                if(nums[i] == val){\\n                    count++;\\n                }\\n            }\\n            if(count == len){\\n                result.push_back(true);\\n                return true;\\n            }\\n        }\\n        result.push_back(false);\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015094,
                "title": "easy-and-understandable-c-beats-100-effecitive-code",
                "content": "# Code\\n```\\nclass DataStream {\\npublic:\\n    int val=0,t=0;\\n    int cnt=0;\\n    DataStream(int value, int k) {\\n        val=value;\\n        t=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=val)\\n            cnt=0;\\n        if(num==val)\\n            cnt++;\\n    return cnt>=t?1:0;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val=0,t=0;\\n    int cnt=0;\\n    DataStream(int value, int k) {\\n        val=value;\\n        t=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=val)\\n            cnt=0;\\n        if(num==val)\\n            cnt++;\\n    return cnt>=t?1:0;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014999,
                "title": "c-java-python3-counter",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7360be4d63ffa8b13518401baa628a6f6800d326) for solutions of weekly 95. \\n\\n**Intuition**\\nHere we can use a counter to count the number of occurrence of `num` as of now. \\n**Implementation**\\n**C++**\\n```\\nclass DataStream {\\n    int value = 0, k = 0, cnt = 0; \\npublic:\\n    DataStream(int value, int k) : value(value), k(k) {}\\n    \\n    bool consec(int num) {\\n        if (value == num) ++cnt; \\n        else cnt = 0; \\n        return cnt >= k; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass DataStream {\\n    private int value = 0, k = 0, cnt = 0; \\n\\n    public DataStream(int value, int k) {\\n        this.value = value; \\n        this.k = k; \\n    }\\n    \\n    public boolean consec(int num) {\\n        if (value == num) ++cnt; \\n        else cnt = 0; \\n        return cnt >= k; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k \\n        self.cnt = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.value: self.cnt += 1\\n        else: self.cnt = 0 \\n        return self.cnt >= self.k \\n```\\n**Complexity**\\nTime `O(1)` \\nSpace `O(1)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass DataStream {\\n    int value = 0, k = 0, cnt = 0; \\npublic:\\n    DataStream(int value, int k) : value(value), k(k) {}\\n    \\n    bool consec(int num) {\\n        if (value == num) ++cnt; \\n        else cnt = 0; \\n        return cnt >= k; \\n    }\\n};\\n```\n```\\nclass DataStream {\\n    private int value = 0, k = 0, cnt = 0; \\n\\n    public DataStream(int value, int k) {\\n        this.value = value; \\n        this.k = k; \\n    }\\n    \\n    public boolean consec(int num) {\\n        if (value == num) ++cnt; \\n        else cnt = 0; \\n        return cnt >= k; \\n    }\\n}\\n```\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k \\n        self.cnt = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.value: self.cnt += 1\\n        else: self.cnt = 0 \\n        return self.cnt >= self.k \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014965,
                "title": "python3-sol-for-reference",
                "content": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.count = 0 \\n        self.value = value\\n        self.k = k\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.value:\\n            self.count += 1\\n        else: \\n            self.count = 0 \\n            \\n        return self.count >= self.k",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.count = 0 \\n        self.value = value\\n        self.k = k\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.value:\\n            self.count += 1\\n        else: \\n            self.count = 0 \\n            \\n        return self.count >= self.k",
                "codeTag": "Java"
            },
            {
                "id": 4004934,
                "title": "simplest-c-code-self-explainatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- Every Operation is of O(1)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int k;\\n    int val;\\n    int res;\\n    DataStream(int value, int K) {\\n        val=value;\\n        k=K;\\n        res=0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val) res++;\\n        else res=0;\\n\\n        if(res>=k) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Queue",
                    "Counting",
                    "Data Stream"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int k;\\n    int val;\\n    int res;\\n    DataStream(int value, int K) {\\n        val=value;\\n        k=K;\\n        res=0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val) res++;\\n        else res=0;\\n\\n        if(res>=k) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670621,
                "title": "java-o-1-no-ds-solution",
                "content": "# Intuition\\nNo data structure used. You can just use count variable.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n# Code\\n```\\nclass DataStream {\\n\\n    int val, main, count;\\n    public DataStream(int value, int k) {\\n        val = value;\\n        main = k;\\n        count = 0;\\n    }\\n\\n    public boolean consec(int num) {\\n        if (num == val) count++;\\n        else count = 0;\\n        return count >= main;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n\\n    int val, main, count;\\n    public DataStream(int value, int k) {\\n        val = value;\\n        main = k;\\n        count = 0;\\n    }\\n\\n    public boolean consec(int num) {\\n        if (num == val) count++;\\n        else count = 0;\\n        return count >= main;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315545,
                "title": "c-o-1-space-100-tc-100-sc-simple-constant-variables-to-keep-track-of-last-value-frequency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the problem, we only need to have the idea of the last occurring element and it\\'s consecutive frequency in that stream. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize 4 variables n giving size of data stream to keep track of, val representing the element we want to serach for, lastVal to keep track of last occurring value in stream and freq to keep track of the last element in stream and update the current value.\\nThe initial values of lastVal should be -1 as it is not included in the data stream values and frequency variable should hold zero.\\n\\nWhenever we encounter an element check if the element is equal to last value, if it is then update the frequency by one. If it is a new value change the last val and frequency values to match the update.\\n\\nTo return first check special case of n == 1, in that case it\\'s always true as long as current value if equal to last value. For any other cases check if current element is same as the value to be checked, if it is then check if frequency is larger than or equal to n.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) for each call\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int n, val, lastVal, freq;\\n    DataStream(int value, int k) {\\n        n = k;\\n        val = value;\\n        lastVal = -1;\\n        freq = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(n == 1)  return num == val;\\n        if(num == lastVal) freq++;\\n        else{\\n            lastVal = num;\\n            freq = 1;\\n        }\\n        return num == val ? freq >= n : false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int n, val, lastVal, freq;\\n    DataStream(int value, int k) {\\n        n = k;\\n        val = value;\\n        lastVal = -1;\\n        freq = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(n == 1)  return num == val;\\n        if(num == lastVal) freq++;\\n        else{\\n            lastVal = num;\\n            freq = 1;\\n        }\\n        return num == val ? freq >= n : false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160030,
                "title": "java-counting-o-1-time-space",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n    private int count;\\n    private int value;\\n    private int k; \\n\\n    public DataStream(int value, int k) {\\n        this.value = value;\\n        this.k = k;\\n        count = 0;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num != value){\\n            count = 0;\\n            return false;\\n        }\\n        return ++count >= k;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    private int count;\\n    private int value;\\n    private int k; \\n\\n    public DataStream(int value, int k) {\\n        this.value = value;\\n        this.k = k;\\n        count = 0;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num != value){\\n            count = 0;\\n            return false;\\n        }\\n        return ++count >= k;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018383,
                "title": "javascript-o-1-time-space",
                "content": "```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function(value, k) {\\n    this.value = value;\\n    this.count = 0;\\n    this.k = k;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function(num) {\\n    this.count = num !== this.value ? 0 : this.count + 1;\\n    return this.count >= this.k;\\n};\\n\\n/** \\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function(value, k) {\\n    this.value = value;\\n    this.count = 0;\\n    this.k = k;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function(num) {\\n    this.count = num !== this.value ? 0 : this.count + 1;\\n    return this.count >= this.k;\\n};\\n\\n/** \\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015181,
                "title": "ruby",
                "content": "\\n# Code\\n```\\nclass DataStream\\n=begin\\n  :type value: Integer\\n  :type k: Integer\\n=end\\n  def initialize(value, k)\\n    @value = value\\n    @k = k\\n    @count = 0\\n  end\\n\\n=begin\\n  :type num: Integer\\n  :rtype: Boolean\\n=end\\n  def consec(num)\\n    if num == @value\\n      @count += 1\\n      @count >= @k\\n    else\\n      @count = 0\\n      false\\n    end\\n  end\\nend\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream.new(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass DataStream\\n=begin\\n  :type value: Integer\\n  :type k: Integer\\n=end\\n  def initialize(value, k)\\n    @value = value\\n    @k = k\\n    @count = 0\\n  end\\n\\n=begin\\n  :type num: Integer\\n  :rtype: Boolean\\n=end\\n  def consec(num)\\n    if num == @value\\n      @count += 1\\n      @count >= @k\\n    else\\n      @count = 0\\n      false\\n    end\\n  end\\nend\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream.new(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014939,
                "title": "python-o-1-time-and-space",
                "content": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.k = k\\n        self.val = value\\n        self.t = k\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if self.t > 0:\\n            self.t -= 1\\n            \\n        if num != self.val:\\n            self.t = self.k\\n        \\n        if self.t:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.k = k\\n        self.val = value\\n        self.t = k\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if self.t > 0:\\n            self.t -= 1\\n            \\n        if num != self.val:\\n            self.t = self.k\\n        \\n        if self.t:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014932,
                "title": "easy-short-efficient-clean-code",
                "content": "```c++\\nclass DataStream {\\npublic:\\ntypedef long long ll;\\npublic:\\n    ll val, k, pre, ts;\\n    DataStream(int value, int K) {\\n        val=value, k=K;\\n        pre=-1, ts=0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=val){\\n            pre=ts;\\n        }\\n        bool ans=ts-pre>=k;\\n        ++ts;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass DataStream {\\npublic:\\ntypedef long long ll;\\npublic:\\n    ll val, k, pre, ts;\\n    DataStream(int value, int K) {\\n        val=value, k=K;\\n        pre=-1, ts=0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=val){\\n            pre=ts;\\n        }\\n        bool ans=ts-pre>=k;\\n        ++ts;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096479,
                "title": "c-beginner-s-friendly-solution",
                "content": "# Intuition\\nAs It is a queue based problem so we have to used queue.\\nThe question only means that : \\nif the value arrived greater or equal to k times in the **continuous manner** then return true else in all condition return false & store all the values in queue.```\\nCode block\\n```\\n\\n# Approach\\nstep 1 -> Initiate the queue & value of k & value* in constructor.\\nStep 2 -> Write all the condition stated in intuition and return.\\n\\n# Complexity\\n- Time complexity:\\nAdd your time complexity here, e.g. $$O(1)$$\\n\\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$\\n\\n# Code\\n```\\nclass DataStream {\\n\\n    queue<int> q;\\n    int k, value;\\n    int cnt = 1;\\npublic:\\n    DataStream(int value, int k) {\\n        this->value = value;\\n        this->k = k;\\n    }\\n    \\n    bool consec(int num) {\\n        \\n        if(cnt < k && num == value){\\n            q.push(num);\\n            cnt++;\\n            return false;\\n        }\\n\\n        if(cnt >= k && num == value){\\n            q.push(num);\\n            cnt++;\\n            return true;\\n        }\\n\\n        else{\\n            q.push(num);\\n            cnt = 1;\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nCode block\\n```\n```\\nclass DataStream {\\n\\n    queue<int> q;\\n    int k, value;\\n    int cnt = 1;\\npublic:\\n    DataStream(int value, int k) {\\n        this->value = value;\\n        this->k = k;\\n    }\\n    \\n    bool consec(int num) {\\n        \\n        if(cnt < k && num == value){\\n            q.push(num);\\n            cnt++;\\n            return false;\\n        }\\n\\n        if(cnt >= k && num == value){\\n            q.push(num);\\n            cnt++;\\n            return true;\\n        }\\n\\n        else{\\n            q.push(num);\\n            cnt = 1;\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092012,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass DataStream {\\n    int cap,val;\\n    int c;\\n    public DataStream(int value, int k) {\\n        cap=k;\\n        val=value;\\n        c=0;\\n    }\\n    public boolean consec(int num) {\\n        if(val==num) c++;\\n        else c=0;\\n        if(c>=cap) return true;\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    int cap,val;\\n    int c;\\n    public DataStream(int value, int k) {\\n        cap=k;\\n        val=value;\\n        c=0;\\n    }\\n    public boolean consec(int num) {\\n        if(val==num) c++;\\n        else c=0;\\n        if(c>=cap) return true;\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087045,
                "title": "solution-for-o-n-time-complexity-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream \\n{\\n    int count=0;\\n    int value;\\n    int k;\\n\\n    public DataStream(int value, int k) \\n    {\\n        count=0;\\n        this.value=value;\\n        this.k=k;\\n        \\n    }\\n    \\n    public boolean consec(int num) \\n    {\\n        if(num==value)\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count=0;\\n        }\\n        if(count>=k) return true;\\n        return false;\\n        \\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream \\n{\\n    int count=0;\\n    int value;\\n    int k;\\n\\n    public DataStream(int value, int k) \\n    {\\n        count=0;\\n        this.value=value;\\n        this.k=k;\\n        \\n    }\\n    \\n    public boolean consec(int num) \\n    {\\n        if(num==value)\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count=0;\\n        }\\n        if(count>=k) return true;\\n        return false;\\n        \\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057522,
                "title": "java-o-1-solution-using-without-any-extra-space",
                "content": "# Intuition\\n  Simple approach man we just have to check the current number is equals to value or not if it is equal then we have to increment count otherwise there is no point to include it in our counting , simply set count as 0.\\n\\nIn the end if count>=k then only we have to return true otherwise simply return false.\\n\\n\\n# Complexity\\n- Time complexity:\\n  O(1)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass DataStream {\\n    int k,value,cnt;\\n    public DataStream(int value, int k) {\\n        this.k=k;\\n        this.value=value;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num==value) cnt++;\\n        else cnt=0;\\n        return cnt>=k;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    int k,value,cnt;\\n    public DataStream(int value, int k) {\\n        this.k=k;\\n        this.value=value;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num==value) cnt++;\\n        else cnt=0;\\n        return cnt>=k;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045264,
                "title": "just-using-base-case-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n22 ms \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n93.7 mb\\n# Code\\n```\\nclass DataStream {\\n\\n    int val, main, count;\\n    public DataStream(int value, int k) {\\n        val = value;\\n        main = k;\\n        count = 0;\\n    }\\n\\n    public boolean consec(int num) {\\n        if (num == val) count++;\\n        else count = 0;\\n        return count >= main;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n\\n    int val, main, count;\\n    public DataStream(int value, int k) {\\n        val = value;\\n        main = k;\\n        count = 0;\\n    }\\n\\n    public boolean consec(int num) {\\n        if (num == val) count++;\\n        else count = 0;\\n        return count >= main;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018097,
                "title": "o-1-solution-using-hash-map-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.val = value\\n        self.k = k\\n        self.queue = []\\n        self.stream = collections.defaultdict(int)\\n\\n    def consec(self, num: int) -> bool:\\n        self.queue.append(num)\\n        self.stream[num] += 1\\n        if len(self.queue) > self.k:\\n            rmv = self.queue.pop(0)\\n            self.stream[rmv] -= 1\\n        return self.stream[self.val] == self.k\\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.val = value\\n        self.k = k\\n        self.queue = []\\n        self.stream = collections.defaultdict(int)\\n\\n    def consec(self, num: int) -> bool:\\n        self.queue.append(num)\\n        self.stream[num] += 1\\n        if len(self.queue) > self.k:\\n            rmv = self.queue.pop(0)\\n            self.stream[rmv] -= 1\\n        return self.stream[self.val] == self.k\\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017025,
                "title": "java-ac-solution-using-queue-and-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n    int value;\\n    int k;\\n    Queue<Integer> q;\\n    int count;\\n    int equalityCount;\\n    public DataStream(int value, int k) {\\n        q = new LinkedList<>();\\n        this.value = value;\\n        this.k = k;\\n        this.count = 0;\\n        this.equalityCount = 0;\\n    }\\n    \\n    public boolean consec(int num) {\\n        count++;\\n        if(count < k){\\n            q.add(num);\\n            \\n            if(num == value){\\n                equalityCount++;\\n            }\\n            return false;\\n        }\\n        if(count == k){\\n            q.add(num);\\n            if(num == value){\\n                equalityCount++;\\n            }\\n\\n            if(equalityCount == k){\\n                return true;\\n            }\\n        }\\n        if(count > k){\\n            int n = q.remove();\\n            if(n == value){\\n                equalityCount--;\\n            }\\n\\n\\n            q.add(num);\\n            if(num == value){\\n                equalityCount++;\\n            }\\n\\n\\n            if(equalityCount == k){\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n}\\n \\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    int value;\\n    int k;\\n    Queue<Integer> q;\\n    int count;\\n    int equalityCount;\\n    public DataStream(int value, int k) {\\n        q = new LinkedList<>();\\n        this.value = value;\\n        this.k = k;\\n        this.count = 0;\\n        this.equalityCount = 0;\\n    }\\n    \\n    public boolean consec(int num) {\\n        count++;\\n        if(count < k){\\n            q.add(num);\\n            \\n            if(num == value){\\n                equalityCount++;\\n            }\\n            return false;\\n        }\\n        if(count == k){\\n            q.add(num);\\n            if(num == value){\\n                equalityCount++;\\n            }\\n\\n            if(equalityCount == k){\\n                return true;\\n            }\\n        }\\n        if(count > k){\\n            int n = q.remove();\\n            if(n == value){\\n                equalityCount--;\\n            }\\n\\n\\n            q.add(num);\\n            if(num == value){\\n                equalityCount++;\\n            }\\n\\n\\n            if(equalityCount == k){\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n}\\n \\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968563,
                "title": "golang-simple-o-n-solution",
                "content": "# Code\\n```go\\ntype DataStream struct {\\n\\tvalue int\\n\\tneedRepeat int\\n\\tcurrRepeat int\\n}\\n\\n\\nfunc Constructor(value int, k int) DataStream {\\n\\treturn DataStream{\\n\\t\\tvalue: value,\\n\\t\\tneedRepeat: k,\\n\\t\\tcurrRepeat: 0,\\n\\t}\\n}\\n\\n\\nfunc (ds *DataStream) Consec(num int) bool {\\n\\tif num == ds.value {\\n\\t\\tds.currRepeat++\\n\\t\\treturn ds.currRepeat >= ds.needRepeat\\n\\t}\\n\\tds.currRepeat = 0\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype DataStream struct {\\n\\tvalue int\\n\\tneedRepeat int\\n\\tcurrRepeat int\\n}\\n\\n\\nfunc Constructor(value int, k int) DataStream {\\n\\treturn DataStream{\\n\\t\\tvalue: value,\\n\\t\\tneedRepeat: k,\\n\\t\\tcurrRepeat: 0,\\n\\t}\\n}\\n\\n\\nfunc (ds *DataStream) Consec(num int) bool {\\n\\tif num == ds.value {\\n\\t\\tds.currRepeat++\\n\\t\\treturn ds.currRepeat >= ds.needRepeat\\n\\t}\\n\\tds.currRepeat = 0\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949366,
                "title": "beats-100-00-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUnderstanding the code will explain the approach it self. As easy as it looks.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function(value, k) {\\n    this.value = value\\n    this.k = k\\n    this.last_wrong_value_position = 0\\n    this.current_count = 0\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function(num) {\\n    this.current_count += 1\\n    if (num != this.value)\\n      this.last_wrong_value_position = this.current_count\\n\\n    if (this.current_count - this.last_wrong_value_position >= this.k)\\n        return true\\n    else\\n      return false\\n    end\\n};\\n\\n/** \\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function(value, k) {\\n    this.value = value\\n    this.k = k\\n    this.last_wrong_value_position = 0\\n    this.current_count = 0\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function(num) {\\n    this.current_count += 1\\n    if (num != this.value)\\n      this.last_wrong_value_position = this.current_count\\n\\n    if (this.current_count - this.last_wrong_value_position >= this.k)\\n        return true\\n    else\\n      return false\\n    end\\n};\\n\\n/** \\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942262,
                "title": "interesting-solution",
                "content": "class DataStream {\\n    private:\\n    unordered_map<int,vector<int>> m;\\n    int val;\\n    int k;\\n    int idx;\\npublic:\\n    DataStream(int value, int K) {\\n        m.clear();\\n        val=value;\\n        k=K;\\n        idx=-1;\\n    }\\n    \\n    bool consec(int num) {\\n        idx++;\\n        m[num].emplace_back(idx);\\n\\n        if(idx+1<k){\\n            return false;\\n        }\\n        \\n        int left=idx-k+1;\\n        int right=idx;\\n        \\n        int a=lower_bound(m[val].begin(),m[val].end(),left)-m[val].begin();\\n        int b=upper_bound(m[val].begin(),m[val].end(),right)-m[val].begin();\\n        \\n        int freq=b-a;\\n        //cout<<freq<<endl;\\n        \\n        return freq>=k;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */",
                "solutionTags": [],
                "code": "class DataStream {\\n    private:\\n    unordered_map<int,vector<int>> m;\\n    int val;\\n    int k;\\n    int idx;\\npublic:\\n    DataStream(int value, int K) {\\n        m.clear();\\n        val=value;\\n        k=K;\\n        idx=-1;\\n    }\\n    \\n    bool consec(int num) {\\n        idx++;\\n        m[num].emplace_back(idx);\\n\\n        if(idx+1<k){\\n            return false;\\n        }\\n        \\n        int left=idx-k+1;\\n        int right=idx;\\n        \\n        int a=lower_bound(m[val].begin(),m[val].end(),left)-m[val].begin();\\n        int b=upper_bound(m[val].begin(),m[val].end(),right)-m[val].begin();\\n        \\n        int freq=b-a;\\n        //cout<<freq<<endl;\\n        \\n        return freq>=k;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */",
                "codeTag": "C++"
            },
            {
                "id": 3925980,
                "title": "beats-100-in-time-js-code-with-detailed-explanation",
                "content": "# Intuition\\nOn seeing the question, first solution which came up to my mind was to store it an a queue and if length of the queue is greater than or equal to k, then check the last k elements individually. If any element is not equal to value, return false. This takes **O(K)** time complexity and space complexity.\\nOn understanding the question properly and looking at hint, I understood that we do not have to store the elements, we only need to keep the track of the last element which is not equal to the value. \\nFor that what we can do is create 2 variables. \\n- One is to count the total data in the data stream.\\n- Other is to count the elements in the data which are equal to value.\\n\\nAt the end, we return true only in one case - if the total elements in the data stream which are equal to value are greater than the k. \\nIn all other case we return false.\\n\\n# Approach\\n- Initialize two variables - length and count.\\n- Increment length at every consec function call.\\n- Increment count only if num === value. \\n- If num !== value, resent count variable to 0.\\n- Check if length < k. If so return false.\\n- If not, check if count is >= k. If so, return true. Else return false.\\n\\n# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Contact Me\\nIf you have any doubt, you can contact me via \\n```\\nhttps://prateekabbi.netlify.app/\\n```\\n\\n# Code\\n```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function(value, k) {\\n    this.k = k\\n    this.val = value\\n\\n    this.length = 0 // Total number of elements in data stream\\n    this.count = 0 // Last elements which are equal to value\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function(num) {\\n    this.length++\\n\\n    if (num === this.val) this.count++\\n    else this.count = 0\\n\\n    if (this.length < this.k) return false\\n\\n    if (this.count >= this.k) return true\\n    return false\\n};\\n\\n/** \\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue",
                    "Counting"
                ],
                "code": "```\\nhttps://prateekabbi.netlify.app/\\n```\n```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function(value, k) {\\n    this.k = k\\n    this.val = value\\n\\n    this.length = 0 // Total number of elements in data stream\\n    this.count = 0 // Last elements which are equal to value\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function(num) {\\n    this.length++\\n\\n    if (num === this.val) this.count++\\n    else this.count = 0\\n\\n    if (this.length < this.k) return false\\n\\n    if (this.count >= this.k) return true\\n    return false\\n};\\n\\n/** \\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3920677,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n\\n    var lastKIntegers = 0;\\n    var target = 0;\\n    final List<int> res = [];\\n\\n    DataStream(int value, int k) {\\n        lastKIntegers = k;\\n        target = value;\\n    }\\n    \\n    bool consec(int num) {\\n        res.add(num);\\n        if (res.length < lastKIntegers) {\\n            return false;\\n        }\\n        var c = 0;\\n        for (int i = res.length - 1; i >= res.length - lastKIntegers; i--) {\\n            if (res[i] == target) {\\n                c += 1;\\n            }\\n        }\\n        return c == lastKIntegers;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = DataStream(value, k);\\n * bool param1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass DataStream {\\n\\n    var lastKIntegers = 0;\\n    var target = 0;\\n    final List<int> res = [];\\n\\n    DataStream(int value, int k) {\\n        lastKIntegers = k;\\n        target = value;\\n    }\\n    \\n    bool consec(int num) {\\n        res.add(num);\\n        if (res.length < lastKIntegers) {\\n            return false;\\n        }\\n        var c = 0;\\n        for (int i = res.length - 1; i >= res.length - lastKIntegers; i--) {\\n            if (res[i] == target) {\\n                c += 1;\\n            }\\n        }\\n        return c == lastKIntegers;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = DataStream(value, k);\\n * bool param1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896489,
                "title": "22ms-98-java-simple-variables",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust count consecutive num==value if its >= k then return true\\nif num != value restart the count\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n\\n    int val;\\n    int k;\\n    int count;\\n    public DataStream(int value, int k) {\\n        val = value;\\n        this.k = k;\\n        count = 0;\\n    }\\n\\n    public boolean consec(int num) {\\n        if (num == val) count++;\\n        else count = 0;\\n        return count >= k;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n\\n    int val;\\n    int k;\\n    int count;\\n    public DataStream(int value, int k) {\\n        val = value;\\n        this.k = k;\\n        count = 0;\\n    }\\n\\n    public boolean consec(int num) {\\n        if (num == val) count++;\\n        else count = 0;\\n        return count >= k;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891238,
                "title": "js-runtime-beats-100-find-consecutive-integers-from-a-data-stream",
                "content": "# Intuition\\nI originally solved the problem by using the length of the integer stream, returning `false` if the array was less than `k`, traversing the array on each `consec` call to check if the integers were each equal to `value`, and removing the first integer if the array was larger than `k`.\\n\\n# Approach\\nBy wanting to optimize, I realized that the length of the stream of integers being fixed, it was possible to deduce the minimum number of calls to `consec` necessary before being able to know that there was a sequence of integers of length `k`, each being `n` **without the need to create a loop**.\\n\\n# Complexity\\nThe time complexity and the space complexity of the provided code are **O(1)**, which means they are constant and do not depend on the size of the input or any other external factors.\\n\\n# Code\\n```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function (value, k) {\\n  this.callCount = 0;\\n  this.callCountBeforeEqualInts = 0;\\n  this.k = k;\\n  this.value = value;\\n};\\n\\n/**\\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function (num) {\\n  this.callCount++;\\n\\n  if (this.callCountBeforeEqualInts !== 0) {\\n    this.callCountBeforeEqualInts--;\\n  }\\n\\n  if (num !== this.value) {\\n    this.callCountBeforeEqualInts = this.k;\\n  }\\n\\n  if (this.callCount < this.k) {\\n    return false;\\n  }\\n\\n  return this.callCountBeforeEqualInts === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function (value, k) {\\n  this.callCount = 0;\\n  this.callCountBeforeEqualInts = 0;\\n  this.k = k;\\n  this.value = value;\\n};\\n\\n/**\\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function (num) {\\n  this.callCount++;\\n\\n  if (this.callCountBeforeEqualInts !== 0) {\\n    this.callCountBeforeEqualInts--;\\n  }\\n\\n  if (num !== this.value) {\\n    this.callCountBeforeEqualInts = this.k;\\n  }\\n\\n  if (this.callCount < this.k) {\\n    return false;\\n  }\\n\\n  return this.callCountBeforeEqualInts === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877818,
                "title": "c-simple-fast",
                "content": "```\\nclass DataStream {\\n    int k_;\\n    int value_;\\n    int cnt_;\\npublic:\\n    DataStream(int value, int k) {\\n        value_ = value;\\n        k_ = k;\\n        cnt_ = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == value_)\\n            ++cnt_;\\n        else\\n            cnt_ = 0;\\n        return cnt_ >= k_;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass DataStream {\\n    int k_;\\n    int value_;\\n    int cnt_;\\npublic:\\n    DataStream(int value, int k) {\\n        value_ = value;\\n        k_ = k;\\n        cnt_ = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == value_)\\n            ++cnt_;\\n        else\\n            cnt_ = 0;\\n        return cnt_ >= k_;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873507,
                "title": "100-easy-simple-to-understand-solutions",
                "content": "# Intuition\\nIf question ask to check the last `k` parsed integers are equal to `value` or not. Then why not to only count last `K` integers if they are equal to `value`.\\n\\n# Approach\\nTake a counter & only increment if `num` is equal to value.\\nif counter at any moment becomes equal to `K`, that means its satisifying the condition, thus returns $$true$$ else $$false$$.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```java []\\nclass DataStream {\\n    private int val = 0;\\n    private int pastK = 0, k = 0;\\n\\n    public DataStream(int value, int k) {\\n        this.val = value;\\n        this.pastK = 0;\\n        this.k = k;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num == val) {\\n            pastK++;\\n        } else {\\n            pastK = 0;\\n        }\\n        // there can be exactly K or more than k numbers = val\\n        return k <= pastK;\\n    }\\n}\\n```\\n```cpp []\\nclass DataStream {\\n    private:\\n        int val = 0;\\n        int pastK = 0, k = 0;\\n\\n    public:\\n        DataStream(int value, int k) {\\n            this->val = value;\\n            this->pastK = 0;\\n            this->k = k;\\n        }\\n\\n        bool consec(int num) {\\n            if(num == val) {\\n                pastK++;\\n            } else {\\n                pastK = 0;\\n            }\\n            // there can be exactly K or more than k numbers = val\\n            return k <= pastK;\\n        }\\n};\\n```\\n```python []\\nclass DataStream:\\n    def __init__(self, value: int, k: int):\\n        self.val = value\\n        self.pastK = 0\\n        self.k = k\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.val:\\n            self.pastK += 1\\n        else:\\n            self.pastK = 0\\n        # there can be exactly K or more than k numbers = val\\n        return self.k <= self.pastK\\n\\n```\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/6263c6a8-51a7-42b2-8662-d842c5fb84e2_1691348418.2592487.webp\" width=\"60%\" height=\"60%\" alt=\"649768ad8f25f.webp\">\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```java []\\nclass DataStream {\\n    private int val = 0;\\n    private int pastK = 0, k = 0;\\n\\n    public DataStream(int value, int k) {\\n        this.val = value;\\n        this.pastK = 0;\\n        this.k = k;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num == val) {\\n            pastK++;\\n        } else {\\n            pastK = 0;\\n        }\\n        // there can be exactly K or more than k numbers = val\\n        return k <= pastK;\\n    }\\n}\\n```\n```cpp []\\nclass DataStream {\\n    private:\\n        int val = 0;\\n        int pastK = 0, k = 0;\\n\\n    public:\\n        DataStream(int value, int k) {\\n            this->val = value;\\n            this->pastK = 0;\\n            this->k = k;\\n        }\\n\\n        bool consec(int num) {\\n            if(num == val) {\\n                pastK++;\\n            } else {\\n                pastK = 0;\\n            }\\n            // there can be exactly K or more than k numbers = val\\n            return k <= pastK;\\n        }\\n};\\n```\n```python []\\nclass DataStream:\\n    def __init__(self, value: int, k: int):\\n        self.val = value\\n        self.pastK = 0\\n        self.k = k\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.val:\\n            self.pastK += 1\\n        else:\\n            self.pastK = 0\\n        # there can be exactly K or more than k numbers = val\\n        return self.k <= self.pastK\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862187,
                "title": "c-based-solution-using-a-vector",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    vector<int> q;\\n    int K,val,count=0;\\n    DataStream(int value, int k) {\\n        val=value;K=k;\\n    }\\n    \\n    bool consec(int num) {\\n        q.push_back(num);\\n        if(num==val){\\n            count++;\\n        }\\n        else{\\n            count=0;\\n        }\\n        if(q.size()<K){\\n            return false;\\n        }\\n        if(count>=K){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    vector<int> q;\\n    int K,val,count=0;\\n    DataStream(int value, int k) {\\n        val=value;K=k;\\n    }\\n    \\n    bool consec(int num) {\\n        q.push_back(num);\\n        if(num==val){\\n            count++;\\n        }\\n        else{\\n            count=0;\\n        }\\n        if(q.size()<K){\\n            return false;\\n        }\\n        if(count>=K){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826106,
                "title": "c-solution-stack-beats-100-in-runtime",
                "content": "\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    stack<int>st;\\n    int v,len;\\n    DataStream(int value, int k) {\\n        v=value;\\n        len=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(!st.empty() && st.top()==num && st.size()<len){\\n            st.push(num);\\n        }\\n        else if(!st.empty() && st.top()==num && st.size()==len){\\n            return true;\\n        }\\n        else if(!st.empty() && st.top()!=num){\\n            while(!st.empty()){\\n                st.pop();\\n            }\\n            st.push(num);\\n        }\\n        else{\\n            st.push(num);\\n        }\\n        if(st.size()==len && st.top()==v)\\n            return true;\\n        else if(st.size()<len && st.top()==v)\\n            return false;\\n        else{\\n            while(!st.empty()){\\n                st.pop();\\n            }\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    stack<int>st;\\n    int v,len;\\n    DataStream(int value, int k) {\\n        v=value;\\n        len=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(!st.empty() && st.top()==num && st.size()<len){\\n            st.push(num);\\n        }\\n        else if(!st.empty() && st.top()==num && st.size()==len){\\n            return true;\\n        }\\n        else if(!st.empty() && st.top()!=num){\\n            while(!st.empty()){\\n                st.pop();\\n            }\\n            st.push(num);\\n        }\\n        else{\\n            st.push(num);\\n        }\\n        if(st.size()==len && st.top()==v)\\n            return true;\\n        else if(st.size()<len && st.top()==v)\\n            return false;\\n        else{\\n            while(!st.empty()){\\n                st.pop();\\n            }\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820523,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nez read the code and u wil understand ;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass DataStream {\\nprivate:\\nint x;\\nint y;\\nint consecu = 0;\\npublic:\\n    DataStream(int value, int k) {\\n         x= value;\\n         y = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == x){\\n            consecu++;\\n        }\\n        else{\\n            consecu = 0 ;\\n        }\\n        return consecu >= y;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\nprivate:\\nint x;\\nint y;\\nint consecu = 0;\\npublic:\\n    DataStream(int value, int k) {\\n         x= value;\\n         y = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == x){\\n            consecu++;\\n        }\\n        else{\\n            consecu = 0 ;\\n        }\\n        return consecu >= y;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818393,
                "title": "simplest-solution-ever-no-need-to-put-sliding-window-forcefully-o-n-time-o-1-space-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given that k consecutive numbers should be equal to Value, so just iterate and maintain a count=0. When we get **num==Value** then increase the count and when we get different number that means this will not give answer and our streak breaks so put count = 0. \\n\\nWhen count reaches k then return true otherwise return false\\n\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int val;\\n    int k;\\n    int cnt=0;\\n    DataStream(int value, int k) {\\n        this->val=value;\\n        this->k=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val)\\n            cnt++;\\n        else\\n            cnt=0;\\n\\n        if(cnt < k)\\n            return false;\\n        else if(cnt==k){\\n            cnt--;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val;\\n    int k;\\n    int cnt=0;\\n    DataStream(int value, int k) {\\n        this->val=value;\\n        this->k=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val)\\n            cnt++;\\n        else\\n            cnt=0;\\n\\n        if(cnt < k)\\n            return false;\\n        else if(cnt==k){\\n            cnt--;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800270,
                "title": "javascript-93-88-faster-simplest-solution-with-explanation-queue-beg-to-adv",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function(value, k) {\\n    this.queue = []; // Initializating  an empty queue.\\n    this.value = value; // Initializating value.\\n    this.k = k; // Initializating k.\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function(num) {\\n    this.queue.push(num); // Adding elements in the queue.\\n    if(this.queue.length < this.k) return false; // if number of element queue is less then k, then return false.\\n    let i = this.queue.length - this.k; // By this we will get from which index we would like to check for value.\\n    while(i < this.queue.length) { // Loop for traversing the queue.\\n        if(this.queue[i] !== this.value) return false; // if queue element is not equal to value, then in that case return false.\\n        i++; // Updating the iterator.\\n    }\\n    return true; // If k elements are matching the value then its a true.\\n};\\n\\n/** \\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```\\n\\n## Found helpful, Do upvote !!",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function(value, k) {\\n    this.queue = []; // Initializating  an empty queue.\\n    this.value = value; // Initializating value.\\n    this.k = k; // Initializating k.\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function(num) {\\n    this.queue.push(num); // Adding elements in the queue.\\n    if(this.queue.length < this.k) return false; // if number of element queue is less then k, then return false.\\n    let i = this.queue.length - this.k; // By this we will get from which index we would like to check for value.\\n    while(i < this.queue.length) { // Loop for traversing the queue.\\n        if(this.queue[i] !== this.value) return false; // if queue element is not equal to value, then in that case return false.\\n        i++; // Updating the iterator.\\n    }\\n    return true; // If k elements are matching the value then its a true.\\n};\\n\\n/** \\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781999,
                "title": "sliding-window-approach-c-easy",
                "content": "# Code\\n```\\nclass DataStream {\\npublic:\\n    int *arr;\\n    int i,j,cntOfValue,val,K;\\n    DataStream(int value, int k) {\\n        arr = new int[100001];\\n        i=j=cntOfValue=0;\\n        val=value;\\n        K=k;\\n    }\\n    \\n    bool consec(int num) {\\n        arr[j]=num;\\n        if(num==val) cntOfValue++;\\n        bool flag=0;\\n\\n        if(j-i+1 == K){\\n            if(cntOfValue==K){\\n                flag=1;\\n            }\\n            if(arr[i++]==val) cntOfValue--;\\n\\n        }\\n        j++;\\n\\n        return flag;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int *arr;\\n    int i,j,cntOfValue,val,K;\\n    DataStream(int value, int k) {\\n        arr = new int[100001];\\n        i=j=cntOfValue=0;\\n        val=value;\\n        K=k;\\n    }\\n    \\n    bool consec(int num) {\\n        arr[j]=num;\\n        if(num==val) cntOfValue++;\\n        bool flag=0;\\n\\n        if(j-i+1 == K){\\n            if(cntOfValue==K){\\n                flag=1;\\n            }\\n            if(arr[i++]==val) cntOfValue--;\\n\\n        }\\n        j++;\\n\\n        return flag;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759064,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream(object):\\n\\n    def __init__(self, value, k):\\n        self.value=value\\n        self.k=k\\n        self.count=0\\n        \\n        \\n        \\n\\n    def consec(self, num):\\n        if num == self.value:\\n            self.count+=1\\n        else:\\n            self.count=0\\n        return self.count>=self.k\\n\\n      \\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass DataStream(object):\\n\\n    def __init__(self, value, k):\\n        self.value=value\\n        self.k=k\\n        self.count=0\\n        \\n        \\n        \\n\\n    def consec(self, num):\\n        if num == self.value:\\n            self.count+=1\\n        else:\\n            self.count=0\\n        return self.count>=self.k\\n\\n      \\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735767,
                "title": "no-queue-or-any-other-data-structure",
                "content": "\\n\\n# Code\\n```\\n\\nclass DataStream {\\n    private int count;\\n    private int value;\\n    private int k;\\n\\n    public DataStream(int value, int k) {\\n        count = 0;\\n        this.k = k;\\n        this.value = value;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if (num == value) {\\n            count++;\\n        } else {\\n            count = 0;\\n        }\\n\\n        if (count >= k) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Queue"
                ],
                "code": "```\\n\\nclass DataStream {\\n    private int count;\\n    private int value;\\n    private int k;\\n\\n    public DataStream(int value, int k) {\\n        count = 0;\\n        this.k = k;\\n        this.value = value;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if (num == value) {\\n            count++;\\n        } else {\\n            count = 0;\\n        }\\n\\n        if (count >= k) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724498,
                "title": "swift-using-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n    let value: Int\\n    let k: Int\\n    var counter = 0\\n\\n    init(_ value: Int, _ k: Int) {\\n        self.value = value\\n        self.k = k\\n    }\\n    \\n    func consec(_ num: Int) -> Bool {\\n        if num == value {\\n            counter += 1\\n        } else {\\n            counter = 0\\n        }\\n\\n        return counter >= k\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * let obj = DataStream(value, k)\\n * let ret_1: Bool = obj.consec(num)\\n */\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass DataStream {\\n    let value: Int\\n    let k: Int\\n    var counter = 0\\n\\n    init(_ value: Int, _ k: Int) {\\n        self.value = value\\n        self.k = k\\n    }\\n    \\n    func consec(_ num: Int) -> Bool {\\n        if num == value {\\n            counter += 1\\n        } else {\\n            counter = 0\\n        }\\n\\n        return counter >= k\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * let obj = DataStream(value, k)\\n * let ret_1: Bool = obj.consec(num)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712614,
                "title": "94-beats-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int count=0;  //total elements in data stream\\n    int last=0;    //frequency of last elements ==value\\n    int tempval;\\n    int tempk;\\n    DataStream(int value, int k) {\\n        tempval=value;\\n        tempk=k;\\n    }\\n    \\n    bool consec(int num) {\\n        count++;\\n       if(num==tempval){\\n          last++;\\n       }\\n       else{\\n           last=0;\\n       }\\n        if(count<tempk){\\n          return false;\\n        }\\n        else if(last>=tempk){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n};\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int count=0;  //total elements in data stream\\n    int last=0;    //frequency of last elements ==value\\n    int tempval;\\n    int tempk;\\n    DataStream(int value, int k) {\\n        tempval=value;\\n        tempk=k;\\n    }\\n    \\n    bool consec(int num) {\\n        count++;\\n       if(num==tempval){\\n          last++;\\n       }\\n       else{\\n           last=0;\\n       }\\n        if(count<tempk){\\n          return false;\\n        }\\n        else if(last>=tempk){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n};\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678894,
                "title": "simple-one-line-solution",
                "content": "# Intuition\\ncreate a `value counter` that tracks the amount of consecutive numbers submitted that are equaled to value. set the counter back to `0` if a number not equal to value is added. if the counter is ` >= k ` then return true.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int mvalue;\\n    int mk;\\n    int amt = 0;\\n    \\n    DataStream(int value, int k) {\\n        mvalue = value;\\n        mk = k;\\n    }\\n    \\n    bool consec(int num) {\\n        return ((++amt) *= (num == mvalue)) >= mk;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int mvalue;\\n    int mk;\\n    int amt = 0;\\n    \\n    DataStream(int value, int k) {\\n        mvalue = value;\\n        mk = k;\\n    }\\n    \\n    bool consec(int num) {\\n        return ((++amt) *= (num == mvalue)) >= mk;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672751,
                "title": "counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value,self.k=value,k\\n        self.count=self.prev_val=None\\n    \\n    def consec(self, num: int) -> bool:\\n        if self.prev_val==num==self.value:\\n            if self.count<self.k:self.count+=1\\n            if self.count==self.k :return True\\n            return False\\n        self.prev_val,self.count=num,1\\n        if self.count==self.k and num==self.value:return True\\n        return False\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Design",
                    "Counting"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value,self.k=value,k\\n        self.count=self.prev_val=None\\n    \\n    def consec(self, num: int) -> bool:\\n        if self.prev_val==num==self.value:\\n            if self.count<self.k:self.count+=1\\n            if self.count==self.k :return True\\n            return False\\n        self.prev_val,self.count=num,1\\n        if self.count==self.k and num==self.value:return True\\n        return False\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649671,
                "title": "easy-solution-java-sliding-window",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n    int value;\\n    int k;\\n    int i;\\n    int j;\\n    List<Integer>list;\\n    int count;\\n    public DataStream(int value, int k) \\n    {\\n        this.value=value;\\n        this.k=k;\\n        this.i=0;\\n        this.j=0;\\n        this.count=0;\\n        this.list=new ArrayList<>();\\n    }\\n    public boolean consec(int num) \\n    {\\n        boolean ans=false;\\n        list.add(num);\\n        \\n        if(list.get(j)==value)\\n        {\\n            count=count+1;\\n        }\\n        if((j-i+1)<k)\\n        {\\n            j=j+1;\\n            return false;\\n        }\\n        else if((j-i+1)==k)\\n        {\\n            if(count==k)\\n            {\\n                ans=true;\\n            }\\n            else\\n            {\\n                ans=false;\\n            }\\n            if(list.get(i)==value)\\n            {\\n                count=count-1;\\n            }\\n            i=i+1;\\n            j=j+1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass DataStream {\\n    int value;\\n    int k;\\n    int i;\\n    int j;\\n    List<Integer>list;\\n    int count;\\n    public DataStream(int value, int k) \\n    {\\n        this.value=value;\\n        this.k=k;\\n        this.i=0;\\n        this.j=0;\\n        this.count=0;\\n        this.list=new ArrayList<>();\\n    }\\n    public boolean consec(int num) \\n    {\\n        boolean ans=false;\\n        list.add(num);\\n        \\n        if(list.get(j)==value)\\n        {\\n            count=count+1;\\n        }\\n        if((j-i+1)<k)\\n        {\\n            j=j+1;\\n            return false;\\n        }\\n        else if((j-i+1)==k)\\n        {\\n            if(count==k)\\n            {\\n                ans=true;\\n            }\\n            else\\n            {\\n                ans=false;\\n            }\\n            if(list.get(i)==value)\\n            {\\n                count=count-1;\\n            }\\n            i=i+1;\\n            j=j+1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597712,
                "title": "2526-find-consecutive-integers-from-a-data-stream",
                "content": "\\n\\n# Code\\n```\\nclass DataStream {\\n    int value;\\n    int k;\\n    int i;\\n    int j;\\n    List<Integer>list;\\n    int count;\\n    public DataStream(int value, int k) {\\n        this.value = value;\\n        this.k = k;\\n        this.i=0;\\n        this.j=0;\\n        this.count=0;\\n        this.list = new ArrayList<>();\\n    }\\n    \\n    public boolean consec(int num) {\\n        boolean ans = false;\\n        list.add(num);\\n        if(list.get(j)==value){\\n            count++;\\n        }\\n        if((j-i+1)<k)\\n        {\\n            j=j+1;\\n            return false;\\n        }\\n        else if((j-i+1)==k)\\n        {\\n            if(count==k)\\n            {\\n                ans=true;\\n            }\\n            else\\n            {\\n                ans=false;\\n            }\\n            if(list.get(i)==value)\\n            {\\n                count=count-1;\\n            }\\n            i=i+1;\\n            j=j+1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */  \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    int value;\\n    int k;\\n    int i;\\n    int j;\\n    List<Integer>list;\\n    int count;\\n    public DataStream(int value, int k) {\\n        this.value = value;\\n        this.k = k;\\n        this.i=0;\\n        this.j=0;\\n        this.count=0;\\n        this.list = new ArrayList<>();\\n    }\\n    \\n    public boolean consec(int num) {\\n        boolean ans = false;\\n        list.add(num);\\n        if(list.get(j)==value){\\n            count++;\\n        }\\n        if((j-i+1)<k)\\n        {\\n            j=j+1;\\n            return false;\\n        }\\n        else if((j-i+1)==k)\\n        {\\n            if(count==k)\\n            {\\n                ans=true;\\n            }\\n            else\\n            {\\n                ans=false;\\n            }\\n            if(list.get(i)==value)\\n            {\\n                count=count-1;\\n            }\\n            i=i+1;\\n            j=j+1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518359,
                "title": "simple-c-solution-using-counter",
                "content": "```\\n\\ntypedef struct {\\n  int val;\\n  int expect;\\n  int k;\\n  int processed;\\n} DataStream;\\n\\nDataStream *dataStreamCreate(int value, int k) {\\n  DataStream *ds = (DataStream *)malloc(sizeof(DataStream));\\n  if (ds == NULL)\\n    return NULL;\\n\\n  ds->val = 0;\\n  ds->expect = value;\\n  ds->k = k;\\n  ds->processed = 0;\\n\\n  return ds;\\n}\\n\\nbool dataStreamConsec(DataStream *obj, int num) {\\n  if (obj->val != num) {\\n    obj->processed = 1;\\n    obj->val = num;\\n  } else {\\n    ++obj->processed;\\n  }\\n\\n  if (obj->processed >= obj->k && obj->val == obj->expect) {\\n    return true;\\n  } else {\\n    return false;\\n  }\\n}\\n\\nvoid dataStreamFree(DataStream *obj) { free(obj); }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\ntypedef struct {\\n  int val;\\n  int expect;\\n  int k;\\n  int processed;\\n} DataStream;\\n\\nDataStream *dataStreamCreate(int value, int k) {\\n  DataStream *ds = (DataStream *)malloc(sizeof(DataStream));\\n  if (ds == NULL)\\n    return NULL;\\n\\n  ds->val = 0;\\n  ds->expect = value;\\n  ds->k = k;\\n  ds->processed = 0;\\n\\n  return ds;\\n}\\n\\nbool dataStreamConsec(DataStream *obj, int num) {\\n  if (obj->val != num) {\\n    obj->processed = 1;\\n    obj->val = num;\\n  } else {\\n    ++obj->processed;\\n  }\\n\\n  if (obj->processed >= obj->k && obj->val == obj->expect) {\\n    return true;\\n  } else {\\n    return false;\\n  }\\n}\\n\\nvoid dataStreamFree(DataStream *obj) { free(obj); }\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3517141,
                "title": "python3-deque-solution-faster-easy-understanding",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeque \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass DataStream:\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k\\n        self.deque = deque()\\n        self.count = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if len(self.deque) == self.k:\\n            if self.deque[0] == self.value:\\n                self.count -= 1\\n            self.deque.popleft()\\n        self.deque.append(num)\\n        if num == self.value:\\n            self.count += 1\\n        return self.count == self.k\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Design",
                    "Queue",
                    "Counting"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass DataStream:\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k\\n        self.deque = deque()\\n        self.count = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if len(self.deque) == self.k:\\n            if self.deque[0] == self.value:\\n                self.count -= 1\\n            self.deque.popleft()\\n        self.deque.append(num)\\n        if num == self.value:\\n            self.count += 1\\n        return self.count == self.k\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501813,
                "title": "o-n-time-0-1-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int count=0;\\n    int value;\\n    int k;\\n    DataStream(int value, int k) {\\n        this->value=value;\\n        this->k=k;\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==value){\\n            count++;\\n        }else{\\n            count=0;\\n        }\\n        return count>=k;\\n    }\\n\\n    \\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int count=0;\\n    int value;\\n    int k;\\n    DataStream(int value, int k) {\\n        this->value=value;\\n        this->k=k;\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==value){\\n            count++;\\n        }else{\\n            count=0;\\n        }\\n        return count>=k;\\n    }\\n\\n    \\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500717,
                "title": "map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype DataStream struct {\\n    value int\\n    num int\\n    maps map[int]int\\n    \\n}\\n\\n\\nfunc Constructor(value int, k int) DataStream {\\n    return DataStream{value:value,num:k,maps:make(map[int]int,0)}\\n}\\n\\n\\nfunc (this *DataStream) Consec(num int) bool {\\n    if num == this.value{\\n        this.maps[num]++\\n    }else {\\n        this.maps = make(map[int]int,0)\\n\\n    }\\n    return this.maps[num] >= this.num\\n}\\n\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * obj := Constructor(value, k);\\n * param_1 := obj.Consec(num);\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype DataStream struct {\\n    value int\\n    num int\\n    maps map[int]int\\n    \\n}\\n\\n\\nfunc Constructor(value int, k int) DataStream {\\n    return DataStream{value:value,num:k,maps:make(map[int]int,0)}\\n}\\n\\n\\nfunc (this *DataStream) Consec(num int) bool {\\n    if num == this.value{\\n        this.maps[num]++\\n    }else {\\n        this.maps = make(map[int]int,0)\\n\\n    }\\n    return this.maps[num] >= this.num\\n}\\n\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * obj := Constructor(value, k);\\n * param_1 := obj.Consec(num);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484558,
                "title": "very-easy-two-pointer",
                "content": "# Intuition\\nwe only need to keep track of length of last elements which is equal to \\'value\\'.\\n\\n# Approach\\nTake two pointer \\'i\\' and \\'j\\' both equal to say value say \\'0\\'.\\nwhenver we will see the num== value then we incr the \\'j keeping \\'i\\' constant.\\nAnd when we will see num!= value then we will make both pointer equal to any \\'value\\'.\\nAny point of time \\'j-i\\' will give the length of last elements which have value== value.\\n\\n# Complexity\\n- Time complexity:\\n  O(1)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.i= 0\\n        self.j= 0\\n        self.value= value\\n        self.k= k\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if num== self.value:\\n            self.j+= 1\\n        else:\\n            self.i= self.j= 0\\n        return self.j - self.i >= self.k\\n\\n\\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.i= 0\\n        self.j= 0\\n        self.value= value\\n        self.k= k\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if num== self.value:\\n            self.j+= 1\\n        else:\\n            self.i= self.j= 0\\n        return self.j - self.i >= self.k\\n\\n\\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482828,
                "title": "rust-python-if-you-see-correct-number-increase-the-counter",
                "content": "# Intuition\\nIf you see a number you are searching for, increase the counter. Otherwise mark it as 0. Then check how big is the counter.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```Rust []\\nstruct DataStream {\\n  cnt: i32,\\n  val: i32,\\n  k: i32,\\n}\\n\\nimpl DataStream {\\n\\n  fn new(value: i32, k: i32) -> Self {\\n    return DataStream {cnt: 0, val: value, k: k};\\n  }\\n  \\n  fn consec(&mut self, num: i32) -> bool {\\n    if self.val == num {\\n      self.cnt += 1;\\n    } else {\\n      self.cnt = 0;\\n    }\\n    return self.cnt >= self.k;\\n  }\\n}\\n```\\n```python []\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n      self.cnt = 0\\n      self.val = value\\n      self.k = k\\n        \\n\\n    def consec(self, num: int) -> bool:\\n      if num == self.val:\\n        self.cnt += 1\\n      else:\\n        self.cnt = 0\\n\\n      return self.cnt >= self.k\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\nstruct DataStream {\\n  cnt: i32,\\n  val: i32,\\n  k: i32,\\n}\\n\\nimpl DataStream {\\n\\n  fn new(value: i32, k: i32) -> Self {\\n    return DataStream {cnt: 0, val: value, k: k};\\n  }\\n  \\n  fn consec(&mut self, num: i32) -> bool {\\n    if self.val == num {\\n      self.cnt += 1;\\n    } else {\\n      self.cnt = 0;\\n    }\\n    return self.cnt >= self.k;\\n  }\\n}\\n```\n```python []\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n      self.cnt = 0\\n      self.val = value\\n      self.k = k\\n        \\n\\n    def consec(self, num: int) -> bool:\\n      if num == self.val:\\n        self.cnt += 1\\n      else:\\n        self.cnt = 0\\n\\n      return self.cnt >= self.k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481941,
                "title": "my-thought-process-can-be-seen-on-all-of-my-dirty-solution-ts-js",
                "content": "\\n# Code\\n```\\nclass DataStream {\\n    protected parsed_nums: number[];\\n    protected value: number;\\n    protected k: number;\\n    // protected idx: number = 0; // capped at k\\n    protected count: number;\\n    constructor(value: number, k: number) {\\n        this.parsed_nums = [];\\n        // this.parsed_nums = new Array(k);\\n        this.value = value;\\n        this.k = k;\\n        this.count = 0;\\n    }\\n\\n    check(): boolean{\\n        return this.parsed_nums.length === this.k && this.count === this.k;\\n    }\\n\\n    consec(num: number): boolean {\\n        // FASTER\\n        if (num === this.value) this.count += 1;\\n        this.parsed_nums.push(num);\\n        let first_num: undefined | number;\\n        if (this.parsed_nums.length > this.k){\\n            first_num = this.parsed_nums.shift();\\n        }\\n        if (first_num === this.value) this.count -= 1;\\n        // console.log(this.parsed_nums);\\n        return this.check();\\n\\n        // SLOW AS HECK\\n        // this.parsed_nums.push(num);\\n        // if (this.parsed_nums.length > this.k) {\\n        //     this.parsed_nums.shift();\\n        //     // this.parsed_nums = this.parsed_nums.slice(1); // TLE\\n        // }\\n\\n        // // TLE\\n        // // if (this.idx === this.k){\\n        // //     let shifted_i = 1;\\n        // //     for (let i = 0; i < this.parsed_nums.length-1; i += 1){\\n        // //         this.parsed_nums[i] = this.parsed_nums[shifted_i];\\n        // //         shifted_i += 1;\\n        // //     }\\n        // //     this.parsed_nums[shifted_i-1] = num;\\n        // // }\\n        // // if (this.idx < this.k){\\n        // //     this.parsed_nums[this.idx] = num;\\n        // //     this.idx += 1;\\n        // // }\\n        // // console.log(this.parsed_nums, this.idx)\\n        // // TLE\\n        \\n        // if (this.parsed_nums.length < this.k) return false;\\n\\n        // // let i = this.parsed_nums.length-this.k; // faster so we not manipulate the array further\\n        // let i = 0; // if we remove the first in queue everytime the quueue excedd the k\\n        // while (i < this.parsed_nums.length){    \\n        //     if (this.parsed_nums[i] !== this.value) return false;\\n        //     i += 1;\\n        // }\\n        // return true;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table",
                    "Design",
                    "Queue"
                ],
                "code": "```\\nclass DataStream {\\n    protected parsed_nums: number[];\\n    protected value: number;\\n    protected k: number;\\n    // protected idx: number = 0; // capped at k\\n    protected count: number;\\n    constructor(value: number, k: number) {\\n        this.parsed_nums = [];\\n        // this.parsed_nums = new Array(k);\\n        this.value = value;\\n        this.k = k;\\n        this.count = 0;\\n    }\\n\\n    check(): boolean{\\n        return this.parsed_nums.length === this.k && this.count === this.k;\\n    }\\n\\n    consec(num: number): boolean {\\n        // FASTER\\n        if (num === this.value) this.count += 1;\\n        this.parsed_nums.push(num);\\n        let first_num: undefined | number;\\n        if (this.parsed_nums.length > this.k){\\n            first_num = this.parsed_nums.shift();\\n        }\\n        if (first_num === this.value) this.count -= 1;\\n        // console.log(this.parsed_nums);\\n        return this.check();\\n\\n        // SLOW AS HECK\\n        // this.parsed_nums.push(num);\\n        // if (this.parsed_nums.length > this.k) {\\n        //     this.parsed_nums.shift();\\n        //     // this.parsed_nums = this.parsed_nums.slice(1); // TLE\\n        // }\\n\\n        // // TLE\\n        // // if (this.idx === this.k){\\n        // //     let shifted_i = 1;\\n        // //     for (let i = 0; i < this.parsed_nums.length-1; i += 1){\\n        // //         this.parsed_nums[i] = this.parsed_nums[shifted_i];\\n        // //         shifted_i += 1;\\n        // //     }\\n        // //     this.parsed_nums[shifted_i-1] = num;\\n        // // }\\n        // // if (this.idx < this.k){\\n        // //     this.parsed_nums[this.idx] = num;\\n        // //     this.idx += 1;\\n        // // }\\n        // // console.log(this.parsed_nums, this.idx)\\n        // // TLE\\n        \\n        // if (this.parsed_nums.length < this.k) return false;\\n\\n        // // let i = this.parsed_nums.length-this.k; // faster so we not manipulate the array further\\n        // let i = 0; // if we remove the first in queue everytime the quueue excedd the k\\n        // while (i < this.parsed_nums.length){    \\n        //     if (this.parsed_nums[i] !== this.value) return false;\\n        //     i += 1;\\n        // }\\n        // return true;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478666,
                "title": "python-beginner-vs-pro-solution",
                "content": "For someone who is trying to understand:\\n\\nI created the (Beginner Approach) code initially but it gave a timeout error and then it led me to go with a different approach.\\n\\nI have posted both below, incase it helps anyone \\n\\nP.S - Someone beginner like me ...LOL\\n\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.n=0\\n        self.value=value\\n        self.k=k\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if num==self.value:\\n            self.n+=1\\n        else:\\n            self.n=0\\n        return self.n>=self.k\\n                    \\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```\\n\\n# Beginner Approach\\n\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.q=[]\\n        self.value=value\\n        self.k=k\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        self.q.append(num)\\n        if len(self.q)<self.k:\\n            return False\\n        else:\\n            n=len(self.q)-1\\n            for i in range(n,n-self.k,-1):\\n                if self.q[i]!=self.value:\\n                    return False\\n            return True\\n                    \\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.n=0\\n        self.value=value\\n        self.k=k\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if num==self.value:\\n            self.n+=1\\n        else:\\n            self.n=0\\n        return self.n>=self.k\\n                    \\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478024,
                "title": "java-using-fixed-size-sliding-window",
                "content": "```\\nclass DataStream {\\n    \\n     int val, k;\\n    int i = 0 ; int j = 0 ; int count = 0 ;\\n     ArrayList<Integer> al =new ArrayList<>();\\n    public DataStream(int value, int k) {\\n        this.val = value;\\n        this.k = k;\\n        \\n    }\\n\\n    \\n    public boolean consec(int num) {\\n    \\n        al.add(num);\\n        boolean ans = true;\\n        \\n        if(al.get(j) ==  val){\\n            count++;\\n        }\\n        \\n        if(j-i+1 < k){\\n            j++;\\n            ans = false;\\n        }\\n        \\n        else if(j-i+1 == k){\\n            if(count== k){\\n                ans = true;\\n            }else{\\n                ans= false;\\n            }\\n            if(al.get(i) == val){\\n                count--;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass DataStream {\\n    \\n     int val, k;\\n    int i = 0 ; int j = 0 ; int count = 0 ;\\n     ArrayList<Integer> al =new ArrayList<>();\\n    public DataStream(int value, int k) {\\n        this.val = value;\\n        this.k = k;\\n        \\n    }\\n\\n    \\n    public boolean consec(int num) {\\n    \\n        al.add(num);\\n        boolean ans = true;\\n        \\n        if(al.get(j) ==  val){\\n            count++;\\n        }\\n        \\n        if(j-i+1 < k){\\n            j++;\\n            ans = false;\\n        }\\n        \\n        else if(j-i+1 == k){\\n            if(count== k){\\n                ans = true;\\n            }else{\\n                ans= false;\\n            }\\n            if(al.get(i) == val){\\n                count--;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 3477558,
                "title": "find-consecutive-integers-from-a-data-stream",
                "content": "-------------- Easy C++ Solution ----------------\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\nint kk,val,count=0;\\n    DataStream(int value, int k) {\\n        kk=k;\\n        val=value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val) count++;\\n        else count=0;\\n        if(count>=kk) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\nint kk,val,count=0;\\n    DataStream(int value, int k) {\\n        kk=k;\\n        val=value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val) count++;\\n        else count=0;\\n        if(count>=kk) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462000,
                "title": "python3-deque-solution-faster-easy-understanding",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeque \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass DataStream:\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k\\n        self.deque = deque()\\n        self.count = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if len(self.deque) == self.k:\\n            if self.deque[0] == self.value:\\n                self.count -= 1\\n            self.deque.popleft()\\n        self.deque.append(num)\\n        if num == self.value:\\n            self.count += 1\\n        return self.count == self.k\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Design",
                    "Queue",
                    "Counting"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass DataStream:\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k\\n        self.deque = deque()\\n        self.count = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if len(self.deque) == self.k:\\n            if self.deque[0] == self.value:\\n                self.count -= 1\\n            self.deque.popleft()\\n        self.deque.append(num)\\n        if num == self.value:\\n            self.count += 1\\n        return self.count == self.k\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461497,
                "title": "simple-python-solutino",
                "content": "# Approach\\nFor this problem, since we are dealing with the stream, we could use a queue with a maximum length. Since the goal is for all the last k stream numbers to be equal to value, we only keep a pointer to the occurrence of latest stream in the queue that is not equal to the target value. If that is less than 0, then it means the last k stream numbers are all equal to the target value.\\n\\n\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.stream = collections.deque(maxlen=k)\\n        self.target = value\\n        self.max_num = k\\n        # Index for latest stream number that is not equal to target\\n        self.max_false = k - 1\\n\\n    def consec(self, num: int) -> bool:\\n        # if the number is not equal to target, the pointer resets,\\n        # Otherwise it resets to minus -1 \\n        if num != self.target:\\n            self.max_false = self.max_num - 1\\n        else:\\n            self.max_false -= 1\\n        \\n        self.stream.append(num)\\n        return self.max_false < 0\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.stream = collections.deque(maxlen=k)\\n        self.target = value\\n        self.max_num = k\\n        # Index for latest stream number that is not equal to target\\n        self.max_false = k - 1\\n\\n    def consec(self, num: int) -> bool:\\n        # if the number is not equal to target, the pointer resets,\\n        # Otherwise it resets to minus -1 \\n        if num != self.target:\\n            self.max_false = self.max_num - 1\\n        else:\\n            self.max_false -= 1\\n        \\n        self.stream.append(num)\\n        return self.max_false < 0\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458225,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass DataStream {\\n\\n    int val;\\n    int k;\\n    List<Integer> list = new LinkedList<>();\\n    Queue<Integer> q = new LinkedList<>();\\n    int i = -1;\\n    public DataStream(int value, int k) {\\n        this.val = value;\\n        this.k = k;\\n    }\\n    \\n    public boolean consec(int num) {\\n        i += 1;\\n        list.add(num);\\n        if (i < (k - 1)) {\\n            if (num !=val) {\\n                if (!q.isEmpty()){\\n                q.poll();\\n            }\\n            q.add(i);\\n            }\\n            return false;\\n        }\\n        if (num != val) {\\n            if (!q.isEmpty()){\\n                q.poll();\\n            }\\n            q.add(i);\\n            return false;\\n        }\\n        else if (!q.isEmpty() && i < q.peek() + k) {\\n            return false;\\n        }\\n        else if (!q.isEmpty() && i >= q.peek() + k) q.poll();\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass DataStream {\\n\\n    int val;\\n    int k;\\n    List<Integer> list = new LinkedList<>();\\n    Queue<Integer> q = new LinkedList<>();\\n    int i = -1;\\n    public DataStream(int value, int k) {\\n        this.val = value;\\n        this.k = k;\\n    }\\n    \\n    public boolean consec(int num) {\\n        i += 1;\\n        list.add(num);\\n        if (i < (k - 1)) {\\n            if (num !=val) {\\n                if (!q.isEmpty()){\\n                q.poll();\\n            }\\n            q.add(i);\\n            }\\n            return false;\\n        }\\n        if (num != val) {\\n            if (!q.isEmpty()){\\n                q.poll();\\n            }\\n            q.add(i);\\n            return false;\\n        }\\n        else if (!q.isEmpty() && i < q.peek() + k) {\\n            return false;\\n        }\\n        else if (!q.isEmpty() && i >= q.peek() + k) q.poll();\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454838,
                "title": "beats-97-java-easy-to-understand-counting",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n\\n    public static int value;\\n    public static int size;\\n    public static int count;\\n    \\n    public DataStream(int v, int k) {\\n        value=v;\\n        size=k;\\n        count=0;\\n    }\\n    \\n    public static boolean consec(int num) {\\n        if (num==value){\\n            count++;\\n        }else{\\n            count=0;\\n        }\\n\\n        return count>=size;\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n\\n    public static int value;\\n    public static int size;\\n    public static int count;\\n    \\n    public DataStream(int v, int k) {\\n        value=v;\\n        size=k;\\n        count=0;\\n    }\\n    \\n    public static boolean consec(int num) {\\n        if (num==value){\\n            count++;\\n        }else{\\n            count=0;\\n        }\\n\\n        return count>=size;\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451997,
                "title": "c-o-1-space-o-n-time-2-lines",
                "content": "```\\nclass DataStream {\\npublic:\\n    int v, x, c;\\n    DataStream(int value, int k) {\\n        v = value, c = 0, x = k;\\n    }\\n    \\n    bool consec(int num) {\\n        return (c = num == v ? c + 1 : 0) >= x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DataStream {\\npublic:\\n    int v, x, c;\\n    DataStream(int value, int k) {\\n        v = value, c = 0, x = k;\\n    }\\n    \\n    bool consec(int num) {\\n        return (c = num == v ? c + 1 : 0) >= x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432903,
                "title": "count-conseq-value-freq",
                "content": "\\n\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k\\n        self.ln = 0\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        \\n        if num==self.value:\\n            self.ln+=1\\n        else:\\n            self.ln=0\\n\\n        return self.ln>=self.k\\n\\n\\n        \\n\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k\\n        self.ln = 0\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        \\n        if num==self.value:\\n            self.ln+=1\\n        else:\\n            self.ln=0\\n\\n        return self.ln>=self.k\\n\\n\\n        \\n\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414176,
                "title": "python3-one-variable-to-store-the-number-of-last-integers",
                "content": "## Solution:  \\n\\n\\n### Explanation:  \\nWe need to check if the last `k` integers are equal to `value`.\\nWe can just use an **integer variable** to store the number of last integers whose value is `value`, don\\'t need to create like a `List` which is more space-consuming.  \\n\\n\\n### Time complexity:  \\n`O(1)`  \\n\\n\\n### Space complexity:  \\n`O(1)`  \\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value, self.k = value, k\\n        self.nof_integer_equal_to_value = 0\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.value:\\n            if self.nof_integer_equal_to_value == self.k:\\n                return True\\n            self.nof_integer_equal_to_value+=1\\n        else:\\n            self.nof_integer_equal_to_value=0\\n        return self.nof_integer_equal_to_value == self.k\\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value, self.k = value, k\\n        self.nof_integer_equal_to_value = 0\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.value:\\n            if self.nof_integer_equal_to_value == self.k:\\n                return True\\n            self.nof_integer_equal_to_value+=1\\n        else:\\n            self.nof_integer_equal_to_value=0\\n        return self.nof_integer_equal_to_value == self.k\\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366161,
                "title": "java-solution-o-1-space",
                "content": "```\\nclass DataStream {\\n    int size;\\n    int i = 0, j = 0;\\n    int val;\\n\\n    public DataStream(int value, int k) {\\n        this.size = k;\\n        this.val = value;\\n    }\\n\\n    public boolean consec(int num) {\\n        if (num == val) {\\n            i++;\\n            if (i - j > size) j++;\\n            if (i - j == size) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        } else {\\n            //As this will be the 1st different element(not similar) so both j,i must point to the same location(As it was before)\\n            j = i;\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Queue"
                ],
                "code": "```\\nclass DataStream {\\n    int size;\\n    int i = 0, j = 0;\\n    int val;\\n\\n    public DataStream(int value, int k) {\\n        this.size = k;\\n        this.val = value;\\n    }\\n\\n    public boolean consec(int num) {\\n        if (num == val) {\\n            i++;\\n            if (i - j > size) j++;\\n            if (i - j == size) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        } else {\\n            //As this will be the 1st different element(not similar) so both j,i must point to the same location(As it was before)\\n            j = i;\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362302,
                "title": "cpp-easy",
                "content": "Just count only when num==value otherwise keep counter=0\\nif your counter value >=k  then return true otherwise return false\\n```\\nclass DataStream {\\npublic:\\n    int c;\\n    int lv;\\n    int K;\\n    DataStream(int value, int k) \\n    {\\n       lv=value;\\n       c=0;\\n       K=k;\\n    }\\n    bool consec(int num) \\n    {\\n     \\n      if(num==lv)\\n      {\\n         ++c;\\n          if(c>=K)\\n             return true;   \\n      }\\n     else\\n     {\\n         c=0;\\n     }\\n         return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass DataStream {\\npublic:\\n    int c;\\n    int lv;\\n    int K;\\n    DataStream(int value, int k) \\n    {\\n       lv=value;\\n       c=0;\\n       K=k;\\n    }\\n    bool consec(int num) \\n    {\\n     \\n      if(num==lv)\\n      {\\n         ++c;\\n          if(c>=K)\\n             return true;   \\n      }\\n     else\\n     {\\n         c=0;\\n     }\\n         return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3343757,
                "title": "java-deque-peek-last-element-or-use-stack-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n    static int value1 = 0;\\n    static int k1 = 0;\\n    Deque<Integer> q= new LinkedList<>();\\n    int count = 0;\\n    public DataStream(int value, int k) {\\n        value1 = value;\\n        k1 = k;\\n         System.out.print(value1);\\n    }\\n    \\n    public boolean consec(int num) {\\n        System.out.print(value1);\\n        q.add(num);\\n        if(num == value1){\\n             \\n             if(!q.isEmpty() && q.peekLast() == num){\\n                 \\n                 count++;\\n                 if(count >= k1) return true;\\n                 \\n             }else{\\n                 count  = 0;\\n             }\\n        }else{\\n            count  = 0;}\\n            return false;\\n        \\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    static int value1 = 0;\\n    static int k1 = 0;\\n    Deque<Integer> q= new LinkedList<>();\\n    int count = 0;\\n    public DataStream(int value, int k) {\\n        value1 = value;\\n        k1 = k;\\n         System.out.print(value1);\\n    }\\n    \\n    public boolean consec(int num) {\\n        System.out.print(value1);\\n        q.add(num);\\n        if(num == value1){\\n             \\n             if(!q.isEmpty() && q.peekLast() == num){\\n                 \\n                 count++;\\n                 if(count >= k1) return true;\\n                 \\n             }else{\\n                 count  = 0;\\n             }\\n        }else{\\n            count  = 0;}\\n            return false;\\n        \\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339882,
                "title": "easy-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int x=0;\\n    int p,q;\\n    DataStream(int value, int k) {\\n        p=value;\\n        q=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==p&&x>=q-1){\\n            x++;\\n            return true;\\n        }\\n        else if(num==p)x++;\\n        else x=0;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int x=0;\\n    int p,q;\\n    DataStream(int value, int k) {\\n        p=value;\\n        q=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==p&&x>=q-1){\\n            x++;\\n            return true;\\n        }\\n        else if(num==p)x++;\\n        else x=0;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335402,
                "title": "ok",
                "content": "```\\nclass DataStream \\n{\\n    int V{}, K{}, k{};\\npublic:\\n    DataStream(int V, int K) : V(V), K(K)\\n    {        \\n    }\\n    \\n    bool consec(int v) \\n    {\\n        return (k = v==V ? k+1 : 0) >= K;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass DataStream \\n{\\n    int V{}, K{}, k{};\\npublic:\\n    DataStream(int V, int K) : V(V), K(K)\\n    {        \\n    }\\n    \\n    bool consec(int v) \\n    {\\n        return (k = v==V ? k+1 : 0) >= K;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324627,
                "title": "how-can-this-be-a-medium-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        # self.stream = []\\n        self.value = value\\n        self.k = k\\n        self.counter = 0\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        # self.stream.append(num)\\n        if num != self.value:\\n            self.counter = 0\\n        else:\\n            self.counter += 1\\n\\n        return self.counter >= self.k\\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        # self.stream = []\\n        self.value = value\\n        self.k = k\\n        self.counter = 0\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        # self.stream.append(num)\\n        if num != self.value:\\n            self.counter = 0\\n        else:\\n            self.counter += 1\\n\\n        return self.counter >= self.k\\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323716,
                "title": "find-consecutive-integers-from-data-stream-c-explained-solution",
                "content": "**Do Upvote If Found Helpful !!!**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to the problem is quite easy. We can simply do it by just maintaining the count of consecutive integers in the stream. As soon as we encounter a different integer than **value**, we reset the counter back to **0**. The implementation goes below : \\n\\n# Complexity\\n- Time complexity: **O(Q)** , where **Q** is the number of queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int cap,val,count = 0;\\n    DataStream(int value, int k) {\\n        cap = k;\\n        val = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == val){\\n            count++;\\n            if(count >= cap){\\n                return true;\\n            }\\n            return false;\\n        }\\n        count = 0;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int cap,val,count = 0;\\n    DataStream(int value, int k) {\\n        cap = k;\\n        val = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == val){\\n            count++;\\n            if(count >= cap){\\n                return true;\\n            }\\n            return false;\\n        }\\n        count = 0;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322976,
                "title": "c-easy-vector-implementation",
                "content": "\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    vector<pair<int,int>> vec;\\n    int lk;\\n    int val;\\n    DataStream(int value, int k) {\\n        vec.clear();\\n        lk = k;\\n        val = value; \\n    }\\n    \\n    bool consec(int num) {\\n        if(vec.size()==0)\\n        vec.push_back({num,1});\\n        else if(vec.size()>0)\\n        {\\n            if(vec[vec.size()-1].first==num)\\n            {\\n                int fre = vec[vec.size()-1].second;\\n                fre++;\\n                vec.pop_back();\\n                vec.push_back({num,fre});\\n            }\\n            else\\n            vec.push_back({num,1});\\n        }\\n        if(vec[vec.size()-1].second<lk)\\n        return false;\\n        if(vec[vec.size()-1].second>=lk && vec[vec.size()-1].first==val)\\n        return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    vector<pair<int,int>> vec;\\n    int lk;\\n    int val;\\n    DataStream(int value, int k) {\\n        vec.clear();\\n        lk = k;\\n        val = value; \\n    }\\n    \\n    bool consec(int num) {\\n        if(vec.size()==0)\\n        vec.push_back({num,1});\\n        else if(vec.size()>0)\\n        {\\n            if(vec[vec.size()-1].first==num)\\n            {\\n                int fre = vec[vec.size()-1].second;\\n                fre++;\\n                vec.pop_back();\\n                vec.push_back({num,fre});\\n            }\\n            else\\n            vec.push_back({num,1});\\n        }\\n        if(vec[vec.size()-1].second<lk)\\n        return false;\\n        if(vec[vec.size()-1].second>=lk && vec[vec.size()-1].first==val)\\n        return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322546,
                "title": "python-solution",
                "content": "# class DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k\\n        self.valueLength = 0  # last length of given value\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.value:\\n            self.valueLength += 1\\n        else:\\n            self.valueLength = 0\\n        \\n        if self.valueLength >= self.k:\\n            return True\\n        return False",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# class DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value = value\\n        self.k = k\\n        self.valueLength = 0  # last length of given value\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.value:\\n            self.valueLength += 1\\n        else:\\n            self.valueLength = 0\\n        \\n        if self.valueLength >= self.k:\\n            return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 3322462,
                "title": "very-easy-without-using-priority-queue-and-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe keep a simple counter variable to keep track of number of \\'value\\' seen till now.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe take a counter variable \\'con\\' which counts the number of \\'value\\' seen till current call. If con is equal to k we return true otherwise false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass DataStream {\\n    int k_val;\\n    int val;\\n    int con;\\npublic:\\n    DataStream(int value, int k) {\\n        val = value;\\n        k_val = k;\\n        con = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        //cout << k_val << \" \" << val << \" \" << con << endl;\\n        if(num == val) {\\n            con++;\\n            if(con >= k_val) return true;\\n        }    \\n        else {\\n            con = 0;\\n        }    \\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\n    int k_val;\\n    int val;\\n    int con;\\npublic:\\n    DataStream(int value, int k) {\\n        val = value;\\n        k_val = k;\\n        con = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        //cout << k_val << \" \" << val << \" \" << con << endl;\\n        if(num == val) {\\n            con++;\\n            if(con >= k_val) return true;\\n        }    \\n        else {\\n            con = 0;\\n        }    \\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3275700,
                "title": "c-simple-solution-explained-beats-72",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe don\\'t have to maintain any sort of data. Just keep track of last value that was not equals to `value`.\\n\\n# Code\\n```\\npublic class DataStream {\\n\\n    int val;\\n    int k;\\n    int counter; // to track no. of total elements inserted.\\n    int temp; // using this to track last value that was != value\\n\\n    public DataStream(int value, int k) {\\n        this.k = k;\\n        this.val = value;\\n        counter = 0;\\n        temp = -1;\\n    }\\n    \\n    public bool Consec(int num) {\\n        \\n        counter++;\\n        if(num != val){\\n            // saving which num was not equals to value\\n            temp = counter;\\n        }\\n        if(counter < k) {\\n            return false;\\n        }\\n        else{\\n            // if temp is in last k numbers, return false\\n            if((counter - k < temp) && temp <= counter){\\n                return false;\\n            } \\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "C#"
                ],
                "code": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe don\\'t have to maintain any sort of data. Just keep track of last value that was not equals to `value`.\\n\\n# Code\\n```\\npublic class DataStream {\\n\\n    int val;\\n    int k;\\n    int counter; // to track no. of total elements inserted.\\n    int temp; // using this to track last value that was != value\\n\\n    public DataStream(int value, int k) {\\n        this.k = k;\\n        this.val = value;\\n        counter = 0;\\n        temp = -1;\\n    }\\n    \\n    public bool Consec(int num) {\\n        \\n        counter++;\\n        if(num != val){\\n            // saving which num was not equals to value\\n            temp = counter;\\n        }\\n        if(counter < k) {\\n            return false;\\n        }\\n        else{\\n            // if temp is in last k numbers, return false\\n            if((counter - k < temp) && temp <= counter){\\n                return false;\\n            } \\n        }\\n        return true;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3272076,
                "title": "lc-2526-m-python3-a-plain-solution-3-lines",
                "content": "Set a counter `self.cnt` to record the number of present consecutive `self.value`\\'s.\\n\\n```Python3 []\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value, self.k, self.cnt = value, k, 0\\n    \\n    def consec(self, num: int) -> bool:\\n        self.cnt = self.cnt + 1 if num == self.value else 0\\n        return False if self.cnt < self.k or num != self.value else True\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python3 []\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value, self.k, self.cnt = value, k, 0\\n    \\n    def consec(self, num: int) -> bool:\\n        self.cnt = self.cnt + 1 if num == self.value else 0\\n        return False if self.cnt < self.k or num != self.value else True\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248362,
                "title": "c-count-last-value-o-1",
                "content": "\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    DataStream(int value, int k) {\\n        t_val = value;\\n        t_k = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == curr_val) curr_count++;\\n        else{\\n            curr_val = num;\\n            curr_count = 1;\\n        }\\n        if(curr_val == t_val && curr_count >= t_k) return true;\\n        return false;\\n    }\\n\\nprivate:\\n    int curr_val = -1;\\n    int curr_count = 0;\\n    int t_val;\\n    int t_k;\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    DataStream(int value, int k) {\\n        t_val = value;\\n        t_k = k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == curr_val) curr_count++;\\n        else{\\n            curr_val = num;\\n            curr_count = 1;\\n        }\\n        if(curr_val == t_val && curr_count >= t_k) return true;\\n        return false;\\n    }\\n\\nprivate:\\n    int curr_val = -1;\\n    int curr_count = 0;\\n    int t_val;\\n    int t_k;\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234451,
                "title": "java-o-1-count-and-compare",
                "content": "# Approach\\n1. Count how many nums equal to value you have consicutively inserted until now\\n2. If current num is not value, reset the count to 0;\\n3. Return true only if count >= k;\\n\\n# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n    private final int value;\\n    private final int k;\\n    private int count;\\n    public DataStream(int value, int k) {\\n        this.value = value;\\n        this.k = k;\\n    }\\n    \\n    public boolean consec(int num) {\\n        count = num == value ? count + 1 : 0;\\n        return count >= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    private final int value;\\n    private final int k;\\n    private int count;\\n    public DataStream(int value, int k) {\\n        this.value = value;\\n        this.k = k;\\n    }\\n    \\n    public boolean consec(int num) {\\n        count = num == value ? count + 1 : 0;\\n        return count >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192433,
                "title": "simple-python-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs per the problem statement, we need to find if the last **k** elements were **value** or not. So, initial thought I got was we need to keep the track of last k elements and best way will be to have a Queue. But on thinking more, I found we can just keep a variable which will keep the count.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will initialize the variables **value**, **k** as received and **count** as 0.\\n2. We will compare the input **num** with the value, if it is same increase the **count** variable. If **count** is greater than or equal **k**, we will send it True.\\n3. if on comparison, the input **num** is not equal to value, we will make the **count** as 0 and return False\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value=value\\n        self.k=k\\n        self.count=0\\n\\n    def consec(self, num: int) -> bool:\\n        if(num!=self.value):\\n            self.count=0\\n            return False\\n        self.count+=1\\n        return self.count>=self.k\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.value=value\\n        self.k=k\\n        self.count=0\\n\\n    def consec(self, num: int) -> bool:\\n        if(num!=self.value):\\n            self.count=0\\n            return False\\n        self.count+=1\\n        return self.count>=self.k\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163615,
                "title": "java-monoqueues",
                "content": "Maintain  two monoqueus increasing and decreasing of size k as we keep getting the seq of nos \\nIf for a window of size k , the item in the windwo , the min and the max elem in the window are all same and is equal to the target value , then we can say that it is a true \\nIncr Monoqueue will give min at peekFirst\\nDecrMonoqueue will give max at the peekFirst\\nwhile a normal dequeu can act as a sliding window of size K\\nwhen window exceesds K , we pop the first elem out of the SW deque and also remove the elem from both the monoqueues\\n```\\nclass DataStream {\\n   \\n    private final int targetValue;\\n    private final int windowSize;\\n    private Deque<Integer> deque;\\n    private Deque<Integer> decMonoqueue;\\n    private Deque<Integer> incrMonoqueue;\\n    public DataStream(int value, int k) {\\n        deque = new LinkedList<>();\\n        decMonoqueue = new LinkedList<>();\\n        incrMonoqueue = new LinkedList<>();\\n        targetValue = value;\\n        windowSize = k;\\n    }\\n\\n    public boolean consec(int num) {\\n        deque.addLast(num);\\n        addToDecrMonoqueue(num);\\n        addToIncrMonoqueue(num);\\n        if(deque.size() > windowSize){\\n            int curr = deque.pollFirst();\\n            removeFromDecrMonoque(curr);\\n            removrFromIncrmonoque(curr);\\n        }\\n        if(deque.size() == windowSize){\\n            if((deque.peekFirst() == targetValue) && (decMonoqueue.peekFirst() == incrMonoqueue.peekFirst()) && (decMonoqueue.peekFirst() == deque.peekFirst()))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private void addToDecrMonoqueue(int num) {\\n        while (!decMonoqueue.isEmpty() && num < decMonoqueue.peekLast())\\n            decMonoqueue.pollLast();\\n        decMonoqueue.addLast(num);\\n    }\\n    \\n    private void addToIncrMonoqueue(int num){\\n        while (! incrMonoqueue.isEmpty() && num > incrMonoqueue.peekLast()){\\n            incrMonoqueue.pollLast();\\n        }\\n        incrMonoqueue.addLast(num);\\n    }\\n    \\n    private void removeFromDecrMonoque(int num){\\n        if(num == decMonoqueue.peekFirst())\\n            decMonoqueue.pollFirst();\\n    }\\n    \\n    private void removrFromIncrmonoque(int num){\\n        if(num == incrMonoqueue.peekFirst())\\n            incrMonoqueue.pollFirst();\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass DataStream {\\n   \\n    private final int targetValue;\\n    private final int windowSize;\\n    private Deque<Integer> deque;\\n    private Deque<Integer> decMonoqueue;\\n    private Deque<Integer> incrMonoqueue;\\n    public DataStream(int value, int k) {\\n        deque = new LinkedList<>();\\n        decMonoqueue = new LinkedList<>();\\n        incrMonoqueue = new LinkedList<>();\\n        targetValue = value;\\n        windowSize = k;\\n    }\\n\\n    public boolean consec(int num) {\\n        deque.addLast(num);\\n        addToDecrMonoqueue(num);\\n        addToIncrMonoqueue(num);\\n        if(deque.size() > windowSize){\\n            int curr = deque.pollFirst();\\n            removeFromDecrMonoque(curr);\\n            removrFromIncrmonoque(curr);\\n        }\\n        if(deque.size() == windowSize){\\n            if((deque.peekFirst() == targetValue) && (decMonoqueue.peekFirst() == incrMonoqueue.peekFirst()) && (decMonoqueue.peekFirst() == deque.peekFirst()))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private void addToDecrMonoqueue(int num) {\\n        while (!decMonoqueue.isEmpty() && num < decMonoqueue.peekLast())\\n            decMonoqueue.pollLast();\\n        decMonoqueue.addLast(num);\\n    }\\n    \\n    private void addToIncrMonoqueue(int num){\\n        while (! incrMonoqueue.isEmpty() && num > incrMonoqueue.peekLast()){\\n            incrMonoqueue.pollLast();\\n        }\\n        incrMonoqueue.addLast(num);\\n    }\\n    \\n    private void removeFromDecrMonoque(int num){\\n        if(num == decMonoqueue.peekFirst())\\n            decMonoqueue.pollFirst();\\n    }\\n    \\n    private void removrFromIncrmonoque(int num){\\n        if(num == incrMonoqueue.peekFirst())\\n            incrMonoqueue.pollFirst();\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162153,
                "title": "count",
                "content": "**C++**\\n```cpp\\nclass DataStream {\\npublic:\\n    int value, k, cnt;\\n    DataStream(int value, int k) : value(value), k(k), cnt(0) {}\\n    bool consec(int num) {\\n        return (cnt = num == value ? cnt + 1 : 0) >= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass DataStream {\\npublic:\\n    int value, k, cnt;\\n    DataStream(int value, int k) : value(value), k(k), cnt(0) {}\\n    bool consec(int num) {\\n        return (cnt = num == value ? cnt + 1 : 0) >= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157641,
                "title": "python3-readable-and-short-solution-in-o-1-time-space-for-all-methods",
                "content": "# Intuition\\nWe must keep track of the consecutive occurrences of `value`.\\n\\n# Approach\\nWe count the consecutive occurrences of `value` and limit it to `k`. If a `number != value` appears, we reset the counter.\\n\\n# Complexity\\n- Time complexity:\\n`O(1)`\\n\\n- Space complexity:\\n`O(1)`\\n\\n# Code\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.k = k\\n        self.value = value\\n        self.consecutive_occurrences_of_value = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.value:\\n            self.consecutive_occurrences_of_value = min(self.k, self.consecutive_occurrences_of_value + 1)\\n        else: \\n            self.consecutive_occurrences_of_value = 0\\n\\n        if self.consecutive_occurrences_of_value == self.k:\\n            return True\\n\\n        return False\\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.k = k\\n        self.value = value\\n        self.consecutive_occurrences_of_value = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.value:\\n            self.consecutive_occurrences_of_value = min(self.k, self.consecutive_occurrences_of_value + 1)\\n        else: \\n            self.consecutive_occurrences_of_value = 0\\n\\n        if self.consecutive_occurrences_of_value == self.k:\\n            return True\\n\\n        return False\\n        \\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143078,
                "title": "c-clean-vector-short",
                "content": "\\n\\n# Code\\n```\\nclass DataStream {\\npublic:vector<int> v,a;\\nint p,e;\\n    DataStream(int value, int k) {\\n       e=value;\\n        p=k;\\n    }\\n    \\n    bool consec(int num) {\\n       if(v.size()>0){ \\n           if(num==v.back())\\n            a.push_back(a.back()+1);\\n           else\\n            a.push_back(1);\\n         }\\n        else\\n        a.push_back(1);\\n\\n        v.push_back(num);\\n        if(a.back()>=p && v.back()==e)\\n        return 1;\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:vector<int> v,a;\\nint p,e;\\n    DataStream(int value, int k) {\\n       e=value;\\n        p=k;\\n    }\\n    \\n    bool consec(int num) {\\n       if(v.size()>0){ \\n           if(num==v.back())\\n            a.push_back(a.back()+1);\\n           else\\n            a.push_back(1);\\n         }\\n        else\\n        a.push_back(1);\\n\\n        v.push_back(num);\\n        if(a.back()>=p && v.back()==e)\\n        return 1;\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141211,
                "title": "c-golang-counting",
                "content": "# Code\\n```\\n//--------------------------------------\\n// C++\\n//--------------------------------------\\nclass DataStream {\\n    int value;\\n    int k;\\n    int count;\\npublic:\\n    DataStream(int value, int k) {\\n        this -> value = value;\\n        this -> k = k;\\n        count = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == value) count++;\\n        else count = 0;\\n        return count >= k;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n\\n\\n\\n//--------------------------------------\\n// Golang\\n//--------------------------------------\\ntype DataStream struct {\\n    k int\\n    value int\\n    count int\\n}\\n\\n\\nfunc Constructor(value int, k int) DataStream {\\n    return DataStream {\\n        k: k,\\n        value: value,\\n        count: 0,\\n    }\\n}\\n\\n\\nfunc (this *DataStream) Consec(num int) bool {\\n    if num == this.value {\\n        this.count++\\n    } else {    \\n        this.count = 0\\n    }\\n    return this.count >= this.k\\n}\\n\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * obj := Constructor(value, k);\\n * param_1 := obj.Consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Counting",
                    "Data Stream"
                ],
                "code": "```\\n//--------------------------------------\\n// C++\\n//--------------------------------------\\nclass DataStream {\\n    int value;\\n    int k;\\n    int count;\\npublic:\\n    DataStream(int value, int k) {\\n        this -> value = value;\\n        this -> k = k;\\n        count = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == value) count++;\\n        else count = 0;\\n        return count >= k;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n\\n\\n\\n//--------------------------------------\\n// Golang\\n//--------------------------------------\\ntype DataStream struct {\\n    k int\\n    value int\\n    count int\\n}\\n\\n\\nfunc Constructor(value int, k int) DataStream {\\n    return DataStream {\\n        k: k,\\n        value: value,\\n        count: 0,\\n    }\\n}\\n\\n\\nfunc (this *DataStream) Consec(num int) bool {\\n    if num == this.value {\\n        this.count++\\n    } else {    \\n        this.count = 0\\n    }\\n    return this.count >= this.k\\n}\\n\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * obj := Constructor(value, k);\\n * param_1 := obj.Consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127278,
                "title": "c-queue-unordered-map-easy-to-understand",
                "content": "* ***Using Queue && Unordered Map***\\n\\n* ***Time Complexity :- O(1)***\\n\\n* ***Space Complexity :- O(K)***\\n\\n```\\nclass DataStream {\\npublic:\\n    \\n    int k;\\n    \\n    int val;\\n    \\n    // declare a queue\\n    \\n    queue<int> q;\\n    \\n    // declare a map\\n    \\n    unordered_map<int, int> mp;\\n    \\n    DataStream(int value, int K) {\\n        \\n        k = K;\\n        \\n        val = value;\\n    }\\n    \\n    bool consec(int num) {\\n        \\n        // push the num into queue\\n        \\n        q.push(num);\\n        \\n        // insert num into map\\n        \\n        mp[num]++;\\n        \\n        bool ans = false;\\n        \\n        // if the number of element in queue is k, then check the condition\\n        \\n        if(q.size() == k)\\n        {\\n            // if the condition is satisfied then mark ans as true\\n            \\n            if(mp.size() == 1 && mp[val] == k)\\n            {\\n                ans = true;\\n            }\\n            \\n            // pop out from queue\\n    \\n            int front = q.front();\\n            \\n            q.pop();\\n            \\n            // decrement the frequency of front from map\\n            \\n            mp[front]--;\\n            \\n            // if the frequency of the from in map is zero then erase the front from map\\n            \\n            if(mp[front] == 0)\\n            {\\n                mp.erase(front);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Queue",
                    "Counting"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    \\n    int k;\\n    \\n    int val;\\n    \\n    // declare a queue\\n    \\n    queue<int> q;\\n    \\n    // declare a map\\n    \\n    unordered_map<int, int> mp;\\n    \\n    DataStream(int value, int K) {\\n        \\n        k = K;\\n        \\n        val = value;\\n    }\\n    \\n    bool consec(int num) {\\n        \\n        // push the num into queue\\n        \\n        q.push(num);\\n        \\n        // insert num into map\\n        \\n        mp[num]++;\\n        \\n        bool ans = false;\\n        \\n        // if the number of element in queue is k, then check the condition\\n        \\n        if(q.size() == k)\\n        {\\n            // if the condition is satisfied then mark ans as true\\n            \\n            if(mp.size() == 1 && mp[val] == k)\\n            {\\n                ans = true;\\n            }\\n            \\n            // pop out from queue\\n    \\n            int front = q.front();\\n            \\n            q.pop();\\n            \\n            // decrement the frequency of front from map\\n            \\n            mp[front]--;\\n            \\n            // if the frequency of the from in map is zero then erase the front from map\\n            \\n            if(mp[front] == 0)\\n            {\\n                mp.erase(front);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110425,
                "title": "easy-c-solution-using-vector-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int i,j;\\n    vector<int>vec;\\n    DataStream(int value, int k) {\\n        i = value;\\n        j = k;\\n    }\\n    \\n    bool consec(int num) {        \\n        while(vec.size() && vec.back()!=num) vec.pop_back();\\n        vec.push_back(num);\\n        if(num != i) return false;\\n        if(vec.size()>=j)return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int i,j;\\n    vector<int>vec;\\n    DataStream(int value, int k) {\\n        i = value;\\n        j = k;\\n    }\\n    \\n    bool consec(int num) {        \\n        while(vec.size() && vec.back()!=num) vec.pop_back();\\n        vec.push_back(num);\\n        if(num != i) return false;\\n        if(vec.size()>=j)return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105760,
                "title": "c-o-1-space-and-time",
                "content": "\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int val=0,kal=0,c=0;\\n    DataStream(int value, int k) {\\n        val=value;\\n        kal=k;\\n    }\\n    \\n    bool consec(int num) {\\n        num==val?c++:c=0;\\n        if(c>=kal)return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val=0,kal=0,c=0;\\n    DataStream(int value, int k) {\\n        val=value;\\n        kal=k;\\n    }\\n    \\n    bool consec(int num) {\\n        num==val?c++:c=0;\\n        if(c>=kal)return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103744,
                "title": "python-count-the-last-n-number-explained",
                "content": "We just need to track the last n numbers that is equal to the value. If we encounter a different value, we reset the counter to 0.\\n\\nReturn the `counter >= k`\\n\\n```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.k = k\\n        self.target = value\\n        self.n_cons = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.target:\\n            self.n_cons += 1\\n        else:\\n            self.n_cons = 0\\n        \\n        return self.n_cons >= self.k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.k = k\\n        self.target = value\\n        self.n_cons = 0\\n\\n    def consec(self, num: int) -> bool:\\n        if num == self.target:\\n            self.n_cons += 1\\n        else:\\n            self.n_cons = 0\\n        \\n        return self.n_cons >= self.k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102161,
                "title": "simple-java-solution-with-explanation-counter",
                "content": "```\\nclass DataStream {\\n    int val;\\n    int count;\\n    int equalCount;\\n    int streamSize;\\n\\n    public DataStream(int value, int k) {\\n        val = value;\\n        count = k; \\n        equalCount = 0; \\n        streamSize = 0;  \\n    }\\n    \\n    public boolean consec(int num) {\\n        streamSize++;\\n        if (num != val) {\\n            equalCount = 0;\\n            return false;\\n        } else {\\n            equalCount++;\\n            return ((streamSize >= count) && (equalCount >= count));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    int val;\\n    int count;\\n    int equalCount;\\n    int streamSize;\\n\\n    public DataStream(int value, int k) {\\n        val = value;\\n        count = k; \\n        equalCount = 0; \\n        streamSize = 0;  \\n    }\\n    \\n    public boolean consec(int num) {\\n        streamSize++;\\n        if (num != val) {\\n            equalCount = 0;\\n            return false;\\n        } else {\\n            equalCount++;\\n            return ((streamSize >= count) && (equalCount >= count));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097467,
                "title": "just-used-if-else-to-solve-this-question-cpp-100-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    vector<int> v;\\n    int K, val, ct=0;\\n    DataStream(int value, int k) {\\n        K=k;\\n        val=value;\\n    }\\n    \\n    bool consec(int num) {\\n        v.push_back(num);\\n        if(num==val){\\n            ct++;\\n        }\\n        else{\\n            ct=0;\\n        }\\n        if(v.size()<K){\\n            return false;\\n        }\\n        if(ct>=K){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Queue",
                    "Counting"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    vector<int> v;\\n    int K, val, ct=0;\\n    DataStream(int value, int k) {\\n        K=k;\\n        val=value;\\n    }\\n    \\n    bool consec(int num) {\\n        v.push_back(num);\\n        if(num==val){\\n            ct++;\\n        }\\n        else{\\n            ct=0;\\n        }\\n        if(v.size()<K){\\n            return false;\\n        }\\n        if(ct>=K){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095674,
                "title": "scala-solution",
                "content": "# Code\\n```\\nclass DataStream(_value: Int, _k: Int) {\\n  var count = 0\\n  def consec(num: Int): Boolean =\\n    if(num != _value) {count = 0; false} else {count += 1; count>= _k}\\n}\\n",
                "solutionTags": [
                    "Scala"
                ],
                "code": "# Code\\n```\\nclass DataStream(_value: Int, _k: Int) {\\n  var count = 0\\n  def consec(num: Int): Boolean =\\n    if(num != _value) {count = 0; false} else {count += 1; count>= _k}\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 3091229,
                "title": "simple-and-short-ans",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust by passing a variable by count of value. If it is equal to k return true and reduce by -1(to check for next consec),else return false.\\nif num!=val make c=0 and return false.\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int val,size,c=0;\\n    DataStream(int value, int k) {\\n         val=value;\\n         size=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=val){\\n            c=0;\\n           return false;\\n        }\\n        else {\\n            c++;\\n            if(c==size){\\n              c--;\\n              return true;\\n            }\\n            else return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val,size,c=0;\\n    DataStream(int value, int k) {\\n         val=value;\\n         size=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=val){\\n            c=0;\\n           return false;\\n        }\\n        else {\\n            c++;\\n            if(c==size){\\n              c--;\\n              return true;\\n            }\\n            else return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086876,
                "title": "easy-understable-code",
                "content": "\\n\\n# Code\\n```\\nclass DataStream:\\n    def __init__(self, value, k):\\n        self._val = 0\\n        self._s = 0\\n        self._kes = 0\\n\\n        self._val = value\\n        self._s = 0\\n        self._kes = k\\n\\n    def consec(self, num):\\n        if num == self._val:\\n            self._s += 1\\n        else:\\n            self._s = 0\\n        if self._s>=self._kes:\\n            return True\\n        return False\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n    def __init__(self, value, k):\\n        self._val = 0\\n        self._s = 0\\n        self._kes = 0\\n\\n        self._val = value\\n        self._s = 0\\n        self._kes = k\\n\\n    def consec(self, num):\\n        if num == self._val:\\n            self._s += 1\\n        else:\\n            self._s = 0\\n        if self._s>=self._kes:\\n            return True\\n        return False\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084117,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass DataStream {\\n    \\n    deque<int> stream;\\n    int value , k;\\n    int size = 0, index = 0, sum = 0;\\npublic:\\n    DataStream(int value, int k) {\\n        this->value = value;\\n        this->k = k;\\n    }\\n    \\n    bool consec(int num) {\\n        \\n        \\n        num = num==this->value ? 1 : 0;\\n        sum+=num;\\n        stream.push_back(num);\\n\\n        if(stream.size() < k) return false;\\n        \\n        if(stream.size() == k) return sum == k;\\n        \\n        int temp = stream.front();\\n        sum -= temp;\\n        stream.pop_front();\\n        \\n        return sum == k;\\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\n    \\n    deque<int> stream;\\n    int value , k;\\n    int size = 0, index = 0, sum = 0;\\npublic:\\n    DataStream(int value, int k) {\\n        this->value = value;\\n        this->k = k;\\n    }\\n    \\n    bool consec(int num) {\\n        \\n        \\n        num = num==this->value ? 1 : 0;\\n        sum+=num;\\n        stream.push_back(num);\\n\\n        if(stream.size() < k) return false;\\n        \\n        if(stream.size() == k) return sum == k;\\n        \\n        int temp = stream.front();\\n        sum -= temp;\\n        stream.pop_front();\\n        \\n        return sum == k;\\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081509,
                "title": "o-1-both-time-and-space-complexity",
                "content": "# Approach\\nI am using a counter currCount to keep track of the number of consective integers that are equal to value. This eliminates the need to store all the integers in a slice, making it more memory-efficient.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the optimized version of the DataStream class is O(1) or constant time.\\n\\n  In every call to Consec(num) function, we are only performing a constant number of operations, regardless of the size of the input stream.\\n\\n  We are comparing the input num with value and incrementing the counter curr if they are equal.\\nWe are checking if the curr is greater than or equal to k and return the result.\\nSince these operations are constant, the time complexity of the function is O(1) regardless of the size of the input stream.\\n\\n\\n- Space complexity:\\nThe space complexity of the this version of the DataStream class is also O(1), as we are not storing the input stream in any data structure, only storing a few variables such as value, k, and currCount.\\n\\n# Code\\n```\\ntype DataStream struct {\\n\\tvalue     int\\n\\tk         int\\n\\tcurrCount int\\n}\\n\\nfunc Constructor(value int, k int) DataStream {\\n\\treturn DataStream{\\n\\t\\tvalue:     value,\\n\\t\\tk:         k,\\n\\t\\tcurrCount: 0,\\n\\t}\\n}\\n\\nfunc (ds *DataStream) Consec(num int) bool {\\n\\tif num != ds.value {\\n\\t\\tds.currCount = 0\\n\\t} else {\\n\\t\\tds.currCount++\\n\\t}\\n\\treturn ds.currCount >= ds.k\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype DataStream struct {\\n\\tvalue     int\\n\\tk         int\\n\\tcurrCount int\\n}\\n\\nfunc Constructor(value int, k int) DataStream {\\n\\treturn DataStream{\\n\\t\\tvalue:     value,\\n\\t\\tk:         k,\\n\\t\\tcurrCount: 0,\\n\\t}\\n}\\n\\nfunc (ds *DataStream) Consec(num int) bool {\\n\\tif num != ds.value {\\n\\t\\tds.currCount = 0\\n\\t} else {\\n\\t\\tds.currCount++\\n\\t}\\n\\treturn ds.currCount >= ds.k\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3073693,
                "title": "swift-solution",
                "content": "# Approach\\n1. Create a class named DataStream with 3 properties: size, val, and i.\\n2. Initialize the class with the value and the size.\\n3. Create a method named consec which takes in a parameter named num.\\n4. The method consec will compare the num to the value of val, and if it is the same, increase i by 1, otherwise, set i to 0.\\n5. The method consec will return whether i is greater than or equal to size.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass DataStream\\n{\\n    var size:Int\\n    var val:Int\\n    var i:Int\\n    init(_ value:Int, _ k:Int) {\\n        val=value;\\n        size=k;\\n        i=0;\\n    }\\n    \\n    func consec(_ num:Int) -> Bool {\\n        i=(num == val) ? i+1 : 0;\\n        return i>=size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass DataStream\\n{\\n    var size:Int\\n    var val:Int\\n    var i:Int\\n    init(_ value:Int, _ k:Int) {\\n        val=value;\\n        size=k;\\n        i=0;\\n    }\\n    \\n    func consec(_ num:Int) -> Bool {\\n        i=(num == val) ? i+1 : 0;\\n        return i>=size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067631,
                "title": "simplest-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass DataStream {\\nprivate:\\n    int val, k, cnt = 0;\\npublic:\\n    DataStream(int val, int k) {\\n        this->val = val;\\n        this->k = k;\\n    }\\n    bool consec(int num) {\\n        if (num != val) cnt = 0;\\n        else cnt ++;\\n        if (cnt >= k) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\nprivate:\\n    int val, k, cnt = 0;\\npublic:\\n    DataStream(int val, int k) {\\n        this->val = val;\\n        this->k = k;\\n    }\\n    bool consec(int num) {\\n        if (num != val) cnt = 0;\\n        else cnt ++;\\n        if (cnt >= k) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065901,
                "title": "minimal",
                "content": "\\n```\\nclass DataStream:\\n\\n    def __init__(self, value, k):\\n        self.stream =[]\\n        self.value = value\\n        self.k = k\\n \\n        \\n\\n    def consec(self, num):\\n        if num != self.value : \\n            self.stream.clear()\\n            return False \\n        self.stream.append(num)\\n\\n        return len(self.stream)>=self.k\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DataStream:\\n\\n    def __init__(self, value, k):\\n        self.stream =[]\\n        self.value = value\\n        self.k = k\\n \\n        \\n\\n    def consec(self, num):\\n        if num != self.value : \\n            self.stream.clear()\\n            return False \\n        self.stream.append(num)\\n\\n        return len(self.stream)>=self.k\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062089,
                "title": "must-see-very-very-easy-to-understand",
                "content": "# Code\\n```\\nclass DataStream {\\npublic:\\n     //we will just maintain the continuous streak for the last inserted element\\n    //the main logic is to check is after every insertio we have k consecutive last element or not\\n    int K;\\n    int val;\\n    unordered_map<int,int>mp;\\n    DataStream(int value, int k) \\n    {\\n        K = k;\\n        val = value;\\n    }\\n    \\n    bool consec(int num) \\n    {\\n        //if this element is equal to the val\\n        if(num == val)\\n        {\\n            mp[val]++;\\n\\n            if(mp[val] >= K)\\n            return true;\\n        }      \\n        else if(num != val)\\n        {\\n            mp[val] = 0;      //out streak for last k interger of value val is now breaked\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Counting",
                    "Data Stream"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n     //we will just maintain the continuous streak for the last inserted element\\n    //the main logic is to check is after every insertio we have k consecutive last element or not\\n    int K;\\n    int val;\\n    unordered_map<int,int>mp;\\n    DataStream(int value, int k) \\n    {\\n        K = k;\\n        val = value;\\n    }\\n    \\n    bool consec(int num) \\n    {\\n        //if this element is equal to the val\\n        if(num == val)\\n        {\\n            mp[val]++;\\n\\n            if(mp[val] >= K)\\n            return true;\\n        }      \\n        else if(num != val)\\n        {\\n            mp[val] = 0;      //out streak for last k interger of value val is now breaked\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053701,
                "title": "c-nice-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass DataStream {\\n    int value{}, k{}, count{};\\npublic:\\n    DataStream(int value, int k) {\\n        this->value = value;\\n        this->k = k;\\n        count = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == value && count < k)\\n            count++;\\n        if(num != value)\\n            count = 0;\\n\\n        return count == k;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\n    int value{}, k{}, count{};\\npublic:\\n    DataStream(int value, int k) {\\n        this->value = value;\\n        this->k = k;\\n        count = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num == value && count < k)\\n            count++;\\n        if(num != value)\\n            count = 0;\\n\\n        return count == k;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051703,
                "title": "c-o-1-time-complexity-and-o-1-space-easy-to-understans",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif new number equals the given value then increment the counter otherwise set it to 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Increment the counter variable whenever you get num equal to the desired value.\\n2.Now check if counter is equal to the desired number of elements or not.if they are equal then decrement the counter and return true.(Counter is decremented as we require only k consecutive elements)\\n3.if the counter is not equal to desired number of elements then return false.\\n4.if numm is not equal to desired value then set counter to zero and return false.\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\nlong long int val,lt,cnt=0;\\n    DataStream(int value, int k) {\\n        val=value;\\n        lt=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val){\\n        cnt++;\\n        if(cnt==lt){\\n        --cnt;\\n        return true;\\n        }\\n        else\\n        return 0;\\n        }\\n        else{\\n            cnt=0;\\n            return 0;\\n        }\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\nlong long int val,lt,cnt=0;\\n    DataStream(int value, int k) {\\n        val=value;\\n        lt=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val){\\n        cnt++;\\n        if(cnt==lt){\\n        --cnt;\\n        return true;\\n        }\\n        else\\n        return 0;\\n        }\\n        else{\\n            cnt=0;\\n            return 0;\\n        }\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050290,
                "title": "the-related-topics-made-it-look-harder-though",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust keep a count of the occurence of the value if any other number occurs just reset the count and you are done\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int n,size,cnt=1;\\n    DataStream(int value, int k) {\\n        n=value;\\n        size=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==n)++cnt;\\n        else cnt=1;\\n        if(cnt>=size+1)return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int n,size,cnt=1;\\n    DataStream(int value, int k) {\\n        n=value;\\n        size=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==n)++cnt;\\n        else cnt=1;\\n        if(cnt>=size+1)return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050138,
                "title": "c-298-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    DataStream(int value, int k): val(value), last(k) {}\\n    \\n    bool consec(int num) {\\n        num==val? ++curr: curr=0;\\n        return curr<last? false: true;\\n    }\\n    \\nprivate:\\n    const int val, last;\\n    int curr=0;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    DataStream(int value, int k): val(value), last(k) {}\\n    \\n    bool consec(int num) {\\n        num==val? ++curr: curr=0;\\n        return curr<last? false: true;\\n    }\\n    \\nprivate:\\n    const int val, last;\\n    int curr=0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049670,
                "title": "2-lines-c-o-n-without-any-data-structure-simple-easy",
                "content": "# Approach\\nif the current number = value , so increaase cnt by 1\\nelse it means that the last k numbers are no longer = value, so cnt = 0\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream \\n{\\npublic:\\n    int v, k, cnt;\\n    DataStream(int value, int kk) \\n    {\\n        v = value;\\n        k = kk;\\n        cnt = 0;\\n    }\\n    \\n    bool consec(int num) \\n    {\\n        num == v ? cnt++ : cnt = 0;\\n        return cnt >= k;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream \\n{\\npublic:\\n    int v, k, cnt;\\n    DataStream(int value, int kk) \\n    {\\n        v = value;\\n        k = kk;\\n        cnt = 0;\\n    }\\n    \\n    bool consec(int num) \\n    {\\n        num == v ? cnt++ : cnt = 0;\\n        return cnt >= k;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047045,
                "title": "pure-list-simple-solution",
                "content": "# Code\\n```\\npublic class DataStream {\\n    List<bool> list;\\n    int _value, _k, len;\\n    public DataStream(int value, int k) {\\n        list = new List<bool>();\\n        _value = value;\\n        _k = k;\\n        len = 1;\\n    }\\n    \\n    public bool Consec(int num) {\\n        if(num != _value){\\n            len=1;\\n            list.Add(false);\\n            return false;\\n        }\\n        else if(num == _value && len < _k){\\n            len++;\\n            list.Add(false);\\n        }\\n        else{\\n            len++;\\n            list.Add(true);\\n        }\\n        return list.Last();\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * bool param_1 = obj.Consec(num);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class DataStream {\\n    List<bool> list;\\n    int _value, _k, len;\\n    public DataStream(int value, int k) {\\n        list = new List<bool>();\\n        _value = value;\\n        _k = k;\\n        len = 1;\\n    }\\n    \\n    public bool Consec(int num) {\\n        if(num != _value){\\n            len=1;\\n            list.Add(false);\\n            return false;\\n        }\\n        else if(num == _value && len < _k){\\n            len++;\\n            list.Add(false);\\n        }\\n        else{\\n            len++;\\n            list.Add(true);\\n        }\\n        return list.Last();\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * bool param_1 = obj.Consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046416,
                "title": "easiest-sol-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int v;\\n       int cnt=0;\\nint r;\\n    DataStream(int value, int k) {\\n        v=value;\\n        r=k;\\n    }\\n    \\n    bool consec(int num) {\\n     if(num==v){\\n         cnt++;\\n     }\\n        else cnt=0;\\n        \\n        \\n        return cnt>=r;\\n        \\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int v;\\n       int cnt=0;\\nint r;\\n    DataStream(int value, int k) {\\n        v=value;\\n        r=k;\\n    }\\n    \\n    bool consec(int num) {\\n     if(num==v){\\n         cnt++;\\n     }\\n        else cnt=0;\\n        \\n        \\n        return cnt>=r;\\n        \\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046137,
                "title": "js-with-tracker-var",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function(value, k) {\\n    this.stream = [];\\n    this.value = value;\\n    this.k = k;\\n    this.tracker = 0;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function(num) {\\n    this.stream.push(num);\\n    if (num === this.value) this.tracker += 1;\\n    else this.tracker = 0;\\n    if (this.stream.length < this.k) return false;\\n    if (this.stream.length >= this.k && this.tracker >= this.k) {\\n        return true;\\n    } else return false;\\n};\\n\\n/** \\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} value\\n * @param {number} k\\n */\\nvar DataStream = function(value, k) {\\n    this.stream = [];\\n    this.value = value;\\n    this.k = k;\\n    this.tracker = 0;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nDataStream.prototype.consec = function(num) {\\n    this.stream.push(num);\\n    if (num === this.value) this.tracker += 1;\\n    else this.tracker = 0;\\n    if (this.stream.length < this.k) return false;\\n    if (this.stream.length >= this.k && this.tracker >= this.k) {\\n        return true;\\n    } else return false;\\n};\\n\\n/** \\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3045217,
                "title": "c-easy-queue",
                "content": "```\\nclass DataStream {\\n    int val,k1;\\n    int truth;\\n    queue<int> ds;\\npublic:\\n    DataStream(int value, int k) {\\n        //ds.clear();\\n        queue<int> emp;\\n        swap(ds,emp);\\n        k1 = k;\\n        truth = 0;\\n        val = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(ds.size()==k1)\\n        {\\n            if(ds.front()!=val)\\n                truth--;\\n            ds.pop();\\n        }\\n        if(num!=val)\\n            truth++;\\n        ds.push(num);\\n        if(ds.size()<k1)\\n            return false;\\n        else if(truth==0)\\n            return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass DataStream {\\n    int val,k1;\\n    int truth;\\n    queue<int> ds;\\npublic:\\n    DataStream(int value, int k) {\\n        //ds.clear();\\n        queue<int> emp;\\n        swap(ds,emp);\\n        k1 = k;\\n        truth = 0;\\n        val = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(ds.size()==k1)\\n        {\\n            if(ds.front()!=val)\\n                truth--;\\n            ds.pop();\\n        }\\n        if(num!=val)\\n            truth++;\\n        ds.push(num);\\n        if(ds.size()<k1)\\n            return false;\\n        else if(truth==0)\\n            return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043414,
                "title": "c-1-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int v, n, cnt;\\n    DataStream(int value, int k) {\\n        v = value;\\n        n = k;\\n        cnt = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        return (cnt = (num == v)* (cnt+(num == v))) >= n;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int v, n, cnt;\\n    DataStream(int value, int k) {\\n        v = value;\\n        n = k;\\n        cnt = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        return (cnt = (num == v)* (cnt+(num == v))) >= n;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041945,
                "title": "easy-c-solution-accepted",
                "content": "# Code\\n```\\nclass DataStream {\\npublic:\\n    int n,max;\\n    DataStream(int value, int k) {\\n        n = value;\\n        max = k;\\n    }\\n    int cnt = 0;\\n    bool consec(int num) {\\n        if(num==n) cnt++;\\n        else if(num != n) cnt= 0;\\n        if(cnt>=max) \\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Counting"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int n,max;\\n    DataStream(int value, int k) {\\n        n = value;\\n        max = k;\\n    }\\n    int cnt = 0;\\n    bool consec(int num) {\\n        if(num==n) cnt++;\\n        else if(num != n) cnt= 0;\\n        if(cnt>=max) \\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040908,
                "title": "java-obvious",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n    int val;\\n    int N;\\n    int ans;\\n\\n    public DataStream(int value, int k) {\\n      val = value;\\n      N = k;\\n      ans = 0;\\n    }\\n    \\n    public boolean consec(int num) {\\n      ans = num == val ? ans + 1 : 0; \\n      return ans >= N;  \\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    int val;\\n    int N;\\n    int ans;\\n\\n    public DataStream(int value, int k) {\\n      val = value;\\n      N = k;\\n      ans = 0;\\n    }\\n    \\n    public boolean consec(int num) {\\n      ans = num == val ? ans + 1 : 0; \\n      return ans >= N;  \\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038734,
                "title": "queue-sliding-window-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can only return true when we have atleast k elements already inputted, and out of those k elements all are of the same given value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe use a queue to store the positions of elements that are not equal to value.\\nif the current window size is greater than or equal to k and the q is empty ( there are no non value elements in the sliding window) then we return true else we return false.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int limit=0;\\n    int val=0;\\n   \\n    int len=0;\\n    set<int>st;\\n    queue<int>q;\\n    DataStream(int value, int k) {\\n        limit=k;\\n        val=value;\\n    }\\n    \\n    bool consec(int num) {\\n       \\n       if(num!=val)\\n        q.push(len);\\n        \\n        len++;\\n        \\n       \\n    if(!q.empty()){\\nint temp=q.front();\\nif(temp+limit<len)\\nq.pop();\\n    \\n    }\\n\\n    if(len>=limit && q.empty() )\\n    return true;\\n    \\n    return false ;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```\\n\\n\\nUPVOTE IF YOU FOUND THIS HELPFUL!!!!",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int limit=0;\\n    int val=0;\\n   \\n    int len=0;\\n    set<int>st;\\n    queue<int>q;\\n    DataStream(int value, int k) {\\n        limit=k;\\n        val=value;\\n    }\\n    \\n    bool consec(int num) {\\n       \\n       if(num!=val)\\n        q.push(len);\\n        \\n        len++;\\n        \\n       \\n    if(!q.empty()){\\nint temp=q.front();\\nif(temp+limit<len)\\nq.pop();\\n    \\n    }\\n\\n    if(len>=limit && q.empty() )\\n    return true;\\n    \\n    return false ;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037761,
                "title": "fastest-solution-with-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class DataStream {\\n    public Queue<int> vals = new Queue<int>();\\n    public int index;\\n    public int val;\\n    public DataStream(int value, int k) {\\n        val = value;\\n        index = k;\\n    }\\n    \\n    public bool Consec(int num) {\\n        vals.Enqueue(num);\\n        while(vals.Count()>0 && vals.Peek()!=num){\\n            vals.Dequeue();\\n        }\\n        if(num!=val){\\n            return false;\\n        }\\n        return vals.Count()>=index;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * bool param_1 = obj.Consec(num);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class DataStream {\\n    public Queue<int> vals = new Queue<int>();\\n    public int index;\\n    public int val;\\n    public DataStream(int value, int k) {\\n        val = value;\\n        index = k;\\n    }\\n    \\n    public bool Consec(int num) {\\n        vals.Enqueue(num);\\n        while(vals.Count()>0 && vals.Peek()!=num){\\n            vals.Dequeue();\\n        }\\n        if(num!=val){\\n            return false;\\n        }\\n        return vals.Count()>=index;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * bool param_1 = obj.Consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036308,
                "title": "simple-queue-soln",
                "content": "```\\nclass DataStream {\\n    int sum=0;\\n    Queue<Integer>q;\\n    int value;\\n    int k;\\n    public DataStream(int value, int k) {\\n        q=new LinkedList<>();\\n        this.value=value;\\n        this.k=k;\\n    }\\n    \\n    public boolean consec(int num) {\\n         if(q.size() >= k) {\\n            int zz = q.poll();\\n            if(zz == value) sum--;\\n        }\\n        if(num == value) sum++;\\n        q.add(num);\\n        if(sum == k) return true;\\n        return false;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n    int sum=0;\\n    Queue<Integer>q;\\n    int value;\\n    int k;\\n    public DataStream(int value, int k) {\\n        q=new LinkedList<>();\\n        this.value=value;\\n        this.k=k;\\n    }\\n    \\n    public boolean consec(int num) {\\n         if(q.size() >= k) {\\n            int zz = q.poll();\\n            if(zz == value) sum--;\\n        }\\n        if(num == value) sum++;\\n        q.add(num);\\n        if(sum == k) return true;\\n        return false;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3035952,
                "title": "ruby-concise-solution",
                "content": "```\\nclass DataStream\\n  def initialize(value, k)\\n    @index = @sequential_count = 0\\n    @k = k\\n    @value = value\\n  end\\n\\n  def consec(num)\\n    @sequential_count = num == @value ? @sequential_count + 1 : 0\\n    @index = (@index + 1) % @k\\n    @sequential_count >= @k\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nclass DataStream\\n  def initialize(value, k)\\n    @index = @sequential_count = 0\\n    @k = k\\n    @value = value\\n  end\\n\\n  def consec(num)\\n    @sequential_count = num == @value ? @sequential_count + 1 : 0\\n    @index = (@index + 1) % @k\\n    @sequential_count >= @k\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035713,
                "title": "easy-understanding-java-solution",
                "content": "```\\nclass DataStream {\\n\\n    int val,kk;\\n    int count=0;\\n    public DataStream(int value, int k) {\\n        val=value;\\n        kk=k;\\n    }\\n    public boolean consec(int num) {\\n        \\n            if(num==val)\\n                count++;\\n            else\\n                count=0;\\n            if(count>=kk)\\n                return true;\\n            return false;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass DataStream {\\n\\n    int val,kk;\\n    int count=0;\\n    public DataStream(int value, int k) {\\n        val=value;\\n        kk=k;\\n    }\\n    public boolean consec(int num) {\\n        \\n            if(num==val)\\n                count++;\\n            else\\n                count=0;\\n            if(count>=kk)\\n                return true;\\n            return false;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035670,
                "title": "java-simple-solution-0-1-space-o-n-complexity",
                "content": "# Intuition\\nwe need to check last 3 elements\\n\\n# Approach\\nwe can maintain a variable for this if value is not equal turn count to zero else increase count value.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass DataStream {\\nint v;\\nint c;\\nint cr;\\n    public DataStream(int value, int k) {\\n\\n    v=value;\\n    cr = k;\\n    c=0;\\n\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num==v)\\n        c++;\\n        else\\n        c=0;\\n        if(c>=cr)return true;\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\nint v;\\nint c;\\nint cr;\\n    public DataStream(int value, int k) {\\n\\n    v=value;\\n    cr = k;\\n    c=0;\\n\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num==v)\\n        c++;\\n        else\\n        c=0;\\n        if(c>=cr)return true;\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035457,
                "title": "php-solution",
                "content": "# Code\\n```\\nclass DataStream {\\n    private $k;\\n    private $value;\\n    private $counter;\\n\\n    public function __construct($value, $k) {\\n        $this->k = $k;\\n        $this->value = $value;\\n        $this->counter = 0;\\n    }\\n\\n    public function consec($num) {\\n        if ($num == $this->value) {\\n            $this->counter++;\\n        } else {\\n            $this->counter = 0;\\n        }\\n        return $this->counter >= $this->k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass DataStream {\\n    private $k;\\n    private $value;\\n    private $counter;\\n\\n    public function __construct($value, $k) {\\n        $this->k = $k;\\n        $this->value = $value;\\n        $this->counter = 0;\\n    }\\n\\n    public function consec($num) {\\n        if ($num == $this->value) {\\n            $this->counter++;\\n        } else {\\n            $this->counter = 0;\\n        }\\n        return $this->counter >= $this->k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035360,
                "title": "intuitive-simulation-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n\\n    int consec_ {0};\\n    int target_ {0};\\n    int value_ {0};\\n\\npublic:\\n    DataStream(int value, int k) {\\n        target_ = k;\\n        value_ = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if (value_ == num) {\\n            consec_++;\\n        } else {\\n            consec_ = 0;\\n        }\\n        return consec_ >= target_;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\n\\n    int consec_ {0};\\n    int target_ {0};\\n    int value_ {0};\\n\\npublic:\\n    DataStream(int value, int k) {\\n        target_ = k;\\n        value_ = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if (value_ == num) {\\n            consec_++;\\n        } else {\\n            consec_ = 0;\\n        }\\n        return consec_ >= target_;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035321,
                "title": "very-easy-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\n    n : number\\n    val : number\\n    result : number[]\\n    constructor(value: number, k: number) {\\n        this.n = k\\n        this.val = value\\n        this.result  = []\\n    }\\n\\n    consec(num: number): boolean {\\n        this.result.push(num)\\n        if(this.result.length < this.n) return false\\n    \\n        for(let i = this.result.length - this.n ; i< this.result.length ; i++){\\n            if(this.result[i] !== this.val) return false\\n        }\\n        return true\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass DataStream {\\n    n : number\\n    val : number\\n    result : number[]\\n    constructor(value: number, k: number) {\\n        this.n = k\\n        this.val = value\\n        this.result  = []\\n    }\\n\\n    consec(num: number): boolean {\\n        this.result.push(num)\\n        if(this.result.length < this.n) return false\\n    \\n        for(let i = this.result.length - this.n ; i< this.result.length ; i++){\\n            if(this.result[i] !== this.val) return false\\n        }\\n        return true\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * var obj = new DataStream(value, k)\\n * var param_1 = obj.consec(num)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033851,
                "title": "rust-solution",
                "content": "# Code\\n```\\nstruct DataStream {\\n    value: i32,\\n    k: i32,\\n    n: i32,\\n}\\n\\nimpl DataStream {\\n    fn new(value: i32, k: i32) -> Self {\\n        Self { value, k, n: 0 }\\n    }\\n\\n    fn consec(&mut self, num: i32) -> bool {\\n        match num == self.value {\\n            true => self.n += 1,\\n            false => self.n = 0,\\n        }\\n        self.n >= self.k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Data Stream"
                ],
                "code": "```\\nstruct DataStream {\\n    value: i32,\\n    k: i32,\\n    n: i32,\\n}\\n\\nimpl DataStream {\\n    fn new(value: i32, k: i32) -> Self {\\n        Self { value, k, n: 0 }\\n    }\\n\\n    fn consec(&mut self, num: i32) -> bool {\\n        match num == self.value {\\n            true => self.n += 1,\\n            false => self.n = 0,\\n        }\\n        self.n >= self.k\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3028690,
                "title": "o-k-memory-to-o-1-memory",
                "content": "# Code\\n```\\nclass DataStream {\\npublic:\\n    long long k;\\n    long long value;\\n    long long count=0;\\n    queue<int> q;\\n    DataStream(int value, int k) {\\n        this->k=k;\\n        this->value=value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=value) count++;\\n        q.push(num);\\n        if(q.size()<k) return false;\\n        else if(q.size()>k) {\\n            int x=q.front();\\n            q.pop();\\n            if(x!=value) count--;\\n        }\\n        return count==0;\\n        \\n        \\n        \\n    }\\n};\\n\\n```\\n- Space complexity: O(k)\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    long long k;\\n    long long value;\\n    long long count=0;\\n\\n    DataStream(int value, int k) {\\n        this->k=k;\\n        this->value=value;\\n    }\\n    \\n    bool consec(int num) {\\n       if(num==value) count++;\\n       else count=0;\\n       return count>=k; \\n\\n\\n    }\\n};\\n\\n```\\n\\n- Space complexity: O(1)\\n- Time Complexity: Same for both the cases, equal to number of calls made to **consec** function.",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    long long k;\\n    long long value;\\n    long long count=0;\\n    queue<int> q;\\n    DataStream(int value, int k) {\\n        this->k=k;\\n        this->value=value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=value) count++;\\n        q.push(num);\\n        if(q.size()<k) return false;\\n        else if(q.size()>k) {\\n            int x=q.front();\\n            q.pop();\\n            if(x!=value) count--;\\n        }\\n        return count==0;\\n        \\n        \\n        \\n    }\\n};\\n\\n```\n```\\nclass DataStream {\\npublic:\\n    long long k;\\n    long long value;\\n    long long count=0;\\n\\n    DataStream(int value, int k) {\\n        this->k=k;\\n        this->value=value;\\n    }\\n    \\n    bool consec(int num) {\\n       if(num==value) count++;\\n       else count=0;\\n       return count>=k; \\n\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028388,
                "title": "easy-to-understand-java-solution",
                "content": "# Intuition\\nAt the first intuition, we think we need to store element in an array, then we realise we only need to store last k values.\\n\\n# Approach\\nBut here we can maintain a count which increase if given value comes and if different value comes, make it zero.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass DataStream {\\n\\n    int c = 0, k, value;\\n\\n    public DataStream(int value, int k) {\\n        this.value = value;\\n        this.k = k;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num == value) c++;  // increase if same value\\n        else c = 0;     // reset counter\\n        return c >= k;  // return true if count is more than k\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DataStream {\\n\\n    int c = 0, k, value;\\n\\n    public DataStream(int value, int k) {\\n        this.value = value;\\n        this.k = k;\\n    }\\n    \\n    public boolean consec(int num) {\\n        if(num == value) c++;  // increase if same value\\n        else c = 0;     // reset counter\\n        return c >= k;  // return true if count is more than k\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * boolean param_1 = obj.consec(num);\\n */\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028123,
                "title": "c-solution-easy-to-understand-using-unordered-map-o-1-time-o-n-space",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    int val,cap;\\n   unordered_map<int,int>mp;\\n    DataStream(int value, int k) {\\n        cap=k;\\n        val=value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=val){\\n            if(mp.count(val)){\\n                mp.erase(val);\\n            }\\n            return false;\\n        }\\n        if(val==num)\\n        {\\n            mp[val]++;\\n        }\\n        return mp[val]>=cap;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Queue",
                    "Counting",
                    "Data Stream"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val,cap;\\n   unordered_map<int,int>mp;\\n    DataStream(int value, int k) {\\n        cap=k;\\n        val=value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num!=val){\\n            if(mp.count(val)){\\n                mp.erase(val);\\n            }\\n            return false;\\n        }\\n        if(val==num)\\n        {\\n            mp[val]++;\\n        }\\n        return mp[val]>=cap;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028103,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class DataStream {\\n    public int _value;\\n    public int _k;\\n    public DataStream(int value, int k) {\\n        _value = value;\\n        _k = k;\\n    }\\n    public List<int> list = new List<int>();\\n    public bool Consec(int num) {\\n        list.Add(num);\\n        if(list.Count < _k){\\n            return false;\\n        }\\n        for(int i = list.Count - _k; i < list.Count; i++){\\n            if(list[i] != _value){\\n                list.Remove(list[0]);\\n                return false;\\n            }\\n        }\\n        list.Remove(list[0]);\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * bool param_1 = obj.Consec(num);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class DataStream {\\n    public int _value;\\n    public int _k;\\n    public DataStream(int value, int k) {\\n        _value = value;\\n        _k = k;\\n    }\\n    public List<int> list = new List<int>();\\n    public bool Consec(int num) {\\n        list.Add(num);\\n        if(list.Count < _k){\\n            return false;\\n        }\\n        for(int i = list.Count - _k; i < list.Count; i++){\\n            if(list[i] != _value){\\n                list.Remove(list[0]);\\n                return false;\\n            }\\n        }\\n        list.Remove(list[0]);\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream obj = new DataStream(value, k);\\n * bool param_1 = obj.Consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026918,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    DataStream(int value, int k) {\\n        _counter = 0;\\n        _k = k;\\n        _value = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num != _value)\\n            _counter = 0;\\n        else\\n            _counter++;\\n        return _counter >= _k;\\n    }\\nprivate:\\n    int _k;\\n    int _counter;\\n    int _value;\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    DataStream(int value, int k) {\\n        _counter = 0;\\n        _k = k;\\n        _value = value;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num != _value)\\n            _counter = 0;\\n        else\\n            _counter++;\\n        return _counter >= _k;\\n    }\\nprivate:\\n    int _k;\\n    int _counter;\\n    int _value;\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026797,
                "title": "python-simple-deque-solution",
                "content": "# Approach\\n1) Use $$deque$$ to store last k-elements and $$defaultdict$$, to count numbers in this deque\\n2) On each $$consec$$ call we check length of deque. If it equals k - remove left element and recalculate stat. \\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nfrom collections import defaultdict, deque\\n\\n\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.dq = deque([])\\n        self.stat = defaultdict(int)\\n        self.to_len = k\\n        self.to_cmp = value\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if len(self.dq) == self.to_len:\\n            pop = self.dq.popleft()\\n            self.stat[pop] -= 1\\n        self.dq.append(num)\\n        self.stat[num] += 1\\n        return self.stat[self.to_cmp] == self.to_len\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Stack"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\n\\nclass DataStream:\\n\\n    def __init__(self, value: int, k: int):\\n        self.dq = deque([])\\n        self.stat = defaultdict(int)\\n        self.to_len = k\\n        self.to_cmp = value\\n        \\n\\n    def consec(self, num: int) -> bool:\\n        if len(self.dq) == self.to_len:\\n            pop = self.dq.popleft()\\n            self.stat[pop] -= 1\\n        self.dq.append(num)\\n        self.stat[num] += 1\\n        return self.stat[self.to_cmp] == self.to_len\\n\\n\\n# Your DataStream object will be instantiated and called as such:\\n# obj = DataStream(value, k)\\n# param_1 = obj.consec(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026720,
                "title": "c-queue-hash-table-100-fast",
                "content": "# Intuition\\nAt a time we just need to keep track of last k elements and adjust their frequencies accordingly\\n\\n# Approach\\nFor keeping track of elements, we\\'ll use Queue and frequencies can be managed by Hash Table\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass DataStream {\\npublic:\\n    queue<int> datastream;\\n    unordered_map<int,int> fq;\\n    int maxlen;\\n    int checkVal;\\n    int curSize;\\n    \\n    DataStream(int value, int k) {\\n        checkVal = value;\\n        maxlen = k;\\n        curSize = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        datastream.push(num);\\n        curSize++;\\n        fq[num]++;\\n        if(curSize > maxlen)\\n        {\\n            fq[datastream.front()]--;\\n            datastream.pop();\\n            curSize--;\\n        }\\n        \\n        if(fq[checkVal] == maxlen)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n    \\n    \\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Queue"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    queue<int> datastream;\\n    unordered_map<int,int> fq;\\n    int maxlen;\\n    int checkVal;\\n    int curSize;\\n    \\n    DataStream(int value, int k) {\\n        checkVal = value;\\n        maxlen = k;\\n        curSize = 0;\\n    }\\n    \\n    bool consec(int num) {\\n        datastream.push(num);\\n        curSize++;\\n        fq[num]++;\\n        if(curSize > maxlen)\\n        {\\n            fq[datastream.front()]--;\\n            datastream.pop();\\n            curSize--;\\n        }\\n        \\n        if(fq[checkVal] == maxlen)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n    \\n    \\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026473,
                "title": "simplest-c",
                "content": "```\\nclass DataStream {\\npublic:\\n    int v,ka,cnt=0;\\n    DataStream(int value, int k) {\\n        v=value;\\n        ka=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==v)\\n            cnt++;\\n        else\\n            cnt=0;\\n        if(cnt>=ka)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass DataStream {\\npublic:\\n    int v,ka,cnt=0;\\n    DataStream(int value, int k) {\\n        v=value;\\n        ka=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==v)\\n            cnt++;\\n        else\\n            cnt=0;\\n        if(cnt>=ka)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026146,
                "title": "easiest-best-solution-in-c-o-1-sc",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**PLease Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass DataStream {\\npublic:\\n    int val,k1,x=0;\\n    DataStream(int value, int k) {\\n        val=value,k1=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val)\\n            x++;\\n        else \\n            x=0;\\n        if(x>=k1)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DataStream {\\npublic:\\n    int val,k1,x=0;\\n    DataStream(int value, int k) {\\n        val=value,k1=k;\\n    }\\n    \\n    bool consec(int num) {\\n        if(num==val)\\n            x++;\\n        else \\n            x=0;\\n        if(x>=k1)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n\\n/**\\n * Your DataStream object will be instantiated and called as such:\\n * DataStream* obj = new DataStream(value, k);\\n * bool param_1 = obj->consec(num);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1779586,
                "content": [
                    {
                        "username": "aarondevelops",
                        "content": "I landed on the \"counter\" solution as well, like so:\\n```\\nif(num == desiredValue) {\\n    consecutiveValues += 1;\\n}\\nelse {\\n     consecutiveValues = 0;\\n}\\n\\nreturn consecutiveValues >= desiredParsed;\\n```\\nHowever, I was surprised to find that this only beat 61% of solutions for runtime. I cannot think of how to improve that further, any suggestions?"
                    },
                    {
                        "username": "souravsinha",
                        "content": "Very weak test cases.\nThe below  code should fail the testcase -[\"DataStream\",\"consec\",\"consec\",\"consec\",\"consec\" , \"consec\" , \"consec\"]\n[[4,3],[4],[4],[4],[3] , [4] , [4]]\nbut the solution is accepted.\n```\n   if(num == value) ++ans;\n        \n        else if(ans > 0 && num != value) --ans;\n        \n        if(ans == k)\n        {\n            --ans;\n            return true;\n        }\n        \n        return false;\n```\n\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Easy but good question. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me make it more efficient?**\\n*I am not posting the solution here as this shows **TLE** just asking for suggestions for improvisation*\\nI removed the for loop that was iterating through the elements if the queue to check equality, in the hopes that it will save time and instead used this HashSet approach. But still to no avail...\\n```\\nclass DataStream {\\n    int value;\\n    int k;\\n    Queue<Integer> q = new LinkedList<>();\\n    public DataStream(int value, int k) {\\n        this.k = k;\\n        this.value = value;\\n    }\\n    \\n    public boolean consec(int num) \\n    {        \\n        if(q.size()<k)\\n            q.add(num);\\n\\n        if(q.size()==k)\\n        {\\n            HashSet<Integer> hSet = new HashSet<>(q);\\n            q.remove();\\n            if(hSet.contains(value) && hSet.size()==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "soham01",
                        "content": "You don\\'t need to maintain a data structure just keep a counter variable and whenever num == value increment the counter\\nif counter >= k return true, else if num != value counter = 0 and return false \\n"
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s a medium question for the ones who didn\\'t come up with a \"counter\" solution. Queue approach is more extensive"
                    }
                ]
            },
            {
                "id": 1746590,
                "content": [
                    {
                        "username": "aarondevelops",
                        "content": "I landed on the \"counter\" solution as well, like so:\\n```\\nif(num == desiredValue) {\\n    consecutiveValues += 1;\\n}\\nelse {\\n     consecutiveValues = 0;\\n}\\n\\nreturn consecutiveValues >= desiredParsed;\\n```\\nHowever, I was surprised to find that this only beat 61% of solutions for runtime. I cannot think of how to improve that further, any suggestions?"
                    },
                    {
                        "username": "souravsinha",
                        "content": "Very weak test cases.\nThe below  code should fail the testcase -[\"DataStream\",\"consec\",\"consec\",\"consec\",\"consec\" , \"consec\" , \"consec\"]\n[[4,3],[4],[4],[4],[3] , [4] , [4]]\nbut the solution is accepted.\n```\n   if(num == value) ++ans;\n        \n        else if(ans > 0 && num != value) --ans;\n        \n        if(ans == k)\n        {\n            --ans;\n            return true;\n        }\n        \n        return false;\n```\n\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Easy but good question. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me make it more efficient?**\\n*I am not posting the solution here as this shows **TLE** just asking for suggestions for improvisation*\\nI removed the for loop that was iterating through the elements if the queue to check equality, in the hopes that it will save time and instead used this HashSet approach. But still to no avail...\\n```\\nclass DataStream {\\n    int value;\\n    int k;\\n    Queue<Integer> q = new LinkedList<>();\\n    public DataStream(int value, int k) {\\n        this.k = k;\\n        this.value = value;\\n    }\\n    \\n    public boolean consec(int num) \\n    {        \\n        if(q.size()<k)\\n            q.add(num);\\n\\n        if(q.size()==k)\\n        {\\n            HashSet<Integer> hSet = new HashSet<>(q);\\n            q.remove();\\n            if(hSet.contains(value) && hSet.size()==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "soham01",
                        "content": "You don\\'t need to maintain a data structure just keep a counter variable and whenever num == value increment the counter\\nif counter >= k return true, else if num != value counter = 0 and return false \\n"
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s a medium question for the ones who didn\\'t come up with a \"counter\" solution. Queue approach is more extensive"
                    }
                ]
            },
            {
                "id": 1746620,
                "content": [
                    {
                        "username": "aarondevelops",
                        "content": "I landed on the \"counter\" solution as well, like so:\\n```\\nif(num == desiredValue) {\\n    consecutiveValues += 1;\\n}\\nelse {\\n     consecutiveValues = 0;\\n}\\n\\nreturn consecutiveValues >= desiredParsed;\\n```\\nHowever, I was surprised to find that this only beat 61% of solutions for runtime. I cannot think of how to improve that further, any suggestions?"
                    },
                    {
                        "username": "souravsinha",
                        "content": "Very weak test cases.\nThe below  code should fail the testcase -[\"DataStream\",\"consec\",\"consec\",\"consec\",\"consec\" , \"consec\" , \"consec\"]\n[[4,3],[4],[4],[4],[3] , [4] , [4]]\nbut the solution is accepted.\n```\n   if(num == value) ++ans;\n        \n        else if(ans > 0 && num != value) --ans;\n        \n        if(ans == k)\n        {\n            --ans;\n            return true;\n        }\n        \n        return false;\n```\n\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Easy but good question. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me make it more efficient?**\\n*I am not posting the solution here as this shows **TLE** just asking for suggestions for improvisation*\\nI removed the for loop that was iterating through the elements if the queue to check equality, in the hopes that it will save time and instead used this HashSet approach. But still to no avail...\\n```\\nclass DataStream {\\n    int value;\\n    int k;\\n    Queue<Integer> q = new LinkedList<>();\\n    public DataStream(int value, int k) {\\n        this.k = k;\\n        this.value = value;\\n    }\\n    \\n    public boolean consec(int num) \\n    {        \\n        if(q.size()<k)\\n            q.add(num);\\n\\n        if(q.size()==k)\\n        {\\n            HashSet<Integer> hSet = new HashSet<>(q);\\n            q.remove();\\n            if(hSet.contains(value) && hSet.size()==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "soham01",
                        "content": "You don\\'t need to maintain a data structure just keep a counter variable and whenever num == value increment the counter\\nif counter >= k return true, else if num != value counter = 0 and return false \\n"
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s a medium question for the ones who didn\\'t come up with a \"counter\" solution. Queue approach is more extensive"
                    }
                ]
            },
            {
                "id": 1747081,
                "content": [
                    {
                        "username": "aarondevelops",
                        "content": "I landed on the \"counter\" solution as well, like so:\\n```\\nif(num == desiredValue) {\\n    consecutiveValues += 1;\\n}\\nelse {\\n     consecutiveValues = 0;\\n}\\n\\nreturn consecutiveValues >= desiredParsed;\\n```\\nHowever, I was surprised to find that this only beat 61% of solutions for runtime. I cannot think of how to improve that further, any suggestions?"
                    },
                    {
                        "username": "souravsinha",
                        "content": "Very weak test cases.\nThe below  code should fail the testcase -[\"DataStream\",\"consec\",\"consec\",\"consec\",\"consec\" , \"consec\" , \"consec\"]\n[[4,3],[4],[4],[4],[3] , [4] , [4]]\nbut the solution is accepted.\n```\n   if(num == value) ++ans;\n        \n        else if(ans > 0 && num != value) --ans;\n        \n        if(ans == k)\n        {\n            --ans;\n            return true;\n        }\n        \n        return false;\n```\n\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Easy but good question. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me make it more efficient?**\\n*I am not posting the solution here as this shows **TLE** just asking for suggestions for improvisation*\\nI removed the for loop that was iterating through the elements if the queue to check equality, in the hopes that it will save time and instead used this HashSet approach. But still to no avail...\\n```\\nclass DataStream {\\n    int value;\\n    int k;\\n    Queue<Integer> q = new LinkedList<>();\\n    public DataStream(int value, int k) {\\n        this.k = k;\\n        this.value = value;\\n    }\\n    \\n    public boolean consec(int num) \\n    {        \\n        if(q.size()<k)\\n            q.add(num);\\n\\n        if(q.size()==k)\\n        {\\n            HashSet<Integer> hSet = new HashSet<>(q);\\n            q.remove();\\n            if(hSet.contains(value) && hSet.size()==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "soham01",
                        "content": "You don\\'t need to maintain a data structure just keep a counter variable and whenever num == value increment the counter\\nif counter >= k return true, else if num != value counter = 0 and return false \\n"
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s a medium question for the ones who didn\\'t come up with a \"counter\" solution. Queue approach is more extensive"
                    }
                ]
            },
            {
                "id": 1746780,
                "content": [
                    {
                        "username": "aarondevelops",
                        "content": "I landed on the \"counter\" solution as well, like so:\\n```\\nif(num == desiredValue) {\\n    consecutiveValues += 1;\\n}\\nelse {\\n     consecutiveValues = 0;\\n}\\n\\nreturn consecutiveValues >= desiredParsed;\\n```\\nHowever, I was surprised to find that this only beat 61% of solutions for runtime. I cannot think of how to improve that further, any suggestions?"
                    },
                    {
                        "username": "souravsinha",
                        "content": "Very weak test cases.\nThe below  code should fail the testcase -[\"DataStream\",\"consec\",\"consec\",\"consec\",\"consec\" , \"consec\" , \"consec\"]\n[[4,3],[4],[4],[4],[3] , [4] , [4]]\nbut the solution is accepted.\n```\n   if(num == value) ++ans;\n        \n        else if(ans > 0 && num != value) --ans;\n        \n        if(ans == k)\n        {\n            --ans;\n            return true;\n        }\n        \n        return false;\n```\n\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Easy but good question. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me make it more efficient?**\\n*I am not posting the solution here as this shows **TLE** just asking for suggestions for improvisation*\\nI removed the for loop that was iterating through the elements if the queue to check equality, in the hopes that it will save time and instead used this HashSet approach. But still to no avail...\\n```\\nclass DataStream {\\n    int value;\\n    int k;\\n    Queue<Integer> q = new LinkedList<>();\\n    public DataStream(int value, int k) {\\n        this.k = k;\\n        this.value = value;\\n    }\\n    \\n    public boolean consec(int num) \\n    {        \\n        if(q.size()<k)\\n            q.add(num);\\n\\n        if(q.size()==k)\\n        {\\n            HashSet<Integer> hSet = new HashSet<>(q);\\n            q.remove();\\n            if(hSet.contains(value) && hSet.size()==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "soham01",
                        "content": "You don\\'t need to maintain a data structure just keep a counter variable and whenever num == value increment the counter\\nif counter >= k return true, else if num != value counter = 0 and return false \\n"
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s a medium question for the ones who didn\\'t come up with a \"counter\" solution. Queue approach is more extensive"
                    }
                ]
            }
        ]
    }
]