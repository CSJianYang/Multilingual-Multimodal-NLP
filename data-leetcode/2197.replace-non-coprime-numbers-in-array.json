[
    {
        "title": "Replace Non-Coprime Numbers in Array",
        "question_content": "You are given an array of integers nums. Perform the following steps:\n\n\tFind any two adjacent numbers in nums that are non-coprime.\n\tIf no such numbers are found, stop the process.\n\tOtherwise, delete the two numbers and replace them with their LCM (Least Common Multiple).\n\tRepeat this process as long as you keep finding two adjacent non-coprime numbers.\n\nReturn the final modified array. It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.\nThe test cases are generated such that the values in the final array are less than or equal to 108.\nTwo values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.\n&nbsp;\nExample 1:\n\nInput: nums = [6,4,3,2,7,6,2]\nOutput: [12,7,6]\nExplanation: \n- (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [12,3,2,7,6,2].\n- (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [12,2,7,6,2].\n- (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [12,7,6,2].\n- (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,6].\nThere are no more adjacent non-coprime numbers in nums.\nThus, the final modified array is [12,7,6].\nNote that there are other ways to obtain the same resultant array.\n\nExample 2:\n\nInput: nums = [2,2,1,1,3,3,3]\nOutput: [2,1,1,3]\nExplanation: \n- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3,3].\n- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3].\n- (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [2,1,1,3].\nThere are no more adjacent non-coprime numbers in nums.\nThus, the final modified array is [2,1,1,3].\nNote that there are other ways to obtain the same resultant array.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 105\n\tThe test cases are generated such that the values in the final array are less than or equal to 108.",
        "solutions": [
            {
                "id": 1823596,
                "title": "c-python-stack-math",
                "content": "## Observations\\n\\nThis hint made the question very easy.\\n\\n```\\nIt can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.\\n```\\nIt could have been transformed to a trick question if this fact was not stated.\\n\\nNow, since the order doesn\\'t matter we have the following observations.\\n\\n### Observation 1\\n\\nIf we start processing from the first element one by one, we only care about the last two elements so we can simply check if they have a `gcd > 1` in `O(log(n))` time (using built in functions or Eucledian algorithm). If they are co-prime we can replace them with their LCM, more on that in `Observation 2`. Once replaced by the LCM we have reduced the previous two elements by one and thus we can check the LCM element with the 3rd last element. Eg: `[x,y,z]` -> `[x, LCM(y,z)]` -> `[LCM(x,(LCM(y,z)))]`. \\n\\nThis setting is similar to many stack related questions like:\\n\\n[1047. Remove All Adjacent Duplicates In String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/)\\n[1209. Remove All Adjacent Duplicates in String II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n[1717. Maximum Score From Removing Substrings](https://leetcode.com/problems/maximum-score-from-removing-substrings/)\\n\\nThus using a stack we can keep repeating this process until the stack is empty or the last two numbers are co-prime and then move on to the next iteration/element of the input and repeat.\\n\\n### Observation 2\\n\\nHow do we get `LCM` of two numbers? Well there is a mathematical formula to do that for two numbers `a` and `b`.\\n`LCM(a,b) * GCD(a,b) = a * b` therefore `LCM(a,b) = (a * b) / GCD(a,b)`.\\n\\nWe can use these two observations to formulate our solution.\\n\\n## Solution\\n**C++**\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> result;\\n        for(int &i:nums) {\\n            result.push_back(i);        // Push the new element in stack.\\n            while(result.size()>1&&__gcd(result.back(),result[result.size()-2])>1) {    // While we have two elements and they are not co-prime.\\n                long long a=result.back(),b=result[result.size()-2],g=__gcd(a,b);  // Get the last two numbers in the stack and their GCD.\\n                \\n                // Remove the two elements.\\n                result.pop_back();      \\n                result.pop_back();\\n                result.push_back(a*b/g); // Push the LCM of the two numbers, replacing them.\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Python**\\n\\nCredits to [@tojuna](https://leetcode.com/tojuna/) for the python solution, please upvote his comment!\\n```python\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n\\tstk = []\\n\\tfor num in nums:\\n\\t\\tstk.append(num)\\n\\t\\twhile len(stk) > 1 and gcd(stk[-1], stk[-2]) > 1:\\n\\t\\t\\tstk.append(lcm(stk.pop(), stk.pop()))\\n\\treturn stk\\n```\\n\\n## Complexity\\nSpace: `O(1)`. If you don\\'t consider the output space.\\nTime: `O(nlog(m))`. GCD of two numbers takes `O(log(min(a,b))`.\\n",
                "solutionTags": [],
                "code": "```\\nIt can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> result;\\n        for(int &i:nums) {\\n            result.push_back(i);        // Push the new element in stack.\\n            while(result.size()>1&&__gcd(result.back(),result[result.size()-2])>1) {    // While we have two elements and they are not co-prime.\\n                long long a=result.back(),b=result[result.size()-2],g=__gcd(a,b);  // Get the last two numbers in the stack and their GCD.\\n                \\n                // Remove the two elements.\\n                result.pop_back();      \\n                result.pop_back();\\n                result.push_back(a*b/g); // Push the LCM of the two numbers, replacing them.\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```python\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n\\tstk = []\\n\\tfor num in nums:\\n\\t\\tstk.append(num)\\n\\t\\twhile len(stk) > 1 and gcd(stk[-1], stk[-2]) > 1:\\n\\t\\t\\tstk.append(lcm(stk.pop(), stk.pop()))\\n\\treturn stk\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823798,
                "title": "java-c-python-stack-one-pass-solution",
                "content": "# **Explanation**\\nFor each number `a` in input array `A`,\\ncheck if it is coprime with the last number `b` in `res`.\\nIf it\\'s not coprime, then we can merge them by calculate `a * b / gcd(a, b)`.\\nand check we can continue to do this process.\\n\\nUntil it\\'s coprime with the last element in `res`,\\nwe append `a` at the end of `res`.\\n\\nWe do this for all elements `a` in `A`, and return the final result.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public List<Integer> replaceNonCoprimes(int[] A) {\\n        LinkedList<Integer> res = new LinkedList();\\n        for (int a : A) {\\n            while (true) {\\n                int last = res.isEmpty() ? 1 : res.getLast();\\n                int x = gcd(last, a);\\n                if (x == 1) break; // co-prime\\n                a *= res.removeLast() / x;\\n            }\\n            res.add(a);\\n        }\\n        return res;\\n    }\\n\\n    private int gcd(int a, int b) {\\n        return b > 0 ? gcd(b, a % b) : a;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    vector<int> replaceNonCoprimes(vector<int>& A) {\\n        vector<int> res;\\n        for (int a: A) {   \\n            while (true) {   \\n                int x = gcd(res.empty() ? 1 : res.back(), a);\\n                if (x == 1) break; // co-prime\\n                a *= res.back() / x;\\n                res.pop_back();\\n            }\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python3**\\n```py\\n    def replaceNonCoprimes(self, A):\\n        res = []\\n        for a in A:\\n            while True:\\n                x = math.gcd(res[-1] if res else 1, a)\\n                if x == 1: break # co-prime\\n                a *= res.pop() // x\\n            res.append(a)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public List<Integer> replaceNonCoprimes(int[] A) {\\n        LinkedList<Integer> res = new LinkedList();\\n        for (int a : A) {\\n            while (true) {\\n                int last = res.isEmpty() ? 1 : res.getLast();\\n                int x = gcd(last, a);\\n                if (x == 1) break; // co-prime\\n                a *= res.removeLast() / x;\\n            }\\n            res.add(a);\\n        }\\n        return res;\\n    }\\n\\n    private int gcd(int a, int b) {\\n        return b > 0 ? gcd(b, a % b) : a;\\n    }\\n```\n```cpp\\n    vector<int> replaceNonCoprimes(vector<int>& A) {\\n        vector<int> res;\\n        for (int a: A) {   \\n            while (true) {   \\n                int x = gcd(res.empty() ? 1 : res.back(), a);\\n                if (x == 1) break; // co-prime\\n                a *= res.back() / x;\\n                res.pop_back();\\n            }\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def replaceNonCoprimes(self, A):\\n        res = []\\n        for a in A:\\n            while True:\\n                x = math.gcd(res[-1] if res else 1, a)\\n                if x == 1: break # co-prime\\n                a *= res.pop() // x\\n            res.append(a)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823681,
                "title": "list",
                "content": "No need to overcomplicate. This is just a brute-force. Using the list just for fun; I feel it\\'s a bit easier to get right than a stack or two-pointer.\\n\\n**C++**\\n```cpp\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n    list<int> l(begin(nums), end(nums));\\n    for (auto it = begin(l); it != end(l); ++it)\\n        if (it != begin(l)) {\\n            int n1 = *prev(it), n2 = *it;\\n            int it_gcd = gcd(n1, n2);\\n            if (it_gcd > 1) {\\n                l.erase(prev(it));\\n                *it = (long long)n1 * n2 / it_gcd;\\n                --it;\\n            }\\n        }\\n    return vector<int>(begin(l), end(l));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n    list<int> l(begin(nums), end(nums));\\n    for (auto it = begin(l); it != end(l); ++it)\\n        if (it != begin(l)) {\\n            int n1 = *prev(it), n2 = *it;\\n            int it_gcd = gcd(n1, n2);\\n            if (it_gcd > 1) {\\n                l.erase(prev(it));\\n                *it = (long long)n1 * n2 / it_gcd;\\n                --it;\\n            }\\n        }\\n    return vector<int>(begin(l), end(l));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823592,
                "title": "c-in-place-simulation-o-nlogm-time-o-1-extra-space",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Simulation + Two Pointers\\n\\n**Intuition**: From left to right, replace two adjacent non-coprime numbers with their LCM. When a merge happens, try keep merging leftwards.\\n\\n**Algorithm**: `i` is a read pointer scaning `A` from left to right. `j` is a write pointer. After reading a new number `A[j] = A[i]`, we keep trying to merge `A[j]` with `A[j-1]` if they are non-coprime. The new `A[j-1]` after merge is `LCM(A[j], A[j-1])`.\\n\\n**Time Complexity**:\\n\\nSince `gcd(a, b)`\\'s time complexity is `log(min(a, b))`, the time complexity is `O(NlogM)` overall where `M` is the maximum number in `A`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/replace-non-coprime-numbers-in-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& A) {\\n        int j = 0, N = A.size();\\n        for (int i = 0; i < N; ++i, ++j) {\\n            A[j] = A[i];\\n            for (; j - 1 >= 0 && gcd(A[j], A[j - 1]) > 1; --j) { // When we can merge leftwards from `A[j]`, keep merging\\n                A[j - 1] = (long)A[j] * A[j - 1] / gcd(A[j], A[j - 1]); // replace `A[j-1]` with LCM of `A[j-1]` and `A[j]`.\\n            }\\n        }\\n        A.resize(j);\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/replace-non-coprime-numbers-in-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& A) {\\n        int j = 0, N = A.size();\\n        for (int i = 0; i < N; ++i, ++j) {\\n            A[j] = A[i];\\n            for (; j - 1 >= 0 && gcd(A[j], A[j - 1]) > 1; --j) { // When we can merge leftwards from `A[j]`, keep merging\\n                A[j - 1] = (long)A[j] * A[j - 1] / gcd(A[j], A[j - 1]); // replace `A[j-1]` with LCM of `A[j-1]` and `A[j]`.\\n            }\\n        }\\n        A.resize(j);\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823645,
                "title": "c-python3-javascript-stack-one-pass",
                "content": "## idea\\n- we process the numbers from left to right, when processing a number, merge it to the left (with the already processed elements) until we can\\'t.\\n- maintain the processed elements by a stack.\\n## code\\n- C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for (auto num : nums) {\\n            while (!res.empty() && gcd(res.back(), num) > 1) {\\n                num = lcm(res.back(), num);\\n                res.pop_back();\\n            }\\n            res.push_back(num);\\n        }\\n        return res;\\n    }\\n};\\n```\\n- Python3\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for num in nums:\\n            while res and gcd(res[-1], num) > 1:\\n                num = lcm(res[-1], num)\\n                res.pop()\\n            res.append(num)\\n        return res\\n```\\n- JavaScript (is there any built-in `gcd` or `lcm` in js?)\\n```\\nfunction gcd(a, b) {\\n    while (b > 0) {\\n        a %= b;\\n        [a, b] = [b, a];\\n    }\\n    return a;\\n}\\nfunction lcm(a, b) {\\n    return a / gcd(a, b) * b;\\n}\\n\\nvar replaceNonCoprimes = function(nums) {\\n    let res = new Array();\\n    for (let num of nums) {\\n        while (res.length > 0 && gcd(res.at(-1), num) > 1) {\\n            num = lcm(res.at(-1), num);\\n            res.pop();\\n        }\\n        res.push(num);\\n    }\\n    return res;\\n};\\n```\\n- Time Complexity\\n\\t- `O(n * log(1e8))` as we process each element once, and the complexity of both `gcd(a, b)` and `lcm(a, b)` are known to be `O(log(max(a, b)))`\\n- Space Complexity\\n\\t- `O(n)` used by `res`.\\n## Similar Problems\\n- Although the concepts are not exactly the same, the code of this problem looks like those related to **monotonic stacks**\\n- [LC 496 - Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/) (solve it in linear time)\\n- [LC 503 - Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/)\\n- [LC 739 - Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)\\n- [LC 402 - Remove K Digits](https://leetcode.com/problems/remove-k-digits/)\\n- [LC 1944 - Number of Visible People in a Queue](https://leetcode.com/problems/number-of-visible-people-in-a-queue/)\\n- [LC 84 - Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n- [LC 85 - Maximum Rectangle](https://leetcode.com/problems/maximal-rectangle/)\\n- [LC 1340 - Jump Game V](https://leetcode.com/problems/jump-game-v/)",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for (auto num : nums) {\\n            while (!res.empty() && gcd(res.back(), num) > 1) {\\n                num = lcm(res.back(), num);\\n                res.pop_back();\\n            }\\n            res.push_back(num);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for num in nums:\\n            while res and gcd(res[-1], num) > 1:\\n                num = lcm(res[-1], num)\\n                res.pop()\\n            res.append(num)\\n        return res\\n```\n```\\nfunction gcd(a, b) {\\n    while (b > 0) {\\n        a %= b;\\n        [a, b] = [b, a];\\n    }\\n    return a;\\n}\\nfunction lcm(a, b) {\\n    return a / gcd(a, b) * b;\\n}\\n\\nvar replaceNonCoprimes = function(nums) {\\n    let res = new Array();\\n    for (let num of nums) {\\n        while (res.length > 0 && gcd(res.at(-1), num) > 1) {\\n            num = lcm(res.at(-1), num);\\n            res.pop();\\n        }\\n        res.push(num);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823603,
                "title": "c-stack-time-complexity-nlogd",
                "content": "**Approach** - \\n\\n0) As in questions says we have to choose adjacent , then I thought **stack** can be used .\\n1) we have to check whether the top value in the stack and the current val in array is non-coprime or not.\\n2) If the **gcd>1** then it means they are non-coprime , so just take the lcm of top value from stack(pop it also) and the current value and push it back to stack.\\n\\nImpo-\\n\\n3)Now first I think this will be valid let\\'s take an example - \\n\\n```\\nA = [4 2 3 5]\\nA = [4,3,5] , 4 and 2 are non-coprime so replace with LCM(4)\\nA = [4,3,5] , 4 and 3 are coprime nothing happens\\nA = [4,3,5] , 3 and 5 are coprime nothing happens\\n```\\n\\nBut wait , take another example where this is wrong-\\n\\n```\\nA = [5,2,3,6]\\nA = [5,2,3,6] , 5 and 2 are coprime nothing happens\\nA = [5,2,3,6] , 2 and 3 are coprime nothing happens\\nA = [5,2,6] , 3 and 6 are non-coprime so replace with LCM(6)\\n\\nin last my stack contains [5,2 6], I returned , this is wrong.\\n```\\n\\n**we have to do step 2 , untill we have non-coprime value from the current element and the top element , and then return it.**\\n\\n\\n\\n\\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> replaceNonCoprimes(vector<int> &a)\\n        {\\n            stack<int> st;\\n            int n = a.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                int cr = a[i];\\n                int gcd, LCM, tp;\\n                while (!st.empty())\\n                {\\n\\n                    int gcd = __gcd(cr, st.top());\\n                    if (gcd > 1)\\n                    {\\n                        tp = st.top();\\n                        st.pop();\\n                        LCM = (cr / gcd) * tp;\\n                        cr = LCM;\\n                    }\\n                    else\\n                        break;\\n                }\\n                st.push(cr);\\n            }\\n\\n            vector<int> ans;\\n\\n            while (!st.empty())\\n            {\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n\\n            reverse(ans.begin(), ans.end());\\n\\n            return ans;\\n        }\\n};\\n```\\nTime complexity : **NlogD** , where D is **maxA** , correct me if I am wrong.\\n\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nA = [4 2 3 5]\\nA = [4,3,5] , 4 and 2 are non-coprime so replace with LCM(4)\\nA = [4,3,5] , 4 and 3 are coprime nothing happens\\nA = [4,3,5] , 3 and 5 are coprime nothing happens\\n```\n```\\nA = [5,2,3,6]\\nA = [5,2,3,6] , 5 and 2 are coprime nothing happens\\nA = [5,2,3,6] , 2 and 3 are coprime nothing happens\\nA = [5,2,6] , 3 and 6 are non-coprime so replace with LCM(6)\\n\\nin last my stack contains [5,2 6], I returned , this is wrong.\\n```\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> replaceNonCoprimes(vector<int> &a)\\n        {\\n            stack<int> st;\\n            int n = a.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                int cr = a[i];\\n                int gcd, LCM, tp;\\n                while (!st.empty())\\n                {\\n\\n                    int gcd = __gcd(cr, st.top());\\n                    if (gcd > 1)\\n                    {\\n                        tp = st.top();\\n                        st.pop();\\n                        LCM = (cr / gcd) * tp;\\n                        cr = LCM;\\n                    }\\n                    else\\n                        break;\\n                }\\n                st.push(cr);\\n            }\\n\\n            vector<int> ans;\\n\\n            while (!st.empty())\\n            {\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n\\n            reverse(ans.begin(), ans.end());\\n\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823618,
                "title": "easy-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n      if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n    }\\n\\n    int lcm(int a, int b) {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> modified;\\n        for (int i : nums) {\\n            int pre = 0, cur = i;\\n            while (modified.size() && gcd(modified.back(), cur) > 1) {\\n                pre  = modified.back();\\n                cur = lcm(cur, pre);\\n                modified.pop_back();\\n            }\\n            modified.push_back(cur);\\n        }\\n        \\n        return modified;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n      if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n    }\\n\\n    int lcm(int a, int b) {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> modified;\\n        for (int i : nums) {\\n            int pre = 0, cur = i;\\n            while (modified.size() && gcd(modified.back(), cur) > 1) {\\n                pre  = modified.back();\\n                cur = lcm(cur, pre);\\n                modified.pop_back();\\n            }\\n            modified.push_back(cur);\\n        }\\n        \\n        return modified;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823911,
                "title": "clean-java-code",
                "content": "\\tclass Solution {\\n\\t\\tpublic List<Integer> replaceNonCoprimes(int[] nums) \\n\\t\\t{\\n\\t\\t\\tList<Integer> al=new ArrayList<>();\\n\\t\\t\\tlong n1=nums[0];\\n\\t\\t\\tint idx=1;\\n\\n\\t\\t\\twhile(idx<nums.length)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((int)gcd(n1,nums[idx])==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile(al.size()!=0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint t=al.get(al.size()-1);\\n\\t\\t\\t\\t\\t\\tif(gcd(n1,t)==1)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tal.remove(al.size()-1);\\n\\t\\t\\t\\t\\t\\t\\tn1=lcm(t,n1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tal.add((int)n1);\\n\\t\\t\\t\\t\\tn1=nums[idx];\\n\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tn1=lcm(n1,nums[idx]);\\n\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(al.size()!=0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint t=al.get(al.size()-1);\\n\\t\\t\\t\\tif(gcd(n1,t)==1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tal.remove(al.size()-1);\\n\\t\\t\\t\\t\\tn1=lcm(t,n1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tal.add((int)n1);\\n\\n\\t\\t\\treturn al;\\n\\t\\t}\\n\\n\\t\\tpublic long gcd(long a,long b)\\n\\t\\t{\\n\\t\\t\\tif (b == 0)   \\n\\t\\t\\t\\treturn a;  \\n\\n\\t\\t\\treturn gcd(b, a % b);  \\n\\t\\t}\\n\\n\\t\\tpublic long lcm(long a,long b)\\n\\t\\t{\\n\\t\\t\\tlong hcf=gcd(a,b);\\n\\t\\t\\treturn (a*b)/hcf;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> replaceNonCoprimes(int[] nums) \\n\\t\\t{\\n\\t\\t\\tList<Integer> al=new ArrayList<>();\\n\\t\\t\\tlong n1=nums[0];\\n\\t\\t\\tint idx=1;\\n\\n\\t\\t\\twhile(idx<nums.length)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((int)gcd(n1,nums[idx])==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile(al.size()!=0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint t=al.get(al.size()-1);\\n\\t\\t\\t\\t\\t\\tif(gcd(n1,t)==1)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tal.remove(al.size()-1);\\n\\t\\t\\t\\t\\t\\t\\tn1=lcm(t,n1);\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1847170,
                "title": "c-stack-with-approach",
                "content": "**C++ solution with Time Complexity = O(nlog m) and space complexity O(n)**,\\nwhere the length of the array and the maximum number present in the array is m.\\n## Approach\\nLet the final array be ans. \\n1.  For each number ```curr``` in array ```nums```, check whether it is Coprime with the last number ```top``` of ```ans``` array. Now, we have two possibilities:\\n\\t\\t\\ta. If they are Coprime, then insert ```curr``` to ```ans```.\\n\\t\\t\\tb. If they are not Coprime, replace ```curr``` with ```LCM (top, curr)``` and pop the last element of ```ans```. Repeat 1 until ```top``` and ```curr``` are not Coprime.\\n\\n\\n```cpp\\nclass Solution\\n{\\n    private:\\n        bool isCoprime(int x, int y)\\t// O(logM)  where M is max(x, y)\\n        {\\n            return gcd(x, y) == 1;\\t\\t\\n        }\\n        int gcd(int x, int y)\\t\\t\\t// O(logM)  where M is max(x, y)\\n        {\\n            return __gcd(x, y);\\t\\t\\n        }\\n        int lcm(int x, int y)\\t\\t\\t// O(logM)  where M is max(x, y)\\n        {\\n            long long LCM = x;\\n            LCM *= y;\\n            LCM /= gcd(x, y);\\n            return LCM;\\n        }\\n    public:\\n        vector<int> replaceNonCoprimes(vector<int> &nums)\\n        {\\n\\n            vector<int> ans;\\n            int n = nums.size();\\n            ans.push_back(nums[0]);\\n            for (int i = 1; i < n; i++)\\n            {\\n                int curr = nums[i];\\n                while (ans.size() && !isCoprime(ans.back(), curr))\\n                {\\n                    int top = ans.back();\\n                    ans.pop_back();\\n                    curr = lcm(curr, top);\\n                }\\n                ans.push_back(curr);\\n            }\\n            return ans;\\n        }\\n};\\n```\\n*If you find this helpful, please consider giving an upvote!!*",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```curr```\n```nums```\n```top```\n```ans```\n```curr```\n```ans```\n```curr```\n```LCM (top, curr)```\n```ans```\n```top```\n```curr```\n```cpp\\nclass Solution\\n{\\n    private:\\n        bool isCoprime(int x, int y)\\t// O(logM)  where M is max(x, y)\\n        {\\n            return gcd(x, y) == 1;\\t\\t\\n        }\\n        int gcd(int x, int y)\\t\\t\\t// O(logM)  where M is max(x, y)\\n        {\\n            return __gcd(x, y);\\t\\t\\n        }\\n        int lcm(int x, int y)\\t\\t\\t// O(logM)  where M is max(x, y)\\n        {\\n            long long LCM = x;\\n            LCM *= y;\\n            LCM /= gcd(x, y);\\n            return LCM;\\n        }\\n    public:\\n        vector<int> replaceNonCoprimes(vector<int> &nums)\\n        {\\n\\n            vector<int> ans;\\n            int n = nums.size();\\n            ans.push_back(nums[0]);\\n            for (int i = 1; i < n; i++)\\n            {\\n                int curr = nums[i];\\n                while (ans.size() && !isCoprime(ans.back(), curr))\\n                {\\n                    int top = ans.back();\\n                    ans.pop_back();\\n                    curr = lcm(curr, top);\\n                }\\n                ans.push_back(curr);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621447,
                "title": "c-most-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto i: nums){\\n            while(!ans.empty() && __gcd(ans.back(),i) != 1){\\n                i = (i*1LL*ans.back())/__gcd(i,ans.back());\\n                ans.pop_back();\\n            }\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Stack",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto i: nums){\\n            while(!ans.empty() && __gcd(ans.back(),i) != 1){\\n                i = (i*1LL*ans.back())/__gcd(i,ans.back());\\n                ans.pop_back();\\n            }\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296323,
                "title": "stack-gcd-short-sweet-c-iterative-code",
                "content": "```\\n#define lli long long int\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        lli a,b;\\n        int n;\\n        vector<int> ans;\\n        for(auto &i: nums){\\n            ans.push_back(i);\\n            n = ans.size();\\n            while(n>1&&__gcd(ans[n-1],ans[n-2])>1){\\n                a = ans[n-1],b = ans[n-2];\\n                ans.pop_back();\\n                ans.pop_back();\\n                ans.push_back(a*b/__gcd(a,b));\\n                n--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\n#define lli long long int\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        lli a,b;\\n        int n;\\n        vector<int> ans;\\n        for(auto &i: nums){\\n            ans.push_back(i);\\n            n = ans.size();\\n            while(n>1&&__gcd(ans[n-1],ans[n-2])>1){\\n                a = ans[n-1],b = ans[n-2];\\n                ans.pop_back();\\n                ans.pop_back();\\n                ans.push_back(a*b/__gcd(a,b));\\n                n--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034901,
                "title": "easiest-python-code-7-line-code-99-faster-stack",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(nlogn)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for i in nums:\\n            toBeAppended = i\\n            while stack and gcd(stack[-1], toBeAppended) > 1:\\n                toBeAppended = lcm(toBeAppended, stack.pop())\\n            stack.append(toBeAppended)\\n        return stack        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for i in nums:\\n            toBeAppended = i\\n            while stack and gcd(stack[-1], toBeAppended) > 1:\\n                toBeAppended = lcm(toBeAppended, stack.pop())\\n            stack.append(toBeAppended)\\n        return stack        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289568,
                "title": "python-stack-solution",
                "content": "```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n\\tstack = [nums[0]]\\n\\tfor n in nums[1:]:\\n\\t\\tstack.append(n)\\n\\t\\twhile(len(stack)>=2 and gcd(stack[-1], stack[-2])>1):\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\tstack.append(a*b//gcd(a, b))\\n\\treturn stack\\n```",
                "solutionTags": [],
                "code": "```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n\\tstack = [nums[0]]\\n\\tfor n in nums[1:]:\\n\\t\\tstack.append(n)\\n\\t\\twhile(len(stack)>=2 and gcd(stack[-1], stack[-2])>1):\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\tstack.append(a*b//gcd(a, b))\\n\\treturn stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1856486,
                "title": "c-stack",
                "content": "* If the top two elements in stack are non coprime replace them with LCM of those two numbers and keep repeating this step until condition satisfies\\n```\\nclass Solution {\\npublic:\\n    #define ll long long  \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<ll> st ;\\n        for(int i = 0 ; i < nums.size() ;++i ){\\n            st.push(nums[i]) ;\\n            while(st.size() >= 2){\\n                ll a = st.top() ; st.pop() ;\\n                ll b = st.top() ; st.pop() ;\\n                if(__gcd(a,b) > 1) st.push((a*b) / __gcd(a,b)) ;\\n                else{\\n                    st.push(b) ; \\n                    st.push(a) ;\\n                    break ;\\n                }\\n            }\\n        }\\n        vector<int> ans ;\\n        while(!st.empty()){\\n            ans.push_back(st.top()) ;\\n            st.pop() ;\\n        }\\n        reverse(begin(ans),end(ans)) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long  \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<ll> st ;\\n        for(int i = 0 ; i < nums.size() ;++i ){\\n            st.push(nums[i]) ;\\n            while(st.size() >= 2){\\n                ll a = st.top() ; st.pop() ;\\n                ll b = st.top() ; st.pop() ;\\n                if(__gcd(a,b) > 1) st.push((a*b) / __gcd(a,b)) ;\\n                else{\\n                    st.push(b) ; \\n                    st.push(a) ;\\n                    break ;\\n                }\\n            }\\n        }\\n        vector<int> ans ;\\n        while(!st.empty()){\\n            ans.push_back(st.top()) ;\\n            st.pop() ;\\n        }\\n        reverse(begin(ans),end(ans)) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827205,
                "title": "c-one-pass-easy-to-understand",
                "content": "**Algorithm/Intuition:**\\n1. Traverse the array and push the elements onto the stack.\\n2. After pushing each element, **recursively** check if the gcd of the top 2 elements > 1. If yes, then they are co-prime. Pop both the elements and push their LCM into the stack. If not, then leave both the elements in the stack.\\n3. After all the elements have been pushed, pop them one by one and insert them into a vector and return. Alternatively, you can directly work on a vector(like a stack) and return it.\\n\\n**Example:**\\n\\nnums = [6,4,3,2,7,6,2]\\nInitially - stack is empty\\nFor 1st element, push 6 into stack. Then check if the top 2 elements have gcd > 1. Since there is only one element in the stack, we move to the next.\\nstack = [6]\\nFor the 2nd element, push 4 into the stack. Since [6, 4] have have gcd = 2, pop 6 and 4 and push their lcm 12 into the stack.\\nstack = [12]\\nFor the 3rd element, push 3 into the stack. Since [12, 3] has gcd = 3, therefore pop 12 and 3, and insert their lcm 12 into the stack.\\nstack = [12]\\nFor the 4th element, push 2 into the stack. Since [12, 2] has gcd = 2, therefore pop 12 and 2, and insert their lcm 12 into the stack.\\nstack = [12]\\nFor the 5th element, push 7 into the stack. Since [12, 7] have gcd = 1, we do nothing.\\nstack = [12, 7]\\nFor the 6th element, push 6 into stack. Since [7, 6] have gcd = 1, we do nothing.\\nstack = [12, 7, 6]\\nFor the 7th element, push 2 into the stack. Since [6, 2] have gcd = 2, we pop 2 and 6 and push their lcm 6 into the stack. Then, we check [7, 6] and since their gcd = 1, we do nothing.\\nstack = [12, 7, 6]\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> st;\\n        for(auto it : nums){\\n            //push elements one by one into the stack\\n            st.push_back(it);\\n            //recursively check if the top 2 elements have gcd > 1\\n            while(st.size() > 1){\\n                int n = st.size();\\n                //if the gcd > 1, then pop the top 2 elements and push their lcm into the stack\\n                //keep continuing this process until the gcd == 1 or only one element in the stack\\n                int gcd = __gcd(st[n - 2], st[n - 1]);\\n                if(gcd > 1){\\n                    //lcm = (a * b) / gcd(a, b)\\n                    int num = st[n - 1] * (st[n - 2] / gcd);\\n                    st.pop_back();\\n                    st.pop_back();\\n                    st.push_back(num);\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return st;\\n    }\\n};\\n```\\n**Time complexity** - O(nlogm) //logm due to gcd function\\n**Space complexity** - O(n)",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> st;\\n        for(auto it : nums){\\n            //push elements one by one into the stack\\n            st.push_back(it);\\n            //recursively check if the top 2 elements have gcd > 1\\n            while(st.size() > 1){\\n                int n = st.size();\\n                //if the gcd > 1, then pop the top 2 elements and push their lcm into the stack\\n                //keep continuing this process until the gcd == 1 or only one element in the stack\\n                int gcd = __gcd(st[n - 2], st[n - 1]);\\n                if(gcd > 1){\\n                    //lcm = (a * b) / gcd(a, b)\\n                    int num = st[n - 1] * (st[n - 2] / gcd);\\n                    st.pop_back();\\n                    st.pop_back();\\n                    st.push_back(num);\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825174,
                "title": "c-o-n-solution-my-own-intuitive-simple-approach-single-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n     stack<int>st;\\n        int n = nums.size();\\n        st.push(nums[0]);\\n        for(int i = 1; i <n;++i){\\n                st.push(nums[i]);\\n                    int t1 = st.top();st.pop();\\n                    int t2 = st.top();st.pop();\\n                    while(!st.empty() && gcd(t1,t2)>1){\\n                        long long z = lcm(t1,t2);\\n                        t2 = st.top();st.pop();\\n                        t1 = z;\\n                    }\\n            if(gcd(t1,t2)>1){\\n                st.push(lcm(t1,t2));\\n            }\\n            else{\\n                st.push(t2);\\n                st.push(t1);\\n            }\\n        }\\n        vector<int>v;\\n        while(!st.empty()){\\n            v.push_back(st.top());st.pop();\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n     stack<int>st;\\n        int n = nums.size();\\n        st.push(nums[0]);\\n        for(int i = 1; i <n;++i){\\n                st.push(nums[i]);\\n                    int t1 = st.top();st.pop();\\n                    int t2 = st.top();st.pop();\\n                    while(!st.empty() && gcd(t1,t2)>1){\\n                        long long z = lcm(t1,t2);\\n                        t2 = st.top();st.pop();\\n                        t1 = z;\\n                    }\\n            if(gcd(t1,t2)>1){\\n                st.push(lcm(t1,t2));\\n            }\\n            else{\\n                st.push(t2);\\n                st.push(t1);\\n            }\\n        }\\n        vector<int>v;\\n        while(!st.empty()){\\n            v.push_back(st.top());st.pop();\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824974,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        \\n        for(auto& x:nums){\\n            while(!ans.empty() && gcd(ans.back(), x)>1){\\n                x=lcm(ans.back(), x);\\n                ans.pop_back();\\n            }\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        \\n        for(auto& x:nums){\\n            while(!ans.empty() && gcd(ans.back(), x)>1){\\n                x=lcm(ans.back(), x);\\n                ans.pop_back();\\n            }\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824851,
                "title": "doubly-linked-list-in-python",
                "content": "By using doubly linked list, you can access the deletable pair in O(1) time.\\nEvery time you delete some pair, you need to add a new node with the value of lcm. Also, it might be possible that one of the pair is already deleted, so you need to keep track of which nodes are already deleted. (`wasted` stores all the finished nodes.)\\n\\n```\\nclass DoublyLinkedNode:\\n    def __init__(self, val=0):\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\nfrom math import gcd, lcm\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def connect(node1, node2):\\n            node1.next, node2.prev = node2, node1\\n        \\n        def are_deletable(node1, node2):\\n            return node1.val != 0 and node2.val != 0 and gcd(node1.val, node2.val) > 1\\n        \\n        #Create doubly linked list\\n        dummy_head, dummy_tail = DoublyLinkedNode(), DoublyLinkedNode()\\n        nodes = [DoublyLinkedNode(num) for num in nums]\\n        N = len(nodes)\\n        deletables = []\\n        for i in range(1, N):\\n            connect(nodes[i - 1], nodes[i])\\n            if are_deletable(nodes[i - 1], nodes[i]):\\n                deletables.append((nodes[i - 1], nodes[i]))\\n        connect(dummy_head, nodes[0]); connect(nodes[-1], dummy_tail);\\n        \\n        #connect adjacent nodes while deletables exist\\n        wasted = set()\\n        while deletables:\\n            node1, node2 = deletables.pop()\\n            if node1 in wasted or node2 in wasted:\\n                continue\\n            new_node = DoublyLinkedNode(val=lcm(node1.val, node2.val))\\n            connect(node1.prev, new_node); connect(new_node, node2.next);\\n            wasted.add(node1); wasted.add(node2);\\n            if are_deletable(new_node.prev, new_node):\\n                deletables.append((new_node.prev, new_node))\\n            if are_deletable(new_node, new_node.next):\\n                deletables.append((new_node, new_node.next)) \\n        \\n\\t\\t#output\\n        curr = dummy_head.next\\n        res = []\\n        while curr != dummy_tail:\\n            res.append(curr.val)\\n            curr = curr.next\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass DoublyLinkedNode:\\n    def __init__(self, val=0):\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\nfrom math import gcd, lcm\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def connect(node1, node2):\\n            node1.next, node2.prev = node2, node1\\n        \\n        def are_deletable(node1, node2):\\n            return node1.val != 0 and node2.val != 0 and gcd(node1.val, node2.val) > 1\\n        \\n        #Create doubly linked list\\n        dummy_head, dummy_tail = DoublyLinkedNode(), DoublyLinkedNode()\\n        nodes = [DoublyLinkedNode(num) for num in nums]\\n        N = len(nodes)\\n        deletables = []\\n        for i in range(1, N):\\n            connect(nodes[i - 1], nodes[i])\\n            if are_deletable(nodes[i - 1], nodes[i]):\\n                deletables.append((nodes[i - 1], nodes[i]))\\n        connect(dummy_head, nodes[0]); connect(nodes[-1], dummy_tail);\\n        \\n        #connect adjacent nodes while deletables exist\\n        wasted = set()\\n        while deletables:\\n            node1, node2 = deletables.pop()\\n            if node1 in wasted or node2 in wasted:\\n                continue\\n            new_node = DoublyLinkedNode(val=lcm(node1.val, node2.val))\\n            connect(node1.prev, new_node); connect(new_node, node2.next);\\n            wasted.add(node1); wasted.add(node2);\\n            if are_deletable(new_node.prev, new_node):\\n                deletables.append((new_node.prev, new_node))\\n            if are_deletable(new_node, new_node.next):\\n                deletables.append((new_node, new_node.next)) \\n        \\n\\t\\t#output\\n        curr = dummy_head.next\\n        res = []\\n        while curr != dummy_tail:\\n            res.append(curr.val)\\n            curr = curr.next\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823886,
                "title": "python-traverse-doubly-linked-o-n-sqrt-n",
                "content": "Intuition:\\n1. It\\'s easy to pop, but we need some data structure to improve time complexity of the merging ops -> Linked List\\n2. If traverse backward is needed, only the recently changed node should be considered. \\n```python\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        queue = deque(nums)\\n        # [2, 7, 2, 14]\\n        # [2, 7, 14]\\n        # [2, 14]\\n        # [14]\\n        \\n        # Need a better way to mark\\n        # to traverse between two\\n        # This would be much easier if this is a list\\n        class ListNode():\\n            def __init__(self, val, prev=None, nxt=None):\\n                self.val = val\\n                self.next = nxt\\n                self.prev = prev\\n                \\n        h = ListNode(nums[0])\\n        curr = h\\n        for n in nums[1:]:\\n            ln = ListNode(n, curr, None)\\n            curr.next = ln\\n            curr = ln\\n        \\n        # Now traverse the list\\n        curr = h\\n        prev = h\\n        # Note that only one the change may occur is to one before it.\\n        # So... if changed: traverse backward\\n        while curr:\\n            if curr.next and math.gcd(curr.val, curr.next.val) > 1:\\n                # Replaces this and next with a new list node\\n                curr.val = math.lcm(curr.val, curr.next.val)\\n                if curr.next.next:\\n                    curr.next.next.prev = curr\\n                curr.next = curr.next.next\\n                if curr.prev is not None:\\n                    curr = curr.prev\\n            else:\\n                curr = curr.next\\n        curr = h\\n        out = []\\n        while curr:\\n            out.append(curr.val)\\n            curr = curr.next\\n        return out\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```python\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        queue = deque(nums)\\n        # [2, 7, 2, 14]\\n        # [2, 7, 14]\\n        # [2, 14]\\n        # [14]\\n        \\n        # Need a better way to mark\\n        # to traverse between two\\n        # This would be much easier if this is a list\\n        class ListNode():\\n            def __init__(self, val, prev=None, nxt=None):\\n                self.val = val\\n                self.next = nxt\\n                self.prev = prev\\n                \\n        h = ListNode(nums[0])\\n        curr = h\\n        for n in nums[1:]:\\n            ln = ListNode(n, curr, None)\\n            curr.next = ln\\n            curr = ln\\n        \\n        # Now traverse the list\\n        curr = h\\n        prev = h\\n        # Note that only one the change may occur is to one before it.\\n        # So... if changed: traverse backward\\n        while curr:\\n            if curr.next and math.gcd(curr.val, curr.next.val) > 1:\\n                # Replaces this and next with a new list node\\n                curr.val = math.lcm(curr.val, curr.next.val)\\n                if curr.next.next:\\n                    curr.next.next.prev = curr\\n                curr.next = curr.next.next\\n                if curr.prev is not None:\\n                    curr = curr.prev\\n            else:\\n                curr = curr.next\\n        curr = h\\n        out = []\\n        while curr:\\n            out.append(curr.val)\\n            curr = curr.next\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274747,
                "title": "c-stack-maths",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>arr;\\n        arr.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){   \\n            int val=arr.back();\\n            if(__gcd(val,nums[i])>1){\\n                arr.pop_back();\\n                int rem=lcm(val,nums[i]);\\n                while(!arr.empty() && __gcd(arr.back(),rem)>1){\\n                    rem=lcm(arr.back(),rem);\\n                    arr.pop_back();\\n                }\\n                arr.push_back(rem);\\n            }\\n            else{\\n                arr.push_back(nums[i]);\\n            }\\n        }\\n        return arr;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>arr;\\n        arr.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){   \\n            int val=arr.back();\\n            if(__gcd(val,nums[i])>1){\\n                arr.pop_back();\\n                int rem=lcm(val,nums[i]);\\n                while(!arr.empty() && __gcd(arr.back(),rem)>1){\\n                    rem=lcm(arr.back(),rem);\\n                    arr.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2000527,
                "title": "easy-stack",
                "content": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        auto lcm = [&](int x , int y){ \\n\\t\\t    /* long long conversion is needed because temporarily \\n\\t\\t\\tx * y might be big enough to cross INT_MAX */\\n            return (int)((long long) x * y / __gcd(x , y)) ; \\n        };\\n        \\n        vector<int> stk ; \\n        for(auto x : nums){\\n            int lcmVal = x ;\\n            while(stk.size() and __gcd(stk.back() , lcmVal) > 1){\\n                lcmVal = lcm(lcmVal , stk.back()) ;\\n                stk.pop_back() ;\\n            }\\n            stk.push_back(lcmVal) ;\\n        }\\n        return stk ; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        auto lcm = [&](int x , int y){ \\n\\t\\t    /* long long conversion is needed because temporarily \\n\\t\\t\\tx * y might be big enough to cross INT_MAX */\\n            return (int)((long long) x * y / __gcd(x , y)) ; \\n        };\\n        \\n        vector<int> stk ; \\n        for(auto x : nums){\\n            int lcmVal = x ;\\n            while(stk.size() and __gcd(stk.back() , lcmVal) > 1){\\n                lcmVal = lcm(lcmVal , stk.back()) ;\\n                stk.pop_back() ;\\n            }\\n            stk.push_back(lcmVal) ;\\n        }\\n        return stk ; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825538,
                "title": "python-3-stack-solution",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:       \\n\\n        stack = nums[:1]\\n        \\n        for j in range(1, len(nums)):\\n            cur = nums[j]\\n            while stack and math.gcd(stack[-1], cur) > 1:\\n                prev = stack.pop()\\n                cur = math.lcm(prev, cur)\\n            stack.append(cur)            \\n               \\n        return stack",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:       \\n\\n        stack = nums[:1]\\n        \\n        for j in range(1, len(nums)):\\n            cur = nums[j]\\n            while stack and math.gcd(stack[-1], cur) > 1:\\n                prev = stack.pop()\\n                cur = math.lcm(prev, cur)\\n            stack.append(cur)            \\n               \\n        return stack",
                "codeTag": "Java"
            },
            {
                "id": 1825209,
                "title": "easy-stack-solution-in-c",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> s;\\n        s.push(nums[0]);\\n        if(nums.size()==1)\\n            return nums;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(__gcd(nums[i],s.top())!=1)\\n            {\\n                int y=s.top();\\n                s.pop();\\n                long long z=1ll*y*nums[i];\\n                int t=z/__gcd(nums[i],y);\\n                while(s.size()>0&&__gcd(s.top(),t)!=1)\\n                {\\n                    y=s.top();\\n                    s.pop();\\n                    z=1ll*y*t;\\n                    t=z/__gcd(y,t);\\n                }\\n                s.push(t);\\n            }\\n            else\\n            {\\n                s.push(nums[i]);\\n            }\\n        }\\n        vector<int> ans;\\n        while(s.size()>0)\\n        {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> s;\\n        s.push(nums[0]);\\n        if(nums.size()==1)\\n            return nums;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(__gcd(nums[i],s.top())!=1)\\n            {\\n                int y=s.top();\\n                s.pop();\\n                long long z=1ll*y*nums[i];\\n                int t=z/__gcd(nums[i],y);\\n                while(s.size()>0&&__gcd(s.top(),t)!=1)\\n                {\\n                    y=s.top();\\n                    s.pop();\\n                    z=1ll*y*t;\\n                    t=z/__gcd(y,t);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1823902,
                "title": "c-stack-o-n-simple-approach",
                "content": "The problem is vey simple if you think it as stack problem. \\n**Approach**: iterate through every element of nums. Push it onto the stack and do the following.\\n* if the stack size is >=2, the pop top 2 element.\\n* find the GCD of both the poped elements\\n* if **GCD**>1, find **LCM** and push it onto the stack, continue\\n* if **GCD**==1, push both the poped element onto the stack in same order and move to next element in nums.\\n\\nContinue the above steps untill `stack.size()<2` or **GCD**==1\\n\\n**Time: O(n)**\\nupvote if it helps\\n ```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        if(nums.size()==1) return nums;\\n        vector<int> re;\\n        stack<int> st; \\n        for(int i = 0;i<nums.size();++i){\\n            st.push(nums[i]);\\n            while(st.size()>=2){\\n                int p1 = st.top(); st.pop();\\n                int p2 = st.top(); st.pop();\\n                int k = __gcd(p1,p2);\\n                if(k>1){\\n                    long lcm = (long long)p1*p2/k;\\n                    st.push((int)lcm);\\n                }\\n                else{\\n                    st.push(p2); st.push(p1); break;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            re.push_back(st.top()); st.pop();\\n        }\\n        reverse(re.begin(),re.end());\\n        return re;\\n    }\\n};\\n        \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        if(nums.size()==1) return nums;\\n        vector<int> re;\\n        stack<int> st; \\n        for(int i = 0;i<nums.size();++i){\\n            st.push(nums[i]);\\n            while(st.size()>=2){\\n                int p1 = st.top(); st.pop();\\n                int p2 = st.top(); st.pop();\\n                int k = __gcd(p1,p2);\\n                if(k>1){\\n                    long lcm = (long long)p1*p2/k;\\n                    st.push((int)lcm);\\n                }\\n                else{\\n                    st.push(p2); st.push(p1); break;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            re.push_back(st.top()); st.pop();\\n        }\\n        reverse(re.begin(),re.end());\\n        return re;\\n    }\\n};\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823742,
                "title": "python3-stack",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/bb5647e856ff11b072f9c51a140e0f243c100171) for solutions of weekly 283.\\n\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for x in nums: \\n            while stack and gcd(stack[-1], x) > 1: x = lcm(x, stack.pop())\\n            stack.append(x)\\n        return stack\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for x in nums: \\n            while stack and gcd(stack[-1], x) > 1: x = lcm(x, stack.pop())\\n            stack.append(x)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823616,
                "title": "stack",
                "content": "Let begin with some mathamatics \\na.b=lcm(a,b).gcd(a,b)\\nlcm(a,b)=(a.b)/gcd(a,b)\\n\\nSo its easy to calculate gcd and lcm in Log(n) time so use internal c++ implementaion.\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<long long>st;\\n        for(auto a:nums)\\n        {\\n\\t\\t\\tlong long num=a;\\n            if(st.emtpy())\\n            {\\n                st.push_back(a);\\n            }\\n            else\\n            {\\n                long long t=__gcd(num,st.back());\\n                if(t>1)\\n                {\\t\\t\\t\\t\\n                    long long temp=(num*st.back())/t;\\n                    st.pop_back();\\n                    t=__gcd(st.back(),temp);\\n                    while(!st.empty() && t>1)\\n                    {\\n                        temp=(temp*st.back())/t;\\n                        t=__gcd(st.back(),temp);\\n                        st.pop_back();\\n                    }\\n                    st.push_back(temp);\\n                }\\n                else \\n                {\\n                    st.push_back(a);\\n                }\\n            }\\n        }\\n\\t\\tvector<int>ans(st.begin(),st.end());\\n        return ans;\\n        \\n    }\\n};\\n``` \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<long long>st;\\n        for(auto a:nums)\\n        {\\n\\t\\t\\tlong long num=a;\\n            if(st.emtpy())\\n            {\\n                st.push_back(a);\\n            }\\n            else\\n            {\\n                long long t=__gcd(num,st.back());\\n                if(t>1)\\n                {\\t\\t\\t\\t\\n                    long long temp=(num*st.back())/t;\\n                    st.pop_back();\\n                    t=__gcd(st.back(),temp);\\n                    while(!st.empty() && t>1)\\n                    {\\n                        temp=(temp*st.back())/t;\\n                        t=__gcd(st.back(),temp);\\n                        st.pop_back();\\n                    }\\n                    st.push_back(temp);\\n                }\\n                else \\n                {\\n                    st.push_back(a);\\n                }\\n            }\\n        }\\n\\t\\tvector<int>ans(st.begin(),st.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438809,
                "title": "one-pass-stack-in-python",
                "content": "```python\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        res = [1]\\n        for num in nums:\\n            new_num = num\\n            while gcd(res[-1], new_num) > 1:\\n                new_num = lcm(res.pop(), new_num)\\n            res.append(new_num)\\n        return res[1:]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        res = [1]\\n        for num in nums:\\n            new_num = num\\n            while gcd(res[-1], new_num) > 1:\\n                new_num = lcm(res.pop(), new_num)\\n            res.append(new_num)\\n        return res[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013507,
                "title": "java-n-log-n-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            ans.add(nums[i]);\\n            while(ans.size()>1){\\n                int a = ans.get(ans.size()-1), b = ans.get(ans.size()-2);\\n                int gcd = gcd(a,b);\\n                if(gcd==1) break;\\n                \\n                int lcm = (a/gcd)*(b/gcd)*gcd;\\n                ans.remove(ans.size()-1);\\n                ans.remove(ans.size()-1);\\n                ans.add(lcm);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    static int gcd(int a,int b){\\n        if(a==0) return b;\\n        return gcd(b%a,a);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            ans.add(nums[i]);\\n            while(ans.size()>1){\\n                int a = ans.get(ans.size()-1), b = ans.get(ans.size()-2);\\n                int gcd = gcd(a,b);\\n                if(gcd==1) break;\\n                \\n                int lcm = (a/gcd)*(b/gcd)*gcd;\\n                ans.remove(ans.size()-1);\\n                ans.remove(ans.size()-1);\\n                ans.add(lcm);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    static int gcd(int a,int b){\\n        if(a==0) return b;\\n        return gcd(b%a,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856371,
                "title": "99-fast-simple-code",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>ans;\\n        for(auto num: nums){\\n           ans.push_back(num);\\n            \\n           while(ans.size() >=2){\\n               int top = ans.back();\\n               int stop = ans[ans.size()-2];\\n               \\n               if(__gcd(top,stop) > 1){\\n                   ans.pop_back();\\n                   ans.pop_back();\\n                   ans.push_back(top*1LL*stop/__gcd(top, stop));\\n               }\\n               else break;\\n           }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>ans;\\n        for(auto num: nums){\\n           ans.push_back(num);\\n            \\n           while(ans.size() >=2){\\n               int top = ans.back();\\n               int stop = ans[ans.size()-2];\\n               \\n               if(__gcd(top,stop) > 1){\\n                   ans.pop_back();\\n                   ans.pop_back();\\n                   ans.push_back(top*1LL*stop/__gcd(top, stop));\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1836123,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        if(nums.length<2 || (nums.length == 2 && gcd(nums[0],nums[1])==1)){\\n            for(int ele:nums){\\n                res.add(ele);\\n            }\\n            return res;\\n        }\\n        int i=1;\\n        res.add(nums[0]);\\n        boolean flag = false;\\n        while(i<nums.length){\\n            int first = res.get(res.size()-1);\\n            int second = nums[i];\\n            int gcd = gcd(first,second);\\n            if(gcd>1){\\n                long lcm = ((long)first *(long)second)/gcd;\\n                if(res.size()>0)\\n                    res.remove(res.size()-1);\\n                res.add((int)lcm);\\n                recursivelyCheck(res);\\n            }else{\\n                res.add(second);\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n    public int gcd(int a,int b){\\n        if(a>b){\\n            return gcd(b,a);\\n        }\\n        if(b%a == 0){\\n            return a;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    public void recursivelyCheck(ArrayList<Integer> list){\\n        if(list.size()<2){\\n            return;\\n        }\\n        int a=list.remove(list.size()-1);\\n        int b = list.remove(list.size()-1);\\n        int gcd = gcd(a,b); \\n        if(gcd>1){\\n            long lcm = ((long)(a)*(long)(b))/gcd;\\n            list.add((int)lcm);\\n            recursivelyCheck(list);\\n        }else{\\n            list.add(b);\\n            list.add(a);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        if(nums.length<2 || (nums.length == 2 && gcd(nums[0],nums[1])==1)){\\n            for(int ele:nums){\\n                res.add(ele);\\n            }\\n            return res;\\n        }\\n        int i=1;\\n        res.add(nums[0]);\\n        boolean flag = false;\\n        while(i<nums.length){\\n            int first = res.get(res.size()-1);\\n            int second = nums[i];\\n            int gcd = gcd(first,second);\\n            if(gcd>1){\\n                long lcm = ((long)first *(long)second)/gcd;\\n                if(res.size()>0)\\n                    res.remove(res.size()-1);\\n                res.add((int)lcm);\\n                recursivelyCheck(res);\\n            }else{\\n                res.add(second);\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n    public int gcd(int a,int b){\\n        if(a>b){\\n            return gcd(b,a);\\n        }\\n        if(b%a == 0){\\n            return a;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    public void recursivelyCheck(ArrayList<Integer> list){\\n        if(list.size()<2){\\n            return;\\n        }\\n        int a=list.remove(list.size()-1);\\n        int b = list.remove(list.size()-1);\\n        int gcd = gcd(a,b); \\n        if(gcd>1){\\n            long lcm = ((long)(a)*(long)(b))/gcd;\\n            list.add((int)lcm);\\n            recursivelyCheck(list);\\n        }else{\\n            list.add(b);\\n            list.add(a);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830994,
                "title": "lol-i-really-don-t-know-why-it-passed",
                "content": "Is This Approach Correct or testcases are weak?\\nI just Iterated Forward and backward and merged elements and if answer is reduced I made the recursive call to check if answer can be reduced or not..\\n\\nPS: I thought about Stack Solution Afterwards But just wondered if this is correct or it can give TLE in given contstraints?\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        ll lcm = nums[0];\\n        if(nums.size()==1)\\n        {\\n            return nums;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ll val = nums[i];\\n            ll g = __gcd(lcm,val); \\n            if(g!=1)\\n            {\\n                lcm = (lcm/g)*val;\\n            }\\n            else\\n            {\\n                ans.push_back(lcm);\\n                lcm = nums[i];\\n            }\\n        }\\n        ans.push_back(lcm);\\n        \\n        vector<int> ans2;\\n        if(ans.size()==1)\\n        {\\n            return ans;\\n        }\\n        lcm = ans.back();\\n        for(int i=ans.size()-2;i>=0;i--)\\n        {\\n            ll val = ans[i];\\n            ll g = __gcd(lcm,val); \\n            if(g!=1)\\n            {\\n                lcm = (lcm/g)*val;\\n            }\\n            else\\n            {\\n                ans2.push_back(lcm);\\n                lcm = ans[i];\\n            }\\n        }\\n        ans2.push_back(lcm);\\n        reverse(ans2.begin(),ans2.end());\\n        if(ans2 == nums)\\n        {\\n            return ans2;\\n        }\\n        return replaceNonCoprimes(ans2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        ll lcm = nums[0];\\n        if(nums.size()==1)\\n        {\\n            return nums;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ll val = nums[i];\\n            ll g = __gcd(lcm,val); \\n            if(g!=1)\\n            {\\n                lcm = (lcm/g)*val;\\n            }\\n            else\\n            {\\n                ans.push_back(lcm);\\n                lcm = nums[i];\\n            }\\n        }\\n        ans.push_back(lcm);\\n        \\n        vector<int> ans2;\\n        if(ans.size()==1)\\n        {\\n            return ans;\\n        }\\n        lcm = ans.back();\\n        for(int i=ans.size()-2;i>=0;i--)\\n        {\\n            ll val = ans[i];\\n            ll g = __gcd(lcm,val); \\n            if(g!=1)\\n            {\\n                lcm = (lcm/g)*val;\\n            }\\n            else\\n            {\\n                ans2.push_back(lcm);\\n                lcm = ans[i];\\n            }\\n        }\\n        ans2.push_back(lcm);\\n        reverse(ans2.begin(),ans2.end());\\n        if(ans2 == nums)\\n        {\\n            return ans2;\\n        }\\n        return replaceNonCoprimes(ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827741,
                "title": "faster-than-100-of-submission-c-product-of-numbers-gcd-lcm-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    return (b==0)? a : gcd(b, a%b);\\n}\\nvector<int> replaceNonCoprimes(vector<int>& arr) {\\n    vector<int>ans;\\n    int n=arr.size();\\n    ans.push_back(arr[0]);\\n    if(n==1)return ans;\\n\\n    for(int i=1;i<n;i++){\\n        int curr=arr[i];\\n        if(gcd(curr, ans.back())==1){\\n            ans.push_back(curr);\\n            continue;\\n        }\\n        \\n        while(!ans.empty() && gcd(curr, ans.back())!=1){\\n            int lcm=1LL*curr*ans.back()/gcd(curr, ans.back());\\n            ans.pop_back();\\n            curr=lcm;\\n        }\\n        ans.push_back(curr);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    return (b==0)? a : gcd(b, a%b);\\n}\\nvector<int> replaceNonCoprimes(vector<int>& arr) {\\n    vector<int>ans;\\n    int n=arr.size();\\n    ans.push_back(arr[0]);\\n    if(n==1)return ans;\\n\\n    for(int i=1;i<n;i++){\\n        int curr=arr[i];\\n        if(gcd(curr, ans.back())==1){\\n            ans.push_back(curr);\\n            continue;\\n        }\\n        \\n        while(!ans.empty() && gcd(curr, ans.back())!=1){\\n            int lcm=1LL*curr*ans.back()/gcd(curr, ans.back());\\n            ans.pop_back();\\n            curr=lcm;\\n        }\\n        ans.push_back(curr);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827181,
                "title": "python-stack-solution-using-gcd",
                "content": "class Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        \\n        ans=[nums[0]]\\n        \\n        for i in range (1,len(nums)):\\n            \\n            y=nums[i]\\n            while(len(ans)>0 and math.gcd(ans[-1],y)>1):\\n                x=ans.pop()\\n                y=x*y//math.gcd(x,y)\\n                \\n            ans.append(y)\\n            \\n        return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        \\n        ans=[nums[0]]\\n        \\n        for i in range (1,len(nums)):\\n            \\n            y=nums[i]\\n            while(len(ans)>0 and math.gcd(ans[-1],y)>1):\\n                x=ans.pop()\\n                y=x*y//math.gcd(x,y)\\n                \\n            ans.append(y)\\n            \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1825537,
                "title": "java-no-stack-solution-25ms-100-faster-o-1-space-with-explanation",
                "content": "No need to utilize external stack structure. The basic idea is to use two indices and update the values in the array inplace:\\n1- `i` this index walks through the input array of numbers.\\n2- `j` this index keeps track of how many numbers to be included in the results array. It will point to the recent number included in the output. When the two numbers are co-prime, it is incremnted by 1.\\n\\nNow, whenever a non-coprime pair is found, the number at index `j` is replaced with their LCM value. Then a look back search is performed to check if this LCM is non-coprime with the previous number, i.e., at index `j-1` (the internal while loop).\\n\\nTime O(nlogn)\\nSpace O(1)\\n\\n```java\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length;\\n        int i, j;\\n        boolean b = true;\\n        for(i = 1, j = 0; i < n; i++){\\n            int g = gcd(nums[j], nums[i]);\\n            if (g == 1){\\n                nums[++j] = nums[i];\\n            } else {\\n                nums[j] *= nums[i] / g;\\n                b = true;\\n                while(j > 0 && b){\\n                    g = gcd(nums[j], nums[j-1]);\\n                    b = g > 1;\\n                    if(b) {\\n                        nums[j-1] *= nums[j] / g;\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        var res = new ArrayList<Integer>();\\n        for(i = 0; i <= j; i++)\\n            res.add(nums[i]);\\n        \\n        return res;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        return b > 0 ? gcd(b, a % b) : a;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length;\\n        int i, j;\\n        boolean b = true;\\n        for(i = 1, j = 0; i < n; i++){\\n            int g = gcd(nums[j], nums[i]);\\n            if (g == 1){\\n                nums[++j] = nums[i];\\n            } else {\\n                nums[j] *= nums[i] / g;\\n                b = true;\\n                while(j > 0 && b){\\n                    g = gcd(nums[j], nums[j-1]);\\n                    b = g > 1;\\n                    if(b) {\\n                        nums[j-1] *= nums[j] / g;\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        var res = new ArrayList<Integer>();\\n        for(i = 0; i <= j; i++)\\n            res.add(nums[i]);\\n        \\n        return res;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        return b > 0 ? gcd(b, a % b) : a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824272,
                "title": "c-try-two-pass-but-fail",
                "content": "Fail at very last case, currently no clue for this.\\n```\\nclass Solution {\\npublic:\\n    long long GCD (long long a, long long b) {\\n        if (b <= 1 || (a % b == 0)) return b; \\n        return GCD(b, a % b);\\n    }\\n    int LCM (long long a, long long b, long long gcd) {\\n        return a * b / gcd;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> s, r = {nums[n-1]};\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (GCD(r.back(), nums[i]) > 1) {\\n                r.back() = LCM(nums[i], r.back(), GCD(r.back(), nums[i]));\\n            } else {\\n                r.push_back(nums[i]);\\n            }\\n        }\\n        n = r.size();\\n        s.push_back(r.back());\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (GCD(s.back(), r[i]) > 1) {\\n                s.back() = LCM(r[i], s.back(), GCD(s.back(), r[i]));\\n            } else {\\n                s.push_back(r[i]);\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long GCD (long long a, long long b) {\\n        if (b <= 1 || (a % b == 0)) return b; \\n        return GCD(b, a % b);\\n    }\\n    int LCM (long long a, long long b, long long gcd) {\\n        return a * b / gcd;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> s, r = {nums[n-1]};\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (GCD(r.back(), nums[i]) > 1) {\\n                r.back() = LCM(nums[i], r.back(), GCD(r.back(), nums[i]));\\n            } else {\\n                r.push_back(nums[i]);\\n            }\\n        }\\n        n = r.size();\\n        s.push_back(r.back());\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (GCD(s.back(), r[i]) > 1) {\\n                s.back() = LCM(r[i], s.back(), GCD(s.back(), r[i]));\\n            } else {\\n                s.push_back(r[i]);\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824121,
                "title": "for-noobs-like-me-naive-sol-space-optimized-2-stack-method",
                "content": "1) Naive solution (which obviously didnt get accepted)\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while(i < n-1){\\n            int g = gcd(nums[i],nums[i+1]);\\n            if(g != 1){\\n                long long t = nums[i];\\n                t*= nums[i+1];\\n                t/= g;\\n\\t\\t\\t\\t// t -- LCM\\n                nums[i] = t;\\n                nums.erase(nums.begin() + i+1);\\n                n--;\\n                i = 0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n2) In the above version i was getting TLE so i though of optimizing it by finding a work around for .erase() method and so I used 2 stacks , by this way both time and space is optimized (time a little enough to get accepted).\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        vector<int> vec;\\n        stack<int> s1,s2;\\n        for(int i =0;i < n;i++){\\n            s1.push(nums[i]);\\n        }\\n        while(!s1.empty() && s1.size() >= 2){\\n                int a = s1.top();\\n                s1.pop();\\n                int b = s1.top();\\n                int g =gcd(max(a,b),min(a,b));\\n                long long t = a;\\n                if(g != 1){\\n                    // t - lcm\\n                    t*= b;\\n                    t/= g;\\n                    s1.pop();\\n                }\\n                while(!s2.empty()){\\n                    g = gcd(max((int)t,s2.top()),min((int)t,s2.top()));\\n                    if(g != 1){\\n                        // t - lcm\\n                        t*= s2.top();\\n                        t/= g;\\n                        s2.pop();\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                } \\n              s2.push(t);\\n        }\\n        // if at all an element left in stack 1\\n        if(!s1.empty()){\\n                int a = s1.top();\\n                s1.pop();\\n                long long t = a;\\n                while(!s2.empty()){\\n                    int g = gcd(max((int)t,s2.top()),min((int)t,s2.top()));\\n                    if(g != 1){\\n                         // t - lcm\\n                        t*= s2.top();\\n                        t/= g;\\n                        s2.pop();\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                } \\n              s2.push(t);\\n        }\\n        while(!s2.empty()){\\n            vec.push_back(s2.top());\\n            s2.pop();\\n        }\\n        return vec;\\n    }\\n};\\n```\\nNote: \\n1) Though its very basic i hope it helps people with little intution and afraid of Hard problem (like me :( )\\n2) Also I found the second approach only after contest :( \\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while(i < n-1){\\n            int g = gcd(nums[i],nums[i+1]);\\n            if(g != 1){\\n                long long t = nums[i];\\n                t*= nums[i+1];\\n                t/= g;\\n\\t\\t\\t\\t// t -- LCM\\n                nums[i] = t;\\n                nums.erase(nums.begin() + i+1);\\n                n--;\\n                i = 0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        vector<int> vec;\\n        stack<int> s1,s2;\\n        for(int i =0;i < n;i++){\\n            s1.push(nums[i]);\\n        }\\n        while(!s1.empty() && s1.size() >= 2){\\n                int a = s1.top();\\n                s1.pop();\\n                int b = s1.top();\\n                int g =gcd(max(a,b),min(a,b));\\n                long long t = a;\\n                if(g != 1){\\n                    // t - lcm\\n                    t*= b;\\n                    t/= g;\\n                    s1.pop();\\n                }\\n                while(!s2.empty()){\\n                    g = gcd(max((int)t,s2.top()),min((int)t,s2.top()));\\n                    if(g != 1){\\n                        // t - lcm\\n                        t*= s2.top();\\n                        t/= g;\\n                        s2.pop();\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                } \\n              s2.push(t);\\n        }\\n        // if at all an element left in stack 1\\n        if(!s1.empty()){\\n                int a = s1.top();\\n                s1.pop();\\n                long long t = a;\\n                while(!s2.empty()){\\n                    int g = gcd(max((int)t,s2.top()),min((int)t,s2.top()));\\n                    if(g != 1){\\n                         // t - lcm\\n                        t*= s2.top();\\n                        t/= g;\\n                        s2.pop();\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                } \\n              s2.push(t);\\n        }\\n        while(!s2.empty()){\\n            vec.push_back(s2.top());\\n            s2.pop();\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824033,
                "title": "clean-python",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        \\n        for num in nums:\\n            while stack and math.gcd(num, stack[-1]) > 1:\\n                num = math.lcm(num, stack.pop())\\n            stack.append(num)\\n                \\n        return stack\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        \\n        for num in nums:\\n            while stack and math.gcd(num, stack[-1]) > 1:\\n                num = math.lcm(num, stack.pop())\\n            stack.append(num)\\n                \\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823972,
                "title": "stack-gcd-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<long long>st;\\n        int i=0,lc=0,gc=0;\\n        while(i<nums.size())\\n        {\\n            long long lc=nums[i];\\n            while(st.size()>0&&__gcd(st.top(),lc)>1)\\n            {\\n                lc=((long long )lc*st.top())/__gcd(lc,st.top());\\n                st.pop();\\n            }\\n            st.push(lc);\\n            i++;\\n        }\\n        vector<int>ans;\\n        while(st.size()>0)\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<long long>st;\\n        int i=0,lc=0,gc=0;\\n        while(i<nums.size())\\n        {\\n            long long lc=nums[i];\\n            while(st.size()>0&&__gcd(st.top(),lc)>1)\\n            {\\n                lc=((long long )lc*st.top())/__gcd(lc,st.top());\\n                st.pop();\\n            }\\n            st.push(lc);\\n            i++;\\n        }\\n        vector<int>ans;\\n        while(st.size()>0)\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823916,
                "title": "stack-cpp",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<ll> stk;\\n        vector<int> a;\\n        for(auto& it:nums){\\n            ll num = it;\\n            while(!stk.empty() && __gcd(stk.top(),num) > 1){\\n                num = ((stk.top()*num)/__gcd(stk.top(),num));\\n                stk.pop();\\n            }stk.push(num);\\n        }while(!stk.empty()){\\n            a.push_back(stk.top());\\n            stk.pop();\\n        }reverse(a.begin(),a.end());\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<ll> stk;\\n        vector<int> a;\\n        for(auto& it:nums){\\n            ll num = it;\\n            while(!stk.empty() && __gcd(stk.top(),num) > 1){\\n                num = ((stk.top()*num)/__gcd(stk.top(),num));\\n                stk.pop();\\n            }stk.push(num);\\n        }while(!stk.empty()){\\n            a.push_back(stk.top());\\n            stk.pop();\\n        }reverse(a.begin(),a.end());\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823796,
                "title": "q4-is-easier-than-q2-1st-time-ak",
                "content": "Here\\'s my solution in < 10 loc. Simply do the simulation iteratively.\\nI created helper method cuz I thougt forward + backward pass is required. But forward pass can pass OJ, so I was happy in the contest.\\n\\n```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n    if len(nums) == 1:\\n        return nums\\n\\n    def helper(A):\\n        stk = []\\n        for i in range(len(nums)):\\n            while stk and gcd(stk[-1], nums[i]) > 1:\\n                a = stk.pop()\\n                nums[i] = lcm(a, nums[i])\\n            stk.append(nums[i])\\n        return stk\\n\\n    return helper(nums)\\n```\\n\\nBoomed by Q2 for 1hr...\\n![image](https://assets.leetcode.com/users/images/8ee99d1b-59b3-4569-a675-89cc90a69019_1646540195.627275.png)\\n",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n    if len(nums) == 1:\\n        return nums\\n\\n    def helper(A):\\n        stk = []\\n        for i in range(len(nums)):\\n            while stk and gcd(stk[-1], nums[i]) > 1:\\n                a = stk.pop()\\n                nums[i] = lcm(a, nums[i])\\n            stk.append(nums[i])\\n        return stk\\n\\n    return helper(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823706,
                "title": "c-2197-replace-non-coprime-numbers-in-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> stk; \\n        for (auto& x : nums) {\\n            while (stk.size() && gcd(stk.back(), x) > 1) {\\n                x = lcm(x, stk.back()); \\n                stk.pop_back(); \\n            }\\n            stk.push_back(x); \\n        }\\n        return stk; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> stk; \\n        for (auto& x : nums) {\\n            while (stk.size() && gcd(stk.back(), x) > 1) {\\n                x = lcm(x, stk.back()); \\n                stk.pop_back(); \\n            }\\n            stk.push_back(x); \\n        }\\n        return stk; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823682,
                "title": "python-solution-cannot-find-easier-than-it",
                "content": "```\\nimport math\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i=1\\n        while i < len(nums):\\n            x = math.gcd(nums[i],nums[i-1])\\n            if x > 1:\\n                nums[i-1] = nums[i]*nums[i-1]//x\\n                nums.pop(i)\\n                i -= 1\\n            else:\\n                i += 1\\n            if i == 0:\\n                i+= 1\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i=1\\n        while i < len(nums):\\n            x = math.gcd(nums[i],nums[i-1])\\n            if x > 1:\\n                nums[i-1] = nums[i]*nums[i-1]//x\\n                nums.pop(i)\\n                i -= 1\\n            else:\\n                i += 1\\n            if i == 0:\\n                i+= 1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823598,
                "title": "python-o-n-simulation-with-doubly-linked-list",
                "content": "\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 1: return nums\\n\\n        class Node:\\n            def __init__(self, v):\\n                self.v = v\\n                self.next = None\\n                self.prev = None\\n                \\n        def addBetween(prev, next, cur):\\n            prev.next = cur\\n            cur.prev = prev\\n            cur.next = next\\n            next.prev = cur\\n\\n        head, tail = Node(0), Node(0)\\n        head.next = tail\\n        tail.prev = head\\n        for i in nums:\\n            cur = Node(i)\\n            prev = tail.prev\\n            addBetween(tail.prev, tail, cur)\\n        \\n        res = []\\n        first, second = head.next, head.next.next\\n        while second != tail:\\n            v1, v2 = first.v, second.v\\n            # replace\\n            if math.gcd(v1, v2) > 1:\\n                lcm = math.lcm(v1, v2)\\n                prev = first.prev\\n                next = second.next\\n                cur = Node(lcm)\\n                addBetween(prev, next, cur)\\n                # use prev as first if its not head\\n                if prev != head:\\n                    first = prev\\n                else:\\n                    first = cur\\n                second = first.next\\n            else: # move to next\\n                first = first.next\\n                second = first.next\\n\\n        cur = head.next\\n        while cur != tail:\\n            res.append(cur.v)\\n            cur = cur.next\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 1: return nums\\n\\n        class Node:\\n            def __init__(self, v):\\n                self.v = v\\n                self.next = None\\n                self.prev = None\\n                \\n        def addBetween(prev, next, cur):\\n            prev.next = cur\\n            cur.prev = prev\\n            cur.next = next\\n            next.prev = cur\\n\\n        head, tail = Node(0), Node(0)\\n        head.next = tail\\n        tail.prev = head\\n        for i in nums:\\n            cur = Node(i)\\n            prev = tail.prev\\n            addBetween(tail.prev, tail, cur)\\n        \\n        res = []\\n        first, second = head.next, head.next.next\\n        while second != tail:\\n            v1, v2 = first.v, second.v\\n            # replace\\n            if math.gcd(v1, v2) > 1:\\n                lcm = math.lcm(v1, v2)\\n                prev = first.prev\\n                next = second.next\\n                cur = Node(lcm)\\n                addBetween(prev, next, cur)\\n                # use prev as first if its not head\\n                if prev != head:\\n                    first = prev\\n                else:\\n                    first = cur\\n                second = first.next\\n            else: # move to next\\n                first = first.next\\n                second = first.next\\n\\n        cur = head.next\\n        while cur != tail:\\n            res.append(cur.v)\\n            cur = cur.next\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823595,
                "title": "easy-stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int lcm(int a, int b){\\n        return (a / __gcd(a, b)) * b;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> stk;\\n        for(auto& i : nums){\\n            // do what question asked\\n            if(!stk.empty() && __gcd(i, stk.top()) > 1){\\n                int t = stk.top();\\n                stk.pop();\\n                stk.push(lcm(i, t));\\n            }\\n            else stk.push(i);\\n            \\n            // maintain stack with only non-comprime elements\\n            while(stk.size() >= 2){\\n                int x = stk.top();\\n                stk.pop();\\n                int y = stk.top();\\n                stk.pop();\\n                \\n                if(__gcd(x, y) > 1){\\n                    stk.push(lcm(x, y));\\n                }\\n                else{\\n                    stk.push(y);\\n                    stk.push(x);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // return answer array from stack\\n        vector<int> ans(stk.size());\\n        int i = stk.size() - 1;\\n        while(!stk.empty()){\\n            ans[i--] = stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcm(int a, int b){\\n        return (a / __gcd(a, b)) * b;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> stk;\\n        for(auto& i : nums){\\n            // do what question asked\\n            if(!stk.empty() && __gcd(i, stk.top()) > 1){\\n                int t = stk.top();\\n                stk.pop();\\n                stk.push(lcm(i, t));\\n            }\\n            else stk.push(i);\\n            \\n            // maintain stack with only non-comprime elements\\n            while(stk.size() >= 2){\\n                int x = stk.top();\\n                stk.pop();\\n                int y = stk.top();\\n                stk.pop();\\n                \\n                if(__gcd(x, y) > 1){\\n                    stk.push(lcm(x, y));\\n                }\\n                else{\\n                    stk.push(y);\\n                    stk.push(x);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // return answer array from stack\\n        vector<int> ans(stk.size());\\n        int i = stk.size() - 1;\\n        while(!stk.empty()){\\n            ans[i--] = stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075170,
                "title": "replace-non-coprime-numbers-in-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n    LinkedList<Integer> ans = new LinkedList<>();\\n    for (int num : nums) {\\n      while (!ans.isEmpty() && gcd(ans.getLast(), num) > 1)\\n        num = lcm(ans.removeLast(), num);\\n      ans.addLast(num);\\n    }\\n\\n    return ans;\\n  }\\n    private int gcd(int a, int b) {\\n    return b == 0 ? a : gcd(b, a % b);\\n  }\\n\\n  private int lcm(int a, int b) {\\n    return a * (b / gcd(a, b)); \\n}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n    LinkedList<Integer> ans = new LinkedList<>();\\n    for (int num : nums) {\\n      while (!ans.isEmpty() && gcd(ans.getLast(), num) > 1)\\n        num = lcm(ans.removeLast(), num);\\n      ans.addLast(num);\\n    }\\n\\n    return ans;\\n  }\\n    private int gcd(int a, int b) {\\n    return b == 0 ? a : gcd(b, a % b);\\n  }\\n\\n  private int lcm(int a, int b) {\\n    return a * (b / gcd(a, b)); \\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862762,
                "title": "rust-52ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we find two adjacents non-coprime we would remove left, change right value to lcm and decrease index, but remove is slow, so let\\'s use a stack instead.\\n\\n\\n# Code\\n\\nThe gcd function is from here:\\nhttps://docs.rs/gcd/latest/src/gcd/lib.rs.html\\n\\n```\\nimpl Solution {\\n    pub fn replace_non_coprimes(mut nums: Vec<i32>) -> Vec<i32> {\\n        let len = nums.len();\\n        let mut x: u64 = nums[0] as u64;\\n        let mut idx = 1;\\n        let mut res: Vec<i32> = vec![];\\n\\n        while idx < len {\\n            let y = nums[idx] as u64;\\n            let gcd = x.gcd(y);\\n            if gcd > 1 {\\n                let lcm = x * y / gcd;\\n                nums[idx] = lcm as i32;\\n                if res.is_empty() {\\n                    x = lcm;\\n                    idx += 1;\\n                } else {\\n                    x = res.pop().unwrap() as u64;\\n                }\\n            } else {\\n                res.push(x as i32);\\n                x = y;\\n                idx += 1;\\n            }\\n        }\\n\\n        res.push(x as i32);\\n\\n        res\\n    }\\n}\\n\\n\\n\\n// https://docs.rs/gcd/latest/src/gcd/lib.rs.html\\n\\n\\nuse core::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\\n\\npub trait Gcd {\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using [`gcd_binary`].\\n    ///\\n    /// [`gcd_binary`]: #method.gcd_binary\\n    ///\\n    /// # Examples\\n    ///\\n    /// ```\\n    /// use gcd::Gcd;\\n    ///\\n    /// assert_eq!(0, 0u8.gcd(0));\\n    /// assert_eq!(10, 10u8.gcd(0));\\n    /// assert_eq!(10, 0u8.gcd(10));\\n    /// assert_eq!(10, 10u8.gcd(20));\\n    /// assert_eq!(44, 2024u32.gcd(748));\\n    /// ```\\n    fn gcd(self, other: Self) -> Self;\\n\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using the [Binary GCD algorithm](https://en.wikipedia.org/wiki/Binary_GCD_algorithm).\\n    fn gcd_binary(self, other: Self) -> Self;\\n\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm).\\n    fn gcd_euclid(self, other: Self) -> Self;\\n}\\n\\nmacro_rules! gcd_impl {\\n    ($(($T:ty) $binary:ident $euclid:ident),*) => {$(\\n        #[doc = concat!(\"Const binary GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $binary(mut u: $T, mut v: $T) -> $T\\n        {\\n            if u == 0 { return v; }\\n            if v == 0 { return u; }\\n\\n            let shift = (u | v).trailing_zeros();\\n            u >>= shift;\\n            v >>= shift;\\n            u >>= u.trailing_zeros();\\n\\n            loop {\\n                v >>= v.trailing_zeros();\\n\\n                #[allow(clippy::manual_swap)]\\n                if u > v {\\n                    // mem::swap(&mut u, &mut v);\\n                    let temp = u;\\n                    u = v;\\n                    v = temp;\\n                }\\n\\n                v -= u; // here v >= u\\n\\n                if v == 0 { break; }\\n            }\\n\\n            u << shift\\n        }\\n\\n        #[doc = concat!(\"Const euclid GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $euclid(a: $T, b: $T) -> $T\\n        {\\n            // variable names based off euclidean division equation: a = b \\xB7 q + r\\n            let (mut a, mut b) = if a > b {\\n                (a, b)\\n            } else {\\n                (b, a)\\n            };\\n\\n            #[allow(clippy::manual_swap)]\\n            while b != 0 {\\n                // mem::swap(&mut a, &mut b);\\n                let temp = a;\\n                a = b;\\n                b = temp;\\n\\n                b %= a;\\n            }\\n\\n            a\\n        }\\n\\n        impl Gcd for $T {\\n            #[inline]\\n            fn gcd(self, other: $T) -> $T {\\n                self.gcd_binary(other)\\n            }\\n\\n            #[inline]\\n            fn gcd_binary(self, v: $T) -> $T {\\n                $binary(self, v)\\n            }\\n\\n            #[inline]\\n            fn gcd_euclid(self, other: $T) -> $T {\\n                $euclid(self, other)\\n            }\\n        }\\n    )*};\\n}\\n\\ngcd_impl! {\\n    (u8) binary_u8 euclid_u8,\\n    (u16) binary_u16 euclid_u16,\\n    (u32) binary_u32 euclid_u32,\\n    (u64) binary_u64 euclid_u64,\\n    (u128) binary_u128 euclid_u128,\\n    (usize) binary_usize euclid_usize\\n}\\n\\nmacro_rules! gcd_impl_nonzero {\\n    ($(($T:ty) $binary_nonzero:ident/$binary:ident $euclid_nonzero:ident/$euclid:ident),*) => {$(\\n        #[doc = concat!(\"Const binary GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $binary_nonzero(u: $T, v: $T) -> $T\\n        {\\n            match <$T>::new($binary(u.get(), v.get())) {\\n                Some(x) => x,\\n                None => unreachable!(),\\n            }\\n        }\\n\\n        #[doc = concat!(\"Const euclid GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $euclid_nonzero(a: $T, b: $T) -> $T\\n        {\\n            match <$T>::new($euclid(a.get(), b.get())) {\\n                Some(x) => x,\\n                None => unreachable!(),\\n            }\\n        }\\n\\n        impl Gcd for $T {\\n            #[inline]\\n            fn gcd(self, other: $T) -> $T {\\n                self.gcd_binary(other)\\n            }\\n\\n            #[inline]\\n            fn gcd_binary(self, v: $T) -> $T {\\n                $binary_nonzero(self, v)\\n            }\\n\\n            #[inline]\\n            fn gcd_euclid(self, other: $T) -> $T {\\n                $euclid_nonzero(self, other)\\n            }\\n        }\\n    )*}\\n}\\n\\ngcd_impl_nonzero! {\\n    (NonZeroU8) binary_nonzero_u8/binary_u8 euclid_nonzero_u8/euclid_u8,\\n    (NonZeroU16) binary_nonzero_u16/binary_u16 euclid_nonzero_u16/euclid_u16,\\n    (NonZeroU32) binary_nonzero_u32/binary_u32 euclid_nonzero_u32/euclid_u32,\\n    (NonZeroU64) binary_nonzero_u64/binary_u64 euclid_nonzero_u64/euclid_u64,\\n    (NonZeroU128) binary_nonzero_u128/binary_u128 euclid_nonzero_u128/euclid_u128,\\n    (NonZeroUsize) binary_nonzero_usize/binary_usize euclid_nonzero_usize/euclid_usize\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn replace_non_coprimes(mut nums: Vec<i32>) -> Vec<i32> {\\n        let len = nums.len();\\n        let mut x: u64 = nums[0] as u64;\\n        let mut idx = 1;\\n        let mut res: Vec<i32> = vec![];\\n\\n        while idx < len {\\n            let y = nums[idx] as u64;\\n            let gcd = x.gcd(y);\\n            if gcd > 1 {\\n                let lcm = x * y / gcd;\\n                nums[idx] = lcm as i32;\\n                if res.is_empty() {\\n                    x = lcm;\\n                    idx += 1;\\n                } else {\\n                    x = res.pop().unwrap() as u64;\\n                }\\n            } else {\\n                res.push(x as i32);\\n                x = y;\\n                idx += 1;\\n            }\\n        }\\n\\n        res.push(x as i32);\\n\\n        res\\n    }\\n}\\n\\n\\n\\n// https://docs.rs/gcd/latest/src/gcd/lib.rs.html\\n\\n\\nuse core::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\\n\\npub trait Gcd {\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using [`gcd_binary`].\\n    ///\\n    /// [`gcd_binary`]: #method.gcd_binary\\n    ///\\n    /// # Examples\\n    ///\\n    /// ```\n```\\n    fn gcd(self, other: Self) -> Self;\\n\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using the [Binary GCD algorithm](https://en.wikipedia.org/wiki/Binary_GCD_algorithm).\\n    fn gcd_binary(self, other: Self) -> Self;\\n\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm).\\n    fn gcd_euclid(self, other: Self) -> Self;\\n}\\n\\nmacro_rules! gcd_impl {\\n    ($(($T:ty) $binary:ident $euclid:ident),*) => {$(\\n        #[doc = concat!(\"Const binary GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $binary(mut u: $T, mut v: $T) -> $T\\n        {\\n            if u == 0 { return v; }\\n            if v == 0 { return u; }\\n\\n            let shift = (u | v).trailing_zeros();\\n            u >>= shift;\\n            v >>= shift;\\n            u >>= u.trailing_zeros();\\n\\n            loop {\\n                v >>= v.trailing_zeros();\\n\\n                #[allow(clippy::manual_swap)]\\n                if u > v {\\n                    // mem::swap(&mut u, &mut v);\\n                    let temp = u;\\n                    u = v;\\n                    v = temp;\\n                }\\n\\n                v -= u; // here v >= u\\n\\n                if v == 0 { break; }\\n            }\\n\\n            u << shift\\n        }\\n\\n        #[doc = concat!(\"Const euclid GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $euclid(a: $T, b: $T) -> $T\\n        {\\n            // variable names based off euclidean division equation: a = b \\xB7 q + r\\n            let (mut a, mut b) = if a > b {\\n                (a, b)\\n            } else {\\n                (b, a)\\n            };\\n\\n            #[allow(clippy::manual_swap)]\\n            while b != 0 {\\n                // mem::swap(&mut a, &mut b);\\n                let temp = a;\\n                a = b;\\n                b = temp;\\n\\n                b %= a;\\n            }\\n\\n            a\\n        }\\n\\n        impl Gcd for $T {\\n            #[inline]\\n            fn gcd(self, other: $T) -> $T {\\n                self.gcd_binary(other)\\n            }\\n\\n            #[inline]\\n            fn gcd_binary(self, v: $T) -> $T {\\n                $binary(self, v)\\n            }\\n\\n            #[inline]\\n            fn gcd_euclid(self, other: $T) -> $T {\\n                $euclid(self, other)\\n            }\\n        }\\n    )*};\\n}\\n\\ngcd_impl! {\\n    (u8) binary_u8 euclid_u8,\\n    (u16) binary_u16 euclid_u16,\\n    (u32) binary_u32 euclid_u32,\\n    (u64) binary_u64 euclid_u64,\\n    (u128) binary_u128 euclid_u128,\\n    (usize) binary_usize euclid_usize\\n}\\n\\nmacro_rules! gcd_impl_nonzero {\\n    ($(($T:ty) $binary_nonzero:ident/$binary:ident $euclid_nonzero:ident/$euclid:ident),*) => {$(\\n        #[doc = concat!(\"Const binary GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $binary_nonzero(u: $T, v: $T) -> $T\\n        {\\n            match <$T>::new($binary(u.get(), v.get())) {\\n                Some(x) => x,\\n                None => unreachable!(),\\n            }\\n        }\\n\\n        #[doc = concat!(\"Const euclid GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $euclid_nonzero(a: $T, b: $T) -> $T\\n        {\\n            match <$T>::new($euclid(a.get(), b.get())) {\\n                Some(x) => x,\\n                None => unreachable!(),\\n            }\\n        }\\n\\n        impl Gcd for $T {\\n            #[inline]\\n            fn gcd(self, other: $T) -> $T {\\n                self.gcd_binary(other)\\n            }\\n\\n            #[inline]\\n            fn gcd_binary(self, v: $T) -> $T {\\n                $binary_nonzero(self, v)\\n            }\\n\\n            #[inline]\\n            fn gcd_euclid(self, other: $T) -> $T {\\n                $euclid_nonzero(self, other)\\n            }\\n        }\\n    )*}\\n}\\n\\ngcd_impl_nonzero! {\\n    (NonZeroU8) binary_nonzero_u8/binary_u8 euclid_nonzero_u8/euclid_u8,\\n    (NonZeroU16) binary_nonzero_u16/binary_u16 euclid_nonzero_u16/euclid_u16,\\n    (NonZeroU32) binary_nonzero_u32/binary_u32 euclid_nonzero_u32/euclid_u32,\\n    (NonZeroU64) binary_nonzero_u64/binary_u64 euclid_nonzero_u64/euclid_u64,\\n    (NonZeroU128) binary_nonzero_u128/binary_u128 euclid_nonzero_u128/euclid_u128,\\n    (NonZeroUsize) binary_nonzero_usize/binary_usize euclid_nonzero_usize/euclid_usize\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862356,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>p;\\n        int n=nums.size();\\n        p.push(nums[0]);\\n        for(int i=1;i<n;i++){\\n            int sum=nums[i];\\n            while(!p.empty() && gcd(sum,p.top())>1){\\n                sum=lcm(sum,p.top());\\n                p.pop();\\n            }\\n            p.push(sum);\\n        }\\n        vector<int>ans;\\n        while(!p.empty()){\\n            ans.push_back(p.top());\\n            p.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>p;\\n        int n=nums.size();\\n        p.push(nums[0]);\\n        for(int i=1;i<n;i++){\\n            int sum=nums[i];\\n            while(!p.empty() && gcd(sum,p.top())>1){\\n                sum=lcm(sum,p.top());\\n                p.pop();\\n            }\\n            p.push(sum);\\n        }\\n        vector<int>ans;\\n        while(!p.empty()){\\n            ans.push_back(p.top());\\n            p.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835720,
                "title": "c-clean-code-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& a) {\\n        stack<int> s;\\n        s.push(a[0]);\\n        vector<int> r;\\n        for(int i=1;i<a.size();i++)\\n            {\\n               int ans=a[i]; \\n               while(s.size() && __gcd(s.top(),ans)>1) \\n               { int x=s.top();\\n                 int y=ans;\\n                 s.pop();\\n                 ans=std::lcm(x,y);     \\n               }  \\n                s.push(ans);\\n            }\\n        while(s.size()){\\n            r.push_back(s.top());\\n            s.pop();\\n        }    \\n        reverse(r.begin(),r.end());\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& a) {\\n        stack<int> s;\\n        s.push(a[0]);\\n        vector<int> r;\\n        for(int i=1;i<a.size();i++)\\n            {\\n               int ans=a[i]; \\n               while(s.size() && __gcd(s.top(),ans)>1) \\n               { int x=s.top();\\n                 int y=ans;\\n                 s.pop();\\n                 ans=std::lcm(x,y);     \\n               }  \\n                s.push(ans);\\n            }\\n        while(s.size()){\\n            r.push_back(s.top());\\n            s.pop();\\n        }    \\n        reverse(r.begin(),r.end());\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687190,
                "title": "python-simple-stack-solution",
                "content": "As the problem statement says - Two values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.\\n\\nSo, we need to figure out a way by which we can take a number and find its GCD with the previous number. And if the GCD with previous is > 1 then we take the LCM of both, remove previous number from output and then again do the same calculation with previous numbers.\\n\\nAnd that can be done efficiently using a Stack.\\n\\nSo, as we traverse the list, we will maintain a stack of elements where, before pushing a value to the stack, we take the GCD of this value with whatever stack has on top. If the GCD is > 1, it means the current and previous values are non-coprime. So, it means, instead of those values, we need to push their LCM in the stack. Hence, we remove the top of stack and so the new value that we have to push is the LCM. \\n\\nBut now, this LCM itself may be non-coprime with the new stack top. So, we again need to do the same calculation. Hence, this will go on until stack is empty or we reach a point where top of stack and the current value are co prime.\\n\\nSince we already know the GCD of two numbers, finding the LCM is pretty straightforward.\\n\\n\\tLCM(a,b) = (a * b) // gcd(a,b)\\n\\n\\n```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        # Stack\\n        stack = []\\n        \\n        # Loop over the input list\\n        for num in nums:\\n            \\n            # The value that we have to push to stack\\n            # It can be this value itself (if its gcd with previous value is 1)\\n            # Or, it can be the LCM with previous value(s)\\n            valToAppend = num\\n            \\n            # While stack is not empty\\n            while stack:\\n                # Get the GCD/HCF of the previous and current value\\n                gcd = math.gcd(stack[-1],valToAppend)\\n                \\n                # Two number are co-prime if their GCD is 1\\n                # So, if they are not co-prime\\n                if gcd > 1:\\n                    # Then, we have to push the LCM of those two numbers in the stack\\n                    # If we know the GCD/HCF, the LCM can be found easily\\n                    # LCM(a,b) = (a * b) // gcd(a,b)\\n                    valToAppend *= stack[-1] // gcd\\n                    \\n                    # And now, the previous value needs to be removed from the stack\\n                    stack.pop()\\n                    \\n                # If two numbers are co-prime, we have to keep both in stack\\n                # So, we pop nothing and break\\n                else: break\\n            \\n            # Finally, we push the \"valToAppend\" in the stack\\n            stack.append(valToAppend)\\n        \\n        # Finally, return the stack\\n        return stack\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        # Stack\\n        stack = []\\n        \\n        # Loop over the input list\\n        for num in nums:\\n            \\n            # The value that we have to push to stack\\n            # It can be this value itself (if its gcd with previous value is 1)\\n            # Or, it can be the LCM with previous value(s)\\n            valToAppend = num\\n            \\n            # While stack is not empty\\n            while stack:\\n                # Get the GCD/HCF of the previous and current value\\n                gcd = math.gcd(stack[-1],valToAppend)\\n                \\n                # Two number are co-prime if their GCD is 1\\n                # So, if they are not co-prime\\n                if gcd > 1:\\n                    # Then, we have to push the LCM of those two numbers in the stack\\n                    # If we know the GCD/HCF, the LCM can be found easily\\n                    # LCM(a,b) = (a * b) // gcd(a,b)\\n                    valToAppend *= stack[-1] // gcd\\n                    \\n                    # And now, the previous value needs to be removed from the stack\\n                    stack.pop()\\n                    \\n                # If two numbers are co-prime, we have to keep both in stack\\n                # So, we pop nothing and break\\n                else: break\\n            \\n            # Finally, we push the \"valToAppend\" in the stack\\n            stack.append(valToAppend)\\n        \\n        # Finally, return the stack\\n        return stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3657296,
                "title": "easy-beginner-friendly-without-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s an easy hard question .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust go through the question ,just keep in the mind Integer overflow at the time of calculating lcm .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n           ans.add(nums[i]);\\n           while(ans.size()>1){\\n               int a=ans.get(ans.size()-1);\\n               int b=ans.get(ans.size()-2);\\n               if(gcd(a,b)==1){\\n                   break;\\n               }\\n               ans.remove(ans.size()-1);\\n               ans.remove(ans.size()-1);\\n               ans.add(lcm(a,b));\\n           }\\n        }\\n        return ans;\\n    }\\n    static int gcd(int a,int b){\\n        if(a==0){\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    static int lcm(int a ,int b){\\n        return (a/gcd(a,b))*(b/gcd(a,b))*gcd(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n           ans.add(nums[i]);\\n           while(ans.size()>1){\\n               int a=ans.get(ans.size()-1);\\n               int b=ans.get(ans.size()-2);\\n               if(gcd(a,b)==1){\\n                   break;\\n               }\\n               ans.remove(ans.size()-1);\\n               ans.remove(ans.size()-1);\\n               ans.add(lcm(a,b));\\n           }\\n        }\\n        return ans;\\n    }\\n    static int gcd(int a,int b){\\n        if(a==0){\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    static int lcm(int a ,int b){\\n        return (a/gcd(a,b))*(b/gcd(a,b))*gcd(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538233,
                "title": "optimize-for-a-row-of-the-same-number-clear-code",
                "content": "# Approache\\nFailed: no extra vector, delete removed entries in num. too slow\\n\\nworking one:\\n1. store result in another vector, no deletion, much faster\\n2. copy 1s, no need to calculate\\n3. jump over a row of the same number\\n\\n\\n# Code\\n```\\n#include <numeric>\\n\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> result; // store result to another vector to avoid too many slow deletion in nums\\n        result.push_back(nums[0]);\\n\\n        int i = 1, j;\\n        int factor;\\n        while (i < nums.size()) {\\n            // no need to calculate 1\\n            if (nums[i] == 1) {\\n                result.push_back(1);\\n                i++;\\n                continue;\\n            }\\n\\n            // jump over same numbers\\n            while(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n                i++;\\n            }\\n\\n            // can merge?\\n            factor = gcd(result[result.size()-1], nums[i]);\\n            if (factor <= 1) { // no need to merge\\n                result.push_back(nums[i]);\\n                i++;\\n                continue;\\n            }\\n            \\n            // then, need to merge now\\n            nums[i-1] = nums[i-1] / factor * nums[i];\\n            result[result.size()-1] = result[result.size()-1] / factor * nums[i];\\n            i++;\\n\\n            // try to merge the last two numbers in result until no more to merge, maybe just use stack like other solutions?\\n            j = result.size()-1;\\n            while(j > 0) {\\n                factor = gcd(result[j-1], result[j]);\\n                if (factor <= 1) {\\n                    break;\\n                }\\n                result[j-1] = result[j-1] / factor * result[j];\\n                j -= 1;\\n            }\\n            // trimming after j, keep j\\n            result.erase(result.begin()+j+1, result.end());\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <numeric>\\n\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> result; // store result to another vector to avoid too many slow deletion in nums\\n        result.push_back(nums[0]);\\n\\n        int i = 1, j;\\n        int factor;\\n        while (i < nums.size()) {\\n            // no need to calculate 1\\n            if (nums[i] == 1) {\\n                result.push_back(1);\\n                i++;\\n                continue;\\n            }\\n\\n            // jump over same numbers\\n            while(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n                i++;\\n            }\\n\\n            // can merge?\\n            factor = gcd(result[result.size()-1], nums[i]);\\n            if (factor <= 1) { // no need to merge\\n                result.push_back(nums[i]);\\n                i++;\\n                continue;\\n            }\\n            \\n            // then, need to merge now\\n            nums[i-1] = nums[i-1] / factor * nums[i];\\n            result[result.size()-1] = result[result.size()-1] / factor * nums[i];\\n            i++;\\n\\n            // try to merge the last two numbers in result until no more to merge, maybe just use stack like other solutions?\\n            j = result.size()-1;\\n            while(j > 0) {\\n                factor = gcd(result[j-1], result[j]);\\n                if (factor <= 1) {\\n                    break;\\n                }\\n                result[j-1] = result[j-1] / factor * result[j];\\n                j -= 1;\\n            }\\n            // trimming after j, keep j\\n            result.erase(result.begin()+j+1, result.end());\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3537434,
                "title": "c-stack",
                "content": "# Intuition\\n**lcm(a,b) = a*b/gcd(a,b)**.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<long long> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.push(nums[i]);\\n            while(st.size()>1)\\n            {\\n                long long n1 = st.top();\\n                st.pop();\\n                long long n2 = st.top();\\n                st.pop();\\n                if(__gcd(n1,n2)!=1)\\n                {\\n                    int num = (n1*n2)/(__gcd(n1,n2));\\n                    st.push(num);\\n                }\\n                else\\n                {\\n                    st.push(n2);\\n                    st.push(n1);\\n                    break;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<long long> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.push(nums[i]);\\n            while(st.size()>1)\\n            {\\n                long long n1 = st.top();\\n                st.pop();\\n                long long n2 = st.top();\\n                st.pop();\\n                if(__gcd(n1,n2)!=1)\\n                {\\n                    int num = (n1*n2)/(__gcd(n1,n2));\\n                    st.push(num);\\n                }\\n                else\\n                {\\n                    st.push(n2);\\n                    st.push(n1);\\n                    break;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520171,
                "title": "c-solution-using-stack-easy-to-understand",
                "content": "\\n```\\npublic class Solution {\\n    public IList<int> ReplaceNonCoprimes(int[] nums) {\\n        // functions\\n        int gcd(int a, int b) => (a == 0) ? b : gcd(b % a,a);\\n        bool IsCoPrime(int a,int b) => gcd(a,b) == 1;\\n        int getLcm(int a, int b) => a / gcd(a,b) * b;\\n        //\\n        Stack<int> s = new Stack<int>();\\n        for(int i = 0;i < nums.Length;i++){\\n            int val = nums[i];\\n            while(s.Count > 0 && !IsCoPrime(s.Peek(),val))\\n                val = getLcm(val,s.Pop());\\n            s.Push(val);\\n        }\\n        List<int> res = new List<int>();\\n        while(s.Count > 0)res.Insert(0,s.Pop());\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> ReplaceNonCoprimes(int[] nums) {\\n        // functions\\n        int gcd(int a, int b) => (a == 0) ? b : gcd(b % a,a);\\n        bool IsCoPrime(int a,int b) => gcd(a,b) == 1;\\n        int getLcm(int a, int b) => a / gcd(a,b) * b;\\n        //\\n        Stack<int> s = new Stack<int>();\\n        for(int i = 0;i < nums.Length;i++){\\n            int val = nums[i];\\n            while(s.Count > 0 && !IsCoPrime(s.Peek(),val))\\n                val = getLcm(val,s.Pop());\\n            s.Push(val);\\n        }\\n        List<int> res = new List<int>();\\n        while(s.Count > 0)res.Insert(0,s.Pop());\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282098,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i : nums){\\n            while(list.size() > 0 && gcd(i, list.get(list.size() - 1)) != 1){\\n                int q = list.get(list.size() - 1);\\n                list.remove(list.size() - 1);\\n                i = lcm(q, i);\\n            }\\n            list.add(i);\\n        }\\n        \\n        return list;\\n\\n        \\n    }\\n    public int gcd(int a, int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n    public int lcm(int a, int b){\\n        return (a / gcd(a, b)) * b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i : nums){\\n            while(list.size() > 0 && gcd(i, list.get(list.size() - 1)) != 1){\\n                int q = list.get(list.size() - 1);\\n                list.remove(list.size() - 1);\\n                i = lcm(q, i);\\n            }\\n            list.add(i);\\n        }\\n        \\n        return list;\\n\\n        \\n    }\\n    public int gcd(int a, int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n    public int lcm(int a, int b){\\n        return (a / gcd(a, b)) * b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260347,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn replace_non_coprimes(nums: Vec<i32>) -> Vec<i32> {\\n        fn gcd(a: i32, b: i32) -> i32 {\\n            match b {\\n                0 => a,\\n                _ => gcd(b, a % b),\\n            }\\n        }\\n\\n        fn lcm(a: i32, b: i32, d: i32) -> i32 {\\n            let a = a as i64;\\n            let b = b as i64;\\n            let d = d as i64;\\n            let ans = (a * b) / d;\\n            ans as i32\\n        }\\n\\n        let mut res = vec![];\\n        for v in nums.iter() {\\n            let n = res.len();\\n            if n == 0 {\\n                res.push(*v);\\n                continue;\\n            }\\n            let mut m = *v;\\n            loop {\\n                let n = res.len() as i32;\\n                if n <= 0 {\\n                    break;\\n                }\\n\\n                let tail = res.pop().unwrap();\\n                let d = gcd(m, tail);\\n                if d == 1 {\\n                    res.push(tail);\\n                    break;\\n                }\\n                m = lcm(m, tail, d);\\n            }\\n            res.push(m);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn replace_non_coprimes(nums: Vec<i32>) -> Vec<i32> {\\n        fn gcd(a: i32, b: i32) -> i32 {\\n            match b {\\n                0 => a,\\n                _ => gcd(b, a % b),\\n            }\\n        }\\n\\n        fn lcm(a: i32, b: i32, d: i32) -> i32 {\\n            let a = a as i64;\\n            let b = b as i64;\\n            let d = d as i64;\\n            let ans = (a * b) / d;\\n            ans as i32\\n        }\\n\\n        let mut res = vec![];\\n        for v in nums.iter() {\\n            let n = res.len();\\n            if n == 0 {\\n                res.push(*v);\\n                continue;\\n            }\\n            let mut m = *v;\\n            loop {\\n                let n = res.len() as i32;\\n                if n <= 0 {\\n                    break;\\n                }\\n\\n                let tail = res.pop().unwrap();\\n                let d = gcd(m, tail);\\n                if d == 1 {\\n                    res.push(tail);\\n                    break;\\n                }\\n                m = lcm(m, tail, d);\\n            }\\n            res.push(m);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165052,
                "title": "keep-merging-with-stack-top",
                "content": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        stack = [nums[0]]\\n        for i in range(1, n):\\n            currval = nums[i]\\n            while len(stack) > 0 and self.gcd(stack[-1], currval) > 1:\\n                prev = stack.pop()\\n                currval = prev * currval // self.gcd(prev, currval)\\n            stack.append(currval)\\n        return stack\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        stack = [nums[0]]\\n        for i in range(1, n):\\n            currval = nums[i]\\n            while len(stack) > 0 and self.gcd(stack[-1], currval) > 1:\\n                prev = stack.pop()\\n                currval = prev * currval // self.gcd(prev, currval)\\n            stack.append(currval)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030558,
                "title": "simply-c-easily-understandable-stack",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate a stack, initially stack is empty so we push first element into stack then traverse again to next element. \\nwhile (st.empty()==false) we check if curr element and stack\\'s top element gcd > 1 or not if yes then we took out the element, calculate the lcm and assign it to curr variable and again check for this new curr value with stack top element.\\nAt any point our gcd == 1 we break out of the loop and push the curr into the stack.\\n\\nAfter that we took out all the element from stack and push them into vector, reverse the vector then return the vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n{\\n    return b == 0 ? a : gcd(b, a % b);   \\n}\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)\\n        return nums;\\n        stack<int> st;\\n        int t, lc ;\\n        for(int i = 0;i<n;i++){\\n            int curr = nums[i];\\n\\n            while(!st.empty()){\\n                int gc = gcd(curr,st.top());\\n                if(gc > 1){\\n                    t = st.top();\\n                    st.pop();\\n                    lc = lcm(curr,t);\\n                    curr = lc;\\n                }\\n                else\\n                break;\\n            }\\n            st.push(curr);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n{\\n    return b == 0 ? a : gcd(b, a % b);   \\n}\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)\\n        return nums;\\n        stack<int> st;\\n        int t, lc ;\\n        for(int i = 0;i<n;i++){\\n            int curr = nums[i];\\n\\n            while(!st.empty()){\\n                int gc = gcd(curr,st.top());\\n                if(gc > 1){\\n                    t = st.top();\\n                    st.pop();\\n                    lc = lcm(curr,t);\\n                    curr = lc;\\n                }\\n                else\\n                break;\\n            }\\n            st.push(curr);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891248,
                "title": "solution-in-scala",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a%b)\\n\\n  def updateStack(n: Int, stack: List[Int]): List[Int] = stack match {\\n    case h :: t =>\\n      val GCD = gcd(n, h)\\n      if (GCD == 1) n :: stack else updateStack(((n.toLong*h)/GCD).toInt, t)\\n    case Nil => n :: stack\\n  }\\n\\n  def replaceNonCoprimes(nums: Array[Int]): List[Int] = {\\n    def loop(index: Int, stack: List[Int]): List[Int] = {\\n      //print(index, stack); println()\\n      if (index == nums.length) stack.reverse\\n      else {\\n        val num = nums(index)\\n        loop(index+1, updateStack(num, stack))\\n      }\\n    }\\n\\n    loop(0, Nil)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a%b)\\n\\n  def updateStack(n: Int, stack: List[Int]): List[Int] = stack match {\\n    case h :: t =>\\n      val GCD = gcd(n, h)\\n      if (GCD == 1) n :: stack else updateStack(((n.toLong*h)/GCD).toInt, t)\\n    case Nil => n :: stack\\n  }\\n\\n  def replaceNonCoprimes(nums: Array[Int]): List[Int] = {\\n    def loop(index: Int, stack: List[Int]): List[Int] = {\\n      //print(index, stack); println()\\n      if (index == nums.length) stack.reverse\\n      else {\\n        val num = nums(index)\\n        loop(index+1, updateStack(num, stack))\\n      }\\n    }\\n\\n    loop(0, Nil)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2889295,
                "title": "python-in-place-w-stack",
                "content": "# Intuition\\nNote that we can greedily merge elements since the problem explicitly states that it can be shown that the order of merge does not matter. \\n# Approach\\nGiven that we can implement a greedy approach, we just need to keep track of the last number we have merged as we iterate over the array.\\n# Complexity\\n- Time complexity:\\n$O(n \\\\log(n))$\\nAlgorithm completes in one loop w/ a log(n) cost per iteration.\\n- Space complexity:\\n$O(n)$\\n# Code\\n```\\nimport math \\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        i = 0\\n        stack = []\\n        while i < n:\\n            while stack and math.gcd(stack[-1][0], nums[i]) > 1:\\n                num, j = stack.pop()\\n                nums[i] = math.lcm(num, nums[i])\\n                nums[j] = float(\\'inf\\')\\n            stack.append([nums[i], i])\\n            i += 1\\n        return [ele for ele in nums if ele != float(\\'inf\\')]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math \\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        i = 0\\n        stack = []\\n        while i < n:\\n            while stack and math.gcd(stack[-1][0], nums[i]) > 1:\\n                num, j = stack.pop()\\n                nums[i] = math.lcm(num, nums[i])\\n                nums[j] = float(\\'inf\\')\\n            stack.append([nums[i], i])\\n            i += 1\\n        return [ele for ele in nums if ele != float(\\'inf\\')]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810140,
                "title": "brute-force-solution-using-stack-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe will use a stack to delete prev top elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStack\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // function to calculate gcd of a and b in log a\\n    int gcd(long int a,long int b){\\n        if(b == 0) return a;\\n        return gcd(b,a%b);\\n    }\\n\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        st.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(st.top() == nums[i] && nums[i] != 1) continue;\\n            int g = nums[i] > st.top() ? gcd(nums[i],st.top()) : gcd(st.top(),nums[i]);\\n            if(g > 1){\\n                // this means we have to change these numbers with its LCM\\n                long int lcm = nums[i]*(st.top()/g);\\n                // Now we have to delete st.top and nums[i] and then insert lcm of both\\n                st.pop();\\n                // Now try to insert lcm while checking in stack for top element\\n                int ng = 1;\\n                if(st.size() > 0) ng = lcm > st.top() ? gcd(lcm,st.top()) : gcd(st.top(),lcm);\\n                while(st.size() > 1 && ng > 1){\\n                    lcm = lcm*(st.top()/ng);\\n                    st.pop();\\n                    ng = lcm > st.top() ? gcd(lcm,st.top()) : gcd(st.top(),lcm);\\n                }\\n                if(st.size() == 1 && ng > 1){\\n                    // we need to delete last element in stack\\n                    lcm = lcm*(st.top()/ng);\\n                    st.pop();\\n                }\\n                st.push(lcm);\\n            }else{\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int> ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to calculate gcd of a and b in log a\\n    int gcd(long int a,long int b){\\n        if(b == 0) return a;\\n        return gcd(b,a%b);\\n    }\\n\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        st.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(st.top() == nums[i] && nums[i] != 1) continue;\\n            int g = nums[i] > st.top() ? gcd(nums[i],st.top()) : gcd(st.top(),nums[i]);\\n            if(g > 1){\\n                // this means we have to change these numbers with its LCM\\n                long int lcm = nums[i]*(st.top()/g);\\n                // Now we have to delete st.top and nums[i] and then insert lcm of both\\n                st.pop();\\n                // Now try to insert lcm while checking in stack for top element\\n                int ng = 1;\\n                if(st.size() > 0) ng = lcm > st.top() ? gcd(lcm,st.top()) : gcd(st.top(),lcm);\\n                while(st.size() > 1 && ng > 1){\\n                    lcm = lcm*(st.top()/ng);\\n                    st.pop();\\n                    ng = lcm > st.top() ? gcd(lcm,st.top()) : gcd(st.top(),lcm);\\n                }\\n                if(st.size() == 1 && ng > 1){\\n                    // we need to delete last element in stack\\n                    lcm = lcm*(st.top()/ng);\\n                    st.pop();\\n                }\\n                st.push(lcm);\\n            }else{\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int> ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806602,
                "title": "easy-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n      \\n            while( !ans.empty() && gcd(nums[i],ans[ans.size()-1]) > 1){\\n                int lcm=(long)nums[i]*ans[ans.size()-1]/gcd(nums[i],ans[ans.size()-1]);\\n                ans.pop_back();\\n                nums[i]=lcm;\\n            }\\n            if(i<nums.size()) ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n      \\n            while( !ans.empty() && gcd(nums[i],ans[ans.size()-1]) > 1){\\n                int lcm=(long)nums[i]*ans[ans.size()-1]/gcd(nums[i],ans[ans.size()-1]);\\n                ans.pop_back();\\n                nums[i]=lcm;\\n            }\\n            if(i<nums.size()) ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800781,
                "title": "c-easy-solution-stack-math-lcm-gcd",
                "content": "class Solution {\\npublic:\\n    \\n    int GCD(int x, int y){\\n        if(y==0) return x;\\n        return GCD(y, x%y);\\n    }\\n    int LCM (int x,int y){\\n        return x / GCD(x,y) * y;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n          for(auto num:nums){\\n              \\n               while (ans.size() && gcd(ans.back(), num) > 1) {\\n                    num = lcm(num, ans.back());\\n                    ans.pop_back();\\n                }\\n                ans.push_back(num);\\n          }   \\n         return ans;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int GCD(int x, int y){\\n        if(y==0) return x;\\n        return GCD(y, x%y);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2800201,
                "title": "python-c-c-100-00-100-00-98-46-faster-two-pointers",
                "content": "We don\\'t use another container as a stack and just move through the \\'nums\\' array with  two pointers i and j.\\n\\nRuntime: 1451 ms, faster than 100.00%\\nMemory Usage: 29.4 MB, less than 92.31%\\n\\n\\tclass Solution(object):\\n\\t\\tdef replaceNonCoprimes(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdef gcd(a, b):\\n\\t\\t\\t\\twhile b:\\n\\t\\t\\t\\t\\ta, b = b, a % b\\n\\t\\t\\t\\treturn a\\n\\n\\t\\t\\tj = 0   # left pointer\\n\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\tg = gcd(nums[j], nums[i])\\n\\t\\t\\t\\tif g == 1:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tif j != i: nums[j] = nums[i]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnums[j] = nums[j] // g * nums[i]\\n\\n\\t\\t\\t\\t\\twhile j >= 1:\\n\\t\\t\\t\\t\\t\\tg = gcd(nums[j - 1], nums[j])\\n\\t\\t\\t\\t\\t\\tif g == 1: break\\n\\t\\t\\t\\t\\t\\tnums[j - 1] = nums[j - 1] // g * nums[j]\\n\\t\\t\\t\\t\\t\\tj -= 1\\n\\n\\t\\t\\treturn nums[:j + 1]\\n\\n\\nRuntime: 508 ms, faster than 100.00%\\nMemory Usage: 47.4 MB, less than 100.00%\\n\\n\\t/**\\n\\t * Note: The returned array must be malloced, assume caller calls free().\\n\\t */\\n\\tint tmp;\\n\\tint gcd(int a, int b)\\n\\t{\\n\\t\\twhile (b)\\n\\t\\t{\\n\\t\\t\\ttmp = a % b;\\n\\t\\t\\ta = b;\\n\\t\\t\\tb = tmp;\\n\\t\\t}\\n\\n\\t\\treturn a;\\n\\t}\\n\\n\\tint* replaceNonCoprimes(int* nums, int numsSize, int* returnSize)\\n\\t{\\n\\t\\tint j = 0;   // left pointer\\n\\t\\tint g;\\n\\n\\t\\tfor (int i = 1; i < numsSize; ++i)\\n\\t\\t{    \\n\\t\\t\\tg = gcd(nums[j], nums[i]);\\n\\n\\t\\t\\tif (g == 1)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tif (++j != i)\\n\\t\\t\\t\\t\\tnums[j] = nums[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{    \\n\\t\\t\\t\\tnums[j] = nums[j] / g * nums[i];\\n\\n\\t\\t\\t\\twhile (j >= 1)\\n\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\tg = gcd(nums[j - 1], nums[j]);\\n\\n\\t\\t\\t\\t\\tif (g == 1) \\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tnums[j - 1] = nums[j - 1] / g * nums[j];\\n\\t\\t\\t\\t\\t--j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturnSize[0] = j + 1; \\n\\t\\treturn nums;\\n\\t}\\n\\t\\nRuntime: 211 ms, faster than 98.46%\\nMemory Usage: 116.6 MB, less than 99.34%\\n\\n\\tclass Solution \\n\\t{\\n\\tpublic:\\n\\t\\tvector<int> replaceNonCoprimes(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tint j = 0;   // left pointer\\n\\t\\t\\tint g;\\n\\n\\t\\t\\tfor (int i = 1; i < nums.size(); ++i)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tg = gcd(nums[j], nums[i]);\\n\\n\\t\\t\\t\\tif (g == 1)\\n\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\tif (++j != i)\\n\\t\\t\\t\\t\\t\\tnums[j] = nums[i];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\tnums[j] = nums[j] / g * nums[i];\\n\\n\\t\\t\\t\\t\\twhile (j >= 1)\\n\\t\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\t\\tg = gcd(nums[j - 1], nums[j]);\\n\\n\\t\\t\\t\\t\\t\\tif (g == 1) \\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tnums[j - 1] = nums[j - 1] / g * nums[j];\\n\\t\\t\\t\\t\\t\\t--j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn vector<int>(nums.begin(), nums.begin() + j + 1);\\n\\t\\t}\\n\\t};\\n\\t\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution(object):\\n\\t\\tdef replaceNonCoprimes(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdef gcd(a, b):\\n\\t\\t\\t\\twhile b:\\n\\t\\t\\t\\t\\ta, b = b, a % b\\n\\t\\t\\t\\treturn a\\n\\n\\t\\t\\tj = 0   # left pointer\\n\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\tg = gcd(nums[j], nums[i])\\n\\t\\t\\t\\tif g == 1:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tif j != i: nums[j] = nums[i]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnums[j] = nums[j] // g * nums[i]\\n\\n\\t\\t\\t\\t\\twhile j >= 1:\\n\\t\\t\\t\\t\\t\\tg = gcd(nums[j - 1], nums[j])\\n\\t\\t\\t\\t\\t\\tif g == 1: break\\n\\t\\t\\t\\t\\t\\tnums[j - 1] = nums[j - 1] // g * nums[j]\\n\\t\\t\\t\\t\\t\\tj -= 1\\n\\n\\t\\t\\treturn nums[:j + 1]\\n\\n\\nRuntime: 508 ms, faster than 100.00%\\nMemory Usage: 47.4 MB, less than 100.00%\\n\\n\\t/**\\n\\t * Note: The returned array must be malloced, assume caller calls free().\\n\\t */\\n\\tint tmp;\\n\\tint gcd(int a, int b)\\n\\t{\\n\\t\\twhile (b)\\n\\t\\t{\\n\\t\\t\\ttmp = a % b;\\n\\t\\t\\ta = b;\\n\\t\\t\\tb = tmp;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2799460,
                "title": "cpp-one-pass-stack-easy-approach-beats-100",
                "content": "# Intuition\\nvariation of Remove All Adjacent Duplicates In String using stack\\n\\n# Approach\\nNote : I used ans vector as stack.\\n1. check gcd of (curr_element and last element in ans vector) \\n2. if(gcd==1) then push the curr_element in ans vector.\\n3. else find LCM and change the curr_element value\\n4. only push the curr_element in ans vector when ans.size()==1 or GCD==1\\n\\n# Complexity\\n- Time complexity:\\nO(NlogM)\\n\\n- Space complexity:\\nO(N) for ans vector otherwise O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        long int i,j,k;\\n        vector<int> ans;\\n        for(i=0;i<nums.size();){\\n            j = nums[i];\\n            if(!ans.empty()){\\n                k = GCD(j,ans.back());\\n                //cout<<j<<\" \"<<k<<\"\\\\n\";\\n                if(k!=1){\\n                    j *= ans.back();\\n                    ans.pop_back();\\n                    j /=k;\\n                    nums[i] = j;\\n                    continue;\\n                }\\n            }ans.push_back(j);\\n            i++;\\n        }\\n        return ans;\\n    }\\n    int GCD(int i,int j){\\n        int rem;\\n        while(j!=0){\\n            rem = i%j;\\n            i=j;\\n            j=rem;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        long int i,j,k;\\n        vector<int> ans;\\n        for(i=0;i<nums.size();){\\n            j = nums[i];\\n            if(!ans.empty()){\\n                k = GCD(j,ans.back());\\n                //cout<<j<<\" \"<<k<<\"\\\\n\";\\n                if(k!=1){\\n                    j *= ans.back();\\n                    ans.pop_back();\\n                    j /=k;\\n                    nums[i] = j;\\n                    continue;\\n                }\\n            }ans.push_back(j);\\n            i++;\\n        }\\n        return ans;\\n    }\\n    int GCD(int i,int j){\\n        int rem;\\n        while(j!=0){\\n            rem = i%j;\\n            i=j;\\n            j=rem;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2799444,
                "title": "python-in-place-o-1-space",
                "content": "note this solution is worse in time complexity than solutions with additional stack\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        while i < len(nums) - 1:\\n            gcd = math.gcd(nums[i], nums[i + 1])\\n            if gcd > 1:\\n                nums[i] = abs(nums[i] * nums[i + 1]) // gcd  # lcm\\n                del nums[i + 1]\\n                i = max(0, i - 1)\\n            else:\\n                i += 1\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        while i < len(nums) - 1:\\n            gcd = math.gcd(nums[i], nums[i + 1])\\n            if gcd > 1:\\n                nums[i] = abs(nums[i] * nums[i + 1]) // gcd  # lcm\\n                del nums[i + 1]\\n                i = max(0, i - 1)\\n            else:\\n                i += 1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742419,
                "title": "python3-o-n-time-o-n-space-stack",
                "content": "Key point:\\n1. lcm(numA, numB) = |numA * numB| / gcd(numA, numB)\\n2. If the incoming element nums[i] and the top element in the stack are non-coprime, then we calculate lcm(nums[i], stack[-1]), pop the top element in the stack, and append the lcm to the stack.\\n\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for idx in range(len(nums)):\\n            cur_num = nums[idx]\\n            while len(stack) > 0:\\n                cur_gcd = self.calculate_gcd(numA=stack[-1], numB=cur_num)\\n                if cur_gcd > 1:\\n                    cur_num = self.calculate_lcm(gcd=cur_gcd, numA=stack[-1], numB=cur_num)\\n                    stack.pop()\\n                else:\\n                    break\\n            stack.append(cur_num)\\n        return stack\\n        \\n    def calculate_gcd(self, numA: int, numB: int) -> int:\\n        while numA > 0 and numB > 0:\\n            if numA == numB:\\n                return numA\\n            if numA > numB:\\n                numA %= numB\\n            else:\\n                numB %= numA\\n        if numA > 0:\\n            return numA\\n        return numB\\n    \\n    def calculate_lcm(self, gcd: int, numA: int, numB: int) -> int:\\n        return (numA * numB) // gcd",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "Key point:\\n1. lcm(numA, numB) = |numA * numB| / gcd(numA, numB)\\n2. If the incoming element nums[i] and the top element in the stack are non-coprime, then we calculate lcm(nums[i], stack[-1]), pop the top element in the stack, and append the lcm to the stack.\\n\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for idx in range(len(nums)):\\n            cur_num = nums[idx]\\n            while len(stack) > 0:\\n                cur_gcd = self.calculate_gcd(numA=stack[-1], numB=cur_num)\\n                if cur_gcd > 1:\\n                    cur_num = self.calculate_lcm(gcd=cur_gcd, numA=stack[-1], numB=cur_num)\\n                    stack.pop()\\n                else:\\n                    break\\n            stack.append(cur_num)\\n        return stack\\n        \\n    def calculate_gcd(self, numA: int, numB: int) -> int:\\n        while numA > 0 and numB > 0:\\n            if numA == numB:\\n                return numA\\n            if numA > numB:\\n                numA %= numB\\n            else:\\n                numB %= numA\\n        if numA > 0:\\n            return numA\\n        return numB\\n    \\n    def calculate_lcm(self, gcd: int, numA: int, numB: int) -> int:\\n        return (numA * numB) // gcd",
                "codeTag": "Java"
            },
            {
                "id": 2740581,
                "title": "simple-c-solution-using-stack-and-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a , int b){\\n        if(a==0){\\n            return b;\\n        }\\n        return gcd(b%a , a);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int> ans;\\n        \\n        stack<int> st;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            if(st.empty()){\\n                st.push(arr[i]);\\n            }\\n            else{\\n                int x = arr[i];\\n                int y = st.top();\\n                int g = gcd(x,y);\\n                if(g>1){\\n                    st.pop();\\n                    int lcm = (int)((1ll*x*y)/g);\\n                    st.push(lcm);\\n                    while(st.size()>1){\\n                        x = st.top();\\n                        st.pop();\\n                        y = st.top();\\n                        st.pop();\\n                        g = gcd(x,y);\\n                        if(g<=1){\\n                            st.push(y);\\n                            st.push(x);\\n                            break;\\n                        }\\n                        lcm = (int)((1ll*x*y)/g);\\n                        st.push(lcm);\\n                    }\\n                }\\n                else{\\n                    st.push(x);\\n                }\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin() , ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a , int b){\\n        if(a==0){\\n            return b;\\n        }\\n        return gcd(b%a , a);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int> ans;\\n        \\n        stack<int> st;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            if(st.empty()){\\n                st.push(arr[i]);\\n            }\\n            else{\\n                int x = arr[i];\\n                int y = st.top();\\n                int g = gcd(x,y);\\n                if(g>1){\\n                    st.pop();\\n                    int lcm = (int)((1ll*x*y)/g);\\n                    st.push(lcm);\\n                    while(st.size()>1){\\n                        x = st.top();\\n                        st.pop();\\n                        y = st.top();\\n                        st.pop();\\n                        g = gcd(x,y);\\n                        if(g<=1){\\n                            st.push(y);\\n                            st.push(x);\\n                            break;\\n                        }\\n                        lcm = (int)((1ll*x*y)/g);\\n                        st.push(lcm);\\n                    }\\n                }\\n                else{\\n                    st.push(x);\\n                }\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin() , ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739338,
                "title": "python-simple-stack",
                "content": "\\n    def replaceNonCoprimes(self, nums):\\n        stack = []\\n        \\n        for i in nums:\\n            stack.append(i)\\n            \\n            while len(stack) > 1 and math.gcd(stack[-1],stack[-2]) > 1:\\n                a, b = stack.pop(), stack.pop()\\n                stack.append(math.lcm(a,b))\\n                \\n        return stack",
                "solutionTags": [],
                "code": "\\n    def replaceNonCoprimes(self, nums):\\n        stack = []\\n        \\n        for i in nums:\\n            stack.append(i)\\n            \\n            while len(stack) > 1 and math.gcd(stack[-1],stack[-2]) > 1:\\n                a, b = stack.pop(), stack.pop()\\n                stack.append(math.lcm(a,b))\\n                \\n        return stack",
                "codeTag": "Python3"
            },
            {
                "id": 2725888,
                "title": "c",
                "content": "Runtime: 615 ms, faster than 100.00% of C online submissions for Replace Non-Coprime Numbers in Array.\\nMemory Usage: 50.3 MB, less than 100.00% of C online submissions for Replace Non-Coprime Numbers in Array.\\n```\\nint gcd(int n1, int n2){\\n\\n    while(n1 != 0 && n2 != 0){\\n        if(n1 >= n2)\\n            n1 %= n2;\\n        else\\n            n2 %= n1;\\n    }\\n    return fmax(n1, n2);\\n}\\n\\nint* replaceNonCoprimes(int* nums, int numsSize, int* returnSize){\\n    int* ans = malloc(numsSize * sizeof(int));\\n    int idx = 0;\\n   for (int i = 0; i < numsSize; i++) {\\n      if(nums[i] == 1){\\n          ans[idx] = 1;\\n          idx++;\\n          continue;\\n      }\\n      if(i > 0 && nums[i] == nums[i-1])\\n           continue;\\n      ans[idx] = nums[i];\\n      idx++;\\n      while (idx > 1) {\\n        const int n1 = ans[idx - 1]; \\n        const int n2 = ans[idx - 2]; \\n        const int d = gcd(n1, n2);\\n        if (d == 1) break;\\n        if(d == n1){\\n            idx--;\\n            continue;\\n        }\\n        if(d == n2){\\n            ans[idx-2] = n1;\\n            idx--;\\n            continue;\\n        }\\n        idx -= 2;\\n        ans[idx] = (n1 / d * n2);\\n        idx++;\\n      }\\n    }\\n    *returnSize = idx;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Stack"
                ],
                "code": "```\\nint gcd(int n1, int n2){\\n\\n    while(n1 != 0 && n2 != 0){\\n        if(n1 >= n2)\\n            n1 %= n2;\\n        else\\n            n2 %= n1;\\n    }\\n    return fmax(n1, n2);\\n}\\n\\nint* replaceNonCoprimes(int* nums, int numsSize, int* returnSize){\\n    int* ans = malloc(numsSize * sizeof(int));\\n    int idx = 0;\\n   for (int i = 0; i < numsSize; i++) {\\n      if(nums[i] == 1){\\n          ans[idx] = 1;\\n          idx++;\\n          continue;\\n      }\\n      if(i > 0 && nums[i] == nums[i-1])\\n           continue;\\n      ans[idx] = nums[i];\\n      idx++;\\n      while (idx > 1) {\\n        const int n1 = ans[idx - 1]; \\n        const int n2 = ans[idx - 2]; \\n        const int d = gcd(n1, n2);\\n        if (d == 1) break;\\n        if(d == n1){\\n            idx--;\\n            continue;\\n        }\\n        if(d == n2){\\n            ans[idx-2] = n1;\\n            idx--;\\n            continue;\\n        }\\n        idx -= 2;\\n        ans[idx] = (n1 / d * n2);\\n        idx++;\\n      }\\n    }\\n    *returnSize = idx;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634808,
                "title": "12-6-question",
                "content": "In example 1 of task, we have final result [12, 7, 6]. \\nBut GCD(12,6) = 6 > 1, so those numbers are not coprime.\\nAnd their MCK = 12, due to condition of task they should be replaced with 1 number (12). \\nSo, final result should look [12, 7]. \\nOr have I missed something ?\\n",
                "solutionTags": [],
                "code": "In example 1 of task, we have final result [12, 7, 6]. \\nBut GCD(12,6) = 6 > 1, so those numbers are not coprime.\\nAnd their MCK = 12, due to condition of task they should be replaced with 1 number (12). \\nSo, final result should look [12, 7]. \\nOr have I missed something ?\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2546121,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for(auto i: nums){\\n            res.push_back(i);\\n            while(res.size() > 1 && __gcd(res.back(), res[res.size() - 2]) > 1){\\n                long long a = res.back();\\n                long long b = res[res.size() - 2];\\n                long long g=__gcd(a,b);\\n                res.pop_back();\\n                res.pop_back();\\n                \\n                res.push_back(a*b/g);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for(auto i: nums){\\n            res.push_back(i);\\n            while(res.size() > 1 && __gcd(res.back(), res[res.size() - 2]) > 1){\\n                long long a = res.back();\\n                long long b = res[res.size() - 2];\\n                long long g=__gcd(a,b);\\n                res.pop_back();\\n                res.pop_back();\\n                \\n                res.push_back(a*b/g);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514757,
                "title": "c-stack-one-pass",
                "content": "TAKE THE TOP 2 ELEMENTS OF THE STACK\\nIF THERE GCD IS >1 THEN POP THOSE 2 ELEMENTS AND PUSH LCM OF THEM\\nLCM OF 2 NUMBERS == (A*B)/GCD(A,B);\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        stack<int>st;\\n        \\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            st.push(nums[i]);\\n            \\n            while(st.size()>1)\\n            {\\n                long long a=st.top();\\n                st.pop();\\n                long long b=st.top();\\n                st.pop();\\n                \\n                if(__gcd(a,b)>1)\\n                {\\n                    st.push(((long long)(a*b)/(__gcd(a,b))));\\n                }\\n                else\\n                {\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        vector<int>ans;\\n        \\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        stack<int>st;\\n        \\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            st.push(nums[i]);\\n            \\n            while(st.size()>1)\\n            {\\n                long long a=st.top();\\n                st.pop();\\n                long long b=st.top();\\n                st.pop();\\n                \\n                if(__gcd(a,b)>1)\\n                {\\n                    st.push(((long long)(a*b)/(__gcd(a,b))));\\n                }\\n                else\\n                {\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        vector<int>ans;\\n        \\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504765,
                "title": "simple-c-implementation-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;i < nums.size() ; i++)\\n        {\\n            while(!ans.empty() and __gcd(ans.back(), nums[i]) > 1)\\n            {\\n                nums[i] = lcm(ans.back(), nums[i]);\\n                ans.pop_back();\\n            }\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;i < nums.size() ; i++)\\n        {\\n            while(!ans.empty() and __gcd(ans.back(), nums[i]) > 1)\\n            {\\n                nums[i] = lcm(ans.back(), nums[i]);\\n                ans.pop_back();\\n            }\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404629,
                "title": "easy-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>st;\\n        int n=nums.size();\\n        st.push(nums[0]);\\n        for(int i=1;i<n;i++){\\n            if(__gcd(nums[i],st.top())!=1){ // we get a non coprime number here\\n              int y=st.top();\\n                st.pop();\\n                long long z=1ll*y*nums[i];\\n                int t=z/__gcd(nums[i],y);    \\n                while(st.size()>0&&__gcd(st.top(),t)!=1)// repeating the same process again \\n                {\\n                    y=st.top();\\n                    st.pop();\\n                    prod=1ll*y*t;\\n                    t=prod/__gcd(y,t); // inbuilt gcd function\\n                }\\n                // Checking the previous elements in the stack \\n                st.push(t);\\n            }else{\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int>ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>st;\\n        int n=nums.size();\\n        st.push(nums[0]);\\n        for(int i=1;i<n;i++){\\n            if(__gcd(nums[i],st.top())!=1){ // we get a non coprime number here\\n              int y=st.top();\\n                st.pop();\\n                long long z=1ll*y*nums[i];\\n                int t=z/__gcd(nums[i],y);    \\n                while(st.size()>0&&__gcd(st.top(),t)!=1)// repeating the same process again \\n                {\\n                    y=st.top();\\n                    st.pop();\\n                    prod=1ll*y*t;\\n                    t=prod/__gcd(y,t); // inbuilt gcd function\\n                }\\n                // Checking the previous elements in the stack \\n                st.push(t);\\n            }else{\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int>ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350412,
                "title": "java-easy-solution-2-approach-stack",
                "content": "\\'\\'\\'\\n**Approach 1:**\\n\\nclass Solution {\\n    \\n    public int gcd(int a,int b){\\n        \\n        if(b==0){\\n            return a;\\n        }\\n        \\n        return gcd(b,a%b);\\n    }\\n    \\n    public int lcm(int a,int b,int gcd){\\n        \\n        return (a/gcd)*(b/gcd)*gcd;\\n    }\\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        \\n        List<Integer> ans=new ArrayList<>();\\n        Stack<Integer> st=new Stack<>();\\n        st.push(nums[0]);\\n        for(int i=1;i<nums.length;i++){\\n            while(st.size()>=2){\\n                int a=st.pop();\\n                int b=st.pop();\\n                int gcd=gcd(a,b);\\n                if(gcd>1){\\n                    st.push(lcm(a,b,gcd));\\n                }else{\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n            int a=st.pop();\\n            int b=nums[i];\\n            int gcd=gcd(a,b);\\n            \\n            if(gcd>1){\\n                st.push(lcm(a,b,gcd));\\n            }else{\\n                st.push(a);\\n                st.push(b);\\n            }\\n        }\\n        \\n        while(st.isEmpty()==false){\\n            ans.add(st.pop());\\n        }\\n        \\n        int i=0,j=ans.size()-1;\\n        \\n        while(i<j){\\n            int temp=ans.get(i);\\n            ans.set(i++,ans.get(j));\\n            ans.set(j--,temp);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n**Approach 2:**\\n\\nclass Solution {\\n    \\n    public int gcd(int a,int b){\\n        \\n        if(b==0){\\n            return a;\\n        }\\n        \\n        return gcd(b,a%b);\\n    }\\n    \\n    public int lcm(int a,int b,int gcd){\\n        \\n        return (a/gcd)*(b/gcd)*gcd;\\n    }\\n             \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            ans.add(nums[i]);\\n            \\n            while(ans.size()>1){\\n                \\n                int a=ans.get(ans.size()-1), b=ans.get(ans.size()-2);\\n                \\n                int gcd=gcd(a,b);\\n                \\n                if(gcd==1)\\n                    break;\\n                ans.remove(ans.size()-1);\\n                ans.remove(ans.size()-1);\\n                ans.add(lcm(a,b,gcd));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int gcd(int a,int b){\\n        \\n        if(b==0){\\n            return a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2346543,
                "title": "c-monotonic-stack",
                "content": "Tips.\\n\\nThough this problem is **Monotonic Stack**, but we use an array instead of stack, to avoid TLE issue.\\nnon-coprime means that two number\\'s GCD is 1\\n```\\n        public IList<int> ReplaceNonCoprimes(int[] nums)\\n        {\\n            int n = nums.Length;\\n            int[] arr = new int[n];//donot use stack , it may TLE\\n            int j = -1;\\n            for(int i = 0; i < n; i++)\\n            {\\n                int curr = nums[i];//we need a local variable, it may update in later\\n                while (j>=0 && getGCD(arr[j], curr) > 1)//if current number is non-coprime with last one\\n                {\\n                    curr = getLCM(arr[j--], curr);//delete them and create their LCM\\n                }\\n                arr[++j]=curr;\\n            }\\n            return arr.Take(j+1).ToList();//j+1 = final count of elements in nums\\n        }\\n\\t\\tprivate int getGCD(int x, int y)//find the GCD of two numbers\\n        {\\n            return y == 0 ? x : getGCD(y, x % y);\\n        }\\n\\t\\tprivate int getLCM(int x, int y)//calculate the LCM of two numbers\\n        {\\n            return x / getGCD(x, y) * y;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public IList<int> ReplaceNonCoprimes(int[] nums)\\n        {\\n            int n = nums.Length;\\n            int[] arr = new int[n];//donot use stack , it may TLE\\n            int j = -1;\\n            for(int i = 0; i < n; i++)\\n            {\\n                int curr = nums[i];//we need a local variable, it may update in later\\n                while (j>=0 && getGCD(arr[j], curr) > 1)//if current number is non-coprime with last one\\n                {\\n                    curr = getLCM(arr[j--], curr);//delete them and create their LCM\\n                }\\n                arr[++j]=curr;\\n            }\\n            return arr.Take(j+1).ToList();//j+1 = final count of elements in nums\\n        }\\n\\t\\tprivate int getGCD(int x, int y)//find the GCD of two numbers\\n        {\\n            return y == 0 ? x : getGCD(y, x % y);\\n        }\\n\\t\\tprivate int getLCM(int x, int y)//calculate the LCM of two numbers\\n        {\\n            return x / getGCD(x, y) * y;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2328607,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int LongestCM(int a, int b, int gcd)\\n    {\\n        int f = a / gcd;\\n        f *= b;\\n        return f;\\n    }\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size(), i = 0;\\n        stack<int> st;\\n        while(i < n)\\n        {\\n            int val = nums[i];\\n            while(!st.empty())\\n            {\\n                int gcd = __gcd(val,st.top());\\n                if(gcd == 1)\\n                    break;\\n                else\\n                {\\n                    int v = st.top();\\n                    st.pop();\\n                    val = LongestCM(v, val, gcd);\\n                }\\n            }\\n            st.push(val);\\n            i++;\\n        }\\n        vector<int> ans(st.size());\\n        int j = st.size()-1;\\n        while(!st.empty())\\n        {\\n            ans[j] = st.top();\\n            st.pop();\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    int LongestCM(int a, int b, int gcd)\\n    {\\n        int f = a / gcd;\\n        f *= b;\\n        return f;\\n    }\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size(), i = 0;\\n        stack<int> st;\\n        while(i < n)\\n        {\\n            int val = nums[i];\\n            while(!st.empty())\\n            {\\n                int gcd = __gcd(val,st.top());\\n                if(gcd == 1)\\n                    break;\\n                else\\n                {\\n                    int v = st.top();\\n                    st.pop();\\n                    val = LongestCM(v, val, gcd);\\n                }\\n            }\\n            st.push(val);\\n            i++;\\n        }\\n        vector<int> ans(st.size());\\n        int j = st.size()-1;\\n        while(!st.empty())\\n        {\\n            ans[j] = st.top();\\n            st.pop();\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133831,
                "title": "c-stack-gcd-storing-temp-results-to-improve-performance",
                "content": "Sometimes it passes all the tests, sometimes produces TLE. Not yet sure how to improve it, but can be helpful for someone.\\n\\nUPD replaced result conversion to and not it is 500ms instead of 2500\\nList<int> result = stack.ToList();\\nresult.Reverse();\\n\\n\\n\\tpublic IList<int> ReplaceNonCoprimes(int[] nums) \\n    {\\n        Stack<int> stack = new Stack<int>();\\n        Dictionary<(int,int), long> gcds = new Dictionary<(int, int), long>();\\n        for(int i = 0; i < nums.Length; ++i)\\n        {\\n            stack.Push(nums[i]);\\n        \\n            while(stack.Count > 1)\\n            {\\n                var temp1 = stack.Pop();\\n                var temp2 = stack.Pop();\\n                \\n                if(!gcds.ContainsKey((temp1, temp2)))\\n                {\\n                    gcds.Add((temp1, temp2), GCD(temp1, temp2));\\n                }\\n                var gcd = gcds[(temp1, temp2)];\\n                    \\n                if(gcd != 1)\\n                {\\n                    long num = (long)temp1*(long)temp2;\\n                    num = num/gcd;\\n                    stack.Push((int)num);\\n                }\\n                else\\n                {\\n                    stack.Push(temp2);\\n                    stack.Push(temp1);\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        \\n       List<int> result = stack.ToList();\\n       result.Reverse();\\n        \\n        return result;\\n    }\\n    \\n    public static long LCM(int a, int b)\\n    {\\n        return a*b/GCD(a, b);\\n    }\\n        \\n    \\n    public static long GCD(int a, int b)\\n    {\\n        if(a == 0 || b == 0)\\n        {\\n            return a + b;\\n        }\\n        \\n        return GCD(b%a, a);\\n    }",
                "solutionTags": [],
                "code": "Sometimes it passes all the tests, sometimes produces TLE. Not yet sure how to improve it, but can be helpful for someone.\\n\\nUPD replaced result conversion to and not it is 500ms instead of 2500\\nList<int> result = stack.ToList();\\nresult.Reverse();\\n\\n\\n\\tpublic IList<int> ReplaceNonCoprimes(int[] nums) \\n    {\\n        Stack<int> stack = new Stack<int>();\\n        Dictionary<(int,int), long> gcds = new Dictionary<(int, int), long>();\\n        for(int i = 0; i < nums.Length; ++i)\\n        {\\n            stack.Push(nums[i]);\\n        \\n            while(stack.Count > 1)\\n            {\\n                var temp1 = stack.Pop();\\n                var temp2 = stack.Pop();\\n                \\n                if(!gcds.ContainsKey((temp1, temp2)))\\n                {\\n                    gcds.Add((temp1, temp2), GCD(temp1, temp2));\\n                }\\n                var gcd = gcds[(temp1, temp2)];\\n                    \\n                if(gcd != 1)\\n                {\\n                    long num = (long)temp1*(long)temp2;\\n                    num = num/gcd;\\n                    stack.Push((int)num);\\n                }\\n                else\\n                {\\n                    stack.Push(temp2);\\n                    stack.Push(temp1);\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        \\n       List<int> result = stack.ToList();\\n       result.Reverse();\\n        \\n        return result;\\n    }\\n    \\n    public static long LCM(int a, int b)\\n    {\\n        return a*b/GCD(a, b);\\n    }\\n        \\n    \\n    public static long GCD(int a, int b)\\n    {\\n        if(a == 0 || b == 0)\\n        {\\n            return a + b;\\n        }\\n        \\n        return GCD(b%a, a);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2097455,
                "title": "c-o-n-solution-using-stack-using-gcd-function",
                "content": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<long long> st;\\n        long long n=nums.size();\\n        st.push(nums[n-1]);\\n        for(int i=n-2;i>=0;i--){\\n            long long x=nums[i];\\n            while(!st.empty() && __gcd(x,st.top())>1){\\n                long long temp=st.top();\\n                st.pop();\\n                long long product=temp*x;\\n                long long res=product/__gcd(x,temp);\\n                x=res;\\n            }\\n            st.push(x);\\n        }\\n        vector<int> sol;\\n        while(!st.empty()){\\n            sol.push_back(st.top());\\n            st.pop();\\n        }\\n        return sol;\\n    }",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<long long> st;\\n        long long n=nums.size();\\n        st.push(nums[n-1]);\\n        for(int i=n-2;i>=0;i--){\\n            long long x=nums[i];\\n            while(!st.empty() && __gcd(x,st.top())>1){\\n                long long temp=st.top();\\n                st.pop();\\n                long long product=temp*x;\\n                long long res=product/__gcd(x,temp);\\n                x=res;\\n            }\\n            st.push(x);\\n        }\\n        vector<int> sol;\\n        while(!st.empty()){\\n            sol.push_back(st.top());\\n            st.pop();\\n        }\\n        return sol;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2092421,
                "title": "simplest-python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for n in nums:\\n            while stack and math.gcd(n, stack[-1]) != 1:\\n                n = math.lcm(stack.pop(), n)\\n            stack.append(n)\\n        return stack\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for n in nums:\\n            while stack and math.gcd(n, stack[-1]) != 1:\\n                n = math.lcm(stack.pop(), n)\\n            stack.append(n)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079605,
                "title": "i-shouted-ba-boom-as-the-code-got-accepted",
                "content": "The idea is:\\n1. traverse the array from left to right > update it\\n2. traverse the array from right to left > update it\\n3. traverse the array from left to right > update it\\n4. traverse the array from right to left > update it\\n.\\n.\\n.\\n... keep doing this until the length of the updated array is not changing. BA-BOOM !!\\n\\n\\n> oh..also, since we are using stack, we don\\'t know that in the end the answer array is reversed or not.\\n> I mean, lets say you did the traversal 5 times, 3 left to right and 2 right to left.\\n> so, eventually, your stack would have given the answer in reversed manner.\\n> you we need to keep track of number of turns we have done the traversal, and accordingly reverse the final answer array.\\n\\n\\nhere is the code..\\n\\n```\\nclass Solution {\\n    \\n    int fgcd(int m, int n){\\n        if(m==0 || n==0) return (m+n);\\n        if(n>m) swap(m,n);\\n        return fgcd(n,m%n);\\n    }\\n    \\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> ans(nums.begin(),nums.end());\\n        \\n        int sz=-1;\\n        int turn=0;\\n        while(sz!=ans.size()){\\n            for(auto it:ans) st.push(it);\\n            ans.clear();\\n            sz=st.size();\\n            \\n            while(st.size()>1){\\n                int n1=st.top();\\n                st.pop();\\n                int n2=st.top();\\n                st.pop();\\n                int gcd=fgcd(n1,n2);\\n                if(gcd>1){\\n                    int lcm = (n1/gcd)*n2;\\n                    st.push(lcm);\\n                }else{\\n                    st.push(n2);\\n                    ans.push_back(n1);\\n                }\\n            }\\n            while(!st.empty()){\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n            turn++;\\n        }\\n        \\n        if(turn%2) reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int fgcd(int m, int n){\\n        if(m==0 || n==0) return (m+n);\\n        if(n>m) swap(m,n);\\n        return fgcd(n,m%n);\\n    }\\n    \\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> ans(nums.begin(),nums.end());\\n        \\n        int sz=-1;\\n        int turn=0;\\n        while(sz!=ans.size()){\\n            for(auto it:ans) st.push(it);\\n            ans.clear();\\n            sz=st.size();\\n            \\n            while(st.size()>1){\\n                int n1=st.top();\\n                st.pop();\\n                int n2=st.top();\\n                st.pop();\\n                int gcd=fgcd(n1,n2);\\n                if(gcd>1){\\n                    int lcm = (n1/gcd)*n2;\\n                    st.push(lcm);\\n                }else{\\n                    st.push(n2);\\n                    ans.push_back(n1);\\n                }\\n            }\\n            while(!st.empty()){\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n            turn++;\\n        }\\n        \\n        if(turn%2) reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060111,
                "title": "simple-stack-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int lcm(int x, int y){\\n        return (x/__gcd(x,y))*y;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        stack<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(st.empty()){\\n                st.push(nums[i]);\\n                continue;\\n            }\\n            int lcmm = nums[i];\\n            while(!st.empty()){\\n                auto curr = st.top();\\n                if(__gcd(curr,lcmm)>1){\\n                    st.pop();\\n                     lcmm= lcm(curr,lcmm);\\n                    \\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            st.push(lcmm);\\n                       \\n            \\n        }\\n        \\n        int n = st.size();\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            ans[i] = st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int lcm(int x, int y){\\n        return (x/__gcd(x,y))*y;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        stack<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(st.empty()){\\n                st.push(nums[i]);\\n                continue;\\n            }\\n            int lcmm = nums[i];\\n            while(!st.empty()){\\n                auto curr = st.top();\\n                if(__gcd(curr,lcmm)>1){\\n                    st.pop();\\n                     lcmm= lcm(curr,lcmm);\\n                    \\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            st.push(lcmm);\\n                       \\n            \\n        }\\n        \\n        int n = st.size();\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            ans[i] = st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041431,
                "title": "js-2-o-n-log-n-solutions-250ms-stack-10x-slower-o-1-space-no-stack",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n// O(n log N) time; O(1) space\\nvar replaceNonCoprimes = function(nums) {\\n  let x = nums[0];\\n  let y;\\n  for( let i = 1; i < nums.length; i++ ) {\\n    y = nums[i];\\n    const d = gcd(x,y);\\n    if ( d > 1 ) {\\n      nums.splice(i-1, 2, x*y/d);\\n      const newi = Math.max(i-2,0);\\n      x = nums[newi];\\n      i = newi;\\n      continue;\\n    }\\n    x = y;\\n  }\\n  return nums;\\n};\\n\\n// this solution is like 10x faster than above\\n// O(N log N) time; O(N) space\\nreplaceNonCoprimes = function(nums) {\\n  const stack = [nums[0]];\\n  stack.top = () => stack[stack.length-1];\\n  let y;\\n  let d;\\n  for( let i = 1; i < nums.length; i++ ) {\\n    y = nums[i];\\n    while(stack.length && (d = gcd(stack.top(),y)) > 1) {\\n      const x = stack.pop();\\n      y = x*y/d; \\n    }\\n    stack.push(y);\\n  }\\n  return stack;\\n};\\n\\n// O( log N ) time; O(1) space\\nfunction gcd(x,y) {\\n  while(y > 0) {\\n    ([x, y] = [y, x % y]);\\n  }\\n  return x;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n// O(n log N) time; O(1) space\\nvar replaceNonCoprimes = function(nums) {\\n  let x = nums[0];\\n  let y;\\n  for( let i = 1; i < nums.length; i++ ) {\\n    y = nums[i];\\n    const d = gcd(x,y);\\n    if ( d > 1 ) {\\n      nums.splice(i-1, 2, x*y/d);\\n      const newi = Math.max(i-2,0);\\n      x = nums[newi];\\n      i = newi;\\n      continue;\\n    }\\n    x = y;\\n  }\\n  return nums;\\n};\\n\\n// this solution is like 10x faster than above\\n// O(N log N) time; O(N) space\\nreplaceNonCoprimes = function(nums) {\\n  const stack = [nums[0]];\\n  stack.top = () => stack[stack.length-1];\\n  let y;\\n  let d;\\n  for( let i = 1; i < nums.length; i++ ) {\\n    y = nums[i];\\n    while(stack.length && (d = gcd(stack.top(),y)) > 1) {\\n      const x = stack.pop();\\n      y = x*y/d; \\n    }\\n    stack.push(y);\\n  }\\n  return stack;\\n};\\n\\n// O( log N ) time; O(1) space\\nfunction gcd(x,y) {\\n  while(y > 0) {\\n    ([x, y] = [y, x % y]);\\n  }\\n  return x;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022851,
                "title": "fully-explained-stack-linear-cpp",
                "content": "Intuition behind using stack is we always need to make sure to replace all adjacent Non-Coprimes. so let\\'s say we replace some jth and (j+1)th index element with their LCM as they were Coprime then we need to check the resultant with (j-1)th element and (j+2)th element.\\n\\nSo in order to make sure that we are checking all of these possibility we can follow the below steps:\\n1. initiate a stack with 1st element\\n2. iterate throgh the given array and check if stack is empty or not\\n3. if not then run a while loop to check that top element is coprime with current element or not\\n4. if not then update the current as lcm of current and top and pop the top element from the stack.\\n5. push the current in stack and repeate step 3 to 5.\\n\\nNow we have our resultant array in stack but in reverse order.\\n\\nTC-O(NlogMaxi), SC-O(N) where N=number of elements in arr and Maxi is the maximum element.\\nPFB the code for your refernce:\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        return b==0 ? a : gcd(b,a%b);\\n    }\\n    int lcm(int a,int b,int c){\\n        return a*1LL*b/c;\\n    } \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> ans;\\n        ans.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(gcd(ans.top(),nums[i])!=1){\\n                int curr=lcm(ans.top(),nums[i],gcd(ans.top(),nums[i]));\\n                ans.pop();\\n                while(ans.size()>0 && gcd(curr,ans.top())!=1){\\n                    curr=lcm(ans.top(),curr,gcd(ans.top(),curr));\\n                    ans.pop();\\n                }\\n                ans.push(curr);\\n            }\\n            else\\n                ans.push(nums[i]);\\n        }\\n        vector<int> vect(ans.size(),0);\\n        for(int i=ans.size()-1;i>=0;i--){\\n            vect[i]=ans.top();\\n            ans.pop();\\n        }\\n        \\n        return vect;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        return b==0 ? a : gcd(b,a%b);\\n    }\\n    int lcm(int a,int b,int c){\\n        return a*1LL*b/c;\\n    } \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> ans;\\n        ans.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(gcd(ans.top(),nums[i])!=1){\\n                int curr=lcm(ans.top(),nums[i],gcd(ans.top(),nums[i]));\\n                ans.pop();\\n                while(ans.size()>0 && gcd(curr,ans.top())!=1){\\n                    curr=lcm(ans.top(),curr,gcd(ans.top(),curr));\\n                    ans.pop();\\n                }\\n                ans.push(curr);\\n            }\\n            else\\n                ans.push(nums[i]);\\n        }\\n        vector<int> vect(ans.size(),0);\\n        for(int i=ans.size()-1;i>=0;i--){\\n            vect[i]=ans.top();\\n            ans.pop();\\n        }\\n        \\n        return vect;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019913,
                "title": "c-short-in-place-solution",
                "content": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n    int n = 0;\\n      \\n    for (int i = 1; i < nums.size(); i++) {\\n      const int num1 = nums[n];\\n      const int num2 = nums[i];\\n      if (std::gcd(num1, num2) < 2) {\\n        nums[++n] = num2;\\n        continue;\\n      }\\n\\n      nums[n] = std::lcm(num1, num2);\\n      // move left\\n      while (n > 0) {\\n        const int num3 = nums[n];\\n        const int num4 = nums[n - 1];\\n        if (std::gcd(num3, num4) < 2) {\\n          break;\\n        }\\n        \\n        nums[--n] = std::lcm(num3, num4);\\n      }\\n    }\\n      \\n    nums.resize(n + 1);\\n    return nums;\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n    int n = 0;\\n      \\n    for (int i = 1; i < nums.size(); i++) {\\n      const int num1 = nums[n];\\n      const int num2 = nums[i];\\n      if (std::gcd(num1, num2) < 2) {\\n        nums[++n] = num2;\\n        continue;\\n      }\\n\\n      nums[n] = std::lcm(num1, num2);\\n      // move left\\n      while (n > 0) {\\n        const int num3 = nums[n];\\n        const int num4 = nums[n - 1];\\n        if (std::gcd(num3, num4) < 2) {\\n          break;\\n        }\\n        \\n        nums[--n] = std::lcm(num3, num4);\\n      }\\n    }\\n      \\n    nums.resize(n + 1);\\n    return nums;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2014543,
                "title": "ruby-stack",
                "content": "```\\ndef replace_non_coprimes(nums)\\n    res = []\\n    nums.each do |ele|\\n        loop do\\n            gcd = (res.last || 1).gcd(ele)\\n            break if gcd == 1\\n            ele *= res.pop/gcd\\n        end\\n        res<<ele\\n    end\\n    res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef replace_non_coprimes(nums)\\n    res = []\\n    nums.each do |ele|\\n        loop do\\n            gcd = (res.last || 1).gcd(ele)\\n            break if gcd == 1\\n            ele *= res.pop/gcd\\n        end\\n        res<<ele\\n    end\\n    res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2014326,
                "title": "easy-o-n-using-stack-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // make a function to get LCM of two numbers\\n    // make a function to get GCD of two numbers\\n    int gcd(int x, int y){\\n        if(y ==0){\\n            return x;\\n        }\\n        return gcd(y,x%y);\\n    }\\n    int lcm(int x, int y){\\n        return (x/gcd(x,y))*y;\\n    }\\n    bool checkNonCoPrime(int x, int y){\\n        int ans = gcd(x,y);\\n        return ans>1;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int>stk;\\n        for(int i =0 ;i<n;i++){\\n            if(stk.empty() || !checkNonCoPrime(stk.top(),nums[i])){\\n                // if numbers are co prime\\n                stk.push(nums[i]);\\n            }\\n            else{\\n                // numbers are non co prime\\n                int lcmN = lcm(stk.top(),nums[i]);\\n                stk.pop();\\n                while(!stk.empty() && checkNonCoPrime(lcmN,stk.top())){\\n                    // we have to also check if our lcmN is also  non-co prime with stk.top() \\n                    lcmN = lcm(lcmN,stk.top());\\n                    stk.pop();    \\n                }\\n                stk.push(lcmN);\\n            }\\n        }\\n        nums.clear();\\n        while(!stk.empty()){\\n            nums.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // make a function to get LCM of two numbers\\n    // make a function to get GCD of two numbers\\n    int gcd(int x, int y){\\n        if(y ==0){\\n            return x;\\n        }\\n        return gcd(y,x%y);\\n    }\\n    int lcm(int x, int y){\\n        return (x/gcd(x,y))*y;\\n    }\\n    bool checkNonCoPrime(int x, int y){\\n        int ans = gcd(x,y);\\n        return ans>1;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int>stk;\\n        for(int i =0 ;i<n;i++){\\n            if(stk.empty() || !checkNonCoPrime(stk.top(),nums[i])){\\n                // if numbers are co prime\\n                stk.push(nums[i]);\\n            }\\n            else{\\n                // numbers are non co prime\\n                int lcmN = lcm(stk.top(),nums[i]);\\n                stk.pop();\\n                while(!stk.empty() && checkNonCoPrime(lcmN,stk.top())){\\n                    // we have to also check if our lcmN is also  non-co prime with stk.top() \\n                    lcmN = lcm(lcmN,stk.top());\\n                    stk.pop();    \\n                }\\n                stk.push(lcmN);\\n            }\\n        }\\n        nums.clear();\\n        while(!stk.empty()){\\n            nums.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014228,
                "title": "c-stack-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {   \\n            st.push(nums[i]);\\n            while(st.size() > 1)        //If stack contain at least 2 elements then\\n            {   \\n                int a = st.top();\\n                st.pop();\\n                int b = st.top();\\n                st.pop();\\n                int gcd = __gcd(a, b);\\n                \\n                if(gcd > 1)\\n                {\\n                    int lcm = 1ll*a*b/gcd;      // A*B = LCM(A, B)*GCD(A, B)\\n                    st.push(lcm);\\n                }\\n                else{                           //Ig gcd comes out to be 1 then push back both A and B and break\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        \\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {   \\n            st.push(nums[i]);\\n            while(st.size() > 1)        //If stack contain at least 2 elements then\\n            {   \\n                int a = st.top();\\n                st.pop();\\n                int b = st.top();\\n                st.pop();\\n                int gcd = __gcd(a, b);\\n                \\n                if(gcd > 1)\\n                {\\n                    int lcm = 1ll*a*b/gcd;      // A*B = LCM(A, B)*GCD(A, B)\\n                    st.push(lcm);\\n                }\\n                else{                           //Ig gcd comes out to be 1 then push back both A and B and break\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        \\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014009,
                "title": "java-o-n-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public int gcd(int a, int b) {\\n        while(b % a != 0) {\\n            int val = a;\\n            a = b % a;\\n            b = val;\\n        }\\n        return a;\\n    }\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            \\n            while(st.size() > 0 && gcd(st.peek(), nums[i]) > 1) {\\n                int val = st.pop();\\n                nums[i] = (val / gcd(val, nums[i])) * nums[i];\\n            } \\n            st.push(nums[i]);\\n            \\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        while(st.size() > 0) {\\n            ans.add(st.pop());\\n        }\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int a, int b) {\\n        while(b % a != 0) {\\n            int val = a;\\n            a = b % a;\\n            b = val;\\n        }\\n        return a;\\n    }\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            \\n            while(st.size() > 0 && gcd(st.peek(), nums[i]) > 1) {\\n                int val = st.pop();\\n                nums[i] = (val / gcd(val, nums[i])) * nums[i];\\n            } \\n            st.push(nums[i]);\\n            \\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        while(st.size() > 0) {\\n            ans.add(st.pop());\\n        }\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013948,
                "title": "python-stack-clean-and-simple",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums):\\n        stack = []\\n        for num in nums:\\n            while stack and gcd(num,stack[-1]) >= 2:\\n                num = lcm(num,stack[-1])\\n                stack.pop()\\n            stack.append(num)\\n        return stack\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums):\\n        stack = []\\n        for num in nums:\\n            while stack and gcd(num,stack[-1]) >= 2:\\n                num = lcm(num,stack[-1])\\n                stack.pop()\\n            stack.append(num)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013924,
                "title": "c-using-gcd",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic IList<int> ReplaceNonCoprimes(int[] nums) {\\n\\t\\t\\tList<int> result = new List<int>();\\n\\t\\t\\tfor(int i=0;i<nums.Length;i++){\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tint lastElem = 0;\\n\\t\\t\\t\\t\\tif(result.Count == 0){\\n\\t\\t\\t\\t\\t\\tlastElem = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tlastElem = result.Last();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tint gcd = GCD(lastElem, nums[i]);\\n\\t\\t\\t\\t\\tif(gcd == 1) break;\\n\\t\\t\\t\\t\\tresult.RemoveAt(result.Count-1);\\n\\t\\t\\t\\t\\tnums[i] = nums[i]*(lastElem/gcd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult.Add(nums[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tpublic int GCD(int num1, int num2){\\n\\t\\t\\treturn (num2>0)? GCD(num2,num1%num2) : num1;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic IList<int> ReplaceNonCoprimes(int[] nums) {\\n\\t\\t\\tList<int> result = new List<int>();\\n\\t\\t\\tfor(int i=0;i<nums.Length;i++){\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tint lastElem = 0;\\n\\t\\t\\t\\t\\tif(result.Count == 0){\\n\\t\\t\\t\\t\\t\\tlastElem = 1;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2012870,
                "title": "python-go-disgustingly-fast-with-caching",
                "content": "There\\'s not much I can add to the solution that hasn\\'t been said, but what I did do is make it go much faster by adding a cache to the GCD, and using an LCM that depends on that cached GCD.\\n\\nIn the Python `math` module, there\\'s a very fast C implementation of Lehmer\\'s algorithm for the GCD. New in 3.9, there\\'s also an LCM function implemented the same way we have here (two numbers multiplied, divided by their GCD), but, *critically*, the very fast GCD implementation doesn\\'t have caching in any way built in (duh). So we are calculating the GCD once to check if the numbers are coprime and *again* to calculate their LCM if they are (inside of the `math.LCM` function.\\n\\nWe can go faster by caching the C implementation of GCM, and writing our own LCM function that uses this cached implementation. The rest of the solution is almost exactly as @tojuna, with the exception of a trick of adding 1 as the initial item in the stack to avoid having to check the length of the stack every loop. Since 1 is coprime with every number, it will be left alone, and we can just chop it off at the end.\\n\\nHope you found the optimization fun!\\n\\n```python\\nfrom functools import cache\\nimport math\\n\\n# LRU cache math.gcd\\ngcd = cache(math.gcd)\\n\\ndef lcm(a: int, b: int) -> int:\\n    \"\"\"\\n    LCM is the product divided by the GCD\\n\\tUses our cached GCD\\n    \"\"\"\\n    return int((a * b) / gcd(a, b))\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = [1] # Initial item, works since 1 is coprime with every number\\n        for i in nums:\\n            stack.append(i)\\n            while gcd(stack[-1], stack[-2]) > 1:\\n                stack.append(lcm(stack.pop(), stack.pop()))\\n        # Trim initial item\\n        return stack[1:]\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom functools import cache\\nimport math\\n\\n# LRU cache math.gcd\\ngcd = cache(math.gcd)\\n\\ndef lcm(a: int, b: int) -> int:\\n    \"\"\"\\n    LCM is the product divided by the GCD\\n\\tUses our cached GCD\\n    \"\"\"\\n    return int((a * b) / gcd(a, b))\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = [1] # Initial item, works since 1 is coprime with every number\\n        for i in nums:\\n            stack.append(i)\\n            while gcd(stack[-1], stack[-2]) > 1:\\n                stack.append(lcm(stack.pop(), stack.pop()))\\n        # Trim initial item\\n        return stack[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012567,
                "title": "python-100-faster-and-easy-to-understand",
                "content": "\\t\"\"\"\\n\\tclass Solution(object):\\n    def replaceNonCoprimes(self, nums):\\n        def gcd(a,b):\\n            if b==0:\\n                return a\\n            return gcd(b,a%b)\\n        stack=[nums[0]]\\n        for i in nums[1:]:\\n            y=i\\n            while len(stack)>0 and gcd(y,stack[-1])>1:\\n                x=stack.pop()\\n                y=(x*y)//gcd(x,y)\\n            stack.append(y)\\n            # print(stack)\\n        return stack\\n                \\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n\\t\"\"\"",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Stack"
                ],
                "code": "\\t\"\"\"\\n\\tclass Solution(object):\\n    def replaceNonCoprimes(self, nums):\\n        def gcd(a,b):\\n            if b==0:\\n                return a\\n            return gcd(b,a%b)\\n        stack=[nums[0]]\\n        for i in nums[1:]:\\n            y=i\\n            while len(stack)>0 and gcd(y,stack[-1])>1:\\n                x=stack.pop()\\n                y=(x*y)//gcd(x,y)\\n            stack.append(y)\\n            # print(stack)\\n        return stack\\n                \\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n\\t\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 2012348,
                "title": "easy-java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length, i; Stack<Long>stk = new Stack<Long>();\\n        \\n        for(i = 0; i<n; i++)\\n        {\\n            long x = nums[i];\\n            \\n            while(!stk.isEmpty()){\\n                long gcd = calcGcd(stk.peek(), x);\\n                if(gcd==1) break;\\n                else{\\n                    long y = stk.peek(); stk.pop();\\n                    x = calcLcm(x, y);\\n                }\\n            }\\n            stk.add(x);\\n        }\\n        \\n        List<Integer>lst = new ArrayList<Integer>();\\n        \\n        while(!stk.isEmpty())\\n        {\\n            long x = stk.peek(); stk.pop();\\n            lst.add((int)x);\\n        }\\n        \\n        Collections.reverse(lst); return lst;\\n    }\\n    \\n    public long calcGcd(long a, long b)\\n    {\\n        if(a==0) return b;\\n        return calcGcd(b%a, a);\\n    }\\n    public long calcLcm(long a, long b)\\n    {\\n        long gcd = calcGcd(a, b);\\n        return (a*b)/gcd;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length, i; Stack<Long>stk = new Stack<Long>();\\n        \\n        for(i = 0; i<n; i++)\\n        {\\n            long x = nums[i];\\n            \\n            while(!stk.isEmpty()){\\n                long gcd = calcGcd(stk.peek(), x);\\n                if(gcd==1) break;\\n                else{\\n                    long y = stk.peek(); stk.pop();\\n                    x = calcLcm(x, y);\\n                }\\n            }\\n            stk.add(x);\\n        }\\n        \\n        List<Integer>lst = new ArrayList<Integer>();\\n        \\n        while(!stk.isEmpty())\\n        {\\n            long x = stk.peek(); stk.pop();\\n            lst.add((int)x);\\n        }\\n        \\n        Collections.reverse(lst); return lst;\\n    }\\n    \\n    public long calcGcd(long a, long b)\\n    {\\n        if(a==0) return b;\\n        return calcGcd(b%a, a);\\n    }\\n    public long calcLcm(long a, long b)\\n    {\\n        long gcd = calcGcd(a, b);\\n        return (a*b)/gcd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967084,
                "title": "golang-stack",
                "content": "```\\nfunc replaceNonCoprimes(nums []int) []int {\\n    stack :=[]int{}\\n    count:=0\\n    for _,num := range nums{\\n        stack=append(stack,num)\\n        count++\\n        for count>1 && GCD(stack[count-2],stack[count-1])!=1{\\n            stack= append(stack[:count-2],LCM(stack[count-2],stack[count-1]))\\n            count--\\n        }\\n    }\\n    return stack\\n}\\n\\nfunc LCM(i,j int) int {\\n    return i*j/(GCD(i,j))\\n}\\n\\nfunc GCD(i,j int) int{\\n    if i<j{\\n        i,j=j,i\\n    }\\n    \\n    for i%j!=0{\\n        i,j = j,i%j\\n    }\\n    return j\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc replaceNonCoprimes(nums []int) []int {\\n    stack :=[]int{}\\n    count:=0\\n    for _,num := range nums{\\n        stack=append(stack,num)\\n        count++\\n        for count>1 && GCD(stack[count-2],stack[count-1])!=1{\\n            stack= append(stack[:count-2],LCM(stack[count-2],stack[count-1]))\\n            count--\\n        }\\n    }\\n    return stack\\n}\\n\\nfunc LCM(i,j int) int {\\n    return i*j/(GCD(i,j))\\n}\\n\\nfunc GCD(i,j int) int{\\n    if i<j{\\n        i,j=j,i\\n    }\\n    \\n    for i%j!=0{\\n        i,j = j,i%j\\n    }\\n    return j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1930879,
                "title": "python-soln",
                "content": "```\\n\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def findgcd(a,b):\\n            if b==0:\\n                return a\\n            return findgcd(b,a%b)\\n        res=[]\\n        res.append(nums[0])\\n        \\n        for i in range(1,len(nums)):\\n            a=nums[i]\\n            while(len(res)>0):\\n                z=findgcd(res[-1],a)\\n                if z>1:\\n                    x=res.pop()\\n                    a=(a*x)//z\\n                else:\\n                    break\\n            res.append(a)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def findgcd(a,b):\\n            if b==0:\\n                return a\\n            return findgcd(b,a%b)\\n        res=[]\\n        res.append(nums[0])\\n        \\n        for i in range(1,len(nums)):\\n            a=nums[i]\\n            while(len(res)>0):\\n                z=findgcd(res[-1],a)\\n                if z>1:\\n                    x=res.pop()\\n                    a=(a*x)//z\\n                else:\\n                    break\\n            res.append(a)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913068,
                "title": "python-stack",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack=[]\\n        def gcd(a,b):\\n            while(b>0):\\n                a,b=b,a%b\\n            return a\\n        for item in nums:\\n            while len(stack)>0 and (gcd(stack[-1],item)>1):\\n                a=stack.pop()\\n                item=a*item//gcd(a,item)\\n            stack.append(item)\\n        return stack",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack=[]\\n        def gcd(a,b):\\n            while(b>0):\\n                a,b=b,a%b\\n            return a\\n        for item in nums:\\n            while len(stack)>0 and (gcd(stack[-1],item)>1):\\n                a=stack.pop()\\n                item=a*item//gcd(a,item)\\n            stack.append(item)\\n        return stack",
                "codeTag": "Java"
            },
            {
                "id": 1848970,
                "title": "my-java-solution-o-length-log-min-n1-n2",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        // lcm = (a * b) / gcd\\n        LinkedList<Integer> result = new LinkedList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        if (nums.length == 1) {\\n            result.add(nums[0]);\\n            return result;\\n        }\\n        for (int number : nums) {\\n            while (true) {\\n                int lastElement = result.isEmpty() ? 1 : result.getLast(); // triggers mainly on the very first element\\n                int gcd = findGCD(lastElement, number);\\n                if (gcd == 1 ) {\\n                    break; // we should not want this\\n                }\\n                number = number * (result.removeLast() / gcd); // done division first to avoid overflow\\n            }\\n            result.add(number);\\n        }\\n        return result;\\n    }\\n    \\n    public int findGCD(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return findGCD(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        // lcm = (a * b) / gcd\\n        LinkedList<Integer> result = new LinkedList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        if (nums.length == 1) {\\n            result.add(nums[0]);\\n            return result;\\n        }\\n        for (int number : nums) {\\n            while (true) {\\n                int lastElement = result.isEmpty() ? 1 : result.getLast(); // triggers mainly on the very first element\\n                int gcd = findGCD(lastElement, number);\\n                if (gcd == 1 ) {\\n                    break; // we should not want this\\n                }\\n                number = number * (result.removeLast() / gcd); // done division first to avoid overflow\\n            }\\n            result.add(number);\\n        }\\n        return result;\\n    }\\n    \\n    public int findGCD(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return findGCD(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844737,
                "title": "java-solution-with-a-stack-one-pass",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        st.push(nums[0]);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int num = nums[i];\\n            while (!st.isEmpty() && GCD(st.peek(), num) != 1) {\\n                int cur = st.pop();\\n                int lcm = LCM(num, cur);\\n                num = lcm;\\n            }\\n            st.push(num);\\n        }\\n        List<Integer> ans = new ArrayList<>(st);\\n        return ans;\\n    }\\n\\n    private int GCD(int a, int b) {\\n        return a % b == 0 ? b : GCD(b, a % b) ;\\n    }\\n\\n    private int LCM(int a, int b) {\\n        int gcd = GCD(a, b);\\n        int lcm = a / gcd * b;\\n        return lcm;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        st.push(nums[0]);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int num = nums[i];\\n            while (!st.isEmpty() && GCD(st.peek(), num) != 1) {\\n                int cur = st.pop();\\n                int lcm = LCM(num, cur);\\n                num = lcm;\\n            }\\n            st.push(num);\\n        }\\n        List<Integer> ans = new ArrayList<>(st);\\n        return ans;\\n    }\\n\\n    private int GCD(int a, int b) {\\n        return a % b == 0 ? b : GCD(b, a % b) ;\\n    }\\n\\n    private int LCM(int a, int b) {\\n        int gcd = GCD(a, b);\\n        int lcm = a / gcd * b;\\n        return lcm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843597,
                "title": "kotlin-stack-math",
                "content": "```\\nclass Solution {\\n\\n    fun replaceNonCoprimes(nums: IntArray): List<Int> {\\n        val stack = Stack<Int>()\\n        if(nums.size <= 1) return nums.toList()\\n        stack.add(nums[0])        \\n        for(i in 1 until nums.size) {\\n            var lcm = nums[i]\\n            while(stack.isNotEmpty() && getGCD(lcm,stack.peek()) > 1) {\\n                lcm = getLCM(lcm, stack.pop())\\n            }\\n            stack.add(lcm)\\n        }\\n        \\n        return stack.toList()\\n    }\\n\\n    private fun getLCM(a: Int, b: Int): Int {\\n        return (a / getGCD(a, b)) * b\\n    }\\n\\n    private fun getGCD(a:Int, b:Int): Int {\\n        if (a == 0)\\n            return b\\n        return getGCD(b % a, a)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    fun replaceNonCoprimes(nums: IntArray): List<Int> {\\n        val stack = Stack<Int>()\\n        if(nums.size <= 1) return nums.toList()\\n        stack.add(nums[0])        \\n        for(i in 1 until nums.size) {\\n            var lcm = nums[i]\\n            while(stack.isNotEmpty() && getGCD(lcm,stack.peek()) > 1) {\\n                lcm = getLCM(lcm, stack.pop())\\n            }\\n            stack.add(lcm)\\n        }\\n        \\n        return stack.toList()\\n    }\\n\\n    private fun getLCM(a: Int, b: Int): Int {\\n        return (a / getGCD(a, b)) * b\\n    }\\n\\n    private fun getGCD(a:Int, b:Int): Int {\\n        if (a == 0)\\n            return b\\n        return getGCD(b % a, a)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843542,
                "title": "rust-stack-gcd-and-lcm-o-n",
                "content": "```\\nfn gcd(a: i32, b: i32) -> i32\\n{\\n    if a < b {\\n        let (a, b) = (b, a);\\n    }\\n    match b {\\n        0 => a,\\n        _ => gcd(b, a % b),\\n    }\\n}\\n\\nfn lcm(a: i32, b: i32, d: i32) -> i32 {\\n    // let ans = (a as i64 * b as i64) / (d as i64);\\n    let a = a as i64;\\n    let b = b as i64;\\n    let d = d as i64;\\n    let ans = (a * b) / d;\\n    ans as i32\\n}\\n\\nimpl Solution {\\n    pub fn replace_non_coprimes(nums: Vec<i32>) -> Vec<i32> {\\n        let mut res = vec![];\\n        for v in nums.iter() {\\n            let n = res.len();\\n            if n == 0 {\\n                res.push(*v);\\n                continue;\\n            }\\n            let mut m = *v;\\n            loop {\\n                let n = res.len();\\n                if n <= 0 { break }\\n                \\n                let tail = res.pop().unwrap();\\n                let d = gcd(m, tail);\\n                if d == 1 {\\n                    res.push(tail);\\n                    break;\\n                }\\n                m = lcm(m, tail, d);\\n                // println!(\"v {} tail {}, gcd {}, lcm {}\", v, tail, d, m);\\n            }\\n            res.push(m);\\n            // println!(\"res {:?}\", res);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn gcd(a: i32, b: i32) -> i32\\n{\\n    if a < b {\\n        let (a, b) = (b, a);\\n    }\\n    match b {\\n        0 => a,\\n        _ => gcd(b, a % b),\\n    }\\n}\\n\\nfn lcm(a: i32, b: i32, d: i32) -> i32 {\\n    // let ans = (a as i64 * b as i64) / (d as i64);\\n    let a = a as i64;\\n    let b = b as i64;\\n    let d = d as i64;\\n    let ans = (a * b) / d;\\n    ans as i32\\n}\\n\\nimpl Solution {\\n    pub fn replace_non_coprimes(nums: Vec<i32>) -> Vec<i32> {\\n        let mut res = vec![];\\n        for v in nums.iter() {\\n            let n = res.len();\\n            if n == 0 {\\n                res.push(*v);\\n                continue;\\n            }\\n            let mut m = *v;\\n            loop {\\n                let n = res.len();\\n                if n <= 0 { break }\\n                \\n                let tail = res.pop().unwrap();\\n                let d = gcd(m, tail);\\n                if d == 1 {\\n                    res.push(tail);\\n                    break;\\n                }\\n                m = lcm(m, tail, d);\\n                // println!(\"v {} tail {}, gcd {}, lcm {}\", v, tail, d, m);\\n            }\\n            res.push(m);\\n            // println!(\"res {:?}\", res);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1842583,
                "title": "typescript-solution",
                "content": "```typescript\\nfunction replaceNonCoprimes(nums: number[]): number[] {\\n    function findGCD(a: number, b: number): number {\\n        const r = Math.min(Math.abs(b - a * Math.floor(b / a)), Math.abs(b - a * Math.ceil(b / a)));\\n        if (r === 0) return a;\\n        return findGCD(r, a);\\n    }\\n\\n    const result: number[] = [];\\n\\n    function process(num: number) {\\n        const top = result.pop();\\n        if (top === undefined) {\\n            result.push(num);\\n        } else {\\n            const GCD = findGCD(top, num);\\n            if (GCD !== 1) {\\n                const LCM = (top * num) / GCD;\\n                process(LCM);\\n            } else {\\n                result.push(top, num);\\n            }\\n        }\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        process(nums[i]);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction replaceNonCoprimes(nums: number[]): number[] {\\n    function findGCD(a: number, b: number): number {\\n        const r = Math.min(Math.abs(b - a * Math.floor(b / a)), Math.abs(b - a * Math.ceil(b / a)));\\n        if (r === 0) return a;\\n        return findGCD(r, a);\\n    }\\n\\n    const result: number[] = [];\\n\\n    function process(num: number) {\\n        const top = result.pop();\\n        if (top === undefined) {\\n            result.push(num);\\n        } else {\\n            const GCD = findGCD(top, num);\\n            if (GCD !== 1) {\\n                const LCM = (top * num) / GCD;\\n                process(LCM);\\n            } else {\\n                result.push(top, num);\\n            }\\n        }\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        process(nums[i]);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841868,
                "title": "p5-js-interative-visualization-for-a-solution-that-resembles-zuma",
                "content": "Very intuitive!\\n\\nIt much resembles playing Zuma\\n\\nInteractive version is on the [p5.js playground](https://editor.p5js.org/nitroglycerine/full/eDfHUufPE) \\n\\n![image](https://assets.leetcode.com/users/images/cc1a4efc-2901-4fa3-a633-1875bf7c1586_1647072579.2999318.gif)\\n\\n",
                "solutionTags": [],
                "code": "Very intuitive!\\n\\nIt much resembles playing Zuma\\n\\nInteractive version is on the [p5.js playground](https://editor.p5js.org/nitroglycerine/full/eDfHUufPE) \\n\\n![image](https://assets.leetcode.com/users/images/cc1a4efc-2901-4fa3-a633-1875bf7c1586_1647072579.2999318.gif)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1841386,
                "title": "simple-c-solution",
                "content": "~~~\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int y=nums[i];\\n            while(v.size()>0 and __gcd(v.back(),y)>1)\\n            {\\n                int x=v.back();\\n                v.pop_back();\\n                y=(x/__gcd(x,y))*y;\\n            }\\n            v.push_back(y);\\n        }\\n        return v;\\n    }\\n\\t~~~\\n",
                "solutionTags": [],
                "code": "~~~\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int y=nums[i];\\n            while(v.size()>0 and __gcd(v.back(),y)>1)\\n            {\\n                int x=v.back();\\n                v.pop_back();\\n                y=(x/__gcd(x,y))*y;\\n            }\\n            v.push_back(y);\\n        }\\n        return v;\\n    }\\n\\t~~~\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1839455,
                "title": "c-solution-2197",
                "content": "A straight forward implementation of the given problem statement\\nMerge two adjacent numbers untill they are not co prime (GCD > 1). For this we can use stack as it gives us the adjacent number at the top of it and we can merge and pop untill the condition satisfies\\nHere we used vector as a stack for better time complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        int n = nums.size(),GCD,LCM,val;\\n        long long product;\\n        for(int i=1;i<n;i++){\\n            val = nums[i];\\n            GCD = __gcd(res.back(),val);\\n            while(GCD > 1){\\n                product = (long long)(res.back()) * (long long)(val);\\n                LCM = product/GCD;\\n                res.pop_back();\\n                val = LCM;\\n\\t\\t\\t\\tGCD = res.empty() ? 1 : __gcd(res.back(),val);\\n            }\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFeel free to comment your queries if any\\n**Upvote** if found useful\\n**Thank You :)**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        int n = nums.size(),GCD,LCM,val;\\n        long long product;\\n        for(int i=1;i<n;i++){\\n            val = nums[i];\\n            GCD = __gcd(res.back(),val);\\n            while(GCD > 1){\\n                product = (long long)(res.back()) * (long long)(val);\\n                LCM = product/GCD;\\n                res.pop_back();\\n                val = LCM;\\n\\t\\t\\t\\tGCD = res.empty() ? 1 : __gcd(res.back(),val);\\n            }\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837561,
                "title": "c-o-n-log-m-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        deque<int> val;\\n        for(int i=0; i<nums.size(); i++){\\n            val.push_back(nums[i]);\\n            \\n            while(val.size()>1){\\n                int gcd = GCD(val[val.size()-1], val[val.size()-2]);\\n                if(gcd==1){\\n                    break;\\n                }else{\\n                    int newVal = (val[val.size()-1]/gcd)* val[val.size()-2];\\n                    val.pop_back();\\n                    val[val.size()-1] = newVal;\\n                }\\n            }\\n        }\\n        return vector<int>(val.begin(), val.end());\\n        \\n    }\\n    \\n    int GCD(int a, int b){\\n        if(a<b){\\n            swap(a,b);\\n        }\\n        if(a%b==0){\\n            return b;\\n        }\\n        return GCD(b, a%b);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        deque<int> val;\\n        for(int i=0; i<nums.size(); i++){\\n            val.push_back(nums[i]);\\n            \\n            while(val.size()>1){\\n                int gcd = GCD(val[val.size()-1], val[val.size()-2]);\\n                if(gcd==1){\\n                    break;\\n                }else{\\n                    int newVal = (val[val.size()-1]/gcd)* val[val.size()-2];\\n                    val.pop_back();\\n                    val[val.size()-1] = newVal;\\n                }\\n            }\\n        }\\n        return vector<int>(val.begin(), val.end());\\n        \\n    }\\n    \\n    int GCD(int a, int b){\\n        if(a<b){\\n            swap(a,b);\\n        }\\n        if(a%b==0){\\n            return b;\\n        }\\n        return GCD(b, a%b);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835973,
                "title": "java-clean-simple-linkedlist",
                "content": "```\\n\\n\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        // 2 numbers are coprime if their greatest common divisor is 1\\n        // LCM is x*y/gcd\\n        LinkedList<Integer> res = new LinkedList();        \\n\\n        for(int i = 0; i < nums.length; i++) {\\n            long cur = nums[i];\\n            \\n            // continuously comparing to the end of the constructed list, remove and re-add if needed\\n            while(!res.isEmpty()) {\\n                long last = res.getLast();\\n                long gcd = gcd(last, cur);\\n                if(gcd > 1) {\\n                    res.removeLast();\\n                    cur = cur*last/gcd;\\n                } else {\\n                    break;   \\n                }\\n            }\\n            \\n            res.add((int)cur);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Euclidean algorithm\\n    private long gcd(long x, long y) {\\n        if(y == 0) {\\n            return x;\\n        }\\n        return gcd(y, x%y);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        // 2 numbers are coprime if their greatest common divisor is 1\\n        // LCM is x*y/gcd\\n        LinkedList<Integer> res = new LinkedList();        \\n\\n        for(int i = 0; i < nums.length; i++) {\\n            long cur = nums[i];\\n            \\n            // continuously comparing to the end of the constructed list, remove and re-add if needed\\n            while(!res.isEmpty()) {\\n                long last = res.getLast();\\n                long gcd = gcd(last, cur);\\n                if(gcd > 1) {\\n                    res.removeLast();\\n                    cur = cur*last/gcd;\\n                } else {\\n                    break;   \\n                }\\n            }\\n            \\n            res.add((int)cur);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Euclidean algorithm\\n    private long gcd(long x, long y) {\\n        if(y == 0) {\\n            return x;\\n        }\\n        return gcd(y, x%y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835073,
                "title": "simple-python-with-comments",
                "content": "The time saving trick here is to check to the immediate left of each merge once it happens. This can be done easily by backtracking our current index.\\n\\n```class Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        hasUpdate = False\\n        isFirstIter = True # We want to simulate a do-while loop\\n        while hasUpdate or isFirstIter:\\n            isFirstIter = False\\n            hasUpdate = False\\n            n = len(nums) - 1\\n            i = 0\\n            while i < n: # We need n to be mutable during the loop\\n                a = nums[i]\\n                b = nums[i + 1]\\n                ab_gcd = gcd(a,b)\\n                if ab_gcd > 1:\\n                    nums[i] = lcm(a,b) # Update the left value\\n                    del nums[i + 1] # Delete the right value\\n                    n -= 1 # Decrement our array size\\n                    i = max(-1, i - 2) # We want to backtrack one to the left of our current index (-2 cause we will +1 in the loop)\\n                    hasUpdate = True\\n                i += 1\\n        return nums\\n        ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        hasUpdate = False\\n        isFirstIter = True # We want to simulate a do-while loop\\n        while hasUpdate or isFirstIter:\\n            isFirstIter = False\\n            hasUpdate = False\\n            n = len(nums) - 1\\n            i = 0\\n            while i < n: # We need n to be mutable during the loop\\n                a = nums[i]\\n                b = nums[i + 1]\\n                ab_gcd = gcd(a,b)\\n                if ab_gcd > 1:\\n                    nums[i] = lcm(a,b) # Update the left value\\n                    del nums[i + 1] # Delete the right value\\n                    n -= 1 # Decrement our array size\\n                    i = max(-1, i - 2) # We want to backtrack one to the left of our current index (-2 cause we will +1 in the loop)\\n                    hasUpdate = True\\n                i += 1\\n        return nums\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1831410,
                "title": "c",
                "content": "```\\n long long gcd(long long a,long long b){\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n    long long lcm(long long a,long long b){\\n         return (a / gcd(a, b)) * b;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        stack<int> stk;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            int curr = nums[i];\\n            while(!stk.empty() && gcd(curr,stk.top()) > 1){\\n               curr = lcm(curr,stk.top());\\n               stk.pop(); \\n            }\\n            stk.push(curr);\\n        }\\n        while(!stk.empty()){\\n            res.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(res.begin(),end(res));\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n long long gcd(long long a,long long b){\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n    long long lcm(long long a,long long b){\\n         return (a / gcd(a, b)) * b;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        stack<int> stk;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            int curr = nums[i];\\n            while(!stk.empty() && gcd(curr,stk.top()) > 1){\\n               curr = lcm(curr,stk.top());\\n               stk.pop(); \\n            }\\n            stk.push(curr);\\n        }\\n        while(!stk.empty()){\\n            res.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(res.begin(),end(res));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1831021,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n         \\n        stack = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            \\n            if math.gcd(stack[-1], nums[i]) > 1 :\\n                num1 = nums[i]\\n                \\n                while math.gcd(num1,stack[-1])>1 :\\n                    x = math.lcm(num1,stack[-1])\\n                    stack.pop()\\n                    if stack :\\n                        num1 = x\\n                    else:\\n                        break\\n                stack.append(x)\\n            else:\\n                stack.append(nums[i])\\n                \\n        return stack\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n         \\n        stack = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            \\n            if math.gcd(stack[-1], nums[i]) > 1 :\\n                num1 = nums[i]\\n                \\n                while math.gcd(num1,stack[-1])>1 :\\n                    x = math.lcm(num1,stack[-1])\\n                    stack.pop()\\n                    if stack :\\n                        num1 = x\\n                    else:\\n                        break\\n                stack.append(x)\\n            else:\\n                stack.append(nums[i])\\n                \\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830943,
                "title": "c-easiest-solution-12-lines-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> dq;int n=nums.size();  \\n        for(int i=0;i<n;i++)\\n        { dq.push_back(nums[i]);\\n           while(dq.size()>1)\\n           {\\n            int a=dq.back();int b=dq[dq.size()-2];\\n            if(gcd(a,b)>1)\\n             {   \\n                dq.pop_back();\\n                dq.pop_back();\\n                dq.push_back(lcm(a,b));\\n             } \\n             else\\n\\t\\t\\t break;\\n           }\\n        }\\n        return dq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> dq;int n=nums.size();  \\n        for(int i=0;i<n;i++)\\n        { dq.push_back(nums[i]);\\n           while(dq.size()>1)\\n           {\\n            int a=dq.back();int b=dq[dq.size()-2];\\n            if(gcd(a,b)>1)\\n             {   \\n                dq.pop_back();\\n                dq.pop_back();\\n                dq.push_back(lcm(a,b));\\n             } \\n             else\\n\\t\\t\\t break;\\n           }\\n        }\\n        return dq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830696,
                "title": "one-pass-with-stack-97-speed",
                "content": "![image](https://assets.leetcode.com/users/images/c0224dda-d8cc-4e0a-b4ed-32dd72da5a86_1646734026.5282936.png)\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for n in nums:\\n            if not stack:\\n                stack.append(n)\\n            else:\\n                last_gcd = gcd(stack[-1], n)\\n                while last_gcd > 1:\\n                    stack[-1] *= n\\n                    stack[-1] //= last_gcd\\n                    if len(stack) > 1:\\n                        n = stack.pop()\\n                        last_gcd = gcd(stack[-1], n)\\n                    else:\\n                        break\\n                else:\\n                    stack.append(n)\\n        return stack\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for n in nums:\\n            if not stack:\\n                stack.append(n)\\n            else:\\n                last_gcd = gcd(stack[-1], n)\\n                while last_gcd > 1:\\n                    stack[-1] *= n\\n                    stack[-1] //= last_gcd\\n                    if len(stack) > 1:\\n                        n = stack.pop()\\n                        last_gcd = gcd(stack[-1], n)\\n                    else:\\n                        break\\n                else:\\n                    stack.append(n)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830605,
                "title": "c-stack-solution",
                "content": "\\tvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            \\n            int curr = nums[i];\\n            \\n            while(st.empty() == false) {\\n                \\n                int gcd = __gcd(curr, st.top());\\n                if(gcd > 1) {\\n                    int lcm = (curr / gcd) * st.top();\\n                    curr = lcm;\\n                    st.pop();\\n                }\\n                else\\n                    break;\\n            }\\n            \\n            st.push(curr);\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(!st.empty()) {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Stack"
                ],
                "code": "\\tvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            \\n            int curr = nums[i];\\n            \\n            while(st.empty() == false) {\\n                \\n                int gcd = __gcd(curr, st.top());\\n                if(gcd > 1) {\\n                    int lcm = (curr / gcd) * st.top();\\n                    curr = lcm;\\n                    st.pop();\\n                }\\n                else\\n                    break;\\n            }\\n            \\n            st.push(curr);\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(!st.empty()) {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1829210,
                "title": "doubly-linked-list",
                "content": "We are trying to replace a pair of number if the gcd is greater than 1. And while we reduce a pair of number into one, I guess using doubly linked list can reduce the cost of `delete` to `O(1)` .\\n\\n```\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def gcd(x,y):\\n            while True:\\n                if 0 == x:\\n                    return y\\n                elif 0 == y:\\n                    return x\\n                if x > y:\\n                    x = x%y\\n                else:\\n                    y = y%x\\n            return None\\n        \\n        head = LL(nums[0])\\n        curr = head\\n        N = len(nums)\\n        for i in range(1,N):\\n            curr = curr.append(nums[i])\\n            \\n        tail = curr\\n        while curr.fr is not None:\\n\\n            # get 2 numbers\\n            x,y = curr.fr.val,curr.val\\n            xgcd = gcd(x,y)\\n            if xgcd != 1: # they are coprime\\n                prev = curr.fr\\n                prev.val = (x*y)//xgcd\\n                curr.drop()\\n                if prev.to:\\n                    curr = prev.to\\n                else:\\n                    curr = prev\\n            else:\\n                curr = curr.fr\\n                \\n        result = []\\n        while curr:\\n            result.append(curr.val)\\n            curr = curr.to\\n        return result\\n```\\n\\nHere is the linked list I used.\\n\\n```\\nclass LL:\\n    __slots__ = [\\'val\\',\\'fr\\',\\'to\\']\\n    def __init__(self, given:int =0):\\n        self.val = given\\n        self.to = None\\n        self.fr = None\\n        \\n    def append(self, x):\\n        self.to = LL(x)\\n        self.to.fr = self\\n        return self.to\\n\\n    def drop(self) -> None:\\n        if self.fr is not None:\\n            self.fr.to = self.to\\n        if self.to is not None:\\n            self.to.fr = self.fr\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def gcd(x,y):\\n            while True:\\n                if 0 == x:\\n                    return y\\n                elif 0 == y:\\n                    return x\\n                if x > y:\\n                    x = x%y\\n                else:\\n                    y = y%x\\n            return None\\n        \\n        head = LL(nums[0])\\n        curr = head\\n        N = len(nums)\\n        for i in range(1,N):\\n            curr = curr.append(nums[i])\\n            \\n        tail = curr\\n        while curr.fr is not None:\\n\\n            # get 2 numbers\\n            x,y = curr.fr.val,curr.val\\n            xgcd = gcd(x,y)\\n            if xgcd != 1: # they are coprime\\n                prev = curr.fr\\n                prev.val = (x*y)//xgcd\\n                curr.drop()\\n                if prev.to:\\n                    curr = prev.to\\n                else:\\n                    curr = prev\\n            else:\\n                curr = curr.fr\\n                \\n        result = []\\n        while curr:\\n            result.append(curr.val)\\n            curr = curr.to\\n        return result\\n```\n```\\nclass LL:\\n    __slots__ = [\\'val\\',\\'fr\\',\\'to\\']\\n    def __init__(self, given:int =0):\\n        self.val = given\\n        self.to = None\\n        self.fr = None\\n        \\n    def append(self, x):\\n        self.to = LL(x)\\n        self.to.fr = self\\n        return self.to\\n\\n    def drop(self) -> None:\\n        if self.fr is not None:\\n            self.fr.to = self.to\\n        if self.to is not None:\\n            self.to.fr = self.fr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828494,
                "title": "python-stack",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        # res -> stack that keep track the left value\\n        res = []\\n        @functools.lru_cache(maxsize = None)\\n        def gcd(a,b):\\n            if a < b: a,b = b,a\\n            while a % b:\\n                a,b = b,a%b\\n            return b \\n        for n in nums:\\n            # if current value and left value are non-coprime, replace current value with their LCM\\n            while res and gcd(res[-1],n) != 1:\\n                left = res.pop()\\n                d = gcd(left,n)\\n                n = left*n//d\\n            res.append(n)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        # res -> stack that keep track the left value\\n        res = []\\n        @functools.lru_cache(maxsize = None)\\n        def gcd(a,b):\\n            if a < b: a,b = b,a\\n            while a % b:\\n                a,b = b,a%b\\n            return b \\n        for n in nums:\\n            # if current value and left value are non-coprime, replace current value with their LCM\\n            while res and gcd(res[-1],n) != 1:\\n                left = res.pop()\\n                d = gcd(left,n)\\n                n = left*n//d\\n            res.append(n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828265,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> st;\\n        for (int i = 0; i < n; i++) {\\n            int last = nums[i];\\n            while(!st.empty() && __gcd(last, st.back()) > 1) {\\n                last = ((long long) last * st.back()) / __gcd(last, st.back());\\n                st.pop_back();\\n            }\\n            st.push_back(last);\\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> st;\\n        for (int i = 0; i < n; i++) {\\n            int last = nums[i];\\n            while(!st.empty() && __gcd(last, st.back()) > 1) {\\n                last = ((long long) last * st.back()) / __gcd(last, st.back());\\n                st.pop_back();\\n            }\\n            st.push_back(last);\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827920,
                "title": "python-o-n",
                "content": "1. The problem statement itself states that the resulting array is the same regardless of the order of the operations. We should leverage this observation.\\n2. Therefore, we can consider elements one by one and operate as soon as it becomes available. Convince yourself that the operation will be applied to the last two elements. \\n3. Therefore we can use a stack to keep track of the resulting array, adding elements one by one, and merging when possible.\\n\\n```python\\nclass Solution:\\n    def replaceNonCoprimes(self, array):\\n        compressed = []\\n        for element in array:\\n            while compressed and gcd(compressed[-1], element) > 1:\\n                element = lcm(compressed[-1], element)\\n                compressed.pop()\\n            compressed.append(element)\\n        return compressed\\n```\\n\\n0. This problem feels like Medium instead, as only a concept of a stack is used. Besides, the most crucial observation is stated in the problem itself, making it rather trivial.",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def replaceNonCoprimes(self, array):\\n        compressed = []\\n        for element in array:\\n            while compressed and gcd(compressed[-1], element) > 1:\\n                element = lcm(compressed[-1], element)\\n                compressed.pop()\\n            compressed.append(element)\\n        return compressed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827573,
                "title": "c-concise-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        vector<int> res;\\n        while (i < n) {\\n            int cur = nums[i];\\n            int j = i + 1;\\n            while (j < n and gcd(cur, nums[j]) > 1) {\\n                cur = lcm(cur, nums[j]);\\n                j++;\\n            }\\n            i = j;\\n            while (res.size() and gcd(cur, res.back()) > 1) {\\n                cur = lcm(cur, res.back());\\n                res.pop_back();\\n            }\\n            res.emplace_back(cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        vector<int> res;\\n        while (i < n) {\\n            int cur = nums[i];\\n            int j = i + 1;\\n            while (j < n and gcd(cur, nums[j]) > 1) {\\n                cur = lcm(cur, nums[j]);\\n                j++;\\n            }\\n            i = j;\\n            while (res.size() and gcd(cur, res.back()) > 1) {\\n                cur = lcm(cur, res.back());\\n                res.pop_back();\\n            }\\n            res.emplace_back(cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827227,
                "title": "kotlin-solution-with-arraylist",
                "content": "```\\nclass Solution {\\n    fun replaceNonCoprimes(nums: IntArray): List<Int> {\\n        \\n        var resultList = mutableListOf<Int>()\\n        \\n        for(num in nums) {\\n            var newNum = num\\n            while(true) {\\n                val last = if(resultList.isEmpty()) 1 else resultList.get(resultList.size-1)\\n                val gcd = getGCD(last, newNum)\\n                if(gcd == 1) break\\n                newNum = newNum * (last / gcd)\\n                resultList.removeAt(resultList.size-1)\\n            }\\n            resultList.add(newNum)\\n        }\\n        \\n        return resultList\\n    }\\n    \\n    private fun getGCD(x: Int, y: Int): Int {    // Copied from lee215\\n        \\n        return if (y>0) getGCD(y, x%y) else x\\n    }\\n}",
                "solutionTags": [
                    "Kotlin",
                    "Array"
                ],
                "code": "class Solution {\\n    fun replaceNonCoprimes(nums: IntArray): List<Int> {\\n        \\n        var resultList = mutableListOf<Int>()\\n        \\n        for(num in nums) {\\n            var newNum = num\\n            while(true) {\\n                val last = if(resultList.isEmpty()) 1 else resultList.get(resultList.size-1)\\n                val gcd = getGCD(last, newNum)\\n                if(gcd == 1) break\\n                newNum = newNum * (last / gcd)\\n                resultList.removeAt(resultList.size-1)\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1827193,
                "title": "63-ms-faster-than-100-00-java-solution-with-detailed-comment",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length;\\n\\t\\t// Use linkedlist as stack like data structure and operator at the tail of list\\n        LinkedList<Integer> list = new LinkedList<>(); \\n        list.add(nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            int a = list.getLast();\\n            int b = nums[i];\\n            if (b > 1 && a == b) {\\n                continue;\\n            }\\n            \\n            int gcd = gcd(a, b);\\n            if (gcd == 1) { \\n                //coprime: append b\\n                list.add(b);\\n            } else { \\n                //non-coprime: replace last with lcm\\n                list.removeLast();\\n                int lcm = (int) ((a * (long) b) / gcd);\\n                \\n                //track back if new last and lcm are non-coprimes \\n                while (!list.isEmpty()) {\\n                    gcd = gcd(list.getLast(), lcm);\\n                    if (gcd == 1) {\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t //remove last and update lcm\\n                    lcm = (int)((list.removeLast() * (long) lcm) / gcd);\\n                }\\n                \\n                list.add(lcm);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (a < b) \\n            return gcd(b, a);\\n        else if (a % b == 0) {\\n            return b;\\n        } else {\\n            return gcd(b, a % b);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length;\\n\\t\\t// Use linkedlist as stack like data structure and operator at the tail of list\\n        LinkedList<Integer> list = new LinkedList<>(); \\n        list.add(nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            int a = list.getLast();\\n            int b = nums[i];\\n            if (b > 1 && a == b) {\\n                continue;\\n            }\\n            \\n            int gcd = gcd(a, b);\\n            if (gcd == 1) { \\n                //coprime: append b\\n                list.add(b);\\n            } else { \\n                //non-coprime: replace last with lcm\\n                list.removeLast();\\n                int lcm = (int) ((a * (long) b) / gcd);\\n                \\n                //track back if new last and lcm are non-coprimes \\n                while (!list.isEmpty()) {\\n                    gcd = gcd(list.getLast(), lcm);\\n                    if (gcd == 1) {\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t //remove last and update lcm\\n                    lcm = (int)((list.removeLast() * (long) lcm) / gcd);\\n                }\\n                \\n                list.add(lcm);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (a < b) \\n            return gcd(b, a);\\n        else if (a % b == 0) {\\n            return b;\\n        } else {\\n            return gcd(b, a % b);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826822,
                "title": "doubly-linked-list-solution",
                "content": "class Solution {\\npublic:\\n    struct List{\\n         List * next;\\n        List *prev;\\n        long long val;\\n        List(long long val1){\\n            val=val1;\\n            next=NULL;\\n            prev=NULL;\\n        }\\n    };\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> v;\\n       List * head=NULL;\\n        List *p=head;\\n        List *previous=NULL;\\n        for(int i=0;i<nums.size();i++){\\n            if(head==NULL){\\n                head= new List(nums[i]);\\n                p=head;\\n            }else{\\n                previous=p;\\n                p->next=new List(nums[i]);\\n                p=p->next;\\n                p->prev=previous;\\n            }\\n        }\\n        List *q=head;\\n        while(q->next!=NULL){\\n            if(gcd(q->val,q->next->val)>1){\\n                q->next->val=(q->val*q->next->val)/gcd(q->val,q->next->val);\\n                if(q->prev==NULL){\\n                    head=head->next;\\n                    head->prev=NULL;\\n                    q=head;\\n                }else{\\n                    q->prev->next=q->next;\\n                    q->next->prev=q->prev;\\n                    q=q->prev;\\n                }\\n            }else{\\n                q=q->next;\\n            }\\n        }\\n       while(head!=NULL){\\n           v.push_back(head->val);\\n           head=head->next;\\n       }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    struct List{\\n         List * next;\\n        List *prev;\\n        long long val;\\n        List(long long val1){\\n            val=val1;\\n            next=NULL;\\n            prev=NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1826401,
                "title": "replace-non-coprime-numbers-in-array-please-help-understand-where-i-have-gone-wrong-in-my-solution",
                "content": "I have done the below code, but i \\'m getting a response for one particular input as wrong result. I am not sure where I am making any mistake. Could someone please help me to understand where I have gone wrong in my solution? \\n\\nHere is the response I got and the standard output from my program.\\nInput: [287,41,49,287,899,23,23,20677,5,825]\\nOutput: [2009,899,20677,825]\\nExpected: [2009,20677,825]\\n\\nStandard Output:\\ni=0;j=1\\nnums[0]=287;nums[1]=41\\ngcd= 41\\nlcm= 287\\npopping 0 element from nums\\n[41, 49, 287, 899, 23, 23, 20677, 5, 825]\\npopping 1 element from nums\\ninserting 287 at 0 position\\n[287, 49, 287, 899, 23, 23, 20677, 5, 825]\\ni=0;j=1\\nnums[0]=287;nums[1]=49\\ngcd= 7\\nlcm= 2009\\npopping 0 element from nums\\n[49, 287, 899, 23, 23, 20677, 5, 825]\\npopping 1 element from nums\\ninserting 2009 at 0 position\\n[2009, 287, 899, 23, 23, 20677, 5, 825]\\ni=0;j=1\\nnums[0]=2009;nums[1]=287\\ngcd= 287\\nlcm= 2009\\npopping 0 element from nums\\n[287, 899, 23, 23, 20677, 5, 825]\\npopping 1 element from nums\\ninserting 2009 at 0 position\\n[2009, 899, 23, 23, 20677, 5, 825]\\ni=0;j=1\\nnums[0]=2009;nums[1]=899\\ngcd= 1\\ni=1;j=2\\nnums[1]=899;nums[2]=23\\ngcd= 1\\ni=2;j=3\\nnums[2]=23;nums[3]=23\\ngcd= 23\\nlcm= 23\\npopping 2 element from nums\\n[2009, 899, 23, 20677, 5, 825]\\npopping 3 element from nums\\ninserting 23 at 2 position\\n[2009, 899, 23, 20677, 5, 825]\\ni=2;j=3\\nnums[2]=23;nums[3]=20677\\ngcd= 23\\nlcm= 20677\\npopping 2 element from nums\\n[2009, 899, 20677, 5, 825]\\npopping 3 element from nums\\ninserting 20677 at 2 position\\n[2009, 899, 20677, 5, 825]\\ni=2;j=3\\nnums[2]=20677;nums[3]=5\\ngcd= 1\\ni=3;j=4\\nnums[3]=5;nums[4]=825\\ngcd= 5\\nlcm= 825\\npopping 3 element from nums\\n[2009, 899, 20677, 825]\\npopping 4 element from nums\\ninserting 825 at 3 position\\n[2009, 899, 20677, 825]\\ni=3;j=4\\n\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        l=len(nums)\\n        if l < 2:\\n            return nums\\n        if l==2:\\n            num1=nums[0]\\n            num2=nums[1]\\n            if num1==1 or num2==1:\\n                return nums\\n            gcd=math.gcd(num1,num2)\\n            if gcd==1:\\n                return nums\\n            else:\\n\\t\\t\\t    lcm=(num1*num2)/gcd\\n                return [lcm]\\n        if l > 2:\\n                l=len(nums)\\n                i=0\\n                j=1\\n                while True:\\n                    print(\"i=\"+str(i)+\";j=\"+str(j))\\n                    if i==l or j==l:\\n                        break\\n                    num1=nums[i]\\n                    num2=nums[j]\\n                    print(\"nums[\"+str(i)+\"]=\"+str(num1)+\";nums[\"+str(j)+\"]=\"+str(num2))\\n                    gcd=math.gcd(num1,num2)\\n                    print(\"gcd=\",str(gcd))\\n                    if gcd==1:\\n                        i=i+1\\n                        j=j+1\\n                        continue\\n                    lcm=int((num1*num2)/gcd)\\n                    print(\"lcm=\",str(lcm))\\n                    print(\"popping \"+str(i)+\" element from nums\")\\n                    nums.pop(i)\\n                    print(nums)\\n                    print(\"popping \"+str(j)+\" element from nums\")\\n                    nums.pop(i)\\n                    print(\"inserting \"+str(lcm)+\" at \"+str(i)+\" position\")\\n                    nums.insert(i,lcm)\\n                    print(nums)\\n                    l=len(nums)\\n                return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        l=len(nums)\\n        if l < 2:\\n            return nums\\n        if l==2:\\n            num1=nums[0]\\n            num2=nums[1]\\n            if num1==1 or num2==1:\\n                return nums\\n            gcd=math.gcd(num1,num2)\\n            if gcd==1:\\n                return nums\\n            else:\\n\\t\\t\\t    lcm=(num1*num2)/gcd\\n                return [lcm]\\n        if l > 2:\\n                l=len(nums)\\n                i=0\\n                j=1\\n                while True:\\n                    print(\"i=\"+str(i)+\";j=\"+str(j))\\n                    if i==l or j==l:\\n                        break\\n                    num1=nums[i]\\n                    num2=nums[j]\\n                    print(\"nums[\"+str(i)+\"]=\"+str(num1)+\";nums[\"+str(j)+\"]=\"+str(num2))\\n                    gcd=math.gcd(num1,num2)\\n                    print(\"gcd=\",str(gcd))\\n                    if gcd==1:\\n                        i=i+1\\n                        j=j+1\\n                        continue\\n                    lcm=int((num1*num2)/gcd)\\n                    print(\"lcm=\",str(lcm))\\n                    print(\"popping \"+str(i)+\" element from nums\")\\n                    nums.pop(i)\\n                    print(nums)\\n                    print(\"popping \"+str(j)+\" element from nums\")\\n                    nums.pop(i)\\n                    print(\"inserting \"+str(lcm)+\" at \"+str(i)+\" position\")\\n                    nums.insert(i,lcm)\\n                    print(nums)\\n                    l=len(nums)\\n                return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826236,
                "title": "java-o-nlog-max-time-o-n-space-stack",
                "content": "Let\\'s understand this with an example,\\n[2, 3, 2, 3, 6, 1, 6, 3, 2, 3, 2]\\n\\nI. If a number is not coprime with last result, we just add it to the stack.\\nII. If it\\'s coprime with it, we obtain a new result (LCM of both) and pop the preceding result and we continue this process until we reach the first condition or stack becomes empty.\\n\\n1. We start with 2 in stack.\\n2. GCD(2, 3) = 1, PUSH 3.\\n3. Similarly, PUSH 2 -> PUSH 3.\\n4. GCD(6, 3) = 3 != 1  => POP  and newResult = LCM(6, 3) = 6\\n\\t\\t Continue checking for coprime with stack top\\n\\t     GCD(6, 2) = 2 != 1 => POP , newResult = LCM(6, 2) = 6\\n\\t\\t  ... Finally we have empty Stack. So, PUSH 6 (newResult).\\n5. GCD(6, 1) = 1, PUSH 1.\\n6. GCD(1, 6) = 1. PUSH 6.\\n7. GCD(6, 3) = 3 != 1 => POP  and newResult = LCM(6, 3) = 6\\n\\t\\tContinue checking for coprime with stack top\\n\\t\\tGCD(6, 1) = 1 => PUSH 6 (newResult).\\n8. At the end, we have our result stored in stack.\\n\\nComplexity : \\n\\tWe iterate through each element in the array. When while runs, it reduces the size of stack and we convert multiple values into just one (i.e. LCM), so a value gets processed only once. So, nested loop doesn\\'t make it quadratic solution.\\n\\tTime Comp. : O(nlogm) ( logm to find GCD where m = Maximum in nums)\\n\\tAux. Space   :  O(n)  (For Stack)\\n\\n[Solution can be modified to store result values directly in result. This will reduce Auxiliary Space to O(1) and optimize the solution further.]\\n\\n![image](https://assets.leetcode.com/users/images/8018a7d3-d440-4317-97c5-4a6464fafcf9_1646591950.6937635.png)\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int len = nums.length;\\n\\t\\t\\n        Stack<Integer> values = new Stack<>();\\n        \\n        for (int i = 0; i < len; i++) {\\n            int curr = nums[i];\\n            \\n            if (values.isEmpty())\\n                values.push(curr);\\n            else {\\n                while (true) {\\n                    if (values.isEmpty()) {\\n                        values.push(curr);\\n                        break;\\n                    }\\n                    \\n                    int gcd = gcd(curr, values.peek());\\n                    if (gcd == 1) {\\n                        values.push(curr);\\n                        break;\\n                    }\\n                    else {\\n                        int top = values.pop();\\n                        curr = lcm(curr, top);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int resultLength = values.size();\\n        \\n        for (int i = 0; i < resultLength; i++) {\\n            result.add(values.pop());\\n        }\\n        \\n        int low = 0;\\n        int high = resultLength - 1;\\n        \\n        while (low < high) {\\n            int temp = result.get(low);\\n            result.set(low++, result.get(high));\\n            result.set(high--, temp);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int gcd(long a, long b) {\\n        if (b > a) \\n            return gcd(b, a);\\n        \\n        while (b > 0) {\\n            long temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        \\n        return (int) a;\\n    }\\n    \\n    private int lcm(long a, long b) {\\n        long prod = a * b;\\n        long gcd = gcd(a, b);\\n        \\n        return (int) (prod / gcd);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int len = nums.length;\\n\\t\\t\\n        Stack<Integer> values = new Stack<>();\\n        \\n        for (int i = 0; i < len; i++) {\\n            int curr = nums[i];\\n            \\n            if (values.isEmpty())\\n                values.push(curr);\\n            else {\\n                while (true) {\\n                    if (values.isEmpty()) {\\n                        values.push(curr);\\n                        break;\\n                    }\\n                    \\n                    int gcd = gcd(curr, values.peek());\\n                    if (gcd == 1) {\\n                        values.push(curr);\\n                        break;\\n                    }\\n                    else {\\n                        int top = values.pop();\\n                        curr = lcm(curr, top);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int resultLength = values.size();\\n        \\n        for (int i = 0; i < resultLength; i++) {\\n            result.add(values.pop());\\n        }\\n        \\n        int low = 0;\\n        int high = resultLength - 1;\\n        \\n        while (low < high) {\\n            int temp = result.get(low);\\n            result.set(low++, result.get(high));\\n            result.set(high--, temp);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int gcd(long a, long b) {\\n        if (b > a) \\n            return gcd(b, a);\\n        \\n        while (b > 0) {\\n            long temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        \\n        return (int) a;\\n    }\\n    \\n    private int lcm(long a, long b) {\\n        long prod = a * b;\\n        long gcd = gcd(a, b);\\n        \\n        return (int) (prod / gcd);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826178,
                "title": "java-stack-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        LinkedList<Integer> li=new LinkedList<>();\\n        for(int val:nums){\\n           while(true){\\n               int last=li.isEmpty()?1:li.getLast();\\n               int g=gcd(last,val);\\n               if(g==1){\\n                   break;\\n               }\\n               li.removeLast();\\n               val*=last/g;\\n           }\\n            li.add(val);\\n        }\\n        \\n        return li;\\n        \\n    }\\n    \\n     public int gcd(int a,int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        LinkedList<Integer> li=new LinkedList<>();\\n        for(int val:nums){\\n           while(true){\\n               int last=li.isEmpty()?1:li.getLast();\\n               int g=gcd(last,val);\\n               if(g==1){\\n                   break;\\n               }\\n               li.removeLast();\\n               val*=last/g;\\n           }\\n            li.add(val);\\n        }\\n        \\n        return li;\\n        \\n    }\\n    \\n     public int gcd(int a,int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825915,
                "title": "python-stack",
                "content": "```\\nfrom math import gcd\\nclass Solution:         \\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        if len(nums) < 2:\\n            return nums\\n        \\n        stack = []\\n        \\n        for n in nums:\\n            stack.append(n)\\n            while len(stack)>1 and (gcd_:=math.gcd(stack[-1], stack[-2]))>1:\\n                last = stack.pop()\\n                stack[-1] = stack[-1]*last//gcd_\\n                \\n        return stack\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:         \\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        if len(nums) < 2:\\n            return nums\\n        \\n        stack = []\\n        \\n        for n in nums:\\n            stack.append(n)\\n            while len(stack)>1 and (gcd_:=math.gcd(stack[-1], stack[-2]))>1:\\n                last = stack.pop()\\n                stack[-1] = stack[-1]*last//gcd_\\n                \\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825679,
                "title": "java-linkedlist",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        LinkedList<Integer> ans= new LinkedList<>();\\n        for(int num:nums) ans.add(num);\\n\\n        for(ListIterator<Integer> it= ans.listIterator(); it.hasNext(); ){\\n            if(!it.hasPrevious()){\\n                it.next();\\n            }else{\\n                it.previous();\\n                int prev= it.next(), curr= it.next(), gcd= gcd(prev, curr);\\n                if(gcd>1){\\n                    it.previous(); \\n                    it.remove(); \\n                    it.previous(); \\n                    it.set((int)((long)prev*curr/gcd));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int gcd(int a, int b){\\n        for(int t; b!=0; t=b, b=a%b, a=t);\\n        return a;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        LinkedList<Integer> ans= new LinkedList<>();\\n        for(int num:nums) ans.add(num);\\n\\n        for(ListIterator<Integer> it= ans.listIterator(); it.hasNext(); ){\\n            if(!it.hasPrevious()){\\n                it.next();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1825523,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        ans = [];n = len(nums)\\n        i = 0\\n        while(i<n):\\n            ans.append(nums[i])\\n            while(len(ans)>=2):\\n                second = ans.pop()\\n                first = ans.pop()\\n                greatCD = gcd(first,second)\\n                if(greatCD>1):\\n                    ans.append(int(first*second/greatCD))\\n                else:\\n                    ans.append(first)\\n                    ans.append(second)\\n                    break\\n            i+=1\\n        return ans\\ndef gcd(m,n):\\n    if(n==0):\\n        return m\\n    else:\\n        return gcd(n,m%n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        ans = [];n = len(nums)\\n        i = 0\\n        while(i<n):\\n            ans.append(nums[i])\\n            while(len(ans)>=2):\\n                second = ans.pop()\\n                first = ans.pop()\\n                greatCD = gcd(first,second)\\n                if(greatCD>1):\\n                    ans.append(int(first*second/greatCD))\\n                else:\\n                    ans.append(first)\\n                    ans.append(second)\\n                    break\\n            i+=1\\n        return ans\\ndef gcd(m,n):\\n    if(n==0):\\n        return m\\n    else:\\n        return gcd(n,m%n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825329,
                "title": "java-solution-using-stack-easy-to-understand",
                "content": "`Intuition`:\\n\\nIt can be observed that order of lcm doesn\\'t matter, but the real challenge is to calculate lcm efficeintly. One intution is to use recursion.\\n\\nLet\\'s say we have choosen any two indices `i` and `j`, where  `0<=i< j<n`  and `gcd(nums[i], nums[j) > 1`  then we can recurse to it\\'s left and right and when we found some indices let say.. `(k1< k2) < i and (l1 < l2) > j` to which can merge the result. Here, k1 and k2 are one of the pair indices to left of `i`. Similarly, l1 and l2 are one of the pair of indices in right of `j.`\\n\\nThis looks hard, but we can use a stack for same and simulate this process. Keep processing the element from left to right and once we find the proper pair of `i and j` , we can start popopping out the element from the stack(these elements were previously processed but they were not merged)\\n\\nWhile moving back to left or popping element from stack, we need to `re-calcluate ` `lcm` again and put it back to the stack. Check below code..\\n \\n```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList();\\n        int n = nums.length;\\n        Stack<Integer> st = new Stack();\\n        int lcm = nums[0];\\n        st.add(nums[0]);\\n        if(n ==1 ){\\n            res.add(nums[0]);\\n            return res;\\n        }\\n        for(int i = 1; i<n; i++){\\n            if( gcd( lcm, nums[i]) > 1){\\n                lcm = lcm(lcm, nums[i]);\\n                while(!st.isEmpty() && gcd(lcm, st.peek()) > 1){\\n                    lcm = lcm(lcm, st.peek());\\n                    st.pop();\\n                }\\n                st.push(lcm);\\n            }else{\\n                lcm = nums[i];\\n                st.push(nums[i]);\\n            }\\n        }\\n        Iterator<Integer> itr = st.iterator();\\n        while(itr.hasNext()){\\n            res.add(itr.next());\\n        }\\n        return res;\\n    }\\n    private int lcm(long a, long b)\\n    {\\n        return (int)((a * b) / gcd(a, b));\\n    }\\n    private int gcd(long a, long b){\\n        if(a == 0) return (int)b;\\n        return (int)gcd(b%a, a);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList();\\n        int n = nums.length;\\n        Stack<Integer> st = new Stack();\\n        int lcm = nums[0];\\n        st.add(nums[0]);\\n        if(n ==1 ){\\n            res.add(nums[0]);\\n            return res;\\n        }\\n        for(int i = 1; i<n; i++){\\n            if( gcd( lcm, nums[i]) > 1){\\n                lcm = lcm(lcm, nums[i]);\\n                while(!st.isEmpty() && gcd(lcm, st.peek()) > 1){\\n                    lcm = lcm(lcm, st.peek());\\n                    st.pop();\\n                }\\n                st.push(lcm);\\n            }else{\\n                lcm = nums[i];\\n                st.push(nums[i]);\\n            }\\n        }\\n        Iterator<Integer> itr = st.iterator();\\n        while(itr.hasNext()){\\n            res.add(itr.next());\\n        }\\n        return res;\\n    }\\n    private int lcm(long a, long b)\\n    {\\n        return (int)((a * b) / gcd(a, b));\\n    }\\n    private int gcd(long a, long b){\\n        if(a == 0) return (int)b;\\n        return (int)gcd(b%a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825085,
                "title": "go-stack-and-primes-gcd-lcm-primer",
                "content": "Following along the theme of primes from [Count Array Pairs Divisible by K](https://leetcode.com/problems/count-array-pairs-divisible-by-k/)...\\n\\nMany CP problems require knowledge about primes and basic number theory.\\n\\nAll positive integers consist of prime factors. The primes only have one factor: themselves.\\n\\nFor two numbers to be co-prime, they must contain no common prime factors.\\n\\nAn example can easily be created by combining some random prime factors, like \\n`7 * 9 = 63` and `3 * 5 = 15`. There are unique prime factors in both numbers, and so\\nthe two numbers are co-prime.\\n\\nSo what does the if `gcd(a,b) != 1 { a = lcm(a,b) }` operation do?\\n\\nGCD will find any common prime between the two numbers. \\nLCM will combine a with b (and all of its factors) then divide by the common prime.\\n\\nFor example, if `a = 3*5` and `b = 2*3`, then `gcd(a,b) = 3`. Simply multiplying `a*b`\\ngives `3*5*2*3`. LCM divides by the common prime, i.e.  \\n`a*b / gcd(a,b) = 3*5*2*3 / 3 = 3*5*2`.\\n\\nSo in a way when looking at the input, you could say that adjacent numbers\\nare linked if they share a common prime. LCM combines numbers that are linked.\\nFor there to be more than one final group in the output, there must exist\\nsegments within nums that have sets of globally unique primes.\\n\\n```go\\nfunc replaceNonCoprimes(nums []int) []int {\\n\\tgcd := func(a, b int) int {\\n\\t\\tfor b != 0 {\\n\\t\\t\\ta, b = b, a%b\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\tlcm := func(a, b int) int {\\n\\t\\treturn a * b / gcd(a, b)\\n\\t}\\n\\n\\tstack := make([]int, 0, len(nums))\\n\\tvar n int\\n\\n\\tfor _, num := range nums {\\n\\t\\tstack = append(stack, num)\\n\\t\\tn++\\n\\t\\tfor n > 1 && gcd(stack[n-2], stack[n-1]) != 1 {\\n\\t\\t\\tstack[n-2] = lcm(stack[n-2], stack[n-1])\\n\\t\\t\\tstack = stack[:n-1]\\n\\t\\t\\tn--\\n\\t\\t}\\n\\t}\\n\\treturn stack\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc replaceNonCoprimes(nums []int) []int {\\n\\tgcd := func(a, b int) int {\\n\\t\\tfor b != 0 {\\n\\t\\t\\ta, b = b, a%b\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\tlcm := func(a, b int) int {\\n\\t\\treturn a * b / gcd(a, b)\\n\\t}\\n\\n\\tstack := make([]int, 0, len(nums))\\n\\tvar n int\\n\\n\\tfor _, num := range nums {\\n\\t\\tstack = append(stack, num)\\n\\t\\tn++\\n\\t\\tfor n > 1 && gcd(stack[n-2], stack[n-1]) != 1 {\\n\\t\\t\\tstack[n-2] = lcm(stack[n-2], stack[n-1])\\n\\t\\t\\tstack = stack[:n-1]\\n\\t\\t\\tn--\\n\\t\\t}\\n\\t}\\n\\treturn stack\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825010,
                "title": "stack",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    int lcm(int a, int b)\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n\\n    vector<int> replaceNonCoprimes(vector<int> &nums)\\n    {\\n\\n        stack<int> st;\\n        int n = nums.size();\\n\\n        st.push(nums[0]);\\n        for (int i = 1; i < n; i++) {\\n            if (st.size() < 1) {\\n                st.push(nums[i]);\\n                continue;\\n            }\\n            st.push(nums[i]);\\n            while (st.size() >= 2) {\\n                int a = st.top();\\n                st.pop();\\n                int b = st.top();\\n                st.pop();\\n                if (gcd(a, b) > 1) {\\n\\n                    st.push(lcm(a, b));\\n                }\\n                else {\\n\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        while (!st.empty()) {\\n            // cout<<st.top()<<endl;\\n            ans.push_back(st.top());\\n\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1824935,
                "title": "java-simple-iterative-code-and-logic-with-explaination",
                "content": "```\\nclass Solution {\\n    // function to find gcd of a and b\\n    public static int gcd(int a,int b) {\\n        if(a==0) {\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0;i<nums.length-1;i++) {\\n            int hcf = gcd(nums[i],nums[i+1]);\\n            if(hcf==1) {\\n                while(ans.size()>0) {\\n                    int hcf1 = gcd(nums[i],ans.get(ans.size()-1));\\n                    if(hcf1==1) {\\n                        break;\\n                    } else {\\n                        nums[i]=(nums[i]/hcf1)*ans.get(ans.size()-1);\\n                        ans.remove(ans.size()-1);\\n                    }\\n                }\\n                ans.add(nums[i]);\\n            } else {\\n                nums[i+1]=(nums[i]/hcf)*nums[i+1];\\n                nums[i]=-1;\\n            }\\n        }\\n        if(nums[nums.length-1]!=-1) {\\n            while(ans.size()>0) {\\n                int hcf1 = gcd(nums[nums.length-1],ans.get(ans.size()-1));\\n                if(hcf1==1) {\\n                    break;\\n                } else {\\n                    nums[nums.length-1]=(nums[nums.length-1]/hcf1)*ans.get(ans.size()-1);\\n                    ans.remove(ans.size()-1);\\n                }\\n            }\\n            ans.add(nums[nums.length-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // function to find gcd of a and b\\n    public static int gcd(int a,int b) {\\n        if(a==0) {\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0;i<nums.length-1;i++) {\\n            int hcf = gcd(nums[i],nums[i+1]);\\n            if(hcf==1) {\\n                while(ans.size()>0) {\\n                    int hcf1 = gcd(nums[i],ans.get(ans.size()-1));\\n                    if(hcf1==1) {\\n                        break;\\n                    } else {\\n                        nums[i]=(nums[i]/hcf1)*ans.get(ans.size()-1);\\n                        ans.remove(ans.size()-1);\\n                    }\\n                }\\n                ans.add(nums[i]);\\n            } else {\\n                nums[i+1]=(nums[i]/hcf)*nums[i+1];\\n                nums[i]=-1;\\n            }\\n        }\\n        if(nums[nums.length-1]!=-1) {\\n            while(ans.size()>0) {\\n                int hcf1 = gcd(nums[nums.length-1],ans.get(ans.size()-1));\\n                if(hcf1==1) {\\n                    break;\\n                } else {\\n                    nums[nums.length-1]=(nums[nums.length-1]/hcf1)*ans.get(ans.size()-1);\\n                    ans.remove(ans.size()-1);\\n                }\\n            }\\n            ans.add(nums[nums.length-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824828,
                "title": "python-divide-and-conquer-with-explanation-o-n-log-n",
                "content": "We would like to divide [0, 1, 2, ... N - 1] into two subarrays. Let\\'s suppose that we have already handled two subarrays left and right. Now we can take a look at the left[-1] and right[0]. If their gcd is 1, then we are done. Otherwise, we can expand to left and to right until there is no lcm expansion.\\n\\nTC is O(n log n) because of master theorem. T(n) = 2 T(n/2) + O(n)\\n\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        @lru_cache(None)\\n        def gcd(a, b):\\n            if b == 0:\\n                return a\\n            return gcd(b, a % b)\\n        \\n        @lru_cache(None)\\n        def lcm(a, b):\\n            return a * b // gcd(a, b)\\n        \\n        def divide(l, r):\\n            if l == r:\\n                return [nums[l]]\\n            m = (l + r) // 2\\n            left, right = divide(l, m), divide(m + 1, r)\\n            if gcd(left[-1], right[0]) == 1:\\n                return left + right\\n            t = lcm(left[-1], right[0])\\n            li, ri = len(left) - 2, 1\\n            while li >= 0 or ri < len(right):\\n                if li >= 0 and gcd(t, left[li]) != 1:\\n                    t = lcm(t, left[li])\\n                    li -= 1\\n                elif ri < len(right) and gcd(t, right[ri]) != 1:\\n                    t = lcm(t, right[ri])\\n                    ri += 1\\n                else:\\n                    break\\n            return left[:li + 1] + [t] + right[ri:]\\n        return divide(0, len(nums) - 1)    \\n```",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        @lru_cache(None)\\n        def gcd(a, b):\\n            if b == 0:\\n                return a\\n            return gcd(b, a % b)\\n        \\n        @lru_cache(None)\\n        def lcm(a, b):\\n            return a * b // gcd(a, b)\\n        \\n        def divide(l, r):\\n            if l == r:\\n                return [nums[l]]\\n            m = (l + r) // 2\\n            left, right = divide(l, m), divide(m + 1, r)\\n            if gcd(left[-1], right[0]) == 1:\\n                return left + right\\n            t = lcm(left[-1], right[0])\\n            li, ri = len(left) - 2, 1\\n            while li >= 0 or ri < len(right):\\n                if li >= 0 and gcd(t, left[li]) != 1:\\n                    t = lcm(t, left[li])\\n                    li -= 1\\n                elif ri < len(right) and gcd(t, right[ri]) != 1:\\n                    t = lcm(t, right[ri])\\n                    ri += 1\\n                else:\\n                    break\\n            return left[:li + 1] + [t] + right[ri:]\\n        return divide(0, len(nums) - 1)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824818,
                "title": "easy-to-understand-java-code-using-stack",
                "content": "```    \\n\\tpublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (gcd(stack.peek(), nums[i]) > 1) {\\n                stack.push(lcm(stack.pop(), nums[i]));\\n                while (stack.size() >= 2) {\\n                    int a = stack.pop(), b = stack.pop();\\n                    if (gcd(a, b) > 1) {\\n                        stack.push(lcm(a, b));\\n                    } else {\\n                        stack.push(b);\\n                        stack.push(a);\\n                        break;\\n                    }\\n                }\\n            } else {\\n                stack.push(nums[i]);\\n            }\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            res.add(stack.pop());\\n        }\\n        Collections.reverse(res);\\n        \\n        return res;\\n    }\\n    \\n    private int lcm(int a, int b) {\\n        int min = Math.min(a, b);\\n        int max = Math.max(a, b);\\n        int res = max;\\n        \\n        while (res % min != 0) {\\n            res += max;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (a < b) {\\n            return gcd(b, a);\\n        }\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```    \\n\\tpublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (gcd(stack.peek(), nums[i]) > 1) {\\n                stack.push(lcm(stack.pop(), nums[i]));\\n                while (stack.size() >= 2) {\\n                    int a = stack.pop(), b = stack.pop();\\n                    if (gcd(a, b) > 1) {\\n                        stack.push(lcm(a, b));\\n                    } else {\\n                        stack.push(b);\\n                        stack.push(a);\\n                        break;\\n                    }\\n                }\\n            } else {\\n                stack.push(nums[i]);\\n            }\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            res.add(stack.pop());\\n        }\\n        Collections.reverse(res);\\n        \\n        return res;\\n    }\\n    \\n    private int lcm(int a, int b) {\\n        int min = Math.min(a, b);\\n        int max = Math.max(a, b);\\n        int res = max;\\n        \\n        while (res % min != 0) {\\n            res += max;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (a < b) {\\n            return gcd(b, a);\\n        }\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1824782,
                "title": "100-faster-c-different-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) \\n    {\\n      int n = nums.size();  \\n      vector<int> result;\\n      result.push_back(nums[0]);   \\n      for(int i =1; i < n; ++i)\\n      {\\n        int last = result.back();\\n        int g = __gcd(nums[i], last);\\n        if(g > 1)\\n        {\\n           result.pop_back();\\n           int lcm = static_cast<long long>((static_cast<long long>(nums[i])*last))/g; \\n           result.push_back(lcm);\\n           while(result.size() > 1)\\n           {\\n             int a = result.back();\\n             int b = result[result.size()-2];\\n             int g_ = __gcd(a, b);\\n             if(g_ > 1)\\n             {\\n               result.pop_back(); result.pop_back();   \\n               int lcm_ = static_cast<long long>((static_cast<long long>(a)*b))/g_;    \\n               result.push_back(lcm_);    \\n             }\\n             else\\n             {\\n               break;  \\n             }    \\n           }    \\n        }\\n        else\\n        {\\n          result.push_back(nums[i]);    \\n        }    \\n      }\\n      return result;  \\n        \\n    }      \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) \\n    {\\n      int n = nums.size();  \\n      vector<int> result;\\n      result.push_back(nums[0]);   \\n      for(int i =1; i < n; ++i)\\n      {\\n        int last = result.back();\\n        int g = __gcd(nums[i], last);\\n        if(g > 1)\\n        {\\n           result.pop_back();\\n           int lcm = static_cast<long long>((static_cast<long long>(nums[i])*last))/g; \\n           result.push_back(lcm);\\n           while(result.size() > 1)\\n           {\\n             int a = result.back();\\n             int b = result[result.size()-2];\\n             int g_ = __gcd(a, b);\\n             if(g_ > 1)\\n             {\\n               result.pop_back(); result.pop_back();   \\n               int lcm_ = static_cast<long long>((static_cast<long long>(a)*b))/g_;    \\n               result.push_back(lcm_);    \\n             }\\n             else\\n             {\\n               break;  \\n             }    \\n           }    \\n        }\\n        else\\n        {\\n          result.push_back(nums[i]);    \\n        }    \\n      }\\n      return result;  \\n        \\n    }      \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824724,
                "title": "simple-solution-in-java-100-faster-concise-code",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            res.add(nums[i]);\\n            \\n            while(res.size() >= 2){\\n                int top = res.get(res.size() - 1);\\n                int num = res.get(res.size() - 2);\\n                \\n                int gcdNum = findGCD(top, num);\\n                if(gcdNum > 1){\\n                    long lcm = (long) top * num / gcdNum;\\n                    res.remove(res.size()-1);\\n                    res.remove(res.size()-1);\\n                    res.add((int)lcm);\\n                }else break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int findGCD(int a, int b){\\n        return b != 0 ? findGCD(b, a%b) : a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            res.add(nums[i]);\\n            \\n            while(res.size() >= 2){\\n                int top = res.get(res.size() - 1);\\n                int num = res.get(res.size() - 2);\\n                \\n                int gcdNum = findGCD(top, num);\\n                if(gcdNum > 1){\\n                    long lcm = (long) top * num / gcdNum;\\n                    res.remove(res.size()-1);\\n                    res.remove(res.size()-1);\\n                    res.add((int)lcm);\\n                }else break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int findGCD(int a, int b){\\n        return b != 0 ? findGCD(b, a%b) : a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824674,
                "title": "monotonic-coprime-stack",
                "content": "Build a monotonic coprime stack.\\n\\nWhile non-coprime pairs in stack then update it until all the pairs in stack are coprime.\\n\\n``` py\\nclass Solution:\\n    def replaceNonCoprimes(self, A: List[int]) -> List[int]:\\n        def is_coprime(x, y): return gcd(x, y) == 1\\n        \\n        stk = []\\n        for x in A:\\n            while stk and not is_coprime(stk[-1], x):\\n                xx = lcm(stk.pop(), x)\\n                x = xx\\n            else: stk.append(x)\\n        return stk\\n```",
                "solutionTags": [
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "``` py\\nclass Solution:\\n    def replaceNonCoprimes(self, A: List[int]) -> List[int]:\\n        def is_coprime(x, y): return gcd(x, y) == 1\\n        \\n        stk = []\\n        for x in A:\\n            while stk and not is_coprime(stk[-1], x):\\n                xx = lcm(stk.pop(), x)\\n                x = xx\\n            else: stk.append(x)\\n        return stk\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824603,
                "title": "easy-c-code-beginner-level",
                "content": "\\n\\n```\\nclass Solution {\\n        long long int gcd(long long int a, long long int b)\\n         {\\n             if(b == 0)\\n                 return a;\\n             return gcd(b, a%b);\\n         }\\n        long long int lcm(long long int a, long long int b)\\n         {\\n             long long int x = a;\\n             long long int y = b;\\n             long long int temp,gcd;\\n              while (b != 0)  \\n            {  \\n            temp = b;  \\n            b = a % b;  \\n            a = temp;  \\n            }\\n             gcd = a;\\n            long long int xy = (x*y)/gcd;\\n             return xy;\\n         }\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>st;\\n        int i=0;\\n        int zx = 0;\\n        while(i < nums.size())\\n        {\\n            if(zx == 0)\\n            {\\n                zx = nums[i];\\n            }\\n            if(st.empty())\\n            {\\n                st.push(zx);\\n                zx = 0;\\n                i++;\\n            }\\n            else\\n            {\\n                int xy = gcd(zx,st.top());\\n                if(xy > 1)\\n                {\\n                    int temp = lcm(zx, st.top());\\n                    st.pop();\\n                    zx = temp;\\n                    // st.push(temp);\\n                    //i++;\\n                }\\n                else\\n                {\\n                    st.push(zx);\\n                    zx = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n        long long int gcd(long long int a, long long int b)\\n         {\\n             if(b == 0)\\n                 return a;\\n             return gcd(b, a%b);\\n         }\\n        long long int lcm(long long int a, long long int b)\\n         {\\n             long long int x = a;\\n             long long int y = b;\\n             long long int temp,gcd;\\n              while (b != 0)  \\n            {  \\n            temp = b;  \\n            b = a % b;  \\n            a = temp;  \\n            }\\n             gcd = a;\\n            long long int xy = (x*y)/gcd;\\n             return xy;\\n         }\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>st;\\n        int i=0;\\n        int zx = 0;\\n        while(i < nums.size())\\n        {\\n            if(zx == 0)\\n            {\\n                zx = nums[i];\\n            }\\n            if(st.empty())\\n            {\\n                st.push(zx);\\n                zx = 0;\\n                i++;\\n            }\\n            else\\n            {\\n                int xy = gcd(zx,st.top());\\n                if(xy > 1)\\n                {\\n                    int temp = lcm(zx, st.top());\\n                    st.pop();\\n                    zx = temp;\\n                    // st.push(temp);\\n                    //i++;\\n                }\\n                else\\n                {\\n                    st.push(zx);\\n                    zx = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824571,
                "title": "linked-list-and-merge-sort-type-divide-and-conquer-approach",
                "content": "**Stack/Linked List based approach**\\n```\\nclass Solution {\\n    private int gcd(int a, int b){\\n        if (a > b) return gcd(b,a);\\n        if (a == 0) return b;\\n        return gcd(b%a,a);\\n    }\\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n       LinkedList<Integer> linkedList = new LinkedList<>();\\n        for (int x : nums){\\n            int currLcm = x;\\n            while (!linkedList.isEmpty()){\\n                int g = gcd(linkedList.peekLast(), currLcm);\\n                if (g == 1) break;\\n                currLcm = (currLcm/g)*linkedList.removeLast();\\n            }\\n            linkedList.add(currLcm);\\n        }\\n        return linkedList;\\n    }\\n}\\n```\\n\\nAlthough the linkedList/Stack based solution is smaller in code, I found the divide and conquer approach more intuitive as it is very similar to merge sort.\\n\\n**Divide And Conquer approach**\\n1. Divide: Divide the list into two halves and solve each half recursively\\n2. Conquer: Merge the lists obtained from recursive calls.\\n\\n```\\n    private List<Integer> divideAndConquer(List<Integer> list){\\n        // base case\\n        if (list.size() <= 1) return list;\\n        \\n        // divide part\\n        int size = list.size();\\n        int mid = (size-1)/2;\\n        List<Integer> leftList = divideAndConquer(list.subList(0,mid+1));\\n        List<Integer> rightList = divideAndConquer(list.subList(mid+1, size));\\n        \\n        //conquer and return\\n        return conquer(leftList, rightList);\\n        \\n    }\\n```\\n\\n**Conquer implementation**\\n ```leftLast``` -> last element of leftList\\n```rightFirst``` -> first element of rightList\\nSince we already solved the left half and right half, new pairs can only be merged if ```leftLast``` and ```rightFirst``` are not coprimes.\\n ```if gcd(leftLast,rightFirst) != 1```  we compute their lcm. We scan the ```leftList``` backwards and ```rightList``` forward to check for more merges with this lcm and update the lcm as we scan.\\n We stop when the lcm is not updated or have exhausted the left and right pointers.\\n \\n\\n```\\n    private List<Integer> conquer(List<Integer> leftList, List<Integer> rightList){\\n        assert !leftList.isEmpty() && !rightList.isEmpty();\\n            \\n        int leftLast = leftList.get(leftList.size()-1);\\n        int rightFirst = rightList.get(0);\\n    \\n        List<Integer> mergedList = new ArrayList<>();\\n        if (gcd(leftLast,rightFirst) == 1){\\n            mergedList.addAll(leftList);\\n            mergedList.addAll(rightList);\\n            return mergedList;\\n        }\\n        \\n        \\n        int currLcm = lcm(leftLast,rightFirst);\\n        int leftPtr = leftList.size()-2;\\n        int rightPtr = 1;\\n        \\n        while (leftPtr >=  0 || rightPtr < rightList.size()){\\n            \\n           boolean isLcmUpdated = false;\\n           \\n            if (leftPtr >= 0 && gcd(leftList.get(leftPtr), currLcm) != 1){\\n              currLcm = lcm(currLcm, leftList.get(leftPtr));\\n              leftPtr--;\\n              isLcmUpdated = true;\\n           }\\n            \\n           if (rightPtr < rightList.size() && gcd(rightList.get(rightPtr), currLcm) != 1){\\n               currLcm = lcm(currLcm, rightList.get(rightPtr));\\n               rightPtr++;\\n               isLcmUpdated = true;\\n           }\\n           \\n           if (!isLcmUpdated) break;\\n        }\\n        \\n        // add everthing until the current position of leftPtr\\n        mergedList.addAll(leftList.subList(0, leftPtr+1));\\n        \\n        // add the lcm\\n        mergedList.add(currLcm);\\n        \\n        // add everything from and after the current position of rightPtr\\n        mergedList.addAll(rightList.subList(rightPtr, rightList.size()));\\n        \\n        return mergedList;\\n    }\\n```\\n\\n\\nTime Complexity:\\nThe recursive structure is very similar to merge sort namely,  Two recursive calls and O(n) work outside the recursive calls (For conquer Step) so the time complexity is O(nlogn)\\n\\n\\n**Full Divide And Conquer code for reference**\\n\\n```\\nclass Solution {\\n    private int gcd(int a, int b){\\n        if (a > b) return gcd(b,a);\\n        if (a == 0) return b;\\n        return gcd(b%a,a);\\n    }\\n    private int lcm(int a, int b){\\n        int g = gcd(a,b);\\n        return (a/g)*b;\\n    }\\n   \\n    \\n    private List<Integer> conquer(List<Integer> leftList, List<Integer> rightList){\\n        assert !leftList.isEmpty() && !rightList.isEmpty();\\n            \\n        int leftLast = leftList.get(leftList.size()-1);\\n        int rightFirst = rightList.get(0);\\n    \\n        List<Integer> mergedList = new ArrayList<>();\\n        if (gcd(leftLast,rightFirst) == 1){\\n            mergedList.addAll(leftList);\\n            mergedList.addAll(rightList);\\n            return mergedList;\\n        }\\n        \\n        \\n        int currLcm = lcm(leftLast,rightFirst);\\n        int leftPtr = leftList.size()-2;\\n        int rightPtr = 1;\\n        \\n        while (leftPtr >=  0 || rightPtr < rightList.size()){\\n            \\n           boolean isLcmUpdated = false;\\n           \\n            if (leftPtr >= 0 && gcd(leftList.get(leftPtr), currLcm) != 1){\\n              currLcm = lcm(currLcm, leftList.get(leftPtr));\\n              leftPtr--;\\n              isLcmUpdated = true;\\n           }\\n            \\n           if (rightPtr < rightList.size() && gcd(rightList.get(rightPtr), currLcm) != 1){\\n               currLcm = lcm(currLcm, rightList.get(rightPtr));\\n               rightPtr++;\\n               isLcmUpdated = true;\\n           }\\n           \\n           if (!isLcmUpdated) break;\\n        }\\n        \\n        // add everthing until the current position of leftPtr\\n        mergedList.addAll(leftList.subList(0, leftPtr+1));\\n        \\n        // add the lcm\\n        mergedList.add(currLcm);\\n        \\n        // add everything from and after the current position of rightPtr\\n        mergedList.addAll(rightList.subList(rightPtr, rightList.size()));\\n        \\n        return mergedList;\\n    }\\n    \\n    private List<Integer> divideAndConquer(List<Integer> list){\\n        // base case\\n        if (list.size() <= 1) return list;\\n        \\n        // divide part\\n        int size = list.size();\\n        int mid = (size-1)/2;\\n        List<Integer> leftList = divideAndConquer(list.subList(0,mid+1));\\n        List<Integer> rightList = divideAndConquer(list.subList(mid+1, size));\\n        \\n        //conquer and return\\n        return conquer(leftList, rightList);\\n        \\n    }\\n    \\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int x : nums) list.add(x);\\n        return divideAndConquer(list);\\n        \\n    }\\n}\\n```\\n\\t",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    private int gcd(int a, int b){\\n        if (a > b) return gcd(b,a);\\n        if (a == 0) return b;\\n        return gcd(b%a,a);\\n    }\\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n       LinkedList<Integer> linkedList = new LinkedList<>();\\n        for (int x : nums){\\n            int currLcm = x;\\n            while (!linkedList.isEmpty()){\\n                int g = gcd(linkedList.peekLast(), currLcm);\\n                if (g == 1) break;\\n                currLcm = (currLcm/g)*linkedList.removeLast();\\n            }\\n            linkedList.add(currLcm);\\n        }\\n        return linkedList;\\n    }\\n}\\n```\n```\\n    private List<Integer> divideAndConquer(List<Integer> list){\\n        // base case\\n        if (list.size() <= 1) return list;\\n        \\n        // divide part\\n        int size = list.size();\\n        int mid = (size-1)/2;\\n        List<Integer> leftList = divideAndConquer(list.subList(0,mid+1));\\n        List<Integer> rightList = divideAndConquer(list.subList(mid+1, size));\\n        \\n        //conquer and return\\n        return conquer(leftList, rightList);\\n        \\n    }\\n```\n```leftLast```\n```rightFirst```\n```leftLast```\n```rightFirst```\n```if gcd(leftLast,rightFirst) != 1```\n```leftList```\n```rightList```\n```\\n    private List<Integer> conquer(List<Integer> leftList, List<Integer> rightList){\\n        assert !leftList.isEmpty() && !rightList.isEmpty();\\n            \\n        int leftLast = leftList.get(leftList.size()-1);\\n        int rightFirst = rightList.get(0);\\n    \\n        List<Integer> mergedList = new ArrayList<>();\\n        if (gcd(leftLast,rightFirst) == 1){\\n            mergedList.addAll(leftList);\\n            mergedList.addAll(rightList);\\n            return mergedList;\\n        }\\n        \\n        \\n        int currLcm = lcm(leftLast,rightFirst);\\n        int leftPtr = leftList.size()-2;\\n        int rightPtr = 1;\\n        \\n        while (leftPtr >=  0 || rightPtr < rightList.size()){\\n            \\n           boolean isLcmUpdated = false;\\n           \\n            if (leftPtr >= 0 && gcd(leftList.get(leftPtr), currLcm) != 1){\\n              currLcm = lcm(currLcm, leftList.get(leftPtr));\\n              leftPtr--;\\n              isLcmUpdated = true;\\n           }\\n            \\n           if (rightPtr < rightList.size() && gcd(rightList.get(rightPtr), currLcm) != 1){\\n               currLcm = lcm(currLcm, rightList.get(rightPtr));\\n               rightPtr++;\\n               isLcmUpdated = true;\\n           }\\n           \\n           if (!isLcmUpdated) break;\\n        }\\n        \\n        // add everthing until the current position of leftPtr\\n        mergedList.addAll(leftList.subList(0, leftPtr+1));\\n        \\n        // add the lcm\\n        mergedList.add(currLcm);\\n        \\n        // add everything from and after the current position of rightPtr\\n        mergedList.addAll(rightList.subList(rightPtr, rightList.size()));\\n        \\n        return mergedList;\\n    }\\n```\n```\\nclass Solution {\\n    private int gcd(int a, int b){\\n        if (a > b) return gcd(b,a);\\n        if (a == 0) return b;\\n        return gcd(b%a,a);\\n    }\\n    private int lcm(int a, int b){\\n        int g = gcd(a,b);\\n        return (a/g)*b;\\n    }\\n   \\n    \\n    private List<Integer> conquer(List<Integer> leftList, List<Integer> rightList){\\n        assert !leftList.isEmpty() && !rightList.isEmpty();\\n            \\n        int leftLast = leftList.get(leftList.size()-1);\\n        int rightFirst = rightList.get(0);\\n    \\n        List<Integer> mergedList = new ArrayList<>();\\n        if (gcd(leftLast,rightFirst) == 1){\\n            mergedList.addAll(leftList);\\n            mergedList.addAll(rightList);\\n            return mergedList;\\n        }\\n        \\n        \\n        int currLcm = lcm(leftLast,rightFirst);\\n        int leftPtr = leftList.size()-2;\\n        int rightPtr = 1;\\n        \\n        while (leftPtr >=  0 || rightPtr < rightList.size()){\\n            \\n           boolean isLcmUpdated = false;\\n           \\n            if (leftPtr >= 0 && gcd(leftList.get(leftPtr), currLcm) != 1){\\n              currLcm = lcm(currLcm, leftList.get(leftPtr));\\n              leftPtr--;\\n              isLcmUpdated = true;\\n           }\\n            \\n           if (rightPtr < rightList.size() && gcd(rightList.get(rightPtr), currLcm) != 1){\\n               currLcm = lcm(currLcm, rightList.get(rightPtr));\\n               rightPtr++;\\n               isLcmUpdated = true;\\n           }\\n           \\n           if (!isLcmUpdated) break;\\n        }\\n        \\n        // add everthing until the current position of leftPtr\\n        mergedList.addAll(leftList.subList(0, leftPtr+1));\\n        \\n        // add the lcm\\n        mergedList.add(currLcm);\\n        \\n        // add everything from and after the current position of rightPtr\\n        mergedList.addAll(rightList.subList(rightPtr, rightList.size()));\\n        \\n        return mergedList;\\n    }\\n    \\n    private List<Integer> divideAndConquer(List<Integer> list){\\n        // base case\\n        if (list.size() <= 1) return list;\\n        \\n        // divide part\\n        int size = list.size();\\n        int mid = (size-1)/2;\\n        List<Integer> leftList = divideAndConquer(list.subList(0,mid+1));\\n        List<Integer> rightList = divideAndConquer(list.subList(mid+1, size));\\n        \\n        //conquer and return\\n        return conquer(leftList, rightList);\\n        \\n    }\\n    \\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int x : nums) list.add(x);\\n        return divideAndConquer(list);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824462,
                "title": "c-stack-implementation-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>ans;\\n        \\n        for(auto  i:nums)\\n        {\\n            ans.push_back(i);\\n            while(ans.size()>=2)\\n            {\\n                \\n                int n=ans.size();\\n                long long int p1=ans[n-1];\\n                long long int p2=ans[n-2];\\n                int k=__gcd(p1,p2);\\n                \\n                if(k==1)\\n                    break;\\n                \\n                ans.pop_back();\\n                ans.pop_back();\\n                \\n                int lcm=(p1*p2)/k;\\n                ans.push_back(lcm);\\n                \\n                //cout<<p1<<\" \"<<p2<<\" \"<<lcm<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>ans;\\n        \\n        for(auto  i:nums)\\n        {\\n            ans.push_back(i);\\n            while(ans.size()>=2)\\n            {\\n                \\n                int n=ans.size();\\n                long long int p1=ans[n-1];\\n                long long int p2=ans[n-2];\\n                int k=__gcd(p1,p2);\\n                \\n                if(k==1)\\n                    break;\\n                \\n                ans.pop_back();\\n                ans.pop_back();\\n                \\n                int lcm=(p1*p2)/k;\\n                ans.push_back(lcm);\\n                \\n                //cout<<p1<<\" \"<<p2<<\" \"<<lcm<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1824407,
                "title": "python-3-doubly-linked-list-explanation",
                "content": "### Explanation\\n- Pretty much brute force with help of Doubly Linked List \\n- Use LinkedList since remove from list is slow `O(N)`\\n- Btw, the stack solution is way better. Ignore this if you want a faster solution.\\n### Implementation\\n```\\nclass ListNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.prev = self.next = None\\n        \\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        prev = cur = root = ListNode(int(1e9+7))\\n        for num in nums:\\n            cur = ListNode(num)\\n            cur.prev = prev\\n            prev.next = cur\\n            prev = cur\\n        prev, cur = root.next, root.next.next\\n        while cur:\\n            tmp = gcd(cur.val, prev.val)\\n            if tmp > 1:    \\n                lcm_node = ListNode(cur.val * prev.val // tmp)\\n                prev.prev.next = lcm_node\\n                lcm_node.prev = prev.prev\\n                lcm_node.next = cur.next\\n                if cur.next:\\n                    cur.next.prev = lcm_node\\n                cur.prev = cur.next = prev.prev = prev.next = None    \\n                prev, cur = lcm_node.prev, lcm_node\\n            else:    \\n                head, prev, cur = prev, cur, cur.next\\n        ans, root = [], root.next\\n        while root:\\n            ans.append(root.val)\\n            root = root.next\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass ListNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.prev = self.next = None\\n        \\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        prev = cur = root = ListNode(int(1e9+7))\\n        for num in nums:\\n            cur = ListNode(num)\\n            cur.prev = prev\\n            prev.next = cur\\n            prev = cur\\n        prev, cur = root.next, root.next.next\\n        while cur:\\n            tmp = gcd(cur.val, prev.val)\\n            if tmp > 1:    \\n                lcm_node = ListNode(cur.val * prev.val // tmp)\\n                prev.prev.next = lcm_node\\n                lcm_node.prev = prev.prev\\n                lcm_node.next = cur.next\\n                if cur.next:\\n                    cur.next.prev = lcm_node\\n                cur.prev = cur.next = prev.prev = prev.next = None    \\n                prev, cur = lcm_node.prev, lcm_node\\n            else:    \\n                head, prev, cur = prev, cur, cur.next\\n        ans, root = [], root.next\\n        while root:\\n            ans.append(root.val)\\n            root = root.next\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824378,
                "title": "c-greedy-let-s-do-something-readable",
                "content": "The key point is you can merge adjacent non-co-prime as many as  as possible, in essence it\\'s an gready algorithm. \\n```\\n\\tvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for (auto i : nums) {\\n            res.push_back(i);\\n            while(res.size() > 1) {\\n                auto last = res.back();\\n                auto penultimate = res[res.size()-2];\\n                if (gcd(last,pre) > 1) {\\n                    res.pop_back();\\n                    res.pop_back();\\n                    res.push_back(lcm(last,penultimate));\\n                }\\n                else break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for (auto i : nums) {\\n            res.push_back(i);\\n            while(res.size() > 1) {\\n                auto last = res.back();\\n                auto penultimate = res[res.size()-2];\\n                if (gcd(last,pre) > 1) {\\n                    res.pop_back();\\n                    res.pop_back();\\n                    res.push_back(lcm(last,penultimate));\\n                }\\n                else break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824363,
                "title": "python-3-recursive-deque-solution",
                "content": "I feel like cheating doing it in Python, cuz we can import gcd and lcm from math.\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        from math import gcd, lcm\\n        l = collections.deque(nums)\\n        \\n        def proc(l, i):\\n            if i >= len(l):\\n                return\\n            if i + 1 < len(l):\\n                if gcd(l[i], l[i + 1]) > 1: # non-coprime\\n                    l[i] = lcm(l[i], l[i + 1])\\n                    del l[i + 1]\\n                    proc(l, max(0, i - 1))\\n                else:\\n                    proc(l, i + 1)\\n        \\n        proc(l, 0)\\n        \\n        return list(l)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        from math import gcd, lcm\\n        l = collections.deque(nums)\\n        \\n        def proc(l, i):\\n            if i >= len(l):\\n                return\\n            if i + 1 < len(l):\\n                if gcd(l[i], l[i + 1]) > 1: # non-coprime\\n                    l[i] = lcm(l[i], l[i + 1])\\n                    del l[i + 1]\\n                    proc(l, max(0, i - 1))\\n                else:\\n                    proc(l, i + 1)\\n        \\n        proc(l, 0)\\n        \\n        return list(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824359,
                "title": "c-69-71-cases-passing-getting-tle-can-anyone-optimise",
                "content": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int a,b;\\n        int flag=1;\\n        \\n        //flag indicates atleast one replacement is done, if not come out of loop\\n        while(flag){\\n            flag=0;\\n            \\n            a=0;\\n            //check where nums[a] is non zero and start from there\\n            while(!nums[a]) a++;\\n            //main logic\\n            for(int i=a+1;i<nums.size();i++){\\n                if(nums[i]>0){\\n                    b=i;\\n                    if(gcd(nums[a],nums[b])>1){\\n                        nums[b]=lcm(nums[b],nums[a]);\\n                        nums[a]=0;\\n                        flag=1;\\n                    }\\n                    a=b;\\n                }\\n            }\\n        }\\n        \\n        //storing in vector\\n        vector<int> vect;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                vect.push_back(nums[i]);\\n            }\\n            \\n        }\\n        \\n        return vect;\\n        \\n           \\n        \\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int a,b;\\n        int flag=1;\\n        \\n        //flag indicates atleast one replacement is done, if not come out of loop\\n        while(flag){\\n            flag=0;\\n            \\n            a=0;\\n            //check where nums[a] is non zero and start from there\\n            while(!nums[a]) a++;\\n            //main logic\\n            for(int i=a+1;i<nums.size();i++){\\n                if(nums[i]>0){\\n                    b=i;\\n                    if(gcd(nums[a],nums[b])>1){\\n                        nums[b]=lcm(nums[b],nums[a]);\\n                        nums[a]=0;\\n                        flag=1;\\n                    }\\n                    a=b;\\n                }\\n            }\\n        }\\n        \\n        //storing in vector\\n        vector<int> vect;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                vect.push_back(nums[i]);\\n            }\\n            \\n        }\\n        \\n        return vect;\\n        \\n           \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824358,
                "title": "use-of-stack-cpp-easy-to-understand",
                "content": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        if(nums.size()<2)\\n            return nums;\\n        vector<int>v;\\n        stack<int>st;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n            while(!st.empty() and __gcd(st.top(),nums[i])>1)\\n            {\\n                nums[i]=lcm(st.top(),nums[i]);\\n                \\n                st.pop();\\n                \\n                \\n            }\\n            \\n            st.push(nums[i]);\\n                 \\n        }\\n        \\n        while(!st.empty())\\n        {\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(v.begin(),v.end());\\n        return v;       \\n    }\\n};\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        if(nums.size()<2)\\n            return nums;\\n        vector<int>v;\\n        stack<int>st;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n            while(!st.empty() and __gcd(st.top(),nums[i])>1)\\n            {\\n                nums[i]=lcm(st.top(),nums[i]);\\n                \\n                st.pop();\\n                \\n                \\n            }\\n            \\n            st.push(nums[i]);\\n                 \\n        }\\n        \\n        while(!st.empty())\\n        {\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(v.begin(),v.end());\\n        return v;       \\n    }\\n};\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1824343,
                "title": "python3-8lines-solution-with-stack",
                "content": "```\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        nums, ans = deque(nums), []\\n        while nums:\\n            ans.append(nums.popleft())\\n            while len(ans) > 1:\\n                if gcd(ans[-1], ans[-2]) > 1: ans.append(lcm(ans.pop(), ans.pop()))\\n                else: break\\n        return ans\\n```\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        nums, ans = deque(nums), []\\n        while nums:\\n            ans.append(nums.popleft())\\n            while len(ans) > 1:\\n                if gcd(ans[-1], ans[-2]) > 1: ans.append(lcm(ans.pop(), ans.pop()))\\n                else: break\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1824285,
                "title": "javascript-stack-gcd-398ms",
                "content": "```\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\n\\nconst replaceNonCoprimes = (a) => {\\n    let st = [];\\n    for (let x of a) {\\n        if (st.length == 0) {\\n            st.push(x);\\n        } else {\\n            while (st.length && gcd(st[st.length - 1], x) != 1) { // check if it can be merged with the value to its left\\n                let last = st.pop(), g = gcd(x, last);\\n                x = x / g * last;  // merge value, update lcm to x\\n            }\\n            st.push(x);\\n        }\\n    }\\n    return st;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\n\\nconst replaceNonCoprimes = (a) => {\\n    let st = [];\\n    for (let x of a) {\\n        if (st.length == 0) {\\n            st.push(x);\\n        } else {\\n            while (st.length && gcd(st[st.length - 1], x) != 1) { // check if it can be merged with the value to its left\\n                let last = st.pop(), g = gcd(x, last);\\n                x = x / g * last;  // merge value, update lcm to x\\n            }\\n            st.push(x);\\n        }\\n    }\\n    return st;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824282,
                "title": "java-stack-solution",
                "content": "```\\nclass Solution {\\n    public int gcd(int m, int n){\\n        if(m < n) return gcd(n, m); \\n        int tmp = 0;\\n        while (n != 0) {\\n            tmp = m % n;\\n            m = n;\\n            n = tmp;\\n        }\\n        return m;\\n    }\\n    \\n\\n    public int lcm(int n1, int n2) {\\n        if(n1 == n2) return n1;\\n        return n1 / gcd(n1, n2) * n2;\\n    }\\n\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(stack.empty()){\\n                stack.push(nums[i]);\\n            }else{\\n                while(stack.size() > 0){\\n                    int top = stack.peek();\\n                     if(gcd(top, nums[i]) == 1){\\n                        break;                             \\n                     }else{\\n                         nums[i] = lcm(stack.pop(), nums[i]);\\n                     }\\n                }\\n                stack.push(nums[i]);\\n            }\\n        }\\n        return stack.stream().toList();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int m, int n){\\n        if(m < n) return gcd(n, m); \\n        int tmp = 0;\\n        while (n != 0) {\\n            tmp = m % n;\\n            m = n;\\n            n = tmp;\\n        }\\n        return m;\\n    }\\n    \\n\\n    public int lcm(int n1, int n2) {\\n        if(n1 == n2) return n1;\\n        return n1 / gcd(n1, n2) * n2;\\n    }\\n\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(stack.empty()){\\n                stack.push(nums[i]);\\n            }else{\\n                while(stack.size() > 0){\\n                    int top = stack.peek();\\n                     if(gcd(top, nums[i]) == 1){\\n                        break;                             \\n                     }else{\\n                         nums[i] = lcm(stack.pop(), nums[i]);\\n                     }\\n                }\\n                stack.push(nums[i]);\\n            }\\n        }\\n        return stack.stream().toList();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824245,
                "title": "c-180ms",
                "content": "```c++\\n vector<int> replaceNonCoprimes(vector<int> &nums) {\\n    int n = nums.size();\\n    vector<int> ret;\\n    ret.reserve(n);\\n    for (int i = 0; i < n; ++i) {\\n      if (ret.empty()) {\\n        ret.push_back(nums[i]);\\n        continue;\\n      }\\n      int a = ret.back();\\n      int b = nums[i];\\n      if (gcd(a, b) == 1) {\\n        ret.push_back(b);\\n      } else {\\n        ret.pop_back();\\n        nums[i] = lcm(a, b);\\n        --i;\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "solutionTags": [],
                "code": "```c++\\n vector<int> replaceNonCoprimes(vector<int> &nums) {\\n    int n = nums.size();\\n    vector<int> ret;\\n    ret.reserve(n);\\n    for (int i = 0; i < n; ++i) {\\n      if (ret.empty()) {\\n        ret.push_back(nums[i]);\\n        continue;\\n      }\\n      int a = ret.back();\\n      int b = nums[i];\\n      if (gcd(a, b) == 1) {\\n        ret.push_back(b);\\n      } else {\\n        ret.pop_back();\\n        nums[i] = lcm(a, b);\\n        --i;\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824222,
                "title": "stack-one-pass-keep-popping-until-gcd-1",
                "content": "Space and time complexity are both O(N)\\n```\\ns = []\\nfor n in nums:\\n\\twhile s and gcd(s[-1], n) > 1:\\n\\t\\tprev = s.pop()\\n\\t\\tn = lcm(n, prev)\\n\\ts.append(n)\\n\\nreturn s\\n```\\nbtw Q2 is harder than Q1, Q3, Q4 combined...",
                "solutionTags": [],
                "code": "```\\ns = []\\nfor n in nums:\\n\\twhile s and gcd(s[-1], n) > 1:\\n\\t\\tprev = s.pop()\\n\\t\\tn = lcm(n, prev)\\n\\ts.append(n)\\n\\nreturn s\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824215,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def gcd(a, b):\\n            if b == 0:\\n                return a\\n            \\n            return gcd(b, a%b)\\n        \\n        def lcm(a, b):\\n            return (a*b)//gcd(a,b)\\n        \\n       \\n        st = []\\n        for n in nums:\\n            st.append(n)\\n            while len(st) > 1 and gcd(st[-1], st[-2]) > 1:\\n                x = st.pop()\\n                y = st.pop()\\n                st.append(lcm(x,y))\\n        \\n        return st\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def gcd(a, b):\\n            if b == 0:\\n                return a\\n            \\n            return gcd(b, a%b)\\n        \\n        def lcm(a, b):\\n            return (a*b)//gcd(a,b)\\n        \\n       \\n        st = []\\n        for n in nums:\\n            st.append(n)\\n            while len(st) > 1 and gcd(st[-1], st[-2]) > 1:\\n                x = st.pop()\\n                y = st.pop()\\n                st.append(lcm(x,y))\\n        \\n        return st\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576490,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            },
            {
                "id": 2010050,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            },
            {
                "id": 2010049,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            },
            {
                "id": 1815760,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            },
            {
                "id": 1790219,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            },
            {
                "id": 1733221,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            }
        ]
    }
]