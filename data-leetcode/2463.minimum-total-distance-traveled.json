[
    {
        "title": "Minimum Total Distance Traveled",
        "question_content": "There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.\nThe positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\nAt any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.\nReturn the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.\nNote that\n\n\tAll robots move at the same speed.\n\tIf two robots move in the same direction, they will never collide.\n\tIf two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.\n\tIf a robot passes by a factory that reached its limits, it crosses it as if it does not exist.\n\tIf the robot moved from a position x to a position y, the distance it moved is |y - x|.\n\n&nbsp;\nExample 1:\n\nInput: robot = [0,4,6], factory = [[2,2],[6,2]]\nOutput: 4\nExplanation: As shown in the figure:\n- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.\n- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.\n- The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.\n\nExample 2:\n\nInput: robot = [1,-1], factory = [[-2,1],[2,1]]\nOutput: 2\nExplanation: As shown in the figure:\n- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.\n- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.\n\n&nbsp;\nConstraints:\n\n\t1 <= robot.length, factory.length <= 100\n\tfactory[j].length == 2\n\t-109 <= robot[i], positionj <= 109\n\t0 <= limitj <= robot.length\n\tThe input will be generated such that it is always possible to repair every robot.",
        "solutions": [
            {
                "id": 2783305,
                "title": "python-dp-solution",
                "content": "# **Solution 1: Top-down DP**\\n`dp(i,j,k)` means the cost that,\\nto fix `robot[i]` and its following roberts\\nwith `factory[j]` already fix `k` robert.\\n\\nIn each iteration of DP:\\nIf `i == robot.length`,\\nmeans already fixed all robert,\\nreturn `cost = 0`.\\n\\nIf `j == factory.length`,\\nmeans no more available factory\\nreturn `cost = inf`.\\n\\nOption 1: Skip the current `factory[i]`, `res1 = dp(i, j + 1, 0)`\\nOption 2: Fix in the current `factory[i]` with cost `abs(A[i] - B[j][0])`\\nStill need to fix `robert[i + 1]` and other roberts,\\nso `res2 = dp(i + 1, j, k + 1) + abs(A[i] - B[j][0])`\\n\\nFinally `return min(res1, res2)` as the result.\\n<br>\\n\\n# **Complexity**\\nTime `O(nmk)`\\nSpace `O(nmk)`\\n<br>\\n\\n**Python**\\n```py\\n    def minimumTotalDistance(self, A: List[int], B: List[List[int]]) -> int:\\n        A.sort()\\n        B.sort()\\n        @lru_cache(None)\\n        def dp(i, j, k):\\n            if i == len(A): return 0\\n            if j == len(B): return inf\\n            res1 = dp(i, j + 1, 0)\\n            res2 = dp(i + 1, j, k + 1) + abs(A[i] - B[j][0]) if B[j][1] > k else inf\\n            return min(res1, res2)\\n        return dp(0, 0, 0)\\n```\\n\\n\\n# Solution 2: Bottom-up DP\\nTime `O(nmk)`\\nSpace `O(n)`\\n```py\\n    def minimumTotalDistance(self, A: List[int], B: List[List[int]]) -> int:\\n        n, m = len(A), len(B)\\n        dp = [inf] * (n + 1)\\n        dp[n] = 0\\n        A.sort()\\n        B.sort()\\n        for j in range(m-1,-1,-1):\\n            for i in range(n):\\n                cur = 0\\n                for k in range(1, min(B[j][1], n - i) + 1):\\n                    cur += abs(A[i + k - 1] - B[j][0])\\n                    dp[i] = min(dp[i], dp[i + k] + cur)\\n        return dp[0]\\n```",
                "solutionTags": [],
                "code": "```py\\n    def minimumTotalDistance(self, A: List[int], B: List[List[int]]) -> int:\\n        A.sort()\\n        B.sort()\\n        @lru_cache(None)\\n        def dp(i, j, k):\\n            if i == len(A): return 0\\n            if j == len(B): return inf\\n            res1 = dp(i, j + 1, 0)\\n            res2 = dp(i + 1, j, k + 1) + abs(A[i] - B[j][0]) if B[j][1] > k else inf\\n            return min(res1, res2)\\n        return dp(0, 0, 0)\\n```\n```py\\n    def minimumTotalDistance(self, A: List[int], B: List[List[int]]) -> int:\\n        n, m = len(A), len(B)\\n        dp = [inf] * (n + 1)\\n        dp[n] = 0\\n        A.sort()\\n        B.sort()\\n        for j in range(m-1,-1,-1):\\n            for i in range(n):\\n                cur = 0\\n                for k in range(1, min(B[j][1], n - i) + 1):\\n                    cur += abs(A[i + k - 1] - B[j][0])\\n                    dp[i] = min(dp[i], dp[i + k] + cur)\\n        return dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2783118,
                "title": "simplest-and-easiest-dp-solution-recursion-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n    long long maxi=1e16;\\n    long long f(int i,int j,vector<int>& robot,vector<int>& v,vector<vector<long long>>& dp) {\\n        if (i==robot.size()) return 0;\\n        if (j==v.size()) return maxi;\\n        if (dp[i][j]!=-1) return dp[i][j];\\n        long long take=abs(robot[i]-v[j])+f(i+1,j+1,robot,v,dp);\\n        long long not_take=f(i,j+1,robot,v,dp);\\n        return dp[i][j]=min(take,not_take);\\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        vector<int> v;\\n        for (auto i:factory) {\\n            int x=i[0],y=i[1];\\n            for (int i=0;i<y;i++) {\\n                v.push_back(x);\\n            }\\n        }\\n        vector<vector<long long>> dp(robot.size()+1,vector<long long>(v.size()+1,-1));\\n        return f(0,0,robot,v,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long maxi=1e16;\\n    long long f(int i,int j,vector<int>& robot,vector<int>& v,vector<vector<long long>>& dp) {\\n        if (i==robot.size()) return 0;\\n        if (j==v.size()) return maxi;\\n        if (dp[i][j]!=-1) return dp[i][j];\\n        long long take=abs(robot[i]-v[j])+f(i+1,j+1,robot,v,dp);\\n        long long not_take=f(i,j+1,robot,v,dp);\\n        return dp[i][j]=min(take,not_take);\\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        vector<int> v;\\n        for (auto i:factory) {\\n            int x=i[0],y=i[1];\\n            for (int i=0;i<y;i++) {\\n                v.push_back(x);\\n            }\\n        }\\n        vector<vector<long long>> dp(robot.size()+1,vector<long long>(v.size()+1,-1));\\n        return f(0,0,robot,v,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784885,
                "title": "python-c-rust-dp-using-singleton-factories-proof-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a Dynamic Programming approach using sorted and transformed arrays. \\n\\n**Comment.** You have probably seen the solution below here on LeetCode. Want to know exatcly where it is coming from? Next, I provide a proof using singleton decomposition of factories. But, first, the solution itself.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, rob, fac):\\n        \\n        rob.sort()\\n        fac.sort()\\n\\n        m, n = len(fac), len(rob)\\n        dp = [0] + [float(\\'inf\\')] * n\\n                \\n        for j, (f,l) in enumerate(fac):\\n            for _ in range(l):\\n                for i, r in reversed(list(enumerate(rob))):\\n                    dp[i+1] = min(abs(f-r) + dp[i], dp[i+1])\\n\\n        return dp[-1]\\n```\\n\\n**Proof.** Here is a list of key ideas behind the \"singleton decomposition\" strategy.\\n1. Imagine that all *factories* were actually *singletons* (both words sound like *design patterns* stuff, but it\\'s not the case), i.e., capable of repairing **only one** robot. The robot with the minimal coordinate will be repaired at some factory (let\\'s say, factory A), and then this factory can no longer be used. The next robot will be repaired at some other factory (let\\'s say, factory B). However, for the optimal solution (assuming that coordinates of robots and factories are sorted), the factory B can not come before factory A (otherwise, we would use it for the first robot). Thus, for a sequence of robots (with the increasing coordinates), there is a sequence of singleton factories with non-decreasing coordinates (in my approach, singleton factories are allowed to have same coordinates). \\n2. Our task is to find such non-decreasing subsequence of singleton factories that minimizes the sum of distances between each robot and its assigned singleton factory. Here, DP comes into play. For, e.g.  robots `[9, 11, 99, 101]` and singleton factories `[7, 10, 14, 96, 100, 103]`, we should extract precisely those **green** distances  (picture on the left) that result in the best total distance (picture on the right) for `i+1` robots and `j+1` factories. Thus, for each robot, we check whether each of subsequent factories (those coming after the last used one) would improve (minimize) the total sum.\\n3. Note that for each robot we should only check `m-n+1` factories (all except those colored in **red**), where `m` is the number of factories and `n` is the number of robots. This is due to the fact that\\n\\t* for the `i-th` robot, we should assign at least `i-th` factory and\\n\\t* for remaining `x` robots, we should have available at least `x` terminal (right-most) factories.\\n4. Finally, for non-singleton factories (those specified in the problem) with limit `L`, we replicate `L`  singleton factories at the same position, namely, `[[2,1], [3,4], [7,2]] -> [2,3,3,3,3,7,7]`, and use the discussed approach.\\n\\n![image](https://assets.leetcode.com/users/images/e74b984e-6cc4-41b9-90e6-f42a0e66e1c4_1667735231.745943.png)\\n\\nThis gives us the following DP solution for singleton factories.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, rob, factory):\\n        \\n        # [1] sort positions of robots and factories, then \\n        #     replicate factories into singleton factories\\n        rob.sort()\\n        fac = [x for f,lim in sorted(factory) for x in [f]*lim]\\n\\n        # [2] initialize DP state\\n        m, n = len(fac), len(rob)\\n        dp = [0] + [float(\\'inf\\')] * n\\n                \\n        # [3] perform DP\\n        for j, f in enumerate(fac):\\n            s, e = max(0,j-m+n), min(j,n)+1\\n            for i, r in reversed(list(enumerate(rob[s:e], start=s))):\\n                dp[i+1] = min(abs(f-r) + dp[i], dp[i+1])\\n\\n        # [4] get minimal value from the last column\\n        return dp[-1]\\n\\n```\\n\\nNote that in the cycle over `fac`  in `[3]` we run over multiple copies of the same singleton factory. If we switch back to the original factories (i.e., groupped singletons with the same position), the cycle over `fac = [[4,1], [6,2],..]` will turn into\\n```\\n        # [3] perform DP\\n\\t\\tfor j, (f,l) in enumerate(fac):\\n            for _ in range(l):\\n                s, e = 0, min(j+l,n)+1\\n```\\n\\nHere, `s` can be calculated exactly, but that\\'s not worth it, just start from `0`. The value `e` (the end of iteration over robots) is much easier to compute, however, for small `m` and `n` it can be safely replaces with `n+1`, thus, giving the solution that was provided in the beginning.\\n\\n**\\u2705 IF AT LEAST YOU LIKED THAT SINGLETON-FACTORY CLICK-BAIT TITLE, PLEASE UPVOTE.**\\n\\nI also provide solutions in other languages.\\n<iframe src=\"https://leetcode.com/playground/PfqigxyD/shared\" frameBorder=\"0\" width=\"800\" height=\"450\"></iframe>\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, rob, fac):\\n        \\n        rob.sort()\\n        fac.sort()\\n\\n        m, n = len(fac), len(rob)\\n        dp = [0] + [float(\\'inf\\')] * n\\n                \\n        for j, (f,l) in enumerate(fac):\\n            for _ in range(l):\\n                for i, r in reversed(list(enumerate(rob))):\\n                    dp[i+1] = min(abs(f-r) + dp[i], dp[i+1])\\n\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def minimumTotalDistance(self, rob, factory):\\n        \\n        # [1] sort positions of robots and factories, then \\n        #     replicate factories into singleton factories\\n        rob.sort()\\n        fac = [x for f,lim in sorted(factory) for x in [f]*lim]\\n\\n        # [2] initialize DP state\\n        m, n = len(fac), len(rob)\\n        dp = [0] + [float(\\'inf\\')] * n\\n                \\n        # [3] perform DP\\n        for j, f in enumerate(fac):\\n            s, e = max(0,j-m+n), min(j,n)+1\\n            for i, r in reversed(list(enumerate(rob[s:e], start=s))):\\n                dp[i+1] = min(abs(f-r) + dp[i], dp[i+1])\\n\\n        # [4] get minimal value from the last column\\n        return dp[-1]\\n\\n```\n```\\n        # [3] perform DP\\n\\t\\tfor j, (f,l) in enumerate(fac):\\n            for _ in range(l):\\n                s, e = 0, min(j+l,n)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785396,
                "title": "python-3-explanation-with-pictures-dp",
                "content": "Let\\'s sort out how DP work, if we assign robots in order, and want to assign robot `r` to factory `f`. \\n\\n- `r`: index of the current robot we want to assign.\\n- `f`: index of the current factory we are considering, all factorys before `r` are not considered.\\n- `res`: the remaining capacity of factory `f`. Apparently, we need to move to factory `f + 1` if `f` is full (res = 0)\\n\\n<br>\\n\\nWhat is the cost of the state `(r, f, res)` ?\\n\\n![image](https://assets.leetcode.com/users/images/2ffec7bc-37ed-4b17-b865-4f1bffab2d81_1667744805.4902806.png)\\n\\nThere are two options to assign robot `r`:\\n\\n### 1. Assign robot `r` to factory `f`, then move on to the next robot `r + 1`.\\n\\n![image](https://assets.leetcode.com/users/images/bb724e8c-0a00-4f82-97f9-3e003f0eeaef_1667745506.070283.png)\\n\\n\\n\\n<br>\\n<br>\\n\\n### 2. Skip the factory `f`, assign robot `r` to factory `f + 1` if possible.\\n\\n![image](https://assets.leetcode.com/users/images/1382f8ff-6c5a-4060-b6c2-ed3de9a8222b_1667745501.143765.png)\\n\\n\\nThus in the top-down dp, the states got transfered as follows:\\n\\n![image](https://assets.leetcode.com/users/images/189f99f1-ed69-46cb-aff4-bf2a6c4d6fb4_1667744814.1003215.png)\\n\\n\\n```python\\nclass Solution:\\n    def minimumTotalDistance(self, R: List[int], F: List[List[int]]) -> int:\\n        memo = {}\\n        \\n        R.sort()\\n        F.sort()\\n        rr, ff = len(R), len(F)\\n        \\n        def dp(r, f, res):\\n            if (r, f, res) in memo: \\n                return memo[(r, f, res)]\\n            \\n\\t\\t\\t# Edge cases: r = rr, we have finished assigning all robots, return 0;\\n\\t\\t\\t# res = 0, the current factory has 0 remaning seats, move to the next factory.\\n            if r == rr:\\n                return 0\\n            if res == 0:\\n                return dp(r, f + 1, F[f + 1][1]) if f + 1 < ff else math.inf\\n            \\n\\t\\t\\t# Assign the current robot r to the current factory f.\\n            cur = dp(r + 1, f, res - 1) + abs(R[r] - F[f][0])\\n\\t\\t\\t\\n\\t\\t\\t# Or assign it to the next factor f + 1, if possible.\\n            if f + 1 < ff:\\n                cur = min(cur, dp(r, f + 1, F[f + 1][1]))\\n                \\n            memo[(r, f, res)] = cur\\n            return cur\\n        \\n        return dp(0, 0, F[0][1])\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumTotalDistance(self, R: List[int], F: List[List[int]]) -> int:\\n        memo = {}\\n        \\n        R.sort()\\n        F.sort()\\n        rr, ff = len(R), len(F)\\n        \\n        def dp(r, f, res):\\n            if (r, f, res) in memo: \\n                return memo[(r, f, res)]\\n            \\n\\t\\t\\t# Edge cases: r = rr, we have finished assigning all robots, return 0;\\n\\t\\t\\t# res = 0, the current factory has 0 remaning seats, move to the next factory.\\n            if r == rr:\\n                return 0\\n            if res == 0:\\n                return dp(r, f + 1, F[f + 1][1]) if f + 1 < ff else math.inf\\n            \\n\\t\\t\\t# Assign the current robot r to the current factory f.\\n            cur = dp(r + 1, f, res - 1) + abs(R[r] - F[f][0])\\n\\t\\t\\t\\n\\t\\t\\t# Or assign it to the next factor f + 1, if possible.\\n            if f + 1 < ff:\\n                cur = min(cur, dp(r, f + 1, F[f + 1][1]))\\n                \\n            memo[(r, f, res)] = cur\\n            return cur\\n        \\n        return dp(0, 0, F[0][1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783353,
                "title": "knapsack-type-dynamic-programming-with-sorting",
                "content": "### Idea:\\n1. Sort the robots postions.\\n2. Sort the factory positions.\\n3. Iterate from left robot to right. For each robot, you have **2 options**:\\n\\t* \\tChoose to fix it in current factory if possible (if the factory hasn\\'t reached it\\'s limit) *(like take item from the current sack)*\\n\\t* \\tor Try to fix the robot in the next factory *(or dont take from the current sack)*\\n\\t*   Answer = max(option1, option2)\\n\\n**Time Complexity:** O(n * n * n)\\n**Space Complexity:** O(n * n * n)\\n\\n```\\nclass Solution {\\npublic:\\n    const long long inf = 1e18;\\n    vector<int> robot;\\n    vector<vector<int>> factory;\\n    int n;\\n    long long dp[111][111][111];\\n\\n    long long minimumTotalDistance(vector<int>& _robot, vector<vector<int>>& _factory) {\\n        this->robot = _robot;\\n        this->factory = _factory;\\n        n = factory.size();\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        memset(dp, -1, sizeof dp);\\n        return solve(0, 0, factory[0][1]);\\n    }\\n\\n    long long solve(int robot_index, int factory_index, int cnt) {\\n        if (robot_index == (int) robot.size()) return 0;\\n        if (factory_index == (int) factory.size()) return inf;\\n        if (cnt == 0) return solve(robot_index, factory_index + 1, (factory_index + 1 == n) ? 0 : factory[factory_index + 1][1]);\\n        if (dp[robot_index][factory_index][cnt] != -1) return dp[robot_index][factory_index][cnt];\\n        long long &ans = dp[robot_index][factory_index][cnt];\\n        ans = inf;\\n        long long subans1 = solve(robot_index + 1, factory_index, cnt - 1) ;\\n        if (subans1 != inf) subans1 += abs(robot[robot_index] - factory[factory_index][0]);\\n        long long subans2 = solve(robot_index, factory_index + 1, (factory_index + 1 == n) ? 0 : factory[factory_index + 1][1]);\\n        ans = min({ans, subans1, subans2});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long inf = 1e18;\\n    vector<int> robot;\\n    vector<vector<int>> factory;\\n    int n;\\n    long long dp[111][111][111];\\n\\n    long long minimumTotalDistance(vector<int>& _robot, vector<vector<int>>& _factory) {\\n        this->robot = _robot;\\n        this->factory = _factory;\\n        n = factory.size();\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        memset(dp, -1, sizeof dp);\\n        return solve(0, 0, factory[0][1]);\\n    }\\n\\n    long long solve(int robot_index, int factory_index, int cnt) {\\n        if (robot_index == (int) robot.size()) return 0;\\n        if (factory_index == (int) factory.size()) return inf;\\n        if (cnt == 0) return solve(robot_index, factory_index + 1, (factory_index + 1 == n) ? 0 : factory[factory_index + 1][1]);\\n        if (dp[robot_index][factory_index][cnt] != -1) return dp[robot_index][factory_index][cnt];\\n        long long &ans = dp[robot_index][factory_index][cnt];\\n        ans = inf;\\n        long long subans1 = solve(robot_index + 1, factory_index, cnt - 1) ;\\n        if (subans1 != inf) subans1 += abs(robot[robot_index] - factory[factory_index][0]);\\n        long long subans2 = solve(robot_index, factory_index + 1, (factory_index + 1 == n) ? 0 : factory[factory_index + 1][1]);\\n        ans = min({ans, subans1, subans2});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783348,
                "title": "max-flow-min-cost-solution",
                "content": "# Intuition\\ng\\n\\n# Approach\\n\\nI won\\'t describe the algorithm because I don\\'t think it\\'s useful for the interview questions, instead it\\'s more of a Codeforces/ICPC topic, but it\\'s interesting to know and useful to get a good place in the contest :), if you want for more information, see https://cp-algorithms.com/graph/min_cost_flow.html\\n \\nWe proceed to model the problem as a bipartite graph, one set is for Robots and the other is for Factories and edges between each pair {$R_i$,$F_i$}, it is obvious that it is bipartite since it makes no sense to connect robots since they don\\'t collide, same for factories.\\n\\nIn a network flow we have the concept of capacity, which means how much \\'flow\\' can go through an edge, in our problem we can see 1 unit of flow as a robot to repair, so each edge from a robot to a factories must have flow = 1, we also have another constraint which is to minimize a cost, and the cost is simply the distance from $R_i$ to $F_i$ so we have a bipartite graph with edges with flow/capacity and a cost and next is just running the minimum flow maximum cost algorithm\\n\\nTo use that algorithm, we need to add two more nodes, a source and a sink, since the goal of the algorithm is to get a certain amount of flow from the source to the sink with minimum cost, so we add the source node and this must connect to each robot with flow = 1 and cost = 0, and sink which must connect to each factory with an edge oriented from factory to sink with flow = $C_i$ (The limit of fabric $i$ ) and cost = 0, notice how the other constraint that says some factories can only repair $x$ robots  can be translated directly with flow capacity.\\n\\nHere is an example of some flow network that model our problem \\n![graph (1).png](https://assets.leetcode.com/users/images/661fefdc-f08e-451d-b923-b67691a1f908_1667706770.5715697.png)\\n\\nF($R_i$,$F_j$) is the distance from some robot to some factory and $C_i$ is the limit of the factory $i$\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nIf you check the resource I shared you can notice that the complexity is $O(n^3m)$ which should give a TLE verdict for the limits of the problem,but actually for bipartite graphs the complexity is much lower, unfortunately I don\\'t remember the exact complexity :(\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct Edge{\\n        long long from, to, capacity, cost;\\n    };\\n\\n    vector<vector<long long>> adj, cost, capacity;\\n\\n    const long long INF = 1e18;\\n    void shortest_paths(long long n, long long v0, vector<long long>& d, vector<long long>& p) {\\n        d.assign(n, INF);\\n        d[v0] = 0;\\n        vector<bool> inq(n, false);\\n        queue<long long> q;\\n        q.push(v0);\\n        p.assign(n, -1);\\n        while (!q.empty()) {\\n            long long u = q.front();\\n            q.pop();\\n            inq[u] = false;\\n            for (int v : adj[u]) {\\n                if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\\n                    d[v] = d[u] + cost[u][v];\\n                    p[v] = u;\\n                    if (!inq[v]) {\\n                        inq[v] = true;\\n                        q.push(v); \\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    long long min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {\\n        N+=7;\\n        adj.assign(N, vector<long long>());\\n        cost.assign(N, vector<long long>(N, 0));\\n        capacity.assign(N, vector<long long>(N, 0));\\n        for (Edge e : edges) {\\n            adj[e.from].push_back(e.to);\\n            adj[e.to].push_back(e.from);\\n            cost[e.from][e.to] = e.cost;\\n            cost[e.to][e.from] = -e.cost;\\n            capacity[e.from][e.to] = e.capacity;\\n        }\\n        long long flow = 0;\\n        long long cost = 0;\\n        vector<long long> d, p;\\n        while (flow < K) {\\n            shortest_paths(N, s, d, p);\\n            if (d[t] == INF)\\n                break;\\n            // find max flow on that path\\n            long long f = K - flow;\\n            long long cur = t;\\n            while (cur != s) {\\n                f = min(f, capacity[p[cur]][cur]);\\n                cur = p[cur];\\n            }\\n            // apply flow\\n            flow += f;\\n            cost += f * d[t];\\n            cur = t;\\n            while (cur != s) {\\n                capacity[p[cur]][cur] -= f;\\n                capacity[cur][p[cur]] += f;\\n                cur = p[cur];\\n            }\\n        }\\n\\n        if (flow < K)\\n            return -1;\\n        else\\n            return cost;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int n = robot.size();\\n        int m = factory.size();\\n        vector<Edge> E;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                E.push_back({i,n+j,1,abs(robot[i]-factory[j][0])});\\n            }\\n            E.push_back({n+m,i,1,0});\\n        }\\n        for(int i = 0;i<m;i++)\\n            E.push_back({n+i,n+m+1,factory[i][1],0});\\n        \\n        return min_cost_flow(n+m+2,E,n,n+m,n+m+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Edge{\\n        long long from, to, capacity, cost;\\n    };\\n\\n    vector<vector<long long>> adj, cost, capacity;\\n\\n    const long long INF = 1e18;\\n    void shortest_paths(long long n, long long v0, vector<long long>& d, vector<long long>& p) {\\n        d.assign(n, INF);\\n        d[v0] = 0;\\n        vector<bool> inq(n, false);\\n        queue<long long> q;\\n        q.push(v0);\\n        p.assign(n, -1);\\n        while (!q.empty()) {\\n            long long u = q.front();\\n            q.pop();\\n            inq[u] = false;\\n            for (int v : adj[u]) {\\n                if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\\n                    d[v] = d[u] + cost[u][v];\\n                    p[v] = u;\\n                    if (!inq[v]) {\\n                        inq[v] = true;\\n                        q.push(v); \\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    long long min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {\\n        N+=7;\\n        adj.assign(N, vector<long long>());\\n        cost.assign(N, vector<long long>(N, 0));\\n        capacity.assign(N, vector<long long>(N, 0));\\n        for (Edge e : edges) {\\n            adj[e.from].push_back(e.to);\\n            adj[e.to].push_back(e.from);\\n            cost[e.from][e.to] = e.cost;\\n            cost[e.to][e.from] = -e.cost;\\n            capacity[e.from][e.to] = e.capacity;\\n        }\\n        long long flow = 0;\\n        long long cost = 0;\\n        vector<long long> d, p;\\n        while (flow < K) {\\n            shortest_paths(N, s, d, p);\\n            if (d[t] == INF)\\n                break;\\n            // find max flow on that path\\n            long long f = K - flow;\\n            long long cur = t;\\n            while (cur != s) {\\n                f = min(f, capacity[p[cur]][cur]);\\n                cur = p[cur];\\n            }\\n            // apply flow\\n            flow += f;\\n            cost += f * d[t];\\n            cur = t;\\n            while (cur != s) {\\n                capacity[p[cur]][cur] -= f;\\n                capacity[cur][p[cur]] += f;\\n                cur = p[cur];\\n            }\\n        }\\n\\n        if (flow < K)\\n            return -1;\\n        else\\n            return cost;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int n = robot.size();\\n        int m = factory.size();\\n        vector<Edge> E;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                E.push_back({i,n+j,1,abs(robot[i]-factory[j][0])});\\n            }\\n            E.push_back({n+m,i,1,0});\\n        }\\n        for(int i = 0;i<m;i++)\\n            E.push_back({n+i,n+m+1,factory[i][1],0});\\n        \\n        return min_cost_flow(n+m+2,E,n,n+m,n+m+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783192,
                "title": "java-n-n-m-standard-dp-memo-easy-to-understand",
                "content": "```\\nclass Solution {\\n    Long[][] dp;\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        Collections.sort(robot);  // sorting robot based on position\\n        Arrays.sort(factory,(a,b)->(a[0]-b[0])); // sorting factory based on position\\n        dp = new Long[robot.size()+1][factory.length+1];\\n        return solve(robot,factory,0,0);\\n    }\\n    \\n    public long solve(List<Integer> list,int[][] arr,int i,int j){\\n        \\n        if(i>=list.size()) return 0L;  // if all robot are repaired then there is no robot left to repair so return 0.\\n        if(j>=arr.length) return Long.MAX_VALUE; // here we check if there is no factory left for rapair robot but we have some robot to repair because we didnt pass on first condition.\\n        \\n        if(dp[i][j]!=null) return dp[i][j]; // checking memo for already calculated result.\\n        \\n        long x = 0;\\n        long res = solve(list,arr,i,j+1); // option 1 - no robot will repair on jth factory\\n\\n\\t\\t// here we check that ... from i to k will repair on jth factory and other will check with recurstion.... \\n\\t\\t// for k, we will check all possible index from i+1 to array.length\\n        for(int k = i;k<list.size() && k-i+1<=arr[j][1];k++){\\n            x += Math.abs(list.get(k)-arr[j][0]);\\n            long p = solve(list,arr,k+1,j+1);\\n\\t\\t\\t\\n\\t\\t\\t//p!=maxValue because of maxValue means there is no possible way to repair all robot with that \\n            if(p!=Long.MAX_VALUE){\\n                res = Math.min(res,x+p);\\n            }\\n        }\\n        \\n        return dp[i][j] = res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Long[][] dp;\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        Collections.sort(robot);  // sorting robot based on position\\n        Arrays.sort(factory,(a,b)->(a[0]-b[0])); // sorting factory based on position\\n        dp = new Long[robot.size()+1][factory.length+1];\\n        return solve(robot,factory,0,0);\\n    }\\n    \\n    public long solve(List<Integer> list,int[][] arr,int i,int j){\\n        \\n        if(i>=list.size()) return 0L;  // if all robot are repaired then there is no robot left to repair so return 0.\\n        if(j>=arr.length) return Long.MAX_VALUE; // here we check if there is no factory left for rapair robot but we have some robot to repair because we didnt pass on first condition.\\n        \\n        if(dp[i][j]!=null) return dp[i][j]; // checking memo for already calculated result.\\n        \\n        long x = 0;\\n        long res = solve(list,arr,i,j+1); // option 1 - no robot will repair on jth factory\\n\\n\\t\\t// here we check that ... from i to k will repair on jth factory and other will check with recurstion.... \\n\\t\\t// for k, we will check all possible index from i+1 to array.length\\n        for(int k = i;k<list.size() && k-i+1<=arr[j][1];k++){\\n            x += Math.abs(list.get(k)-arr[j][0]);\\n            long p = solve(list,arr,k+1,j+1);\\n\\t\\t\\t\\n\\t\\t\\t//p!=maxValue because of maxValue means there is no possible way to repair all robot with that \\n            if(p!=Long.MAX_VALUE){\\n                res = Math.min(res,x+p);\\n            }\\n        }\\n        \\n        return dp[i][j] = res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783245,
                "title": "python3-o-mn-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6a94b729b8594be1319f14da1cf3c97ddb12a427) for solutions of weekly 318.\\n\\nThis is an overkill for this problem as cubic solutions can pass the OJ as well. But a quadratic solution is possible. \\n\\n**Intuition**\\nHere, I define `dp[i][j]` as the minimum moves to fix `robot[i:]` with `factory[j:]`. Clearly, `dp[0][0]` is the desired answer. The recurrence relation is \\n\\n```\\ndp[i][j] = min(dp[i][j+1], \\n\\t\\t\\t   |robot[i] - pos| + dp[i+1][j+1], \\n\\t\\t\\t   |robot[i] - pos| + |robot[i+1] - pos| + dp[i+2][j+1], \\n\\t\\t\\t   ...\\n\\t\\t\\t   |robot[i] - pos| + ... + |robot[i+limit-1] - pos| + dp[i+limit][j+1])\\n```\\nThis can be rewritten as \\n```\\ndp[i][j] = |robot[i] - pos| + ... + |robot[i+limit-1] - pos| + min(dp[i][j+1] - |robot[i] - pos| - ... - |robot[i+limit-1][j+1]|, \\n\\t\\t                                                           dp[i+1][j+1] - |robot[i+1] - pos| - ... - |robot[i+limit-1][j+1]|, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   ... \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   dp[i+limit][j+1]) \\n```\\nWhat\\'s nice about this form is that I can break `dp[i][j]` into two parts \\n* prefix sum of absolute differences \\n* minimum of `dp[*][j+1]` - prefix sum. \\n\\nNotice that even though the prefix sum in the 2nd part differ for `dp[*][j+1]` it happens to be the prefix sum when `dp[*][j]` is being computed. To elaborate, when I compute `dp[i][j]` the prefix sum is `|robot[i] - pos| + ... + |robot[i+limit-1] - pos|` and this is the term trailing `dp[i][j+1]` in the min calculation. Similarly, when computing `dp[i+1][j]` the prefix sum is `|robot[i+1] - pos| + ... + |robot[i+limit-1] - pos|` which happens to be the term trailing `dp[i+1][j+1]` in the min calculation. \\n\\nWith this breakdown, I can throw `dp[*][j+1] - prefix` into a mono-deque to compute the minimum in `O(1)` time, which is essentially a running minimum with fixed window. \\n\\nSo the overall time complexity of this implementation is `O(MN)`. The space complexity is also `O(MN)`. \\n\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        m, n = len(robot), len(factory)\\n        dp = [[0]*(n+1) for _ in range(m+1)] \\n        for i in range(m): dp[i][-1] = inf \\n        for j in range(n-1, -1, -1): \\n            prefix = 0 \\n            qq = deque([(m, 0)])\\n            for i in range(m-1, -1, -1): \\n                prefix += abs(robot[i] - factory[j][0])\\n                if qq[0][0] > i+factory[j][1]: qq.popleft()\\n                while qq and qq[-1][1] >= dp[i][j+1] - prefix: qq.pop()\\n                qq.append((i, dp[i][j+1] - prefix))\\n                dp[i][j] = qq[0][1] + prefix\\n        return dp[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndp[i][j] = min(dp[i][j+1], \\n\\t\\t\\t   |robot[i] - pos| + dp[i+1][j+1], \\n\\t\\t\\t   |robot[i] - pos| + |robot[i+1] - pos| + dp[i+2][j+1], \\n\\t\\t\\t   ...\\n\\t\\t\\t   |robot[i] - pos| + ... + |robot[i+limit-1] - pos| + dp[i+limit][j+1])\\n```\n```\\ndp[i][j] = |robot[i] - pos| + ... + |robot[i+limit-1] - pos| + min(dp[i][j+1] - |robot[i] - pos| - ... - |robot[i+limit-1][j+1]|, \\n\\t\\t                                                           dp[i+1][j+1] - |robot[i+1] - pos| - ... - |robot[i+limit-1][j+1]|, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   ... \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   dp[i+limit][j+1]) \\n```\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        m, n = len(robot), len(factory)\\n        dp = [[0]*(n+1) for _ in range(m+1)] \\n        for i in range(m): dp[i][-1] = inf \\n        for j in range(n-1, -1, -1): \\n            prefix = 0 \\n            qq = deque([(m, 0)])\\n            for i in range(m-1, -1, -1): \\n                prefix += abs(robot[i] - factory[j][0])\\n                if qq[0][0] > i+factory[j][1]: qq.popleft()\\n                while qq and qq[-1][1] >= dp[i][j+1] - prefix: qq.pop()\\n                qq.append((i, dp[i][j+1] - prefix))\\n                dp[i][j] = qq[0][1] + prefix\\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783969,
                "title": "c-dynamic-programming-memoization-easy-to-understand",
                "content": "```\\n#define ll long long int\\n#define sz(a) (int)a.size()\\n\\nclass Solution {\\n    int n, m;\\n    ll dp[101][101][101];\\n    ll solve(vector<int>& robot, vector<vector<int>>& factory, int i, int j, int lim) {\\n\\t\\t// if all factories are taken but some robots are still left then we return big value \\'1e10\\' else if all robots and factories are taken then we return 0\\n        if(j >= m) return ((i < n) ? 1e10 : 0);\\n\\t\\t\\n\\t\\t// if all robots are repaired then we return 0 \\n        if(i >= n) return 0;\\n        ll &ans = dp[i][j][lim];\\n        if(ans != -1) return ans;\\n\\t\\t\\n        ans = 1e18; // max initial value\\n\\t\\t\\n\\t\\t// if some lim of current factory is remaining then we can take it and add the absolute distance between factory and robot\\n        if(lim > 0) ans = solve(robot, factory, i + 1, j, lim - 1) + abs(robot[i] - factory[j][0]);\\n\\t\\t\\n\\t\\t// else we have another option to leave that factory and take next factory if available;\\n        if(j + 1 < m) ans = min(ans, solve(robot, factory, i, j + 1, factory[j + 1][1]));\\n        return ans;\\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        n = sz(robot);\\n        m = sz(factory);\\n        sort(robot.begin(), robot.end()); // we will sort the position of all robots\\n        sort(factory.begin(), factory.end()); // we will sort the position of all factories\\n        memset(dp, -1, sizeof dp);\\n\\t\\t\\n        return solve(robot, factory, 0, 0, factory[0][1]);\\n    }\\n};\\n```\\nplease upvote if you like the solution",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n#define ll long long int\\n#define sz(a) (int)a.size()\\n\\nclass Solution {\\n    int n, m;\\n    ll dp[101][101][101];\\n    ll solve(vector<int>& robot, vector<vector<int>>& factory, int i, int j, int lim) {\\n\\t\\t// if all factories are taken but some robots are still left then we return big value \\'1e10\\' else if all robots and factories are taken then we return 0\\n        if(j >= m) return ((i < n) ? 1e10 : 0);\\n\\t\\t\\n\\t\\t// if all robots are repaired then we return 0 \\n        if(i >= n) return 0;\\n        ll &ans = dp[i][j][lim];\\n        if(ans != -1) return ans;\\n\\t\\t\\n        ans = 1e18; // max initial value\\n\\t\\t\\n\\t\\t// if some lim of current factory is remaining then we can take it and add the absolute distance between factory and robot\\n        if(lim > 0) ans = solve(robot, factory, i + 1, j, lim - 1) + abs(robot[i] - factory[j][0]);\\n\\t\\t\\n\\t\\t// else we have another option to leave that factory and take next factory if available;\\n        if(j + 1 < m) ans = min(ans, solve(robot, factory, i, j + 1, factory[j + 1][1]));\\n        return ans;\\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        n = sz(robot);\\n        m = sz(factory);\\n        sort(robot.begin(), robot.end()); // we will sort the position of all robots\\n        sort(factory.begin(), factory.end()); // we will sort the position of all factories\\n        memset(dp, -1, sizeof dp);\\n\\t\\t\\n        return solve(robot, factory, 0, 0, factory[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783308,
                "title": "python-assignment-problem-with-scipy",
                "content": "classic assignment problem, scipy implements linear_sum_assignment with [Jonker-Volgenant/Hungarian algorithm](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linear_sum_assignment.html). Time complexity is o(n^3). \\n\\nAssignment solution treats robots and factories as bipatite graph, it didn\\'t utilize the fact that all robots and factories share the same number axis, which was why DP solution with sorting achieves quadratic complexity. \\n\\n\\n```\\nfrom scipy import optimize\\nimport numpy\\n\\nclass Solution:\\n    def minimumTotalDistance(self, rs: List[int], fs: List[List[int]]) -> int:\\n        costs = []\\n        for i, k in fs:\\n            c = [abs(j-i) for j in rs]\\n            for _ in range(k):\\n                costs.append(c)\\n        costs = numpy.array(costs)\\n        return costs[optimize.linear_sum_assignment(costs)].sum() \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom scipy import optimize\\nimport numpy\\n\\nclass Solution:\\n    def minimumTotalDistance(self, rs: List[int], fs: List[List[int]]) -> int:\\n        costs = []\\n        for i, k in fs:\\n            c = [abs(j-i) for j in rs]\\n            for _ in range(k):\\n                costs.append(c)\\n        costs = numpy.array(costs)\\n        return costs[optimize.linear_sum_assignment(costs)].sum() \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783240,
                "title": "visualized-solution-memoization-memory-beats-100-time-beats-84",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* The intution was that only a (range/adjacent) of robots will be repaired by  factory provided its limit does not exceed.\\n* Since ony adjacent range of robots can be in the factory we will sort both the arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* for jth factory we can  take a range of robots lets say from i,i+x\\nand pass recursion to calculate for i+x+1 robots and j+1th factory.\\nfor visualisation chec this test case:\\n![image.png](https://assets.leetcode.com/users/images/ae267021-0287-4339-9562-423cc00926e0_1667708172.9376771.png)\\n\\n* it was important to sort the values else we wont be able to check the adjacenct robots.\\n\\n\\nplease give it an upvote if you liked the approach.\\n# Complexity\\n- Time complexity:O(size(robots) * size(factory) * max(limits))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(size(robots) * size(factory))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nll memo[101][101]={0};\\nclass Solution {\\npublic:    \\n   long long dp(vector<int>& robot, vector<vector<int>>& factory,int i,int j)\\n    {\\n        if(i == robot.size()) return 0;    \\n        if(j == factory.size()) return  1e16;\\n        if(memo[i][j]!=-1) return memo[i][j];\\n        \\n        int limit=0,ind=i;\\n        ll sum=dp(robot,factory,i,j+1),cursum=0;\\n        \\n        while(ind<robot.size()&&limit<factory[j][1])\\n        {\\n            cursum=cursum+(1LL*abs(1LL*robot[ind]-factory[j][0]));\\n            sum=min(sum,cursum+dp(robot,factory,ind+1,j+1));\\n            ind++,limit++;\\n        }\\n        return memo[i][j]=sum;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) \\n    {\\n        sort(begin(robot),end(robot));\\n        sort(begin(factory),end(factory));\\n        memset(memo, -1, sizeof(memo)); \\n        return dp(robot,factory,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nll memo[101][101]={0};\\nclass Solution {\\npublic:    \\n   long long dp(vector<int>& robot, vector<vector<int>>& factory,int i,int j)\\n    {\\n        if(i == robot.size()) return 0;    \\n        if(j == factory.size()) return  1e16;\\n        if(memo[i][j]!=-1) return memo[i][j];\\n        \\n        int limit=0,ind=i;\\n        ll sum=dp(robot,factory,i,j+1),cursum=0;\\n        \\n        while(ind<robot.size()&&limit<factory[j][1])\\n        {\\n            cursum=cursum+(1LL*abs(1LL*robot[ind]-factory[j][0]));\\n            sum=min(sum,cursum+dp(robot,factory,ind+1,j+1));\\n            ind++,limit++;\\n        }\\n        return memo[i][j]=sum;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) \\n    {\\n        sort(begin(robot),end(robot));\\n        sort(begin(factory),end(factory));\\n        memset(memo, -1, sizeof(memo)); \\n        return dp(robot,factory,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789004,
                "title": "recursion-memoization-tabulation-space-optimization",
                "content": "# Recursive\\n```\\n\\tlong long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(begin(robot), end(robot));\\n        sort(begin(factory), end(factory));\\n        vector<int>pos;\\n        for(auto &it : factory)\\n            for(int i = 0; i < it[1]; i++)\\n                pos.push_back(it[0]);\\n        \\n        return f(0, 0, robot, pos);\\n\\t}\\n\\t\\n\\tlong long f(int i, int j, vector<int>& robot, vector<int>& pos) {\\n        if(i == robot.size()) return 0;\\n        if(j == pos.size()) return 1e12;\\n        \\n        long long pick = abs(robot[i]-pos[j]) + f(i+1, j+1, robot, pos);\\n        long long skip = f(i, j+1, robot, pos);\\n        return min(pick, skip);\\n    }\\n```\\n**This will give TLE.**\\n# Memoization\\n\\tlong long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(begin(robot), end(robot));\\n        sort(begin(factory), end(factory));\\n        vector<int>pos;\\n        for(auto &it : factory)\\n            for(int i = 0; i < it[1]; i++)\\n                pos.push_back(it[0]);\\n        int n = robot.size(), m = pos.size();\\n        vector<vector<long long>> dp(n, vector<long long>(m, -1));\\n        return f(0, 0, robot, pos, dp);\\n    }\\n\\t\\n\\tlong long f(int i, int j, vector<int>& robot, vector<int>& pos, vector<vector<long long>>& dp) {\\n        if(i == robot.size()) return 0;\\n        if(j == pos.size()) return 1e12;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        long long pick = abs(robot[i]-pos[j]) + f(i+1, j+1, robot, pos, dp);\\n        long long skip = f(i, j+1, robot, pos, dp);\\n        return dp[i][j] = min(pick, skip);\\n    }\\n\\t\\n# \\tTabulation\\n```\\n\\tlong long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(begin(robot), end(robot));\\n        sort(begin(factory), end(factory));\\n        vector<int>pos;\\n        for(auto &it : factory)\\n            for(int i = 0; i < it[1]; i++)\\n                pos.push_back(it[0]);\\n        \\n        int n = robot.size(), m = pos.size();\\n        vector<vector<long long>> dp(n+1, vector<long long>(m+1, 0));\\n        for(int i = 0; i < n; i++) dp[i][m] = 1e12;\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            for(int j = m-1; j >= 0; j--) {\\n                long long pick = abs(robot[i]-pos[j]) + dp[i+1][j+1];\\n                long long skip = dp[i][j+1];\\n                dp[i][j] = min(pick, skip);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```\\n\\n***Space Optimization***\\n```\\n\\tlong long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(begin(robot), end(robot));\\n        sort(begin(factory), end(factory));\\n        vector<int>pos;\\n        for(auto &it : factory)\\n            for(int i = 0; i < it[1]; i++)\\n                pos.push_back(it[0]);\\n        \\n        int n = robot.size(), m = pos.size();\\n        vector<long long>next(m+1, 0), cur(m+1, 0);\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            if(i != n-1) next[m] = 1e12;\\n            cur[m] = 1e12;\\n            for(int j = m-1; j >= 0; j--) {\\n                long long pick = abs(robot[i]-pos[j]) + next[j+1];\\n                long long skip = cur[j+1];\\n                cur[j] = min(pick, skip);\\n            }\\n            next = cur;\\n        }\\n        return cur[0];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tlong long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(begin(robot), end(robot));\\n        sort(begin(factory), end(factory));\\n        vector<int>pos;\\n        for(auto &it : factory)\\n            for(int i = 0; i < it[1]; i++)\\n                pos.push_back(it[0]);\\n        \\n        return f(0, 0, robot, pos);\\n\\t}\\n\\t\\n\\tlong long f(int i, int j, vector<int>& robot, vector<int>& pos) {\\n        if(i == robot.size()) return 0;\\n        if(j == pos.size()) return 1e12;\\n        \\n        long long pick = abs(robot[i]-pos[j]) + f(i+1, j+1, robot, pos);\\n        long long skip = f(i, j+1, robot, pos);\\n        return min(pick, skip);\\n    }\\n```\n```\\n\\tlong long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(begin(robot), end(robot));\\n        sort(begin(factory), end(factory));\\n        vector<int>pos;\\n        for(auto &it : factory)\\n            for(int i = 0; i < it[1]; i++)\\n                pos.push_back(it[0]);\\n        \\n        int n = robot.size(), m = pos.size();\\n        vector<vector<long long>> dp(n+1, vector<long long>(m+1, 0));\\n        for(int i = 0; i < n; i++) dp[i][m] = 1e12;\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            for(int j = m-1; j >= 0; j--) {\\n                long long pick = abs(robot[i]-pos[j]) + dp[i+1][j+1];\\n                long long skip = dp[i][j+1];\\n                dp[i][j] = min(pick, skip);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```\n```\\n\\tlong long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(begin(robot), end(robot));\\n        sort(begin(factory), end(factory));\\n        vector<int>pos;\\n        for(auto &it : factory)\\n            for(int i = 0; i < it[1]; i++)\\n                pos.push_back(it[0]);\\n        \\n        int n = robot.size(), m = pos.size();\\n        vector<long long>next(m+1, 0), cur(m+1, 0);\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            if(i != n-1) next[m] = 1e12;\\n            cur[m] = 1e12;\\n            for(int j = m-1; j >= 0; j--) {\\n                long long pick = abs(robot[i]-pos[j]) + next[j+1];\\n                long long skip = cur[j+1];\\n                cur[j] = min(pick, skip);\\n            }\\n            next = cur;\\n        }\\n        return cur[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783271,
                "title": "c-dp",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[101][101][101],pos[101][101],n,m;\\n    ll func(int i,int j,int x,vector<int>& r, vector<vector<int>>& f)\\n    {\\n        if(i==n)\\n            return (j==m) ? 1e15 : 0 ;\\n        if(j==m)\\n            return 0;\\n        if(dp[i][j][x]!=-1)\\n            return dp[i][j][x];\\n        ll ans = 1e18;\\n        if(i+1<n)\\n            ans=func(i+1,j,f[i+1][1],r,f);\\n        if(x)\\n            ans=min(ans,pos[i][j] + func(i,j+1,x-1,r,f));\\n        return dp[i][j][x]=ans;\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& r, vector<vector<int>>& f) {\\n        n=f.size(),m=r.size(),sort(begin(r),end(r)),sort(begin(f),end(f)),memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                pos[i][j] = max(f[i][0],r[j]) - min(f[i][0],r[j]);\\n        return func(0,0,f[0][1],r,f);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[101][101][101],pos[101][101],n,m;\\n    ll func(int i,int j,int x,vector<int>& r, vector<vector<int>>& f)\\n    {\\n        if(i==n)\\n            return (j==m) ? 1e15 : 0 ;\\n        if(j==m)\\n            return 0;\\n        if(dp[i][j][x]!=-1)\\n            return dp[i][j][x];\\n        ll ans = 1e18;\\n        if(i+1<n)\\n            ans=func(i+1,j,f[i+1][1],r,f);\\n        if(x)\\n            ans=min(ans,pos[i][j] + func(i,j+1,x-1,r,f));\\n        return dp[i][j][x]=ans;\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& r, vector<vector<int>>& f) {\\n        n=f.size(),m=r.size(),sort(begin(r),end(r)),sort(begin(f),end(f)),memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                pos[i][j] = max(f[i][0],r[j]) - min(f[i][0],r[j]);\\n        return func(0,0,f[0][1],r,f);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814641,
                "title": "2d-dp",
                "content": "This problem is quite tricky.\\n\\nInstead of moving robots, it helps to think that each factory repairs a certain number of *continuously positioned* robots.\\n\\nWe first sort factories and robots by position. Once sorted, we can \"assign\" a factory to repair a *continous* group of robots.\\n\\n> It can be shown that skipping a robot (so it\\'s repaired by another factory) always leads to longer total distance.\\n\\nFor a factory `i`, and robot `j`, we try to repair from 0 to `limit[i]` robots. \\n\\nSay we chose to repair `n` robots. The total distance is the distance for those `n` robots to factory `i`, and distance for remaining factories and robots `dfs(i + 1, j + n + 1)`.\\n\\nWe memoise the minimum distance in `dp[i][j]`. \\n\\n**C++**\\n```cpp\\nlong long dp[101][101] = {};\\nlong long dfs(int i, int j, vector<vector<int>>& f, vector<int>& r) {\\n    if (j >= r.size())\\n        return 0;\\n    if (i >= f.size())\\n        return 200000000000LL;\\n    if (dp[i][j] == 0) {\\n        dp[i][j] = 1 + dfs(i + 1, j, f, r);\\n        long long dist = 0;\\n        for (int n = 0; j + n < r.size() && n < f[i][1]; ++n) {\\n            dist += abs(f[i][0] - r[j + n]);\\n            dp[i][j] = min(dp[i][j], 1 + dist + dfs(i + 1, j + n + 1, f, r));\\n        }\\n    }\\n    return dp[i][j] - 1;\\n}\\nlong long minimumTotalDistance(vector<int>& r, vector<vector<int>>& f) {\\n    sort(begin(r), end(r));\\n    sort(begin(f), end(f));\\n    return dfs(0, 0, f, r);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long dp[101][101] = {};\\nlong long dfs(int i, int j, vector<vector<int>>& f, vector<int>& r) {\\n    if (j >= r.size())\\n        return 0;\\n    if (i >= f.size())\\n        return 200000000000LL;\\n    if (dp[i][j] == 0) {\\n        dp[i][j] = 1 + dfs(i + 1, j, f, r);\\n        long long dist = 0;\\n        for (int n = 0; j + n < r.size() && n < f[i][1]; ++n) {\\n            dist += abs(f[i][0] - r[j + n]);\\n            dp[i][j] = min(dp[i][j], 1 + dist + dfs(i + 1, j + n + 1, f, r));\\n        }\\n    }\\n    return dp[i][j] - 1;\\n}\\nlong long minimumTotalDistance(vector<int>& r, vector<vector<int>>& f) {\\n    sort(begin(r), end(r));\\n    sort(begin(f), end(f));\\n    return dfs(0, 0, f, r);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783296,
                "title": "c-dp-with-explanation-o-m-n-max-limit",
                "content": "The idea is simple: essentially, we are partitioning the robot into several groups, each all goes to one factory, and try to minimize the total distance. \\n\\nWe use `dp[i][j]` to represent the total distance of covering first `i` robot with first `j` factories. In this way, we do not need to keep track of which robot goes to which factory. It\\'s all lumped into the current minimum distance `dp[i][j]`. \\n\\nTo propergate, we need to enumerate the cases for `j th` factory up to `limit[j]` times. For example, if `j th` factory has a limit of 3, we only need to figure out the total distance of covering last `{0, 1, 2, 3}` robot with `j th` factory plus correspondingly value of `dp[i][j-1]`, `dp[i-1][j-1]`, `dp[i-2][j-1]` and `dp[i-3][j-1]`, which are the total distance of covering the rest of robots in the front with the `j-1 th` factory.\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        using ll = long long;\\n        \\n        int m = robot.size();\\n        int n = factory.size();\\n        ll MAX = 1e15;\\n        vector<vector<ll>> dp(m+1, vector<ll>(n+1, MAX));\\n        \\n        // initial condition, cost of covering 0 robot with first j factory is 0\\n        dp[0][0] = 0;\\n        for (int j = 1; j <= n; ++j) dp[0][j] = 0;\\n        \\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        \\n        for (int j = 1; j <= n; ++j) {\\n            int f = factory[j-1][0], d = factory[j-1][1];\\n            for (int i = 1; i <= m; ++i) {\\n                // if not cover any robot\\n                dp[i][j] = dp[i][j-1];\\n                \\n                // try to enumerate cases for current factory\\n                // there are at most limit cases or if there\\'s not enough robots\\n                ll subtotal = 0;\\n                for (int k = 1; k <= min(d, i); ++k) {\\n                    subtotal += llabs((ll)f - robot[i-k]);\\n                    dp[i][j] = min(dp[i][j], dp[i-k][j-1] + subtotal);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        using ll = long long;\\n        \\n        int m = robot.size();\\n        int n = factory.size();\\n        ll MAX = 1e15;\\n        vector<vector<ll>> dp(m+1, vector<ll>(n+1, MAX));\\n        \\n        // initial condition, cost of covering 0 robot with first j factory is 0\\n        dp[0][0] = 0;\\n        for (int j = 1; j <= n; ++j) dp[0][j] = 0;\\n        \\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        \\n        for (int j = 1; j <= n; ++j) {\\n            int f = factory[j-1][0], d = factory[j-1][1];\\n            for (int i = 1; i <= m; ++i) {\\n                // if not cover any robot\\n                dp[i][j] = dp[i][j-1];\\n                \\n                // try to enumerate cases for current factory\\n                // there are at most limit cases or if there\\'s not enough robots\\n                ll subtotal = 0;\\n                for (int k = 1; k <= min(d, i); ++k) {\\n                    subtotal += llabs((ll)f - robot[i-k]);\\n                    dp[i][j] = min(dp[i][j], dp[i-k][j-1] + subtotal);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783212,
                "title": "python-dp",
                "content": "Split a factory with limit `lim` into `lim` factories with limit `1`. \\n\\n`dp[i][j] =` the best cost to solve `0` to `i` robots with `0` to `j` factories (splited factories). So\\n- `dp[i][j] = min(dp[i][j-1], dp[i-1][j-1] + cost(i, j))`. \\n\\nNotice that all `dp[ ][j]` only use info from `dp[ ][j-1]`. So we can save some memory space by doing this DP is a good order. \\n\\n\\nBottom-up version DP:\\n```py\\ndef minimumTotalDistance(self, R: List[int], F: List[List[int]]) -> int:\\n\\tR.sort()\\n\\tF.sort()\\n\\tdp = [0] + [float(\\'inf\\')] * len(R)\\n\\tfor j, (f, l) in enumerate(F):\\n\\t\\tfor _ in range(l):\\n\\t\\t\\tfor i in range(len(R), 0, -1):\\n\\t\\t\\t\\tdp[i] = min(dp[i], dp[i-1] + abs(R[i-1]-f))\\n\\treturn dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```py\\ndef minimumTotalDistance(self, R: List[int], F: List[List[int]]) -> int:\\n\\tR.sort()\\n\\tF.sort()\\n\\tdp = [0] + [float(\\'inf\\')] * len(R)\\n\\tfor j, (f, l) in enumerate(F):\\n\\t\\tfor _ in range(l):\\n\\t\\t\\tfor i in range(len(R), 0, -1):\\n\\t\\t\\t\\tdp[i] = min(dp[i], dp[i-1] + abs(R[i-1]-f))\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2783154,
                "title": "python-3-dp-with-intuition-and-detailed-in-line-explanation",
                "content": "### Intuition\\nAll nearby robots should finally be assigned to one factory in order to minimize the total distance, as a result, we can simply work on seprate all robots into groups with each group assigned to a factory. This should be a classic dp problem. \\n\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n\\n        # calculate the total limit for first k factories and store them in the array\\n        fac_prefix_sum = [0]\\n        for _, limit in factory:\\n            fac_prefix_sum.append(fac_prefix_sum[-1] + limit)\\n            \\n        # dp[i][j] is the minimumTotalDistance for assignning the first i robots to the first j factories\\n        # when num_robots == 0, total distance should be 0 anyway\\n        # when num_factories == 0, if there is any robot, we have no way to assign it, set value to -1.\\n        dp = [[0] * (len(factory) + 1)] + [[-1] + [None] * len(factory) for _ in range(len(robot))]\\n        def helper(num_robots, num_factories):\\n            if dp[num_robots][num_factories] is None:\\n                # when do not have enough limits to repair robot, set value to -1\\n                if fac_prefix_sum[num_factories] < num_robots:\\n                    dp[num_robots][num_factories] = -1\\n                else:\\n                    # get the position and limit of the right most factory\\n                    idx, limit = factory[num_factories - 1]\\n                    best = -1\\n                    # total distance for all robot going to the right most factory\\n                    cur_distance = 0\\n\\n                    # loop through number of robots assginning to the right most factory, max number is min(limit, num_robots)\\n                    for i in range(min(num_robots, limit) + 1):\\n                        cur = helper(num_robots - i, num_factories - 1)\\n                        if cur >= 0:\\n                            cur += cur_distance\\n                            if best < 0 or cur < best:\\n                                best = cur\\n                        cur_distance += abs(robot[num_robots - 1 - i] - idx)\\n                    dp[num_robots][num_factories] = best\\n            return dp[num_robots][num_factories]\\n        return helper(len(robot), len(factory))",
                "solutionTags": [],
                "code": "### Intuition\\nAll nearby robots should finally be assigned to one factory in order to minimize the total distance, as a result, we can simply work on seprate all robots into groups with each group assigned to a factory. This should be a classic dp problem. \\n\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n\\n        # calculate the total limit for first k factories and store them in the array\\n        fac_prefix_sum = [0]\\n        for _, limit in factory:\\n            fac_prefix_sum.append(fac_prefix_sum[-1] + limit)\\n            \\n        # dp[i][j] is the minimumTotalDistance for assignning the first i robots to the first j factories\\n        # when num_robots == 0, total distance should be 0 anyway\\n        # when num_factories == 0, if there is any robot, we have no way to assign it, set value to -1.\\n        dp = [[0] * (len(factory) + 1)] + [[-1] + [None] * len(factory) for _ in range(len(robot))]\\n        def helper(num_robots, num_factories):\\n            if dp[num_robots][num_factories] is None:\\n                # when do not have enough limits to repair robot, set value to -1\\n                if fac_prefix_sum[num_factories] < num_robots:\\n                    dp[num_robots][num_factories] = -1\\n                else:\\n                    # get the position and limit of the right most factory\\n                    idx, limit = factory[num_factories - 1]\\n                    best = -1\\n                    # total distance for all robot going to the right most factory\\n                    cur_distance = 0\\n\\n                    # loop through number of robots assginning to the right most factory, max number is min(limit, num_robots)\\n                    for i in range(min(num_robots, limit) + 1):\\n                        cur = helper(num_robots - i, num_factories - 1)\\n                        if cur >= 0:\\n                            cur += cur_distance\\n                            if best < 0 or cur < best:\\n                                best = cur\\n                        cur_distance += abs(robot[num_robots - 1 - i] - idx)\\n                    dp[num_robots][num_factories] = best\\n            return dp[num_robots][num_factories]\\n        return helper(len(robot), len(factory))",
                "codeTag": "Java"
            },
            {
                "id": 2802703,
                "title": "c-dp-memorization",
                "content": "```\\ntypedef long long int ll;\\nconst ll INF = 1e15;\\n\\nclass Solution {\\n     vector<vector<int>> factories;\\n    vector<int> robots;\\n    vector<vector<ll>> dp;\\n    \\n    ll MinimumTotalDistance(int f_ind,int r_ind)\\n    {\\n        int r = robots.size();\\n        int f = factories.size();\\n        \\n        if(r_ind == r) return 0;\\n        if(f_ind == f) return INF;\\n        \\n        ll &ans = dp[f_ind][r_ind];\\n        if(ans != -1) return ans;\\n        ans = INF;\\n        \\n        int f_position = factories[f_ind][0];\\n        int f_capacity = factories[f_ind][1];\\n        \\n        for(int repaired = 0;repaired <= f_capacity;repaired++){\\n            ll repair_cost = 0;\\n            int j;\\n            for(j = r_ind;j<r && j<r_ind+repaired;j++){\\n                repair_cost += abs(robots[j]-f_position);\\n            }\\n            \\n            ans = min(ans,repair_cost + MinimumTotalDistance(f_ind+1,j));\\n        }\\n        return ans;\\n            \\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        \\n        robots = robot;\\n        factories = factory;\\n        \\n        dp.clear();\\n        dp.resize(factory.size(),vector<ll>(robots.size(),-1));\\n        \\n        return MinimumTotalDistance(0,0);\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long int ll;\\nconst ll INF = 1e15;\\n\\nclass Solution {\\n     vector<vector<int>> factories;\\n    vector<int> robots;\\n    vector<vector<ll>> dp;\\n    \\n    ll MinimumTotalDistance(int f_ind,int r_ind)\\n    {\\n        int r = robots.size();\\n        int f = factories.size();\\n        \\n        if(r_ind == r) return 0;\\n        if(f_ind == f) return INF;\\n        \\n        ll &ans = dp[f_ind][r_ind];\\n        if(ans != -1) return ans;\\n        ans = INF;\\n        \\n        int f_position = factories[f_ind][0];\\n        int f_capacity = factories[f_ind][1];\\n        \\n        for(int repaired = 0;repaired <= f_capacity;repaired++){\\n            ll repair_cost = 0;\\n            int j;\\n            for(j = r_ind;j<r && j<r_ind+repaired;j++){\\n                repair_cost += abs(robots[j]-f_position);\\n            }\\n            \\n            ans = min(ans,repair_cost + MinimumTotalDistance(f_ind+1,j));\\n        }\\n        return ans;\\n            \\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        \\n        robots = robot;\\n        factories = factory;\\n        \\n        dp.clear();\\n        dp.resize(factory.size(),vector<ll>(robots.size(),-1));\\n        \\n        return MinimumTotalDistance(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783461,
                "title": "python3-yet-another-dp-solution-but-not-3d",
                "content": "* 3D DP solution is difficult to come up and understand\\n* For those who can not understand 3D DP solution, a simple trick here is flatten the **factory** and then apply 2D DP. Ex, flatten `[[2, 2], [6, 2]]` to `[2, 2, 6, 6]`.\\n* `dp[i][j]`: Mimum distance to travel by first `i + 1` robot, using first `j + 1` factory.\\n\\n<iframe src=\"https://leetcode.com/playground/9aZLZzrU/shared\" frameBorder=\"0\" width=\"700\" height=\"500\"></iframe>\\n\\n**Complexity analysis:**\\n* Time: `O(N^3)`\\n* Space : `O(N^3)`",
                "solutionTags": [],
                "code": "* 3D DP solution is difficult to come up and understand\\n* For those who can not understand 3D DP solution, a simple trick here is flatten the **factory** and then apply 2D DP. Ex, flatten `[[2, 2], [6, 2]]` to `[2, 2, 6, 6]`.\\n* `dp[i][j]`: Mimum distance to travel by first `i + 1` robot, using first `j + 1` factory.\\n\\n<iframe src=\"https://leetcode.com/playground/9aZLZzrU/shared\" frameBorder=\"0\" width=\"700\" height=\"500\"></iframe>\\n\\n**Complexity analysis:**\\n* Time: `O(N^3)`\\n* Space : `O(N^3)`",
                "codeTag": "Unknown"
            },
            {
                "id": 2783336,
                "title": "4-minimum-total-distance-traveled-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& a, vector<vector<int>>& b) {\\n        vector<unordered_map<int, long long>> dp;\\n        \\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        \\n        const int x = int(a.size());\\n        const int y = int(b.size());\\n        dp.resize(y);\\n        \\n        auto AddToMap = [&](int index, int m, long long alt) {\\n\\n            unordered_map<int, long long>& x = dp[index];\\n            if (x.count(m) < 1) {\\n                x[m] = alt;\\n            } else {\\n                x[m] = min(x[m], alt);\\n            }\\n        };\\n        \\n        for (int i=0; i<y; i++) {\\n            long long prev_cost = 0;\\n            if (i > 0) {\\n                const unordered_map<int, long long>& prev = dp[i-1];\\n                for (const auto& pp : prev) {\\n                    long long c = pp.second;\\n                    AddToMap(i, pp.first, c);\\n                    for (int res = pp.first; res < pp.first + b[i][1]; res++) { \\n                        if (res < x) {\\n                            c += abs(a[res] - b[i][0]);\\n                            AddToMap(i, res+1, c);\\n                        }\\n                    }\\n                }\\n            } else {\\n                long long c = 0;\\n                AddToMap(i, 0, c);\\n                for (int res=0; res<b[i][1]; res++) {\\n                    c += abs(a[res] - b[i][0]);\\n                    AddToMap(i, res+1, c);\\n                }\\n            }\\n        }\\n        \\n        return dp.back()[a.size()];\\n    }\\n};\\n```\\n\\n**comment your solutions** \\n# Upvote it",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& a, vector<vector<int>>& b) {\\n        vector<unordered_map<int, long long>> dp;\\n        \\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        \\n        const int x = int(a.size());\\n        const int y = int(b.size());\\n        dp.resize(y);\\n        \\n        auto AddToMap = [&](int index, int m, long long alt) {\\n\\n            unordered_map<int, long long>& x = dp[index];\\n            if (x.count(m) < 1) {\\n                x[m] = alt;\\n            } else {\\n                x[m] = min(x[m], alt);\\n            }\\n        };\\n        \\n        for (int i=0; i<y; i++) {\\n            long long prev_cost = 0;\\n            if (i > 0) {\\n                const unordered_map<int, long long>& prev = dp[i-1];\\n                for (const auto& pp : prev) {\\n                    long long c = pp.second;\\n                    AddToMap(i, pp.first, c);\\n                    for (int res = pp.first; res < pp.first + b[i][1]; res++) { \\n                        if (res < x) {\\n                            c += abs(a[res] - b[i][0]);\\n                            AddToMap(i, res+1, c);\\n                        }\\n                    }\\n                }\\n            } else {\\n                long long c = 0;\\n                AddToMap(i, 0, c);\\n                for (int res=0; res<b[i][1]; res++) {\\n                    c += abs(a[res] - b[i][0]);\\n                    AddToMap(i, res+1, c);\\n                }\\n            }\\n        }\\n        \\n        return dp.back()[a.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796503,
                "title": "proof-on-why-sorting-works",
                "content": "Many solutions used sorting, but I found out that none of the explanations about why it led to an optimal solution sounded convincing to me. Some of them, I guess, seemed to do some circular reasoning by already assuming that the optimal solution is from the sorted ones.\\n\\nSo, the question is why a contiguous sequence of robots have to be assigned to a factory and next contiguous sequence of robots have to be assigned to a next factory, not to a previous one in an optimal solution. I got an intuition by doing case study as below. I first flattened the problems into a smaller structure; We only have 2 robots and 2 factories and a factory can repair only one robot.\\n\\n```\\n# Terminologies\\nr1, r2: robot location, r1 < r2\\nf1, f2: factory location, f1 < f2\\ndistance 1: distance we get by assigning r1 to f1 and r2 to f2.\\ndistance 2: distance we get by assigning r1 to f2 and r2 to f1.\\n\\n# Case study\\n\\nIn this setup, we should think about the 6 cases according to the reletive locations of the robots and factories.\\n\\n### Case 1\\n- Locations:\\n     r1    r2\\n  f1    f2\\n \\n- distance 1: r1 - f1 + r2 - f2\\n- distance 2: f2 - r1 + r2 - f1\\n- result: distance 1 < distance 2\\n\\n### Case 2\\n- Locations:\\n     r1    r2\\n  f1          f2\\n \\n- distance 1: r1 - f1 + f2 - r2\\n- distance 2: f2 - r1 + r2 - f1\\n- result: distance 1 < distance 2\\n\\n### Case 3\\n- Locations:\\n     r1    r2\\n        f1    f2\\n\\n- distance 1: f1 - r1 + f2 - r2\\n- distance 2: f2 - r1 + r2 - f1\\n- result: distance 1 < distance 2\\n\\n### Case 4\\n- Locations:\\n            r1    r2\\n  f1    f2\\n\\n- distance 1: r1 - f1 + r2 - f2\\n- distance 2: r1 - f2 + r2 - f1\\n- result: distance 1 == distance 2\\n\\n### Case 5\\n- Locations:\\n     r1        r2\\n        f1  f2\\n\\n- distance 1: f1 - r1 + r2 - f2\\n- distance 2: f2 - r1 + r2 - f1\\n- result: distance 1 < distance 2\\n\\n### Case 6\\n- Locations:\\n     r1    r2\\n\\t           f1    f2\\n\\n- distance 1: f1 - r1 + f2 - r2\\n- distance 2: f2 - r1 + f1 - r2\\n- result: distance 1 == distance 2\\n```\\n\\nIn all cases, the distance by assigning r1 to f1 and r2 to f2 is shorter than or equal to the one by assigning r1 to f2 and r2 to f1. In case 4 and 6, the two distances are the same, which means that we can just assign r1 to f1 and r2 to f2 in those cases.\\n\\nThis result implies that if r1 has been assigned to f1, r2 does not need to care about any previous factories of f1 and only needs to care about the same or next factories of f1, and I think it explains why sorting works for this problem.",
                "solutionTags": [],
                "code": "```\\n# Terminologies\\nr1, r2: robot location, r1 < r2\\nf1, f2: factory location, f1 < f2\\ndistance 1: distance we get by assigning r1 to f1 and r2 to f2.\\ndistance 2: distance we get by assigning r1 to f2 and r2 to f1.\\n\\n# Case study\\n\\nIn this setup, we should think about the 6 cases according to the reletive locations of the robots and factories.\\n\\n### Case 1\\n- Locations:\\n     r1    r2\\n  f1    f2\\n \\n- distance 1: r1 - f1 + r2 - f2\\n- distance 2: f2 - r1 + r2 - f1\\n- result: distance 1 < distance 2\\n\\n### Case 2\\n- Locations:\\n     r1    r2\\n  f1          f2\\n \\n- distance 1: r1 - f1 + f2 - r2\\n- distance 2: f2 - r1 + r2 - f1\\n- result: distance 1 < distance 2\\n\\n### Case 3\\n- Locations:\\n     r1    r2\\n        f1    f2\\n\\n- distance 1: f1 - r1 + f2 - r2\\n- distance 2: f2 - r1 + r2 - f1\\n- result: distance 1 < distance 2\\n\\n### Case 4\\n- Locations:\\n            r1    r2\\n  f1    f2\\n\\n- distance 1: r1 - f1 + r2 - f2\\n- distance 2: r1 - f2 + r2 - f1\\n- result: distance 1 == distance 2\\n\\n### Case 5\\n- Locations:\\n     r1        r2\\n        f1  f2\\n\\n- distance 1: f1 - r1 + r2 - f2\\n- distance 2: f2 - r1 + r2 - f1\\n- result: distance 1 < distance 2\\n\\n### Case 6\\n- Locations:\\n     r1    r2\\n\\t           f1    f2\\n\\n- distance 1: f1 - r1 + f2 - r2\\n- distance 2: f2 - r1 + f1 - r2\\n- result: distance 1 == distance 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783686,
                "title": "java-use-dp-to-memorize-the-minimum-costs-to-move-0-i-1-robots-to-0-j-1-factories",
                "content": "# Intuition\\nIn the optimal solution, there should be no crossings between robots.\\n\\n# Approach\\nCreate a matrix `dp` where `dp[i][j]` is the minimum costs to move [0, i -1] robots to [0, j - 1] factories.\\nSort the robot and the factory by their positions.\\nGiven the intuition, `dp[i][j]` is the minimum among all `dp[i - k][j - 1] + v` where `v` is cost to move [i - k, i - 1] robots to factory `j`. `k` is from 0 to the limit of factory `j`.\\n\\n# Complexity\\n\\nAssume m is the number of robots and n is the number of factories:\\n\\n- Time complexity: $O(m^2n)$\\n\\n- Space complexity: $O(mn)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        int m = robot.size(), n = factory.length;\\n        long[][] dp = new long[m + 1][n + 1];\\n        Arrays.sort(factory, (f1, f2) -> f1[0] - f2[0]);\\n        Collections.sort(robot);\\n        for (int i = 1; i <= m; i++) dp[i][0] = 200000000001L; // impossible to move robots when there is no factory\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i + 1][j + 1] = dp[i + 1][j];\\n                long v = 0;\\n                for (int k = i; k >= 0 && k > i - factory[j][1]; k--) {\\n                    v += Math.abs(factory[j][0] - robot.get(k));\\n                    dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[k][j] + v);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        int m = robot.size(), n = factory.length;\\n        long[][] dp = new long[m + 1][n + 1];\\n        Arrays.sort(factory, (f1, f2) -> f1[0] - f2[0]);\\n        Collections.sort(robot);\\n        for (int i = 1; i <= m; i++) dp[i][0] = 200000000001L; // impossible to move robots when there is no factory\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i + 1][j + 1] = dp[i + 1][j];\\n                long v = 0;\\n                for (int k = i; k >= 0 && k > i - factory[j][1]; k--) {\\n                    v += Math.abs(factory[j][0] - robot.get(k));\\n                    dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[k][j] + v);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783295,
                "title": "c-min-cost-max-flow-solution",
                "content": "For some reason, I did not think of the DP solution during the contest. Instead, the first thing that came to mind was matching. I thought of matching each robot to a factory.\\n\\nFirst, we can make a dummy source and sink nodes. The source node can connect to all of the robots. The cost of all of these edges is 0, and the capacity is 1, to make sure that each robot is matched.\\n\\nThen, we can connect each robot to every factory with an edge of capacity 1, but this time with a cost. The cost is the distance between the robot and the factory, because that is how much it would cost to match those two together.\\n\\nFinally, we can connect each factory to the sink node with a capacity of the limit of the factory, to make sure that no factory has more than limit_i robots, and cost 0.\\n\\nAfter all of this, we can run a min cost max flow from the dummy source to the dummy sink, and the total cost will be the minimum cost of pairing each robot to the best possible factory.\\n\\nHere is my sample C++ code:\\n\\n```\\ntypedef long long ll;\\nclass Solution \\n{\\npublic:\\n    struct pq\\n    {\\n        ll len, par, cur;\\n        const bool operator>(const pq& other) const\\n        {\\n            return len > other.len;\\n        }\\n    };\\n    const ll inf = 1e15;\\n    vector<ll> adj[210];\\n    priority_queue<pq, vector<pq>, greater<pq>> nextInLine;\\n    bitset<210> visited;\\n    ll cur[210][210], lim[210][210], cost[210][210], par[210], dist[210], upDist[210], len[210];\\n    queue<ll> q;\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) \\n    {\\n        ll n, m, st, en, a, b, c, d, curN, curD, curP, curF, flow = 0;\\n        st = 0;\\n        en = (int)(robot.size()+factory.size())+1;\\n        for(int i = 0; i < robot.size(); i ++)\\n        {\\n            adj[0].push_back(i+1); adj[i+1].push_back(0);\\n            lim[0][i+1] += 1;\\n        }\\n        for(int i = 0; i < robot.size(); i ++)\\n            for(int j = 0; j < factory.size(); j ++)\\n            {\\n                adj[i+1].push_back(j+robot.size()+1); adj[j+robot.size()+1].push_back(i+1);\\n                lim[i+1][j+robot.size()+1] += 1; cost[i+1][j+robot.size()+1] += abs(robot[i]-factory[j][0]); cost[j+robot.size()+1][i+1] -= abs(robot[i]-factory[j][0]);\\n            }\\n        for(int i = 0; i < factory.size(); i ++)\\n        {\\n            adj[i+robot.size()+1].push_back(en); adj[en].push_back(i+robot.size()+1);\\n            lim[i+robot.size()+1][en] += factory[i][1];\\n        }\\n        n = en+1;\\n        for(int i = 0; i < n; i ++)\\n            dist[i] = inf;\\n        dist[st] = 0; q.push(st);\\n        while(!q.empty())\\n        {\\n            curN = q.front(); q.pop();\\n            for(auto it : adj[curN])\\n                if(lim[curN][it])\\n                    if(dist[curN] + cost[curN][it] < dist[it])\\n                        dist[it] = dist[curN] + cost[curN][it], q.push(it);\\n        }\\n        while(true)\\n        {\\n            nextInLine.push({0, -1, st});\\n            visited.reset();\\n            fill(upDist, upDist+n, inf); fill(len, len+n, inf);\\n            len[st] = 0;\\n            while(!nextInLine.empty())\\n            {\\n                curD = nextInLine.top().len; curP = nextInLine.top().par; curN = nextInLine.top().cur;\\n                nextInLine.pop();\\n                if(len[curN] < curD) continue;\\n                upDist[curN] = curD;\\n                par[curN] = curP;\\n                if(curN == en)\\n                {\\n                    d = curD;\\n                    continue;\\n                }\\n                for(ll it : adj[curN])\\n                    if(cur[curN][it] != lim[curN][it] && len[curN] + cost[curN][it] + dist[curN] - dist[it] < len[it])\\n                    {\\n                        nextInLine.push({len[curN] + cost[curN][it] + dist[curN] - dist[it], curN, it});\\n                        len[it] = len[curN] + cost[curN][it] + dist[curN] - dist[it];\\n                    }\\n            }\\n            if(len[en] == inf) break;\\n            curF = inf; curN = en;\\n            while(curN != st)\\n            {\\n                curF = min(curF, lim[par[curN]][curN] - cur[par[curN]][curN]);\\n                curN = par[curN];\\n            }\\n            curN = en;\\n            while(curN != st)\\n            {\\n                cur[par[curN]][curN] += curF;\\n                cur[curN][par[curN]] -= curF;\\n                curN = par[curN];\\n            }\\n            flow += curF * (d + dist[en]);\\n            for(int i = 0; i < n; i ++)\\n                dist[i] += upDist[i];\\n        }\\n        return flow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution \\n{\\npublic:\\n    struct pq\\n    {\\n        ll len, par, cur;\\n        const bool operator>(const pq& other) const\\n        {\\n            return len > other.len;\\n        }\\n    };\\n    const ll inf = 1e15;\\n    vector<ll> adj[210];\\n    priority_queue<pq, vector<pq>, greater<pq>> nextInLine;\\n    bitset<210> visited;\\n    ll cur[210][210], lim[210][210], cost[210][210], par[210], dist[210], upDist[210], len[210];\\n    queue<ll> q;\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) \\n    {\\n        ll n, m, st, en, a, b, c, d, curN, curD, curP, curF, flow = 0;\\n        st = 0;\\n        en = (int)(robot.size()+factory.size())+1;\\n        for(int i = 0; i < robot.size(); i ++)\\n        {\\n            adj[0].push_back(i+1); adj[i+1].push_back(0);\\n            lim[0][i+1] += 1;\\n        }\\n        for(int i = 0; i < robot.size(); i ++)\\n            for(int j = 0; j < factory.size(); j ++)\\n            {\\n                adj[i+1].push_back(j+robot.size()+1); adj[j+robot.size()+1].push_back(i+1);\\n                lim[i+1][j+robot.size()+1] += 1; cost[i+1][j+robot.size()+1] += abs(robot[i]-factory[j][0]); cost[j+robot.size()+1][i+1] -= abs(robot[i]-factory[j][0]);\\n            }\\n        for(int i = 0; i < factory.size(); i ++)\\n        {\\n            adj[i+robot.size()+1].push_back(en); adj[en].push_back(i+robot.size()+1);\\n            lim[i+robot.size()+1][en] += factory[i][1];\\n        }\\n        n = en+1;\\n        for(int i = 0; i < n; i ++)\\n            dist[i] = inf;\\n        dist[st] = 0; q.push(st);\\n        while(!q.empty())\\n        {\\n            curN = q.front(); q.pop();\\n            for(auto it : adj[curN])\\n                if(lim[curN][it])\\n                    if(dist[curN] + cost[curN][it] < dist[it])\\n                        dist[it] = dist[curN] + cost[curN][it], q.push(it);\\n        }\\n        while(true)\\n        {\\n            nextInLine.push({0, -1, st});\\n            visited.reset();\\n            fill(upDist, upDist+n, inf); fill(len, len+n, inf);\\n            len[st] = 0;\\n            while(!nextInLine.empty())\\n            {\\n                curD = nextInLine.top().len; curP = nextInLine.top().par; curN = nextInLine.top().cur;\\n                nextInLine.pop();\\n                if(len[curN] < curD) continue;\\n                upDist[curN] = curD;\\n                par[curN] = curP;\\n                if(curN == en)\\n                {\\n                    d = curD;\\n                    continue;\\n                }\\n                for(ll it : adj[curN])\\n                    if(cur[curN][it] != lim[curN][it] && len[curN] + cost[curN][it] + dist[curN] - dist[it] < len[it])\\n                    {\\n                        nextInLine.push({len[curN] + cost[curN][it] + dist[curN] - dist[it], curN, it});\\n                        len[it] = len[curN] + cost[curN][it] + dist[curN] - dist[it];\\n                    }\\n            }\\n            if(len[en] == inf) break;\\n            curF = inf; curN = en;\\n            while(curN != st)\\n            {\\n                curF = min(curF, lim[par[curN]][curN] - cur[par[curN]][curN]);\\n                curN = par[curN];\\n            }\\n            curN = en;\\n            while(curN != st)\\n            {\\n                cur[par[curN]][curN] += curF;\\n                cur[curN][par[curN]] -= curF;\\n                curN = par[curN];\\n            }\\n            flow += curF * (d + dist[en]);\\n            for(int i = 0; i < n; i ++)\\n                dist[i] += upDist[i];\\n        }\\n        return flow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783120,
                "title": "cxx-d-p-for-the-win",
                "content": "D.P. for the win !!!\\n\\nFirst, we sort all Robots so that their positions are from left 2 right, & sort all Factories so that their positions are from left 2 right.\\n\\nThe D.P. table is defined as follows:\\n\\n```\\nvector<unordered_map<int, long long>> dp;\\n```\\n\\nIt is interpreted as follows:\\n\\n`dp[i][j] = k`, means \"Factory `i` has repaired `j` robots from left to right; the minimal cost of doing so is `k`\".\\n\\nThe D.P. table is filled as follows:\\n\\n* For each Factory, we do the following:\\n  - Check the D.P. table for the previous factory and start from there\\n  - In other words, `dp[i][j]` comes from the minimum cost of:\\n    *`dp[i-1][0]` plus the cost of repairing robots #1..j\\n    *`dp[i-1][1]` plus the cost of repairing robots #2..j\\n    *`dp[i-1][2]` plus the cost of repairing robots #3..j\\n    *so on and so forth . . .\\n    *`dp[i-1][j]` plus having the current Factory stay idle & do nothing.\\n\\nFinally, we return `dp[factory.size()-1][robot.size()]`.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        vector<unordered_map<int, long long>> dp;\\n        \\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        \\n        const int M = int(robot.size());\\n        const int N = int(factory.size());\\n        dp.resize(N);\\n        \\n        auto AddToMap = [&](int idx, int k, long long elt) {\\n            unordered_map<int, long long>& m = dp[idx];\\n            if (m.count(k) < 1) {\\n                m[k] = elt;\\n            } else {\\n                m[k] = min(m[k], elt);\\n            }\\n        };\\n        \\n        for (int i=0; i<N; i++) {\\n            long long prev_cost = 0;\\n            if (i > 0) {\\n                const unordered_map<int, long long>& prev = dp[i-1];\\n                for (const auto& pp : prev) {\\n                    long long cand = pp.second;\\n                    AddToMap(i, pp.first, cand);\\n                    for (int rep = pp.first; rep < pp.first + factory[i][1]; rep++) { // How many do I repair?\\n                        if (rep < M) {\\n                            cand += abs(robot[rep] - factory[i][0]);\\n                            AddToMap(i, rep+1, cand);\\n                        }\\n                    }\\n                }\\n            } else {\\n                long long cand = 0;\\n                AddToMap(i, 0, cand);\\n                for (int rep=0; rep<factory[i][1]; rep++) {\\n                    cand += abs(robot[rep] - factory[i][0]);\\n                    AddToMap(i, rep+1, cand);\\n                }\\n            }\\n        }\\n        \\n        return dp.back()[robot.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<unordered_map<int, long long>> dp;\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        vector<unordered_map<int, long long>> dp;\\n        \\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        \\n        const int M = int(robot.size());\\n        const int N = int(factory.size());\\n        dp.resize(N);\\n        \\n        auto AddToMap = [&](int idx, int k, long long elt) {\\n            unordered_map<int, long long>& m = dp[idx];\\n            if (m.count(k) < 1) {\\n                m[k] = elt;\\n            } else {\\n                m[k] = min(m[k], elt);\\n            }\\n        };\\n        \\n        for (int i=0; i<N; i++) {\\n            long long prev_cost = 0;\\n            if (i > 0) {\\n                const unordered_map<int, long long>& prev = dp[i-1];\\n                for (const auto& pp : prev) {\\n                    long long cand = pp.second;\\n                    AddToMap(i, pp.first, cand);\\n                    for (int rep = pp.first; rep < pp.first + factory[i][1]; rep++) { // How many do I repair?\\n                        if (rep < M) {\\n                            cand += abs(robot[rep] - factory[i][0]);\\n                            AddToMap(i, rep+1, cand);\\n                        }\\n                    }\\n                }\\n            } else {\\n                long long cand = 0;\\n                AddToMap(i, 0, cand);\\n                for (int rep=0; rep<factory[i][1]; rep++) {\\n                    cand += abs(robot[rep] - factory[i][0]);\\n                    AddToMap(i, rep+1, cand);\\n                }\\n            }\\n        }\\n        \\n        return dp.back()[robot.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796145,
                "title": "java-greedy-solution-beats-100-time-and-memory-o-rxfxf-2ms",
                "content": "First of all, we have to keep in mind the following idea:\\n**If one robot is on the left side from another then it can\\'t be assigned to a factory that is on the right from the one that is second robot assigned to.**\\n\\nWith that said, we need to take robots one by one from rightmost to the leftmost and search for the most optimal factory (with minimum distance). As we process robots from right to left, we know that every time we will not choose the factory on the right from the previous one.\\nHowever sometimes it maybe better to shift already processed to the right in order to save some points (distance).\\n\\n```\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] f) {\\n        // sort factories :\\n        // 1. move all factories with 0-capacity to the end\\n        // 2. sort everything else by x-position in asc order\\n        Arrays.sort(f, (a, b) -> (a[1] == 0) ? 1 : (b[1] == 0) ? -1 : a[0] - b[0]);\\n        \\n        // Sort robots by x-position in asc order\\n        // As we don\\'t know the implementation of the List that is passed, it is better to map it to an array explicitly\\n        int[] r = new int[robot.size()];\\n        int i = 0;\\n        for (int x : robot) r[i++] = x;\\n        Arrays.sort(r);\\n        \\n        // An array to be used for tracking robots assigned to each factory\\n        int[][] d = new int[f.length][2];\\n        \\n        // For each robot starting from the rightmost find the most optimal destination factory\\n        // and add it\\'s cost to the result.\\n        long res = 0;\\n        for (i = r.length - 1; i >= 0; i--) res += pop(d, i, r, f);        \\n        return res;\\n    }\\n    \\n    long pop(int[][] d, int i, int[] r, int[][] f) {\\n        long cost = Long.MAX_VALUE;\\n        int j;\\n        // try assigning robot to each factory starting from the leftmost\\n        for (j = 0; j < d.length; j++) {\\n            // cost of adding robot to the current factory\\n            long t = Math.abs(r[i] - f[j][0]);\\n            int tj = j;\\n            // if current factory is full calculate the cost of moving the rightmost robot in the factory to the next one\\n            // and add the calculated cost to the current cost.\\n            // repeat the same action until we fit our robots to factories.\\n            while (tj < d.length && d[tj][1] == f[tj][1]) {\\n                // if we faced a factory with 0-capactity or the rightmost factory\\n                // it would mean we reached the end and cannot fit our robot to the current factory\\n                if (d[tj][1] == 0 || tj == d.length-1) {\\n                    t = Long.MAX_VALUE;\\n                    break;\\n                }\\n                int l = d[tj][0] + d[tj][1] - 1;\\n                t += Math.abs(f[tj+1][0] - r[l]) - Math.abs(f[tj][0] - r[l]);\\n                ++tj;\\n            }\\n            // if the cost for adding robot to the current factory is greater than the previous one\\n            // it means that the previous one was the most optimal\\n            if (t > cost) {\\n                break;\\n            }\\n            cost = t;\\n        }\\n        // assign current robot to the previous factory and move any non-fit robots to the right\\n        d[j-1][0] = i;\\n        int tj = j-1;\\n        while (d[tj][1] == f[tj][1]) {\\n            d[tj+1][0] = d[tj][0] + d[tj][1];\\n           ++tj;\\n        }\\n        d[tj][1]++;\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] f) {\\n        // sort factories :\\n        // 1. move all factories with 0-capacity to the end\\n        // 2. sort everything else by x-position in asc order\\n        Arrays.sort(f, (a, b) -> (a[1] == 0) ? 1 : (b[1] == 0) ? -1 : a[0] - b[0]);\\n        \\n        // Sort robots by x-position in asc order\\n        // As we don\\'t know the implementation of the List that is passed, it is better to map it to an array explicitly\\n        int[] r = new int[robot.size()];\\n        int i = 0;\\n        for (int x : robot) r[i++] = x;\\n        Arrays.sort(r);\\n        \\n        // An array to be used for tracking robots assigned to each factory\\n        int[][] d = new int[f.length][2];\\n        \\n        // For each robot starting from the rightmost find the most optimal destination factory\\n        // and add it\\'s cost to the result.\\n        long res = 0;\\n        for (i = r.length - 1; i >= 0; i--) res += pop(d, i, r, f);        \\n        return res;\\n    }\\n    \\n    long pop(int[][] d, int i, int[] r, int[][] f) {\\n        long cost = Long.MAX_VALUE;\\n        int j;\\n        // try assigning robot to each factory starting from the leftmost\\n        for (j = 0; j < d.length; j++) {\\n            // cost of adding robot to the current factory\\n            long t = Math.abs(r[i] - f[j][0]);\\n            int tj = j;\\n            // if current factory is full calculate the cost of moving the rightmost robot in the factory to the next one\\n            // and add the calculated cost to the current cost.\\n            // repeat the same action until we fit our robots to factories.\\n            while (tj < d.length && d[tj][1] == f[tj][1]) {\\n                // if we faced a factory with 0-capactity or the rightmost factory\\n                // it would mean we reached the end and cannot fit our robot to the current factory\\n                if (d[tj][1] == 0 || tj == d.length-1) {\\n                    t = Long.MAX_VALUE;\\n                    break;\\n                }\\n                int l = d[tj][0] + d[tj][1] - 1;\\n                t += Math.abs(f[tj+1][0] - r[l]) - Math.abs(f[tj][0] - r[l]);\\n                ++tj;\\n            }\\n            // if the cost for adding robot to the current factory is greater than the previous one\\n            // it means that the previous one was the most optimal\\n            if (t > cost) {\\n                break;\\n            }\\n            cost = t;\\n        }\\n        // assign current robot to the previous factory and move any non-fit robots to the right\\n        d[j-1][0] = i;\\n        int tj = j-1;\\n        while (d[tj][1] == f[tj][1]) {\\n            d[tj+1][0] = d[tj][0] + d[tj][1];\\n           ++tj;\\n        }\\n        d[tj][1]++;\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789634,
                "title": "java-memoization-approach-along-with-hindi-comments",
                "content": "```\\nclass Solution {\\n    int n=0;\\n    int m=0;\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        ArrayList<Integer> fac=new ArrayList<>();\\n        for(int i=0;i<factory.length;i++){\\n            for(int j=0;j<factory[i][1];j++){\\n                fac.add(factory[i][0]); // sare factory ke position ko limit time add\\n            }\\n        }\\n        Collections.sort(fac);\\n        Collections.sort(robot);\\n         m=fac.size();\\n         n=robot.size();\\n        long dp[][]=new long[n+1][m+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(n,m,dp,fac,robot);\\n    }\\n    public long solve(int i,int j,long dp[][],ArrayList<Integer> fac,List<Integer> robot){\\n        if(i==0){\\n            return 0L; //consumed all robot\\n        }\\n        if(j==0){\\n            return Long.MAX_VALUE; //consumed all factory\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        long ans1=solve(i-1,j-1,dp,fac,robot); //ye factory cosume hoke jo minimum\\n        long ans2=solve(i,j-1,dp,fac,robot);//ye factory ni consume honne pe minimum ya skip krne pe\\n       if(ans1!=Long.MAX_VALUE){\\n           ans2= Math.min(ans1+Math.abs(robot.get(i-1)-fac.get(j-1)),ans2);\\n       }\\n        return dp[i][j]=ans2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n=0;\\n    int m=0;\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        ArrayList<Integer> fac=new ArrayList<>();\\n        for(int i=0;i<factory.length;i++){\\n            for(int j=0;j<factory[i][1];j++){\\n                fac.add(factory[i][0]); // sare factory ke position ko limit time add\\n            }\\n        }\\n        Collections.sort(fac);\\n        Collections.sort(robot);\\n         m=fac.size();\\n         n=robot.size();\\n        long dp[][]=new long[n+1][m+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(n,m,dp,fac,robot);\\n    }\\n    public long solve(int i,int j,long dp[][],ArrayList<Integer> fac,List<Integer> robot){\\n        if(i==0){\\n            return 0L; //consumed all robot\\n        }\\n        if(j==0){\\n            return Long.MAX_VALUE; //consumed all factory\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        long ans1=solve(i-1,j-1,dp,fac,robot); //ye factory cosume hoke jo minimum\\n        long ans2=solve(i,j-1,dp,fac,robot);//ye factory ni consume honne pe minimum ya skip krne pe\\n       if(ans1!=Long.MAX_VALUE){\\n           ans2= Math.min(ans1+Math.abs(robot.get(i-1)-fac.get(j-1)),ans2);\\n       }\\n        return dp[i][j]=ans2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783393,
                "title": "simple-c-dp-with-recursion-and-memoization",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially the robots array and factory array are sorted.\\n\\nThen a recursive dp is applied with: \\n$$i$$ denotes the index of robots array\\n$$j$$ denotes the index of robots array\\n\\nEach Factory choses a subarray of robots with size >= 0.\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll dp[301][301];\\n    ll rec(int i, int j, vector<int>& ro, vector<vector<int>>& fac){\\n        \\n        if(i >= ro.size()){\\n            return 0;\\n        }\\n        if(j >= fac.size()){\\n            return 1e12;\\n        }\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        ll limit = fac[j][1];\\n        // Factory doesn\\'t chose any robots\\n        ll ans = rec(i, j+1, ro, fac);\\n        ll dist = 0;\\n            for(int itr = 0;itr<limit;itr++){\\n                // Factory choses itr + 1 number of robots after the index i\\n                if(i + itr < ro.size()){\\n                    // distance is calculated from the factory to i + itr robot\\n                    dist += abs(ro[i + itr] - fac[j][0]);\\n                    ans = min(ans, dist+ rec(i + itr + 1, j+1, ro, fac));\\n                }\\n            }\\n        \\n        return dp[i][j] = ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& ro, vector<vector<int>>& fac) {\\n        ll ans = 0;\\n        sort(ro.begin(), ro.end());\\n        sort(fac.begin(), fac.end());\\n        \\n        memset(dp, -1, sizeof(dp));\\n        ans = rec(0, 0, ro, fac);        \\n        return ans;       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll dp[301][301];\\n    ll rec(int i, int j, vector<int>& ro, vector<vector<int>>& fac){\\n        \\n        if(i >= ro.size()){\\n            return 0;\\n        }\\n        if(j >= fac.size()){\\n            return 1e12;\\n        }\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        ll limit = fac[j][1];\\n        // Factory doesn\\'t chose any robots\\n        ll ans = rec(i, j+1, ro, fac);\\n        ll dist = 0;\\n            for(int itr = 0;itr<limit;itr++){\\n                // Factory choses itr + 1 number of robots after the index i\\n                if(i + itr < ro.size()){\\n                    // distance is calculated from the factory to i + itr robot\\n                    dist += abs(ro[i + itr] - fac[j][0]);\\n                    ans = min(ans, dist+ rec(i + itr + 1, j+1, ro, fac));\\n                }\\n            }\\n        \\n        return dp[i][j] = ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& ro, vector<vector<int>>& fac) {\\n        ll ans = 0;\\n        sort(ro.begin(), ro.end());\\n        sort(fac.begin(), fac.end());\\n        \\n        memset(dp, -1, sizeof(dp));\\n        ans = rec(0, 0, ro, fac);        \\n        return ans;       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482923,
                "title": "c-easy-to-understand-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n\\n    long long fn(int i, int j, vector<int>& robot, vector<int>& factory){\\n        //i -> robot index\\n        //j -> factor index\\n\\n        if(i >= robot.size()){\\n            return 0;\\n        }\\n\\n        if(j >= factory.size()){\\n            return LLONG_MAX;\\n        }\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        long long a = fn(i+1, j+1, robot, factory);\\n        if(a != LLONG_MAX){\\n            a += abs(robot[i] - factory[j]);\\n        }\\n\\n        long long b = fn(i, j+1, robot, factory);\\n\\n        return dp[i][j] = min(a, b);\\n    }\\n\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n\\n        vector<int> v;\\n        for(auto& fac : factory){\\n            while(fac[1]--){\\n                v.push_back(fac[0]);\\n            }\\n        }\\n\\n        dp.resize(robot.size()+1, vector<long long>(v.size()+1, -1));\\n\\n        return fn(0, 0, robot, v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n\\n    long long fn(int i, int j, vector<int>& robot, vector<int>& factory){\\n        //i -> robot index\\n        //j -> factor index\\n\\n        if(i >= robot.size()){\\n            return 0;\\n        }\\n\\n        if(j >= factory.size()){\\n            return LLONG_MAX;\\n        }\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        long long a = fn(i+1, j+1, robot, factory);\\n        if(a != LLONG_MAX){\\n            a += abs(robot[i] - factory[j]);\\n        }\\n\\n        long long b = fn(i, j+1, robot, factory);\\n\\n        return dp[i][j] = min(a, b);\\n    }\\n\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n\\n        vector<int> v;\\n        for(auto& fac : factory){\\n            while(fac[1]--){\\n                v.push_back(fac[0]);\\n            }\\n        }\\n\\n        dp.resize(robot.size()+1, vector<long long>(v.size()+1, -1));\\n\\n        return fn(0, 0, robot, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816471,
                "title": "recursion-memoization",
                "content": "\\n# Approach\\nQuite similar to knapsack with variable cost.\\n\\n# Time Complexity\\n\\n```O(mn max(k))```\\n\\n n-> number of robot\\n m-> number of factory\\n k -> number of robot that can be replaired in factory\\n\\n \\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        \\n         //have all factory based on it\\'s frequency\\n        List<Integer> factories = new ArrayList<>();\\n        for(int i = 0 ; i < factory.length ; i++){\\n            for(int j = 0; j < factory[i][1] ; j++){\\n                factories.add(factory[i][0]);\\n            }\\n        }\\n\\n        Collections.sort(robot);\\n        Collections.sort(factories);\\n\\n        int m = robot.size() ;\\n        int n = factories.size();\\n\\n        long[][] memoization = new long[m+1][n+1];\\n        Arrays.stream(memoization).forEach(a -> Arrays.fill(a, -1));\\n        \\n        return count(robot , factories , 0 , 0 , memoization);\\n    }\\n\\n     private long count(List<Integer> robot, List<Integer> factories, int robotInd, int factoryIndex, long[][] dp) {\\n\\n        if(robotInd == robot.size()) return 0; //all robot are fixed\\n\\n        if(factoryIndex == factories.size()) return (long) 1e18; // there is no factory\\n\\n        //if already calculated this subproblem\\n        if (dp[robotInd][factoryIndex]!=-1) return dp[robotInd][factoryIndex];\\n\\n        long cost = Math.abs(robot.get(robotInd)-factories.get(factoryIndex));\\n\\n        long fixHere=cost + count(robot ,factories,robotInd+1,factoryIndex+1,dp); //fix robot in this factory\\n        long notFixHere = count(robot , factories , robotInd,factoryIndex+1,dp); // do not fix here\\n\\n        return dp[robotInd][factoryIndex]=Math.min(fixHere,notFixHere);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```O(mn max(k))```\n```\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        \\n         //have all factory based on it\\'s frequency\\n        List<Integer> factories = new ArrayList<>();\\n        for(int i = 0 ; i < factory.length ; i++){\\n            for(int j = 0; j < factory[i][1] ; j++){\\n                factories.add(factory[i][0]);\\n            }\\n        }\\n\\n        Collections.sort(robot);\\n        Collections.sort(factories);\\n\\n        int m = robot.size() ;\\n        int n = factories.size();\\n\\n        long[][] memoization = new long[m+1][n+1];\\n        Arrays.stream(memoization).forEach(a -> Arrays.fill(a, -1));\\n        \\n        return count(robot , factories , 0 , 0 , memoization);\\n    }\\n\\n     private long count(List<Integer> robot, List<Integer> factories, int robotInd, int factoryIndex, long[][] dp) {\\n\\n        if(robotInd == robot.size()) return 0; //all robot are fixed\\n\\n        if(factoryIndex == factories.size()) return (long) 1e18; // there is no factory\\n\\n        //if already calculated this subproblem\\n        if (dp[robotInd][factoryIndex]!=-1) return dp[robotInd][factoryIndex];\\n\\n        long cost = Math.abs(robot.get(robotInd)-factories.get(factoryIndex));\\n\\n        long fixHere=cost + count(robot ,factories,robotInd+1,factoryIndex+1,dp); //fix robot in this factory\\n        long notFixHere = count(robot , factories , robotInd,factoryIndex+1,dp); // do not fix here\\n\\n        return dp[robotInd][factoryIndex]=Math.min(fixHere,notFixHere);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798044,
                "title": "javascript-sort-dp",
                "content": "```\\n/**\\n * @param {number[]} robot\\n * @param {number[][]} factory\\n * @return {number}\\n */\\nvar minimumTotalDistance = function (robot, factory) {\\n  const factories = [];\\n  for (const [pos, limit] of factory) {\\n    for (let i = 0; i < limit; i++) {\\n      factories.push(pos);\\n    }\\n  }\\n\\n  robot.sort((a, b) => a - b);\\n  factories.sort((a, b) => a - b);\\n\\n  const dp = new Array(robot.length)\\n    .fill()\\n    .map((_) => new Array(factories.length).fill());\\n\\n  return helper(0, 0, robot, factories, dp);\\n};\\n\\nfunction helper(i, j, robot, factories, dp) {\\n  if (i === robot.length) return 0;\\n  if (j === factories.length) return Infinity;\\n  if (dp[i][j] !== undefined) return dp[i][j];\\n\\n  const take =\\n    Math.abs(robot[i] - factories[j]) +\\n    helper(i + 1, j + 1, robot, factories, dp);\\n  const noTake = helper(i, j + 1, robot, factories, dp);\\n\\n  return (dp[i][j] = Math.min(take, noTake));\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} robot\\n * @param {number[][]} factory\\n * @return {number}\\n */\\nvar minimumTotalDistance = function (robot, factory) {\\n  const factories = [];\\n  for (const [pos, limit] of factory) {\\n    for (let i = 0; i < limit; i++) {\\n      factories.push(pos);\\n    }\\n  }\\n\\n  robot.sort((a, b) => a - b);\\n  factories.sort((a, b) => a - b);\\n\\n  const dp = new Array(robot.length)\\n    .fill()\\n    .map((_) => new Array(factories.length).fill());\\n\\n  return helper(0, 0, robot, factories, dp);\\n};\\n\\nfunction helper(i, j, robot, factories, dp) {\\n  if (i === robot.length) return 0;\\n  if (j === factories.length) return Infinity;\\n  if (dp[i][j] !== undefined) return dp[i][j];\\n\\n  const take =\\n    Math.abs(robot[i] - factories[j]) +\\n    helper(i + 1, j + 1, robot, factories, dp);\\n  const noTake = helper(i, j + 1, robot, factories, dp);\\n\\n  return (dp[i][j] = Math.min(take, noTake));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2789649,
                "title": "dp-bottom-up-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& a, vector<vector<int>>& b) {\\n        sort(a.begin(),a.end());\\n        vector<int> v;\\n        for(auto i:b)\\n        {\\n            int m=i[1];\\n            while(m--)\\n                v.push_back(i[0]);\\n        }\\n        sort(v.begin(),v.end());\\n        int n=a.size(); int m=v.size();\\n        vector<vector<long long>> dp(n+1,vector<long long>(m+1,0));\\n        for(int i=1;i<=n;i++)\\n            dp[i][0]=1e15;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                dp[i][j]=min(dp[i-1][j-1]+abs(a[i-1]-v[j-1]),dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n\\nEither take element or skip it",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& a, vector<vector<int>>& b) {\\n        sort(a.begin(),a.end());\\n        vector<int> v;\\n        for(auto i:b)\\n        {\\n            int m=i[1];\\n            while(m--)\\n                v.push_back(i[0]);\\n        }\\n        sort(v.begin(),v.end());\\n        int n=a.size(); int m=v.size();\\n        vector<vector<long long>> dp(n+1,vector<long long>(m+1,0));\\n        for(int i=1;i<=n;i++)\\n            dp[i][0]=1e15;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                dp[i][j]=min(dp[i-1][j-1]+abs(a[i-1]-v[j-1]),dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788629,
                "title": "c-dp-o-n-n-m",
                "content": "# Intuition\\nTo each Factory, try to allocate `x` no. of robot where `0<=x<=f[i][1]` in sequential manner of robots from `0 to n-1` \\n\\n# Complexity\\n- Time complexity:\\nO(MN^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dfs(vector<int>& r,vector<vector<int>>& f,vector<vector<long long>>& dp,int in,int j){\\n        if(in>=r.size()) return 0;\\n        if(j>=f.size() && in<r.size()) return LLONG_MAX;\\n        if(dp[in][j]!=-1) return dp[in][j];\\n        long long re = dfs(r,f,dp,in,j+1), sum = 0;\\n        for(int i = in; i<r.size() && i-in+1<=f[j][1];++i){\\n            sum+= abs(r[i]-f[j][0]);\\n            long long k = dfs(r,f,dp,i+1,j+1);\\n            if(k!=LLONG_MAX) re = min(re,sum+k);\\n        }\\n        return dp[in][j] = re;\\n    }\\n    long long minimumTotalDistance(vector<int>& r, vector<vector<int>>& f) {\\n        sort(f.begin(),f.end());\\n        sort(r.begin(),r.end());\\n        vector<vector<long long>> dp(r.size()+1,vector<long long>(f.size()+1,-1));\\n        return dfs(r,f,dp,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dfs(vector<int>& r,vector<vector<int>>& f,vector<vector<long long>>& dp,int in,int j){\\n        if(in>=r.size()) return 0;\\n        if(j>=f.size() && in<r.size()) return LLONG_MAX;\\n        if(dp[in][j]!=-1) return dp[in][j];\\n        long long re = dfs(r,f,dp,in,j+1), sum = 0;\\n        for(int i = in; i<r.size() && i-in+1<=f[j][1];++i){\\n            sum+= abs(r[i]-f[j][0]);\\n            long long k = dfs(r,f,dp,i+1,j+1);\\n            if(k!=LLONG_MAX) re = min(re,sum+k);\\n        }\\n        return dp[in][j] = re;\\n    }\\n    long long minimumTotalDistance(vector<int>& r, vector<vector<int>>& f) {\\n        sort(f.begin(),f.end());\\n        sort(r.begin(),r.end());\\n        vector<vector<long long>> dp(r.size()+1,vector<long long>(f.size()+1,-1));\\n        return dfs(r,f,dp,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786768,
                "title": "python-dp-o-n-m-log-n",
                "content": "\\n\\n\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        n, m = len(robot), len(factory)\\n        costs = [inf] * n\\n        for p, c in factory[::-1]:\\n            df =[(0, -1)]\\n            prefix = 0\\n            for i, r in enumerate(robot[::-1]): \\n                prefix += abs(r - p)\\n                while df and i - df[0][1] > c:\\n                    heappop(df)\\n                heappush(df, (costs[i] - prefix, i))\\n                costs[i] = prefix + df[0][0]\\n        return costs[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        n, m = len(robot), len(factory)\\n        costs = [inf] * n\\n        for p, c in factory[::-1]:\\n            df =[(0, -1)]\\n            prefix = 0\\n            for i, r in enumerate(robot[::-1]): \\n                prefix += abs(r - p)\\n                while df and i - df[0][1] > c:\\n                    heappop(df)\\n                heappush(df, (costs[i] - prefix, i))\\n                costs[i] = prefix + df[0][0]\\n        return costs[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786664,
                "title": "java-o-len-robot-2-len-factory-o-len-robot-len-factory-bottom-up-dp",
                "content": "```\\n//could not solve it during contest ..\\n\\n\\n//1. every factory can cover a segment of positions.\\n//2. we sort factory and robot by positions.\\n//3. build subproblems\\n//4. use dynamic programming to solve the global problem using results from subproblems.\\n\\n//Approach\\n\\n//1. define dp[i][j] to be min total distance traveled by the first j robots using the\\n//first i factories after sorting their positions in increasing order.\\n\\n//2. base case.\\n//        dp[i][0] = 0, i=0, ... , len(factory)\\n\\n//3. transition formula to figure out dp[i][j]\\n//        option a : at factory i-1, we do not repair any robots, dp[i][j] = dp[i-1][j]\\n//        option b : at factory i-1, we know its position factory[i-1][0] and has a limit of factory[i-1][1]\\n//                   we can assume we repaired k robots at factory i-1, k = 1, ... , Math.min(j, limit)\\n//                   then dp[i][j] = Math.min(dp[i][j], dp[i-1][j-k]+cost of repairing k robots)\\n\\n//4. final result is dp[len(factory)][len(robot)]\\n\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        long INF = (long) 1e18;\\n        Collections.sort(robot);\\n        Arrays.sort(factory,(a,b)->(a[0]-b[0]));\\n        int n = robot.size(), m = factory.length;\\n        long[][] dp = new long[m+1][n+1];\\n        for(long[] f:dp) Arrays.fill(f, INF);\\n        dp[0][0] = 0;\\n        for(int i=1;i<=m;i++){\\n            dp[i][0] = 0;\\n            for(int j=1; j<=n;j++){\\n                dp[i][j] = dp[i-1][j];\\n                long cost = 0L;\\n                for(int k=1;k<=Math.min(j,factory[i-1][1]);k++){\\n                    cost += Math.abs(robot.get(j-k)-factory[i-1][0]);\\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j-k] + cost);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n//could not solve it during contest ..\\n\\n\\n//1. every factory can cover a segment of positions.\\n//2. we sort factory and robot by positions.\\n//3. build subproblems\\n//4. use dynamic programming to solve the global problem using results from subproblems.\\n\\n//Approach\\n\\n//1. define dp[i][j] to be min total distance traveled by the first j robots using the\\n//first i factories after sorting their positions in increasing order.\\n\\n//2. base case.\\n//        dp[i][0] = 0, i=0, ... , len(factory)\\n\\n//3. transition formula to figure out dp[i][j]\\n//        option a : at factory i-1, we do not repair any robots, dp[i][j] = dp[i-1][j]\\n//        option b : at factory i-1, we know its position factory[i-1][0] and has a limit of factory[i-1][1]\\n//                   we can assume we repaired k robots at factory i-1, k = 1, ... , Math.min(j, limit)\\n//                   then dp[i][j] = Math.min(dp[i][j], dp[i-1][j-k]+cost of repairing k robots)\\n\\n//4. final result is dp[len(factory)][len(robot)]\\n\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        long INF = (long) 1e18;\\n        Collections.sort(robot);\\n        Arrays.sort(factory,(a,b)->(a[0]-b[0]));\\n        int n = robot.size(), m = factory.length;\\n        long[][] dp = new long[m+1][n+1];\\n        for(long[] f:dp) Arrays.fill(f, INF);\\n        dp[0][0] = 0;\\n        for(int i=1;i<=m;i++){\\n            dp[i][0] = 0;\\n            for(int j=1; j<=n;j++){\\n                dp[i][j] = dp[i-1][j];\\n                long cost = 0L;\\n                for(int k=1;k<=Math.min(j,factory[i-1][1]);k++){\\n                    cost += Math.abs(robot.get(j-k)-factory[i-1][0]);\\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j-k] + cost);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786014,
                "title": "c-dfs-with-memo-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKey observation, sort both robots and factories by their position,\\nOptimal solution must be within the sequential assignments solutions (robots i < j must be assign to factories with p < q).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS with memorization\\n\\n# Complexity\\n- Time complexity: n^3\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^3\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long LL;\\nconst int N = 110;\\n\\nclass Solution {\\n    int n, m;\\n    LL f[N][N][N];\\npublic:\\n    LL minimumTotalDistance(vector<int>& rs, vector<vector<int>>& fs) {\\n        memset(f, -1, sizeof f);\\n        n = rs.size(), m = fs.size();\\n        sort(rs.begin(), rs.end());\\n        sort(fs.begin(), fs.end());\\n        return dfs(0, 0, 0, rs, fs);\\n    }\\n \\n    LL dfs(int i, int j, int k, vector<int>& rs, vector<vector<int>>& fs) \\n    {\\n        if (f[i][j][k] != -1) return f[i][j][k];\\n        LL& v = f[i][j][k];\\n        if (i == n)\\n        {\\n            return v = 0;\\n        }\\n        \\n        if (j == m) // impossible\\n        {\\n            return v = LONG_LONG_MAX;\\n        }\\n\\n        if (k == fs[j][1]) // used up, must move on to next factory\\n        {\\n            return v = dfs(i, j + 1, 0, rs, fs);\\n        }\\n        else\\n        {\\n            // assign ith robot to j factory\\n            LL r1 = dfs(i + 1, j, k + 1, rs, fs);\\n            LL r2 = dfs(i, j + 1, 0, rs, fs);\\n            if (r1 > LONG_LONG_MAX / 2) return v = r2;\\n            else\\n                return v = min(r1 + abs(rs[i] - fs[j][0]), r2);\\n        }\\n    }\\n};\\n```\\n\\nAlternative: DP\\n```\\ntypedef long long LL;\\nconst int N = 110;\\n\\n/*\\n    dp:\\n        state repr:\\n            f[i][j][k]: distribute first i robots to first j factories, and jth factory used k of its quota\\n        \\n        transition:\\n            for k : 0 -> f[][1]\\n                f[i][j][k] = f[i-1][j][k-1]\\n                f[i][j][0] = f[i][j-1][k]\\n*/\\n\\nclass Solution {\\n    LL f[N][N][N];\\npublic:\\n    long long minimumTotalDistance(vector<int>& rs, vector<vector<int>>& fs) {\\n        \\n        int n = rs.size(), m = fs.size();\\n        sort(rs.begin(), rs.end());\\n        sort(fs.begin(), fs.end());\\n\\n        rs.insert(rs.begin(), 0);\\n        fs.insert(fs.begin(), vector<int>(2, 0));\\n\\n        LL ans = LONG_LONG_MAX;\\n\\n        memset(f, 0x3f, sizeof f);\\n        for (int j = 0; j <= m; ++ j)\\n        {\\n            f[0][j][0] = 0;\\n        }\\n\\n        for (int i = 1; i <= n; ++ i) // 100\\n        {\\n            for (int j = 1; j <= m; ++ j) // 100\\n            {\\n                for (int k = 0; k <= fs[j-1][1]; ++ k)\\n                    f[i][j][0] = min(f[i][j][0], f[i][j-1][k]);\\n                for (int k = 1; k <= fs[j][1]; ++ k) // 100\\n                {\\n                    f[i][j][k] = min(f[i][j][k], f[i-1][j][k-1] + abs(rs[i] - fs[j][0]));\\n                    if (i == n)\\n                    {\\n                        if (f[i][j][k] > LONG_LONG_MAX / 2) continue;\\n                        ans = min(ans, f[i][j][k]);   \\n                    }\\n                }\\n            }\\n        }      \\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long LL;\\nconst int N = 110;\\n\\nclass Solution {\\n    int n, m;\\n    LL f[N][N][N];\\npublic:\\n    LL minimumTotalDistance(vector<int>& rs, vector<vector<int>>& fs) {\\n        memset(f, -1, sizeof f);\\n        n = rs.size(), m = fs.size();\\n        sort(rs.begin(), rs.end());\\n        sort(fs.begin(), fs.end());\\n        return dfs(0, 0, 0, rs, fs);\\n    }\\n \\n    LL dfs(int i, int j, int k, vector<int>& rs, vector<vector<int>>& fs) \\n    {\\n        if (f[i][j][k] != -1) return f[i][j][k];\\n        LL& v = f[i][j][k];\\n        if (i == n)\\n        {\\n            return v = 0;\\n        }\\n        \\n        if (j == m) // impossible\\n        {\\n            return v = LONG_LONG_MAX;\\n        }\\n\\n        if (k == fs[j][1]) // used up, must move on to next factory\\n        {\\n            return v = dfs(i, j + 1, 0, rs, fs);\\n        }\\n        else\\n        {\\n            // assign ith robot to j factory\\n            LL r1 = dfs(i + 1, j, k + 1, rs, fs);\\n            LL r2 = dfs(i, j + 1, 0, rs, fs);\\n            if (r1 > LONG_LONG_MAX / 2) return v = r2;\\n            else\\n                return v = min(r1 + abs(rs[i] - fs[j][0]), r2);\\n        }\\n    }\\n};\\n```\n```\\ntypedef long long LL;\\nconst int N = 110;\\n\\n/*\\n    dp:\\n        state repr:\\n            f[i][j][k]: distribute first i robots to first j factories, and jth factory used k of its quota\\n        \\n        transition:\\n            for k : 0 -> f[][1]\\n                f[i][j][k] = f[i-1][j][k-1]\\n                f[i][j][0] = f[i][j-1][k]\\n*/\\n\\nclass Solution {\\n    LL f[N][N][N];\\npublic:\\n    long long minimumTotalDistance(vector<int>& rs, vector<vector<int>>& fs) {\\n        \\n        int n = rs.size(), m = fs.size();\\n        sort(rs.begin(), rs.end());\\n        sort(fs.begin(), fs.end());\\n\\n        rs.insert(rs.begin(), 0);\\n        fs.insert(fs.begin(), vector<int>(2, 0));\\n\\n        LL ans = LONG_LONG_MAX;\\n\\n        memset(f, 0x3f, sizeof f);\\n        for (int j = 0; j <= m; ++ j)\\n        {\\n            f[0][j][0] = 0;\\n        }\\n\\n        for (int i = 1; i <= n; ++ i) // 100\\n        {\\n            for (int j = 1; j <= m; ++ j) // 100\\n            {\\n                for (int k = 0; k <= fs[j-1][1]; ++ k)\\n                    f[i][j][0] = min(f[i][j][0], f[i][j-1][k]);\\n                for (int k = 1; k <= fs[j][1]; ++ k) // 100\\n                {\\n                    f[i][j][k] = min(f[i][j][k], f[i-1][j][k-1] + abs(rs[i] - fs[j][0]));\\n                    if (i == n)\\n                    {\\n                        if (f[i][j][k] > LONG_LONG_MAX / 2) continue;\\n                        ans = min(ans, f[i][j][k]);   \\n                    }\\n                }\\n            }\\n        }      \\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785624,
                "title": "top-down-dp-python",
                "content": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        R, F = len(robot), len(factory)\\n        robot.sort()\\n        factory.sort()\\n        \\n        # i --> robot idx\\n        # j --> factory idx\\n        # cnt --> robots fixed at factory j\\n        @cache\\n        def dp(i, iFactory, cnt):\\n            if i >= R:\\n                return 0\\n            if iFactory >= F:\\n                return float(\\'inf\\') # impossible!\\n            \\n            # Skip current factory\\n            ans1 = dp(i, iFactory + 1, 0)\\n            \\n            # Fix robot at current factory\\n            ans2 = float(\\'inf\\')\\n            if cnt < factory[iFactory][1]:\\n                ans2 = dp(i + 1, iFactory, cnt + 1) + abs(robot[i] - factory[iFactory][0])\\n            \\n            return min(ans1, ans2)\\n\\n        return dp(0, 0, 0)\\n    # Time: O(M^2 * N) where M is the number of robots and N the number of factories\\n    # Space: O(M^2 * N)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        R, F = len(robot), len(factory)\\n        robot.sort()\\n        factory.sort()\\n        \\n        # i --> robot idx\\n        # j --> factory idx\\n        # cnt --> robots fixed at factory j\\n        @cache\\n        def dp(i, iFactory, cnt):\\n            if i >= R:\\n                return 0\\n            if iFactory >= F:\\n                return float(\\'inf\\') # impossible!\\n            \\n            # Skip current factory\\n            ans1 = dp(i, iFactory + 1, 0)\\n            \\n            # Fix robot at current factory\\n            ans2 = float(\\'inf\\')\\n            if cnt < factory[iFactory][1]:\\n                ans2 = dp(i + 1, iFactory, cnt + 1) + abs(robot[i] - factory[iFactory][0])\\n            \\n            return min(ans1, ans2)\\n\\n        return dp(0, 0, 0)\\n    # Time: O(M^2 * N) where M is the number of robots and N the number of factories\\n    # Space: O(M^2 * N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784452,
                "title": "double-dp-o-robot-size-2-factory-size-tc-quick-explanation",
                "content": "Before anything, sort robot and factory according to their posiotion on the axis.\\nfirst dp is for calculating steps for each factory to fix every robot from i to j on the axis on their own, i.e. the steps required if every robot from i to j goes to the kth factory. (-1 incase covering i to j is over the limit of  kth factory)\\nWe would then have a table with all the computation.\\nnow, we need a second dp to calculate steps required to cover 0 to j robots by k factories, such that kth factory covers i to j robots(we have this available in first dp table) and 0 to i-1 factory were already covered by previous k-1 factories(we have this result in current dp table).\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        vector<vector<vector<long long int> > > table(factory.size(), vector<vector<long long int> >(robot.size(), vector<long long int> (robot.size(), - 1)));\\n        long long int c, d;\\n        for(int i = 0; i < factory.size(); i++) {\\n            c = factory[i][0];\\n            for(int j = 0; j < robot.size(); j++) {\\n                d = 0;\\n                for(int k = j; k < robot.size() && k - j < factory[i][1]; k++) {\\n                    d += abs(c - robot[k]);\\n                    table[i][j][k] = d;\\n                }\\n            }\\n        }\\n        vector<vector<long long int> > dp(2, vector<long long int>(robot.size()));\\n        for(int i = 0; i < robot.size(); i++) dp[0][i] = table[0][0][i];\\n        int p = 1;\\n        for(int i = 1; i < factory.size(); i++) {\\n            for(int j = 0; j < robot.size(); j++) {\\n                dp[p][j] = table[i][0][j];\\n                if(dp[p^1][j] != -1) {\\n                    if(dp[p][j] == -1) dp[p][j] = dp[p^1][j];\\n                    else dp[p][j] = min(dp[p][j], dp[p^1][j]);\\n                }\\n                for(int k = 0; k < j; k++) {\\n                    if(dp[p^1][k] != -1 && table[i][k + 1][j] != -1) {\\n                        if(dp[p][j] == -1) dp[p][j] = dp[p^1][k] + table[i][k + 1][j];\\n                        else dp[p][j] = min(dp[p][j], dp[p^1][k] + table[i][k + 1][j]);\\n                    }\\n                }\\n            }\\n            p ^= 1;\\n        }\\n        return dp[p^1][robot.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        vector<vector<vector<long long int> > > table(factory.size(), vector<vector<long long int> >(robot.size(), vector<long long int> (robot.size(), - 1)));\\n        long long int c, d;\\n        for(int i = 0; i < factory.size(); i++) {\\n            c = factory[i][0];\\n            for(int j = 0; j < robot.size(); j++) {\\n                d = 0;\\n                for(int k = j; k < robot.size() && k - j < factory[i][1]; k++) {\\n                    d += abs(c - robot[k]);\\n                    table[i][j][k] = d;\\n                }\\n            }\\n        }\\n        vector<vector<long long int> > dp(2, vector<long long int>(robot.size()));\\n        for(int i = 0; i < robot.size(); i++) dp[0][i] = table[0][0][i];\\n        int p = 1;\\n        for(int i = 1; i < factory.size(); i++) {\\n            for(int j = 0; j < robot.size(); j++) {\\n                dp[p][j] = table[i][0][j];\\n                if(dp[p^1][j] != -1) {\\n                    if(dp[p][j] == -1) dp[p][j] = dp[p^1][j];\\n                    else dp[p][j] = min(dp[p][j], dp[p^1][j]);\\n                }\\n                for(int k = 0; k < j; k++) {\\n                    if(dp[p^1][k] != -1 && table[i][k + 1][j] != -1) {\\n                        if(dp[p][j] == -1) dp[p][j] = dp[p^1][k] + table[i][k + 1][j];\\n                        else dp[p][j] = min(dp[p][j], dp[p^1][k] + table[i][k + 1][j]);\\n                    }\\n                }\\n            }\\n            p ^= 1;\\n        }\\n        return dp[p^1][robot.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783906,
                "title": "c-dp-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    long long f(int i,int j,vector<int>& robot,vector<int> &v,vector<vector<ll>> &dp){\\n        // if we have covered all robots, we return 0.\\n        if(i==robot.size())\\n            return 0;\\n        // if we have covered all factories, it means we still need to cover the robots so we return 1e13.\\n        if(j==v.size())\\n            return 1e13;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        ll ans = 1e13;\\n        // If we take the current robot and factory, we increment the indexes and add the difference.\\n        ll take = abs(robot[i]-v[j]) + f(i+1,j+1,robot,v,dp);\\n        // We don\\'t take the current robot but increment the factory count.\\n        ll notTake = f(i,j+1,robot,v,dp);\\n        // We take the minimum of both and return the ans.\\n        // We use a dp array to optimise the solution.\\n        ans = min(take,notTake);\\n        return dp[i][j]=ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        vector<int> v;\\n        // Taking the factories and storing them in v according to their limits.\\n        for(int i=0;i<factory.size();i++){\\n            for(int j=0;j<factory[i][1];j++)\\n                v.push_back(factory[i][0]);\\n        }\\n        // sortign the factories and robots so it makes it easier for us to search for the nearest factory.\\n        sort(v.begin(),v.end());\\n        sort(robot.begin(),robot.end());\\n        // Initializing a dp array of size (m*n) \\n        // where m = size of the robot array.\\n        // n = size of the factory array.\\n        vector<vector<ll>> dp(robot.size()+1,vector<ll>(v.size()+1,-1));\\n        // calling the recursive function.\\n        return f(0,0,robot,v,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    long long f(int i,int j,vector<int>& robot,vector<int> &v,vector<vector<ll>> &dp){\\n        // if we have covered all robots, we return 0.\\n        if(i==robot.size())\\n            return 0;\\n        // if we have covered all factories, it means we still need to cover the robots so we return 1e13.\\n        if(j==v.size())\\n            return 1e13;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        ll ans = 1e13;\\n        // If we take the current robot and factory, we increment the indexes and add the difference.\\n        ll take = abs(robot[i]-v[j]) + f(i+1,j+1,robot,v,dp);\\n        // We don\\'t take the current robot but increment the factory count.\\n        ll notTake = f(i,j+1,robot,v,dp);\\n        // We take the minimum of both and return the ans.\\n        // We use a dp array to optimise the solution.\\n        ans = min(take,notTake);\\n        return dp[i][j]=ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        vector<int> v;\\n        // Taking the factories and storing them in v according to their limits.\\n        for(int i=0;i<factory.size();i++){\\n            for(int j=0;j<factory[i][1];j++)\\n                v.push_back(factory[i][0]);\\n        }\\n        // sortign the factories and robots so it makes it easier for us to search for the nearest factory.\\n        sort(v.begin(),v.end());\\n        sort(robot.begin(),robot.end());\\n        // Initializing a dp array of size (m*n) \\n        // where m = size of the robot array.\\n        // n = size of the factory array.\\n        vector<vector<ll>> dp(robot.size()+1,vector<ll>(v.size()+1,-1));\\n        // calling the recursive function.\\n        return f(0,0,robot,v,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783391,
                "title": "easy-recursion-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApply recursion with memoization (DP) on robots and factory pair. dp\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the robots and the factory.\\nNow Apply the dynamic problem such that dp[i][j] will indicate the minimum cost such that i robots and j factories has be used.\\nFor each factory try to get all possible robots till its limit. By sorting We are ensuring that the current factory will get the cost optimal robots.\\n\\n# Complexity\\n- Time complexity: $$O(N^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const long long inf = 1e15;\\n    long long solve(int i,int j,vector<int>& robots, vector<vector<int>>& F,vector<vector<long long>> &dp)\\n    {\\n        if(i == robots.size())\\n        {\\n            return 0;\\n        }\\n        if(j == F.size())\\n        {\\n            return 1000000000000;\\n        }\\n\\n        if(dp[i][j] != inf) return dp[i][j];\\n\\n        long long ans = 1000000000000;\\n\\n        long long d = 0;\\n\\n        int k = i;\\n\\n        for(int taken = 1;taken <= F[j][1];taken++)\\n        {\\n            \\n            d += labs(robots[k] - F[j][0]);\\n\\n            ans = min(ans, d + solve(k+1,j+1,robots,F,dp));\\n            k++;\\n            \\n            if(k == robots.size()) break;\\n        }\\n        \\n        // Not taking current factory\\n        ans = min(ans,solve(i,j+1,robots,F,dp));\\n        \\n\\n\\n        return dp[i][j] = ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        \\n        vector<vector<long long>> dp(robot.size(),vector<long long>(factory.size(), inf));\\n      \\n        sort(factory.begin(),factory.end());\\n\\n        sort(robot.begin(),robot.end());\\n\\n\\n\\n        return solve(0,0,robot,factory,dp);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long inf = 1e15;\\n    long long solve(int i,int j,vector<int>& robots, vector<vector<int>>& F,vector<vector<long long>> &dp)\\n    {\\n        if(i == robots.size())\\n        {\\n            return 0;\\n        }\\n        if(j == F.size())\\n        {\\n            return 1000000000000;\\n        }\\n\\n        if(dp[i][j] != inf) return dp[i][j];\\n\\n        long long ans = 1000000000000;\\n\\n        long long d = 0;\\n\\n        int k = i;\\n\\n        for(int taken = 1;taken <= F[j][1];taken++)\\n        {\\n            \\n            d += labs(robots[k] - F[j][0]);\\n\\n            ans = min(ans, d + solve(k+1,j+1,robots,F,dp));\\n            k++;\\n            \\n            if(k == robots.size()) break;\\n        }\\n        \\n        // Not taking current factory\\n        ans = min(ans,solve(i,j+1,robots,F,dp));\\n        \\n\\n\\n        return dp[i][j] = ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        \\n        vector<vector<long long>> dp(robot.size(),vector<long long>(factory.size(), inf));\\n      \\n        sort(factory.begin(),factory.end());\\n\\n        sort(robot.begin(),robot.end());\\n\\n\\n\\n        return solve(0,0,robot,factory,dp);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783378,
                "title": "o-n-3-solution-sort-shift-the-minimum-subarray-of-assignments",
                "content": "# Intuition\\nAs you shift the factory assignment of any given robot from left to right, the distance traveled first decreases to a minimum (or starts from the minimum), and then starts to increase again. As we go through the robots\\' initial positions one by one from left the right, the closest factory either stays the same or shifts to one of the factories to the right. So, it never makes sense for the robots to cross path. The only complication is that factories may run out of capacity: In that case, a subarray of the sorted `robot` have to shift assignments at the same time.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExpand the full list of capacity of sorted `factory` as `cap` list. Initially assign the sorted `robot` to the leftmost subarray. Consider the robots in the reverse order. Shift the assignments of the smallest subarray starting from the `i`th robot of the sorted `robot` from left to right until the distance travled starts to increase.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^3), `n = max(len(robot), len(factory))`\\n\\n- Space complexity:\\nO(n^2) due to the `cap` list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:        \\n        robot.sort()\\n        factory.sort()\\n        cap = []\\n        for x, limit in factory:\\n            cap.extend([x] * limit)\\n        m = len(robot)\\n        n = len(cap)\\n        indices = list(range(m))\\n        ans = sum(abs(x - y) for x, y in zip(robot, cap))\\n        \\n        def increment(i):\\n            diff = 0\\n            while i < m:\\n                if indices[i] + 1 < n:\\n                    diff -= abs(robot[i] - cap[indices[i]])\\n                    diff += abs(robot[i] - cap[indices[i] + 1])\\n                else:\\n                    return math.inf, i + 1\\n                if i + 1 < m and indices[i] + 1 == indices[i + 1]:\\n                    i += 1\\n                else:\\n                    return diff, i + 1\\n        for i in reversed(range(m)):\\n            while True:\\n                diff, j = increment(i)\\n                if diff <= 0:\\n                    ans += diff\\n                    for x in range(i, j):\\n                        indices[x] += 1\\n                else:\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:        \\n        robot.sort()\\n        factory.sort()\\n        cap = []\\n        for x, limit in factory:\\n            cap.extend([x] * limit)\\n        m = len(robot)\\n        n = len(cap)\\n        indices = list(range(m))\\n        ans = sum(abs(x - y) for x, y in zip(robot, cap))\\n        \\n        def increment(i):\\n            diff = 0\\n            while i < m:\\n                if indices[i] + 1 < n:\\n                    diff -= abs(robot[i] - cap[indices[i]])\\n                    diff += abs(robot[i] - cap[indices[i] + 1])\\n                else:\\n                    return math.inf, i + 1\\n                if i + 1 < m and indices[i] + 1 == indices[i + 1]:\\n                    i += 1\\n                else:\\n                    return diff, i + 1\\n        for i in reversed(range(m)):\\n            while True:\\n                diff, j = increment(i)\\n                if diff <= 0:\\n                    ans += diff\\n                    for x in range(i, j):\\n                        indices[x] += 1\\n                else:\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783339,
                "title": "minimum-cost-maximum-flow-much-simpler-than-dp",
                "content": "This problem is actually extremely simple to solve using minimum cost maximum flow if you know how to do the reduction. You only need to write an few additional lines of code and no preprocessing is needed.\\nFirst you need to realize that you can assign any robot to any factory. The robots don\\'t need to start walking at time 0, and you can let them start walking and get repaired one by one.\\nWe build a flow graph with the robots and the factory. Each edge from the robot[i] to the factory[j] has capacity 1 and costs the distance between them. Each edge from the source to robot[i] has capacity 1 and cost 0. Each edge from factory[j] to the sink has capacity limit[j] and cost 0. Then, we see that the requirements are satisfied, the maximum flow will be equal to n, and the minimum cost maximum flow is the solution to the problem.\\n```\\nstruct FlowEdge {\\n    int u, v;\\n    long long cap, cost, flow = 0;\\n    FlowEdge(int u, int v, long long cap, long long cost) : u(u), v(v), cap(cap), cost(cost) {}\\n};\\nstruct MinCostFlow {\\n    vector<vector<int>> adj, cost, cap;\\n    vector<FlowEdge> edges;\\n    vector<pair<long long, long long>> ans;\\n    const long long INF = 1e14;\\n    int n, m = 0;\\n    int s, t;\\n    MinCostFlow(int n, int s, int t) : n(n), s(s), t(t) {\\n        adj.assign(n, vector<int>());\\n    }\\n    void add_edge(int u, int v, long long cap_, long long cost_) {\\n        edges.emplace_back(u, v, cap_, cost_);\\n        edges.emplace_back(v, u, 0, -cost_);\\n        adj[u].push_back(m);\\n        adj[v].push_back(m + 1);\\n        m += 2;\\n    }\\n    void shortest_paths(int v0, vector<long long>& d, vector<int>& p) {\\n        d.assign(n, INF);\\n        d[v0] = 0;\\n        vector<bool> inq(n, false);\\n        queue<int> q;\\n        q.push(v0);\\n        p.assign(n, -1);\\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            inq[u] = false;\\n            for (int id : adj[u]) {\\n                int v = edges[id].v;\\n                if (edges[id].cap > 0 && d[v] > d[u] + edges[id].cost) {\\n                    d[v] = d[u] + edges[id].cost;\\n                    p[v] = id;\\n                    if (!inq[v]) {\\n                        inq[v] = true;\\n                        q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    long long flow(long long k = -1) {\\n        if (k == -1) k = INF;\\n        long long flow = 0;\\n        long long cost = 0;\\n        vector<long long> d;\\n        vector<int> p;\\n        while (flow < k) {\\n            shortest_paths(s, d, p);\\n            if (d[t] == INF)\\n                break;\\n            // find max flow on that path\\n            long long f = k - flow;\\n            int cur = t;\\n            while (cur != s) {\\n                f = min(f, edges[p[cur]].cap);\\n                cur = edges[p[cur]].u;\\n            }\\n            // apply flow\\n            flow += f;\\n            cost += f * d[t];\\n            cur = t;\\n            while (cur != s) {\\n                edges[p[cur]].flow += f;\\n                edges[p[cur]^1].flow -= f;\\n                edges[p[cur]].cap -= f;\\n                edges[p[cur]^1].cap += f;\\n                cur = edges[p[cur]].u;\\n            }\\n            ans.push_back({flow, cost});\\n        }\\n        if (k < INF && flow < k)\\n            return -1;\\n        else\\n            return cost;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int n = robot.size(), m = factory.size();\\n        MinCostFlow G(n+m+2, n+m, n+m+1);\\n        for (int i = 0; i < n; i++) {\\n            G.add_edge(n+m, i, 1, 0);\\n        }\\n        for (int i = 0; i < m; i++) {\\n            G.add_edge(i+n, n+m+1, factory[i][1], 0);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                G.add_edge(i, j+n, 1, abs(robot[i] - factory[j][0]));\\n            }\\n        }\\n        return G.flow(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct FlowEdge {\\n    int u, v;\\n    long long cap, cost, flow = 0;\\n    FlowEdge(int u, int v, long long cap, long long cost) : u(u), v(v), cap(cap), cost(cost) {}\\n};\\nstruct MinCostFlow {\\n    vector<vector<int>> adj, cost, cap;\\n    vector<FlowEdge> edges;\\n    vector<pair<long long, long long>> ans;\\n    const long long INF = 1e14;\\n    int n, m = 0;\\n    int s, t;\\n    MinCostFlow(int n, int s, int t) : n(n), s(s), t(t) {\\n        adj.assign(n, vector<int>());\\n    }\\n    void add_edge(int u, int v, long long cap_, long long cost_) {\\n        edges.emplace_back(u, v, cap_, cost_);\\n        edges.emplace_back(v, u, 0, -cost_);\\n        adj[u].push_back(m);\\n        adj[v].push_back(m + 1);\\n        m += 2;\\n    }\\n    void shortest_paths(int v0, vector<long long>& d, vector<int>& p) {\\n        d.assign(n, INF);\\n        d[v0] = 0;\\n        vector<bool> inq(n, false);\\n        queue<int> q;\\n        q.push(v0);\\n        p.assign(n, -1);\\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            inq[u] = false;\\n            for (int id : adj[u]) {\\n                int v = edges[id].v;\\n                if (edges[id].cap > 0 && d[v] > d[u] + edges[id].cost) {\\n                    d[v] = d[u] + edges[id].cost;\\n                    p[v] = id;\\n                    if (!inq[v]) {\\n                        inq[v] = true;\\n                        q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    long long flow(long long k = -1) {\\n        if (k == -1) k = INF;\\n        long long flow = 0;\\n        long long cost = 0;\\n        vector<long long> d;\\n        vector<int> p;\\n        while (flow < k) {\\n            shortest_paths(s, d, p);\\n            if (d[t] == INF)\\n                break;\\n            // find max flow on that path\\n            long long f = k - flow;\\n            int cur = t;\\n            while (cur != s) {\\n                f = min(f, edges[p[cur]].cap);\\n                cur = edges[p[cur]].u;\\n            }\\n            // apply flow\\n            flow += f;\\n            cost += f * d[t];\\n            cur = t;\\n            while (cur != s) {\\n                edges[p[cur]].flow += f;\\n                edges[p[cur]^1].flow -= f;\\n                edges[p[cur]].cap -= f;\\n                edges[p[cur]^1].cap += f;\\n                cur = edges[p[cur]].u;\\n            }\\n            ans.push_back({flow, cost});\\n        }\\n        if (k < INF && flow < k)\\n            return -1;\\n        else\\n            return cost;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int n = robot.size(), m = factory.size();\\n        MinCostFlow G(n+m+2, n+m, n+m+1);\\n        for (int i = 0; i < n; i++) {\\n            G.add_edge(n+m, i, 1, 0);\\n        }\\n        for (int i = 0; i < m; i++) {\\n            G.add_edge(i+n, n+m+1, factory[i][1], 0);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                G.add_edge(i, j+n, 1, abs(robot[i] - factory[j][0]));\\n            }\\n        }\\n        return G.flow(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783197,
                "title": "simple-c-dp-solution",
                "content": "```\\nclass Solution\\n{\\nprivate:\\n    long long solve(int fidx, int ridx, vector<int> &robot, vector<vector<int>> &factory, vector<vector<long long>> &dp)\\n    {\\n        if (ridx == robot.size())\\n        {\\n            return dp[fidx][ridx] = 0l;\\n        }\\n\\n        if (fidx == factory.size())\\n        {\\n            return dp[fidx][ridx] = (long long)(1e18);\\n        }\\n\\n        if (dp[fidx][ridx] != -1l)\\n        {\\n            return dp[fidx][ridx];\\n        }\\n\\n        long long ans = (long long)1e18;\\n        long long sum = 0l;\\n        int cap = factory[fidx][1], pos = factory[fidx][0];\\n\\n        for (int i = 0; i < cap && ridx + i < robot.size(); i++)\\n        {\\n            sum += (long long) (abs(pos - robot[ridx + i]));\\n            long long curr = sum + solve(fidx + 1, ridx + i + 1, robot, factory, dp);\\n            ans = min(ans, curr);\\n        }\\n\\n        ans = min(ans, solve(fidx + 1, ridx, robot, factory, dp));\\n\\n        return dp[fidx][ridx] = ans;\\n    }\\n\\npublic:\\n    long long minimumTotalDistance(vector<int> &robot, vector<vector<int>> &factory)\\n    {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n\\n        int n = factory.size(), m = robot.size();\\n        vector<vector<long long>> dp(n + 1, vector<long long>(m + 1, -1l));\\n\\n        return solve(0, 0, robot, factory, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    long long solve(int fidx, int ridx, vector<int> &robot, vector<vector<int>> &factory, vector<vector<long long>> &dp)\\n    {\\n        if (ridx == robot.size())\\n        {\\n            return dp[fidx][ridx] = 0l;\\n        }\\n\\n        if (fidx == factory.size())\\n        {\\n            return dp[fidx][ridx] = (long long)(1e18);\\n        }\\n\\n        if (dp[fidx][ridx] != -1l)\\n        {\\n            return dp[fidx][ridx];\\n        }\\n\\n        long long ans = (long long)1e18;\\n        long long sum = 0l;\\n        int cap = factory[fidx][1], pos = factory[fidx][0];\\n\\n        for (int i = 0; i < cap && ridx + i < robot.size(); i++)\\n        {\\n            sum += (long long) (abs(pos - robot[ridx + i]));\\n            long long curr = sum + solve(fidx + 1, ridx + i + 1, robot, factory, dp);\\n            ans = min(ans, curr);\\n        }\\n\\n        ans = min(ans, solve(fidx + 1, ridx, robot, factory, dp));\\n\\n        return dp[fidx][ridx] = ans;\\n    }\\n\\npublic:\\n    long long minimumTotalDistance(vector<int> &robot, vector<vector<int>> &factory)\\n    {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n\\n        int n = factory.size(), m = robot.size();\\n        vector<vector<long long>> dp(n + 1, vector<long long>(m + 1, -1l));\\n\\n        return solve(0, 0, robot, factory, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087131,
                "title": "dart",
                "content": "# Intuition\\n`dfs(facs, robs)` means the first `robs` number of Robots are repaired by the first `facs` number of factories.\\n\\n# Code\\n```\\n\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int minimumTotalDistance(List<int> robot, List<List<int>> factory) {\\n    const MAX = 1 << 60;\\n    robot.sort();\\n    factory.sort((a, b) => a[0] - b[0]);\\n    List<int> prefix = [0];\\n    for (final f in factory)\\n      prefix.add(prefix.last + f[1]);\\n\\n    final F = factory.length, R = robot.length;\\n    final memo = List.generate(F + 1, (_) => List.filled(R + 1, -1));\\n    int dfs(int facs, int robs) {\\n      if (robs == 0) return 0;\\n      if (prefix[facs] < robs) return MAX;\\n      if (memo[facs][robs] == -1) {\\n        final my_loc = factory[facs - 1][0];\\n        var my_limit = factory[facs - 1][1];\\n\\n        var tmp = dfs(facs - 1, robs);\\n        var my_cost = 0;\\n        for (int r = robs - 1; r >= 0 && my_limit > 0; r--, my_limit--) {\\n          // robs [r, robs-1] goes to me\\n          my_cost += (robot[r] - my_loc).abs();\\n          tmp = min(tmp, my_cost + dfs(facs - 1, r));\\n        }\\n        memo[facs][robs] = tmp;\\n      }\\n      return memo[facs][robs];\\n    }\\n    return dfs(F, R);\\n  }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int minimumTotalDistance(List<int> robot, List<List<int>> factory) {\\n    const MAX = 1 << 60;\\n    robot.sort();\\n    factory.sort((a, b) => a[0] - b[0]);\\n    List<int> prefix = [0];\\n    for (final f in factory)\\n      prefix.add(prefix.last + f[1]);\\n\\n    final F = factory.length, R = robot.length;\\n    final memo = List.generate(F + 1, (_) => List.filled(R + 1, -1));\\n    int dfs(int facs, int robs) {\\n      if (robs == 0) return 0;\\n      if (prefix[facs] < robs) return MAX;\\n      if (memo[facs][robs] == -1) {\\n        final my_loc = factory[facs - 1][0];\\n        var my_limit = factory[facs - 1][1];\\n\\n        var tmp = dfs(facs - 1, robs);\\n        var my_cost = 0;\\n        for (int r = robs - 1; r >= 0 && my_limit > 0; r--, my_limit--) {\\n          // robs [r, robs-1] goes to me\\n          my_cost += (robot[r] - my_loc).abs();\\n          tmp = min(tmp, my_cost + dfs(facs - 1, r));\\n        }\\n        memo[facs][robs] = tmp;\\n      }\\n      return memo[facs][robs];\\n    }\\n    return dfs(F, R);\\n  }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844023,
                "title": "efficient-js-solution-beat-100-both-time-and-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/377633cf-e26b-4478-a2f5-659115c19a86_1690823278.1218612.png)\\n\\n# Complexity\\n- let `n = robot.length` and `m = factory.length`\\n- Time complexity: $$O(mn^2)$$\\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```jsx\\n/**\\n * @param {number[]} robot\\n * @param {number[][]} factory\\n * @return {number}\\n */\\nvar minimumTotalDistance = function (robot, factory) {\\n  const n = robot.length;\\n  const m = factory.length;\\n  robot.sort((a, b) => a - b);\\n  factory.sort((a, b) => a[0] - b[0]);\\n\\n  const dp = [];\\n  for (let i = 0; i < m; i++) dp.push(Array(n).fill(null));\\n\\n  function getDp(fi, ri) {\\n    if (ri < 0) return 0;\\n    if (fi < 0) return null;\\n    return dp[fi][ri];\\n  }\\n\\n  for (let fi = 0; fi < m; fi++) {\\n    for (let rir = 0; rir < n; rir++) {\\n      dp[fi][rir] = getDp(fi - 1, rir);\\n      let sum = 0;\\n      for (let ril = rir; ril >= Math.max(0, rir - factory[fi][1] + 1); ril--) {\\n        sum += Math.abs(robot[ril] - factory[fi][0]);\\n        const prev = getDp(fi-1, ril-1);\\n        if (prev !== null) {\\n          if (dp[fi][rir] === null) dp[fi][rir] = prev + sum;\\n          else dp[fi][rir] = Math.min(dp[fi][rir], prev + sum);\\n        }\\n      }\\n    }\\n  }\\n\\n  return dp[m-1][n-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```jsx\\n/**\\n * @param {number[]} robot\\n * @param {number[][]} factory\\n * @return {number}\\n */\\nvar minimumTotalDistance = function (robot, factory) {\\n  const n = robot.length;\\n  const m = factory.length;\\n  robot.sort((a, b) => a - b);\\n  factory.sort((a, b) => a[0] - b[0]);\\n\\n  const dp = [];\\n  for (let i = 0; i < m; i++) dp.push(Array(n).fill(null));\\n\\n  function getDp(fi, ri) {\\n    if (ri < 0) return 0;\\n    if (fi < 0) return null;\\n    return dp[fi][ri];\\n  }\\n\\n  for (let fi = 0; fi < m; fi++) {\\n    for (let rir = 0; rir < n; rir++) {\\n      dp[fi][rir] = getDp(fi - 1, rir);\\n      let sum = 0;\\n      for (let ril = rir; ril >= Math.max(0, rir - factory[fi][1] + 1); ril--) {\\n        sum += Math.abs(robot[ril] - factory[fi][0]);\\n        const prev = getDp(fi-1, ril-1);\\n        if (prev !== null) {\\n          if (dp[fi][rir] === null) dp[fi][rir] = prev + sum;\\n          else dp[fi][rir] = Math.min(dp[fi][rir], prev + sum);\\n        }\\n      }\\n    }\\n  }\\n\\n  return dp[m-1][n-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765880,
                "title": "dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(int i,int j, vector<int>&robot ,vector<int>&fac,vector<vector<long long>> &DP)\\n    {\\n        if(i==robot.size())\\n                return 0;\\n        if(j==fac.size())\\n                return LLONG_MAX;\\n        if(DP[i][j]!=-1)\\n            return DP[i][j];\\n        long long pick = solve(i+1,j+1,robot,fac,DP);\\n        if(pick !=LLONG_MAX)\\n            pick+=abs(robot[i]-fac[j])*1LL;\\n        long long skip = solve(i,j+1,robot,fac,DP);\\n        return DP[i][j]=min(pick,skip);\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        vector<int> fac;\\n        sort(factory.begin(),factory.end());\\n        for(auto it:factory)\\n        {\\n            for(int i=0;i<it[1];i++)\\n                fac.push_back(it[0]);\\n        }\\n        sort(robot.begin(),robot.end());\\n        int n=robot.size();\\n        int m=fac.size();\\n        vector<vector<long long>> DP(n,vector<long long>(m,-1));\\n        return solve(0,0,robot,fac,DP);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int i,int j, vector<int>&robot ,vector<int>&fac,vector<vector<long long>> &DP)\\n    {\\n        if(i==robot.size())\\n                return 0;\\n        if(j==fac.size())\\n                return LLONG_MAX;\\n        if(DP[i][j]!=-1)\\n            return DP[i][j];\\n        long long pick = solve(i+1,j+1,robot,fac,DP);\\n        if(pick !=LLONG_MAX)\\n            pick+=abs(robot[i]-fac[j])*1LL;\\n        long long skip = solve(i,j+1,robot,fac,DP);\\n        return DP[i][j]=min(pick,skip);\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        vector<int> fac;\\n        sort(factory.begin(),factory.end());\\n        for(auto it:factory)\\n        {\\n            for(int i=0;i<it[1];i++)\\n                fac.push_back(it[0]);\\n        }\\n        sort(robot.begin(),robot.end());\\n        int n=robot.size();\\n        int m=fac.size();\\n        vector<vector<long long>> DP(n,vector<long long>(m,-1));\\n        return solve(0,0,robot,fac,DP);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745033,
                "title": "top-down-and-bottom-up-dp-o-m-space-o-mmn-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long long mem[101][101][101];\\n    long long solve(int i, int j, int k, vector<int>& robot, vector<vector<int>>& factory) {\\n        if (i < 0) {\\n            return 0;\\n        }\\n\\n        if (j < 0) {\\n            return 2e11 + 1;\\n        }\\n\\n        if (mem[i][j][k] == -1) {\\n            long long v = LLONG_MAX;\\n            if (k > 0) {\\n                v = min(v, abs(factory[j][0] - robot[i]) + solve(i - 1, j, k - 1, robot, factory));\\n            }\\n\\n            v = min(v, solve(i, j - 1, j > 0 ? factory[j - 1][1] : 0, robot, factory));\\n            mem[i][j][k] = v;\\n        }\\n\\n        return mem[i][j][k];\\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int m = robot.size(), n = factory.size();\\n\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n\\n        /*\\n        memset(mem, -1, sizeof(mem));\\n        return solve(m - 1, n - 1, factory.back()[1], robot, factory);\\n        */\\n\\n        // O(m) space O(mnm) time\\n        // can be further optimized to single row, \\n        // since row[j] only relies on row[j...j+cnt]\\n        vector<vector<long long>> row(2, vector<long long>(m + 1, 2e11 + 1));\\n        int idx = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            row[idx][m] = 0;\\n            int pidx = idx;\\n            idx = !idx;\\n            for (int j = 0; j < m; j++) {\\n                int cnt = min(m - j, factory[i][1]);\\n                long long val = 2e11 + 1, dist = 0;\\n                for (int k = 0; k <= cnt; k++) {\\n                    dist += k > 0 ? abs(robot[j + k - 1] - factory[i][0]) : 0;\\n                    val = min(val, dist + row[pidx][j + k]);\\n                }\\n\\n                row[idx][j] = val;\\n            }\\n        }\\n\\n        return row[idx][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long long mem[101][101][101];\\n    long long solve(int i, int j, int k, vector<int>& robot, vector<vector<int>>& factory) {\\n        if (i < 0) {\\n            return 0;\\n        }\\n\\n        if (j < 0) {\\n            return 2e11 + 1;\\n        }\\n\\n        if (mem[i][j][k] == -1) {\\n            long long v = LLONG_MAX;\\n            if (k > 0) {\\n                v = min(v, abs(factory[j][0] - robot[i]) + solve(i - 1, j, k - 1, robot, factory));\\n            }\\n\\n            v = min(v, solve(i, j - 1, j > 0 ? factory[j - 1][1] : 0, robot, factory));\\n            mem[i][j][k] = v;\\n        }\\n\\n        return mem[i][j][k];\\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int m = robot.size(), n = factory.size();\\n\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n\\n        /*\\n        memset(mem, -1, sizeof(mem));\\n        return solve(m - 1, n - 1, factory.back()[1], robot, factory);\\n        */\\n\\n        // O(m) space O(mnm) time\\n        // can be further optimized to single row, \\n        // since row[j] only relies on row[j...j+cnt]\\n        vector<vector<long long>> row(2, vector<long long>(m + 1, 2e11 + 1));\\n        int idx = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            row[idx][m] = 0;\\n            int pidx = idx;\\n            idx = !idx;\\n            for (int j = 0; j < m; j++) {\\n                int cnt = min(m - j, factory[i][1]);\\n                long long val = 2e11 + 1, dist = 0;\\n                for (int k = 0; k <= cnt; k++) {\\n                    dist += k > 0 ? abs(robot[j + k - 1] - factory[i][0]) : 0;\\n                    val = min(val, dist + row[pidx][j + k]);\\n                }\\n\\n                row[idx][j] = val;\\n            }\\n        }\\n\\n        return row[idx][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710275,
                "title": "memoization-o-n-m-max-limit",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[101][101][101];\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n         sort(robot.begin(),robot.end());\\n         sort(factory.begin(),factory.end());\\n         memset(dp,-1,sizeof(dp));\\n         return solve(0,0,factory[0][1],factory,robot);\\n    }\\n    long long solve(int pos,int factpos,int limit,vector<vector<int>> &factory,vector<int> &robot) {\\n         if(pos>=robot.size()) return 0;\\n         if(factpos>=factory.size()) return 1e18;\\n         if(dp[pos][factpos][limit]!=-1) return dp[pos][factpos][limit];\\n\\t\\t // you can always choose to pick next factory along with its limit , whether or not limit of current factory is 0.\\n         long long cnt = factpos + 1 < factory.size() ? solve(pos,factpos+1,factory[factpos+1][1],factory,robot) : 1e18;\\n         if(limit > 0) { // if limit of current factory is not zero , we can choose to pick the current factory for that robot\\n             cnt = min(cnt , (long long) abs(factory[factpos][0] - robot[pos]) + solve(pos+1,factpos,limit - 1,factory,robot)); \\n         }\\n        return dp[pos][factpos][limit] = cnt;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[101][101][101];\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n         sort(robot.begin(),robot.end());\\n         sort(factory.begin(),factory.end());\\n         memset(dp,-1,sizeof(dp));\\n         return solve(0,0,factory[0][1],factory,robot);\\n    }\\n    long long solve(int pos,int factpos,int limit,vector<vector<int>> &factory,vector<int> &robot) {\\n         if(pos>=robot.size()) return 0;\\n         if(factpos>=factory.size()) return 1e18;\\n         if(dp[pos][factpos][limit]!=-1) return dp[pos][factpos][limit];\\n\\t\\t // you can always choose to pick next factory along with its limit , whether or not limit of current factory is 0.\\n         long long cnt = factpos + 1 < factory.size() ? solve(pos,factpos+1,factory[factpos+1][1],factory,robot) : 1e18;\\n         if(limit > 0) { // if limit of current factory is not zero , we can choose to pick the current factory for that robot\\n             cnt = min(cnt , (long long) abs(factory[factpos][0] - robot[pos]) + solve(pos+1,factpos,limit - 1,factory,robot)); \\n         }\\n        return dp[pos][factpos][limit] = cnt;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674776,
                "title": "2d-dp-c",
                "content": "# Intuition\\nSort the robot and factory by position.\\n\\n# Approach\\ndp[i][j] represents the minimum cost of i robots repaired by j factories.\\nCheck for last factory[j][1] number of robots suffix for which dp[i][j] is minimum.\\n\\n# Complexity\\n- Time complexity:\\nO(n * m * n)\\n- Space complexity:\\nO(n * m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& r, vector<vector<int>>& f) {\\n        int n = r.size();\\n        int m = f.size();\\n        \\n        sort(r.begin() , r.end());\\n        sort(f.begin() , f.end());\\n        \\n        long long int dp[n + 1][m + 1];\\n        for(int i = 0; i <= m; i++)\\n        {\\n            dp[0][i] = 0;\\n        }\\n        for(int i = 1; i <= n; i++)\\n        {\\n            dp[i][0] = 1e17;\\n        }\\n\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                dp[i][j] = dp[i][j - 1];\\n                long long int cur = 0;\\n                int sz = max(1 , i - f[j - 1][1] + 1);\\n                for(int k = i; k >= sz; k--)\\n                {\\n                    cur += abs(r[k - 1] - f[j - 1][0]);\\n                    dp[i][j] = min(dp[k - 1][j - 1] + cur , dp[i][j]);\\n                }    \\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& r, vector<vector<int>>& f) {\\n        int n = r.size();\\n        int m = f.size();\\n        \\n        sort(r.begin() , r.end());\\n        sort(f.begin() , f.end());\\n        \\n        long long int dp[n + 1][m + 1];\\n        for(int i = 0; i <= m; i++)\\n        {\\n            dp[0][i] = 0;\\n        }\\n        for(int i = 1; i <= n; i++)\\n        {\\n            dp[i][0] = 1e17;\\n        }\\n\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                dp[i][j] = dp[i][j - 1];\\n                long long int cur = 0;\\n                int sz = max(1 , i - f[j - 1][1] + 1);\\n                for(int k = i; k >= sz; k--)\\n                {\\n                    cur += abs(r[k - 1] - f[j - 1][0]);\\n                    dp[i][j] = min(dp[k - 1][j - 1] + cur , dp[i][j]);\\n                }    \\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614342,
                "title": "simple-c-dp",
                "content": "# Intuition\\nLets define the state of out dp , how many states do we need. Here 3 will be enough to get uniqueness.\\nstate1 : Current Robot\\nstate2 : Current Factory\\nstate3 : Remaining capacity of the current factory\\n\\n# Approach\\nFor given robot and factory(with some capacity <=initial_capacity), at any point of time we can either\\n1. Ignore the current factory and move to the next factory\\n2. Send the Robo to this factory, if factory has the capacity. Then decrease factory capacity by 1.\\n\\n# Complexity\\n- Time complexity:\\n We are just filling the dp with 3 states\\n Transition time is constant (2 transitions only)\\n Let n = number of robots\\n Let m = number of factories\\nTime Complexity => O(n^2 * m);\\n\\n- Space complexity:\\n As We are just filling the dp with 3 states\\nSpace is also O(n^2 + m)\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        ll n=robot.size(),m=factory.size(),i,j,k;\\n        ll dp[n+1][m+1][n+1];\\n        for(i=0;i<=n;i++) for(j=0;j<=m;j++) for(k=0;k<=n;k++) dp[i][j][k]=1e12;\\n        for(j=0;j<=m;j++) for(k=0;k<=n;k++) dp[n][j][k]=0;\\n        for(i=n-1;i>-1;i--) {\\n            for(j=m-1;j>-1;j--) {\\n                for(k=0;k<=n;k++) {\\n                    // ignore current factory\\n                    dp[i][j][k]=dp[i][j+1][0];\\n                    // can we occupy current facotory\\n                    if(k<factory[j][1]) dp[i][j][k]=min(dp[i][j][k],abs(factory[j][0]-robot[i]) + dp[i+1][j][k+1]);\\n                }\\n            }\\n        }\\n        return dp[0][0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        ll n=robot.size(),m=factory.size(),i,j,k;\\n        ll dp[n+1][m+1][n+1];\\n        for(i=0;i<=n;i++) for(j=0;j<=m;j++) for(k=0;k<=n;k++) dp[i][j][k]=1e12;\\n        for(j=0;j<=m;j++) for(k=0;k<=n;k++) dp[n][j][k]=0;\\n        for(i=n-1;i>-1;i--) {\\n            for(j=m-1;j>-1;j--) {\\n                for(k=0;k<=n;k++) {\\n                    // ignore current factory\\n                    dp[i][j][k]=dp[i][j+1][0];\\n                    // can we occupy current facotory\\n                    if(k<factory[j][1]) dp[i][j][k]=min(dp[i][j][k],abs(factory[j][0]-robot[i]) + dp[i+1][j][k+1]);\\n                }\\n            }\\n        }\\n        return dp[0][0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425576,
                "title": "simple-memoization-in-python-with-explanation",
                "content": "# Approach\\nSort the factories and the robots according to their positions. \\nFrom the left to the right, at each factory we explore all possible assignment of robots and find the optimized solution. The details are shown in the comments. \\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2m)$$ where $$n$$ is the number of robots and $$m$$ is the number of factories. \\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def dp(self, i, j):\\n        # All robots are repaired\\n        if i >= self.n:  \\n            return 0\\n        # Some robots not repaired yet but no factory remaining\\n        if j >= self.m:\\n            return inf\\n        cost = 0\\n        ans = self.dp(i, j+1)  # Assign 0 robot to this factory\\n        for k in range(min(self.n - i, self.factory[j][1])):\\n            cost += abs(self.robot[i+k] - self.factory[j][0])\\n            ans = min(ans, cost + self.dp(i+k+1, j+1))\\n        return ans\\n\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        # Sort robots and factories accoding to their positions\\n        self.robot = sorted(robot)\\n        self.factory = sorted(factory)\\n        self.n, self.m = len(self.robot), len(self.factory)\\n        return self.dp(0, 0)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    @cache\\n    def dp(self, i, j):\\n        # All robots are repaired\\n        if i >= self.n:  \\n            return 0\\n        # Some robots not repaired yet but no factory remaining\\n        if j >= self.m:\\n            return inf\\n        cost = 0\\n        ans = self.dp(i, j+1)  # Assign 0 robot to this factory\\n        for k in range(min(self.n - i, self.factory[j][1])):\\n            cost += abs(self.robot[i+k] - self.factory[j][0])\\n            ans = min(ans, cost + self.dp(i+k+1, j+1))\\n        return ans\\n\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        # Sort robots and factories accoding to their positions\\n        self.robot = sorted(robot)\\n        self.factory = sorted(factory)\\n        self.n, self.m = len(self.robot), len(self.factory)\\n        return self.dp(0, 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425569,
                "title": "simple-memoization-in-python-with-explanation",
                "content": "# Approach\\nSort the factories and the robots according to their positions. \\nFrom the left to the right, at each factory we explore all possible assignment of robots and find the optimized solution. \\n\\n\\n# Complexity\\n- Time complexity: $$O(nm)$$ where $$n$$ is the number of robots and $$mm$$ is the number of factories. \\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def dp(self, i, j):\\n        if i >= self.n:\\n            return 0\\n        if j >= self.m:\\n            return inf\\n        cost = 0\\n        ans = self.dp(i, j+1)\\n        for k in range(min(self.n - i, self.factory[j][1])):\\n            cost += abs(self.robot[i+k] - self.factory[j][0])\\n            ans = min(ans, cost + self.dp(i+k+1, j+1))\\n        return ans\\n\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        self.robot = sorted(robot)\\n        self.factory = sorted(factory)\\n        self.n, self.m = len(self.robot), len(self.factory)\\n        return self.dp(0, 0)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    @cache\\n    def dp(self, i, j):\\n        if i >= self.n:\\n            return 0\\n        if j >= self.m:\\n            return inf\\n        cost = 0\\n        ans = self.dp(i, j+1)\\n        for k in range(min(self.n - i, self.factory[j][1])):\\n            cost += abs(self.robot[i+k] - self.factory[j][0])\\n            ans = min(ans, cost + self.dp(i+k+1, j+1))\\n        return ans\\n\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        self.robot = sorted(robot)\\n        self.factory = sorted(factory)\\n        self.n, self.m = len(self.robot), len(self.factory)\\n        return self.dp(0, 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295445,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool custom(vector<int>& v1,vector<int>& v2)\\n    {\\n        return v1[0]<v2[0];\\n    }\\n    long long F[101][101];\\n    long long memoi(int x,int y,vector<int>& robot,vector<vector<int>>& factory)\\n    {\\n        if(x==robot.size()) return 0;\\n        if(y==factory.size()) return -1;\\n        if(F[x][y]!=-1) return F[x][y];\\n        long long mi=LLONG_MAX,a=0,v,f;\\n        f=memoi(x,y+1,robot,factory);\\n        if(f!=-1) mi=f;\\n        for(int i=1;i<=factory[y][1];i++)\\n        {\\n            if(x+i>robot.size()) break;\\n            a=a+abs(factory[y][0]-robot[x+i-1]);\\n            f=memoi(x+i,y+1,robot,factory);\\n            if(f==-1) continue;\\n            v=a+f;\\n            if(mi>v) mi=v;\\n        }\\n        if(mi==LLONG_MAX) mi=-1;\\n        return F[x][y]=mi;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end(),custom);\\n        memset(F,-1,sizeof(F));\\n        return memoi(0,0,robot,factory);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool custom(vector<int>& v1,vector<int>& v2)\\n    {\\n        return v1[0]<v2[0];\\n    }\\n    long long F[101][101];\\n    long long memoi(int x,int y,vector<int>& robot,vector<vector<int>>& factory)\\n    {\\n        if(x==robot.size()) return 0;\\n        if(y==factory.size()) return -1;\\n        if(F[x][y]!=-1) return F[x][y];\\n        long long mi=LLONG_MAX,a=0,v,f;\\n        f=memoi(x,y+1,robot,factory);\\n        if(f!=-1) mi=f;\\n        for(int i=1;i<=factory[y][1];i++)\\n        {\\n            if(x+i>robot.size()) break;\\n            a=a+abs(factory[y][0]-robot[x+i-1]);\\n            f=memoi(x+i,y+1,robot,factory);\\n            if(f==-1) continue;\\n            v=a+f;\\n            if(mi>v) mi=v;\\n        }\\n        if(mi==LLONG_MAX) mi=-1;\\n        return F[x][y]=mi;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end(),custom);\\n        memset(F,-1,sizeof(F));\\n        return memoi(0,0,robot,factory);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293935,
                "title": "c-maximum-flow-minimum-cost-flow",
                "content": "# Code\\n```\\npublic class Solution {\\n    const int N = (int)1e5 + 1, M = (int)1e6 + 1, INF = (int)1e9;\\n    int[] pre = new int[M], incf = new int[M], f = new int[M], w = new int[M];\\n    int[] h = new int[N], ne = new int[M], e = new int[M];\\n    long[] d = new long[M];\\n    bool[] st = new bool[M];\\n    int idx = 0, T = 0, S = 0; \\n    public long MinimumTotalDistance(IList<int> robot, int[][] factory) {\\n        Array.Fill(h, -1);\\n        int n = robot.Count, m = factory.Length;\\n        S = n + m + 1; T = n + m + 2;\\n        long cost = 0;\\n        for(int i = 0; i < n; i++) Add(S, i, 1, 0);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++)\\n                Add(i, j + n, 1, Math.Abs(robot[i] - factory[j][0]));\\n        }\\n        for(int i = 0; i < m; i++) Add(i + n, T, factory[i][1], 0);\\n        EK(ref cost);\\n        return cost;\\n    }\\n\\n    public void EK(ref long cost){\\n        while (Spfa()) {\\n            int t = incf[T];\\n            cost += d[T] * t;\\n            for (int i = T; i != S; i = e[pre[i] ^ 1]) {\\n                f[pre[i]] -= t;\\n                f[pre[i] ^ 1] += t;\\n            }\\n        }\\n    }\\n\\n    public bool Spfa(){\\n        Array.Fill(d, (long)1e18);\\n        Array.Fill(incf, 0);\\n        Queue<int> q = new();\\n        q.Enqueue(S); d[S] = 0; incf[S] = INF;\\n        while (q.Count > 0) {\\n            int u = q.Dequeue();\\n            st[u] = false;\\n            for (int i = h[u]; i != -1; i = ne[i]) {\\n                int j = e[i];\\n                if (f[i] > 0 && d[j] > d[u] + w[i]) {\\n                    d[j] = d[u] + w[i];\\n                    pre[j] = i;\\n                    incf[j] = Math.Min(incf[u], f[i]);\\n                    if (!st[j]) {\\n                        q.Enqueue(j);\\n                        st[j] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return incf[T] > 0;\\n    }\\n\\n    public void Add(int u, int v, int c, int t){\\n        e[idx] = v; f[idx] = c; w[idx] = t; ne[idx] = h[u]; h[u] = idx++;\\n        e[idx] = u; f[idx] = 0; w[idx] = -t; ne[idx] = h[v]; h[v] = idx++; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    const int N = (int)1e5 + 1, M = (int)1e6 + 1, INF = (int)1e9;\\n    int[] pre = new int[M], incf = new int[M], f = new int[M], w = new int[M];\\n    int[] h = new int[N], ne = new int[M], e = new int[M];\\n    long[] d = new long[M];\\n    bool[] st = new bool[M];\\n    int idx = 0, T = 0, S = 0; \\n    public long MinimumTotalDistance(IList<int> robot, int[][] factory) {\\n        Array.Fill(h, -1);\\n        int n = robot.Count, m = factory.Length;\\n        S = n + m + 1; T = n + m + 2;\\n        long cost = 0;\\n        for(int i = 0; i < n; i++) Add(S, i, 1, 0);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++)\\n                Add(i, j + n, 1, Math.Abs(robot[i] - factory[j][0]));\\n        }\\n        for(int i = 0; i < m; i++) Add(i + n, T, factory[i][1], 0);\\n        EK(ref cost);\\n        return cost;\\n    }\\n\\n    public void EK(ref long cost){\\n        while (Spfa()) {\\n            int t = incf[T];\\n            cost += d[T] * t;\\n            for (int i = T; i != S; i = e[pre[i] ^ 1]) {\\n                f[pre[i]] -= t;\\n                f[pre[i] ^ 1] += t;\\n            }\\n        }\\n    }\\n\\n    public bool Spfa(){\\n        Array.Fill(d, (long)1e18);\\n        Array.Fill(incf, 0);\\n        Queue<int> q = new();\\n        q.Enqueue(S); d[S] = 0; incf[S] = INF;\\n        while (q.Count > 0) {\\n            int u = q.Dequeue();\\n            st[u] = false;\\n            for (int i = h[u]; i != -1; i = ne[i]) {\\n                int j = e[i];\\n                if (f[i] > 0 && d[j] > d[u] + w[i]) {\\n                    d[j] = d[u] + w[i];\\n                    pre[j] = i;\\n                    incf[j] = Math.Min(incf[u], f[i]);\\n                    if (!st[j]) {\\n                        q.Enqueue(j);\\n                        st[j] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return incf[T] > 0;\\n    }\\n\\n    public void Add(int u, int v, int c, int t){\\n        e[idx] = v; f[idx] = c; w[idx] = t; ne[idx] = h[u]; h[u] = idx++;\\n        e[idx] = u; f[idx] = 0; w[idx] = -t; ne[idx] = h[v]; h[v] = idx++; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247905,
                "title": "simplest-memorized-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nSolution 1\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        @cache \\n        def f(i, j, k):\\n            if j < len(factory) and k > factory[j][1]:\\n                return inf\\n            if i == len(robot):\\n                return 0\\n            if j == len(factory):\\n                return inf\\n            return min(f(i, j + 1, 0), f(i + 1, j, k + 1) + abs(robot[i] - factory[j][0])) \\n        robot.sort()\\n        factory.sort()\\n        return f(0, 0, 0)\\n```\\n\\nSolution2\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        @cache \\n        def dfs(i, j):\\n            if i == len(robot):\\n                return 0\\n            if j == len(factory):\\n                return inf\\n            pos, limit = factory[j]\\n            ans = dfs(i, j + 1)\\n            walk = 0\\n            for k in range(limit):\\n                if i + k == len(robot):\\n                    break\\n                walk += abs(robot[i + k] - pos)\\n                ans = min(ans, dfs(i + k + 1, j + 1) + walk)\\n            return ans \\n        robot.sort()\\n        factory.sort()\\n        return dfs(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        @cache \\n        def f(i, j, k):\\n            if j < len(factory) and k > factory[j][1]:\\n                return inf\\n            if i == len(robot):\\n                return 0\\n            if j == len(factory):\\n                return inf\\n            return min(f(i, j + 1, 0), f(i + 1, j, k + 1) + abs(robot[i] - factory[j][0])) \\n        robot.sort()\\n        factory.sort()\\n        return f(0, 0, 0)\\n```\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        @cache \\n        def dfs(i, j):\\n            if i == len(robot):\\n                return 0\\n            if j == len(factory):\\n                return inf\\n            pos, limit = factory[j]\\n            ans = dfs(i, j + 1)\\n            walk = 0\\n            for k in range(limit):\\n                if i + k == len(robot):\\n                    break\\n                walk += abs(robot[i + k] - pos)\\n                ans = min(ans, dfs(i + k + 1, j + 1) + walk)\\n            return ans \\n        robot.sort()\\n        factory.sort()\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247812,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot, factory):\\n        m, n = len(robot), len(factory)\\n\\n        robot.sort()\\n        factory.sort()\\n\\n        @lru_cache(None)\\n        def dfs(i,j,k):\\n            if i >= m:\\n                return 0\\n\\n            if j >= n:\\n                return float(\"inf\")\\n\\n            res1 = dfs(i,j+1,0)\\n            res2 = dfs(i+1,j,k+1) + abs(robot[i] - factory[j][0]) if factory[j][1] > k else float(\"inf\")\\n\\n            return min(res1,res2)\\n\\n        return dfs(0,0,0)\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot, factory):\\n        m, n = len(robot), len(factory)\\n\\n        robot.sort()\\n        factory.sort()\\n\\n        @lru_cache(None)\\n        def dfs(i,j,k):\\n            if i >= m:\\n                return 0\\n\\n            if j >= n:\\n                return float(\"inf\")\\n\\n            res1 = dfs(i,j+1,0)\\n            res2 = dfs(i+1,j,k+1) + abs(robot[i] - factory[j][0]) if factory[j][1] > k else float(\"inf\")\\n\\n            return min(res1,res2)\\n\\n        return dfs(0,0,0)\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224505,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    long long dp[101][101][101];\\n    long long solve(int i, int j, vector<int> &robot, vector<vector<int>> &factory, int lim){\\n        if(i<0){\\n            return 0;\\n        }\\n        if(dp[i][j][lim] != -1){\\n            return dp[i][j][lim];\\n        }       \\n        long long ans = 1e18;\\n        if(lim > 0){\\n            ans = min(ans, abs(factory[j][0]-robot[i]) + solve(i-1, j, robot, factory, lim-1));\\n        }       \\n        if(j-1 >= 0){\\n            ans = min(ans, solve(i, j-1, robot, factory, factory[j-1][1]));\\n        }\\n        return dp[i][j][lim] = ans;\\n    }\\n    long long minimumTotalDistance(vector<int> &robot, vector<vector<int>> &factory) {\\n        int n = robot.size();\\n        int m = factory.size();\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        memset(dp, -1, sizeof(dp));\\n        return solve(n-1, m-1, robot, factory, factory[m-1][1]);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    long long dp[101][101][101];\\n    long long solve(int i, int j, vector<int> &robot, vector<vector<int>> &factory, int lim){\\n        if(i<0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3174449,
                "title": "c-easy-dp",
                "content": "\\n\\n# Code\\n```\\ntypedef long long int ll;\\nconst ll INF = 1e15;\\n\\nclass Solution {\\n     vector<vector<int>> factories;\\n    vector<int> robots;\\n    vector<vector<ll>> dp;\\n    \\n    ll MinimumTotalDistance(int f_ind,int r_ind)\\n    {\\n        int r = robots.size();\\n        int f = factories.size();\\n        \\n        if(r_ind == r) return 0;\\n        if(f_ind == f) return INF;\\n        \\n        ll &ans = dp[f_ind][r_ind];\\n        if(ans != -1) return ans;\\n        ans = INF;\\n        \\n        int f_position = factories[f_ind][0];\\n        int f_capacity = factories[f_ind][1];\\n        \\n        for(int repaired = 0;repaired <= f_capacity;repaired++){\\n            ll repair_cost = 0;\\n            int j;\\n            for(j = r_ind;j<r && j<r_ind+repaired;j++){\\n                repair_cost += abs(robots[j]-f_position);\\n            }\\n            \\n            ans = min(ans,repair_cost + MinimumTotalDistance(f_ind+1,j));\\n        }\\n        return ans;\\n            \\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        \\n        robots = robot;\\n        factories = factory;\\n        \\n        dp.clear();\\n        dp.resize(factory.size(),vector<ll>(robots.size(),-1));\\n        \\n        return MinimumTotalDistance(0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\nconst ll INF = 1e15;\\n\\nclass Solution {\\n     vector<vector<int>> factories;\\n    vector<int> robots;\\n    vector<vector<ll>> dp;\\n    \\n    ll MinimumTotalDistance(int f_ind,int r_ind)\\n    {\\n        int r = robots.size();\\n        int f = factories.size();\\n        \\n        if(r_ind == r) return 0;\\n        if(f_ind == f) return INF;\\n        \\n        ll &ans = dp[f_ind][r_ind];\\n        if(ans != -1) return ans;\\n        ans = INF;\\n        \\n        int f_position = factories[f_ind][0];\\n        int f_capacity = factories[f_ind][1];\\n        \\n        for(int repaired = 0;repaired <= f_capacity;repaired++){\\n            ll repair_cost = 0;\\n            int j;\\n            for(j = r_ind;j<r && j<r_ind+repaired;j++){\\n                repair_cost += abs(robots[j]-f_position);\\n            }\\n            \\n            ans = min(ans,repair_cost + MinimumTotalDistance(f_ind+1,j));\\n        }\\n        return ans;\\n            \\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        \\n        robots = robot;\\n        factories = factory;\\n        \\n        dp.clear();\\n        dp.resize(factory.size(),vector<ll>(robots.size(),-1));\\n        \\n        return MinimumTotalDistance(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018708,
                "title": "java-solution-with-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    long[][] memo;\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        if(robot.isEmpty()) return 0;\\n        List<Integer> factories = new ArrayList<>();\\n\\n        // add how many times a factory can repair a robot to a list\\n        //transform from this [[2,2][6,6]] to [2, 2, 6, 6]\\n        for(int[] f: factory) {\\n            while(f[1] > 0) {\\n                factories.add(f[0]);\\n                f[1]--;\\n            }\\n        }\\n        memo = new long[robot.size()+1][factories.size()+1];\\n        for(long[] arr: memo) {\\n            Arrays.fill(arr, -1l);\\n        }\\n        Collections.sort(factories);\\n        Collections.sort(robot);\\n        return getMinCost(robot, factories, 0, 0);\\n    }\\n\\n    private long getMinCost(List<Integer> robot, List<Integer> factory, int i, int j) {\\n        if(robot.size()-i > factory.size()-j) return Long.MAX_VALUE;\\n        if(i == robot.size()) {\\n            return 0;\\n        }\\n\\n        if(memo[i][j] != -1) {\\n            return memo[i][j];\\n        }\\n        // case when robot i was repaired at factory j\\n        long cost1 = getMinCost(robot, factory, i+1, j+1) + \\n                         Math.abs(factory.get(j)-robot.get(i));\\n        // case when robot i was not repaired yet\\n        long cost2 = getMinCost(robot, factory, i, j+1);\\n        \\n        long min = Math.min(cost1, cost2);\\n        memo[i][j] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long[][] memo;\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        if(robot.isEmpty()) return 0;\\n        List<Integer> factories = new ArrayList<>();\\n\\n        // add how many times a factory can repair a robot to a list\\n        //transform from this [[2,2][6,6]] to [2, 2, 6, 6]\\n        for(int[] f: factory) {\\n            while(f[1] > 0) {\\n                factories.add(f[0]);\\n                f[1]--;\\n            }\\n        }\\n        memo = new long[robot.size()+1][factories.size()+1];\\n        for(long[] arr: memo) {\\n            Arrays.fill(arr, -1l);\\n        }\\n        Collections.sort(factories);\\n        Collections.sort(robot);\\n        return getMinCost(robot, factories, 0, 0);\\n    }\\n\\n    private long getMinCost(List<Integer> robot, List<Integer> factory, int i, int j) {\\n        if(robot.size()-i > factory.size()-j) return Long.MAX_VALUE;\\n        if(i == robot.size()) {\\n            return 0;\\n        }\\n\\n        if(memo[i][j] != -1) {\\n            return memo[i][j];\\n        }\\n        // case when robot i was repaired at factory j\\n        long cost1 = getMinCost(robot, factory, i+1, j+1) + \\n                         Math.abs(factory.get(j)-robot.get(i));\\n        // case when robot i was not repaired yet\\n        long cost2 = getMinCost(robot, factory, i, j+1);\\n        \\n        long min = Math.min(cost1, cost2);\\n        memo[i][j] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931544,
                "title": "golang-search-with-memoization",
                "content": "\\n\\n# Code\\n```\\nfunc minimumTotalDistance(robot []int, factory [][]int) int64 {\\n    sort.Ints(robot)\\n    sort.Slice(factory, func(i int, j int) bool {\\n        return factory[i][0] < factory[j][0]\\n    })\\n\\n    memo := make([][][]int, len(robot) + 1)\\n    for i := 0; i < len(memo); i++ {\\n        memo[i] = make([][]int, len(factory) + 1)\\n        for j := 0; j < len(memo[i]); j++ {\\n            memo[i][j] = make([]int, len(robot) + 1)\\n            for k := 0; k < len(memo[i][j]); k++ {\\n                memo[i][j][k] = -1\\n            }\\n        }\\n    }\\n\\n    return int64(dfs(robot, factory, memo))\\n}\\n\\nfunc dfs(robot []int, factory [][]int, memo [][][]int) int {\\n    if len(robot) == 0 {\\n        return 0\\n    }\\n\\n    if len(factory) == 0 {\\n        return -1\\n    }\\n\\n    if factory[0][1] == 0 {\\n        return dfs(robot, factory[1:], memo)\\n    }\\n\\n    if memo[len(robot)][len(factory)][factory[0][1]] != -1 {\\n        return memo[len(robot)][len(factory)][factory[0][1]]\\n    }\\n\\n    a := dfs(robot, factory[1:], memo)\\n    factory[0][1]--\\n    b := dfs(robot[1:], factory, memo)\\n    factory[0][1]++\\n    \\n    res := 0\\n\\n    if a == -1 && b == -1 {\\n        res = -1\\n    } else if a == -1 {\\n        res = b + abs(robot[0] - factory[0][0])\\n    } else if b == -1 {\\n        res = a\\n    } else {\\n        res = min(a, b + abs(robot[0] - factory[0][0]))\\n    }\\n\\n    memo[len(robot)][len(factory)][factory[0][1]] = res\\n\\n    return res\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumTotalDistance(robot []int, factory [][]int) int64 {\\n    sort.Ints(robot)\\n    sort.Slice(factory, func(i int, j int) bool {\\n        return factory[i][0] < factory[j][0]\\n    })\\n\\n    memo := make([][][]int, len(robot) + 1)\\n    for i := 0; i < len(memo); i++ {\\n        memo[i] = make([][]int, len(factory) + 1)\\n        for j := 0; j < len(memo[i]); j++ {\\n            memo[i][j] = make([]int, len(robot) + 1)\\n            for k := 0; k < len(memo[i][j]); k++ {\\n                memo[i][j][k] = -1\\n            }\\n        }\\n    }\\n\\n    return int64(dfs(robot, factory, memo))\\n}\\n\\nfunc dfs(robot []int, factory [][]int, memo [][][]int) int {\\n    if len(robot) == 0 {\\n        return 0\\n    }\\n\\n    if len(factory) == 0 {\\n        return -1\\n    }\\n\\n    if factory[0][1] == 0 {\\n        return dfs(robot, factory[1:], memo)\\n    }\\n\\n    if memo[len(robot)][len(factory)][factory[0][1]] != -1 {\\n        return memo[len(robot)][len(factory)][factory[0][1]]\\n    }\\n\\n    a := dfs(robot, factory[1:], memo)\\n    factory[0][1]--\\n    b := dfs(robot[1:], factory, memo)\\n    factory[0][1]++\\n    \\n    res := 0\\n\\n    if a == -1 && b == -1 {\\n        res = -1\\n    } else if a == -1 {\\n        res = b + abs(robot[0] - factory[0][0])\\n    } else if b == -1 {\\n        res = a\\n    } else {\\n        res = min(a, b + abs(robot[0] - factory[0][0]))\\n    }\\n\\n    memo[len(robot)][len(factory)][factory[0][1]] = res\\n\\n    return res\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2905292,
                "title": "clean-c-code-beats-89-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo, basically assign different robots to factories and you can also skip factories not necessary every factory should be assigned, but definitely every robot should be assigned\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdopt a basic recursive approach, before this just sort the arrays, so you don\\'t have to take random robots for a factory you can take any subarray\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(2^(n*4))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(n * m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& A, vector<int>& B) {\\n        return A[0] < B[0];\\n    }\\n    long long solve(vector<int>& robot, vector<vector<int>>& factory, int robo_pos, int fac_pos, vector<vector<long long>>& dp) {\\n        if(robot.size() <= robo_pos) {\\n            return 0;\\n        }\\n        if(factory.size() <= fac_pos) {\\n            return LLONG_MAX;\\n        }\\n        if(dp[robo_pos][fac_pos] != -1) {\\n            return dp[robo_pos][fac_pos];\\n        }\\n        long long result = 0, cost = 0, answer = LLONG_MAX;\\n        int factory_limit = factory[fac_pos][1]; \\n        \\n        result = solve(robot, factory, robo_pos, fac_pos + 1, dp);\\n        if(result != LLONG_MAX) {\\n            answer = min(answer, result);\\n        }\\n       \\n        for(int i = robo_pos; i < min(robo_pos + factory_limit, (int)robot.size()); ++i) {\\n            cost += abs(robot[i] - factory[fac_pos][0]);\\n            result = solve(robot, factory, i + 1, fac_pos + 1, dp);\\n            if(result != LLONG_MAX) {\\n                answer = min(answer, cost + result);\\n            }\\n        }\\n\\n        return dp[robo_pos][fac_pos] = answer;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end(), cmp);\\n        int n = robot.size(), m = factory.size();\\n        vector<vector<long long>> dp(n, vector<long long>(m, -1));\\n        return solve(robot, factory, 0, 0, dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& A, vector<int>& B) {\\n        return A[0] < B[0];\\n    }\\n    long long solve(vector<int>& robot, vector<vector<int>>& factory, int robo_pos, int fac_pos, vector<vector<long long>>& dp) {\\n        if(robot.size() <= robo_pos) {\\n            return 0;\\n        }\\n        if(factory.size() <= fac_pos) {\\n            return LLONG_MAX;\\n        }\\n        if(dp[robo_pos][fac_pos] != -1) {\\n            return dp[robo_pos][fac_pos];\\n        }\\n        long long result = 0, cost = 0, answer = LLONG_MAX;\\n        int factory_limit = factory[fac_pos][1]; \\n        \\n        result = solve(robot, factory, robo_pos, fac_pos + 1, dp);\\n        if(result != LLONG_MAX) {\\n            answer = min(answer, result);\\n        }\\n       \\n        for(int i = robo_pos; i < min(robo_pos + factory_limit, (int)robot.size()); ++i) {\\n            cost += abs(robot[i] - factory[fac_pos][0]);\\n            result = solve(robot, factory, i + 1, fac_pos + 1, dp);\\n            if(result != LLONG_MAX) {\\n                answer = min(answer, cost + result);\\n            }\\n        }\\n\\n        return dp[robo_pos][fac_pos] = answer;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end(), cmp);\\n        int n = robot.size(), m = factory.size();\\n        vector<vector<long long>> dp(n, vector<long long>(m, -1));\\n        return solve(robot, factory, 0, 0, dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857690,
                "title": "very-short-python3-recursive-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        F =[];dp = {};Id = {}\\n        for i,j in sorted(factory):\\n            t = len(F)\\n            for k in range(j):\\n                F.append(i)\\n                Id[len(F)-1] = t + j\\n        robot.sort()\\n\\n        @lru_cache(None)\\n        def fun(x,y):\\n            if x == len(robot): return 0\\n            if y == len(F): return 1e15 \\n            return min(fun(x+1,y+1) + abs(robot[x] - F[y]), fun(x,Id[y]))\\n\\n        return fun(0,0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        F =[];dp = {};Id = {}\\n        for i,j in sorted(factory):\\n            t = len(F)\\n            for k in range(j):\\n                F.append(i)\\n                Id[len(F)-1] = t + j\\n        robot.sort()\\n\\n        @lru_cache(None)\\n        def fun(x,y):\\n            if x == len(robot): return 0\\n            if y == len(F): return 1e15 \\n            return min(fun(x+1,y+1) + abs(robot[x] - F[y]), fun(x,Id[y]))\\n\\n        return fun(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843355,
                "title": "c-easy-simple-o-n-3-dp-solution-with-comments-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long memo[101][101][101];\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int n = size(robot);\\n        int m = size(factory);\\n        sort(begin(robot), end(robot));\\n        sort(begin(factory), end(factory));\\n        memset(memo, -1, sizeof memo);\\n        return solve(0,0,factory[0][1],n,m,robot,factory);\\n    }\\n    // i = robotIdx, j = factoryIDx, rem = rem limit in factory\\n    long long solve(int i, int j, int rem, int& n, int& m, vector<int>& robot, vector<vector<int>>& factory) {\\n        if(i == n || j == m) {\\n            return i == n ? 0 : LONG_LONG_MAX; // if we fixed all robots then return 0 else inf\\n        }\\n        auto& ans = memo[i][j][rem];\\n        if (ans != -1) return ans;\\n        ans = solve(i,j+1, j+1 < m ? factory[j+1][1] : 0, n,m,robot,factory); // skip this factory and try the next one with the same robot\\n        if (rem) { // try to use this factory and move to the next robot\\n            long long cost = abs(robot[i] - factory[j][0]);\\n            auto next = solve(i+1,j,rem-1,n,m,robot,factory);\\n            if (next != LONG_LONG_MAX) { // avoid overflow\\n                ans = min(ans, cost + next);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long memo[101][101][101];\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int n = size(robot);\\n        int m = size(factory);\\n        sort(begin(robot), end(robot));\\n        sort(begin(factory), end(factory));\\n        memset(memo, -1, sizeof memo);\\n        return solve(0,0,factory[0][1],n,m,robot,factory);\\n    }\\n    // i = robotIdx, j = factoryIDx, rem = rem limit in factory\\n    long long solve(int i, int j, int rem, int& n, int& m, vector<int>& robot, vector<vector<int>>& factory) {\\n        if(i == n || j == m) {\\n            return i == n ? 0 : LONG_LONG_MAX; // if we fixed all robots then return 0 else inf\\n        }\\n        auto& ans = memo[i][j][rem];\\n        if (ans != -1) return ans;\\n        ans = solve(i,j+1, j+1 < m ? factory[j+1][1] : 0, n,m,robot,factory); // skip this factory and try the next one with the same robot\\n        if (rem) { // try to use this factory and move to the next robot\\n            long long cost = abs(robot[i] - factory[j][0]);\\n            auto next = solve(i+1,j,rem-1,n,m,robot,factory);\\n            if (next != LONG_LONG_MAX) { // avoid overflow\\n                ans = min(ans, cost + next);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837667,
                "title": "bottom-up-dp",
                "content": "```\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        // arrangement\\n        int k = factory.length;\\n        int n = robot.size();\\n        Collections.sort(robot);\\n        Arrays.sort(factory, new Comparator<>(){\\n            public int compare(int[] one, int[] two) {\\n                return one[0] - two[0];\\n            }\\n        });\\n        //\\n        long[][] dp = new long[k][n];\\n        // initial state: handle i-1 (i==0)\\n        for (int i = 0; i < n; i++) {\\n            int limit = factory[0][1];\\n            if (i+1 <= limit) {\\n                if (i == 0) {\\n                    dp[0][i] = (long)Math.abs(factory[0][0] - robot.get(i));\\n                } else {\\n                    dp[0][i] = dp[0][i-1] + (long)Math.abs(factory[0][0] - robot.get(i));\\n                }\\n            } else {\\n                dp[0][i] = Long.MAX_VALUE/2; // change to -1 in the future\\n            }\\n        }\\n\\n        // dp\\n        for (int i = 1; i < k; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // dp[i-1][j - m]\\n                dp[i][j] = dp[i-1][j];\\n                long cost = 0l;\\n                for (int m = 1; m <= factory[i][1] && j-m+1 >= 0; m++) {\\n                    cost += (long)Math.abs(factory[i][0] - robot.get(j-m+1));\\n                    if (j-m+1 == 0) {\\n                        dp[i][j] = Math.min(dp[i][j], cost);\\n                    } else {\\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][j-m] + cost);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[k-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        // arrangement\\n        int k = factory.length;\\n        int n = robot.size();\\n        Collections.sort(robot);\\n        Arrays.sort(factory, new Comparator<>(){\\n            public int compare(int[] one, int[] two) {\\n                return one[0] - two[0];\\n            }\\n        });\\n        //\\n        long[][] dp = new long[k][n];\\n        // initial state: handle i-1 (i==0)\\n        for (int i = 0; i < n; i++) {\\n            int limit = factory[0][1];\\n            if (i+1 <= limit) {\\n                if (i == 0) {\\n                    dp[0][i] = (long)Math.abs(factory[0][0] - robot.get(i));\\n                } else {\\n                    dp[0][i] = dp[0][i-1] + (long)Math.abs(factory[0][0] - robot.get(i));\\n                }\\n            } else {\\n                dp[0][i] = Long.MAX_VALUE/2; // change to -1 in the future\\n            }\\n        }\\n\\n        // dp\\n        for (int i = 1; i < k; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // dp[i-1][j - m]\\n                dp[i][j] = dp[i-1][j];\\n                long cost = 0l;\\n                for (int m = 1; m <= factory[i][1] && j-m+1 >= 0; m++) {\\n                    cost += (long)Math.abs(factory[i][0] - robot.get(j-m+1));\\n                    if (j-m+1 == 0) {\\n                        dp[i][j] = Math.min(dp[i][j], cost);\\n                    } else {\\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][j-m] + cost);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[k-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832504,
                "title": "python3-dp-solution-commented-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort(); factory.sort()\\n        \\n        @cache\\n        def dp(numRobots: int, numFactories: int, numRobotsRepaired: int) -> int:\\n            # If all robots are repaired, it\\'s possible\\n            if numRobots == len(robot): \\n                return 0\\n            # If all factories are used up without repairing all robots, it\\'s immpossible\\n            if numFactories == len(factory): \\n                return inf\\n            # Leave: Don\\'t repair current robot at current factory\\n            ans1 = dp(numRobots, numFactories + 1, 0)\\n            # Take: Check the conditions and if the conditions are satisfied, \\n            # repair the current robot at current factory\\n            ans2 = dp(numRobots + 1, numFactories, numRobotsRepaired + 1) + abs(robot[numRobots] - factory[numFactories][0]) if factory[numFactories][1] > numRobotsRepaired else inf\\n            # return minimum of leave and take\\n            return min(ans1, ans2)\\n        \\n        return dp(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort(); factory.sort()\\n        \\n        @cache\\n        def dp(numRobots: int, numFactories: int, numRobotsRepaired: int) -> int:\\n            # If all robots are repaired, it\\'s possible\\n            if numRobots == len(robot): \\n                return 0\\n            # If all factories are used up without repairing all robots, it\\'s immpossible\\n            if numFactories == len(factory): \\n                return inf\\n            # Leave: Don\\'t repair current robot at current factory\\n            ans1 = dp(numRobots, numFactories + 1, 0)\\n            # Take: Check the conditions and if the conditions are satisfied, \\n            # repair the current robot at current factory\\n            ans2 = dp(numRobots + 1, numFactories, numRobotsRepaired + 1) + abs(robot[numRobots] - factory[numFactories][0]) if factory[numFactories][1] > numRobotsRepaired else inf\\n            # return minimum of leave and take\\n            return min(ans1, ans2)\\n        \\n        return dp(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827603,
                "title": "c-classic-top-down-dp-solution-with-memoization",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any robot i we can either fix it in the given factory (if the factory still did not reach its limit) or skip the current factory (i.e. fix the robot later on in later factory). So answer will be minimum of those two possibilities.\\n\\nBase cases:\\nIf we reach end of robot array, it means we have processed all robots and so we return 0\\nIf we reach end of factory array and not reach end of robot array, it means there are no factories left to fix the robots and there are still robots left to be fixed, so we return INF\\n\\nMemoization:\\nFor each state (i, j, k), save the answer in memo array so that each state is computed at most once.\\n\\n\\n# Complexity\\n- Time complexity: O(rbt.size() * fctry.size() * limit), where limit <= rbt.size() and fctry.size() <= rbt.size(). So it equivalent to O(n^3) where n is rbt.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^3)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define INF 1e12 // ans at most 2e9 * 100 = 2e11, so set INF to 1e12\\n#define ll long long\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    vi rbt;\\n    vector<vi> fctry;\\n    \\n    ll memo[101][101][101];\\n    ll getAns(int i, int j, int k) {\\n        if (i == rbt.size())\\n            return 0;\\n        if (j == fctry.size())\\n            return INF;\\n        \\n        if (memo[i][j][k])\\n            return memo[i][j][k];\\n        \\n        // option 1: fix robot i at factory j if it still has a capacity\\n        ll x = (k < fctry[j][1]) ? abs(rbt[i] - fctry[j][0]) + getAns(i + 1, j, k + 1) : INF;\\n        \\n        // option 2: skip factory j\\n        ll y = getAns(i, j + 1, 0);\\n       \\n        return memo[i][j][k] = min(x, y);\\n    }\\n    \\n    ll minimumTotalDistance(vi robot, vector<vi> factory) {\\n        rbt = robot, fctry = factory;\\n        sort(fctry.begin(), fctry.end());\\n        sort(rbt.begin(), rbt.end());   \\n        return getAns(0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define INF 1e12 // ans at most 2e9 * 100 = 2e11, so set INF to 1e12\\n#define ll long long\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    vi rbt;\\n    vector<vi> fctry;\\n    \\n    ll memo[101][101][101];\\n    ll getAns(int i, int j, int k) {\\n        if (i == rbt.size())\\n            return 0;\\n        if (j == fctry.size())\\n            return INF;\\n        \\n        if (memo[i][j][k])\\n            return memo[i][j][k];\\n        \\n        // option 1: fix robot i at factory j if it still has a capacity\\n        ll x = (k < fctry[j][1]) ? abs(rbt[i] - fctry[j][0]) + getAns(i + 1, j, k + 1) : INF;\\n        \\n        // option 2: skip factory j\\n        ll y = getAns(i, j + 1, 0);\\n       \\n        return memo[i][j][k] = min(x, y);\\n    }\\n    \\n    ll minimumTotalDistance(vi robot, vector<vi> factory) {\\n        rbt = robot, fctry = factory;\\n        sort(fctry.begin(), fctry.end());\\n        sort(rbt.begin(), rbt.end());   \\n        return getAns(0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823480,
                "title": "go-slow-and-steady-o-n3-memo",
                "content": "```\\n\\ntype FactoryList [][]int\\n\\nfunc (a FactoryList) Swap(i, j int) {\\n\\ta[i], a[j] = a[j], a[i]\\n}\\n\\nfunc (a FactoryList) Len() int {\\n\\treturn len(a)\\n}\\n\\nfunc (a FactoryList) Less(i, j int) bool {\\n\\treturn a[i][0] < a[j][0]\\n}\\n\\nfunc minimumTotalDistance(robot []int, factory [][]int) int64 {\\n\\tmem := make(map[[3]int]int64, 0)\\n\\n\\tsort.Ints(robot)\\n\\tsort.Sort(FactoryList(factory))\\n\\n\\treturn dp(robot, factory, mem)\\n}\\n\\nfunc dp(r []int, f [][]int, mem map[[3]int]int64) int64 {\\n\\tif v, ok := mem[[3]int{len(r), len(f), f[0][1]}]; ok {\\n\\t\\treturn v\\n\\t}\\n\\n\\tif len(r) == 0 {\\n\\t\\treturn 0\\n\\t} else if f[0][1] == 0 {\\n\\t\\tif len(f) > 1 {\\n\\t\\t\\treturn dp(r, f[1:], mem)\\n\\t\\t} else {\\n\\t\\t\\treturn math.MaxInt64\\n\\t\\t}\\n\\n\\t}\\n\\n\\tf[0][1]--\\n\\tcur := dp(r[1:], f, mem)\\n\\tif cur < math.MaxInt64 {\\n\\t\\tcur += dist(r[0], f[0][0])\\n\\t}\\n\\tf[0][1]++\\n\\n\\tif len(f) > 1 {\\n        cur = min64(cur, dp(r, f[1:], mem))\\n\\t}\\n\\n\\tmem[[3]int{len(r), len(f), f[0][1]}] = cur\\n\\treturn cur\\n}\\n\\nfunc dist(a, b int) int64 {\\n\\tif (a >= 0 && b >= 0) || (a < 0 && b < 0) {\\n\\t\\tif a >= b {\\n\\t\\t\\treturn int64(a - b)\\n\\t\\t}\\n\\t\\treturn int64(b - a)\\n\\t} else if a >= 0 && b < 0 {\\n\\t\\treturn int64(a - b)\\n\\t} else if b >= 0 && a < 0 {\\n\\t\\treturn int64(b - a)\\n\\t}\\n\\treturn int64(0)\\n}\\n\\nfunc min64(a, b int64) int64 {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\ntype FactoryList [][]int\\n\\nfunc (a FactoryList) Swap(i, j int) {\\n\\ta[i], a[j] = a[j], a[i]\\n}\\n\\nfunc (a FactoryList) Len() int {\\n\\treturn len(a)\\n}\\n\\nfunc (a FactoryList) Less(i, j int) bool {\\n\\treturn a[i][0] < a[j][0]\\n}\\n\\nfunc minimumTotalDistance(robot []int, factory [][]int) int64 {\\n\\tmem := make(map[[3]int]int64, 0)\\n\\n\\tsort.Ints(robot)\\n\\tsort.Sort(FactoryList(factory))\\n\\n\\treturn dp(robot, factory, mem)\\n}\\n\\nfunc dp(r []int, f [][]int, mem map[[3]int]int64) int64 {\\n\\tif v, ok := mem[[3]int{len(r), len(f), f[0][1]}]; ok {\\n\\t\\treturn v\\n\\t}\\n\\n\\tif len(r) == 0 {\\n\\t\\treturn 0\\n\\t} else if f[0][1] == 0 {\\n\\t\\tif len(f) > 1 {\\n\\t\\t\\treturn dp(r, f[1:], mem)\\n\\t\\t} else {\\n\\t\\t\\treturn math.MaxInt64\\n\\t\\t}\\n\\n\\t}\\n\\n\\tf[0][1]--\\n\\tcur := dp(r[1:], f, mem)\\n\\tif cur < math.MaxInt64 {\\n\\t\\tcur += dist(r[0], f[0][0])\\n\\t}\\n\\tf[0][1]++\\n\\n\\tif len(f) > 1 {\\n        cur = min64(cur, dp(r, f[1:], mem))\\n\\t}\\n\\n\\tmem[[3]int{len(r), len(f), f[0][1]}] = cur\\n\\treturn cur\\n}\\n\\nfunc dist(a, b int) int64 {\\n\\tif (a >= 0 && b >= 0) || (a < 0 && b < 0) {\\n\\t\\tif a >= b {\\n\\t\\t\\treturn int64(a - b)\\n\\t\\t}\\n\\t\\treturn int64(b - a)\\n\\t} else if a >= 0 && b < 0 {\\n\\t\\treturn int64(a - b)\\n\\t} else if b >= 0 && a < 0 {\\n\\t\\treturn int64(b - a)\\n\\t}\\n\\treturn int64(0)\\n}\\n\\nfunc min64(a, b int64) int64 {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2815285,
                "title": "js-dfs-with-memo",
                "content": "\\n## Solution\\n`dfs(i , j, k)`:  index of robot `i` arrives at factory `j`, with current already fixed `k` robots at `factory[j]`.\\n\\n## Code\\n```\\n/**\\n * @param {number[]} robot\\n * @param {number[][]} factory\\n * @return {number}\\n */\\nvar minimumTotalDistance = function(robot, factory) {\\n    const memo = new Map(); // <key, val>\\n    robot.sort((a,b)=>a-b);\\n    factory.sort((a,b)=>a[0] - b[0]);\\n    \\n    function dfs(i, j, k) {\\n        if(i=== robot.length) {\\n            return 0; // finished all assignment\\n        }\\n        if(j === factory.length) {\\n            return Infinity; // cannot repair all robots\\n        }\\n        if(memo.has(`${i}:${j}:${k}`)) {\\n            return memo.get(`${i}:${j}:${k}`);\\n        }\\n        const res1 = dfs(i, j+1, 0); // skip current factory\\n        const curCost = factory[j][1] <= k ? Infinity : Math.abs(robot[i] - factory[j][0]);\\n        const res2 = dfs(i+1, j, k+1) + curCost;\\n        const res = Math.min(res1, res2);\\n        memo.set(`${i}:${j}:${k}`, res); \\n        return res;\\n    }\\n    return dfs(0, 0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} robot\\n * @param {number[][]} factory\\n * @return {number}\\n */\\nvar minimumTotalDistance = function(robot, factory) {\\n    const memo = new Map(); // <key, val>\\n    robot.sort((a,b)=>a-b);\\n    factory.sort((a,b)=>a[0] - b[0]);\\n    \\n    function dfs(i, j, k) {\\n        if(i=== robot.length) {\\n            return 0; // finished all assignment\\n        }\\n        if(j === factory.length) {\\n            return Infinity; // cannot repair all robots\\n        }\\n        if(memo.has(`${i}:${j}:${k}`)) {\\n            return memo.get(`${i}:${j}:${k}`);\\n        }\\n        const res1 = dfs(i, j+1, 0); // skip current factory\\n        const curCost = factory[j][1] <= k ? Infinity : Math.abs(robot[i] - factory[j][0]);\\n        const res2 = dfs(i+1, j, k+1) + curCost;\\n        const res = Math.min(res1, res2);\\n        memo.set(`${i}:${j}:${k}`, res); \\n        return res;\\n    }\\n    return dfs(0, 0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2804953,
                "title": "python-top-down-dp-clean-code",
                "content": "dfs(i,j,rem): minimum cost to allocate robot[i:] to factory[j:] when factory[j]\\'s remaining capacity is rem\\n```\\nfrom functools import cache\\n\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        @cache\\n        def dfs(i, j, rem):\\n            if i == len(robot): return 0\\n            if not rem: return dfs(i, j+1, factory[j+1][1] ) if j+1 < len(factory) else float(\\'inf\\')\\n            res = abs(robot[i]-factory[j][0]) + dfs(i+1,j,rem-1)\\n            res = min(res, dfs(i,j+1,factory[j+1][1])) if j+1 < len(factory) else res\\n            return res\\n        return dfs(0,0,factory[0][1])",
                "solutionTags": [
                    "Python"
                ],
                "code": "dfs(i,j,rem): minimum cost to allocate robot[i:] to factory[j:] when factory[j]\\'s remaining capacity is rem\\n```\\nfrom functools import cache\\n\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        @cache\\n        def dfs(i, j, rem):\\n            if i == len(robot): return 0\\n            if not rem: return dfs(i, j+1, factory[j+1][1] ) if j+1 < len(factory) else float(\\'inf\\')\\n            res = abs(robot[i]-factory[j][0]) + dfs(i+1,j,rem-1)\\n            res = min(res, dfs(i,j+1,factory[j+1][1])) if j+1 < len(factory) else res\\n            return res\\n        return dfs(0,0,factory[0][1])",
                "codeTag": "Java"
            },
            {
                "id": 2803870,
                "title": "c-solution",
                "content": "```\\nstruct Robot{\\n    bool To_L;\\n    int Right;\\n    int Left;\\n};\\n\\nstruct Factory{\\n    int* RobNo;\\n    int Point;\\n    int Count;\\n};\\n\\nint comp (const void* a, const void* b){\\n    return *(int*)a > *(int*)b ? 1 : -1;\\n}\\n\\nint comp_f (const void** a, const void** b){\\n    return (*(int**)a)[0] > (*(int**)b)[0] ? 1 : -1;\\n}\\n\\nvoid cost(int* robot, int** factory, struct Robot* list, struct Factory* F_list, int now, int left_factory, bool* to_left, int* l, int r){\\n    if (left_factory == -1){\\n        list[now].Left = -1;\\n        return;\\n    }\\n    *l += robot[now]-factory[left_factory][0]; //\\u52A0\\u4E0A\\u9019\\u6BB5\\u5DEE\\u8DDD\\n    if (factory[left_factory][1] <= F_list[left_factory].Count){\\n        int replace_rob = F_list[left_factory].RobNo[F_list[left_factory].Point]; //\\u88AB\\u8E22\\u51FA\\u4F86\\u7684\\u6A5F\\u5668\\u4EBA \\u67E5\\u770B\\u662F\\u5426\\u80FD\\u6539\\u6210\\u5411\\u5DE6\\u8D70\\n        if (list[replace_rob].To_L){\\n            *l -= robot[replace_rob]-factory[left_factory][0];\\n        } else {\\n            *l -= factory[left_factory][0]-robot[replace_rob];\\n        }\\n        cost(robot, factory, list, F_list, replace_rob, list[replace_rob].Left, to_left, l, r);\\n        if (*to_left){\\n            F_list[left_factory].Point++;\\n        }\\n    } else {\\n        if (*l <= r){\\n            *to_left = true;\\n        }\\n    }\\n    if (*to_left){ //\\u5982\\u679C\\u771F\\u7684\\u8981\\u5F80\\u5DE6\\u908A\\u8D70 \\u90A3\\u56E0\\u70BA\\u88AB\\u66FF\\u63DB\\u6389 Point \\u8981++ \\u7136\\u5F8C\\u9700\\u8981Input now \\u9032\\u53BB\\n        list[now].To_L = true;\\n        list[now].Left = left_factory-1;\\n        F_list[left_factory].RobNo[F_list[left_factory].Count] = now;\\n        F_list[left_factory].Count++;\\n    }\\n    return;\\n}\\n\\nint cost_r(int** factory, int factorySize, struct Factory* F_list, int right_factory){\\n    int r = 0;\\n    if (right_factory == factorySize){\\n        return INT_MAX;\\n    }\\n    while (factory[right_factory][1] <= F_list[right_factory].Count){ //\\u5982\\u679C\\u53F3\\u908A\\u7684\\u5DE5\\u5EE0\\u6EFF\\u4E86\\n        r += factory[right_factory][0]-factory[right_factory-1][0]; //\\u52A0\\u4E0A\\u9019\\u6BB5\\u5DEE\\u8DDD\\n        right_factory++;\\n        if (right_factory == factorySize){\\n            return INT_MAX;\\n        }\\n    }\\n    r += factory[right_factory][0]-factory[right_factory-1][0]; //\\u52A0\\u4E0A\\u9019\\u6BB5\\u5DEE\\u8DDD\\n    return r;\\n}\\n\\nvoid to_r_change(int** factory, struct Robot* list, struct Factory* F_list, int now, int right_factory){\\n    if (factory[right_factory][1] <= F_list[right_factory].Count){ //\\u5982\\u679C\\u53F3\\u908A\\u7684\\u5DE5\\u5EE0\\u6EFF\\u4E86\\n        int replace_rob = F_list[right_factory].RobNo[F_list[right_factory].Point]; //\\u88AB\\u8E22\\u51FA\\u4F86\\u7684\\u6A5F\\u5668\\u4EBA\\n        to_r_change(factory, list, F_list, replace_rob, list[replace_rob].Left);\\n        F_list[right_factory].Point++;\\n    }\\n    list[now].Right = right_factory+1;\\n    F_list[right_factory].RobNo[F_list[right_factory].Count] = now;\\n    F_list[right_factory].Count++;\\n    return;\\n}\\n\\nlong long minimumTotalDistance(int* robot, int robotSize, int** factory, int factorySize, int* factoryColSize){\\n    qsort(robot, robotSize, sizeof(int), comp);\\n    qsort(factory, factorySize, sizeof(int*), comp_f);\\n    struct Robot* list = malloc(sizeof(struct Robot)*robotSize);\\n    struct Factory* F_list = calloc(factorySize, sizeof(struct Factory));\\n    int point = 0;\\n    for (int i = 0 ; i < robotSize ; i++){\\n        while(point < factorySize && factory[point][0] < robot[i]){\\n            point++;\\n        }\\n        list[i].Right = point;\\n        list[i].Left = point-1;\\n    }\\n    for (int i = 0 ; i < factorySize ; i++){\\n        F_list[i].RobNo = malloc(sizeof(int)*robotSize);\\n    }\\n    \\n    int head = 0;\\n    long long ans = 0;\\n    \\n    while(head < robotSize && list[head].Left == -1){\\n        while (factory[list[head].Right][1] == F_list[list[head].Right].Count){\\n            list[head].Right++;\\n        }\\n        ans += factory[list[head].Right][0] - robot[head];\\n        list[head].To_L = false;\\n        F_list[list[head].Right].RobNo[F_list[list[head].Right].Count] = head;\\n        F_list[list[head].Right].Count++;\\n        head++;\\n    }\\n    \\n    while (head < robotSize){\\n        int l = list[head].Left == -1 ? INT_MAX : robot[head] - factory[list[head].Left][0];\\n        int r = list[head].Right == factorySize ? INT_MAX : factory[list[head].Right][0] - robot[head];\\n        int right_factory = list[head].Right; //\\u5148\\u8003\\u616E\\u524D\\u5F80\\u53F3\\u908A\\u7684\\u5DE5\\u5EE0\\u7684\\u6210\\u672C\\n        bool to_left = false;\\n        if (right_factory < factorySize){\\n            while (factory[right_factory][1] == 0){\\n                right_factory++;\\n                if (right_factory == factorySize){\\n                    r = INT_MAX;\\n                    break;\\n                } else {\\n                    r = factory[right_factory][0] - robot[head];\\n                }\\n            }\\n            \\n            if (right_factory < factorySize && factory[right_factory][1] <= F_list[right_factory].Count){\\n                //\\u5982\\u679C\\u53F3\\u908A\\u7684\\u5DE5\\u5EE0\\u6EFF\\u4E86 \\u4E00\\u5B9A\\u662F\\u5411\\u53F3\\u64E0\\u51FA\\u4E00\\u500B\\n                list[head].To_L = false;\\n                ans += r;\\n                F_list[right_factory].RobNo[F_list[right_factory].Count] = head;\\n                F_list[right_factory].Count++;\\n                int replace_rob = F_list[right_factory].RobNo[F_list[right_factory].Point]; //\\u88AB\\u79FB\\u51FA\\u7684\\u6A5F\\u5668\\u4EBA\\n                F_list[right_factory].Point++;\\n                if (list[replace_rob].Left == -1){ \\n                    //\\u79FB\\u51FA\\u7684\\u6A5F\\u5668\\u4EBA\\u7684\\u5DE6\\u908A\\u662F-1 \\u4EE3\\u8868\\u5DE6\\u908A\\u5DF2\\u7D93\\u6C92\\u6709\\u4EFB\\u4F55\\u7A7A\\u7684\\u5DE5\\u5EE0\\u4E86 \\u7121\\u6CD5\\u79FB\\u51FA\\n                    list[head].Left = -1;\\n                    right_factory++; //\\u67E5\\u770B\\u4E0B\\u4E00\\u9593\\u5DE5\\u5EE0\\n                    ans += factory[right_factory][0] - factory[right_factory-1][0];\\n                    while (factory[right_factory][1] <= F_list[right_factory].Count){ //\\u5982\\u679C\\u9084\\u662F\\u6EFF\\u7684\\n                        F_list[right_factory].RobNo[F_list[right_factory].Count] = replace_rob;\\n                        replace_rob = F_list[right_factory].RobNo[F_list[right_factory].Point];\\n                        F_list[right_factory].Count++;\\n                        F_list[right_factory].Point++;\\n                        right_factory++; //\\u67E5\\u770B\\u4E0B\\u4E00\\u9593\\u5DE5\\u5EE0\\n                        ans += factory[right_factory][0] - factory[right_factory-1][0];\\n                    }\\n                    F_list[right_factory].RobNo[F_list[right_factory].Count] = replace_rob;\\n                    F_list[right_factory].Count++;\\n                    F_list[right_factory].Point++;\\n                } else { //\\u53F3\\u908A\\u7684\\u6700\\u4E0B\\u9762\\u7684\\u6A5F\\u5668\\u4EBA\\u53EF\\u4EE5\\u5F80\\u5DE6 \\u90A3\\u8981\\u627E\\u51FA\\u6210\\u672C\\n                    r = cost_r(factory, factorySize, F_list, right_factory+1);\\n                    l = robot[replace_rob]-factory[right_factory][0];\\n                    cost(robot, factory, list, F_list, replace_rob, list[replace_rob].Left, &to_left, &l, r);\\n                    \\n                    //right_factory+1 = replace_rob \\u6240\\u8655\\u7684\\u5DE5\\u5EE0 \\u53F3\\u908A\\u7684\\u5DE5\\u5EE0\\n                    if (to_left){\\n                        ans += l;\\n                    } else {\\n                        ans += r;\\n                        to_r_change(factory, list, F_list, replace_rob, list[replace_rob].Right);\\n                    }\\n                }\\n                head++;\\n                continue;\\n            }\\n        }\\n        //\\u6AA2\\u67E5\\u5DE6\\u908A\\u5DE5\\u5EE0\\u6EFF\\u4E86\\u6C92 \\u5DE6\\u908A\\u4E0D\\u53EF\\u80FD\\u70BA-1\\n        int left_factory = list[head].Left;\\n        \\n        while (factory[left_factory][1] == 0){\\n            left_factory--;\\n            if (left_factory >= 0){ \\n                l = robot[head] - factory[left_factory][0];\\n                list[head].Left = left_factory;\\n            } else {\\n                l = INT_MAX;\\n                list[head].Left = left_factory;\\n                break;\\n            }\\n        }\\n        \\n        if (left_factory >= 0 && factory[left_factory][1] <= F_list[left_factory].Count){  //\\u5982\\u679C\\u6EFF\\u4E86\\n            int replace_rob = F_list[left_factory].RobNo[F_list[left_factory].Point]; //\\u88AB\\u8E22\\u51FA\\u4F86\\u7684\\u6A5F\\u5668\\u4EBA\\n            //\\u4E00\\u500B\\u51FD\\u5F0F \\u6703\\u8A08\\u7B97\\u5DE6\\u53F3\\u54EA\\u908A\\u5212\\u7B97\\n            if (list[replace_rob].To_L){\\n                l -= robot[replace_rob]-factory[left_factory][0];\\n            } else {\\n                l -= factory[left_factory][0]-robot[replace_rob];\\n            }\\n            cost(robot, factory, list, F_list, replace_rob, list[replace_rob].Left, &to_left, &l, r);\\n            if (to_left){\\n                F_list[left_factory].Point++;\\n            }\\n        } else {  //\\u5982\\u679C\\u6C92\\u6EFF \\u90A3\\u5C31\\u662F\\u6BD4\\u8F03\\u5DE6\\u53F3 \\u54EA\\u908A\\u5C0F\\u585E\\u54EA\\u908A\\n            if (l <= r){\\n                to_left = true;\\n            }\\n        }\\n        if (to_left){ //\\u5982\\u679C\\u5DE6\\u908A\\u5C0F\\n            ans += l;\\n            list[head].To_L = true;\\n            list[head].Left = left_factory-1;\\n            F_list[left_factory].RobNo[F_list[left_factory].Count] = head;\\n            F_list[left_factory].Count++;\\n        } else {    //\\u5982\\u679C\\u53F3\\u908A\\u7684\\u5C0F\\n            ans += r;\\n            list[head].To_L = false;\\n            F_list[right_factory].RobNo[F_list[right_factory].Count] = head;\\n            F_list[right_factory].Count++;\\n        }\\n        head++;\\n    }\\n\\tfor (int i = 0 ; i < factorySize ; i++){\\n        free(F_list[i].RobNo);\\n    }\\n    free(F_list);\\n    free(list);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Robot{\\n    bool To_L;\\n    int Right;\\n    int Left;\\n};\\n\\nstruct Factory{\\n    int* RobNo;\\n    int Point;\\n    int Count;\\n};\\n\\nint comp (const void* a, const void* b){\\n    return *(int*)a > *(int*)b ? 1 : -1;\\n}\\n\\nint comp_f (const void** a, const void** b){\\n    return (*(int**)a)[0] > (*(int**)b)[0] ? 1 : -1;\\n}\\n\\nvoid cost(int* robot, int** factory, struct Robot* list, struct Factory* F_list, int now, int left_factory, bool* to_left, int* l, int r){\\n    if (left_factory == -1){\\n        list[now].Left = -1;\\n        return;\\n    }\\n    *l += robot[now]-factory[left_factory][0]; //\\u52A0\\u4E0A\\u9019\\u6BB5\\u5DEE\\u8DDD\\n    if (factory[left_factory][1] <= F_list[left_factory].Count){\\n        int replace_rob = F_list[left_factory].RobNo[F_list[left_factory].Point]; //\\u88AB\\u8E22\\u51FA\\u4F86\\u7684\\u6A5F\\u5668\\u4EBA \\u67E5\\u770B\\u662F\\u5426\\u80FD\\u6539\\u6210\\u5411\\u5DE6\\u8D70\\n        if (list[replace_rob].To_L){\\n            *l -= robot[replace_rob]-factory[left_factory][0];\\n        } else {\\n            *l -= factory[left_factory][0]-robot[replace_rob];\\n        }\\n        cost(robot, factory, list, F_list, replace_rob, list[replace_rob].Left, to_left, l, r);\\n        if (*to_left){\\n            F_list[left_factory].Point++;\\n        }\\n    } else {\\n        if (*l <= r){\\n            *to_left = true;\\n        }\\n    }\\n    if (*to_left){ //\\u5982\\u679C\\u771F\\u7684\\u8981\\u5F80\\u5DE6\\u908A\\u8D70 \\u90A3\\u56E0\\u70BA\\u88AB\\u66FF\\u63DB\\u6389 Point \\u8981++ \\u7136\\u5F8C\\u9700\\u8981Input now \\u9032\\u53BB\\n        list[now].To_L = true;\\n        list[now].Left = left_factory-1;\\n        F_list[left_factory].RobNo[F_list[left_factory].Count] = now;\\n        F_list[left_factory].Count++;\\n    }\\n    return;\\n}\\n\\nint cost_r(int** factory, int factorySize, struct Factory* F_list, int right_factory){\\n    int r = 0;\\n    if (right_factory == factorySize){\\n        return INT_MAX;\\n    }\\n    while (factory[right_factory][1] <= F_list[right_factory].Count){ //\\u5982\\u679C\\u53F3\\u908A\\u7684\\u5DE5\\u5EE0\\u6EFF\\u4E86\\n        r += factory[right_factory][0]-factory[right_factory-1][0]; //\\u52A0\\u4E0A\\u9019\\u6BB5\\u5DEE\\u8DDD\\n        right_factory++;\\n        if (right_factory == factorySize){\\n            return INT_MAX;\\n        }\\n    }\\n    r += factory[right_factory][0]-factory[right_factory-1][0]; //\\u52A0\\u4E0A\\u9019\\u6BB5\\u5DEE\\u8DDD\\n    return r;\\n}\\n\\nvoid to_r_change(int** factory, struct Robot* list, struct Factory* F_list, int now, int right_factory){\\n    if (factory[right_factory][1] <= F_list[right_factory].Count){ //\\u5982\\u679C\\u53F3\\u908A\\u7684\\u5DE5\\u5EE0\\u6EFF\\u4E86\\n        int replace_rob = F_list[right_factory].RobNo[F_list[right_factory].Point]; //\\u88AB\\u8E22\\u51FA\\u4F86\\u7684\\u6A5F\\u5668\\u4EBA\\n        to_r_change(factory, list, F_list, replace_rob, list[replace_rob].Left);\\n        F_list[right_factory].Point++;\\n    }\\n    list[now].Right = right_factory+1;\\n    F_list[right_factory].RobNo[F_list[right_factory].Count] = now;\\n    F_list[right_factory].Count++;\\n    return;\\n}\\n\\nlong long minimumTotalDistance(int* robot, int robotSize, int** factory, int factorySize, int* factoryColSize){\\n    qsort(robot, robotSize, sizeof(int), comp);\\n    qsort(factory, factorySize, sizeof(int*), comp_f);\\n    struct Robot* list = malloc(sizeof(struct Robot)*robotSize);\\n    struct Factory* F_list = calloc(factorySize, sizeof(struct Factory));\\n    int point = 0;\\n    for (int i = 0 ; i < robotSize ; i++){\\n        while(point < factorySize && factory[point][0] < robot[i]){\\n            point++;\\n        }\\n        list[i].Right = point;\\n        list[i].Left = point-1;\\n    }\\n    for (int i = 0 ; i < factorySize ; i++){\\n        F_list[i].RobNo = malloc(sizeof(int)*robotSize);\\n    }\\n    \\n    int head = 0;\\n    long long ans = 0;\\n    \\n    while(head < robotSize && list[head].Left == -1){\\n        while (factory[list[head].Right][1] == F_list[list[head].Right].Count){\\n            list[head].Right++;\\n        }\\n        ans += factory[list[head].Right][0] - robot[head];\\n        list[head].To_L = false;\\n        F_list[list[head].Right].RobNo[F_list[list[head].Right].Count] = head;\\n        F_list[list[head].Right].Count++;\\n        head++;\\n    }\\n    \\n    while (head < robotSize){\\n        int l = list[head].Left == -1 ? INT_MAX : robot[head] - factory[list[head].Left][0];\\n        int r = list[head].Right == factorySize ? INT_MAX : factory[list[head].Right][0] - robot[head];\\n        int right_factory = list[head].Right; //\\u5148\\u8003\\u616E\\u524D\\u5F80\\u53F3\\u908A\\u7684\\u5DE5\\u5EE0\\u7684\\u6210\\u672C\\n        bool to_left = false;\\n        if (right_factory < factorySize){\\n            while (factory[right_factory][1] == 0){\\n                right_factory++;\\n                if (right_factory == factorySize){\\n                    r = INT_MAX;\\n                    break;\\n                } else {\\n                    r = factory[right_factory][0] - robot[head];\\n                }\\n            }\\n            \\n            if (right_factory < factorySize && factory[right_factory][1] <= F_list[right_factory].Count){\\n                //\\u5982\\u679C\\u53F3\\u908A\\u7684\\u5DE5\\u5EE0\\u6EFF\\u4E86 \\u4E00\\u5B9A\\u662F\\u5411\\u53F3\\u64E0\\u51FA\\u4E00\\u500B\\n                list[head].To_L = false;\\n                ans += r;\\n                F_list[right_factory].RobNo[F_list[right_factory].Count] = head;\\n                F_list[right_factory].Count++;\\n                int replace_rob = F_list[right_factory].RobNo[F_list[right_factory].Point]; //\\u88AB\\u79FB\\u51FA\\u7684\\u6A5F\\u5668\\u4EBA\\n                F_list[right_factory].Point++;\\n                if (list[replace_rob].Left == -1){ \\n                    //\\u79FB\\u51FA\\u7684\\u6A5F\\u5668\\u4EBA\\u7684\\u5DE6\\u908A\\u662F-1 \\u4EE3\\u8868\\u5DE6\\u908A\\u5DF2\\u7D93\\u6C92\\u6709\\u4EFB\\u4F55\\u7A7A\\u7684\\u5DE5\\u5EE0\\u4E86 \\u7121\\u6CD5\\u79FB\\u51FA\\n                    list[head].Left = -1;\\n                    right_factory++; //\\u67E5\\u770B\\u4E0B\\u4E00\\u9593\\u5DE5\\u5EE0\\n                    ans += factory[right_factory][0] - factory[right_factory-1][0];\\n                    while (factory[right_factory][1] <= F_list[right_factory].Count){ //\\u5982\\u679C\\u9084\\u662F\\u6EFF\\u7684\\n                        F_list[right_factory].RobNo[F_list[right_factory].Count] = replace_rob;\\n                        replace_rob = F_list[right_factory].RobNo[F_list[right_factory].Point];\\n                        F_list[right_factory].Count++;\\n                        F_list[right_factory].Point++;\\n                        right_factory++; //\\u67E5\\u770B\\u4E0B\\u4E00\\u9593\\u5DE5\\u5EE0\\n                        ans += factory[right_factory][0] - factory[right_factory-1][0];\\n                    }\\n                    F_list[right_factory].RobNo[F_list[right_factory].Count] = replace_rob;\\n                    F_list[right_factory].Count++;\\n                    F_list[right_factory].Point++;\\n                } else { //\\u53F3\\u908A\\u7684\\u6700\\u4E0B\\u9762\\u7684\\u6A5F\\u5668\\u4EBA\\u53EF\\u4EE5\\u5F80\\u5DE6 \\u90A3\\u8981\\u627E\\u51FA\\u6210\\u672C\\n                    r = cost_r(factory, factorySize, F_list, right_factory+1);\\n                    l = robot[replace_rob]-factory[right_factory][0];\\n                    cost(robot, factory, list, F_list, replace_rob, list[replace_rob].Left, &to_left, &l, r);\\n                    \\n                    //right_factory+1 = replace_rob \\u6240\\u8655\\u7684\\u5DE5\\u5EE0 \\u53F3\\u908A\\u7684\\u5DE5\\u5EE0\\n                    if (to_left){\\n                        ans += l;\\n                    } else {\\n                        ans += r;\\n                        to_r_change(factory, list, F_list, replace_rob, list[replace_rob].Right);\\n                    }\\n                }\\n                head++;\\n                continue;\\n            }\\n        }\\n        //\\u6AA2\\u67E5\\u5DE6\\u908A\\u5DE5\\u5EE0\\u6EFF\\u4E86\\u6C92 \\u5DE6\\u908A\\u4E0D\\u53EF\\u80FD\\u70BA-1\\n        int left_factory = list[head].Left;\\n        \\n        while (factory[left_factory][1] == 0){\\n            left_factory--;\\n            if (left_factory >= 0){ \\n                l = robot[head] - factory[left_factory][0];\\n                list[head].Left = left_factory;\\n            } else {\\n                l = INT_MAX;\\n                list[head].Left = left_factory;\\n                break;\\n            }\\n        }\\n        \\n        if (left_factory >= 0 && factory[left_factory][1] <= F_list[left_factory].Count){  //\\u5982\\u679C\\u6EFF\\u4E86\\n            int replace_rob = F_list[left_factory].RobNo[F_list[left_factory].Point]; //\\u88AB\\u8E22\\u51FA\\u4F86\\u7684\\u6A5F\\u5668\\u4EBA\\n            //\\u4E00\\u500B\\u51FD\\u5F0F \\u6703\\u8A08\\u7B97\\u5DE6\\u53F3\\u54EA\\u908A\\u5212\\u7B97\\n            if (list[replace_rob].To_L){\\n                l -= robot[replace_rob]-factory[left_factory][0];\\n            } else {\\n                l -= factory[left_factory][0]-robot[replace_rob];\\n            }\\n            cost(robot, factory, list, F_list, replace_rob, list[replace_rob].Left, &to_left, &l, r);\\n            if (to_left){\\n                F_list[left_factory].Point++;\\n            }\\n        } else {  //\\u5982\\u679C\\u6C92\\u6EFF \\u90A3\\u5C31\\u662F\\u6BD4\\u8F03\\u5DE6\\u53F3 \\u54EA\\u908A\\u5C0F\\u585E\\u54EA\\u908A\\n            if (l <= r){\\n                to_left = true;\\n            }\\n        }\\n        if (to_left){ //\\u5982\\u679C\\u5DE6\\u908A\\u5C0F\\n            ans += l;\\n            list[head].To_L = true;\\n            list[head].Left = left_factory-1;\\n            F_list[left_factory].RobNo[F_list[left_factory].Count] = head;\\n            F_list[left_factory].Count++;\\n        } else {    //\\u5982\\u679C\\u53F3\\u908A\\u7684\\u5C0F\\n            ans += r;\\n            list[head].To_L = false;\\n            F_list[right_factory].RobNo[F_list[right_factory].Count] = head;\\n            F_list[right_factory].Count++;\\n        }\\n        head++;\\n    }\\n\\tfor (int i = 0 ; i < factorySize ; i++){\\n        free(F_list[i].RobNo);\\n    }\\n    free(F_list);\\n    free(list);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797666,
                "title": "c-using-dp-hardest-approach-easiest-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& rob, vector<vector<int>>& fac) {\\n        sort(rob.begin(), rob.end());\\n        sort(fac.begin(), fac.end());\\n        int n= rob.size();\\n        int m= fac.size();\\n        \\n        vector<long long> dp(n+1, 1000000000000000);\\n        dp[0] = 0;\\n        \\n        for(int j=0; j<m; j++){\\n            for(int k=0; k<fac[j][1]; k++){\\n                for(int i=n-1; i>=0; i--){\\n                    dp[i+1] = min(dp[i+1], dp[i] + abs(fac[j][0]-rob[i]) );\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& rob, vector<vector<int>>& fac) {\\n        sort(rob.begin(), rob.end());\\n        sort(fac.begin(), fac.end());\\n        int n= rob.size();\\n        int m= fac.size();\\n        \\n        vector<long long> dp(n+1, 1000000000000000);\\n        dp[0] = 0;\\n        \\n        for(int j=0; j<m; j++){\\n            for(int k=0; k<fac[j][1]; k++){\\n                for(int i=n-1; i>=0; i--){\\n                    dp[i+1] = min(dp[i+1], dp[i] + abs(fac[j][0]-rob[i]) );\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797660,
                "title": "ugliest-solution-ever",
                "content": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        \\n        facts = {}\\n        \\n        for i in factory:\\n            \\n            if i[1] <= 0:\\n                continue\\n            if i[0] in facts:\\n                facts[i[0]]+=i[1]\\n            else:\\n                facts[i[0]] = i[1]\\n                \\n        def repetition(r, fact):\\n                \\n            basis = sorted(fact.keys())\\n            \\n            \\n            \\n            \\n\\n            ans = 0\\n\\n\\n\\n            for i in r:\\n\\n                mini = 1000000000000000000000\\n                indi = 0\\n\\n                for ind, j in enumerate(basis):\\n                    if abs(j-i) < mini:\\n                        mini = abs(j-i)\\n                        indi = j\\n                ans += mini\\n                \\n                \\n                facts[indi] -= 1\\n                if facts[indi] <= 0:\\n                    basis.remove(indi)\\n                    \\n                \\n            return ans\\n        \\n        anz = 1000000000000000000000\\n        for i in range(250):\\n            random.shuffle(robot)\\n            \\n            \\n            base = {}\\n            \\n            for i in facts.keys():\\n                base[i] = facts[i]\\n            \\n            \\n            anz = min(anz, repetition(robot, facts))\\n            \\n            facts = base\\n        \\n        return anz",
                "solutionTags": [],
                "code": "class Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        \\n        facts = {}",
                "codeTag": "Java"
            },
            {
                "id": 2797159,
                "title": "dynamic-programming-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\nlong long solve(vector<int> &a,vector<long long> &f,long long i,long long j,vector<vector<long long>> &dp){\\n    if(i==a.size()) return 0;\\n    if(j==f.size()) return 1e13;\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    long long take=1e13;\\n    take=min(take,solve(a,f,i+1,j+1,dp)+abs(a[i]-f[j]));\\n    take=min(take,solve(a,f,i,j+1,dp));\\n    // cout<<take<<\" \";\\n    return dp[i][j]=take;\\n};\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        vector<long long> f;\\n        for(long long i=0;i<factory.size();i++){\\n            for(long long j=0;j<factory[i][1];j++){\\n                f.push_back(factory[i][0]);\\n            }\\n        }\\n        sort(f.begin(),f.end());\\n        sort(robot.begin(),robot.end());\\n        vector<vector<long long>> dp(robot.size(),vector<long long>(f.size(),-1));\\n        return solve(robot,f,0,0,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nlong long solve(vector<int> &a,vector<long long> &f,long long i,long long j,vector<vector<long long>> &dp){\\n    if(i==a.size()) return 0;\\n    if(j==f.size()) return 1e13;\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    long long take=1e13;\\n    take=min(take,solve(a,f,i+1,j+1,dp)+abs(a[i]-f[j]));\\n    take=min(take,solve(a,f,i,j+1,dp));\\n    // cout<<take<<\" \";\\n    return dp[i][j]=take;\\n};\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        vector<long long> f;\\n        for(long long i=0;i<factory.size();i++){\\n            for(long long j=0;j<factory[i][1];j++){\\n                f.push_back(factory[i][0]);\\n            }\\n        }\\n        sort(f.begin(),f.end());\\n        sort(robot.begin(),robot.end());\\n        vector<vector<long long>> dp(robot.size(),vector<long long>(f.size(),-1));\\n        return solve(robot,f,0,0,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2795442,
                "title": "dp-solution-explained-clearly",
                "content": "```\\nclass Solution {\\npublic:\\n    long long f(int currBot, int currShop, vector<long long>& shops, vector<int>& robot, vector<vector<long long>>& dp){\\n        // base cases\\n        if(currBot == robot.size())\\n            return 0 ; // since we have repaired all bots \\n        if(currShop == shops.size())\\n            return 1e16 ; // since no facts are available its not a valid solution\\n        if(dp[currBot][currShop] ^ -1)\\n            return dp[currBot][currShop] ;\\n        \\n        // we have two choices\\n        // either repair the currBot in the currShop  OR \\n        // do not repair the currBot in the currShop\\n        long long take, notTake ;\\n        take = abs(robot[currBot] - shops[currShop]) + f(currBot+1, currShop+1, shops, robot, dp) ;\\n        notTake = f(currBot, currShop+1, shops, robot, dp) ;\\n        return dp[currBot][currShop] = min(take, notTake) ;\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end()) ;\\n        sort(factory.begin(), factory.end()) ;\\n        \\n        // lets spread the factory i.e a factory at pos 1 with limit 2 is \\n        // same as two factories at pos 1 with limit 1 \\n        vector<long long> shops ;\\n        for(auto it: factory){\\n            long long pos = it[0] , limit = it[1] ;\\n            while(limit--) shops.push_back(pos) ;\\n        }\\n        \\n        // create a dp array -> dp[currBot][currShop]\\n        vector<vector<long long>> dp(robot.size(), vector<long long>(shops.size(), -1)) ;\\n        \\n        return f(0, 0, shops, robot, dp) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(int currBot, int currShop, vector<long long>& shops, vector<int>& robot, vector<vector<long long>>& dp){\\n        // base cases\\n        if(currBot == robot.size())\\n            return 0 ; // since we have repaired all bots \\n        if(currShop == shops.size())\\n            return 1e16 ; // since no facts are available its not a valid solution\\n        if(dp[currBot][currShop] ^ -1)\\n            return dp[currBot][currShop] ;\\n        \\n        // we have two choices\\n        // either repair the currBot in the currShop  OR \\n        // do not repair the currBot in the currShop\\n        long long take, notTake ;\\n        take = abs(robot[currBot] - shops[currShop]) + f(currBot+1, currShop+1, shops, robot, dp) ;\\n        notTake = f(currBot, currShop+1, shops, robot, dp) ;\\n        return dp[currBot][currShop] = min(take, notTake) ;\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end()) ;\\n        sort(factory.begin(), factory.end()) ;\\n        \\n        // lets spread the factory i.e a factory at pos 1 with limit 2 is \\n        // same as two factories at pos 1 with limit 1 \\n        vector<long long> shops ;\\n        for(auto it: factory){\\n            long long pos = it[0] , limit = it[1] ;\\n            while(limit--) shops.push_back(pos) ;\\n        }\\n        \\n        // create a dp array -> dp[currBot][currShop]\\n        vector<vector<long long>> dp(robot.size(), vector<long long>(shops.size(), -1)) ;\\n        \\n        return f(0, 0, shops, robot, dp) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794188,
                "title": "java-one-the-easiest-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long solve(int x, int y, int n, int m ,List<Integer> robots, List<Integer> factory, Long[][] dp){\\n        if(x==n) return 0;\\n        if(y==m) return (long)1e13;\\n        if(dp[x][y] != null) return dp[x][y];\\n        long ans = (long)1e13;\\n        ans = Math.min(ans, solve(x+1, y+1, n, m, robots, factory, dp)+Math.abs(robots.get(x)-factory.get(y)));\\n        ans = Math.min(ans, solve(x, y+1, n,m, robots, factory, dp));\\n        return dp[x][y] = ans;\\n    }\\n\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        List<Integer> factories = new ArrayList<>();\\n        for(int[] row : factory){\\n            for (int i = 0; i < row[1]; i++) {\\n                factories.add(row[0]);\\n            }\\n        }\\n\\n        int n = robot.size();\\n        int m = factories.size();\\n        Collections.sort(robot);\\n        Collections.sort(factories);\\n        Long[][] dp = new Long[n][m];\\n        return solve(0,0, n, m, robot, factories, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private long solve(int x, int y, int n, int m ,List<Integer> robots, List<Integer> factory, Long[][] dp){\\n        if(x==n) return 0;\\n        if(y==m) return (long)1e13;\\n        if(dp[x][y] != null) return dp[x][y];\\n        long ans = (long)1e13;\\n        ans = Math.min(ans, solve(x+1, y+1, n, m, robots, factory, dp)+Math.abs(robots.get(x)-factory.get(y)));\\n        ans = Math.min(ans, solve(x, y+1, n,m, robots, factory, dp));\\n        return dp[x][y] = ans;\\n    }\\n\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        List<Integer> factories = new ArrayList<>();\\n        for(int[] row : factory){\\n            for (int i = 0; i < row[1]; i++) {\\n                factories.add(row[0]);\\n            }\\n        }\\n\\n        int n = robot.size();\\n        int m = factories.size();\\n        Collections.sort(robot);\\n        Collections.sort(factories);\\n        Long[][] dp = new Long[n][m];\\n        return solve(0,0, n, m, robot, factories, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793428,
                "title": "simple-c-dp-solution-with-intuition-and-approach",
                "content": "1. First sort the robot array;\\n2. and make a new factories array with all positions of factories and for multiple possible repairings \\nInsert the same position multiple times.\\n2. start fom the start (least value ) of both the array.\\n3. And use take not take DP \\n4. Minimize the values found from take not take.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> ans;\\n    long long solve(vector<int>& robot, vector<int> &fact, int i,int j){\\n        int n=robot.size();\\n        int len=fact.size();\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(i<n and j>=len){\\n            return LLONG_MAX;\\n        }\\n        if(ans[i][j]!=-1){\\n            return ans[i][j];\\n        }\\n        \\n//         take\\n        long long take=abs(robot[i]-fact[j]);\\n        long long rem=solve(robot,fact,i+1,j+1);\\n        if(rem==LLONG_MAX){\\n            take=LLONG_MAX;\\n        }else{\\n            take+=rem;\\n        }\\n//         not take\\n        long long notTake=solve(robot,fact,i,j+1);\\n        return ans[i][j]=min(take,notTake);\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        // long long ans=0;\\n        int n=robot.size();\\n        \\n        sort(robot.begin(),robot.end());\\n        vector<int> fact;\\n        sort(factory.begin(),factory.end());\\n        for(int i=0;i<factory.size();i++){\\n            for(int j=0;j<factory[i][1];j++){\\n                fact.push_back(factory[i][0]);\\n            }\\n        }\\n        int len=fact.size();\\n        ans.resize(n,vector<long long>(len,-1));\\n        return solve(robot,fact,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> ans;\\n    long long solve(vector<int>& robot, vector<int> &fact, int i,int j){\\n        int n=robot.size();\\n        int len=fact.size();\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(i<n and j>=len){\\n            return LLONG_MAX;\\n        }\\n        if(ans[i][j]!=-1){\\n            return ans[i][j];\\n        }\\n        \\n//         take\\n        long long take=abs(robot[i]-fact[j]);\\n        long long rem=solve(robot,fact,i+1,j+1);\\n        if(rem==LLONG_MAX){\\n            take=LLONG_MAX;\\n        }else{\\n            take+=rem;\\n        }\\n//         not take\\n        long long notTake=solve(robot,fact,i,j+1);\\n        return ans[i][j]=min(take,notTake);\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        // long long ans=0;\\n        int n=robot.size();\\n        \\n        sort(robot.begin(),robot.end());\\n        vector<int> fact;\\n        sort(factory.begin(),factory.end());\\n        for(int i=0;i<factory.size();i++){\\n            for(int j=0;j<factory[i][1];j++){\\n                fact.push_back(factory[i][0]);\\n            }\\n        }\\n        int len=fact.size();\\n        ans.resize(n,vector<long long>(len,-1));\\n        return solve(robot,fact,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792921,
                "title": "why-priority-queue-is-not-working-here",
                "content": "class Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        \\n        typedef pair<long,pair<int,int>> pairp;\\n        //vector<vector<>>edges;\\n        priority_queue <pairp, vector<pairp>, greater<pairp> > pq;\\n        \\n        for(int i = 0; i < robot.size(); i++)\\n        {\\n            //vector<pair<int,pair<int,int>>>v1;\\n            for(int j = 0; j < factory.size(); j++)\\n            {\\n                int c = abs(robot[i]-factory[j][0]);\\n                pq.push(make_pair(c,make_pair(i,j)));\\n                \\n            }\\n        }\\n        \\n        long long ans = 0;\\n        \\n        int dp[factory.size()];\\n        bool visit[robot.size()];\\n        \\n        for(int i = 0; i < factory.size(); i++)\\n        {\\n            dp[i] = factory[i][1]; \\n        }\\n        \\n        for(int i = 0; i < robot.size(); i++)\\n        {\\n            visit[i] = false;\\n        }\\n        \\n        while(pq.size())\\n        {\\n            pairp p1 = pq.top();\\n            \\n            if(visit[p1.second.first] || dp[p1.second.second] == 0)\\n            {\\n                pq.pop();\\n                continue;\\n            }\\n            \\n            ans += p1.first;\\n            \\n            cout << p1.second.first << \"factry\" << p1.second.second << \"cost is\" << p1.first << endl; \\n            \\n            visit[p1.second.first] =true;\\n            dp[p1.second.second]-=1;\\n            pq.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        \\n        typedef pair<long,pair<int,int>> pairp;\\n        //vector<vector<>>edges;\\n        priority_queue <pairp, vector<pairp>, greater<pairp> > pq;\\n        \\n        for(int i = 0; i < robot.size(); i++)\\n        {\\n            //vector<pair<int,pair<int,int>>>v1;\\n            for(int j = 0; j < factory.size(); j++)\\n            {\\n                int c = abs(robot[i]-factory[j][0]);\\n                pq.push(make_pair(c,make_pair(i,j)));\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2792687,
                "title": "dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThought this problem as which factory will repair which robot. Factories are expected to repair robots nearest to them, but they have a limit. It makes the problem more complex, hence we can think of a factory can repair at most limit robots, so we can check for every possibility of 0 to limit, in which the solution is optimal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt will be solved using DP.\\nlet DP[i][j] -> minimun movment required by first i robots to repaired by first j factories.\\n\\n# Complexity\\n- Time complexity: O(nm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nm)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    vector<vector<long long>> dp;\\n    \\n    long long recur(vector<int> & robot,vector<vector<int>> & factory,int i, int j){\\n        if(i<=0){\\n            return 0;\\n        }\\n        else if(j<=0){\\n            return -1;\\n        }\\n        else if(dp[i][j]!=-2){\\n            return dp[i][j];\\n        }\\n        else{\\n            int mn=factory[j-1][1];\\n            long long ans=LONG_MAX;\\n            long long pf=0;\\n            for(int ind=i-1;ind>=0 && (i-ind)<=mn;ind--){\\n                pf+=abs(robot[ind]-factory[j-1][0]);\\n                long long val=recur(robot,factory,ind,j-1);\\n                if(val==-1){\\n                    continue;\\n                }\\n                ans=min(ans,pf+val);\\n                \\n            }\\n            long long v=recur(robot,factory,i,j-1);\\n            if(v!=-1){\\n                ans=min(ans,v);\\n            }\\n            if(ans==LONG_MAX){\\n                dp[i][j]=-1;\\n            }\\n            else{\\n                dp[i][j]=ans;\\n            }\\n            \\n            return dp[i][j];\\n        }\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int r=robot.size();\\n        int f=factory.size();\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        dp.resize(r+1,vector<long long>(f+1,-2));\\n        long long ans=recur(robot,factory,r,f);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    vector<vector<long long>> dp;\\n    \\n    long long recur(vector<int> & robot,vector<vector<int>> & factory,int i, int j){\\n        if(i<=0){\\n            return 0;\\n        }\\n        else if(j<=0){\\n            return -1;\\n        }\\n        else if(dp[i][j]!=-2){\\n            return dp[i][j];\\n        }\\n        else{\\n            int mn=factory[j-1][1];\\n            long long ans=LONG_MAX;\\n            long long pf=0;\\n            for(int ind=i-1;ind>=0 && (i-ind)<=mn;ind--){\\n                pf+=abs(robot[ind]-factory[j-1][0]);\\n                long long val=recur(robot,factory,ind,j-1);\\n                if(val==-1){\\n                    continue;\\n                }\\n                ans=min(ans,pf+val);\\n                \\n            }\\n            long long v=recur(robot,factory,i,j-1);\\n            if(v!=-1){\\n                ans=min(ans,v);\\n            }\\n            if(ans==LONG_MAX){\\n                dp[i][j]=-1;\\n            }\\n            else{\\n                dp[i][j]=ans;\\n            }\\n            \\n            return dp[i][j];\\n        }\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int r=robot.size();\\n        int f=factory.size();\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        dp.resize(r+1,vector<long long>(f+1,-2));\\n        long long ans=recur(robot,factory,r,f);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792340,
                "title": "c-3d-dp-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        \\n        int m = robot.size();\\n        int n = factory.size();\\n        int o = m + 1;\\n        \\n        vector<vector<vector<long long>>> memo(m, vector<vector<long long>>(n, vector<long long>(o, -1)));\\n        \\n        return solve(0, 0, factory[0][1], robot, factory, memo);\\n    }\\n\\nprivate:\\n    long long solve(int robotIndex, int factoryIndex, int factoryLimit, vector<int>& robot, vector<vector<int>>& factory, vector<vector<vector<long long>>>& memo) {\\n               \\n        // if all the robots have been fixed, there will be no cost to fix them\\n        if (robotIndex == robot.size()) {\\n            return 0;\\n        }\\n        \\n        // if we ran out of factories to fix the current robot, return a very large value\\n        if (factoryIndex == factory.size()) {\\n            return 1e16;\\n        }\\n        \\n        // looking up in the memo\\n        if (memo[robotIndex][factoryIndex][factoryLimit] != -1) return memo[robotIndex][factoryIndex][factoryLimit];\\n        \\n        // at each factory, there is a choice to fix that robot here, or at some other factory ahead\\n        long long minCostIfAssigned = 1e16;\\n        long long minCostIfNotAssigned = 1e16;\\n        \\n        // if we choose to assign it to this factory, we must check if it has a limit > 0\\n        if (factoryLimit > 0) {\\n            minCostIfAssigned = min(minCostIfAssigned, solve(robotIndex + 1, factoryIndex, factoryLimit - 1, robot, factory, memo) + abs(robot[robotIndex] - factory[factoryIndex][0]));\\n        }\\n        \\n        // if we choose not to assign it to this factory, then simply increase the factory index and pass the next factory\\'s limit\\n        if (factoryIndex + 1 < factory.size()) {\\n        minCostIfNotAssigned = min(minCostIfNotAssigned, solve(robotIndex, factoryIndex + 1, factory[factoryIndex + 1][1], robot, factory, memo));\\n        }\\n        \\n        return memo[robotIndex][factoryIndex][factoryLimit] = min(minCostIfAssigned, minCostIfNotAssigned);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        \\n        int m = robot.size();\\n        int n = factory.size();\\n        int o = m + 1;\\n        \\n        vector<vector<vector<long long>>> memo(m, vector<vector<long long>>(n, vector<long long>(o, -1)));\\n        \\n        return solve(0, 0, factory[0][1], robot, factory, memo);\\n    }\\n\\nprivate:\\n    long long solve(int robotIndex, int factoryIndex, int factoryLimit, vector<int>& robot, vector<vector<int>>& factory, vector<vector<vector<long long>>>& memo) {\\n               \\n        // if all the robots have been fixed, there will be no cost to fix them\\n        if (robotIndex == robot.size()) {\\n            return 0;\\n        }\\n        \\n        // if we ran out of factories to fix the current robot, return a very large value\\n        if (factoryIndex == factory.size()) {\\n            return 1e16;\\n        }\\n        \\n        // looking up in the memo\\n        if (memo[robotIndex][factoryIndex][factoryLimit] != -1) return memo[robotIndex][factoryIndex][factoryLimit];\\n        \\n        // at each factory, there is a choice to fix that robot here, or at some other factory ahead\\n        long long minCostIfAssigned = 1e16;\\n        long long minCostIfNotAssigned = 1e16;\\n        \\n        // if we choose to assign it to this factory, we must check if it has a limit > 0\\n        if (factoryLimit > 0) {\\n            minCostIfAssigned = min(minCostIfAssigned, solve(robotIndex + 1, factoryIndex, factoryLimit - 1, robot, factory, memo) + abs(robot[robotIndex] - factory[factoryIndex][0]));\\n        }\\n        \\n        // if we choose not to assign it to this factory, then simply increase the factory index and pass the next factory\\'s limit\\n        if (factoryIndex + 1 < factory.size()) {\\n        minCostIfNotAssigned = min(minCostIfNotAssigned, solve(robotIndex, factoryIndex + 1, factory[factoryIndex + 1][1], robot, factory, memo));\\n        }\\n        \\n        return memo[robotIndex][factoryIndex][factoryLimit] = min(minCostIfAssigned, minCostIfNotAssigned);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791827,
                "title": "c-dp-recursive-easy-approach",
                "content": "Hey, found it as variation of edit-distance. : )\\n```\\nclass Solution {\\npublic:\\n    long long dp[101][101][101];\\n    long long f(vector<int> &robot, vector<vector<int>> &factory, int i, int j, int lim){\\n        if(j >= factory.size()){\\n            return i >= robot.size() ? 0 : 1e18; \\n        }\\n        if(i >= robot.size()){\\n            return 0;\\n        }\\n        // int lim = factory[j][1];\\n        long long ans = 1e18;\\n        if(dp[i][j][lim] != -1){\\n             return dp[i][j][lim];\\n        }\\n\\t\\t//Going with the simple approach of whether giving to the jth factory or not and finding the min of them, more like edit-distance kinda approach \\n        if(lim > 0){\\n            // factory[j][1]--;\\n            ans = f(robot, factory, i+1, j, lim - 1) + abs(robot[i] - factory[j][0]);\\n        }\\n\\t\\t\\n        if(j + 1 < factory.size())\\n\\t\\t\\tans = min(ans, f(robot, factory, i, j+1, factory[j+1][1]));\\n        dp[i][j][lim] = ans;\\n        return ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        memset(dp, -1, sizeof(dp));\\n        long long ans = f(robot, factory, 0, 0, factory[0][1]);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[101][101][101];\\n    long long f(vector<int> &robot, vector<vector<int>> &factory, int i, int j, int lim){\\n        if(j >= factory.size()){\\n            return i >= robot.size() ? 0 : 1e18; \\n        }\\n        if(i >= robot.size()){\\n            return 0;\\n        }\\n        // int lim = factory[j][1];\\n        long long ans = 1e18;\\n        if(dp[i][j][lim] != -1){\\n             return dp[i][j][lim];\\n        }\\n\\t\\t//Going with the simple approach of whether giving to the jth factory or not and finding the min of them, more like edit-distance kinda approach \\n        if(lim > 0){\\n            // factory[j][1]--;\\n            ans = f(robot, factory, i+1, j, lim - 1) + abs(robot[i] - factory[j][0]);\\n        }\\n\\t\\t\\n        if(j + 1 < factory.size())\\n\\t\\t\\tans = min(ans, f(robot, factory, i, j+1, factory[j+1][1]));\\n        dp[i][j][lim] = ans;\\n        return ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        memset(dp, -1, sizeof(dp));\\n        long long ans = f(robot, factory, 0, 0, factory[0][1]);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791804,
                "title": "recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n * n * n)\\n\\n- Space complexity:\\nO(n * n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n, m;\\nlong long cache[101][101];\\nlong long dp(int i, int j, vector<int>& robot, vector<vector<int>>& factory) {\\n    if(j == n) {\\n        return 0;\\n    }\\n    if(i == m) {\\n        return 1e16;\\n    }\\n    long long& ans = cache[i][j];\\n    if(ans != -1) {\\n        return ans;\\n    }\\n    ans = 1e16;\\n    int position = factory[i][0];\\n    int limit = factory[i][1];\\n    long long to_add = 0;\\n    // consider this factory\\n    for(int l = 0; l < limit; l++) {\\n        int index_r = j + l;\\n        if(index_r < n) {\\n            to_add += abs(robot[index_r] - position);\\n            ans = min(ans, to_add + dp(i + 1, index_r + 1, robot, factory));\\n            continue;\\n        }\\n        break;\\n    }\\n    // do not consider this factory\\n    ans = min(ans, dp(i + 1, j, robot, factory));\\n    return ans;\\n} \\nlong long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n    n = robot.size();\\n    m = factory.size();\\n    sort(robot.begin(), robot.end());\\n    auto flg = [&] (vector<int>& a, vector<int>& b) {\\n        return a[0] < b[0];\\n    };\\n    sort(factory.begin(), factory.end(), flg);\\n    memset(cache, -1, sizeof(cache));\\n    long long ans = dp(0, 0, robot, factory);\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n, m;\\nlong long cache[101][101];\\nlong long dp(int i, int j, vector<int>& robot, vector<vector<int>>& factory) {\\n    if(j == n) {\\n        return 0;\\n    }\\n    if(i == m) {\\n        return 1e16;\\n    }\\n    long long& ans = cache[i][j];\\n    if(ans != -1) {\\n        return ans;\\n    }\\n    ans = 1e16;\\n    int position = factory[i][0];\\n    int limit = factory[i][1];\\n    long long to_add = 0;\\n    // consider this factory\\n    for(int l = 0; l < limit; l++) {\\n        int index_r = j + l;\\n        if(index_r < n) {\\n            to_add += abs(robot[index_r] - position);\\n            ans = min(ans, to_add + dp(i + 1, index_r + 1, robot, factory));\\n            continue;\\n        }\\n        break;\\n    }\\n    // do not consider this factory\\n    ans = min(ans, dp(i + 1, j, robot, factory));\\n    return ans;\\n} \\nlong long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n    n = robot.size();\\n    m = factory.size();\\n    sort(robot.begin(), robot.end());\\n    auto flg = [&] (vector<int>& a, vector<int>& b) {\\n        return a[0] < b[0];\\n    };\\n    sort(factory.begin(), factory.end(), flg);\\n    memset(cache, -1, sizeof(cache));\\n    long long ans = dp(0, 0, robot, factory);\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791244,
                "title": "easy-dp-solution-c",
                "content": "# Intuition\\neach factory will repair [ O to limit of ith factor] number of robots\\n\\n# Approach\\nwe will sort both robots and factory by there position now we will try to assign each factor 0 to its limit number of robot \\n\\n# Complexity\\n- Time complexity:\\n        O(N3)\\n \\n\\n- Space complexity:\\n  O(N2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll; \\n    ll dp[101][101];\\n    ll solver(int i,int j,vector<int>&rob,vector<int>&pos,vector<int>&lim,int n,int m)\\n    {\\n          // i --> ith robot      rob[i]--> position of ith robot\\n          // j --> jth factory    pos[j]--> position of jth factory\\n          // lim[j] --> limit of jth factor \\n             \\n      \\n        if(i==n)\\n         return 0;\\n\\n        if(j==m)\\n         return 1e18;\\n\\n        if(dp[i][j]!=-1)\\n          return dp[i][j];\\n\\n        ll ans=LLONG_MAX;\\n        ll res=0;\\n\\n        ans=min(ans,solver(i,j+1,rob,pos,lim,n,m)); // no robot assinged to jth factor\\n        for(int k=i,l=0;l<lim[j] && k<n;k++,l++)// l+1 number of robots are assinged to jth factory\\n        {\\n           res+=abs(rob[k]-pos[j]);\\n           ans=min(ans,solver(k+1,j+1,rob,pos,lim,n,m)+res);\\n        }\\n\\n        return dp[i][j]=ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& rob, vector<vector<int>>& factory) {\\n        sort(rob.begin(),rob.end());\\n        sort(factory.begin(),factory.end(),[](vector<int>&a,vector<int>&b)\\n        {\\n            return a[0]<b[0];\\n        });\\n\\n        vector<int>pos;\\n        vector<int>lim;\\n\\n        int m=factory.size();\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            pos.push_back(factory[i][0]);\\n            lim.push_back(factory[i][1]);\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return solver(0,0,rob,pos,lim,rob.size(),factory.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll; \\n    ll dp[101][101];\\n    ll solver(int i,int j,vector<int>&rob,vector<int>&pos,vector<int>&lim,int n,int m)\\n    {\\n          // i --> ith robot      rob[i]--> position of ith robot\\n          // j --> jth factory    pos[j]--> position of jth factory\\n          // lim[j] --> limit of jth factor \\n             \\n      \\n        if(i==n)\\n         return 0;\\n\\n        if(j==m)\\n         return 1e18;\\n\\n        if(dp[i][j]!=-1)\\n          return dp[i][j];\\n\\n        ll ans=LLONG_MAX;\\n        ll res=0;\\n\\n        ans=min(ans,solver(i,j+1,rob,pos,lim,n,m)); // no robot assinged to jth factor\\n        for(int k=i,l=0;l<lim[j] && k<n;k++,l++)// l+1 number of robots are assinged to jth factory\\n        {\\n           res+=abs(rob[k]-pos[j]);\\n           ans=min(ans,solver(k+1,j+1,rob,pos,lim,n,m)+res);\\n        }\\n\\n        return dp[i][j]=ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& rob, vector<vector<int>>& factory) {\\n        sort(rob.begin(),rob.end());\\n        sort(factory.begin(),factory.end(),[](vector<int>&a,vector<int>&b)\\n        {\\n            return a[0]<b[0];\\n        });\\n\\n        vector<int>pos;\\n        vector<int>lim;\\n\\n        int m=factory.size();\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            pos.push_back(factory[i][0]);\\n            lim.push_back(factory[i][1]);\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return solver(0,0,rob,pos,lim,rob.size(),factory.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790769,
                "title": "python-dp-with-trimming-save-50-time",
                "content": "\\nthere are three trimming points, \\nfirst, the easiest one: skip the factory can fix zero robot\\nsecond, if a robot can not be fixed in the factory, the following robots will neighter \\nthird, this need some explain, \\n\\nto understand in easier way, I add a specific requirment to all factories, say one factory fix one and exact one robot.\\n\\nwhen the count of factories is just the same as the count of robots, there will be only one solution, that the factories match the robots one by one in order. \\n![image](https://assets.leetcode.com/users/images/5008a482-7f41-4147-b8a7-52b09eee0ed3_1667864259.1129026.png)\\n\\n\\nwhen the count of factories is just the one extra than the count of robots, there will be more choices. While each robot could has two oppotunities to pick a factory from two candidates. On the other hand, the factories\\'s choice has a up bound limitation. For the last factory f5 in following case, it can only pick r4, f4 has more choices, r4 and r3, f3 hs r3, r2,. So the up bound for f5 is 3 ( the index of r4) f4 is 2....\\nNo robot beyond the up bound will be handled by the corespoding factory. That is to say, they should be handled by earlier factories. Use this bound the loop will be cutted, for each factory, the loop will not exeed (C-R) * 2 + 1 times. Where C is the total capacity of all factories, R is the amount of robots. when C == R, each loop will exactly excuted one time for each factory.\\n![image](https://assets.leetcode.com/users/images/65a971c3-20fd-4fd3-b0c3-c38acf1798d0_1667864369.2961214.png)\\n\\nWhen the factories are allowed to fix more than one robots, it becomes a little complex, but not too much. \\n\\nWith all these the final code is here \\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        n, m = len(robot), len(factory)\\n        costs = [inf] * n\\n        totalability = sum(_[1] for _ in factory)\\n        up = n - totalability\\n        #remain = totalability - n\\n        pastfix = 0\\n        for p, c in factory[::-1]:\\n            if not c:\\n                # skip unqualified factory\\n                continue\\n            prefix = 0\\n            if up > 0:\\n                prefix = costs[up - 1]\\n                costs = costs[up:]\\n                robot = robot[:-up] \\n                up = 0\\n            df =[(0, -1)] \\n            for i, r in enumerate(robot[::-1]):  \\n                prefix += abs(r - p)\\n                while df and i - df[0][1] > c:\\n                    heappop(df)\\n                heappush(df, (costs[i] - prefix, i))\\n                costs[i] = prefix + df[0][0]\\n                if costs[i] == inf:\\n                    break\\n            up += c \\n        return costs[-1]\\n```\\n\\nM is the over all capability of all factories\\nN is amount of robots\\n\\nThe original DP is O(M*N*log(N)) for time complexity.\\nE = MIN(N, M - N + 1)\\nWith the trim is O(M*E*log(E)) for time complexity.\\nin many of the cases, E is smaller than N significently \\n\\nFor the current test cases in this problem, it saves almost half time.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        n, m = len(robot), len(factory)\\n        costs = [inf] * n\\n        totalability = sum(_[1] for _ in factory)\\n        up = n - totalability\\n        #remain = totalability - n\\n        pastfix = 0\\n        for p, c in factory[::-1]:\\n            if not c:\\n                # skip unqualified factory\\n                continue\\n            prefix = 0\\n            if up > 0:\\n                prefix = costs[up - 1]\\n                costs = costs[up:]\\n                robot = robot[:-up] \\n                up = 0\\n            df =[(0, -1)] \\n            for i, r in enumerate(robot[::-1]):  \\n                prefix += abs(r - p)\\n                while df and i - df[0][1] > c:\\n                    heappop(df)\\n                heappush(df, (costs[i] - prefix, i))\\n                costs[i] = prefix + df[0][0]\\n                if costs[i] == inf:\\n                    break\\n            up += c \\n        return costs[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790137,
                "title": "recursion-bottom-dp-and-optimized-space-bottom",
                "content": "First is the memoization\\n```\\n\\tlong long dp[103][10001]={0}; //dp[i][j] -> minimum distance for robots upto (i-1)th index and factory upto (j-1)th index\\n    long long inf = 1e12;\\n\\n    long long helper(int i,int j,vector<int>&robot,int *fact_pos){\\n        if(i<0) return 0; // all robot repaired\\n        if(j<0) return inf; //no factory left\\n        if(dp[i][j]==0){\\n            long long nch = helper(i,j-1,robot,fact_pos);\\n            long long ch = abs(robot[i]-fact_pos[j]) + helper(i-1,j-1,robot,fact_pos);\\n            dp[i][j] = 1+min(ch,nch);\\n        }\\n        return dp[i][j]-1;\\n    }\\n    \\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end(),[&](const auto &a,const auto &b){\\n            return a[0]<b[0];\\n        });\\n        \\n        int fact_pos[10000]; //expanding the original factory vector to fact_pos\\n        int j = 0;\\n        for(auto &it:factory)\\n            while(it[1]--)\\n                fact_pos[j++] = it[0];\\n        \\n        \\n        return helper(robot.size()-1,j-1,robot,fact_pos);\\n    }\\n```\\n\\nBottom up approach\\n```\\nlong long dp[103][10001]={0}; //dp[i][j] -> minimum distance for robots upto (i-1)th index and factory upto (j-1)th index\\n    long long inf = 1e12;\\n\\n    \\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end(),[&](const auto &a,const auto &b){\\n            return a[0]<b[0];\\n        });\\n        \\n        int fact_pos[10000];\\n        int j = 0;\\n        for(auto &it:factory)\\n            while(it[1]--)\\n                fact_pos[j++] = it[0];\\n        \\n        for(int i = 1;i<=robot.size();i++) //If there are no factory left\\n            dp[i][0] = inf;\\n        \\n        for(int J = 0;J<=j;J++) //If there are no robot left\\n            dp[0][J] = 0;\\n        \\n        for(int i = 1;i<=robot.size();i++){\\n            for(int J = 1;J<=j;J++){\\n                long long ch = abs(robot[i-1]-fact_pos[J-1]) + dp[i-1][J-1];\\n                long long nch = dp[i][J-1];\\n                dp[i][J] = min(ch,nch);\\n            }\\n        }\\n        return dp[robot.size()][j];\\n        \\n    }\\n```\\n\\nSpace optimized bottom up\\n```\\nlong long dp[2][10001]={0};\\n    long long inf = 1e12;\\n\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end(),[&](const auto &a,const auto &b){\\n            return a[0]<b[0];\\n        });\\n        \\n        int fact_pos[10000];\\n        int j = 0;\\n        for(auto &it:factory)\\n            while(it[1]--)\\n                fact_pos[j++] = it[0];\\n    \\n        \\n        for(int i = 1;i<=robot.size();i++){\\n            int cur = i%2,prev = !cur;\\n            for(int J = 1;J<=j;J++){\\n                //printf(\"%d %d \",i,J);\\n                long long ch = abs(robot[i-1]-fact_pos[J-1]) + (i==1?0:(J==1?inf:dp[prev][J-1]));\\n                long long nch = J==1?inf:dp[cur][J-1];\\n                dp[cur][J] = min(ch,nch);\\n                //printf(\"%lld %lld %lld\\\\n\",ch,nch,dp[cur][J]);\\n            }\\n        }\\n        return dp[robot.size()%2][j];\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tlong long dp[103][10001]={0}; //dp[i][j] -> minimum distance for robots upto (i-1)th index and factory upto (j-1)th index\\n    long long inf = 1e12;\\n\\n    long long helper(int i,int j,vector<int>&robot,int *fact_pos){\\n        if(i<0) return 0; // all robot repaired\\n        if(j<0) return inf; //no factory left\\n        if(dp[i][j]==0){\\n            long long nch = helper(i,j-1,robot,fact_pos);\\n            long long ch = abs(robot[i]-fact_pos[j]) + helper(i-1,j-1,robot,fact_pos);\\n            dp[i][j] = 1+min(ch,nch);\\n        }\\n        return dp[i][j]-1;\\n    }\\n    \\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end(),[&](const auto &a,const auto &b){\\n            return a[0]<b[0];\\n        });\\n        \\n        int fact_pos[10000]; //expanding the original factory vector to fact_pos\\n        int j = 0;\\n        for(auto &it:factory)\\n            while(it[1]--)\\n                fact_pos[j++] = it[0];\\n        \\n        \\n        return helper(robot.size()-1,j-1,robot,fact_pos);\\n    }\\n```\n```\\nlong long dp[103][10001]={0}; //dp[i][j] -> minimum distance for robots upto (i-1)th index and factory upto (j-1)th index\\n    long long inf = 1e12;\\n\\n    \\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end(),[&](const auto &a,const auto &b){\\n            return a[0]<b[0];\\n        });\\n        \\n        int fact_pos[10000];\\n        int j = 0;\\n        for(auto &it:factory)\\n            while(it[1]--)\\n                fact_pos[j++] = it[0];\\n        \\n        for(int i = 1;i<=robot.size();i++) //If there are no factory left\\n            dp[i][0] = inf;\\n        \\n        for(int J = 0;J<=j;J++) //If there are no robot left\\n            dp[0][J] = 0;\\n        \\n        for(int i = 1;i<=robot.size();i++){\\n            for(int J = 1;J<=j;J++){\\n                long long ch = abs(robot[i-1]-fact_pos[J-1]) + dp[i-1][J-1];\\n                long long nch = dp[i][J-1];\\n                dp[i][J] = min(ch,nch);\\n            }\\n        }\\n        return dp[robot.size()][j];\\n        \\n    }\\n```\n```\\nlong long dp[2][10001]={0};\\n    long long inf = 1e12;\\n\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end(),[&](const auto &a,const auto &b){\\n            return a[0]<b[0];\\n        });\\n        \\n        int fact_pos[10000];\\n        int j = 0;\\n        for(auto &it:factory)\\n            while(it[1]--)\\n                fact_pos[j++] = it[0];\\n    \\n        \\n        for(int i = 1;i<=robot.size();i++){\\n            int cur = i%2,prev = !cur;\\n            for(int J = 1;J<=j;J++){\\n                //printf(\"%d %d \",i,J);\\n                long long ch = abs(robot[i-1]-fact_pos[J-1]) + (i==1?0:(J==1?inf:dp[prev][J-1]));\\n                long long nch = J==1?inf:dp[cur][J-1];\\n                dp[cur][J] = min(ch,nch);\\n                //printf(\"%lld %lld %lld\\\\n\",ch,nch,dp[cur][J]);\\n            }\\n        }\\n        return dp[robot.size()%2][j];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2788604,
                "title": "simple-dp-solution-c",
                "content": "```\\n#define vi vector<int>\\nclass Solution {\\npublic:\\n    //dp[i][j] means what is minimum sum if we have robots (i,i+1,....n-1) & factory (j,j+1,..)\\n    long long dp[101][101];\\n    long long helper(int i,int j,vi &robot, vector<vi>&factory){\\n\\t    // if all robots are used up so ans =0;\\n        if(i>=robot.size())return 0;\\n\\t\\t// if factory accomodation capacity fall short then inf is ans as robots won\\'t find any place\\n        else if(j>=factory.size())return (long long)100*INT_MAX;\\n        else if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        long long &ans=dp[i][j];\\n        ans=helper(i,j+1,robot,factory);\\n        long long sum=0;\\n        long long k=factory[j][1],pos=factory[j][0];\\n\\t\\t//for each factory we will try to accomodate 0-max capcity robots that lie on number line nearest to it.\\n        while(i<robot.size()&&k--){\\n            sum+=abs(pos-robot[i]);\\n            long long r=helper(i+1,j+1,robot,factory);\\n            // if(r!=-1)\\n            ans=min(ans,sum+r);\\n            i++;\\n        }\\n        return ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,robot,factory);\\n    }\\n};\\n```\\nUpvote if you like the solution. Feel free to ask query in comments.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\n#define vi vector<int>\\nclass Solution {\\npublic:\\n    //dp[i][j] means what is minimum sum if we have robots (i,i+1,....n-1) & factory (j,j+1,..)\\n    long long dp[101][101];\\n    long long helper(int i,int j,vi &robot, vector<vi>&factory){\\n\\t    // if all robots are used up so ans =0;\\n        if(i>=robot.size())return 0;\\n\\t\\t// if factory accomodation capacity fall short then inf is ans as robots won\\'t find any place\\n        else if(j>=factory.size())return (long long)100*INT_MAX;\\n        else if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        long long &ans=dp[i][j];\\n        ans=helper(i,j+1,robot,factory);\\n        long long sum=0;\\n        long long k=factory[j][1],pos=factory[j][0];\\n\\t\\t//for each factory we will try to accomodate 0-max capcity robots that lie on number line nearest to it.\\n        while(i<robot.size()&&k--){\\n            sum+=abs(pos-robot[i]);\\n            long long r=helper(i+1,j+1,robot,factory);\\n            // if(r!=-1)\\n            ans=min(ans,sum+r);\\n            i++;\\n        }\\n        return ans;\\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,robot,factory);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787810,
                "title": "my-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, A: List[int], B: List[List[int]]) -> int:\\n        n, m = len(A), len(B)\\n        dp = [inf] * (n + 1)\\n        dp[n] = 0\\n        A.sort()\\n        B.sort()\\n        for j in range(m-1,-1,-1):\\n            for i in range(n):\\n                cur = 0\\n                for k in range(1, min(B[j][1], n - i) + 1):\\n                    cur += abs(A[i + k - 1] - B[j][0])\\n                    dp[i] = min(dp[i], dp[i + k] + cur)\\n        return dp[0]        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, A: List[int], B: List[List[int]]) -> int:\\n        n, m = len(A), len(B)\\n        dp = [inf] * (n + 1)\\n        dp[n] = 0\\n        A.sort()\\n        B.sort()\\n        for j in range(m-1,-1,-1):\\n            for i in range(n):\\n                cur = 0\\n                for k in range(1, min(B[j][1], n - i) + 1):\\n                    cur += abs(A[i + k - 1] - B[j][0])\\n                    dp[i] = min(dp[i], dp[i + k] + cur)\\n        return dp[0]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787757,
                "title": "iterative-solution",
                "content": "`dp[i][j]` is the minimum cost to assign first `i` factories to first `j` robots.\\n\\n`i`th factory can repair atmost `limit` number of robots. Among the first j robots it\\'s optimal to pick  k robots from the right side because they are nearest to ith factory, as shown below:\\n```\\nrj => jth robot\\nfi => ith factory\\n\\n\\t\\tj robots\\n<-------------------->\\n\\t\\t\\t\\tk\\n\\t\\t  <---------->\\nr1   r2   r3   r4   r5 . . .\\n\\t  . . f1   f2   f3 . . .\\n<---------->\\ni factories\\n\\t\\t  \\n```\\n`r1` and `r2` can also be close to factory `f1` but the distance between the factories on the left of `f1` and `r3, r4, r5` will always be greater than distance between factories on the left of `f1` and `r1, r2`. So `r1, r2` are assigned to factories on the left and the suffix is assigned to `f1`.\\n\\nFor each value of `i` and `j` we can iterate on the `limit` of each factory and try to assign the best k robots from the suffix to each factory.\\n\\n```\\n    ll minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int n = robot.size();\\n        int m = factory.size();\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        \\n        vector<vector<ll>> dp(105, vector<ll>(105, 1e14));\\n        dp[0][0] = 0;\\n\\t\\t\\n        for(int i=1; i<=m; i++) {\\n            dp[i][0] = 0;\\n\\t\\t\\t\\n            for(int j=1; j<=n; j++) {\\n                dp[i][j] = dp[i-1][j];\\n\\t\\t\\t\\t\\n                ll curCost = 0;\\n                for(int k=1; k<=factory[i-1][1]; k++) {\\n                    if(j-k<0) break;\\n                    curCost += abs(factory[i-1][0] - robot[j-k]);\\n                    dp[i][j] = min(dp[i][j], curCost + dp[i-1][j-k]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nrj => jth robot\\nfi => ith factory\\n\\n\\t\\tj robots\\n<-------------------->\\n\\t\\t\\t\\tk\\n\\t\\t  <---------->\\nr1   r2   r3   r4   r5 . . .\\n\\t  . . f1   f2   f3 . . .\\n<---------->\\ni factories\\n\\t\\t  \\n```\n```\\n    ll minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int n = robot.size();\\n        int m = factory.size();\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        \\n        vector<vector<ll>> dp(105, vector<ll>(105, 1e14));\\n        dp[0][0] = 0;\\n\\t\\t\\n        for(int i=1; i<=m; i++) {\\n            dp[i][0] = 0;\\n\\t\\t\\t\\n            for(int j=1; j<=n; j++) {\\n                dp[i][j] = dp[i-1][j];\\n\\t\\t\\t\\t\\n                ll curCost = 0;\\n                for(int k=1; k<=factory[i-1][1]; k++) {\\n                    if(j-k<0) break;\\n                    curCost += abs(factory[i-1][0] - robot[j-k]);\\n                    dp[i][j] = min(dp[i][j], curCost + dp[i-1][j-k]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2787749,
                "title": "c-dp-commented-code",
                "content": "**Approach**\\n1.] If i==robot.length i.e. all robots get repaired so return 0 else if j==factory.size i.e. not possible so return big value\\n2.] here dp[i][j][x] means for robo ith and jth factory with x remaining repaires on that factory\\n\\n**C++ code**\\n```\\nclass Solution {\\nprivate:\\n    int n,m;\\n    long long dp[101][101][101];\\n    \\npublic:\\n    \\n    long long solve(int i, int j, int x, vector<int>& rob, vector<vector<int>>& fac){\\n        if(i==n){\\n            return 0;\\n        }\\n        if(j>=m){\\n            return 1e10;\\n        }\\n        if(dp[i][j][x]!=-1){\\n            return dp[i][j][x];\\n        }\\n        long long ans=1e18;\\n        if(x>0){\\n            //take that factory\\n            ans=abs(rob[i]-fac[j][0])+solve(i+1,j,x-1,rob,fac);\\n            //i+1 becoz ith robo get repaired\\n            //x-1 becoz our current factory strngth reduced by one\\n        }\\n        \\n        //neglect current factory\\n        if(j+1<m)\\n            ans=min(ans,solve(i,j+1,fac[j+1][1],rob,fac));\\n        return dp[i][j][x] = ans;\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        n=robot.size();\\n        m=factory.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,factory[0][1],robot,factory);\\n    }\\n};\\n//code by sachin\\n```\\n**Upvote if solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n,m;\\n    long long dp[101][101][101];\\n    \\npublic:\\n    \\n    long long solve(int i, int j, int x, vector<int>& rob, vector<vector<int>>& fac){\\n        if(i==n){\\n            return 0;\\n        }\\n        if(j>=m){\\n            return 1e10;\\n        }\\n        if(dp[i][j][x]!=-1){\\n            return dp[i][j][x];\\n        }\\n        long long ans=1e18;\\n        if(x>0){\\n            //take that factory\\n            ans=abs(rob[i]-fac[j][0])+solve(i+1,j,x-1,rob,fac);\\n            //i+1 becoz ith robo get repaired\\n            //x-1 becoz our current factory strngth reduced by one\\n        }\\n        \\n        //neglect current factory\\n        if(j+1<m)\\n            ans=min(ans,solve(i,j+1,fac[j+1][1],rob,fac));\\n        return dp[i][j][x] = ans;\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        n=robot.size();\\n        m=factory.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,factory[0][1],robot,factory);\\n    }\\n};\\n//code by sachin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787736,
                "title": "python-min-cost-max-flow-with-dijkstra-traverse",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith factory has limits, we can view the problem as Min Cost Max Flow.\\nPlease refer to [https://cp-algorithms.com/graph/min_cost_flow.html](https://cp-algorithms.com/graph/min_cost_flow.html) for detail of this alogorithm.\\n\\n# Complexity\\n- Time complexity:\\nO(FElogV), F is max flow(in the problem is M), E is Edge number(M * N + M + N), V is Vertex number(M + N + 2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n(M + N)\\n# Code\\n```\\nfrom heapq import heappush, heappop\\n\\n\\nclass edge:\\n    def __init__(self, to, cap, cost, rev):\\n        self.to, self.cap, self.cost, self.rev = to, cap, cost, rev\\n\\n\\nclass MinCostFlow:\\n\\n    def __init__(self, n):\\n        self.n = n\\n        self.graph = [[] for _ in range(n)]\\n\\n    def add_edge(self, src, to, cap, cost):\\n        self.graph[src].append(edge(to, cap, cost, len(self.graph[to])))\\n        self.graph[to].append(edge(src, 0, -cost, len(self.graph[src]) - 1))\\n    \\n    def solve(self, s, t, f):\\n        h = [0] * self.n\\n        prevv, preve = [0] * self.n, [0] * self.n\\n        ret = 0\\n        while f:\\n            dis = [float(\\'inf\\')] * self.n\\n            dis[s] = 0\\n            hq = [(0, s)]\\n            while hq:\\n                d, v = heappop(hq)\\n                if dis[v] < d: continue\\n                for i, e in enumerate(self.graph[v]):\\n                    if e.cap > 0 and dis[e.to] > dis[v] + e.cost + h[v] - h[e.to]:\\n                        dis[e.to] = dis[v] + e.cost + h[v] - h[e.to]\\n                        prevv[e.to], preve[e.to] = v, i\\n                        heappush(hq, (dis[e.to], e.to))\\n            if dis[t] == float(\\'inf\\'): return -1\\n            for v in range(self.n): h[v] += dis[v]\\n            d, v = f, t\\n            while v != s:\\n                d = min(d, self.graph[prevv[v]][preve[v]].cap)\\n                v = prevv[v]\\n            f -= d\\n            ret += d * h[t]\\n            v = t\\n            while v != s:\\n                self.graph[prevv[v]][preve[v]].cap -= d\\n                self.graph[v][self.graph[prevv[v]][preve[v]].rev].cap += d\\n                v = prevv[v]\\n        return ret\\n\\n\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        m, n = len(robot), len(factory)\\n        s, t = m + n, m + n + 1\\n        mcf = MinCostFlow(t + 1)\\n        for i in range(m): mcf.add_edge(s, i, 1, 0)\\n        for j in range(n): mcf.add_edge(j + m, t, factory[j][1], 0)\\n        for i in range(m):\\n            for j in range(n): mcf.add_edge(i, j + m, 1, abs(robot[i] - factory[j][0]))\\n        return mcf.solve(s, t, len(robot))\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\n\\nclass edge:\\n    def __init__(self, to, cap, cost, rev):\\n        self.to, self.cap, self.cost, self.rev = to, cap, cost, rev\\n\\n\\nclass MinCostFlow:\\n\\n    def __init__(self, n):\\n        self.n = n\\n        self.graph = [[] for _ in range(n)]\\n\\n    def add_edge(self, src, to, cap, cost):\\n        self.graph[src].append(edge(to, cap, cost, len(self.graph[to])))\\n        self.graph[to].append(edge(src, 0, -cost, len(self.graph[src]) - 1))\\n    \\n    def solve(self, s, t, f):\\n        h = [0] * self.n\\n        prevv, preve = [0] * self.n, [0] * self.n\\n        ret = 0\\n        while f:\\n            dis = [float(\\'inf\\')] * self.n\\n            dis[s] = 0\\n            hq = [(0, s)]\\n            while hq:\\n                d, v = heappop(hq)\\n                if dis[v] < d: continue\\n                for i, e in enumerate(self.graph[v]):\\n                    if e.cap > 0 and dis[e.to] > dis[v] + e.cost + h[v] - h[e.to]:\\n                        dis[e.to] = dis[v] + e.cost + h[v] - h[e.to]\\n                        prevv[e.to], preve[e.to] = v, i\\n                        heappush(hq, (dis[e.to], e.to))\\n            if dis[t] == float(\\'inf\\'): return -1\\n            for v in range(self.n): h[v] += dis[v]\\n            d, v = f, t\\n            while v != s:\\n                d = min(d, self.graph[prevv[v]][preve[v]].cap)\\n                v = prevv[v]\\n            f -= d\\n            ret += d * h[t]\\n            v = t\\n            while v != s:\\n                self.graph[prevv[v]][preve[v]].cap -= d\\n                self.graph[v][self.graph[prevv[v]][preve[v]].rev].cap += d\\n                v = prevv[v]\\n        return ret\\n\\n\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        m, n = len(robot), len(factory)\\n        s, t = m + n, m + n + 1\\n        mcf = MinCostFlow(t + 1)\\n        for i in range(m): mcf.add_edge(s, i, 1, 0)\\n        for j in range(n): mcf.add_edge(j + m, t, factory[j][1], 0)\\n        for i in range(m):\\n            for j in range(n): mcf.add_edge(i, j + m, 1, abs(robot[i] - factory[j][0]))\\n        return mcf.solve(s, t, len(robot))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787509,
                "title": "simple-java-solution-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs this problem involves cases of sucess or failure it tells us that Dynamic Programming is needed. As it is a minimize distance problem so we need to sort the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd all the repairs available at the locations in an array and sort it.\\nThen we will use concept of Take-notTake to select if robots would be repair at that location.\\nWe take minimum of Take-notTake and return the answer\\n\\n# Complexity\\n- Time complexity: O(n*m) here n is number of robots and m is the number of repairs that can be perform\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m) here n is number of robots and m is the number of repairs that can be perform\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        Collections.sort(robot);\\n        List<Integer> fact=new ArrayList<Integer>();\\n        for(int i=0;i<factory.length;i++){\\n            for(int j=0;j<factory[i][1];j++){\\n                fact.add(factory[i][0]);\\n            }\\n        }\\n        Collections.sort(fact);\\n        Long[][] dp=new Long[robot.size()+1][fact.size()+1];\\n        return helper(dp,robot,fact,0,0);\\n    }\\n    public long helper(Long[][] dp,List<Integer> robot,List<Integer> factory,int i,int j){\\n        if(i==robot.size()){\\n            return 0;\\n        }\\n        if(j==factory.size()){\\n            return (long)1e14;\\n        }\\n        if(dp[i][j]!=null){\\n            return dp[i][j];\\n        }\\n        long min=(long)1e14;\\n        min=Math.min(min,helper(dp,robot,factory,i+1,j+1)+Math.abs(robot.get(i)-factory.get(j)));\\n        min=Math.min(min,helper(dp,robot,factory,i,j+1));\\n        return dp[i][j]=min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        Collections.sort(robot);\\n        List<Integer> fact=new ArrayList<Integer>();\\n        for(int i=0;i<factory.length;i++){\\n            for(int j=0;j<factory[i][1];j++){\\n                fact.add(factory[i][0]);\\n            }\\n        }\\n        Collections.sort(fact);\\n        Long[][] dp=new Long[robot.size()+1][fact.size()+1];\\n        return helper(dp,robot,fact,0,0);\\n    }\\n    public long helper(Long[][] dp,List<Integer> robot,List<Integer> factory,int i,int j){\\n        if(i==robot.size()){\\n            return 0;\\n        }\\n        if(j==factory.size()){\\n            return (long)1e14;\\n        }\\n        if(dp[i][j]!=null){\\n            return dp[i][j];\\n        }\\n        long min=(long)1e14;\\n        min=Math.min(min,helper(dp,robot,factory,i+1,j+1)+Math.abs(robot.get(i)-factory.get(j)));\\n        min=Math.min(min,helper(dp,robot,factory,i,j+1));\\n        return dp[i][j]=min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787480,
                "title": "help-why-can-t-we-use-multi-source-bfs-like-we-do-in-rotten-oranges",
                "content": "The first intution i got after seeing this problem was multi-source BFS bcoz BFS gives the shortest path.\\nMy approach was putting all the factories in a queue with there index in 2-D matrix with the side they are moving and putting all the location of robots in a set and when we remove any pair from queue and if at that index there is any robot and the limit is not reached we will repair it and put again factory in queue. we will move factory to both left and right.\\n\\nBut these approach giving wrong answer.\\ncan anyone explain what is wrong with that....\\nmy java code->\\n```\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        HashSet<Integer>set = new HashSet<>();\\n        for(int val : robot){\\n            set.add(val);\\n        }\\n        Queue<Pair>que = new LinkedList<>();\\n        for(int i = 0;i<factory.length;i++ ){\\n            int []fac = factory[i];\\n            que.add(new Pair(fac[0],i,false));\\n            que.add(new Pair(fac[0],i,true));\\n            \\n        }\\n        long ans = 0L;\\n        while(set.size()>0){\\n            Pair rem = que.remove();\\n            int left = rem.idx-1;\\n            int right = rem.idx+1;\\n            if(set.contains(rem.idx)&&factory[rem.origin][1]>0){\\n                ans += Math.abs(factory[rem.origin][0] - rem.idx);\\n                factory[rem.origin][1]--;\\n                set.remove(rem.idx);   \\n            }\\n            if(factory[rem.origin][1]>0){\\n                if(!rem.side)que.add(new Pair(left,rem.origin,false));\\n                if(rem.side)que.add(new Pair(right,rem.origin,true));\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n    class Pair{\\n        int idx;\\n        int origin;\\n        boolean side;\\n        Pair(int idx,int origin,boolean side){\\n            this.idx = idx;\\n            this.origin = origin;\\n            this.side = side;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        HashSet<Integer>set = new HashSet<>();\\n        for(int val : robot){\\n            set.add(val);\\n        }\\n        Queue<Pair>que = new LinkedList<>();\\n        for(int i = 0;i<factory.length;i++ ){\\n            int []fac = factory[i];\\n            que.add(new Pair(fac[0],i,false));\\n            que.add(new Pair(fac[0],i,true));\\n            \\n        }\\n        long ans = 0L;\\n        while(set.size()>0){\\n            Pair rem = que.remove();\\n            int left = rem.idx-1;\\n            int right = rem.idx+1;\\n            if(set.contains(rem.idx)&&factory[rem.origin][1]>0){\\n                ans += Math.abs(factory[rem.origin][0] - rem.idx);\\n                factory[rem.origin][1]--;\\n                set.remove(rem.idx);   \\n            }\\n            if(factory[rem.origin][1]>0){\\n                if(!rem.side)que.add(new Pair(left,rem.origin,false));\\n                if(rem.side)que.add(new Pair(right,rem.origin,true));\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n    class Pair{\\n        int idx;\\n        int origin;\\n        boolean side;\\n        Pair(int idx,int origin,boolean side){\\n            this.idx = idx;\\n            this.origin = origin;\\n            this.side = side;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786910,
                "title": "javascript-solution-dp",
                "content": "The specific explanation about the solution could be found by [@lee215](https://leetcode.com/problems/minimum-total-distance-traveled/discuss/2783305/Python-DP-Solution)\\n```\\nvar minimumTotalDistance = function(robot, factory) {\\n    robot.sort((a, b) => a - b);\\n    factory.sort((a, b) => a[0] - b[0]);\\n    let memo = {};\\n    \\n    const dp = function(i, j, k) {\\n        if (memo[`${i} ${j} ${k}`]) return memo[`${i} ${j} ${k}`];\\n        if (i === robot.length) return 0;\\n        if (j === factory.length) return Infinity;\\n        let distance1 = dp(i, j + 1, 0); \\n        let distance2 = factory[j][1] > k ? dp(i + 1, j, k + 1) + Math.abs(robot[i] - factory[j][0]) : Infinity;\\n        const result = Math.min(distance1, distance2);\\n        memo[`${i} ${j} ${k}`] = result;\\n        return result;\\n    }\\n    \\n    return dp(0, 0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumTotalDistance = function(robot, factory) {\\n    robot.sort((a, b) => a - b);\\n    factory.sort((a, b) => a[0] - b[0]);\\n    let memo = {};\\n    \\n    const dp = function(i, j, k) {\\n        if (memo[`${i} ${j} ${k}`]) return memo[`${i} ${j} ${k}`];\\n        if (i === robot.length) return 0;\\n        if (j === factory.length) return Infinity;\\n        let distance1 = dp(i, j + 1, 0); \\n        let distance2 = factory[j][1] > k ? dp(i + 1, j, k + 1) + Math.abs(robot[i] - factory[j][0]) : Infinity;\\n        const result = Math.min(distance1, distance2);\\n        memo[`${i} ${j} ${k}`] = result;\\n        return result;\\n    }\\n    \\n    return dp(0, 0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2786548,
                "title": "c-o-nlogn-beats-100",
                "content": "```\\nusing ll=long long;\\nstruct T{\\n\\tll v;\\n\\tmutable int c;\\n\\tbool operator<(T a)const{return v>a.v;}\\n};\\nenum{N=100009};\\nint x[N],y[N],w[N],c[N];\\nll solve(int n,int m){\\n\\tint i,j,k,t;\\n\\tll u,ans=0;\\n    priority_queue<T>q1,q2;\\n\\tfor(i=j=1,y[m+1]=2e9;;++i){\\n\\t\\tfor(;j<=n&&x[j]<y[i];++j){\\n\\t\\t\\tu=9e9;\\n\\t\\t\\tif(q2.size())if(u=x[j]+q2.top().v,!(--q2.top().c))q2.pop();\\n\\t\\t\\tans+=u,q1.push({-u-x[j],1});\\n\\t\\t}\\n\\t\\tif(i>m)break;\\n\\t\\tfor(t=0;q1.size()&&t<c[i];){\\n\\t\\t\\tif(u=q1.top().v+w[i]+y[i],u>0)break;\\n\\t\\t\\tk=min(c[i]-t,q1.top().c),ans+=u*k,t+=k;\\n\\t\\t\\tif(q2.push({-u-y[i]+w[i],k}),!(q1.top().c-=k))q1.pop();\\n\\t\\t}\\n\\t\\tif(t)q1.push({-y[i]-w[i],t});\\n\\t\\tif(c[i]-t)q2.push({w[i]-y[i],c[i]-t});\\n\\t}\\n\\treturn ans;\\n}\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& x, vector<vector<int>>& y) {\\n        int n=x.size(),m=y.size();\\n        sort(x.begin(),x.end()),sort(y.begin(),y.end());\\n        for(int i=1;i<=n;++i)::x[i]=x[i-1];\\n        for(int i=1;i<=m;++i)::y[i]=y[i-1][0],::c[i]=y[i-1][1];\\n        return solve(n,m);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll=long long;\\nstruct T{\\n\\tll v;\\n\\tmutable int c;\\n\\tbool operator<(T a)const{return v>a.v;}\\n};\\nenum{N=100009};\\nint x[N],y[N],w[N],c[N];\\nll solve(int n,int m){\\n\\tint i,j,k,t;\\n\\tll u,ans=0;\\n    priority_queue<T>q1,q2;\\n\\tfor(i=j=1,y[m+1]=2e9;;++i){\\n\\t\\tfor(;j<=n&&x[j]<y[i];++j){\\n\\t\\t\\tu=9e9;\\n\\t\\t\\tif(q2.size())if(u=x[j]+q2.top().v,!(--q2.top().c))q2.pop();\\n\\t\\t\\tans+=u,q1.push({-u-x[j],1});\\n\\t\\t}\\n\\t\\tif(i>m)break;\\n\\t\\tfor(t=0;q1.size()&&t<c[i];){\\n\\t\\t\\tif(u=q1.top().v+w[i]+y[i],u>0)break;\\n\\t\\t\\tk=min(c[i]-t,q1.top().c),ans+=u*k,t+=k;\\n\\t\\t\\tif(q2.push({-u-y[i]+w[i],k}),!(q1.top().c-=k))q1.pop();\\n\\t\\t}\\n\\t\\tif(t)q1.push({-y[i]-w[i],t});\\n\\t\\tif(c[i]-t)q2.push({w[i]-y[i],c[i]-t});\\n\\t}\\n\\treturn ans;\\n}\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& x, vector<vector<int>>& y) {\\n        int n=x.size(),m=y.size();\\n        sort(x.begin(),x.end()),sort(y.begin(),y.end());\\n        for(int i=1;i<=n;++i)::x[i]=x[i-1];\\n        for(int i=1;i<=m;++i)::y[i]=y[i-1][0],::c[i]=y[i-1][1];\\n        return solve(n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785941,
                "title": "c-easy-understanding-dynamic-programming",
                "content": "```\\n#define ll long long int\\n\\nclass Solution {\\n    int n,m;\\n    ll dp[101][101][101];\\n    ll INF = 1e18;\\n    long long utilfunc(int i,vector<int> &robot,int j,vector<vector<int>> &factory,int limit){\\n        if(i>=n) return 0;\\n        if(j>=m) return INF;\\n        \\n        if(dp[i][j][limit] != -1)\\n        {\\n            return dp[i][j][limit];\\n        }\\n        \\n        ll ans = INF;\\n        if(limit>0)\\n        {\\n            ans = utilfunc(i+1,robot,j,factory,limit-1)+abs(factory[j][0] - robot[i]);\\n        }\\n        \\n        if(j+1<m)\\n        ans = min(ans,utilfunc(i,robot,j+1,factory,factory[j+1][1]));\\n        \\n        return dp[i][j][limit] = ans;\\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        n = robot.size();\\n        m = factory.size();\\n        \\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return utilfunc(0,robot,0,factory,factory[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\n    int n,m;\\n    ll dp[101][101][101];\\n    ll INF = 1e18;\\n    long long utilfunc(int i,vector<int> &robot,int j,vector<vector<int>> &factory,int limit){\\n        if(i>=n) return 0;\\n        if(j>=m) return INF;\\n        \\n        if(dp[i][j][limit] != -1)\\n        {\\n            return dp[i][j][limit];\\n        }\\n        \\n        ll ans = INF;\\n        if(limit>0)\\n        {\\n            ans = utilfunc(i+1,robot,j,factory,limit-1)+abs(factory[j][0] - robot[i]);\\n        }\\n        \\n        if(j+1<m)\\n        ans = min(ans,utilfunc(i,robot,j+1,factory,factory[j+1][1]));\\n        \\n        return dp[i][j][limit] = ans;\\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        n = robot.size();\\n        m = factory.size();\\n        \\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return utilfunc(0,robot,0,factory,factory[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785431,
                "title": "python-top-down-dp",
                "content": "```\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        dp = defaultdict(lambda : defaultdict(dict))\\n        # distance for this f to r if it has already fixed k robots.\\n        def rec(r, f, k):\\n            if r == len(robot):\\n                return 0\\n            if f == len(factory):\\n                return inf\\n            if k in dp[r][f]:\\n                return dp[r][f][k]\\n            \\n            # we can either fix it at the next factory of this facotry\\n            o1 = rec(r + 1, f, k + 1) + abs(robot[r] - factory[f][0]) if factory[f][1] > k else inf\\n            o2 = rec(r, f+1, 0)\\n            v = min(o1, o2)\\n            dp[r][f][k] = v\\n            return v\\n        return rec(0,0,0)\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        dp = defaultdict(lambda : defaultdict(dict))\\n        # distance for this f to r if it has already fixed k robots.\\n        def rec(r, f, k):\\n            if r == len(robot):\\n                return 0\\n            if f == len(factory):\\n                return inf\\n            if k in dp[r][f]:\\n                return dp[r][f][k]\\n            \\n            # we can either fix it at the next factory of this facotry\\n            o1 = rec(r + 1, f, k + 1) + abs(robot[r] - factory[f][0]) if factory[f][1] > k else inf\\n            o2 = rec(r, f+1, 0)\\n            v = min(o1, o2)\\n            dp[r][f][k] = v\\n            return v\\n        return rec(0,0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2785382,
                "title": "c-dp-memo",
                "content": "\\tclass Solution {\\n    \\n    long long dp[101][101][101];\\n    long long inf = 1e18;\\n    long long rec(int ind1, int ind2, vector<int>& r, vector<vector<int>>& f) {\\n        \\n        if(ind1 == r.size())\\n            return 0;\\n        \\n        if(ind2 == f.size())\\n            return inf;\\n        \\n        long long curr = dp[ind1][ind2][f[ind2][1]];\\n        if(curr != -1)\\n            return curr;\\n        \\n        long long way1, way2;\\n        way1 = way2 = inf;\\n        \\n        if(f[ind2][1]) {\\n            f[ind2][1]--;\\n            way1 = abs(f[ind2][0] - r[ind1]) + rec(ind1 + 1, ind2, r, f);\\n            f[ind2][1]++;\\n        }\\n        \\n        way2 = rec(ind1, ind2 + 1, r, f);\\n        \\n        return dp[ind1][ind2][f[ind2][1]] = min(way1, way2);\\n    }\\n    \\n\\tpublic:\\n    long long minimumTotalDistance(vector<int>& r, vector<vector<int>>& f) {\\n        \\n        sort(r.begin(), r.end());\\n        sort(f.begin(), f.end());\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return rec(0, 0, r, f);\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    \\n    long long dp[101][101][101];\\n    long long inf = 1e18;\\n    long long rec(int ind1, int ind2, vector<int>& r, vector<vector<int>>& f) {\\n        \\n        if(ind1 == r.size())\\n            return 0;\\n        \\n        if(ind2 == f.size())\\n            return inf;\\n        \\n        long long curr = dp[ind1][ind2][f[ind2][1]];\\n        if(curr != -1)\\n            return curr;\\n        \\n        long long way1, way2;\\n        way1 = way2 = inf;\\n        \\n        if(f[ind2][1]) {\\n            f[ind2][1]--;\\n            way1 = abs(f[ind2][0] - r[ind1]) + rec(ind1 + 1, ind2, r, f);\\n            f[ind2][1]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2785365,
                "title": "c-solution-with-dp-descriptive-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- the clue is we can use dp by seeing constrains.\\n- the complexity might be NMK because it would be 10^6 for NMK by considering the constraints.\\n- write base cases when it completes all robots repair and for factory finish.\\n- check if we already solved the problem by looking into the dp.\\n- the idea is simple repairing the currentIndexRobot with currentIndexFactory or skip factory.\\n- return answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NMK)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(NMK)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long inf=1e12;\\n    long long dp[102][102][102];\\n    long long dynamicProgramming(int robotIndex,int factoryIndex,int robotsRepaired,vector<int> &robot,vector<vector<int>> &factory)\\n    {\\n        if(robotIndex==robot.size())\\n            return 0;\\n        if(factoryIndex==factory.size())\\n            return inf;\\n        if(dp[robotIndex][factoryIndex][robotsRepaired]!=-1)\\n            return dp[robotIndex][factoryIndex][robotsRepaired];\\n        long long ans=0;\\n        if(factory[factoryIndex][1]>robotsRepaired)\\n        {\\n            long long possibility1=dynamicProgramming(robotIndex,factoryIndex+1,0,robot,factory);\\n            long long possibility2=abs(robot[robotIndex]-factory[factoryIndex][0])+dynamicProgramming(robotIndex+1,factoryIndex,robotsRepaired+1,robot,factory);\\n            ans=min(possibility1,possibility2);\\n        }\\n        else\\n            {\\n                ans=dynamicProgramming(robotIndex,factoryIndex+1,0,robot,factory);\\n            }\\n        return dp[robotIndex][factoryIndex][robotsRepaired]=ans;\\n        \\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        memset(dp,-1,sizeof(dp));\\n        return dynamicProgramming(0,0,0,robot,factory);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long inf=1e12;\\n    long long dp[102][102][102];\\n    long long dynamicProgramming(int robotIndex,int factoryIndex,int robotsRepaired,vector<int> &robot,vector<vector<int>> &factory)\\n    {\\n        if(robotIndex==robot.size())\\n            return 0;\\n        if(factoryIndex==factory.size())\\n            return inf;\\n        if(dp[robotIndex][factoryIndex][robotsRepaired]!=-1)\\n            return dp[robotIndex][factoryIndex][robotsRepaired];\\n        long long ans=0;\\n        if(factory[factoryIndex][1]>robotsRepaired)\\n        {\\n            long long possibility1=dynamicProgramming(robotIndex,factoryIndex+1,0,robot,factory);\\n            long long possibility2=abs(robot[robotIndex]-factory[factoryIndex][0])+dynamicProgramming(robotIndex+1,factoryIndex,robotsRepaired+1,robot,factory);\\n            ans=min(possibility1,possibility2);\\n        }\\n        else\\n            {\\n                ans=dynamicProgramming(robotIndex,factoryIndex+1,0,robot,factory);\\n            }\\n        return dp[robotIndex][factoryIndex][robotsRepaired]=ans;\\n        \\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        memset(dp,-1,sizeof(dp));\\n        return dynamicProgramming(0,0,0,robot,factory);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785131,
                "title": "0-1-knapsack-type-3d-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    long long max_ele=1e13;\\n    long long dp[103][103][103];\\n    long long f(int i,int j,int limit,vector<int>& robot, vector<vector<int>>& factory){\\n        \\n        \\n        if(i==n)return 0;\\n        if(j==m)return max_ele;\\n        if(dp[i][j][limit]!=-1)return dp[i][j][limit];\\n        \\n        long long take=max_ele;\\n        if(limit>0){\\n            take=abs(factory[j][0]-robot[i])+f(i+1,j,limit-1,robot,factory);\\n        }\\n        long long notTake=max_ele;\\n        if(j+1<m){\\n             notTake=f(i,j+1,factory[j+1][1],robot,factory);\\n        }\\n        return dp[i][j][limit]=min(take,notTake);\\n        \\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        \\n        memset(dp,-1,sizeof dp);\\n        sort(begin(robot),end(robot));\\n        sort(begin(factory),end(factory));\\n        n=robot.size();\\n        m=factory.size();\\n        return f(0,0,factory[0][1],robot,factory);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    long long max_ele=1e13;\\n    long long dp[103][103][103];\\n    long long f(int i,int j,int limit,vector<int>& robot, vector<vector<int>>& factory){\\n        \\n        \\n        if(i==n)return 0;\\n        if(j==m)return max_ele;\\n        if(dp[i][j][limit]!=-1)return dp[i][j][limit];\\n        \\n        long long take=max_ele;\\n        if(limit>0){\\n            take=abs(factory[j][0]-robot[i])+f(i+1,j,limit-1,robot,factory);\\n        }\\n        long long notTake=max_ele;\\n        if(j+1<m){\\n             notTake=f(i,j+1,factory[j+1][1],robot,factory);\\n        }\\n        return dp[i][j][limit]=min(take,notTake);\\n        \\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        \\n        memset(dp,-1,sizeof dp);\\n        sort(begin(robot),end(robot));\\n        sort(begin(factory),end(factory));\\n        n=robot.size();\\n        m=factory.size();\\n        return f(0,0,factory[0][1],robot,factory);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785090,
                "title": "rust-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_total_distance(robot: Vec<i32>, factory: Vec<Vec<i32>>) -> i64 {\\n        let (m, n) = (factory.len(), robot.len());\\n        let (mut factory, mut robot) = (factory, robot);\\n        let mut sum = vec![0; m + 1];\\n        let mut dp = vec![vec![i64::MAX; m]; n];\\n\\n        factory.sort();\\n        robot.sort();\\n        for i in 0 .. m { sum[i + 1] = sum[i] + factory[i][1] as i64; }\\n        \\n        for i in 0 .. n {\\n            for j in 0 .. m {\\n                if i as i64 + 1 > sum[j + 1] { continue }\\n                if j == 0 {\\n                    dp[i][j] = 0;\\n                    for k in 0 ..= i {\\n                        dp[i][j] += i64::abs(factory[j][0] as i64 - robot[k] as i64);\\n                    }  \\n                    continue\\n                }\\n                \\n                let mut temp = 0;\\n                for k in 0 ..= factory[j][1] as usize {\\n                    if k > i + 1 { break }\\n                    if k > 0 {  temp += i64::abs(factory[j][0] as i64 - robot[i - k + 1] as i64); }\\n                    \\n                    if k <= i && dp[i - k][j - 1] == i64::MAX { continue }\\n                    let mut extra = 0;\\n                    if k <= i { extra = dp[i - k][j - 1]; }\\n                    dp[i][j] = dp[i][j].min(temp + extra);\\n                }\\n            }\\n        }\\n        \\n        dp[n - 1][m - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_total_distance(robot: Vec<i32>, factory: Vec<Vec<i32>>) -> i64 {\\n        let (m, n) = (factory.len(), robot.len());\\n        let (mut factory, mut robot) = (factory, robot);\\n        let mut sum = vec![0; m + 1];\\n        let mut dp = vec![vec![i64::MAX; m]; n];\\n\\n        factory.sort();\\n        robot.sort();\\n        for i in 0 .. m { sum[i + 1] = sum[i] + factory[i][1] as i64; }\\n        \\n        for i in 0 .. n {\\n            for j in 0 .. m {\\n                if i as i64 + 1 > sum[j + 1] { continue }\\n                if j == 0 {\\n                    dp[i][j] = 0;\\n                    for k in 0 ..= i {\\n                        dp[i][j] += i64::abs(factory[j][0] as i64 - robot[k] as i64);\\n                    }  \\n                    continue\\n                }\\n                \\n                let mut temp = 0;\\n                for k in 0 ..= factory[j][1] as usize {\\n                    if k > i + 1 { break }\\n                    if k > 0 {  temp += i64::abs(factory[j][0] as i64 - robot[i - k + 1] as i64); }\\n                    \\n                    if k <= i && dp[i - k][j - 1] == i64::MAX { continue }\\n                    let mut extra = 0;\\n                    if k <= i { extra = dp[i - k][j - 1]; }\\n                    dp[i][j] = dp[i][j].min(temp + extra);\\n                }\\n            }\\n        }\\n        \\n        dp[n - 1][m - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2784699,
                "title": "python3-dp",
                "content": "```python\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort(key=lambda x: x[0])\\n        \\n        dp = [[2**64 - 1 for _  in range(len(factory) + 1)] for _  in range(len(robot) + 1)]\\n        \\n        # base case \\n        # no robot\\n        for factory_i in range(len(factory)):\\n            dp[0][factory_i] = 0\\n        \\n        for factory_i in range(len(factory)):\\n            factory_pos, factory_limit = factory[factory_i]\\n            for robot_j in range(len(robot)):\\n                dp[robot_j + 1][factory_i + 1] = min(dp[robot_j + 1][factory_i], dp[robot_j + 1][factory_i + 1])\\n                cur_cost = 0\\n                for idx in range(min(factory_limit, robot_j + 1)):\\n                    cur_cost += abs(robot[robot_j - idx] - factory_pos)\\n                    if robot_j - idx >= 0:\\n                        dp[robot_j + 1][factory_i + 1] = min(\\n                            dp[robot_j + 1][factory_i + 1],\\n                            cur_cost + dp[robot_j - idx][factory_i]\\n                        )\\n        return dp[-1][-1]",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort(key=lambda x: x[0])\\n        \\n        dp = [[2**64 - 1 for _  in range(len(factory) + 1)] for _  in range(len(robot) + 1)]\\n        \\n        # base case \\n        # no robot\\n        for factory_i in range(len(factory)):\\n            dp[0][factory_i] = 0\\n        \\n        for factory_i in range(len(factory)):\\n            factory_pos, factory_limit = factory[factory_i]\\n            for robot_j in range(len(robot)):\\n                dp[robot_j + 1][factory_i + 1] = min(dp[robot_j + 1][factory_i], dp[robot_j + 1][factory_i + 1])\\n                cur_cost = 0\\n                for idx in range(min(factory_limit, robot_j + 1)):\\n                    cur_cost += abs(robot[robot_j - idx] - factory_pos)\\n                    if robot_j - idx >= 0:\\n                        dp[robot_j + 1][factory_i + 1] = min(\\n                            dp[robot_j + 1][factory_i + 1],\\n                            cur_cost + dp[robot_j - idx][factory_i]\\n                        )\\n        return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 2784397,
                "title": "c-dp-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long MAX_V = 200000000001;\\n    long long minimumTotalDistance(vector<int>& R, vector<vector<int>>& F) {\\n        sort(begin(R), end(R));\\n        sort(begin(F), end(F));\\n\\n        vector<vector<long long>> dp(R.size(), vector<long long>(F.size(), MAX_V));\\n        return helper(R, F, 0, 0, dp);\\n    }\\n\\n    long long helper(vector<int>& R, vector<vector<int>>& F, int i, int j, vector<vector<long long>>& dp) {\\n        if(i >= R.size()) return 0LL;\\n        if(j >= F.size()) return MAX_V;\\n\\n        if(dp[i][j] != MAX_V) return dp[i][j];\\n\\n        long long res = helper(R, F, i, j+1, dp), dist = 0;\\n        for(int k = 1; k <= F[j][1] && i+k-1 < R.size(); k++) {\\n            dist += abs(R[i+k-1]-F[j][0]);\\n            res = min(res, dist + helper(R, F, i+k, j+1, dp));\\n        }\\n        dp[i][j] = res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long MAX_V = 200000000001;\\n    long long minimumTotalDistance(vector<int>& R, vector<vector<int>>& F) {\\n        sort(begin(R), end(R));\\n        sort(begin(F), end(F));\\n\\n        vector<vector<long long>> dp(R.size(), vector<long long>(F.size(), MAX_V));\\n        return helper(R, F, 0, 0, dp);\\n    }\\n\\n    long long helper(vector<int>& R, vector<vector<int>>& F, int i, int j, vector<vector<long long>>& dp) {\\n        if(i >= R.size()) return 0LL;\\n        if(j >= F.size()) return MAX_V;\\n\\n        if(dp[i][j] != MAX_V) return dp[i][j];\\n\\n        long long res = helper(R, F, i, j+1, dp), dist = 0;\\n        for(int k = 1; k <= F[j][1] && i+k-1 < R.size(); k++) {\\n            dist += abs(R[i+k-1]-F[j][0]);\\n            res = min(res, dist + helper(R, F, i+k, j+1, dp));\\n        }\\n        dp[i][j] = res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784310,
                "title": "well-commented-2-state-recursive-dp-solution-time-o-r-f-l-space-o-r-f",
                "content": "```\\nclass Solution {\\nprivate:\\n    const long long inf = 1e13;\\n    long long dp[101][101];\\npublic:\\n    long long minD(vector<int>& R,vector<vector<int>>& F,int r,int f) {\\n        // all robots repaired\\n        if(r >= R.size()) return 0LL;\\n        \\n        //factories ended and robots still remaining => unwanted state\\n        if(f == F.size()) return inf;\\n        \\n        long long &ans = dp[r][f];\\n        \\n        if(~ans) return ans;\\n        \\n        // dont repair any robot at this factory so move to next factory\\n        ans = minD(R,F,r,f+1);\\n        \\n        long long cur_cost = 0LL,idx = r;\\n        for(int l = 1 ; l <= F[f][1] && idx < R.size() ; ++l,++idx) {\\n            // repair exactly l robots in this factory \\n            // and move to next factory with remaining robots\\n            cur_cost += 1LL* abs(R[idx] - F[f][0]);\\n            ans = min(ans,cur_cost + minD(R,F,idx + 1,f + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        return minD(robot,factory,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    const long long inf = 1e13;\\n    long long dp[101][101];\\npublic:\\n    long long minD(vector<int>& R,vector<vector<int>>& F,int r,int f) {\\n        // all robots repaired\\n        if(r >= R.size()) return 0LL;\\n        \\n        //factories ended and robots still remaining => unwanted state\\n        if(f == F.size()) return inf;\\n        \\n        long long &ans = dp[r][f];\\n        \\n        if(~ans) return ans;\\n        \\n        // dont repair any robot at this factory so move to next factory\\n        ans = minD(R,F,r,f+1);\\n        \\n        long long cur_cost = 0LL,idx = r;\\n        for(int l = 1 ; l <= F[f][1] && idx < R.size() ; ++l,++idx) {\\n            // repair exactly l robots in this factory \\n            // and move to next factory with remaining robots\\n            cur_cost += 1LL* abs(R[idx] - F[f][0]);\\n            ans = min(ans,cur_cost + minD(R,F,idx + 1,f + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        return minD(robot,factory,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784235,
                "title": "c-dynamic-programming",
                "content": "**Approach**\\nWe maintain total 3 states here one is for current factory and second for total choosen robot for the factory, and last state is for the current robot.\\n\\nCases:\\n\\n1. First case is that we can skip the current factory.\\n2. Second case is that if the choosen robots dosn\\'t exceed to the limit of the factory then we fix that factory for the current robot and add the total steps.\\n3. Finally we return the minimum of above two answers.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long solve(int i,int taken,int j,vector<int>& robot, vector<vector<int>>& factory,vector<vector<vector<long long>>>&dp){\\n        if(j >= robot.size()){\\n            return 0;\\n        }\\n        if(i >= factory.size()){\\n            return 1e15;\\n        }\\n        if(dp[i][taken][j] != -1) return dp[i][taken][j];\\n        long long ans1 = solve(i+1,0,j,robot,factory,dp);\\n        long long ans2 = 1e15;\\n        if(factory[i][1] > taken){\\n            ans2 = solve(i,taken+1,j+1,robot,factory,dp)+abs((long long)robot[j]-factory[i][0]);\\n        }\\n        return dp[i][taken][j] = min(ans1,ans2);\\n        \\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int n = factory.size();\\n        int m = robot.size();\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        vector<vector<vector<long long>>>dp(n,vector<vector<long long>>(101,vector<long long>(m,-1)));\\n        return solve(0,0,0,robot,factory,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int i,int taken,int j,vector<int>& robot, vector<vector<int>>& factory,vector<vector<vector<long long>>>&dp){\\n        if(j >= robot.size()){\\n            return 0;\\n        }\\n        if(i >= factory.size()){\\n            return 1e15;\\n        }\\n        if(dp[i][taken][j] != -1) return dp[i][taken][j];\\n        long long ans1 = solve(i+1,0,j,robot,factory,dp);\\n        long long ans2 = 1e15;\\n        if(factory[i][1] > taken){\\n            ans2 = solve(i,taken+1,j+1,robot,factory,dp)+abs((long long)robot[j]-factory[i][0]);\\n        }\\n        return dp[i][taken][j] = min(ans1,ans2);\\n        \\n    }\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        int n = factory.size();\\n        int m = robot.size();\\n        sort(robot.begin(),robot.end());\\n        sort(factory.begin(),factory.end());\\n        vector<vector<vector<long long>>>dp(n,vector<vector<long long>>(101,vector<long long>(m,-1)));\\n        return solve(0,0,0,robot,factory,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784137,
                "title": "python-by-3d-dp-w-comment",
                "content": "**Pyhton**:\\n\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        \\n        # Keep robot position in ascending order\\n        robot.sort()\\n        \\n        # Keep factory position in ascending order\\n        factory.sort()\\n        \\n        Infinity = sys.maxsize\\n\\t\\t\\n\\t\\t# Constant literal for factory parameter\\n        LOCATION, QUOTA = 0, 1\\n        \\n        \\n        # Check if factory[factoryIndex] can repair robot[robotIndex] with loading or not\\n        @cache\\n        def repair(robotIndex, factoryIndex, loading):\\n            \\n            ## Base case aka stop condition\\n            # We have repaired all robots already\\n            if robotIndex == len(robot):\\n                return 0\\n            \\n            ## Base case aka stop condition\\n            # Run out of all quota of all factories, cannot repair anymore\\n            if factoryIndex == len(factory):\\n                return Infinity\\n            \\n            \\n            ## Option_1: Current factory still has repair quota, use current factory to repair current robot\\n            if factory[factoryIndex][QUOTA] > loading :\\n\\n                option_1 = repair( robotIndex+1, factoryIndex, loading+1) + abs( factory[factoryIndex][LOCATION] - robot[robotIndex] )\\n                \\n            else:\\n                # Current factory cannot repair anymore.\\n                option_1 = Infinity\\n            \\n            \\n            ## Option_2: Not to use current factory to repair current robot\\n            option_2 = repair( robotIndex, factoryIndex+1, 0)\\n            \\n            # Optimization goal: minimize moving distance\\n            return min(option_1, option_2)\\n        \\n        # ------------------------------------------------------------\\n        return repair(robotIndex=0, factoryIndex=0, loading=0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        \\n        # Keep robot position in ascending order\\n        robot.sort()\\n        \\n        # Keep factory position in ascending order\\n        factory.sort()\\n        \\n        Infinity = sys.maxsize\\n\\t\\t\\n\\t\\t# Constant literal for factory parameter\\n        LOCATION, QUOTA = 0, 1\\n        \\n        \\n        # Check if factory[factoryIndex] can repair robot[robotIndex] with loading or not\\n        @cache\\n        def repair(robotIndex, factoryIndex, loading):\\n            \\n            ## Base case aka stop condition\\n            # We have repaired all robots already\\n            if robotIndex == len(robot):\\n                return 0\\n            \\n            ## Base case aka stop condition\\n            # Run out of all quota of all factories, cannot repair anymore\\n            if factoryIndex == len(factory):\\n                return Infinity\\n            \\n            \\n            ## Option_1: Current factory still has repair quota, use current factory to repair current robot\\n            if factory[factoryIndex][QUOTA] > loading :\\n\\n                option_1 = repair( robotIndex+1, factoryIndex, loading+1) + abs( factory[factoryIndex][LOCATION] - robot[robotIndex] )\\n                \\n            else:\\n                # Current factory cannot repair anymore.\\n                option_1 = Infinity\\n            \\n            \\n            ## Option_2: Not to use current factory to repair current robot\\n            option_2 = repair( robotIndex, factoryIndex+1, 0)\\n            \\n            # Optimization goal: minimize moving distance\\n            return min(option_1, option_2)\\n        \\n        # ------------------------------------------------------------\\n        return repair(robotIndex=0, factoryIndex=0, loading=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784068,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_robot * n_factories)\\n * Space Complexity: O(n_factories)\\n * where `n_robot` is the length of the vector `robot`\\n *       `n_factories` is the total number of robots which can be fixed by all factories\\n */\\nclass Solution {\\n public:\\n  long long minimumTotalDistance(vector<int> &robot, vector<vector<int>> &factory) {\\n    constexpr int factory_position_index = 0;\\n    constexpr int factory_capacity_index = 1;\\n    sort(robot.begin(), robot.end());\\n    sort(factory.begin(), factory.end());\\n    vector<int> factories;\\n    for (const vector<int> &factory_information : factory) {\\n      const int factory_position = factory_information[factory_position_index];\\n      const int factory_capacity = factory_information[factory_capacity_index];\\n      for (int i = 0; i < factory_capacity; ++i) {\\n        factories.emplace_back(factory_position);\\n      }\\n    }\\n\\n    const int n_robot = static_cast<int>(robot.size());\\n    const int n_factories = static_cast<int>(factories.size());\\n    /**\\n     * dp[i_robot][i_factory] stands for the minimum total distances\\n     * of all robots from robot[0] to robit[i_robot] when all robots\\n     * from robot[0] to robot[i_robot] have been fixed in factories\\n     * from factories[0] to factories[i_factory]\\n     */\\n    unsigned long long dp[2][n_factories];\\n    int previous = 0;\\n    int current = 1;\\n    memset(dp, -1, sizeof(dp));\\n    memset(dp[previous], 0, sizeof(dp[previous]));\\n    for (int i_robot = 0; i_robot < n_robot; ++i_robot) {\\n      const int robot_position = robot[i_robot];\\n      for (int i_factory = i_robot; i_factory + (n_robot - i_robot - 1) < n_factories; ++i_factory) {\\n        dp[current][i_factory] = min(\\n          /**\\n           * Case 1:\\n           * the robot `robot[i_robot]` has been fixed before the factory `factories[i_factory]`\\n           */\\n          i_factory == i_robot ? numeric_limits<unsigned long long>::max() : dp[current][i_factory - 1],\\n          /**\\n           * Case 2:\\n           * the robot `robot[i_robot]` will be fixed by the factory `factories[i_factory]`\\n           */\\n          (i_factory == 0 ? 0 : dp[previous][i_factory - 1]) + abs(robot_position - factories[i_factory])\\n        );\\n      }\\n\\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], -1, sizeof(dp[current]));\\n    }\\n    return static_cast<long long>(dp[previous][n_factories - 1]);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(n_robot * n_factories)\\n * Space Complexity: O(n_factories)\\n * where `n_robot` is the length of the vector `robot`\\n *       `n_factories` is the total number of robots which can be fixed by all factories\\n */\\nclass Solution {\\n public:\\n  long long minimumTotalDistance(vector<int> &robot, vector<vector<int>> &factory) {\\n    constexpr int factory_position_index = 0;\\n    constexpr int factory_capacity_index = 1;\\n    sort(robot.begin(), robot.end());\\n    sort(factory.begin(), factory.end());\\n    vector<int> factories;\\n    for (const vector<int> &factory_information : factory) {\\n      const int factory_position = factory_information[factory_position_index];\\n      const int factory_capacity = factory_information[factory_capacity_index];\\n      for (int i = 0; i < factory_capacity; ++i) {\\n        factories.emplace_back(factory_position);\\n      }\\n    }\\n\\n    const int n_robot = static_cast<int>(robot.size());\\n    const int n_factories = static_cast<int>(factories.size());\\n    /**\\n     * dp[i_robot][i_factory] stands for the minimum total distances\\n     * of all robots from robot[0] to robit[i_robot] when all robots\\n     * from robot[0] to robot[i_robot] have been fixed in factories\\n     * from factories[0] to factories[i_factory]\\n     */\\n    unsigned long long dp[2][n_factories];\\n    int previous = 0;\\n    int current = 1;\\n    memset(dp, -1, sizeof(dp));\\n    memset(dp[previous], 0, sizeof(dp[previous]));\\n    for (int i_robot = 0; i_robot < n_robot; ++i_robot) {\\n      const int robot_position = robot[i_robot];\\n      for (int i_factory = i_robot; i_factory + (n_robot - i_robot - 1) < n_factories; ++i_factory) {\\n        dp[current][i_factory] = min(\\n          /**\\n           * Case 1:\\n           * the robot `robot[i_robot]` has been fixed before the factory `factories[i_factory]`\\n           */\\n          i_factory == i_robot ? numeric_limits<unsigned long long>::max() : dp[current][i_factory - 1],\\n          /**\\n           * Case 2:\\n           * the robot `robot[i_robot]` will be fixed by the factory `factories[i_factory]`\\n           */\\n          (i_factory == 0 ? 0 : dp[previous][i_factory - 1]) + abs(robot_position - factories[i_factory])\\n        );\\n      }\\n\\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], -1, sizeof(dp[current]));\\n    }\\n    return static_cast<long long>(dp[previous][n_factories - 1]);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784038,
                "title": "c-super-easy-bottom-up-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        long long inf = 1e16;\\n        \\n        vector<int>v;\\n        \\n        for(auto f: factory){\\n            int x = f[0];\\n            int y = f[1];\\n            for(int i=0; i<y; i++)\\n                v.push_back(x);\\n        }\\n        \\n        int n = robot.size(), m = v.size();\\n        \\n        vector<vector<long long>>dp(n+1, vector<long long>(m+1, inf));\\n        \\n                             \\n        fill(dp[0].begin(), dp[0].end(), 0);\\n                                           \\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                \\n                dp[i][j] = min(dp[i][j-1],  llabs(robot[i-1]-v[j-1]) + dp[i-1][j-1]);\\n                \\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(robot.begin(), robot.end());\\n        sort(factory.begin(), factory.end());\\n        long long inf = 1e16;\\n        \\n        vector<int>v;\\n        \\n        for(auto f: factory){\\n            int x = f[0];\\n            int y = f[1];\\n            for(int i=0; i<y; i++)\\n                v.push_back(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2783962,
                "title": "someone-plz-explain-this-very-fast-solution-18ms",
                "content": "after my submission, i found there is a submission use only 18ms..\\nit seems to be greedy, just search twice\\n```\\nint64_t attempt(vector<int> const& robot, vector<vector<int>> const& factory, vector<int> const& perm) {\\n    int nf = factory.size();\\n    map<int, int> factoryIndex;\\n    vector<int> factoryUsed(nf);\\n    for (int i = 0; i < nf; ++i) {\\n        if (factory[i][1] > 0) {\\n            factoryIndex[factory[i][0]] = i;\\n        }\\n    }\\n\\n    int nr = robot.size();\\n    vector<int> robotFactory(nr);\\n\\n    for (int ii = 0; ii < nr; ++ii) {\\n        int i = perm[ii];\\n        int r = robot[i];\\n        auto it = factoryIndex.lower_bound(r);\\n        auto it1 = it;\\n        if (it1 != factoryIndex.begin()) {\\n            --it1;\\n            if (it == factoryIndex.end() || abs(it1->first - r) < abs(it->first - r)) {\\n                it = it1;\\n            }\\n        }\\n\\n        int index = it->second;\\n        robotFactory[i] = index;\\n\\n        if (++factoryUsed[index] == factory[index][1]) {\\n            factoryIndex.erase(it);\\n        }\\n    }\\n\\n    sort(robotFactory.begin(), robotFactory.end());\\n    \\n    int64_t ret = 0;\\n    for (int i = 0; i < nr; ++i) {\\n        ret += abs(robot[i] - factory[robotFactory[i]][0]);\\n    }\\n\\n    return ret;\\n}\\n\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(factory.begin(), factory.end());\\n        sort(robot.begin(), robot.end());\\n\\n        int nr = robot.size();\\n        vector<int> perm(nr);\\n        for (int i = 0; i < nr; ++i) {\\n            perm[i] = i;\\n        }\\n        int64_t ret = attempt(robot, factory, perm);\\n\\n        reverse(perm.begin(), perm.end());\\n        ret = min(ret, attempt(robot, factory, perm));\\n\\n        return ret;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nint64_t attempt(vector<int> const& robot, vector<vector<int>> const& factory, vector<int> const& perm) {\\n    int nf = factory.size();\\n    map<int, int> factoryIndex;\\n    vector<int> factoryUsed(nf);\\n    for (int i = 0; i < nf; ++i) {\\n        if (factory[i][1] > 0) {\\n            factoryIndex[factory[i][0]] = i;\\n        }\\n    }\\n\\n    int nr = robot.size();\\n    vector<int> robotFactory(nr);\\n\\n    for (int ii = 0; ii < nr; ++ii) {\\n        int i = perm[ii];\\n        int r = robot[i];\\n        auto it = factoryIndex.lower_bound(r);\\n        auto it1 = it;\\n        if (it1 != factoryIndex.begin()) {\\n            --it1;\\n            if (it == factoryIndex.end() || abs(it1->first - r) < abs(it->first - r)) {\\n                it = it1;\\n            }\\n        }\\n\\n        int index = it->second;\\n        robotFactory[i] = index;\\n\\n        if (++factoryUsed[index] == factory[index][1]) {\\n            factoryIndex.erase(it);\\n        }\\n    }\\n\\n    sort(robotFactory.begin(), robotFactory.end());\\n    \\n    int64_t ret = 0;\\n    for (int i = 0; i < nr; ++i) {\\n        ret += abs(robot[i] - factory[robotFactory[i]][0]);\\n    }\\n\\n    return ret;\\n}\\n\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        sort(factory.begin(), factory.end());\\n        sort(robot.begin(), robot.end());\\n\\n        int nr = robot.size();\\n        vector<int> perm(nr);\\n        for (int i = 0; i < nr; ++i) {\\n            perm[i] = i;\\n        }\\n        int64_t ret = attempt(robot, factory, perm);\\n\\n        reverse(perm.begin(), perm.end());\\n        ret = min(ret, attempt(robot, factory, perm));\\n\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783899,
                "title": "python3-top-down-memoization",
                "content": "1. To reduce the total distance, first sort robot and factory.\\n2. Use dp to figure out the minimum distance. dp(i, j) represents the minimum distance to assign the first i robots to the first j factories in the left. \\n\\n           dp(i, j) = min(dp(i-k, j-1) + distance_increased) for k in range(0, min(limit_(j-1), i) + 1)\\n\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        @cache\\n        def dp(i, j):\\n            if i == 0:\\n                return 0\\n            if j == 1:\\n                if i > factory[j-1][1]:\\n                    return inf\\n                return sum(abs(robot[k] - factory[j-1][0]) for k in range(i))\\n            \\n            d = 0\\n            res = dp(i, j -1)\\n            for k in range(1, 1+min(factory[j-1][1], i)):\\n                d += abs(robot[i-k] - factory[j-1][0])\\n                res = min(res, d + dp(i-k, j-1))\\n            return res\\n        \\n        # Filter out factories with limit = 0.\\n        factory = [[p, l] for p, l in factory if l>0]\\n        m, n = len(robot), len(factory)\\n        robot.sort()\\n        factory.sort()\\n        return dp(m, n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        @cache\\n        def dp(i, j):\\n            if i == 0:\\n                return 0\\n            if j == 1:\\n                if i > factory[j-1][1]:\\n                    return inf\\n                return sum(abs(robot[k] - factory[j-1][0]) for k in range(i))\\n            \\n            d = 0\\n            res = dp(i, j -1)\\n            for k in range(1, 1+min(factory[j-1][1], i)):\\n                d += abs(robot[i-k] - factory[j-1][0])\\n                res = min(res, d + dp(i-k, j-1))\\n            return res\\n        \\n        # Filter out factories with limit = 0.\\n        factory = [[p, l] for p, l in factory if l>0]\\n        m, n = len(robot), len(factory)\\n        robot.sort()\\n        factory.sort()\\n        return dp(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783751,
                "title": "java-iterative-greedy-approach-sort-of",
                "content": "I wasn\\'t able to complete this during the contest, but I eventually came up with this non-DP solution. It is a little long but I think it should be pretty easy to follow with comments.\\n\\n```\\nclass Solution {\\n    private List<Integer> robot;\\n    private int[][] factory;\\n    \\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        this.robot = robot;\\n        this.factory = factory;\\n        \\n        long total = 0;\\n        int n = robot.size();\\n        \\n        // distance to factory that repairs each robot\\n        int[] robotToFactory = new int[n];\\n        \\n        // for each robot, make min-heap of distance to each factory,\\n        // stored as array [distanceToFactory, factoryIdx]\\n        List<PriorityQueue<int[]>> distances = new ArrayList<>();\\n        for (int robotIdx = 0; robotIdx < n; robotIdx++) {\\n            PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n            for (int factoryIdx = 0; factoryIdx < factory.length; factoryIdx++) {\\n                heap.offer(new int[] { dist(robotIdx, factoryIdx), factoryIdx });\\n            }\\n            distances.add(heap);\\n        }\\n        \\n        // for each factory, keep a set of which robots each factory will repair\\n        List<Set<Integer>> factoryToRobots = new ArrayList<>();\\n        for (int i = 0; i < factory.length; i++) {\\n            factoryToRobots.add(new HashSet<>());\\n        }\\n        \\n        // greedily assign each robot to its closest factory\\n        for (int robotIdx = 0; robotIdx < n; robotIdx++) {\\n            int[] entry = distances.get(robotIdx).poll();\\n            total += entry[0];\\n            robotToFactory[robotIdx] = entry[0];\\n            factoryToRobots.get(entry[1]).add(robotIdx);\\n        }\\n        \\n        // as long as there are factories that are assigned too many robots,\\n        // we must reassign some robots to other factories\\n        Set<Integer> factoriesOverLimit = getFactoriesOverLimit(factoryToRobots);\\n        \\n        while (!factoriesOverLimit.isEmpty()) {\\n            // for each factory, find a robot to reassign to a different\\n            // factory which causes the smallest increase in total distance\\n            for (int factoryIdx : factoriesOverLimit) {\\n                int minDistIncrease = Integer.MAX_VALUE;\\n                int reassignRobotIdx = -1;\\n                \\n                for (int robotIdx : factoryToRobots.get(factoryIdx)) {\\n                    // calculate distance increase caused by moving to next closest factory\\n                    int distIncrease = distances.get(robotIdx).peek()[0] - robotToFactory[robotIdx];\\n                    if (distIncrease < minDistIncrease) {\\n                        minDistIncrease = distIncrease;\\n                        reassignRobotIdx = robotIdx;\\n                    }\\n                }\\n                \\n                // now reassign the chosen robot to its next closest factory\\n                int[] entry = distances.get(reassignRobotIdx).poll();\\n                total += minDistIncrease;\\n                robotToFactory[reassignRobotIdx] = entry[0];\\n                factoryToRobots.get(factoryIdx).remove(reassignRobotIdx);\\n                factoryToRobots.get(entry[1]).add(reassignRobotIdx);\\n            }\\n            \\n            // check if we need to continue\\n            factoriesOverLimit = getFactoriesOverLimit(factoryToRobots);\\n        }\\n        \\n        return total;\\n    }\\n    \\n    // return set of all factories with more robots assigned than the factory limit\\n    private Set<Integer> getFactoriesOverLimit(List<Set<Integer>> factoryToRobots) {\\n        Set<Integer> factoriesOverLimit = new HashSet<>();\\n        for (int i = 0; i < factoryToRobots.size(); i++) {\\n            if (factoryToRobots.get(i).size() > factory[i][1]) {\\n                factoriesOverLimit.add(i);\\n            }\\n        }\\n        return factoriesOverLimit;\\n    }\\n    \\n    // return distance between robot and factory\\n    private int dist(int robotIdx, int factoryIdx) {\\n        return Math.abs(robot.get(robotIdx) - factory[factoryIdx][0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    private List<Integer> robot;\\n    private int[][] factory;\\n    \\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        this.robot = robot;\\n        this.factory = factory;\\n        \\n        long total = 0;\\n        int n = robot.size();\\n        \\n        // distance to factory that repairs each robot\\n        int[] robotToFactory = new int[n];\\n        \\n        // for each robot, make min-heap of distance to each factory,\\n        // stored as array [distanceToFactory, factoryIdx]\\n        List<PriorityQueue<int[]>> distances = new ArrayList<>();\\n        for (int robotIdx = 0; robotIdx < n; robotIdx++) {\\n            PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n            for (int factoryIdx = 0; factoryIdx < factory.length; factoryIdx++) {\\n                heap.offer(new int[] { dist(robotIdx, factoryIdx), factoryIdx });\\n            }\\n            distances.add(heap);\\n        }\\n        \\n        // for each factory, keep a set of which robots each factory will repair\\n        List<Set<Integer>> factoryToRobots = new ArrayList<>();\\n        for (int i = 0; i < factory.length; i++) {\\n            factoryToRobots.add(new HashSet<>());\\n        }\\n        \\n        // greedily assign each robot to its closest factory\\n        for (int robotIdx = 0; robotIdx < n; robotIdx++) {\\n            int[] entry = distances.get(robotIdx).poll();\\n            total += entry[0];\\n            robotToFactory[robotIdx] = entry[0];\\n            factoryToRobots.get(entry[1]).add(robotIdx);\\n        }\\n        \\n        // as long as there are factories that are assigned too many robots,\\n        // we must reassign some robots to other factories\\n        Set<Integer> factoriesOverLimit = getFactoriesOverLimit(factoryToRobots);\\n        \\n        while (!factoriesOverLimit.isEmpty()) {\\n            // for each factory, find a robot to reassign to a different\\n            // factory which causes the smallest increase in total distance\\n            for (int factoryIdx : factoriesOverLimit) {\\n                int minDistIncrease = Integer.MAX_VALUE;\\n                int reassignRobotIdx = -1;\\n                \\n                for (int robotIdx : factoryToRobots.get(factoryIdx)) {\\n                    // calculate distance increase caused by moving to next closest factory\\n                    int distIncrease = distances.get(robotIdx).peek()[0] - robotToFactory[robotIdx];\\n                    if (distIncrease < minDistIncrease) {\\n                        minDistIncrease = distIncrease;\\n                        reassignRobotIdx = robotIdx;\\n                    }\\n                }\\n                \\n                // now reassign the chosen robot to its next closest factory\\n                int[] entry = distances.get(reassignRobotIdx).poll();\\n                total += minDistIncrease;\\n                robotToFactory[reassignRobotIdx] = entry[0];\\n                factoryToRobots.get(factoryIdx).remove(reassignRobotIdx);\\n                factoryToRobots.get(entry[1]).add(reassignRobotIdx);\\n            }\\n            \\n            // check if we need to continue\\n            factoriesOverLimit = getFactoriesOverLimit(factoryToRobots);\\n        }\\n        \\n        return total;\\n    }\\n    \\n    // return set of all factories with more robots assigned than the factory limit\\n    private Set<Integer> getFactoriesOverLimit(List<Set<Integer>> factoryToRobots) {\\n        Set<Integer> factoriesOverLimit = new HashSet<>();\\n        for (int i = 0; i < factoryToRobots.size(); i++) {\\n            if (factoryToRobots.get(i).size() > factory[i][1]) {\\n                factoriesOverLimit.add(i);\\n            }\\n        }\\n        return factoriesOverLimit;\\n    }\\n    \\n    // return distance between robot and factory\\n    private int dist(int robotIdx, int factoryIdx) {\\n        return Math.abs(robot.get(robotIdx) - factory[factoryIdx][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783722,
                "title": "javascript-mcmf-542ms",
                "content": "```\\n//////////////////////////////// Template //////////////////////////////\\nfunction edge(from, to, cost, cap) {\\n    this.from = from;\\n    this.to = to;\\n    this.cost = cost;\\n    this.cap = cap;\\n}\\n\\nfunction MCMF(n) {\\n    const initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\n    let g = initializeGraph(n), h = Array(n).fill(0), dis = Array(n).fill(0), prev_v = Array(n).fill(0), prev_e = Array(n).fill(0);\\n    return { addEdge, minCostFlow }\\n    function addEdge(from, to, cost, cap) {\\n        g[from].push(new edge(g[to].length, to, cost, cap));\\n        g[to].push(new edge(g[from].length - 1, from, -cost, 0));\\n    }\\n    function minCostFlow(from, to, flow) {\\n        let res = 0;\\n        while (flow > 0) {\\n            let pq = new MinPriorityQueue({\\n                compare: (x, y) => {\\n                    if (x[0] != y[0]) return x[0] - y[0];\\n                    return x[1] - y[1];\\n                }\\n            });\\n            dis.fill(Number.MAX_SAFE_INTEGER);\\n            dis[from] = 0;\\n            pq.enqueue([0, from]);\\n            while (pq.size()) {\\n                let [curDis, cur] = pq.dequeue();\\n                if (dis[cur] < curDis) continue;\\n                for (let i = 0; i < g[cur].length; i++) {\\n                    let child = g[cur][i];\\n                    if (child.cap > 0 && dis[child.to] > dis[cur] + child.cost + h[cur] - h[child.to]) {\\n                        dis[child.to] = dis[cur] + child.cost + h[cur] - h[child.to];\\n                        prev_v[child.to] = cur;\\n                        prev_e[child.to] = i;\\n                        pq.enqueue([dis[child.to], child.to]);\\n                    }\\n                }\\n            }\\n            if (dis[to] == Number.MAX_SAFE_INTEGER) return -1;\\n            for (let i = 0; i < n; i++) h[i] += dis[i];\\n            let d = flow;\\n            for (let i = to; i != from; i = prev_v[i]) {\\n                d = Math.min(d, g[prev_v[i]][prev_e[i]].cap);\\n            }\\n            flow -= d;\\n            res += d * h[to];\\n            for (let i = to; i != from; i = prev_v[i]) {\\n                let edge = g[prev_v[i]][prev_e[i]];\\n                edge.cap -= d;\\n                g[i][edge.from].cap += d;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////////\\n\\nconst minimumTotalDistance = (a, b) => {\\n    let n = a.length, m = b.length, mcmf = new MCMF(n + m + 2), from = n + m, to = from + 1;\\n    for (let i = 0; i < n; i++) mcmf.addEdge(from, i, 0, 1);\\n    for (let i = 0; i < m; i++) mcmf.addEdge(n + i, to, 0, b[i][1]);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            mcmf.addEdge(i, n + j, Math.abs(a[i] - b[j][0]), 1);\\n        }\\n    }\\n    return mcmf.minCostFlow(from, to, n);\\n};\\n```\\nsimilar problem:\\nhttps://leetcode.com/problems/maximum-and-sum-of-array/\\nmy solution:\\nhttps://leetcode.com/problems/maximum-and-sum-of-array/solutions/1767417/javascript-graph-MCMF-186ms/",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//////////////////////////////// Template //////////////////////////////\\nfunction edge(from, to, cost, cap) {\\n    this.from = from;\\n    this.to = to;\\n    this.cost = cost;\\n    this.cap = cap;\\n}\\n\\nfunction MCMF(n) {\\n    const initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\n    let g = initializeGraph(n), h = Array(n).fill(0), dis = Array(n).fill(0), prev_v = Array(n).fill(0), prev_e = Array(n).fill(0);\\n    return { addEdge, minCostFlow }\\n    function addEdge(from, to, cost, cap) {\\n        g[from].push(new edge(g[to].length, to, cost, cap));\\n        g[to].push(new edge(g[from].length - 1, from, -cost, 0));\\n    }\\n    function minCostFlow(from, to, flow) {\\n        let res = 0;\\n        while (flow > 0) {\\n            let pq = new MinPriorityQueue({\\n                compare: (x, y) => {\\n                    if (x[0] != y[0]) return x[0] - y[0];\\n                    return x[1] - y[1];\\n                }\\n            });\\n            dis.fill(Number.MAX_SAFE_INTEGER);\\n            dis[from] = 0;\\n            pq.enqueue([0, from]);\\n            while (pq.size()) {\\n                let [curDis, cur] = pq.dequeue();\\n                if (dis[cur] < curDis) continue;\\n                for (let i = 0; i < g[cur].length; i++) {\\n                    let child = g[cur][i];\\n                    if (child.cap > 0 && dis[child.to] > dis[cur] + child.cost + h[cur] - h[child.to]) {\\n                        dis[child.to] = dis[cur] + child.cost + h[cur] - h[child.to];\\n                        prev_v[child.to] = cur;\\n                        prev_e[child.to] = i;\\n                        pq.enqueue([dis[child.to], child.to]);\\n                    }\\n                }\\n            }\\n            if (dis[to] == Number.MAX_SAFE_INTEGER) return -1;\\n            for (let i = 0; i < n; i++) h[i] += dis[i];\\n            let d = flow;\\n            for (let i = to; i != from; i = prev_v[i]) {\\n                d = Math.min(d, g[prev_v[i]][prev_e[i]].cap);\\n            }\\n            flow -= d;\\n            res += d * h[to];\\n            for (let i = to; i != from; i = prev_v[i]) {\\n                let edge = g[prev_v[i]][prev_e[i]];\\n                edge.cap -= d;\\n                g[i][edge.from].cap += d;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////////\\n\\nconst minimumTotalDistance = (a, b) => {\\n    let n = a.length, m = b.length, mcmf = new MCMF(n + m + 2), from = n + m, to = from + 1;\\n    for (let i = 0; i < n; i++) mcmf.addEdge(from, i, 0, 1);\\n    for (let i = 0; i < m; i++) mcmf.addEdge(n + i, to, 0, b[i][1]);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            mcmf.addEdge(i, n + j, Math.abs(a[i] - b[j][0]), 1);\\n        }\\n    }\\n    return mcmf.minCostFlow(from, to, n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783714,
                "title": "easy-dp-solution-java",
                "content": "# Intuition\\ntry to check minimum distance of first i robots and j factories\\n\\n# Approach\\nDp\\n\\n# Complexity\\n- Time complexity:\\n- O(n3)\\n\\n- Space complexity:\\nO(n2)\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n\\n        Collections.sort(robot);\\n        Arrays.sort(factory,new Comparator<>(){\\n            @Override\\n            public int compare(int[]a,int[]b){\\n                return a[0]-b[0];\\n            }\\n        });\\n\\n        int n = robot.size();\\n        int m = factory.length;\\n\\n\\n        long[][] dp = new long[n][m];\\n\\n        return solve(0,0,robot,factory,n,m,dp);\\n\\n    }\\n\\n    public long solve(int i,int j,List<Integer> robot,int[][]factory,int n,int m,long[][]dp) {\\n\\n        if (i == n) {\\n            return 0;\\n        }\\n\\n        if (j == m) {\\n            return Long.MAX_VALUE;\\n        }\\n        if(dp[i][j]!=0){\\n            return dp[i][j];\\n        }\\n\\n\\n        long ans = solve(i, j + 1, robot, factory, n, m, dp);\\n\\n        long sum = 0;\\n        int count = 0;\\n        for (int k = i; k < n; k++) {\\n            int p = Math.abs(robot.get(k) - factory[j][0]);\\n            if (count < factory[j][1]) {\\n                long l = solve(k + 1, j + 1, robot, factory, n, m, dp);\\n                if(l!=Long.MAX_VALUE) {\\n                  l +=  sum + p;\\n                }\\n                ans = Math.min(ans, l);\\n                count++;\\n                sum += p;\\n            } else {\\n                break;\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n\\n        Collections.sort(robot);\\n        Arrays.sort(factory,new Comparator<>(){\\n            @Override\\n            public int compare(int[]a,int[]b){\\n                return a[0]-b[0];\\n            }\\n        });\\n\\n        int n = robot.size();\\n        int m = factory.length;\\n\\n\\n        long[][] dp = new long[n][m];\\n\\n        return solve(0,0,robot,factory,n,m,dp);\\n\\n    }\\n\\n    public long solve(int i,int j,List<Integer> robot,int[][]factory,int n,int m,long[][]dp) {\\n\\n        if (i == n) {\\n            return 0;\\n        }\\n\\n        if (j == m) {\\n            return Long.MAX_VALUE;\\n        }\\n        if(dp[i][j]!=0){\\n            return dp[i][j];\\n        }\\n\\n\\n        long ans = solve(i, j + 1, robot, factory, n, m, dp);\\n\\n        long sum = 0;\\n        int count = 0;\\n        for (int k = i; k < n; k++) {\\n            int p = Math.abs(robot.get(k) - factory[j][0]);\\n            if (count < factory[j][1]) {\\n                long l = solve(k + 1, j + 1, robot, factory, n, m, dp);\\n                if(l!=Long.MAX_VALUE) {\\n                  l +=  sum + p;\\n                }\\n                ans = Math.min(ans, l);\\n                count++;\\n                sum += p;\\n            } else {\\n                break;\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783682,
                "title": "o-n-3-using-hungarian-algorithm",
                "content": "**Main Idea**:\\n+ Building factory1 where every factory[i] = (pos[i], limit[i]) in factory converting to limit[i] elements with value pos[i]\\n+ Building cost matrix where cost[i][j] = abs(robot[i] - factory1[j])\\n+ Applying Hungarian for finding the pairs of (robot, factory) achieving the minimum cost.\\n\\n**Code**:\\n+ Python\\n```python\\nfrom scipy.optimize import linear_sum_assignment\\nimport numpy as np\\n\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        cost = []\\n        for i in range(len(robot)):\\n            costi = []\\n            for j in range(len(factory)):\\n                for k in range(factory[j][1]):\\n                    costi.append(abs(robot[i] - factory[j][0]))\\n            cost.append(costi)\\n        cost = np.array(cost)\\n        row_idx, col_idx = linear_sum_assignment(cost)\\n        ans = sum([cost[row_idx[i]][col_idx[i]] for i in range(len(row_idx))])\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom scipy.optimize import linear_sum_assignment\\nimport numpy as np\\n\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        cost = []\\n        for i in range(len(robot)):\\n            costi = []\\n            for j in range(len(factory)):\\n                for k in range(factory[j][1]):\\n                    costi.append(abs(robot[i] - factory[j][0]))\\n            cost.append(costi)\\n        cost = np.array(cost)\\n        row_idx, col_idx = linear_sum_assignment(cost)\\n        ans = sum([cost[row_idx[i]][col_idx[i]] for i in range(len(row_idx))])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783549,
                "title": "python3-o-n-3-dp-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        m, n = len(robot), len(factory)\\n        \\n        @lru_cache(None)\\n        def dp(i, j, k):\\n            if i >= m:  # all robots fixed\\n                return 0\\n            if j >= n:  # not all robots get fixed but run out of factories.\\n                return math.inf\\n            if k <= 0:  # the factory uses up repair limit\\n                if j + 1 < n: # use next factory if it\\'s valid\\n                    return dp(i, j + 1, factory[j + 1][1])\\n                else: # no more factory to use, return inf\\n                    return math.inf\\n            dist = abs(robot[i] - factory[j][0]) # cost to use current factory\\n            # Use current factory or skip it\\n            return min(dist + dp(i + 1, j, k - 1), dp(i, j, -1))\\n        \\n        return dp(0, 0, factory[0][1])\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        robot.sort()\\n        factory.sort()\\n        m, n = len(robot), len(factory)\\n        \\n        @lru_cache(None)\\n        def dp(i, j, k):\\n            if i >= m:  # all robots fixed\\n                return 0\\n            if j >= n:  # not all robots get fixed but run out of factories.\\n                return math.inf\\n            if k <= 0:  # the factory uses up repair limit\\n                if j + 1 < n: # use next factory if it\\'s valid\\n                    return dp(i, j + 1, factory[j + 1][1])\\n                else: # no more factory to use, return inf\\n                    return math.inf\\n            dist = abs(robot[i] - factory[j][0]) # cost to use current factory\\n            # Use current factory or skip it\\n            return min(dist + dp(i + 1, j, k - 1), dp(i, j, -1))\\n        \\n        return dp(0, 0, factory[0][1])\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783547,
                "title": "dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n       \\n      vector<int> costs;\\n        sort(factory.begin(),factory.end());\\n        for(auto it: factory){\\n            for (int i=0;i<it[1];i++) {\\n                costs.push_back(it[0]);\\n            }\\n        }\\n        sort(robot.begin(),robot.end());\\n        int n=robot.size();\\n        int m=costs.size();\\n        vector<vector<long long>> dp(n+1,vector<long long>(m+1,1e18));\\n         dp[0][0]=0;     \\n        for(int i=0;i<m;i++) dp[0][i]=0;\\n        \\n        // dp[i][j] is minimum distance cover by i robot for repairing within j factorys\\n        \\n        for(int bot=1;bot<=n;bot++){\\n            for(int station=1;station<=m;station++){\\n                long long currCost=abs(robot[bot-1]-costs[station-1])+dp[bot-1][station-1];\\n                dp[bot][station]=min(dp[bot][station-1],currCost);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n       \\n      vector<int> costs;\\n        sort(factory.begin(),factory.end());\\n        for(auto it: factory){\\n            for (int i=0;i<it[1];i++) {\\n                costs.push_back(it[0]);\\n            }\\n        }\\n        sort(robot.begin(),robot.end());\\n        int n=robot.size();\\n        int m=costs.size();\\n        vector<vector<long long>> dp(n+1,vector<long long>(m+1,1e18));\\n         dp[0][0]=0;     \\n        for(int i=0;i<m;i++) dp[0][i]=0;\\n        \\n        // dp[i][j] is minimum distance cover by i robot for repairing within j factorys\\n        \\n        for(int bot=1;bot<=n;bot++){\\n            for(int station=1;station<=m;station++){\\n                long long currCost=abs(robot[bot-1]-costs[station-1])+dp[bot-1][station-1];\\n                dp[bot][station]=min(dp[bot][station-1],currCost);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783490,
                "title": "python-dp-solution-with-explanation",
                "content": "\\n# Approach\\nlet opt[i][j] be the minimum cost of first i robots and first j stations\\n\\ndp formula:\\nfor each station, it can fix 0 - it\\'s limit robots\\nso opt[i][j] = min(opt[i-x][j-1] + cost to repair the last x robots) for x from 0 - limits\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n\\n        m = len(robot)\\n        n = len(factory)\\n\\n        factory.sort()\\n        robot.sort()\\n\\n        opt = [[float(\\'inf\\') for j in range(n + 1)] for i in range(m + 1)]\\n\\n        for j in range(n + 1):\\n            opt[0][j] = 0\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                cur = 0\\n                for x in range(min(factory[j - 1][1], i) + 1):\\n                    opt[i][j] = min(opt[i][j], opt[i-x][j-1] + cur)\\n                    cur += abs(factory[j-1][0] - robot[i-1-x])\\n\\n        return opt[-1][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n\\n        m = len(robot)\\n        n = len(factory)\\n\\n        factory.sort()\\n        robot.sort()\\n\\n        opt = [[float(\\'inf\\') for j in range(n + 1)] for i in range(m + 1)]\\n\\n        for j in range(n + 1):\\n            opt[0][j] = 0\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                cur = 0\\n                for x in range(min(factory[j - 1][1], i) + 1):\\n                    opt[i][j] = min(opt[i][j], opt[i-x][j-1] + cur)\\n                    cur += abs(factory[j-1][0] - robot[i-1-x])\\n\\n        return opt[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783462,
                "title": "solving-assignment-problem-using-min-cost-flow",
                "content": "(i didnot solve this in the contest..)\\nhttps://cp-algorithms.com/graph/Assignment-problem-min-flow.html",
                "solutionTags": [],
                "code": "(i didnot solve this in the contest..)\\nhttps://cp-algorithms.com/graph/Assignment-problem-min-flow.html",
                "codeTag": "Unknown"
            },
            {
                "id": 2783442,
                "title": "c-dfs-memo",
                "content": "```\\nusing ll = long long;\\nconst int N = 105;\\nconst ll INF = 1000000000000000ll;\\nll dp[N][N];\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& a, vector<vector<int>>& b) {\\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        int n = a.size(), m = b.size();\\n        for(int i = 0; i <= n; i++) {\\n            for(int j = 0; j <= m; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        ll res = dfs(a, b, 0, 0);\\n        return res;\\n    }\\n    \\n    ll dfs(vector<int>& a, vector<vector<int>>& b, int i, int j) {\\n        if(i >= a.size()) {\\n            return 0;\\n        }\\n        \\n        if(j >= b.size()) {\\n            return INF;\\n        }\\n        \\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        vector<int>& fa = b[j];\\n        int p = fa[0], lim = fa[1];\\n        int cnt = 0;\\n        ll sum = 0;\\n        ll res = INF;\\n        \\n        res = min(res, dfs(a, b, i, j + 1));\\n        for(int idx = i; idx < a.size(); idx++) {\\n            cnt ++;\\n            if(cnt > lim) break;\\n            sum += abs(a[idx] - p);\\n            res = min(res, sum + dfs(a, b, idx + 1, j + 1));\\n        }\\n\\n        return dp[i][j] = res;\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll = long long;\\nconst int N = 105;\\nconst ll INF = 1000000000000000ll;\\nll dp[N][N];\\nclass Solution {\\npublic:\\n    long long minimumTotalDistance(vector<int>& a, vector<vector<int>>& b) {\\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        int n = a.size(), m = b.size();\\n        for(int i = 0; i <= n; i++) {\\n            for(int j = 0; j <= m; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        ll res = dfs(a, b, 0, 0);\\n        return res;\\n    }\\n    \\n    ll dfs(vector<int>& a, vector<vector<int>>& b, int i, int j) {\\n        if(i >= a.size()) {\\n            return 0;\\n        }\\n        \\n        if(j >= b.size()) {\\n            return INF;\\n        }\\n        \\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        vector<int>& fa = b[j];\\n        int p = fa[0], lim = fa[1];\\n        int cnt = 0;\\n        ll sum = 0;\\n        ll res = INF;\\n        \\n        res = min(res, dfs(a, b, i, j + 1));\\n        for(int idx = i; idx < a.size(); idx++) {\\n            cnt ++;\\n            if(cnt > lim) break;\\n            sum += abs(a[idx] - p);\\n            res = min(res, sum + dfs(a, b, idx + 1, j + 1));\\n        }\\n\\n        return dp[i][j] = res;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783412,
                "title": "mincostflow",
                "content": "# Intuition\\nCast it as a network flow problem. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    using integer = long long;    \\n    \\n    struct Edge {\\n        integer from, to, capacity;\\n        integer cost;\\n    };\\n\\n    // https://cp-algorithms.com/graph/min_cost_flow.html\\n    class MinCostFlow {\\n        std::vector<std::vector<integer>> adj, capacity;\\n        std::vector<std::vector<integer>> cost;\\n\\n        static constexpr integer INF = 1E14 + 7;    \\n\\n        void shortest_paths(integer n, integer v0, vector<integer>& d, vector<integer>& p) {\\n            d.assign(n, INF);\\n            d[v0] = 0;\\n            vector<bool> inq(n, false);\\n            queue<integer> q;\\n            q.push(v0);\\n            p.assign(n, -1);\\n\\n            while (!q.empty()) {\\n                const integer u = q.front();\\n                q.pop();\\n                inq[u] = false;\\n                for (const integer v : adj[u]) {\\n                    if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\\n                        d[v] = d[u] + cost[u][v];\\n                        p[v] = u;\\n                        if (!inq[v]) {\\n                            inq[v] = true;\\n                            q.push(v);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n    public:\\n        integer min_cost_flow(integer N, vector<Edge> edges, integer K, integer s, integer t) {\\n            adj.assign(N, vector<integer>());\\n            cost.assign(N, vector<integer>(N, 0));\\n            capacity.assign(N, vector<integer>(N, 0));\\n            for (Edge e : edges) {\\n                adj[e.from].push_back(e.to);\\n                adj[e.to].push_back(e.from);\\n                cost[e.from][e.to] = e.cost;\\n                cost[e.to][e.from] = -e.cost;\\n                capacity[e.from][e.to] = e.capacity;\\n            }\\n\\n            integer flow = 0;\\n            integer cost = 0;\\n            vector<integer> d, p;\\n            while (flow < K) {\\n                shortest_paths(N, s, d, p);\\n                if (d[t] == INF) {\\n                    break;\\n                }\\n\\n                // find max flow on that path\\n                integer f = K - flow;\\n                integer cur = t;\\n                while (cur != s) {\\n                    f = std::min(f, capacity[p[cur]][cur]);\\n                    cur = p[cur];\\n                }\\n\\n                // apply flow\\n                flow += f;\\n                cost += f * d[t];\\n                cur = t;\\n                while (cur != s) {\\n                    capacity[p[cur]][cur] -= f;\\n                    capacity[cur][p[cur]] += f;\\n                    cur = p[cur];\\n                }\\n            }\\n\\n            return (flow < K) ? -1 : cost;\\n        }\\n    };\\n    \\npublic:\\n    integer minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {                \\n        std::vector<Edge> edges;\\n        const int num_vertex = 1 + robot.size() + factory.size() + 1;\\n        const int robot_idx_shift = 1;\\n        const int factory_idx_shift = 1 + robot.size();\\n        const int sink_idx = 1 + robot.size() + factory.size();\\n        const int source_flow = robot.size();\\n        \\n        for (int i = 0; i < robot.size(); ++i) {\\n            edges.push_back(Edge {\\n                .from = 0,\\n                .to = robot_idx_shift + i,\\n                .capacity = 1,\\n                .cost = 0\\n            });\\n        }\\n        \\n        // Configure robot -> factory mapping, adding costs.\\n        for (int i = 0; i < robot.size(); ++i) {\\n            for (int j = 0; j < factory.size(); ++j) {\\n                edges.push_back(Edge {\\n                    .from = robot_idx_shift + i,\\n                    .to = factory_idx_shift + j,\\n                    .capacity = 1,\\n                    .cost = std::abs(robot[i] - factory[j][0])\\n                });\\n            }\\n        }\\n        \\n        // Assign factory capacity in factory -> sink mapping.\\n        for (int j = 0; j < factory.size(); ++j) {\\n            edges.push_back(Edge {\\n                .from = factory_idx_shift + j,\\n                .to = sink_idx,\\n                .capacity = factory[j][1],\\n                .cost = 0\\n            });\\n        }\\n                \\n        return MinCostFlow().min_cost_flow(num_vertex, edges, source_flow, 0, sink_idx);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using integer = long long;    \\n    \\n    struct Edge {\\n        integer from, to, capacity;\\n        integer cost;\\n    };\\n\\n    // https://cp-algorithms.com/graph/min_cost_flow.html\\n    class MinCostFlow {\\n        std::vector<std::vector<integer>> adj, capacity;\\n        std::vector<std::vector<integer>> cost;\\n\\n        static constexpr integer INF = 1E14 + 7;    \\n\\n        void shortest_paths(integer n, integer v0, vector<integer>& d, vector<integer>& p) {\\n            d.assign(n, INF);\\n            d[v0] = 0;\\n            vector<bool> inq(n, false);\\n            queue<integer> q;\\n            q.push(v0);\\n            p.assign(n, -1);\\n\\n            while (!q.empty()) {\\n                const integer u = q.front();\\n                q.pop();\\n                inq[u] = false;\\n                for (const integer v : adj[u]) {\\n                    if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\\n                        d[v] = d[u] + cost[u][v];\\n                        p[v] = u;\\n                        if (!inq[v]) {\\n                            inq[v] = true;\\n                            q.push(v);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n    public:\\n        integer min_cost_flow(integer N, vector<Edge> edges, integer K, integer s, integer t) {\\n            adj.assign(N, vector<integer>());\\n            cost.assign(N, vector<integer>(N, 0));\\n            capacity.assign(N, vector<integer>(N, 0));\\n            for (Edge e : edges) {\\n                adj[e.from].push_back(e.to);\\n                adj[e.to].push_back(e.from);\\n                cost[e.from][e.to] = e.cost;\\n                cost[e.to][e.from] = -e.cost;\\n                capacity[e.from][e.to] = e.capacity;\\n            }\\n\\n            integer flow = 0;\\n            integer cost = 0;\\n            vector<integer> d, p;\\n            while (flow < K) {\\n                shortest_paths(N, s, d, p);\\n                if (d[t] == INF) {\\n                    break;\\n                }\\n\\n                // find max flow on that path\\n                integer f = K - flow;\\n                integer cur = t;\\n                while (cur != s) {\\n                    f = std::min(f, capacity[p[cur]][cur]);\\n                    cur = p[cur];\\n                }\\n\\n                // apply flow\\n                flow += f;\\n                cost += f * d[t];\\n                cur = t;\\n                while (cur != s) {\\n                    capacity[p[cur]][cur] -= f;\\n                    capacity[cur][p[cur]] += f;\\n                    cur = p[cur];\\n                }\\n            }\\n\\n            return (flow < K) ? -1 : cost;\\n        }\\n    };\\n    \\npublic:\\n    integer minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {                \\n        std::vector<Edge> edges;\\n        const int num_vertex = 1 + robot.size() + factory.size() + 1;\\n        const int robot_idx_shift = 1;\\n        const int factory_idx_shift = 1 + robot.size();\\n        const int sink_idx = 1 + robot.size() + factory.size();\\n        const int source_flow = robot.size();\\n        \\n        for (int i = 0; i < robot.size(); ++i) {\\n            edges.push_back(Edge {\\n                .from = 0,\\n                .to = robot_idx_shift + i,\\n                .capacity = 1,\\n                .cost = 0\\n            });\\n        }\\n        \\n        // Configure robot -> factory mapping, adding costs.\\n        for (int i = 0; i < robot.size(); ++i) {\\n            for (int j = 0; j < factory.size(); ++j) {\\n                edges.push_back(Edge {\\n                    .from = robot_idx_shift + i,\\n                    .to = factory_idx_shift + j,\\n                    .capacity = 1,\\n                    .cost = std::abs(robot[i] - factory[j][0])\\n                });\\n            }\\n        }\\n        \\n        // Assign factory capacity in factory -> sink mapping.\\n        for (int j = 0; j < factory.size(); ++j) {\\n            edges.push_back(Edge {\\n                .from = factory_idx_shift + j,\\n                .to = sink_idx,\\n                .capacity = factory[j][1],\\n                .cost = 0\\n            });\\n        }\\n                \\n        return MinCostFlow().min_cost_flow(num_vertex, edges, source_flow, 0, sink_idx);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783331,
                "title": "codeforce-797f",
                "content": "from : https://codeforces.com/problemset/problem/797/F",
                "solutionTags": [],
                "code": "from : https://codeforces.com/problemset/problem/797/F",
                "codeTag": "Unknown"
            },
            {
                "id": 2783320,
                "title": "python3-with-dp",
                "content": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def helper(i, j, k):\\n            if i == n: return 0\\n            if j == m: return float(\\'inf\\')\\n            if k == 0:\\n                dp[i][j][k] = helper(i , j+1 , factory[j+1][1] if j+1 < m else 0)\\n            else:\\n                dp[i][j][k] = min(helper(i , j+1 , factory[j+1][1] if j+1 < m else 0) , helper(i+1 , j , k-1) + abs(robot[i] - factory[j][0]))\\n            return dp[i][j][k] \\n        n = len(robot)\\n        m = len(factory)\\n        dp = [[[-1 for _ in range(n+1)] for _ in range(m+1)] for _ in range(n+1)]\\n        robot.sort()\\n        factory.sort()\\n        return helper(0, 0, factory[0][1])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def helper(i, j, k):\\n            if i == n: return 0\\n            if j == m: return float(\\'inf\\')\\n            if k == 0:\\n                dp[i][j][k] = helper(i , j+1 , factory[j+1][1] if j+1 < m else 0)\\n            else:\\n                dp[i][j][k] = min(helper(i , j+1 , factory[j+1][1] if j+1 < m else 0) , helper(i+1 , j , k-1) + abs(robot[i] - factory[j][0]))\\n            return dp[i][j][k] \\n        n = len(robot)\\n        m = len(factory)\\n        dp = [[[-1 for _ in range(n+1)] for _ in range(m+1)] for _ in range(n+1)]\\n        robot.sort()\\n        factory.sort()\\n        return helper(0, 0, factory[0][1])",
                "codeTag": "Java"
            },
            {
                "id": 2783306,
                "title": "dp-memoization-recur-c-commented",
                "content": "```\\n#define ll long long\\nclass Solution {\\n    vector<vector<ll>> dp;\\n    //IN ONE ITERATION OF HELP() , WE ASSIGN POSSIBLE ROBOTS TO 1 FACTORY , AND IN NEXT ITERATION WE MOVE TO NEXT FACTORY.\\n\\n    ll help(vector<int>& robot , vector<vector<int>>& fac , int ri , int fi)\\n    {\\n        if(ri >= robot.size()) return (ll)0;    //if all robots are exhausted , return remaining cost = 0;\\n        if(fi >= fac.size()) return LLONG_MAX;  //if factories are exhausted . but robots aren\\'t return LLONG_MAX so that it gets rejected.\\n        \\n        if(dp[ri][fi] != -999) return dp[ri][fi];\\n        \\n            \\n        ll fact_pos = (ll)fac[fi][0];   //current-factory-position\\n        ll fact_lim = (ll)fac[fi][1]; //current-factory-limit\\n        ll minSum = LLONG_MAX;  //minimum sum so far\\n        ll curr_sum = (ll)0; //current sum of distances of the robots that will be assigned to current factory\\n        \\n        \\n        ll a1 = (ll)help(robot , fac , ri , fi+1); //if we skip the current factory.\\n        for(int i = ri ; i < (ri + fact_lim) && i < robot.size() ; i++)\\n        {\\n            ll robot_pos = (ll)robot[i];    //robot-position\\n            curr_sum += (ll)(abs(robot_pos - fact_pos)); //current_distane of robot[i] from the factory under consideration fac[fi]\\n\\n            ll rem_sum = help(robot , fac , i+1 , fi+1); // remaining distances (factory is incremented)\\n            if(rem_sum == LLONG_MAX) continue;\\n            minSum = min(minSum , ((ll)rem_sum+curr_sum));\\n        }\\n        return dp[ri][fi] = (ll)min(minSum , a1);\\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        \\n        for(int i = 0 ; i < 101 ; i++)\\n        {\\n            vector<ll> f(101 , (ll)-999);\\n            dp.push_back(f);\\n        }\\n        sort(robot.begin() , robot.end());\\n        sort(factory.begin() , factory.end());\\n      \\n        return help(robot , factory , 0 , 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\n    vector<vector<ll>> dp;\\n    //IN ONE ITERATION OF HELP() , WE ASSIGN POSSIBLE ROBOTS TO 1 FACTORY , AND IN NEXT ITERATION WE MOVE TO NEXT FACTORY.\\n\\n    ll help(vector<int>& robot , vector<vector<int>>& fac , int ri , int fi)\\n    {\\n        if(ri >= robot.size()) return (ll)0;    //if all robots are exhausted , return remaining cost = 0;\\n        if(fi >= fac.size()) return LLONG_MAX;  //if factories are exhausted . but robots aren\\'t return LLONG_MAX so that it gets rejected.\\n        \\n        if(dp[ri][fi] != -999) return dp[ri][fi];\\n        \\n            \\n        ll fact_pos = (ll)fac[fi][0];   //current-factory-position\\n        ll fact_lim = (ll)fac[fi][1]; //current-factory-limit\\n        ll minSum = LLONG_MAX;  //minimum sum so far\\n        ll curr_sum = (ll)0; //current sum of distances of the robots that will be assigned to current factory\\n        \\n        \\n        ll a1 = (ll)help(robot , fac , ri , fi+1); //if we skip the current factory.\\n        for(int i = ri ; i < (ri + fact_lim) && i < robot.size() ; i++)\\n        {\\n            ll robot_pos = (ll)robot[i];    //robot-position\\n            curr_sum += (ll)(abs(robot_pos - fact_pos)); //current_distane of robot[i] from the factory under consideration fac[fi]\\n\\n            ll rem_sum = help(robot , fac , i+1 , fi+1); // remaining distances (factory is incremented)\\n            if(rem_sum == LLONG_MAX) continue;\\n            minSum = min(minSum , ((ll)rem_sum+curr_sum));\\n        }\\n        return dp[ri][fi] = (ll)min(minSum , a1);\\n    }\\npublic:\\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\\n        \\n        for(int i = 0 ; i < 101 ; i++)\\n        {\\n            vector<ll> f(101 , (ll)-999);\\n            dp.push_back(f);\\n        }\\n        sort(robot.begin() , robot.end());\\n        sort(factory.begin() , factory.end());\\n      \\n        return help(robot , factory , 0 , 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2009668,
                "content": [
                    {
                        "username": "mrprashantkumar",
                        "content": "This TC might be helpful\\n`robot = [9,11,99,101]`\\n`factory = [[10,1],[7,1],[14,1],[100,1],[96,1],[103,1]]`\\n\\nCorrect ans is 6\\n\\n```\\n9 will be repared by 7          +2\\n11 will be repared by 10        +1\\n99 will be repared by 100       +1\\n101 will be repared by 103      +2\\n```"
                    },
                    {
                        "username": "abhimontu",
                        "content": "become robot  in solving !!"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "I want to know where this algorithm fails.\\n\\nTo get the minimum total distance travelled by all the robots....shouldn\\'t it be the sum of the distances of the factories which are the nearest to the particular robot and are capable of repairing them? Like for each robot, we find the factory which is the closest to it and is available for repair and add all of those distances to get the minimum total distance? "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "[@shepherd_a](/shepherd_a)  can u tell me where i am going wrong in this below code \n\n`\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }`\n"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "[@shepherd_a](/shepherd_a) Ah I see thanks"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "If you move one robot to its closest, you might be taking away the opportunity for a different robot which needs it more.\\n\\n\\nAn example:\\n\\n````\\nrobot = [5, 9]\\nfactory = [[1, 1], [6, 1], [16,1]]\\n`````\\n\\nIf you moved robot at 5 to 6 (which is its closest), we would then have to move 9 to 16, for a total cost of 8.\\n\\nIt is more optimal to move 5 to 1 and 9 to 6 for a total cost of 7. "
                    },
                    {
                        "username": "czjnbb",
                        "content": "A silly way to make DP easier:\\n\\nConvert the factory array to position only array, e.g.:\\n\\n [[2,2],[6,2]] ==> [2,2,6,6].\\n"
                    },
                    {
                        "username": "varunsh170502",
                        "content": "Best Dp problem !!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can anyone tell me where this is going wrong\n[@votrubac](/votrubac)\n\n`#define ll long long  int\nclass Solution {\n\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }\n\npublic:\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n        int i , j , rn = robot.size() , fn =factory.size();\n        sort(robot.begin(),robot.end()) ;\n        sort(factory.begin(),factory.end(),bysec) ;\n        for(i=0;i<111;i++) {\n            for(j=0;j<111;j++) {\n                rs[i][j] = -1;\n            }\n        }\n        return func(0,0,robot,factory,rn,fn) ;\n    }\n};`\n\n"
                    }
                ]
            },
            {
                "id": 1753008,
                "content": [
                    {
                        "username": "mrprashantkumar",
                        "content": "This TC might be helpful\\n`robot = [9,11,99,101]`\\n`factory = [[10,1],[7,1],[14,1],[100,1],[96,1],[103,1]]`\\n\\nCorrect ans is 6\\n\\n```\\n9 will be repared by 7          +2\\n11 will be repared by 10        +1\\n99 will be repared by 100       +1\\n101 will be repared by 103      +2\\n```"
                    },
                    {
                        "username": "abhimontu",
                        "content": "become robot  in solving !!"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "I want to know where this algorithm fails.\\n\\nTo get the minimum total distance travelled by all the robots....shouldn\\'t it be the sum of the distances of the factories which are the nearest to the particular robot and are capable of repairing them? Like for each robot, we find the factory which is the closest to it and is available for repair and add all of those distances to get the minimum total distance? "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "[@shepherd_a](/shepherd_a)  can u tell me where i am going wrong in this below code \n\n`\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }`\n"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "[@shepherd_a](/shepherd_a) Ah I see thanks"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "If you move one robot to its closest, you might be taking away the opportunity for a different robot which needs it more.\\n\\n\\nAn example:\\n\\n````\\nrobot = [5, 9]\\nfactory = [[1, 1], [6, 1], [16,1]]\\n`````\\n\\nIf you moved robot at 5 to 6 (which is its closest), we would then have to move 9 to 16, for a total cost of 8.\\n\\nIt is more optimal to move 5 to 1 and 9 to 6 for a total cost of 7. "
                    },
                    {
                        "username": "czjnbb",
                        "content": "A silly way to make DP easier:\\n\\nConvert the factory array to position only array, e.g.:\\n\\n [[2,2],[6,2]] ==> [2,2,6,6].\\n"
                    },
                    {
                        "username": "varunsh170502",
                        "content": "Best Dp problem !!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can anyone tell me where this is going wrong\n[@votrubac](/votrubac)\n\n`#define ll long long  int\nclass Solution {\n\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }\n\npublic:\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n        int i , j , rn = robot.size() , fn =factory.size();\n        sort(robot.begin(),robot.end()) ;\n        sort(factory.begin(),factory.end(),bysec) ;\n        for(i=0;i<111;i++) {\n            for(j=0;j<111;j++) {\n                rs[i][j] = -1;\n            }\n        }\n        return func(0,0,robot,factory,rn,fn) ;\n    }\n};`\n\n"
                    }
                ]
            },
            {
                "id": 1675719,
                "content": [
                    {
                        "username": "mrprashantkumar",
                        "content": "This TC might be helpful\\n`robot = [9,11,99,101]`\\n`factory = [[10,1],[7,1],[14,1],[100,1],[96,1],[103,1]]`\\n\\nCorrect ans is 6\\n\\n```\\n9 will be repared by 7          +2\\n11 will be repared by 10        +1\\n99 will be repared by 100       +1\\n101 will be repared by 103      +2\\n```"
                    },
                    {
                        "username": "abhimontu",
                        "content": "become robot  in solving !!"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "I want to know where this algorithm fails.\\n\\nTo get the minimum total distance travelled by all the robots....shouldn\\'t it be the sum of the distances of the factories which are the nearest to the particular robot and are capable of repairing them? Like for each robot, we find the factory which is the closest to it and is available for repair and add all of those distances to get the minimum total distance? "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "[@shepherd_a](/shepherd_a)  can u tell me where i am going wrong in this below code \n\n`\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }`\n"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "[@shepherd_a](/shepherd_a) Ah I see thanks"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "If you move one robot to its closest, you might be taking away the opportunity for a different robot which needs it more.\\n\\n\\nAn example:\\n\\n````\\nrobot = [5, 9]\\nfactory = [[1, 1], [6, 1], [16,1]]\\n`````\\n\\nIf you moved robot at 5 to 6 (which is its closest), we would then have to move 9 to 16, for a total cost of 8.\\n\\nIt is more optimal to move 5 to 1 and 9 to 6 for a total cost of 7. "
                    },
                    {
                        "username": "czjnbb",
                        "content": "A silly way to make DP easier:\\n\\nConvert the factory array to position only array, e.g.:\\n\\n [[2,2],[6,2]] ==> [2,2,6,6].\\n"
                    },
                    {
                        "username": "varunsh170502",
                        "content": "Best Dp problem !!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can anyone tell me where this is going wrong\n[@votrubac](/votrubac)\n\n`#define ll long long  int\nclass Solution {\n\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }\n\npublic:\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n        int i , j , rn = robot.size() , fn =factory.size();\n        sort(robot.begin(),robot.end()) ;\n        sort(factory.begin(),factory.end(),bysec) ;\n        for(i=0;i<111;i++) {\n            for(j=0;j<111;j++) {\n                rs[i][j] = -1;\n            }\n        }\n        return func(0,0,robot,factory,rn,fn) ;\n    }\n};`\n\n"
                    }
                ]
            },
            {
                "id": 2058841,
                "content": [
                    {
                        "username": "mrprashantkumar",
                        "content": "This TC might be helpful\\n`robot = [9,11,99,101]`\\n`factory = [[10,1],[7,1],[14,1],[100,1],[96,1],[103,1]]`\\n\\nCorrect ans is 6\\n\\n```\\n9 will be repared by 7          +2\\n11 will be repared by 10        +1\\n99 will be repared by 100       +1\\n101 will be repared by 103      +2\\n```"
                    },
                    {
                        "username": "abhimontu",
                        "content": "become robot  in solving !!"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "I want to know where this algorithm fails.\\n\\nTo get the minimum total distance travelled by all the robots....shouldn\\'t it be the sum of the distances of the factories which are the nearest to the particular robot and are capable of repairing them? Like for each robot, we find the factory which is the closest to it and is available for repair and add all of those distances to get the minimum total distance? "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "[@shepherd_a](/shepherd_a)  can u tell me where i am going wrong in this below code \n\n`\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }`\n"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "[@shepherd_a](/shepherd_a) Ah I see thanks"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "If you move one robot to its closest, you might be taking away the opportunity for a different robot which needs it more.\\n\\n\\nAn example:\\n\\n````\\nrobot = [5, 9]\\nfactory = [[1, 1], [6, 1], [16,1]]\\n`````\\n\\nIf you moved robot at 5 to 6 (which is its closest), we would then have to move 9 to 16, for a total cost of 8.\\n\\nIt is more optimal to move 5 to 1 and 9 to 6 for a total cost of 7. "
                    },
                    {
                        "username": "czjnbb",
                        "content": "A silly way to make DP easier:\\n\\nConvert the factory array to position only array, e.g.:\\n\\n [[2,2],[6,2]] ==> [2,2,6,6].\\n"
                    },
                    {
                        "username": "varunsh170502",
                        "content": "Best Dp problem !!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can anyone tell me where this is going wrong\n[@votrubac](/votrubac)\n\n`#define ll long long  int\nclass Solution {\n\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }\n\npublic:\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n        int i , j , rn = robot.size() , fn =factory.size();\n        sort(robot.begin(),robot.end()) ;\n        sort(factory.begin(),factory.end(),bysec) ;\n        for(i=0;i<111;i++) {\n            for(j=0;j<111;j++) {\n                rs[i][j] = -1;\n            }\n        }\n        return func(0,0,robot,factory,rn,fn) ;\n    }\n};`\n\n"
                    }
                ]
            },
            {
                "id": 1678325,
                "content": [
                    {
                        "username": "mrprashantkumar",
                        "content": "This TC might be helpful\\n`robot = [9,11,99,101]`\\n`factory = [[10,1],[7,1],[14,1],[100,1],[96,1],[103,1]]`\\n\\nCorrect ans is 6\\n\\n```\\n9 will be repared by 7          +2\\n11 will be repared by 10        +1\\n99 will be repared by 100       +1\\n101 will be repared by 103      +2\\n```"
                    },
                    {
                        "username": "abhimontu",
                        "content": "become robot  in solving !!"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "I want to know where this algorithm fails.\\n\\nTo get the minimum total distance travelled by all the robots....shouldn\\'t it be the sum of the distances of the factories which are the nearest to the particular robot and are capable of repairing them? Like for each robot, we find the factory which is the closest to it and is available for repair and add all of those distances to get the minimum total distance? "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "[@shepherd_a](/shepherd_a)  can u tell me where i am going wrong in this below code \n\n`\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }`\n"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "[@shepherd_a](/shepherd_a) Ah I see thanks"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "If you move one robot to its closest, you might be taking away the opportunity for a different robot which needs it more.\\n\\n\\nAn example:\\n\\n````\\nrobot = [5, 9]\\nfactory = [[1, 1], [6, 1], [16,1]]\\n`````\\n\\nIf you moved robot at 5 to 6 (which is its closest), we would then have to move 9 to 16, for a total cost of 8.\\n\\nIt is more optimal to move 5 to 1 and 9 to 6 for a total cost of 7. "
                    },
                    {
                        "username": "czjnbb",
                        "content": "A silly way to make DP easier:\\n\\nConvert the factory array to position only array, e.g.:\\n\\n [[2,2],[6,2]] ==> [2,2,6,6].\\n"
                    },
                    {
                        "username": "varunsh170502",
                        "content": "Best Dp problem !!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can anyone tell me where this is going wrong\n[@votrubac](/votrubac)\n\n`#define ll long long  int\nclass Solution {\n\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }\n\npublic:\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n        int i , j , rn = robot.size() , fn =factory.size();\n        sort(robot.begin(),robot.end()) ;\n        sort(factory.begin(),factory.end(),bysec) ;\n        for(i=0;i<111;i++) {\n            for(j=0;j<111;j++) {\n                rs[i][j] = -1;\n            }\n        }\n        return func(0,0,robot,factory,rn,fn) ;\n    }\n};`\n\n"
                    }
                ]
            },
            {
                "id": 1851820,
                "content": [
                    {
                        "username": "mrprashantkumar",
                        "content": "This TC might be helpful\\n`robot = [9,11,99,101]`\\n`factory = [[10,1],[7,1],[14,1],[100,1],[96,1],[103,1]]`\\n\\nCorrect ans is 6\\n\\n```\\n9 will be repared by 7          +2\\n11 will be repared by 10        +1\\n99 will be repared by 100       +1\\n101 will be repared by 103      +2\\n```"
                    },
                    {
                        "username": "abhimontu",
                        "content": "become robot  in solving !!"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "I want to know where this algorithm fails.\\n\\nTo get the minimum total distance travelled by all the robots....shouldn\\'t it be the sum of the distances of the factories which are the nearest to the particular robot and are capable of repairing them? Like for each robot, we find the factory which is the closest to it and is available for repair and add all of those distances to get the minimum total distance? "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "[@shepherd_a](/shepherd_a)  can u tell me where i am going wrong in this below code \n\n`\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }`\n"
                    },
                    {
                        "username": "Subhrodeep_25",
                        "content": "[@shepherd_a](/shepherd_a) Ah I see thanks"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "If you move one robot to its closest, you might be taking away the opportunity for a different robot which needs it more.\\n\\n\\nAn example:\\n\\n````\\nrobot = [5, 9]\\nfactory = [[1, 1], [6, 1], [16,1]]\\n`````\\n\\nIf you moved robot at 5 to 6 (which is its closest), we would then have to move 9 to 16, for a total cost of 8.\\n\\nIt is more optimal to move 5 to 1 and 9 to 6 for a total cost of 7. "
                    },
                    {
                        "username": "czjnbb",
                        "content": "A silly way to make DP easier:\\n\\nConvert the factory array to position only array, e.g.:\\n\\n [[2,2],[6,2]] ==> [2,2,6,6].\\n"
                    },
                    {
                        "username": "varunsh170502",
                        "content": "Best Dp problem !!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can anyone tell me where this is going wrong\n[@votrubac](/votrubac)\n\n`#define ll long long  int\nclass Solution {\n\n    static bool bysec(vector<int> &v1, vector<int> &v2) {\n        return v1[0]<v2[0] ;\n    }\n\n    ll rs[111][111] ;\n\n    ll func(int i , int j , vector<int> &r, vector<vector<int>> &f,int rn , int fn) {\n        if(i==rn) { // reached end of robot queue so 0 distance needed\n            return 0 ;\n        }\n        else if(j==fn) { // no factory left , well in reality factory left before but not give mnm dist\n            return LONG_LONG_MAX ; \n        }\n        else { // in this case we have robot as well as factory so we will choose best choice from rest of factories\n            if(rs[i][j]!=-1) {\n                return rs[i][j] ;\n            }\n            ll dist = LONG_LONG_MAX;\n\n            for(int k=j;k<fn;k++) {\n                if(f[k][1]>0) {\n                    f[k][1] -= 1;\n                    ll temp = abs(f[k][0]-r[i]) ;\n                    if(f[k][1]==0) {\n                        ll ret = func(i+1,k+1,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }\n                    }\n                    else {\n                        ll ret = func(i+1,k,r,f,rn,fn) ;\n                        if(ret!=LONG_LONG_MAX) {\n                            dist = min(ret+temp,dist) ;\n                        }                    \n                    }\n                    f[k][1] += 1;\n                }\n                else {\n                    ll ret = func(i,k+1,r,f,rn,fn) ;\n                    if(ret!=LONG_LONG_MAX) {\n                        dist = min(ret,dist) ;\n                    }\n                }\n            }\n            cout<<i<<\" \"<<j<<\" \"<<dist<<endl;\n            return rs[i][j] = dist ;\n        }\n    }\n\npublic:\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n        int i , j , rn = robot.size() , fn =factory.size();\n        sort(robot.begin(),robot.end()) ;\n        sort(factory.begin(),factory.end(),bysec) ;\n        for(i=0;i<111;i++) {\n            for(j=0;j<111;j++) {\n                rs[i][j] = -1;\n            }\n        }\n        return func(0,0,robot,factory,rn,fn) ;\n    }\n};`\n\n"
                    }
                ]
            }
        ]
    }
]