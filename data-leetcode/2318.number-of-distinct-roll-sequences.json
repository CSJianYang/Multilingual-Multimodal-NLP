[
    {
        "title": "Number of Distinct Roll Sequences",
        "question_content": "You are given an integer n. You roll a fair 6-sided dice n times. Determine the total number of distinct sequences of rolls possible such that the following conditions are satisfied:\n\n\tThe greatest common divisor of any adjacent values in the sequence is equal to 1.\n\tThere is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2.\n\nReturn the total number of distinct sequences possible. Since the answer may be very large, return it modulo 109 + 7.\nTwo sequences are considered distinct if at least one element is different.\n&nbsp;\nExample 1:\n\nInput: n = 4\nOutput: 184\nExplanation: Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc.\nSome invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6).\n(1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed).\n(1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3.\nThere are a total of 184 distinct sequences possible, so we return 184.\nExample 2:\n\nInput: n = 2\nOutput: 22\nExplanation: Some of the possible sequences are (1, 2), (2, 1), (3, 2).\nSome invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1.\nThere are a total of 22 distinct sequences possible, so we return 22.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 104",
        "solutions": [
            {
                "id": 2195808,
                "title": "top-down-and-bottom-up-dp",
                "content": "Top-down DP is easier, so we will look at it first. Then, we will convert it to bottom-up DP so we can optimize for the constant memory.\\n\\n#### Top-Down\\nWhen doing DFS, for the current roll `n`, we pass previous (`p`), and one before (`pp`) rolls.\\n\\nFor `p` and `pp`, we try all valid rolls, and continue with DFS. Then `n == 0`, we explored one valid sequence.\\n\\nFinally, we memoise the result in `dp[n][p][pp]`.\\n\\n**C++**\\n```cpp\\nint dp[10001][7][7] = {};\\nint distinctSequences(int n, int p = 0, int pp = 0) {\\n    if (n == 0)\\n        return 1;\\n    if (dp[n][p][pp] == 0)\\n        for (int d = 1; d < 7; ++d)\\n            if (d != p && d != pp && (p == 0 || gcd(d, p) == 1))\\n                dp[n][p][pp] = (dp[n][p][pp] + distinctSequences(n - 1, d, p)) % 1000000007;\\n    return dp[n][p][pp];\\n}\\n```\\n**Complexity Analsys**\\n- Time: O(n)\\n- Memory: O(n)\\n#### Bottom-Up\\nThe initial state of `dp` is the result of 2 rolls. Note that we can use that data going forward to check for valid combinations (` if (dp[d][p])`). \\n\\nWe only need to track the result of the `i - 1` roll, so we use constant memory (two arrays - `dp` and `dp1` - 36 elements each).\\n\\nWith these optimizations, the runtime is reduced to 70 ms.\\n\\n**C++**\\n```cpp\\nint dp[6][6] = {{0, 1, 1, 1, 1, 1}, {1, 0, 1, 0, 1, 0}, {1, 1, 0, 1, 1, 0},\\n                {1, 0, 1, 0, 1, 0}, {1, 1, 1, 1, 0, 1}, {1, 0, 0, 0, 1, 0}}, dp1[6][6] = {};\\nint distinctSequences(int n) {\\n    if (n == 1)\\n        return 6;\\n    for (int i = 3; i <= n; ++i) {\\n        for (int d = 0; d < 6; ++d)\\n            for (int p = 0; p < 6; ++p) {\\n                dp1[d][p] = 0;\\n                if (dp[d][p])\\n                    for (int pp = 0; pp < 6; ++pp)\\n                        if (d != pp)\\n                            dp1[d][p] = (dp1[d][p] + dp[p][pp]) % 1000000007;\\n            }\\n        swap(dp, dp1);\\n    }\\n    return accumulate(begin(dp), end(dp), 0LL, [](long long s, const auto &n) \\n        { return (s + accumulate(begin(n), end(n), 0LL)) % 1000000007; });\\n} \\n```\\n**Complexity Analsys**\\n- Time: O(n)\\n- Memory: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[10001][7][7] = {};\\nint distinctSequences(int n, int p = 0, int pp = 0) {\\n    if (n == 0)\\n        return 1;\\n    if (dp[n][p][pp] == 0)\\n        for (int d = 1; d < 7; ++d)\\n            if (d != p && d != pp && (p == 0 || gcd(d, p) == 1))\\n                dp[n][p][pp] = (dp[n][p][pp] + distinctSequences(n - 1, d, p)) % 1000000007;\\n    return dp[n][p][pp];\\n}\\n```\n```cpp\\nint dp[6][6] = {{0, 1, 1, 1, 1, 1}, {1, 0, 1, 0, 1, 0}, {1, 1, 0, 1, 1, 0},\\n                {1, 0, 1, 0, 1, 0}, {1, 1, 1, 1, 0, 1}, {1, 0, 0, 0, 1, 0}}, dp1[6][6] = {};\\nint distinctSequences(int n) {\\n    if (n == 1)\\n        return 6;\\n    for (int i = 3; i <= n; ++i) {\\n        for (int d = 0; d < 6; ++d)\\n            for (int p = 0; p < 6; ++p) {\\n                dp1[d][p] = 0;\\n                if (dp[d][p])\\n                    for (int pp = 0; pp < 6; ++pp)\\n                        if (d != pp)\\n                            dp1[d][p] = (dp1[d][p] + dp[p][pp]) % 1000000007;\\n            }\\n        swap(dp, dp1);\\n    }\\n    return accumulate(begin(dp), end(dp), 0LL, [](long long s, const auto &n) \\n        { return (s + accumulate(begin(n), end(n), 0LL)) % 1000000007; });\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195807,
                "title": "c-java-python3-dp-explained-fast-1-liner",
                "content": "# Explanation:\\n\\nThe previous and current cannot have gcd > 1 hence:\\nFor a previous value of:\\n```\\n1 we can have current value in: [2,3,4,5,6]\\n2 we can have current value in: [1,3,5]\\n3 we can have current value in: [1,2,4,5]\\n4 we can have current value in: [1,3,5]\\n5 we can have current value in: [1,2,3,4,6]\\n6 we can have current value in: [1,5]\\n```\\nThe first number in the sequence can be any out of [1,2,3,4,5,6], to denote this I have taken m[0] = [1,2,3,4,5,6]\\nAlso previous of previous cannot be equal to current number. previous of previous is denoted by pprev.\\n<iframe src=\"https://leetcode.com/playground/nB8dsbkM/shared\" frameBorder=\"0\" width=\"700\" height=\"360\"></iframe>\\n\\n*Time Complexity: O(n)*\\n\\n**Bonus**:\\n*Method to get extremely fast python solution*:\\nMost of the solutions in the discussions take anywhere between 6000 ms and 10000 ms for python. But if you write your code like this it gives you a very fast solution (<500ms *aka* 20x faster): \\n\\n```\\n@lru_cache()\\ndef dp(n: int, p = 0, pp = 0) -> int:\\n    return reduce(lambda a,b:(a+b)%1000000007,(dp(n-1,x,p) for x in range(1,7) if x!=p and x!=pp and (p==0 or gcd(x,p)==1))) if n else 1\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int: return dp(n)\\n```\\nBasic thing is you want your caching to be done outside the Solution class\\n![image](https://assets.leetcode.com/users/images/8366e313-5b08-4cc9-9ad1-65e7cb9f0474_1656196078.002673.png)\\n\\n**Fast 1 liner**:\\n```\\ndp = lru_cache()(lambda n,p=0,pp=0:sum(dp(n-1,x,p) for x in range(1,7) if x!=p and x!=pp and (p==0 or gcd(x,p)==1)) % 1000000007 if n else 1)\\nclass Solution: \\n    distinctSequences = lambda self, n: dp(n)\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n1 we can have current value in: [2,3,4,5,6]\\n2 we can have current value in: [1,3,5]\\n3 we can have current value in: [1,2,4,5]\\n4 we can have current value in: [1,3,5]\\n5 we can have current value in: [1,2,3,4,6]\\n6 we can have current value in: [1,5]\\n```\n```\\n@lru_cache()\\ndef dp(n: int, p = 0, pp = 0) -> int:\\n    return reduce(lambda a,b:(a+b)%1000000007,(dp(n-1,x,p) for x in range(1,7) if x!=p and x!=pp and (p==0 or gcd(x,p)==1))) if n else 1\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int: return dp(n)\\n```\n```\\ndp = lru_cache()(lambda n,p=0,pp=0:sum(dp(n-1,x,p) for x in range(1,7) if x!=p and x!=pp and (p==0 or gcd(x,p)==1)) % 1000000007 if n else 1)\\nclass Solution: \\n    distinctSequences = lambda self, n: dp(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197300,
                "title": "3d-dp-recursion-memoization-tabulation-space-optimization",
                "content": "#####  **Let\\'s Start The Journey of Solving This Beautiful Problem** \\uD83D\\uDE09\\n\\n\\n**Step - 1** **(*Understanding what the problem states*)**\\n\\nWe have to `explore all possible ways `\\n(i.e number of all distinct  sequences of rolls possible )\\nand `return` the case in which `following conditions are satisfied`:\\n\\n```\\n1. The greatest common divisor of any adjacent values in the sequence is equal to 1.\\n2. There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2.\\n```\\n\\n****\\n\\t\\n**Step - 2** **(*How to approach the problem*)**\\n\\nAccording to step - 1, we have `explore all possible` ways \\nin which `following conditions are satisfied`:\\n\\n```\\n1. The greatest common divisor of any adjacent values in the sequence is equal to 1.\\n2. There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2.\\n```\\nSo, we have to `use Recursion`.\\n\\t\\n****\\n\\n**Step - 3** **(*Writing Recursion / Top-Down Approach*)**\\t\\n\\n**How To Write Recursion ? :**\\n1. To Explore all possible ways, we have to keep track of `number of throws of dice` (say, `ind`) & according to  `\"1. The greatest common divisor of any adjacent values in the sequence is equal to 1\"` , we have to keep track of `previous value` also (say, `prev1`) & according to `\"2. There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2\"` , we have to keep track of `previous of previous value` (say, `prev2`).\\n\\t\\n\\tI.  Range of `ind` will be `0,1,2,....n`.\\n\\n\\tII.  Range of `prev1` will be `0,1,2,....,6`.\\n\\t\\n\\tIII. Range of `prev2` will be `0,1,2,....,6`.\\n\\n2.  `Return` the `total` of all cases.\\n\\n3.  ***Writing Conditions in Codes-*** \\n\\n\\tI. \"The greatest common divisor of any adjacent values in the sequence is equal to 1\" i.e `__gcd(prev1,i) == 1` in c++. As we are `starting prev1 `from `0` & in that case `__gcd(0,i) == 0`, but it valid case so, should be consisered i.e we have to write `\"(prev1 == 0 || __gcd(prev1,i) == 1)\"`.\\n\\t\\n\\tII. \"There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2\" i.e `\"prev1 != i && prev2 != i\"`.\\n\\n4. ***Base case -*** When we already `throw the dice n times` i.e `ind` reached `n`, then we got a distinct sequence which follow the given conditions. so, we will have to `return 0`.\\n\\n**Code :** \\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tint mod = 1e9+7;\\n\\n\\t\\tint f(int ind,int prev1,int prev2,int n){\\n\\t\\t\\t//Base Case\\n\\t\\t\\tif(ind == n) return 1;\\n\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 1;i <= 6;i++) //Exploring all possible values\\n\\t\\t\\t\\tif(prev1 != i && prev2 != i && (prev1 == 0 || __gcd(prev1,i) == 1))\\n\\t\\t\\t\\t\\tans = (ans + f(ind+1,i,prev1,n))%mod;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tint distinctSequences(int n) {\\n\\t\\t\\treturn f(0,0,0,n);\\n\\t\\t}\\n\\t};\\n\\n\\n**Time complexity -** *Exponential*\\n**Space complexity -** *O(n)* [Recursion stack space]\\n\\n**Result :** *Time Limit Exceded*\\n\\n****\\n\\n**Step - 4** **(*Writing Memoization*)**\\n\\n**Obervation :** \\nIf you `draw Recursion Tree`, You will `observe` there will be lots of `Overlapping Sub-Problems`.\\nSo, we have to `use Memoization`.\\n\\n**How To Write Memoization ? :**\\n\\n1.  See the `range` of `ind` , `prev1` and `prev2` variable.\\n\\t I. `ind` - `[0,n]`\\n\\t II. `prev1` - `[0,6]`\\n\\t III. `prev2` - `[0,6]`\\n\\t \\n2. Declare a 3D Vector (say, `dp`)\\tOf length `[max(ind)+1][max(prev1)+1][max(prev2)+1]` and `Intialised` with a value not in the constraints (like `-1` here) i.e `vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(7,vector<int>(7,-1)));`\\n\\n3. Now before going into recursion call check (i.e `if(dp[ind][prev1][prev2] != -1)`) if the value is already computed or not. If computed return it (i.e `return dp[ind][prev1][prev2];`), no need to compute it again.\\n\\n4. Every time returning the value of recursion call store it in `dp[ind][prev1][prev2];` so that we can use it again.\\n\\n**Code :**\\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tint mod = 1e9+7;\\n\\n\\t\\tint f(int ind,int prev1,int prev2,int n,vector<vector<vector<int>>> &dp){\\n\\t\\t\\t//Base Case\\n\\t\\t\\tif(ind == n) return 1;\\n\\n\\t\\t\\tif(dp[ind][prev1][prev2] != -1) return dp[ind][prev1][prev2];\\n\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 1;i <= 6;i++) //Exploring all possible values\\n\\t\\t\\t\\tif(prev1 != i && prev2 != i && (prev1 == 0 || __gcd(prev1,i) == 1))\\n\\t\\t\\t\\t\\tans = (ans + f(ind+1,i,prev1,n,dp))%mod;\\n\\n\\t\\t\\treturn dp[ind][prev1][prev2] = ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tint distinctSequences(int n) {\\n\\t\\t\\tvector<vector<vector<int>>> dp(n+1,vector<vector<int>>(7,vector<int>(7,-1)));\\n\\t\\t\\treturn f(0,0,0,n,dp);\\n\\t\\t}\\n\\t};\\n\\n**Time complexity -** *O(n\\xD76\\xD76)*\\n**Space complexity -** *O(n\\xD76\\xD76) + O(n)* [ Recursion stack space]\\n\\n**Result :** *Accepted*\\n\\n****\\n\\n**Step - 5** **(*Writing Tabulation / Bottom-Up Approach*)**\\t\\n\\n**Why To Do Tabulation ? :**\\nTo remove the `Recursion stack Space` (i.e `O(n)`) we are using.\\n\\n**How To Write Tabulation? :**\\n\\n1. ***Write Base Case -*** All the Table value for which `ind = n` will be `initialized to 1` i.e \\n\\n\\t\\tfor(int prev1 = 0;prev1 < 7;prev1++)\\n            for(int prev2 = 0;prev2 < 7;prev2++)\\n                dp[n][prev1][prev2] = 1;\\n\\n2. `Tabulation` is `Bottom-up` approach i.e `opposite` of `Top-Down / Recursion`. So, here we will run `Outer loop` in `opposite order` i.e `ind - n-1,n-2,....,2,1,0` and Rest variable will run as it was in Recursion i.e   `prev1 - 0,1,2,....,6` & `prev2 - 0,1,2,....,6`.\\n\\n3. `Copy & Paste` the `recursion` inside the loop `i.e`\\n\\t\\t\\n\\t\\tif(dp[ind][prev1][prev2] != -1) return dp[ind][prev1][prev2];\\n        \\n        int ans = 0;\\n        for(int i = 1;i <= 6;i++) //Exploring all possible values\\n            if(prev1 != i && prev2 != i && (prev1 == 0 || __gcd(prev1,i) == 1))\\n                ans = (ans + f(ind+1,i,prev1,n,dp))%mod;\\n        \\n        return dp[ind][prev1][prev2] = ans;\\n\\t\\t\\n\\tand `change function to dp array` ( like `f(ind+1,i,prev1,n,dp)` to `dp[ind+1][i][prev1]`).\\n\\t\\n4. `Remove return` from `return dp[ind][prev1][prev2] = ans`\\n5. Atlast change return statement `return f(0,0,0,n,dp)` to `return dp[0][0][0]`.\\n\\n\\n**Code :**\\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tint mod = 1e9 + 7;\\n\\tpublic:\\n\\t\\tint distinctSequences(int n) {\\n\\t\\t\\tvector<vector<vector<int>>> dp(n+1,vector<vector<int>>(7,vector<int>(7,-1))); \\n\\n\\t\\t\\t//Base Case\\n\\t\\t\\tfor(int prev1 = 0;prev1 < 7;prev1++)\\n\\t\\t\\t\\tfor(int prev2 = 0;prev2 < 7;prev2++)\\n\\t\\t\\t\\t\\tdp[n][prev1][prev2] = 1;\\n\\n\\n\\t\\t\\tfor(int ind = n-1;ind >= 0;ind--){ //Loop Reversed\\n\\t\\t\\t\\tfor(int prev1 = 0;prev1 < 7;prev1++){\\n\\t\\t\\t\\t\\tfor(int prev2 = 0;prev2 < 7 ;prev2++){\\n\\t\\t\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\t\\t\\tfor(int i = 1;i <= 6;i++)\\n\\t\\t\\t\\t\\t\\t\\tif(prev1 != i && prev2 != i && (prev1 == 0 || __gcd(prev1,i) == 1))\\n\\t\\t\\t\\t\\t\\t\\t\\tans = (ans + dp[ind+1][i][prev1])%mod;\\n\\n\\t\\t\\t\\t\\t\\tdp[ind][prev1][prev2] = ans;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][0][0];\\n\\t\\t}\\n\\t};\\n\\n**Time complexity -** *O(n\\xD76\\xD76) + O(6\\xD76)*\\n**Space complexity -** *O(n\\xD76\\xD76)*\\n\\n**Result :** *Accepted*\\n\\n****\\n\\n**Step - 6** **(*Optimizing Tabulation / Bottom-Up Approach*)**\\t\\n\\n**Observation :**\\nWe can `reduced` the time taking during `Initialization of Base Case` by `Initializing dp by 1`, when declaring it i.e `vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(7,vector<int>(7,1)));`\\n\\n**Code :**\\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tint mod = 1e9 + 7;\\n\\tpublic:\\n\\t\\tint distinctSequences(int n) {\\n\\t\\t\\tvector<vector<vector<int>>> dp(n+1,vector<vector<int>>(7,vector<int>(7,1))); //Base case initialized here only\\n\\n\\t\\t\\tfor(int ind = n-1;ind >= 0;ind--){ //Loop Reversed\\n\\t\\t\\t\\tfor(int prev1 = 0;prev1 < 7;prev1++){\\n\\t\\t\\t\\t\\tfor(int prev2 = 0;prev2 < 7 ;prev2++){\\n\\t\\t\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\t\\t\\tfor(int i = 1;i <= 6;i++)\\n\\t\\t\\t\\t\\t\\t\\tif(prev1 != i && prev2 != i && (prev1 == 0 || __gcd(prev1,i) == 1))\\n\\t\\t\\t\\t\\t\\t\\t\\tans = (ans + dp[ind+1][i][prev1])%mod;\\n\\n\\t\\t\\t\\t\\t\\tdp[ind][prev1][prev2] = ans;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][0][0];\\n\\t\\t}\\n\\t};\\n\\n\\n**Time complexity -** *O(n\\xD76\\xD76)*\\n**Space complexity -** *O(n\\xD76\\xD76)*\\n\\n**Result :** *Accepted*\\n\\n****\\n\\n\\n\\n**Step - 7** **(*Writing Space Optimization*)**\\n\\n**Obervation :** \\nIf you can `fill the dp array`,then you will see, we can actually fill any `current ``ind` , if we know the `previous ind` values only. \\nSo, no need to take 3D Vector instead we can take two 2D vector vectors (`prev` to `store values of previous ind` &`cur` to `store values of current ind`).\\n\\n**How to Write Space Optimization ? :**\\n\\n1. `Define` two 2D vector `prev` and `cur` and we have to `initialize prev` vector with` 1 `to `tackle Base Case `i.e\\n\\n\\t\\tvector<vector<int>> prev(7,vector<int>(7,1));//Base case initialized here only\\n\\t\\tvector<vector<int>> cur(7,vector<int>(7));\\n\\t\\t\\n2. Write `prev in place of dp[ind+1]` (as it is previous vector now) & `cur in place of dp[ind]` (as it is current vector now) i.e\\n\\n\\t\\tdp[ind+1][i][prev1] -> prev[i][prev1]\\n\\t\\tdp[ind][prev1][prev2] ->cur[prev1][prev2]\\n\\t\\t\\n3. Do `prev = cur` at the end of every iteration of outer loop so that we can `use the cur iteration values in calculating the next iteration values.` \\t\\n\\n4. `At the end of loop`,` all the values` will be `stored in prev`.  so, we will have to return `prev[0][0] `instead of `dp[0][0][0]`.\\n\\t\\n\\n**Code :**\\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tint mod = 1e9 + 7;\\n\\tpublic:\\n\\t\\tint distinctSequences(int n) {\\n\\t\\t\\tvector<vector<int>> prev(7,vector<int>(7,1));//Base case initialized here only\\n\\t\\t\\tvector<vector<int>> cur(7,vector<int>(7));\\n\\n\\t\\t\\tfor(int ind = n-1;ind >= 0;ind--){ //Loop Reversed\\n\\t\\t\\t\\tfor(int prev1 = 0;prev1 < 7;prev1++){\\n\\t\\t\\t\\t\\tfor(int prev2 = 0;prev2 < 7 ;prev2++){\\n\\t\\t\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\t\\t\\tfor(int i = 1;i <= 6;i++)\\n\\t\\t\\t\\t\\t\\t\\tif(prev1 != i && prev2 != i && (prev1 == 0 || __gcd(prev1,i) == 1))\\n\\t\\t\\t\\t\\t\\t\\t\\tans = (ans + prev[i][prev1])%mod;\\n\\n\\t\\t\\t\\t\\t\\tcur[prev1][prev2] = ans;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev = cur;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev[0][0];\\n\\t\\t}\\n\\t};\\n\\n**Time complexity -** *O(n\\xD76\\xD76) \\u2248 O(n)*\\n**Space complexity -** *O(2\\xD76\\xD76) \\u2248 O(1)*\\n\\n**Result :** *Accepted*\\n\\n****\\n\\n**JOURNEY ENDS HERE\\uD83D\\uDE42**\\n\\n\\n**My Other Articles :**\\n\\n1. [Selling Pieces of Wood](https://leetcode.com/problems/selling-pieces-of-wood/discuss/2170082/partition-dp-detailed-explanations-for-absolute-beginners) [ Partition DP Pattern ]\\n\\n**If You Like It, Please Upvote.**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n1. The greatest common divisor of any adjacent values in the sequence is equal to 1.\\n2. There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2.\\n```\n```\\n1. The greatest common divisor of any adjacent values in the sequence is equal to 1.\\n2. There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196042,
                "title": "just-do-as-question-says-memoization",
                "content": "Ok so again, I am gonna saying that don\\'t overthink and make complicate. Just do what question said and first find the solution.\\nSo first we have numbers forget about dices because I fear when i listen dices, stones, alice-bob etc in dp problems. So just think we have an arr of 6 size containing \\narr = {1,2,3,4,5,6};\\n\\nNow you\\'re have to choose N value from above array so that\\n1. Current i-th is not equal to last or prev of last choosen.\\n2. And gcd of i-th and last would be 1.\\n\\nSo let\\'s make a recursive solution :\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> arr{1,2,3,4,5,6};\\n    long solve(int n, int last, int prevLast, int i) {\\n        if(i == n) return 1;\\n        long res = 0;\\n        for(int &j:arr) {\\n\\t\\t\\t// validate step 1 and 2\\n            if(j == last || j == prevLast || (last!=-1 && (__gcd(j, last)!=1))) continue;\\n            res+=solve(n, j, last, i+1);\\n        }\\n        return res;\\n    }\\n    \\n    int distinctSequences(int n) {\\n     return solve(n, -1, -1, 0);   \\n    }\\n};\\n```\\nOk!, \\nNow we have something which working fine just we need to do it smartly. So let\\'s what are the variables in our recursion function :\\n1. At every i-th we can have any element from 1..6\\n2. For every i-th we can have last element from 1..6 as well.\\n3. For every i-th we can have prev of last element from 1..6 as well.\\n\\n***So for n-> we can have last 1..6 -> for each last we can have -> 1..6 prev of last***\\nNow some basic sanity checking :\\n1. Handle integer overflow,\\n2. avoid to check memo when last and prevLast is not choosen i.e. you\\'ve only less than 2 element choosen in hand.\\n\\nSo here is memo version :\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    vector<int> arr{1,2,3,4,5,6};\\n    int mod;\\n    long solve(int n, int last, int prevLast, int i) {\\n        if(i == n) return 1;\\n        \\n        //  avoid to check when we have choosen less than 2 element only\\n        long res = min(last, prevLast)<0 ? -1 :dp[last][prevLast][i];\\n        if(res!=-1) return res;\\n        res = 0;\\n        for(int &j:arr) {\\n            //  handle the cases\\n            if(j == last || j == prevLast || (last!=-1 && (__gcd(j, last)!=1))) continue;\\n            \\n            //  handle integer overflow case\\n            res=(res+solve(n, j, last, i+1))%mod;\\n        }\\n        if(min(last, prevLast)>=0) {\\n            dp[last][prevLast][i]=res;\\n        }\\n        return res;\\n    }\\n    \\n    int distinctSequences(int n) {\\n     mod = 1000000007;\\n     dp.resize(7, vector<vector<int>>(7, vector<int>(n+1, -1)));\\n     return solve(n, -1, -1, 0);   \\n    }\\n};\\n```\\n\\n# Time Complexity :\\nSo over-all time-complexity would be O(N) even we\\'re using N*7*7 but those are constant in terms of N. Second we\\'re using __gcd which wouldn\\'t be costly because number would be very small {1..6}.\\neventhough if take gcd complexity than it would be O(N*(log n)2) where n is maximum element in {1..6} and N is the given input\\n# Space Complexity :\\nWe\\'re using dp of size n*7*7. So overall space would be O(N).",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arr{1,2,3,4,5,6};\\n    long solve(int n, int last, int prevLast, int i) {\\n        if(i == n) return 1;\\n        long res = 0;\\n        for(int &j:arr) {\\n\\t\\t\\t// validate step 1 and 2\\n            if(j == last || j == prevLast || (last!=-1 && (__gcd(j, last)!=1))) continue;\\n            res+=solve(n, j, last, i+1);\\n        }\\n        return res;\\n    }\\n    \\n    int distinctSequences(int n) {\\n     return solve(n, -1, -1, 0);   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    vector<int> arr{1,2,3,4,5,6};\\n    int mod;\\n    long solve(int n, int last, int prevLast, int i) {\\n        if(i == n) return 1;\\n        \\n        //  avoid to check when we have choosen less than 2 element only\\n        long res = min(last, prevLast)<0 ? -1 :dp[last][prevLast][i];\\n        if(res!=-1) return res;\\n        res = 0;\\n        for(int &j:arr) {\\n            //  handle the cases\\n            if(j == last || j == prevLast || (last!=-1 && (__gcd(j, last)!=1))) continue;\\n            \\n            //  handle integer overflow case\\n            res=(res+solve(n, j, last, i+1))%mod;\\n        }\\n        if(min(last, prevLast)>=0) {\\n            dp[last][prevLast][i]=res;\\n        }\\n        return res;\\n    }\\n    \\n    int distinctSequences(int n) {\\n     mod = 1000000007;\\n     dp.resize(7, vector<vector<int>>(7, vector<int>(n+1, -1)));\\n     return solve(n, -1, -1, 0);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195829,
                "title": "recursion-memoization-o-n-c-solution",
                "content": "**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int dp[10001][7][7];\\n\\n    int find(int index, int prev1, int prev2, int n) {\\n        if (index == n) {\\n            return 1;\\n        }\\n        \\n        if (dp[index][prev1][prev2] != -1) {\\n            return dp[index][prev1][prev2];\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i <= 6; i++) {\\n            if (i != prev1 && i != prev2 && (prev1 == 0 || __gcd(i, prev1) == 1)) {\\n                ans = (ans + find(index + 1, i, prev1, n)) % mod;\\n            }\\n        }\\n        \\n        return dp[index][prev1][prev2] = ans;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return find(0, 0, 0, n);\\n    }\\n};\\n```\\n\\n**Solution:**\\n\\n\\n- We can keep three variables, current index, previous value and the previous to previous value.\\n- Current index is used to keep track of the dice count\\n- Previous value is needed as we need to ensure the gcd of current value we are choosing and the previous value is 1\\n- Previous to previous value is needed to ensure the value we are choosing at this index is not equal to this value (as per the second constraint)\\n\\n\\n**Time Complexity:**\\nThe time complexit is equal to the number of states required * time for each state, the number of states is equal to N * 6 * 6 and for each such states, there is a loop of size 6. Hence the total number of operations will be N * 6 * 6 * 6. Therefore the time complexity is equal to **O(N)**.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int dp[10001][7][7];\\n\\n    int find(int index, int prev1, int prev2, int n) {\\n        if (index == n) {\\n            return 1;\\n        }\\n        \\n        if (dp[index][prev1][prev2] != -1) {\\n            return dp[index][prev1][prev2];\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i <= 6; i++) {\\n            if (i != prev1 && i != prev2 && (prev1 == 0 || __gcd(i, prev1) == 1)) {\\n                ans = (ans + find(index + 1, i, prev1, n)) % mod;\\n            }\\n        }\\n        \\n        return dp[index][prev1][prev2] = ans;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return find(0, 0, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195996,
                "title": "python-dp-solution-with-explanation",
                "content": "# **Explanation**\\n`dp[i][j]` means the number of sequence ending with `i` and `j`\\n`dp[j][k] = sum(dp[i][j])`, where `k != i and k != j and gcd(j, k) == 1`.\\n\\nInitialize `dp[-1][-1]`,\\nsince `-1` is not on dice and co-prime with any integers.\\n<br>\\n\\n# **Complexity**\\nTime `O(216n)`\\nSpace `O(36)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def distinctSequences(self, n: int) -> int:\\n        mod = 10**9 + 7\\n        dp, dp2 = {(7, 7): 1}, Counter()\\n        for _ in range(n):\\n            for i, j in dp:\\n                for k in range(1, 7):\\n                    if k != i and k != j and gcd(j, k) == 1:\\n                        dp2[j, k] = (dp2[j, k] + dp[i, j]) % mod\\n            dp, dp2 = dp2, Counter()\\n        return sum(dp.values()) % mod\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def distinctSequences(self, n: int) -> int:\\n        mod = 10**9 + 7\\n        dp, dp2 = {(7, 7): 1}, Counter()\\n        for _ in range(n):\\n            for i, j in dp:\\n                for k in range(1, 7):\\n                    if k != i and k != j and gcd(j, k) == 1:\\n                        dp2[j, k] = (dp2[j, k] + dp[i, j]) % mod\\n            dp, dp2 = dp2, Counter()\\n        return sum(dp.values()) % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2195930,
                "title": "python-3-explanation-with-pictures-dp",
                "content": "Firstly let\\'s find all valid pairs `prev-curr` that has gcd of 1.\\nFor the first roll, `dp[i] = 1` since there is no constrain.\\n\\nFor the second roll, the second roll `curr` is valid only if the pair made by previous roll `curr - prev` is valid.\\n\\nTake the picture below as an example, if the second roll ends up with `2`, the previous roll can only be `1, 3, 5` according to the gcd constrain.\\n\\n![image](https://assets.leetcode.com/users/images/85ae67e2-efa9-4b5f-a924-84e484764324_1656172906.3691068.png)\\n\\nLet\\'s update the third roll, now we also have to check if the roll before the previous roll is also valid, that is `roll 1` isn\\'t equal to `roll 3`. The `1 - 3 - 1` sequence is not valid, even though both `1-3` and `3-1` are valid.\\n\\n![image](https://assets.leetcode.com/users/images/754270f0-2d01-434d-ae58-041b78201563_1656172910.2037878.png)\\n\\nTherefore, for each number `num` in `roll X`, we can\\'t only record the number of valid roll ended by `num`, but also the numbers of valid roll in `roll X-1`.\\n\\n![image](https://assets.leetcode.com/users/images/0b5391a3-fa5d-4ba7-abd5-5043cb6f858a_1656173650.066918.png)\\n\\n\\nNow when we update the `number 1` in `roll 3`, we can go through the prev stats of `2` in `roll 2`. Since `roll2[2]` has 1 occurrence of 1 in `roll 1`, thus we discard this roll and only add the rest rolls to `roll 3`. Meanwhile, we are building the same `prev stats` table for each number in `roll 3`, therefore it can be used when we update `roll 4`. Since `roll3[1]` has 3 valid previous number from `roll2` we update `roll3[1][2] = 3`.\\n\\n![image](https://assets.leetcode.com/users/images/845a6c42-140c-41de-86d4-1a9371289dae_1656172917.1702557.png)\\n\\n\\n\\n**python**\\n\\n```\\ndef distinctSequences(self, n: int) -> int:\\n        if n < 2: \\n            return 6\\n        \\n        P = {1: {2, 3, 4, 5, 6}, 2: {1, 3, 5}, 3: {1, 2, 4, 5}, 4: {1, 3, 5}, 5: {1, 2, 3, 4, 6}, 6: {1, 5}}\\n        mod = 1000000007\\n        \\n        prev = [[0] * 7 for _ in range(7)]\\n        for i in range(1, 7):\\n            for j in P[i]:\\n                prev[i][j] = 1\\n\\n        for _ in range(n - 2):\\n            curr = [[0] * 7 for _ in range(7)]\\n            for i in range(1, 7):\\n                for j in P[i]:\\n                    for k in range(1, 7):\\n                        if k != i:\\n                            curr[i][j] += prev[j][k]\\n                            curr[i][j] %= mod          \\n            prev = curr[:]\\n        return sum(sum(x) for x in prev) % mod\\n```",
                "solutionTags": [],
                "code": "```\\ndef distinctSequences(self, n: int) -> int:\\n        if n < 2: \\n            return 6\\n        \\n        P = {1: {2, 3, 4, 5, 6}, 2: {1, 3, 5}, 3: {1, 2, 4, 5}, 4: {1, 3, 5}, 5: {1, 2, 3, 4, 6}, 6: {1, 5}}\\n        mod = 1000000007\\n        \\n        prev = [[0] * 7 for _ in range(7)]\\n        for i in range(1, 7):\\n            for j in P[i]:\\n                prev[i][j] = 1\\n\\n        for _ in range(n - 2):\\n            curr = [[0] * 7 for _ in range(7)]\\n            for i in range(1, 7):\\n                for j in P[i]:\\n                    for k in range(1, 7):\\n                        if k != i:\\n                            curr[i][j] += prev[j][k]\\n                            curr[i][j] %= mod          \\n            prev = curr[:]\\n        return sum(sum(x) for x in prev) % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2196069,
                "title": "can-anyone-please-contradict-this-solution",
                "content": "Can someone please help me in porving this solution wrong/\\nwe simply check gcd condition and then remove all the sequences formed by putting valid characters in front of i-2\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int distinctSequences(int n) {\\n        vector<vector<int> > arr(7);\\n \\n        arr[1]={2,3,4,5,6};\\n        arr[2]={1,3,5};\\n        arr[3]={1,2,4,5};\\n        arr[4]={1,3,5};\\n        arr[5]={1,2,3,4,6};\\n        arr[6]={1,5};\\n        \\n        \\n        \\n        vector<vector<long long> > dp(n+1, vector<long long> (7,0));\\n        for(int dig=1;dig<=6;dig++) dp[1][dig]=1;\\n        for(int i=2;i<=n;i++){\\n            for(int dig=1;dig<=6;dig++){\\n                for(int k:arr[dig]){\\n                    dp[i][dig] = (dp[i][dig] +  dp[i-1][k])%mod;\\n                }\\n            \\n                if(i-2>=0){\\n                    dp[i][dig]=( dp[i][dig] -  dp[i-2][dig]*arr[dig].size())%mod;\\n  \\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=6;j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n        \\n        long long sum = 0;\\n        for(int dig=1;dig<=6;dig++){\\n            sum = (sum + dp[n][dig])%mod;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Helped me understand thanks guys :)**\\n@tar_infinity \\'s comment helped me understand the problem in this question\\nThe problem is \\n`dp[i][dig]=( dp[i][dig] -  dp[i-2][dig]*arr[dig].size())%mod;`\\n\\nThis statement is assuming that we can always put all the valid characters from arr at the end , but its not true as on putting them we may be violating some condition. But here we are still removing them thats why we have a smaller answer.\\n\\nExample:\\n n=4     dig=2;\\n 5 2 5      2\\n Here we will end up removing 525 as we can append 5 at the end of 2 , but see we cannot actually do it as the condition of 2 gaps fails in525 , therefore its not even present",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int distinctSequences(int n) {\\n        vector<vector<int> > arr(7);\\n \\n        arr[1]={2,3,4,5,6};\\n        arr[2]={1,3,5};\\n        arr[3]={1,2,4,5};\\n        arr[4]={1,3,5};\\n        arr[5]={1,2,3,4,6};\\n        arr[6]={1,5};\\n        \\n        \\n        \\n        vector<vector<long long> > dp(n+1, vector<long long> (7,0));\\n        for(int dig=1;dig<=6;dig++) dp[1][dig]=1;\\n        for(int i=2;i<=n;i++){\\n            for(int dig=1;dig<=6;dig++){\\n                for(int k:arr[dig]){\\n                    dp[i][dig] = (dp[i][dig] +  dp[i-1][k])%mod;\\n                }\\n            \\n                if(i-2>=0){\\n                    dp[i][dig]=( dp[i][dig] -  dp[i-2][dig]*arr[dig].size())%mod;\\n  \\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=6;j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n        \\n        long long sum = 0;\\n        for(int dig=1;dig<=6;dig++){\\n            sum = (sum + dp[n][dig])%mod;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2200320,
                "title": "c-memoization-with-proper-explanation",
                "content": "**Approch:-Dynamic Programming memoization approach (Top-Down).**\\n**-->** Let\\'s supoose we have n empty indices and we have to fill that indices with number up to  1 to 6.\\n**-->** But we have to follow some rules:-\\n**-->** Rule1:-Adjacent values have gcd 1.\\n**-->** Rule2:-And same number sholud be palced at gap of two.\\n\\n\\u26AB Now, what we see ,that we have choices for every indices:-\\n-->But we follow rules to fillis according to choices.\\n-->And when we will fill all indices then we will get one choice.\\n\\n**\\u26AB  Algorithm and steps:- **\\n\\n-->Initillay We will create a 2d vector size 7. \\n-->Ignoring 0\\'th index.\\n-->All other i\\'th index vector will hold the list of all the numbers which will have gcd 1 with i.\\n\\n-->We have all 6 choices to fix at index 0.\\n-->We will call a solve function:-\\n -->Solve function have three dp state variable :\\n \\xA0  1.) idx:-Aindex on which we will put some choices from 1 to 6.\\n    2.) Val:- value we have putted at index idx-1.\\n    3.) PreVal:- value we have putted at index idx-2;\\n    \\n -->Base condition of solve:- if idx hit n then return 1.\\n -->Other wise for index idx we will Put values which are eligible for putting next of Val i.e thier gcd be 1 and it must not eual to PreVal.\\n \\n -->Add all choices in ans1 and return it .\\n \\n --> **Time Complexity:- **  O(6n);\\n--> **Sapce Complexity :- ** O(7*7*n);\\n \\n *-->Understand more from Code.*\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int dp[10001][7][7];\\n    int solve(int PreVal,int Val,int idx,int &n,vector<vector<int>>&v)\\n    {\\n        if(idx>=n) //Base Condition\\n            return 1;\\n        \\n        \\n        if(dp[idx][PreVal][Val]!=-1) //Memoization\\n            return dp[idx][PreVal][Val]%mod;\\n        \\n        \\n        int ans1=0; //Answer that will keep count.\\n        for(int i=0;i<v[Val].size();i++) //Check all the eligibale number for adjacent of Val.\\n        {\\n            \\n            if(PreVal!=v[Val][i]) //But it sholud not equal to PreVal.\\n            {\\n                /*Then call solve function for index idx+1.\\n                -->And val will become preval.\\n                -->Add it in ans1.*/\\n                ans1=(ans1 % mod + solve(Val,v[Val][i],idx+1,n,v) % mod)%mod; \\n            }\\n            \\n        }\\n        \\n        return dp[idx][PreVal][Val] = ans1%mod; //return ans1\\n    }\\n    int distinctSequences(int n) {\\n        vector<vector<int>>v(7); //2d vector that will store the Gcd 1 values with i\\'th index.\\n        \\n        v[1]={2,3,4,5,6};\\n        v[2]={1,3,5};\\n        v[3]={1,2,4,5};\\n        v[4]={1,3,5};\\n        v[5]={1,2,3,4,6};\\n        v[6]={1,5};\\n        \\n        memset(dp,-1,sizeof(dp)); \\n        \\n        int ans=0;\\n        for(int i=1;i<=6;i++) //For index 0 we have all choices from 0 to 6.\\n        {\\n            ans=(ans % mod+solve(i,i,1,n,v) % mod)%mod; //Call solve function from index 1.\\n        }\\n        \\n        return ans%mod; // return ans.\\n    }\\n};\\n```\\n\\u2764*Please Upvote if it is helpful for you .*\\n*Do comment if solution have any mistake.*",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int dp[10001][7][7];\\n    int solve(int PreVal,int Val,int idx,int &n,vector<vector<int>>&v)\\n    {\\n        if(idx>=n) //Base Condition\\n            return 1;\\n        \\n        \\n        if(dp[idx][PreVal][Val]!=-1) //Memoization\\n            return dp[idx][PreVal][Val]%mod;\\n        \\n        \\n        int ans1=0; //Answer that will keep count.\\n        for(int i=0;i<v[Val].size();i++) //Check all the eligibale number for adjacent of Val.\\n        {\\n            \\n            if(PreVal!=v[Val][i]) //But it sholud not equal to PreVal.\\n            {\\n                /*Then call solve function for index idx+1.\\n                -->And val will become preval.\\n                -->Add it in ans1.*/\\n                ans1=(ans1 % mod + solve(Val,v[Val][i],idx+1,n,v) % mod)%mod; \\n            }\\n            \\n        }\\n        \\n        return dp[idx][PreVal][Val] = ans1%mod; //return ans1\\n    }\\n    int distinctSequences(int n) {\\n        vector<vector<int>>v(7); //2d vector that will store the Gcd 1 values with i\\'th index.\\n        \\n        v[1]={2,3,4,5,6};\\n        v[2]={1,3,5};\\n        v[3]={1,2,4,5};\\n        v[4]={1,3,5};\\n        v[5]={1,2,3,4,6};\\n        v[6]={1,5};\\n        \\n        memset(dp,-1,sizeof(dp)); \\n        \\n        int ans=0;\\n        for(int i=1;i<=6;i++) //For index 0 we have all choices from 0 to 6.\\n        {\\n            ans=(ans % mod+solve(i,i,1,n,v) % mod)%mod; //Call solve function from index 1.\\n        }\\n        \\n        return ans%mod; // return ans.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196009,
                "title": "python3-top-down-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7a67de4e975be771355e048bf8dde4cf0906e360) for solutions of biweekly 81. \\n\\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        \\n        @lru_cache\\n        def fn(n, p0, p1): \\n            \"\"\"Return total number of distinct sequences.\"\"\"\\n            if n == 0: return 1\\n            ans = 0\\n            for x in range(1, 7): \\n                if x not in (p0, p1) and gcd(x, p0) == 1: ans += fn(n-1, x, p0)\\n            return ans % 1_000_000_007\\n        \\n        return fn(n, -1, -1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        \\n        @lru_cache\\n        def fn(n, p0, p1): \\n            \"\"\"Return total number of distinct sequences.\"\"\"\\n            if n == 0: return 1\\n            ans = 0\\n            for x in range(1, 7): \\n                if x not in (p0, p1) and gcd(x, p0) == 1: ans += fn(n-1, x, p0)\\n            return ans % 1_000_000_007\\n        \\n        return fn(n, -1, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195965,
                "title": "top-down-memoization-3d-c",
                "content": "We can approach this problem in dp way .Standing at any index we just need to know about the no. just before current index (so that we do not put a no that have a factor>1 with previous number) and a number at index (current - 2) so that we do not put the current number equal to that.\\n\\nIn code,if current index is i,\\nd1 is number at distance 1(number at i-1)\\nd2 is number at distance 2(number at i-2)\\n\\n```\\n\\n int mod = 1e9+7;\\n    long long getans(int n, int d1,int d2,vector<vector<int>>& patt,vector<vector<vector<long long>>>& vec){\\n        if(n == 0)return 1;\\n        \\n        if(d1!=-1 && d2!=-1 && vec[n][d1][d2]!=-1)return vec[n][d1][d2];\\n        \\n        long long count = 0;\\n        \\n        if(d1 == -1){\\n           \\n            for(int i =1;i<=6;i++){\\n            count = (count + getans(n-1,i,d1,patt,vec))%mod;\\n            }\\n           \\n        }\\n        else{\\n            \\n            for(int i=0;i<patt[d1].size();i++){\\n                if(d2 == patt[d1][i])continue;\\n                count = (count+getans(n-1,patt[d1][i],d1,patt,vec))%mod;   \\n            }   \\n        }\\n         if(d1!=-1 && d2!=-1 )vec[n][d1][d2] = count;\\n        return count;\\n        \\n        \\n    }\\n    \\n    int distinctSequences(int n) {\\n        \\n        vector<vector<int>> patt{{0},{2,3,4,5,6},{1,3,5},{1,2,4,5},{1,3,5},{1,2,3,4,6},{1,5}};\\n    \\n        vector<vector<vector<long long>>> vec(n+1, vector<vector<long long>>(7,vector<long long>(7,-1)));    \\n        \\n        long long ans = getans(n,-1,-1,patt,vec);\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n int mod = 1e9+7;\\n    long long getans(int n, int d1,int d2,vector<vector<int>>& patt,vector<vector<vector<long long>>>& vec){\\n        if(n == 0)return 1;\\n        \\n        if(d1!=-1 && d2!=-1 && vec[n][d1][d2]!=-1)return vec[n][d1][d2];\\n        \\n        long long count = 0;\\n        \\n        if(d1 == -1){\\n           \\n            for(int i =1;i<=6;i++){\\n            count = (count + getans(n-1,i,d1,patt,vec))%mod;\\n            }\\n           \\n        }\\n        else{\\n            \\n            for(int i=0;i<patt[d1].size();i++){\\n                if(d2 == patt[d1][i])continue;\\n                count = (count+getans(n-1,patt[d1][i],d1,patt,vec))%mod;   \\n            }   \\n        }\\n         if(d1!=-1 && d2!=-1 )vec[n][d1][d2] = count;\\n        return count;\\n        \\n        \\n    }\\n    \\n    int distinctSequences(int n) {\\n        \\n        vector<vector<int>> patt{{0},{2,3,4,5,6},{1,3,5},{1,2,4,5},{1,3,5},{1,2,3,4,6},{1,5}};\\n    \\n        vector<vector<vector<long long>>> vec(n+1, vector<vector<long long>>(7,vector<long long>(7,-1)));    \\n        \\n        long long ans = getans(n,-1,-1,patt,vec);\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2255405,
                "title": "c-linear-cost-constant-space-22-long-var-needed",
                "content": "# Base Case (1)\\n\\nWhen n is 1, answer is simply 6.\\nEach of the 6 face is valid, since they are no \"adjacency\" concept in just 1 face.\\n\\n# Base Case (2)\\n\\nWhen n is 2, answer is 22.\\nSuppose `(f1, f2)` is a valid pair.\\n`f1 = 1`: `f2` can be anything except `1` => `Count[f1 = 1] = 5`\\n`f1 = 2`: `f2` can be `1, 3, 5` => `Count[f1 = 2] = 3`\\n`f1 = 3`: `f2` can be `1, 2, 4, 5` => `Count[f1 = 3] = 4`\\n`f1 = 4`: `f2` can be `1, 3, 5` => `Count[f1 = 4] = 3`\\n`f1 = 5`: `f2` can be `1, 2, 3, 4, 6` => `Count[f1 = 5] = 5`\\n`f1 = 6`: `f2` can be `1, 5` => `Count[f1 = 5] = 2`\\nSumming all up, we get 22.\\n\\n# Arbitrary Case (k)\\n\\nSince the is a DP question, we want to draw `Count[k]` from `Count[k - 1]`. \\n\\n## Proposition 1:\\n**Suppose `f(k), f(k - 1), ..., f(1)` is a valid sequence, then `f(k - 1), ..., f(1)` is also a valid sequence.**\\n\\n## Proof:\\n*For Constraint 1, any `GCD(i, i + 1)` from the shorter sequence can be deduced from the longer sequence, hence they are all `1`.*\\n*Similar argument for Constraint 2.*\\n\\nSuppose we have `Count[k - 1]`. We then can consider what are the candidates for `f(k)` to form `Count[k]`. \\nFor that, we need the below argument.\\n\\n## Proposition 2:\\n**Constraint II is equivalent to the statement that, `i - j <= 2 implies f(i) != f(j)`**\\n\\n## Proof:\\n*By taking contrapositive of the original constaint.*\\n\\nWe can then reformulate the question constraint. \\n\\n## Proposition 3:\\n**`f(k), f(k - 1), ..., f(1)` is a valid sequence if and only if**\\n1. **`GCD(f(i), f(i + 1)) = 1` for i = 1, 2, ... , k - 1**\\n2. **`f(i) != f(i + 1) && f(i + 1) != f(i + 2) && f(i + 2) != f(i)` for i = 1, 2, ... , k - 2**\\n\\nHence to get `f(k)`, we only need to check `f(k - 1)` and `f(k - 2)`.\\n\\nFrom Base Case (2), this further divides the problems into 22 sub-cases.\\n1. `(f(k - 1), f(k - 2)) = (1, 2)`\\n2. `(f(k - 1), f(k - 2)) = (1, 3)`\\n3. `(f(k - 1), f(k - 2)) = (1, 4)`\\n4. `(f(k - 1), f(k - 2)) = (1, 5)`\\n5. `(f(k - 1), f(k - 2)) = (1, 6)`\\n6. `(f(k - 1), f(k - 2)) = (2, 1)`\\n7. `(f(k - 1), f(k - 2)) = (2, 3)`\\n8. `(f(k - 1), f(k - 2)) = (2, 5)`\\n9. `(f(k - 1), f(k - 2)) = (3, 1)`\\n10. `(f(k - 1), f(k - 2)) = (3, 2)`\\n11. `(f(k - 1), f(k - 2)) = (3, 4)`\\n12. `(f(k - 1), f(k - 2)) = (3, 5)`\\n13. `(f(k - 1), f(k - 2)) = (4, 1)`\\n14. `(f(k - 1), f(k - 2)) = (4, 3)`\\n15. `(f(k - 1), f(k - 2)) = (4, 5)`\\n16. `(f(k - 1), f(k - 2)) = (5, 1)`\\n17. `(f(k - 1), f(k - 2)) = (5, 2)`\\n18. `(f(k - 1), f(k - 2)) = (5, 3)`\\n19. `(f(k - 1), f(k - 2)) = (5, 4)`\\n20. `(f(k - 1), f(k - 2)) = (5, 6)`\\n21. `(f(k - 1), f(k - 2)) = (6, 1)`\\n22. `(f(k - 1), f(k - 2)) = (6, 5)`\\n\\nConsequently, we need to maintain 22 state variables at every `k`.\\n\\nThen, for example, if we want to compute for `(f(k), f(k - 1)) = (1, 2)`, we just need to check the rows that satisfy `f(k - 1) = 2` and `f(k) != f(k - 2)`.\\n```\\nCount[f(k) = 1, f(k - 1) = 2]   =   Count[f(k - 1) = 2, f(k - 2) = 3]   +   Count[f(k - 1) = 2, f(k - 2)) = 5]\\n```\\n\\nA bottom-up DP in this case will be helpful.\\nAfter computing 22 states at the last step, we simply sum them up to get the real count.\\n\\nExample C++ codes are shown below.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if (n == 1)\\n            return 6;\\n        if (n == 2)\\n            return 22;\\n        \\n        long modulo = 1000000007;\\n        \\n        // maintaining 22 states as mentioned\\n        long long memo[22];\\n        long long *x12 = &memo[0];\\n        *x12 = 1;\\n        long long *x13 = &memo[1];\\n        *x13 = 1;\\n        long long *x14 = &memo[2];\\n        *x14 = 1;\\n        long long *x15 = &memo[3];\\n        *x15 = 1;\\n        long long *x16 = &memo[4];\\n        *x16 = 1;\\n        long long *x21 = &memo[5];\\n        *x21 = 1;\\n        long long *x23 = &memo[6];\\n        *x23 = 1;\\n        long long *x25 = &memo[7];\\n        *x25 = 1;\\n        long long *x31 = &memo[8];\\n        *x31 = 1;\\n        long long *x32 = &memo[9];\\n        *x32 = 1;\\n        long long *x34 = &memo[10];\\n        *x34 = 1;\\n        long long *x35 = &memo[11];\\n        *x35 = 1;\\n        long long *x41 = &memo[12];\\n        *x41 = 1;\\n        long long *x43 = &memo[13];\\n        *x43 = 1;\\n        long long *x45 = &memo[14];\\n        *x45 = 1;\\n        long long *x51 = &memo[15];\\n        *x51 = 1;\\n        long long *x52 = &memo[16];\\n        *x52 = 1;\\n        long long *x53 = &memo[17];\\n        *x53 = 1;\\n        long long *x54 = &memo[18];\\n        *x54 = 1;\\n        long long *x56 = &memo[19];\\n        *x56 = 1;\\n        long long *x61 = &memo[20];\\n        *x61 = 1;\\n        long long *x65 = &memo[21];\\n        *x65 = 1;\\n\\n        // Updating the states by the rules stated above\\n        for (int i = 3; i <= n; i++) {\\n            long long new_x12 = (*x23 + *x25) % modulo;\\n            long long new_x13 = (*x32 + *x34 + *x35) % modulo;\\n            long long new_x14 = (*x43 + *x45) % modulo;\\n            long long new_x15 = (*x52 + *x53 + *x54 + *x56) % modulo;\\n            long long new_x16 = (*x65) % modulo;\\n            long long new_x21 = (*x13 + *x14 + *x15 + *x16) % modulo;\\n            long long new_x23 = (*x31 + *x34 + *x35) % modulo;\\n            long long new_x25 = (*x51 + *x53 + *x54 + *x56) % modulo;\\n            long long new_x31 = (*x12 + *x14 + *x15 + *x16) % modulo;\\n            long long new_x32 = (*x21 + *x25) % modulo;\\n            long long new_x34 = (*x41 + *x45) % modulo;\\n            long long new_x35 = (*x51 + *x52 + *x54 + *x56) % modulo;\\n            long long new_x41 = (*x12 + *x13 + *x15 + *x16) % modulo;\\n            long long new_x43 = (*x31 + *x32 + *x35) % modulo;\\n            long long new_x45 = (*x51 + *x52 + *x53 + *x56) % modulo;\\n            long long new_x51 = (*x12 + *x13 + *x14 + *x16) % modulo;\\n            long long new_x52 = (*x21 + *x23) % modulo;\\n            long long new_x53 = (*x31 + *x32 + *x34) % modulo;\\n            long long new_x54 = (*x41 + *x43) % modulo;\\n            long long new_x56 = (*x61) % modulo;\\n            long long new_x61 = (*x12 + *x13 + *x14 + *x15) % modulo;\\n            long long new_x65 = (*x51 + *x52 + *x53 + *x54) % modulo;\\n            *x12 = new_x12;\\n            *x13 = new_x13;\\n            *x14 = new_x14;\\n            *x15 = new_x15;\\n            *x16 = new_x16;\\n            *x21 = new_x21;\\n            *x23 = new_x23;\\n            *x25 = new_x25;\\n            *x31 = new_x31;\\n            *x32 = new_x32;\\n            *x34 = new_x34;\\n            *x35 = new_x35;\\n            *x41 = new_x41;\\n            *x43 = new_x43;\\n            *x45 = new_x45;\\n            *x51 = new_x51;\\n            *x52 = new_x52;\\n            *x53 = new_x53;\\n            *x54 = new_x54;\\n            *x56 = new_x56;\\n            *x61 = new_x61;\\n            *x65 = new_x65;\\n        }\\n\\n        // At last sum those states to get the desired count\\n        long res = 0;\\n        for (int i = 0; i < 22; i++) {\\n            res += memo[i];\\n            res %= modulo;\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nCount[f(k) = 1, f(k - 1) = 2]   =   Count[f(k - 1) = 2, f(k - 2) = 3]   +   Count[f(k - 1) = 2, f(k - 2)) = 5]\\n```\n```c++\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if (n == 1)\\n            return 6;\\n        if (n == 2)\\n            return 22;\\n        \\n        long modulo = 1000000007;\\n        \\n        // maintaining 22 states as mentioned\\n        long long memo[22];\\n        long long *x12 = &memo[0];\\n        *x12 = 1;\\n        long long *x13 = &memo[1];\\n        *x13 = 1;\\n        long long *x14 = &memo[2];\\n        *x14 = 1;\\n        long long *x15 = &memo[3];\\n        *x15 = 1;\\n        long long *x16 = &memo[4];\\n        *x16 = 1;\\n        long long *x21 = &memo[5];\\n        *x21 = 1;\\n        long long *x23 = &memo[6];\\n        *x23 = 1;\\n        long long *x25 = &memo[7];\\n        *x25 = 1;\\n        long long *x31 = &memo[8];\\n        *x31 = 1;\\n        long long *x32 = &memo[9];\\n        *x32 = 1;\\n        long long *x34 = &memo[10];\\n        *x34 = 1;\\n        long long *x35 = &memo[11];\\n        *x35 = 1;\\n        long long *x41 = &memo[12];\\n        *x41 = 1;\\n        long long *x43 = &memo[13];\\n        *x43 = 1;\\n        long long *x45 = &memo[14];\\n        *x45 = 1;\\n        long long *x51 = &memo[15];\\n        *x51 = 1;\\n        long long *x52 = &memo[16];\\n        *x52 = 1;\\n        long long *x53 = &memo[17];\\n        *x53 = 1;\\n        long long *x54 = &memo[18];\\n        *x54 = 1;\\n        long long *x56 = &memo[19];\\n        *x56 = 1;\\n        long long *x61 = &memo[20];\\n        *x61 = 1;\\n        long long *x65 = &memo[21];\\n        *x65 = 1;\\n\\n        // Updating the states by the rules stated above\\n        for (int i = 3; i <= n; i++) {\\n            long long new_x12 = (*x23 + *x25) % modulo;\\n            long long new_x13 = (*x32 + *x34 + *x35) % modulo;\\n            long long new_x14 = (*x43 + *x45) % modulo;\\n            long long new_x15 = (*x52 + *x53 + *x54 + *x56) % modulo;\\n            long long new_x16 = (*x65) % modulo;\\n            long long new_x21 = (*x13 + *x14 + *x15 + *x16) % modulo;\\n            long long new_x23 = (*x31 + *x34 + *x35) % modulo;\\n            long long new_x25 = (*x51 + *x53 + *x54 + *x56) % modulo;\\n            long long new_x31 = (*x12 + *x14 + *x15 + *x16) % modulo;\\n            long long new_x32 = (*x21 + *x25) % modulo;\\n            long long new_x34 = (*x41 + *x45) % modulo;\\n            long long new_x35 = (*x51 + *x52 + *x54 + *x56) % modulo;\\n            long long new_x41 = (*x12 + *x13 + *x15 + *x16) % modulo;\\n            long long new_x43 = (*x31 + *x32 + *x35) % modulo;\\n            long long new_x45 = (*x51 + *x52 + *x53 + *x56) % modulo;\\n            long long new_x51 = (*x12 + *x13 + *x14 + *x16) % modulo;\\n            long long new_x52 = (*x21 + *x23) % modulo;\\n            long long new_x53 = (*x31 + *x32 + *x34) % modulo;\\n            long long new_x54 = (*x41 + *x43) % modulo;\\n            long long new_x56 = (*x61) % modulo;\\n            long long new_x61 = (*x12 + *x13 + *x14 + *x15) % modulo;\\n            long long new_x65 = (*x51 + *x52 + *x53 + *x54) % modulo;\\n            *x12 = new_x12;\\n            *x13 = new_x13;\\n            *x14 = new_x14;\\n            *x15 = new_x15;\\n            *x16 = new_x16;\\n            *x21 = new_x21;\\n            *x23 = new_x23;\\n            *x25 = new_x25;\\n            *x31 = new_x31;\\n            *x32 = new_x32;\\n            *x34 = new_x34;\\n            *x35 = new_x35;\\n            *x41 = new_x41;\\n            *x43 = new_x43;\\n            *x45 = new_x45;\\n            *x51 = new_x51;\\n            *x52 = new_x52;\\n            *x53 = new_x53;\\n            *x54 = new_x54;\\n            *x56 = new_x56;\\n            *x61 = new_x61;\\n            *x65 = new_x65;\\n        }\\n\\n        // At last sum those states to get the desired count\\n        long res = 0;\\n        for (int i = 0; i < 22; i++) {\\n            res += memo[i];\\n            res %= modulo;\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195837,
                "title": "dp-c",
                "content": "Just set the first two elements by brute force and for further index call your DP solution states are simple the current number that you want to choose should not be equal to the previous two and GCD of the element to be chosen and the previous element should be one\\n```\\n#define ll long long\\nconst int nx = 1e4 + 100;\\nll dp[nx][7][7];\\nll mod;\\n\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    ll dfs(int ind, int p1, int p2) {\\n        if(ind == n) return 1;\\n        if(dp[ind][p1][p2] != -1) return dp[ind][p1][p2];\\n        \\n        ll ans = 0;\\n        for(int i = 1; i <= 6; ++i) {\\n            if(p1 != i  and p2 != i and __gcd(i, p2) == 1) ans = (ans + dfs(ind + 1, p2, i)) % mod;\\n        }\\n        \\n        return dp[ind][p1][p2] = ans;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        \\n        memset(dp, -1, sizeof dp);\\n        mod = 1e9 + 7;\\n        this->n = n;\\n        \\n        ll ans = 0;\\n        for(int i = 1; i <= 6; ++i) {\\n            for(int j = 1; j <= 6; ++j) {\\n                if(i != j and __gcd(i, j) == 1) ans = (ans + dfs(2, i, j)) % mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nconst int nx = 1e4 + 100;\\nll dp[nx][7][7];\\nll mod;\\n\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    ll dfs(int ind, int p1, int p2) {\\n        if(ind == n) return 1;\\n        if(dp[ind][p1][p2] != -1) return dp[ind][p1][p2];\\n        \\n        ll ans = 0;\\n        for(int i = 1; i <= 6; ++i) {\\n            if(p1 != i  and p2 != i and __gcd(i, p2) == 1) ans = (ans + dfs(ind + 1, p2, i)) % mod;\\n        }\\n        \\n        return dp[ind][p1][p2] = ans;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        \\n        memset(dp, -1, sizeof dp);\\n        mod = 1e9 + 7;\\n        this->n = n;\\n        \\n        ll ans = 0;\\n        for(int i = 1; i <= 6; ++i) {\\n            for(int j = 1; j <= 6; ++j) {\\n                if(i != j and __gcd(i, j) == 1) ans = (ans + dfs(2, i, j)) % mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220844,
                "title": "tabulation-simple-dp-readable-tc-o-216-n-sc-o-36",
                "content": "The solution is preety intuitive,\\nfor n = 1, distinct sequence will be 6 which sort of a base case,\\nwe proceed forward with n=2, which is giving us 22 distinct sequnece,\\n**Intution for DP**\\nwe are needed to remember that what are the previous 2 roll values are, coz condition is clear that a number can only repeat after 2 more rolls, that is  the reason, we are tabulating the last 2 rolls,\\n*for cell [0,3]* it represents that previous element was 4 and 1 is previous to 4,\\nNow DP comes into the picture, what we will do is go to the column 4 and scan all the way to last row from 1st row and maintain sum of all the elements, except row 0 for this case as it is invaid to consider this.\\n![image](https://assets.leetcode.com/users/images/dbdeb0e6-b172-41d7-903d-360c7a066c6d_1656646803.188051.png)\\n```\\nclass Solution {\\n    static long[][] dp;\\n    public int distinctSequences(int n) {\\n        if(n==1) return 6;\\n        int mod = 1_000_000_007;\\n        dp =new long[][]\\n                {\\n                    {0,1,1,1,1,1},\\n                    {1,0,1,0,1,0},\\n                    {1,1,0,1,1,0},\\n                    {1,0,1,0,1,0},\\n                    {1,1,1,1,0,1},\\n                    {1,0,0,0,1,0}\\n                };\\n        for(int i=2;i<n;i++){\\n            long[][] temp = new long[6][6];\\n            for(int j=0;j<6;j++){\\n                for(int k=0;k<6;k++){\\n                    long total = 0;\\n                    if(dp[j][k] == 0) continue;\\n                    for(int l=0;l<6;l++){\\n                        total = (total + ((l==k)?0:dp[l][j]))%mod;\\n                    }\\n                    temp[j][k] = total;\\n                }\\n            }\\n            dp = temp;\\n        }\\n        long result = 0;\\n        for(int i=0;i<6;i++){\\n            for(int j=0;j<6;j++){\\n                result = (result + dp[i][j])%mod;\\n            }\\n        }\\n        return (int)(result);\\n    }\\n}\\n```\\nHappy Leetcoding",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    static long[][] dp;\\n    public int distinctSequences(int n) {\\n        if(n==1) return 6;\\n        int mod = 1_000_000_007;\\n        dp =new long[][]\\n                {\\n                    {0,1,1,1,1,1},\\n                    {1,0,1,0,1,0},\\n                    {1,1,0,1,1,0},\\n                    {1,0,1,0,1,0},\\n                    {1,1,1,1,0,1},\\n                    {1,0,0,0,1,0}\\n                };\\n        for(int i=2;i<n;i++){\\n            long[][] temp = new long[6][6];\\n            for(int j=0;j<6;j++){\\n                for(int k=0;k<6;k++){\\n                    long total = 0;\\n                    if(dp[j][k] == 0) continue;\\n                    for(int l=0;l<6;l++){\\n                        total = (total + ((l==k)?0:dp[l][j]))%mod;\\n                    }\\n                    temp[j][k] = total;\\n                }\\n            }\\n            dp = temp;\\n        }\\n        long result = 0;\\n        for(int i=0;i<6;i++){\\n            for(int j=0;j<6;j++){\\n                result = (result + dp[i][j])%mod;\\n            }\\n        }\\n        return (int)(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197010,
                "title": "o-logn-time-o-1-space-fast-matrix-power",
                "content": "Let\\'s enumerate possible pairs of consecutive rolls. Let\\'s say total number of allowed pairs is M.\\nNow imagine matrix A of size M\\\\*M. For i-th pair (a,b) and j-th pair (c,d) the A(i,j)=1 if only b==c and sequence (a,b,d) of rolls is allowed. \\nIn other words for every allowed three consecutive rolls (a,b,c) A[index of pair (b,c)][index of pair (a,b)]=1\\nNow imagine X - verctor of size M filled with 1.\\n\\nThen A\\\\*x  - is how can many ways to get some pair of rolls as the last after 3 rolls.\\nA^n * x - is how many ways to get some pair of rolls as the last pair after (n+2) rolls.\\n\\nWe can compute n-th power of A in similar way as n-th power of number in O(logN).\\n\\nAlso tricks: we can check gcd==1 of two consecutive rolls by only checking two possible gcd values 2 and 3.\\n\\nIf there were k-sided dice then we can estimate complexity in the following way:\\npossible pairs -  O(k^2)\\nmatrix size - O(k^2)*O(k^2) = O(k^4)\\nmastrix computation O(k^2)*k = O(k^3)\\nmatrix power (O(k^2))^3 * logN = O(k^6 logN). Can be lowered by using fast matrix multiplication methos like Strassen\\'s multiplication.\\nSo time - O(k^6 logN), space - O(k^4)\\n\\n```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    private static final int k = 6, p = 1_000_000_007;\\n\\n    public int distinctSequences(int n) {\\n        if (n == 1) return 6;\\n        int counter = 0;\\n        Map<Pair, Integer> map = new HashMap<>();\\n\\t\\t//enumerate possible pairs\\n        for (int i = 1; i < k; i++) {\\n            for (int j = i + 1; j <= k; j++) {\\n                if ((i % 2 != 0 || j % 2 != 0) && (i % 3 != 0 || j % 3 != 0)) {\\n                    map.put(new Pair(i, j), counter++);\\n                    map.put(new Pair(j, i), counter++);\\n                }\\n            }\\n        }\\n\\n        if (n == 2) return counter;\\n\\n        long[][] matrix = new long[counter][counter];\\n\\t\\t//for every possible pairs (a,b) check if (a,b,c) is possible\\n\\t\\t// if so set A[index of (b,c)][index of (a,b)] = 1\\n        for (Map.Entry<Pair, Integer> entry : map.entrySet()) {\\n            int a = entry.getKey().x, b = entry.getKey().y;\\n            for (int c = 1; c <= k; c++) {\\n                if (a == c || b == c || b % 2 == 0 && c % 2 == 0 || b % 3 == 0 && c % 3 == 0) continue;\\n                matrix[map.get(new Pair(b, c))][entry.getValue()] = 1;\\n            }\\n        }\\n\\n        long[][] power = matrixPower(matrix, n - 2);\\n        int ans = 0;\\n        for (long[] row : power) {\\n            for (long a : row) {\\n                ans += a;\\n                if (ans >= p) ans -= p;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private record Pair(int x, int y) {\\n    }\\n\\n\\n    private static long[][] matrixPower(long[][] base, long pow) {\\n        int n = base.length;\\n        long[][] res = new long[n][n];\\n        for (int i = 0; i < n; i++) {\\n            res[i][i] = 1;\\n        }\\n        while (pow != 0) {\\n            if ((pow & 1) != 0) {\\n                res = multiplyMatrix(res, base);\\n                --pow;\\n            } else {\\n                base = multiplyMatrix(base, base);\\n                pow >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private static long[][] multiplyMatrix(long[][] a, long[][] b) {\\n        int n = a.length;\\n        long[][] ans = new long[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < n; k++) {\\n                    ans[i][j] += a[i][k] * b[k][j];\\n                    if (ans[i][j] >= p) ans[i][j] %= p; // remove if not modular\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    private static final int k = 6, p = 1_000_000_007;\\n\\n    public int distinctSequences(int n) {\\n        if (n == 1) return 6;\\n        int counter = 0;\\n        Map<Pair, Integer> map = new HashMap<>();\\n\\t\\t//enumerate possible pairs\\n        for (int i = 1; i < k; i++) {\\n            for (int j = i + 1; j <= k; j++) {\\n                if ((i % 2 != 0 || j % 2 != 0) && (i % 3 != 0 || j % 3 != 0)) {\\n                    map.put(new Pair(i, j), counter++);\\n                    map.put(new Pair(j, i), counter++);\\n                }\\n            }\\n        }\\n\\n        if (n == 2) return counter;\\n\\n        long[][] matrix = new long[counter][counter];\\n\\t\\t//for every possible pairs (a,b) check if (a,b,c) is possible\\n\\t\\t// if so set A[index of (b,c)][index of (a,b)] = 1\\n        for (Map.Entry<Pair, Integer> entry : map.entrySet()) {\\n            int a = entry.getKey().x, b = entry.getKey().y;\\n            for (int c = 1; c <= k; c++) {\\n                if (a == c || b == c || b % 2 == 0 && c % 2 == 0 || b % 3 == 0 && c % 3 == 0) continue;\\n                matrix[map.get(new Pair(b, c))][entry.getValue()] = 1;\\n            }\\n        }\\n\\n        long[][] power = matrixPower(matrix, n - 2);\\n        int ans = 0;\\n        for (long[] row : power) {\\n            for (long a : row) {\\n                ans += a;\\n                if (ans >= p) ans -= p;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private record Pair(int x, int y) {\\n    }\\n\\n\\n    private static long[][] matrixPower(long[][] base, long pow) {\\n        int n = base.length;\\n        long[][] res = new long[n][n];\\n        for (int i = 0; i < n; i++) {\\n            res[i][i] = 1;\\n        }\\n        while (pow != 0) {\\n            if ((pow & 1) != 0) {\\n                res = multiplyMatrix(res, base);\\n                --pow;\\n            } else {\\n                base = multiplyMatrix(base, base);\\n                pow >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private static long[][] multiplyMatrix(long[][] a, long[][] b) {\\n        int n = a.length;\\n        long[][] ans = new long[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < n; k++) {\\n                    ans[i][j] += a[i][k] * b[k][j];\\n                    if (ans[i][j] >= p) ans[i][j] %= p; // remove if not modular\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196216,
                "title": "easy-bottom-up-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        long long DP[10005][7][7]={0};\\n        if(n==1)\\n            return 6;\\n        int ans;\\n        //set the bottom\\n        for(int i=1;i<7;i++)\\n        {\\n            for(int j=1;j<7;j++)\\n            {\\n                if(i==j||gcd(i,j)!=1)\\n                    DP[2][i][j]=0;\\n                else\\n                    DP[2][i][j]=1;\\n            }\\n        }\\n        for(int i=3;i<=n;i++)\\n        {\\n            for(int j=1;j<7;j++)\\n            {\\n                for(int k=1;k<7;k++)\\n                {\\n                    for(int h=1;h<7;h++)\\n                    {\\n                        if(k==j||h==j||gcd(k,j)!=1)\\n                            continue;\\n                        DP[i][k][j] +=DP[i-1][h][k];\\n                    }\\n                    DP[i][k][j]%=1000000007;\\n                }\\n            }\\n        }\\n        long long a=0;\\n        for(int i=1;i<7;i++)\\n        {\\n            for(int j=1;j<7;j++)\\n            {\\n                a+=DP[n][i][j];\\n            }\\n        }\\n        a%=1000000007;\\n        ans=a;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        long long DP[10005][7][7]={0};\\n        if(n==1)\\n            return 6;\\n        int ans;\\n        //set the bottom\\n        for(int i=1;i<7;i++)\\n        {\\n            for(int j=1;j<7;j++)\\n            {\\n                if(i==j||gcd(i,j)!=1)\\n                    DP[2][i][j]=0;\\n                else\\n                    DP[2][i][j]=1;\\n            }\\n        }\\n        for(int i=3;i<=n;i++)\\n        {\\n            for(int j=1;j<7;j++)\\n            {\\n                for(int k=1;k<7;k++)\\n                {\\n                    for(int h=1;h<7;h++)\\n                    {\\n                        if(k==j||h==j||gcd(k,j)!=1)\\n                            continue;\\n                        DP[i][k][j] +=DP[i-1][h][k];\\n                    }\\n                    DP[i][k][j]%=1000000007;\\n                }\\n            }\\n        }\\n        long long a=0;\\n        for(int i=1;i<7;i++)\\n        {\\n            for(int j=1;j<7;j++)\\n            {\\n                a+=DP[n][i][j];\\n            }\\n        }\\n        a%=1000000007;\\n        ans=a;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338079,
                "title": "dp-3d-c-well-explained",
                "content": "# Intuition\\nWe have n times to roll the dice \\nEach time the dice can have values from [1-----6]\\n\\nWe have to check for two condition \\n\\nIf we are ith point \\n\\nKeep a check of i-1 and i-2 move\\n\\nBecause __gcd(i move , i-1 move) == 1 \\nand i!=i-1 move\\nand i!=i-2 move\\n\\n\\n# Approach\\nWe will use a 3D dp matrix\\nWhy 3D \\n\\nBecause we have 3 changing variables \\n1 ind (current move)\\n2 prev (previous move)\\n3 previous of previous \\n\\n\\nAt i th move we have to 6 options \\n\\nAnd for each move , we have to check for its validity \\n```\\n\\nfor(int i = 1;i<=6;i++)\\n{\\n    //my current move can have 6 options \\n    //each of my option has to satisfy the given       constraint\\n\\n                if(p1!=i && p2!=i && (p1 == 0 || __gcd(p1 , i) ==1))\\n        {\\n            ans = ans+solve(dp , n , ind+1 , i , p1);\\n        }\\n}\\n\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nO(36N) approximatly $$O(n)$$\\n- Space complexity:\\nO(36N) approximatly $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int distinctSequences(int n) {\\n        vector<vector<vector<int>>> dp(n+1 , vector<vector<int>>(7 , vector<int>(7 , -1)));\\n        return solve(dp , n , 0 , 0 , 0);\\n    }\\n    //we have three varying parameters\\n    //ind , prev , prev1\\n    //dp 3d dp is required\\n\\n    int solve(vector<vector<vector<int>>> &dp , int n , int ind , int p1 ,int p2)\\n    {\\n        if(ind == n)\\n            return 1;\\n        if(dp[ind][p1][p2]!=-1)\\n            return dp[ind][p1][p2];\\n        long long ans = 0;\\n        for(int i = 1;i<=6;i++)\\n        {\\n            if(p1 != i && p2 != i && (p1 == 0 || __gcd(p1 , i) == 1))\\n            {\\n                //we can use this i , since it satisfies all the condition \\n                ans = (ans%mod+(long long)solve(dp , n , ind+1 , i , p1)%mod)%mod;\\n            }\\n        }\\n        return dp[ind][p1][p2]= ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nfor(int i = 1;i<=6;i++)\\n{\\n    //my current move can have 6 options \\n    //each of my option has to satisfy the given       constraint\\n\\n                if(p1!=i && p2!=i && (p1 == 0 || __gcd(p1 , i) ==1))\\n        {\\n            ans = ans+solve(dp , n , ind+1 , i , p1);\\n        }\\n}\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int distinctSequences(int n) {\\n        vector<vector<vector<int>>> dp(n+1 , vector<vector<int>>(7 , vector<int>(7 , -1)));\\n        return solve(dp , n , 0 , 0 , 0);\\n    }\\n    //we have three varying parameters\\n    //ind , prev , prev1\\n    //dp 3d dp is required\\n\\n    int solve(vector<vector<vector<int>>> &dp , int n , int ind , int p1 ,int p2)\\n    {\\n        if(ind == n)\\n            return 1;\\n        if(dp[ind][p1][p2]!=-1)\\n            return dp[ind][p1][p2];\\n        long long ans = 0;\\n        for(int i = 1;i<=6;i++)\\n        {\\n            if(p1 != i && p2 != i && (p1 == 0 || __gcd(p1 , i) == 1))\\n            {\\n                //we can use this i , since it satisfies all the condition \\n                ans = (ans%mod+(long long)solve(dp , n , ind+1 , i , p1)%mod)%mod;\\n            }\\n        }\\n        return dp[ind][p1][p2]= ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253898,
                "title": "c-very-easy-and-simple",
                "content": "class Solution {\\npublic:\\n\\n    int mod=1e9+7;\\n    int dp[10001][7][7];\\n    int distinctSequences(int n) {\\n        memset(dp ,-1, sizeof dp);\\n        return solve(0,n,0,0);\\n    }\\n    int solve(int cnt ,int n ,int prev ,int secprev ){\\n        if(cnt == n)\\n            return 1;\\n        if(dp[cnt][prev][secprev]!=-1)\\n            return dp[cnt][prev][secprev];\\n        int ans=0;\\n        for(int i=1;i<=6;i++){\\n            if(prev == 0 || (prev != i  && secprev!=i && __gcd(i,prev)==1))\\n                ans=((ans%mod)+(solve(cnt+1,n,i,prev)%mod))%mod;\\n               \\n        }\\n        return dp[cnt][prev][secprev]=ans%mod;\\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int mod=1e9+7;\\n    int dp[10001][7][7];\\n    int distinctSequences(int n) {\\n        memset(dp ,-1, sizeof dp);\\n        return solve(0,n,0,0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2219708,
                "title": "dp-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    // dp state -> pos (10^4) - prev_outcome (6) - prev_prev_outcome (6)\\n    const int m = 1e9+7;\\n    int dp[10001][7][7];\\n    unordered_map<int,vector<int>>poss;\\n    \\n    int go(int pos,int prev,int pprev, int& n) {\\n        if(pos==n)\\n            return 1;\\n        if(dp[pos][prev][pprev]!=-1)\\n            return dp[pos][prev][pprev];\\n        int ans = 0;\\n        for(int p:poss[prev]) {\\n            if(p!=pprev) {\\n                ans = ((ans%m) + (go(pos+1, p, prev, n)%m))%m;\\n            }\\n        }\\n        return dp[pos][prev][pprev] = ans;\\n    }\\n    int distinctSequences(int n) {\\n        int ans=0;\\n        \\n        poss[1] = {2,3,4,5,6};\\n        poss[2] = {1,3,5};\\n        poss[3] = {1,2,4,5};\\n        poss[4] = {1,3,5};\\n        poss[5] = {1,2,3,4,6};\\n        poss[6] = {1,5};\\n        memset(dp, -1, sizeof(dp));\\n        \\n        for(int i=1;i<=6;i++) {\\n            ans = (ans%m+go(1,i,0,n))%m;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // dp state -> pos (10^4) - prev_outcome (6) - prev_prev_outcome (6)\\n    const int m = 1e9+7;\\n    int dp[10001][7][7];\\n    unordered_map<int,vector<int>>poss;\\n    \\n    int go(int pos,int prev,int pprev, int& n) {\\n        if(pos==n)\\n            return 1;\\n        if(dp[pos][prev][pprev]!=-1)\\n            return dp[pos][prev][pprev];\\n        int ans = 0;\\n        for(int p:poss[prev]) {\\n            if(p!=pprev) {\\n                ans = ((ans%m) + (go(pos+1, p, prev, n)%m))%m;\\n            }\\n        }\\n        return dp[pos][prev][pprev] = ans;\\n    }\\n    int distinctSequences(int n) {\\n        int ans=0;\\n        \\n        poss[1] = {2,3,4,5,6};\\n        poss[2] = {1,3,5};\\n        poss[3] = {1,2,4,5};\\n        poss[4] = {1,3,5};\\n        poss[5] = {1,2,3,4,6};\\n        poss[6] = {1,5};\\n        memset(dp, -1, sizeof(dp));\\n        \\n        for(int i=1;i<=6;i++) {\\n            ans = (ans%m+go(1,i,0,n))%m;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209568,
                "title": "python-faster-than-99",
                "content": "```\\n@lru_cache(None)\\ndef f(i,a,b):\\n    if i==0:return 1\\n    ans=0\\n    for j in range(1,7):\\n        if (j not in (a,b)) and (b==-1 or gcd(j,b)==1):\\n            ans+=f(i-1,b,j)\\n    return ans%(10**9+7)\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        return f(n,-1,-1)\\n```",
                "solutionTags": [],
                "code": "```\\n@lru_cache(None)\\ndef f(i,a,b):\\n    if i==0:return 1\\n    ans=0\\n    for j in range(1,7):\\n        if (j not in (a,b)) and (b==-1 or gcd(j,b)==1):\\n            ans+=f(i-1,b,j)\\n    return ans%(10**9+7)\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        return f(n,-1,-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204516,
                "title": "simple-explanation-to-understand",
                "content": "Just think! It is clearly visible that it is dp.\\n\\n[...., prev, num, next, next-next .....]\\n\\nInitially precalculate the adj vector of all the numbers 1-6 to know what are the numbers having gcd == 1 associated with each one.\\n\\nSince the difference between index of next-next and prev element is > 2, so the we have to maintain a dp of current index, current dice value(num) and previous element. As these are the parameters using which we can uniquely identify the value of a [idx, num, prev] and this thing can be repeated, that is why we are making a dp for it.\\n\\nPlease **upvote ^** if you like the post!\\n\\nNow, just code it recursively as it is easy.\\n\\n```\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    vector<vector<int>> adj = {{1, 2, 3, 4, 5, 6}, {2, 3, 4, 5, 6}, {1, 3, 5}, {1, 2, 4, 5}, {1, 3, 5}, {1, 2, 3, 4, 6}, {1, 5}};\\n    vector<vector<vector<int>>> dp;\\n    \\n    int calc(int idx, int num, int prev, int n){\\n        if(idx == n)\\n            return 1;\\n        \\n        if(dp[idx][num][prev] != -1)\\n            return dp[idx][num][prev];\\n            \\n        int ans = 0;\\n        for(auto j: adj[num])\\n            if(j != prev)\\n                ans = (ans + calc(idx + 1, j, num, n)) % m;\\n        \\n        return dp[idx][num][prev] = ans;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        dp = vector<vector<vector<int>>> (n + 2, vector<vector<int>>(7, vector<int>(7, -1)));\\n        return calc(0, 0, 0, n);\\n    }\\n};\\n```\\n\\nAnd you are done! Yes it is that simple \\uD83D\\uDE00.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    vector<vector<int>> adj = {{1, 2, 3, 4, 5, 6}, {2, 3, 4, 5, 6}, {1, 3, 5}, {1, 2, 4, 5}, {1, 3, 5}, {1, 2, 3, 4, 6}, {1, 5}};\\n    vector<vector<vector<int>>> dp;\\n    \\n    int calc(int idx, int num, int prev, int n){\\n        if(idx == n)\\n            return 1;\\n        \\n        if(dp[idx][num][prev] != -1)\\n            return dp[idx][num][prev];\\n            \\n        int ans = 0;\\n        for(auto j: adj[num])\\n            if(j != prev)\\n                ans = (ans + calc(idx + 1, j, num, n)) % m;\\n        \\n        return dp[idx][num][prev] = ans;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        dp = vector<vector<vector<int>>> (n + 2, vector<vector<int>>(7, vector<int>(7, -1)));\\n        return calc(0, 0, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197145,
                "title": "java-solution",
                "content": "EXPLAINATION :- \\n\\n1. It would require a DP solution because the possibilities are endless (*well, they are finite but intuitively*).\\n2. Figuring out the number of states :- 3 states i.e. The current dice number, the previous dice number and the number of throws already performed.\\n3. Current And Previous dice numbers are variables because once we throw a number (say 2) we can\\'t throw it the next time and the next - next time. Which means (2, 2, 2) is not possible. (Though (2, any, any, 2) is valid. The question forbids throwing the same number twice after it shows up first )\\n\\nIt took me a while to figure out that the number of throws is also a variable. Although I considered it as a variable in my recursive approach, I couldn\\'t see how it would affect DP (which is non-trivially silly). So, I had to sketch the case which could clear my doubt. Sketch follows...\\n\\n**(NOTE :- I only sketched and explored the throws relevant to understand)**\\n\\n![image](https://assets.leetcode.com/users/images/3b7f4613-6107-40e0-b405-4edd22cd7945_1656184032.177827.jpeg)\\n\\n**Number of throws is an important variable.** In above example, had we ignored the number of throws, the answer of [1][2] becomes 7 every time a dice shows up 1 followed by 2, which is wrong. [1][2] = 7 is valid only if [1] showed up the very first time followed by [2] on second throw.\\nIf [1] shows up third followed by [2] on the last throw (considering n = 4), we can\\'t quote 7 as the resulting answer of [1][2] in this scenario. Because, this time after the dice showed up [2], our throws exhausted. \\n\\n```\\nclass Solution {\\n    \\n    public static int[][] arr = {{}, {2,3,4,5,6},{1,3,5},{1,2,4,5},{1,3,5},{1,2,3,4,6},{1,5}};\\n    \\n    int[][][] dp = new int[10001][7][7];\\n    \\n    int mod = 1000000007;\\n    \\n    public int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        \\n        int ans = 0;\\n        for(int i=1;i<=6;i++){\\n            ans = add(ans, memo(2,n,i,0));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int memo(int roll, int n, int curr, int prev){\\n        if(roll > n)\\n            return 1;\\n        \\n        if(dp[roll][curr][prev] != 0) return dp[roll][curr][prev];\\n        \\n        int ans = 0;\\n        for(int i=0;i<arr[curr].length; i++){\\n            if(arr[curr][i] == prev) continue;\\n            ans = add(ans, memo(roll + 1, n, arr[curr][i], curr));\\n        }\\n        \\n        return dp[roll][curr][prev] = ans;\\n    }\\n    \\n    public int add(int a, int b){\\n        return ( (a % mod) + (b % mod) ) % mod;\\n    }\\n    \\n}\\n```\\n\\n# Code-Through :- \\n\\n**1. Signature of memo function :-**\\n\\n**roll ==>** roll means the \"about to be\" roll. For example, roll = 2 would mean that 1 roll has already occured. Now it\\'s time to roll the dice 2nd time.\\n**n ==>** n means the number of rolls allowed. When roll exceeds n, it means we can\\'t roll anymore. And, since we can\\'t roll anymore, it also means that we reached this point through a valid roll sequence. Hence, return 1 on behalf of the roll sequence.\\n**curr ==>** curr means the number which is currently appearing on the dice. In the for loop, we are exploring all the possibilities that the curr dice has.\\n**prev ==>** prev means that before curr show-up, the dice showed prev. In the for loop, we don\\'t calculate the answer when curr equals prev. (Remember, we can\\'t throw prev until next throw)\\n\\t\\t\\n*If you got the solution, GOOD. Otherwise, keep rolling, you\\'ll get it !*",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static int[][] arr = {{}, {2,3,4,5,6},{1,3,5},{1,2,4,5},{1,3,5},{1,2,3,4,6},{1,5}};\\n    \\n    int[][][] dp = new int[10001][7][7];\\n    \\n    int mod = 1000000007;\\n    \\n    public int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        \\n        int ans = 0;\\n        for(int i=1;i<=6;i++){\\n            ans = add(ans, memo(2,n,i,0));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int memo(int roll, int n, int curr, int prev){\\n        if(roll > n)\\n            return 1;\\n        \\n        if(dp[roll][curr][prev] != 0) return dp[roll][curr][prev];\\n        \\n        int ans = 0;\\n        for(int i=0;i<arr[curr].length; i++){\\n            if(arr[curr][i] == prev) continue;\\n            ans = add(ans, memo(roll + 1, n, arr[curr][i], curr));\\n        }\\n        \\n        return dp[roll][curr][prev] = ans;\\n    }\\n    \\n    public int add(int a, int b){\\n        return ( (a % mod) + (b % mod) ) % mod;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196179,
                "title": "cpp-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    # define ll long long\\n    ll dp[10004][7][7];\\n    ll mod =1e9+7;\\n    int find(int i,int prev1,int prev2,int n,map<int,vector<int>>&mp)\\n    {\\n        if(i==n+1)return 1;\\n        if(dp[i][prev1][prev2]!=-1)return dp[i][prev1][prev2];\\n        ll ans=0;\\n        for(auto&p:mp[prev1])\\n        {\\n            if(p==prev1||p==prev2)continue;\\n            ans=(ans+find(i+1,p,prev1,n,mp))%mod;\\n        }\\n        return dp[i][prev1][prev2]=ans;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        map<int,vector<int>>mp;\\n        mp[0]={1,2,3,4,5,6};\\n        mp[1]={2,3,4,5,6};\\n        mp[2]={3,5,1};\\n        mp[3]={4,5,1,2};\\n        mp[4]={1,3,5};\\n        mp[5]={1,2,3,4,6};\\n        mp[6]={1,5};\\n        return find(1,0,0,n,mp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    # define ll long long\\n    ll dp[10004][7][7];\\n    ll mod =1e9+7;\\n    int find(int i,int prev1,int prev2,int n,map<int,vector<int>>&mp)\\n    {\\n        if(i==n+1)return 1;\\n        if(dp[i][prev1][prev2]!=-1)return dp[i][prev1][prev2];\\n        ll ans=0;\\n        for(auto&p:mp[prev1])\\n        {\\n            if(p==prev1||p==prev2)continue;\\n            ans=(ans+find(i+1,p,prev1,n,mp))%mod;\\n        }\\n        return dp[i][prev1][prev2]=ans;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        map<int,vector<int>>mp;\\n        mp[0]={1,2,3,4,5,6};\\n        mp[1]={2,3,4,5,6};\\n        mp[2]={3,5,1};\\n        mp[3]={4,5,1,2};\\n        mp[4]={1,3,5};\\n        mp[5]={1,2,3,4,6};\\n        mp[6]={1,5};\\n        return find(1,0,0,n,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196122,
                "title": "c-dp-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // state - index , prev, prev of prev\\n    long long dp[10003][7][7];\\n    const int mod = 1e9+7;\\n    int n;\\n    \\n    // mp[i] will store valid values for i\\n    map<int,vector<int>> mp;\\n    \\n    long long rec(int level,int prev,int prevv){\\n        // base case , if choice made for n index return 1\\n        if(level == n){\\n            return 1;\\n        }\\n        \\n        if(dp[level][prev][prevv] != -1) return dp[level][prev][prevv];\\n        \\n        long long ans = 0;\\n        \\n        // some case work for transition\\n        if(prev==0 && prevv ==0){\\n            for(int i=1;i<=6;i++){\\n                ans+=rec(level+1,i,0);\\n                ans%=mod;\\n            }\\n        }\\n        else if(prevv == 0){\\n            for(int choice:mp[prev]){\\n               if(choice !=prev) ans+=rec(level+1,choice,prev);\\n                ans%=mod;\\n            }\\n        }\\n        else{\\n            for(int choice:mp[prev]){\\n                if(choice != prev && choice !=prevv){\\n                    ans+=rec(level+1,choice,prev);\\n                    ans%=mod;\\n                }\\n            }\\n        }\\n        \\n        return dp[level][prev][prevv] = ans;\\n    }\\n    \\n    int distinctSequences(int _n) {\\n        n = _n;\\n        memset(dp,-1,sizeof(dp));\\n        // finding valid values for each number from 1 to 6\\n        for(int i=1;i<=6;i++){\\n            for(int j=1;j<=6;j++){\\n                if(__gcd(i,j) == 1) mp[i].push_back(j);\\n            }\\n        }\\n        long long ans = rec(0,0,0);\\n        ans%=mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // state - index , prev, prev of prev\\n    long long dp[10003][7][7];\\n    const int mod = 1e9+7;\\n    int n;\\n    \\n    // mp[i] will store valid values for i\\n    map<int,vector<int>> mp;\\n    \\n    long long rec(int level,int prev,int prevv){\\n        // base case , if choice made for n index return 1\\n        if(level == n){\\n            return 1;\\n        }\\n        \\n        if(dp[level][prev][prevv] != -1) return dp[level][prev][prevv];\\n        \\n        long long ans = 0;\\n        \\n        // some case work for transition\\n        if(prev==0 && prevv ==0){\\n            for(int i=1;i<=6;i++){\\n                ans+=rec(level+1,i,0);\\n                ans%=mod;\\n            }\\n        }\\n        else if(prevv == 0){\\n            for(int choice:mp[prev]){\\n               if(choice !=prev) ans+=rec(level+1,choice,prev);\\n                ans%=mod;\\n            }\\n        }\\n        else{\\n            for(int choice:mp[prev]){\\n                if(choice != prev && choice !=prevv){\\n                    ans+=rec(level+1,choice,prev);\\n                    ans%=mod;\\n                }\\n            }\\n        }\\n        \\n        return dp[level][prev][prevv] = ans;\\n    }\\n    \\n    int distinctSequences(int _n) {\\n        n = _n;\\n        memset(dp,-1,sizeof(dp));\\n        // finding valid values for each number from 1 to 6\\n        for(int i=1;i<=6;i++){\\n            for(int j=1;j<=6;j++){\\n                if(__gcd(i,j) == 1) mp[i].push_back(j);\\n            }\\n        }\\n        long long ans = rec(0,0,0);\\n        ans%=mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196023,
                "title": "python-dp-memo",
                "content": "```\\nmod=1000000007\\n@cache\\ndef func(n,prev,pp):\\n    if n==0:\\n        return 1\\n    ans=0\\n    for i in range(1,7):\\n        if prev==-1:\\n            ans+=func(n-1,i,prev)\\n            ans=ans%mod\\n        elif pp==-1:\\n            if(math.gcd(i,prev)==1 and i!=prev):\\n                ans+=func(n-1,i,prev)\\n                ans=ans%mod\\n        else:\\n            if(math.gcd(i,prev)==1 and i!=prev and i!=pp):\\n                ans+=func(n-1,i,prev)\\n                ans=ans%mod\\n    return ans;\\nclass Solution:\\n    \\n            \\n    def distinctSequences(self, n: int) -> int:\\n        return func(n,-1,-1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nmod=1000000007\\n@cache\\ndef func(n,prev,pp):\\n    if n==0:\\n        return 1\\n    ans=0\\n    for i in range(1,7):\\n        if prev==-1:\\n            ans+=func(n-1,i,prev)\\n            ans=ans%mod\\n        elif pp==-1:\\n            if(math.gcd(i,prev)==1 and i!=prev):\\n                ans+=func(n-1,i,prev)\\n                ans=ans%mod\\n        else:\\n            if(math.gcd(i,prev)==1 and i!=prev and i!=pp):\\n                ans+=func(n-1,i,prev)\\n                ans=ans%mod\\n    return ans;\\nclass Solution:\\n    \\n            \\n    def distinctSequences(self, n: int) -> int:\\n        return func(n,-1,-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195931,
                "title": "python3-clear-top-down-dp",
                "content": "## Idea\\nUse memoization (e.g. `cache`, `lru_cache`) to store number of combinations of length `rem` that can come after each pair.\\nHandle edge case of `n == 1` to return `6`.\\n\\n## FAQ\\n- Why do we consider only two elements for memoization?\\n-- because you only need to look back for the last two elements. Given by requirement `abs(i - j) > 2` for every `i` and `j` indices of the combination that has same roll. Also, considering 3 or more makes the problem more complicated and waste the effort.\\n- Why do we use memoization?\\n-- To avoid repeated calculation\\n\\n## Time and Memory Complexity\\n`O(n)` for memory because we need to store constant * `n` combinations in the cache! (what is constant?)\\nLet me know of the time-complexity in the comments!\\n\\n## Code\\n```python\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        mod = 1_000_000_007\\n        # edge case\\n        if n == 1: return 6\\n        # to create possible adjacent pairs\\n        next_option = {\\n            1: (2, 3, 4, 5, 6),\\n            2: (1, 3, 5),\\n            3: (1, 2, 4, 5),\\n            4: (1, 3, 5),\\n            5: (1, 2, 3, 4, 6),\\n            6: (1, 5)\\n        }\\n        # create dictionary where the key is allowed adjacent pairs and the value is list of third elment after the pair\\n        allowed_third = defaultdict(list)\\n        for i, j, k in product(list(range(1, 7)), repeat=3):\\n            if k != i and j in next_option[i] and k in next_option[j]:\\n                allowed_third[(i, j)] += k,\\n        # memoize the answers\\n        @cache\\n        def get_help(i, j, rem):\\n            ans = 0\\n            if rem == 0:\\n                return 1\\n            for k in allowed_third[(i, j)]:\\n                ans += get_help(j, k, rem - 1) % mod\\n            return ans\\n        ans = 0\\n        \\n        for i, j in allowed_third:\\n            ans += get_help(i, j, n - 2) % mod\\n        return ans % mod\\n```\\n\\n## Feedback\\nI appreciate your feedback and support!\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        mod = 1_000_000_007\\n        # edge case\\n        if n == 1: return 6\\n        # to create possible adjacent pairs\\n        next_option = {\\n            1: (2, 3, 4, 5, 6),\\n            2: (1, 3, 5),\\n            3: (1, 2, 4, 5),\\n            4: (1, 3, 5),\\n            5: (1, 2, 3, 4, 6),\\n            6: (1, 5)\\n        }\\n        # create dictionary where the key is allowed adjacent pairs and the value is list of third elment after the pair\\n        allowed_third = defaultdict(list)\\n        for i, j, k in product(list(range(1, 7)), repeat=3):\\n            if k != i and j in next_option[i] and k in next_option[j]:\\n                allowed_third[(i, j)] += k,\\n        # memoize the answers\\n        @cache\\n        def get_help(i, j, rem):\\n            ans = 0\\n            if rem == 0:\\n                return 1\\n            for k in allowed_third[(i, j)]:\\n                ans += get_help(j, k, rem - 1) % mod\\n            return ans\\n        ans = 0\\n        \\n        for i, j in allowed_third:\\n            ans += get_help(i, j, n - 2) % mod\\n        return ans % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195897,
                "title": "dp-solution-top-down",
                "content": "for every n we can take 6 values.While taking 6 values there is 3 condition\\n1. if n == 0 (means first value) - can take any value\\n2. elif n == 1 (means second value) - just check last value ,we cant add same value and also check gcd\\n3. else check prev and pprev value not same and gcd of prev value\\n```\\nclass Solution {\\nprivate:\\n    int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n        return b;\\n        if (b == 0)\\n        return a;\\n  \\n        if (a == b)\\n            return a;\\n  \\n        if (a > b)\\n            return gcd(a-b, b);\\n        return gcd(a, b-a);\\n    }\\n\\tlong long dfs(int n,int index,int prev,int pprev,vector<vector<vector<long long>>> &dp) {\\n        \\n        if(index == n) return 1;\\n        if(dp[index][prev][pprev] != -1) return dp[index][prev][pprev];\\n        \\n        long long ans = 0;\\n\\t\\t\\n        for(int i=1;i<=6;i++) {\\n\\t\\t\\n            if(index == 0) {\\n                ans += dfs(n,index+1,i,pprev,dp);\\n                ans%= 1000000007;\\n\\t\\t\\t\\t\\n            }else if(index == 1) {\\n\\t\\t\\t\\n                if(prev == i) continue;\\n                if(gcd(prev,i) != 1) continue;\\n                ans += dfs(n,index+1,i,prev,dp); \\n                ans%= 1000000007;\\n\\n            }else{\\n\\t\\t\\t\\n                if(prev == i or pprev == i) continue;\\n                if(gcd(prev,i) != 1) continue;\\n                ans += dfs(n,index+1,i,prev,dp);  \\n                 ans%= 1000000007;\\n\\n            }\\n        }\\n        \\n        return dp[index][prev][pprev] = ans%1000000007;\\n    }\\npublic:\\n    int distinctSequences(int n) {\\n        int prev = 0;\\n        int pprev = 0;\\n        vector<vector<vector<long long>>> dp(n,vector<vector<long long>>(7,vector<long long>(7,-1)));\\n        long long ans = dfs(n,0,prev,pprev,dp);\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n        return b;\\n        if (b == 0)\\n        return a;\\n  \\n        if (a == b)\\n            return a;\\n  \\n        if (a > b)\\n            return gcd(a-b, b);\\n        return gcd(a, b-a);\\n    }\\n\\tlong long dfs(int n,int index,int prev,int pprev,vector<vector<vector<long long>>> &dp) {\\n        \\n        if(index == n) return 1;\\n        if(dp[index][prev][pprev] != -1) return dp[index][prev][pprev];\\n        \\n        long long ans = 0;\\n\\t\\t\\n        for(int i=1;i<=6;i++) {\\n\\t\\t\\n            if(index == 0) {\\n                ans += dfs(n,index+1,i,pprev,dp);\\n                ans%= 1000000007;\\n\\t\\t\\t\\t\\n            }else if(index == 1) {\\n\\t\\t\\t\\n                if(prev == i) continue;\\n                if(gcd(prev,i) != 1) continue;\\n                ans += dfs(n,index+1,i,prev,dp); \\n                ans%= 1000000007;\\n\\n            }else{\\n\\t\\t\\t\\n                if(prev == i or pprev == i) continue;\\n                if(gcd(prev,i) != 1) continue;\\n                ans += dfs(n,index+1,i,prev,dp);  \\n                 ans%= 1000000007;\\n\\n            }\\n        }\\n        \\n        return dp[index][prev][pprev] = ans%1000000007;\\n    }\\npublic:\\n    int distinctSequences(int n) {\\n        int prev = 0;\\n        int pprev = 0;\\n        vector<vector<vector<long long>>> dp(n,vector<vector<long long>>(7,vector<long long>(7,-1)));\\n        long long ans = dfs(n,0,prev,pprev,dp);\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195835,
                "title": "c-3-states-dp-with-explanation",
                "content": "**Approach:**\\nDp states are positions, previous element, and current element.\\n**base case:**\\nif reaches the last position then return `1`\\n\\nNow I have to check the first and second condition.\\n1. first the second conditon, we can\\'t place a same value with index difference of `2`. So like this case `(1, 2, 1, 3)`, we can\\'t place `1` in `2nd` position, because `1` is placed on `0th` position so difference is `2`. `prev` and `curr` will haldle this case. If my previous element is equal to which I am currently positioning this place. So if `prev == i` then continue\\n2. For second condition, we have to check the gcd and current and positioning elemement and sum up all the valid cases.\\n\\n**Time:**  `O(N * 7 * 7) ~ O(49N), N = Given number`\\n**Space:** `O(N * 7 * 7) ~ O(49N)`\\n```\\nclass Solution {\\nprivate:\\n    long dp[10005][7][7];\\n    int n;\\n    int mod = 1e9 + 7;\\npublic:\\n    long solve(int pos, int prev, int curr){\\n        if(pos == n - 1) return 1l;\\n        long &ret = dp[pos][prev][curr];\\n        if(ret != -1) return ret;\\n        ret = 0;\\n        for(int i = 1; i < 7; i++){\\n            if(i == prev) continue;\\n            if(curr != i && __gcd(curr, i) == 1){\\n                ret = (ret + solve(pos + 1, curr, i)) % mod;\\n            }\\n        }\\n        return ret;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp, -1l, sizeof dp);\\n        long ans = 0;\\n        this->n = n;\\n        for(int i = 1; i < 7; i++){\\n            ans = (ans + solve(0, 0, i)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long dp[10005][7][7];\\n    int n;\\n    int mod = 1e9 + 7;\\npublic:\\n    long solve(int pos, int prev, int curr){\\n        if(pos == n - 1) return 1l;\\n        long &ret = dp[pos][prev][curr];\\n        if(ret != -1) return ret;\\n        ret = 0;\\n        for(int i = 1; i < 7; i++){\\n            if(i == prev) continue;\\n            if(curr != i && __gcd(curr, i) == 1){\\n                ret = (ret + solve(pos + 1, curr, i)) % mod;\\n            }\\n        }\\n        return ret;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp, -1l, sizeof dp);\\n        long ans = 0;\\n        this->n = n;\\n        for(int i = 1; i < 7; i++){\\n            ans = (ans + solve(0, 0, i)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053533,
                "title": "c-3-d-dp-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will have 3 variables that change values within the recursive calls. i will keep track of the number of dice rolls. j keeps track of the previous roll value and k keeps track of the second prev roll value. When j == 0, we can consider any value from 1 to 6. When k ==0, we will consider only those values from 1 to 6 which are not equal to j and gcd(j, curr_val) == 1. Else we will consider only those values where curr_val != j && curr_val != k && gcd(curr_val, j) == 1. Our base case is when our number of rolls equals n. We will return 1 since we found a valid roll sequence. To reduce the time complexity from exponential to O(n ^3), we maintain a 3-D dp vector and instantly return the value stored in the vector if the ans of that particular sub-problem has already been calculated.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n\\n    int dp[10000 + 1][7][7];\\n\\n    int solve(int i, int j, int k, int n) {\\n\\n        if(i == n) return 1;\\n\\n        if(dp[i][j][k] != -1) return dp[i][j][k];\\n\\n        int ans = 0;\\n\\n        if(j == 0) {\\n\\n            for(int l = 1; l <= 6; l++) {\\n\\n                ans = (ans + solve(i + 1, l, k, n)) % mod;\\n            }\\n        \\n        }\\n        \\n        else if(k == 0) {\\n\\n            for(int l = 1; l <= 6; l++) {\\n\\n                if((__gcd(l, j) == 1) && (l != j)) {\\n\\n                    ans = (ans + solve(i + 1, l, j, n)) % mod;\\n                \\n                }\\n\\n            }\\n        }\\n\\n        else {\\n\\n            for(int l = 1; l <= 6; l++) {\\n\\n                if((__gcd(l, j) == 1) && (l != j) && (l != k)) ans = (ans + solve(i + 1, l, j, n)) % mod;\\n            \\n            }\\n\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    \\n    int distinctSequences(int n) {\\n\\n        //vector<vector<vector<int>>> dp (n, vector<vector<int>> (7, vector<int> (7, -1)));\\n\\n        memset(dp, -1, sizeof dp);\\n\\n        return solve(0, 0, 0, n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n\\n    int dp[10000 + 1][7][7];\\n\\n    int solve(int i, int j, int k, int n) {\\n\\n        if(i == n) return 1;\\n\\n        if(dp[i][j][k] != -1) return dp[i][j][k];\\n\\n        int ans = 0;\\n\\n        if(j == 0) {\\n\\n            for(int l = 1; l <= 6; l++) {\\n\\n                ans = (ans + solve(i + 1, l, k, n)) % mod;\\n            }\\n        \\n        }\\n        \\n        else if(k == 0) {\\n\\n            for(int l = 1; l <= 6; l++) {\\n\\n                if((__gcd(l, j) == 1) && (l != j)) {\\n\\n                    ans = (ans + solve(i + 1, l, j, n)) % mod;\\n                \\n                }\\n\\n            }\\n        }\\n\\n        else {\\n\\n            for(int l = 1; l <= 6; l++) {\\n\\n                if((__gcd(l, j) == 1) && (l != j) && (l != k)) ans = (ans + solve(i + 1, l, j, n)) % mod;\\n            \\n            }\\n\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    \\n    int distinctSequences(int n) {\\n\\n        //vector<vector<vector<int>>> dp (n, vector<vector<int>> (7, vector<int> (7, -1)));\\n\\n        memset(dp, -1, sizeof dp);\\n\\n        return solve(0, 0, 0, n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287344,
                "title": "c-4ms-faster-than-100",
                "content": "just precompute everything boi\\n\\n```\\n#pragma clang attribute push (__attribute__((no_sanitize(\"address\",\"undefined\"))), apply_to=function)\\n\\nconst int mod = 1E9 + 7;\\n\\nint dp[10001][7][7];\\n\\nauto $ = [] {\\n    for (int p = 0; p <= 6; p++)\\n        for (int q = 0; q <= 6; q++)\\n            dp[0][p][q] = 1;\\n    \\n    for (int i = 1; i <= 10000; i++) {\\n        for (int p = 0; p <= 6; p++) {\\n            for (int q = 0; q <= 6; q++) {\\n                auto& ans = dp[i][p][q];\\n                if (p != 1 && q != 1)\\n                    (ans += dp[i - 1][q][1]) %= mod;\\n                if (p != 2 && q != 2 && q != 4 && q != 6)\\n                    (ans += dp[i - 1][q][2]) %= mod;\\n                if (p != 3 && q != 3 && q != 6)\\n                    (ans += dp[i - 1][q][3]) %= mod;\\n                if (p != 4 && q != 2 && q != 4 && q != 6)\\n                    (ans += dp[i - 1][q][4]) %= mod;\\n                if (p != 5 && q != 5)\\n                    (ans += dp[i - 1][q][5]) %= mod;\\n                if (p != 6 && q != 2 && q != 3 && q != 4 && q != 6)\\n                    (ans += dp[i - 1][q][6]) %= mod;\\n            }\\n        }\\n    }\\n    \\n    return ios::sync_with_stdio(0), cin.tie(0), 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        return dp[n][0][0];\\n    }\\n};\\n\\n#pragma clang attribute pop\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#pragma clang attribute push (__attribute__((no_sanitize(\"address\",\"undefined\"))), apply_to=function)\\n\\nconst int mod = 1E9 + 7;\\n\\nint dp[10001][7][7];\\n\\nauto $ = [] {\\n    for (int p = 0; p <= 6; p++)\\n        for (int q = 0; q <= 6; q++)\\n            dp[0][p][q] = 1;\\n    \\n    for (int i = 1; i <= 10000; i++) {\\n        for (int p = 0; p <= 6; p++) {\\n            for (int q = 0; q <= 6; q++) {\\n                auto& ans = dp[i][p][q];\\n                if (p != 1 && q != 1)\\n                    (ans += dp[i - 1][q][1]) %= mod;\\n                if (p != 2 && q != 2 && q != 4 && q != 6)\\n                    (ans += dp[i - 1][q][2]) %= mod;\\n                if (p != 3 && q != 3 && q != 6)\\n                    (ans += dp[i - 1][q][3]) %= mod;\\n                if (p != 4 && q != 2 && q != 4 && q != 6)\\n                    (ans += dp[i - 1][q][4]) %= mod;\\n                if (p != 5 && q != 5)\\n                    (ans += dp[i - 1][q][5]) %= mod;\\n                if (p != 6 && q != 2 && q != 3 && q != 4 && q != 6)\\n                    (ans += dp[i - 1][q][6]) %= mod;\\n            }\\n        }\\n    }\\n    \\n    return ios::sync_with_stdio(0), cin.tie(0), 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        return dp[n][0][0];\\n    }\\n};\\n\\n#pragma clang attribute pop\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748493,
                "title": "c-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int memo[7][7][10001];\\n    int distinctSequences(int n) {\\n        memset(memo, -1, sizeof(memo));\\n        return dp(n, 0, 0);\\n    }\\n    int dp(int n, int prev2, int prev1){\\n        if(!n)\\n            return 1;\\n        if(memo[prev1][prev2][n] != -1)\\n            return memo[prev1][prev2][n];\\n        int res = 0;\\n        for(int i = 1; i <= 6; i++)\\n            if(i != prev2 && i != prev1 && (prev1 == 0 || gcd(i, prev1) == 1))\\n                res += dp(n - 1, prev1, i) % MOD, res %= MOD;\\n        return memo[prev1][prev2][n] = res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int memo[7][7][10001];\\n    int distinctSequences(int n) {\\n        memset(memo, -1, sizeof(memo));\\n        return dp(n, 0, 0);\\n    }\\n    int dp(int n, int prev2, int prev1){\\n        if(!n)\\n            return 1;\\n        if(memo[prev1][prev2][n] != -1)\\n            return memo[prev1][prev2][n];\\n        int res = 0;\\n        for(int i = 1; i <= 6; i++)\\n            if(i != prev2 && i != prev1 && (prev1 == 0 || gcd(i, prev1) == 1))\\n                res += dp(n - 1, prev1, i) % MOD, res %= MOD;\\n        return memo[prev1][prev2][n] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730950,
                "title": "simple-o-n-time-o-1-space-complexity-solution-beats-99-and-96",
                "content": "The i th element in list L(t) represents number of valid sequences ending with i+1 after t rolls.\\n\\nTo move forward, for example, in the next step t+1, the number of sequences ending in 2 is:\\n\\nL(t+1)[1] = L(t)[0]+L(t)[2]+L(t)[4] - 3*L(t-1)[1]\\n\\nsince 2 is coprime with 1, 3, 5. \\n\\nThe reason of subtracting 3*L(t-1)[1] is that each of L(t)[0],  L(t)[2],  L(t)[4] contains sequences ending in 2 from previous step, which make the sequences invalid.\\n\\nSo far the solution is close but still not correct, the reason is that   L(t)[0] does not include all of  L(t-1)[1], but only the part excluding L(t-2)[0], so on and so forth. \\n\\nthe correct solution is:\\n\\nL(t+1)[1] = L(t)[0]+L(t)[2]+L(t)[4] - 3*L(t-1)[1] + L(t-2)[0]+L(t-2)[2]+L(t-2)[4] - 3*L(t-3)[1] + ...\\n\\nsimilar to inclusion exclusion principle in Probability.\\n\\nTo simplify the solution, we notice that this infinite sum\\n\\nL(t-2)[0]+L(t-2)[2]+L(t-2)[4] - 3*L(t-3)[1] + ...\\n\\nis just L(t-1)[1]!\\n\\nso we have a closed form solution:\\n\\nL(t+1)[1] = L(t)[0]+L(t)[2]+L(t)[4] - 2*L(t-1)[1]\\n\\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        \\n        l1 = [5, 3, 4, 3, 5, 2]\\n        l2 = [12, 11, 12, 11, 12, 8]\\n\\n        \\n        if n==1:\\n            return 6\\n        if n==2:\\n            return sum(l1)\\n        \\n        mod = 10**9+7\\n        for i in range(n-3):\\n            \\n            temp = [0]*6\\n            \\n            temp[0] = (sum(l2[1:]) - 4*l1[0] )%mod\\n            \\n            temp[1] = (l2[0]+l2[2]+l2[4] - 2*l1[1])%mod\\n           \\n            temp[2] = (l2[0]+l2[1]+l2[3]+l2[4] - 3*l1[2] )%mod\\n            \\n            temp[3] = (l2[0]+l2[2]+l2[4] - 2*l1[3])%mod\\n            \\n            temp[4] = (sum(l2[:4])+l2[5] - 4*l1[4])%mod\\n            \\n            temp[5] = (l2[0]+l2[4] - 1*l1[5] )%mod\\n            \\n            l1, l2 = l2, temp\\n\\n        return sum(l2)%mod\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        \\n        l1 = [5, 3, 4, 3, 5, 2]\\n        l2 = [12, 11, 12, 11, 12, 8]\\n\\n        \\n        if n==1:\\n            return 6\\n        if n==2:\\n            return sum(l1)\\n        \\n        mod = 10**9+7\\n        for i in range(n-3):\\n            \\n            temp = [0]*6\\n            \\n            temp[0] = (sum(l2[1:]) - 4*l1[0] )%mod\\n            \\n            temp[1] = (l2[0]+l2[2]+l2[4] - 2*l1[1])%mod\\n           \\n            temp[2] = (l2[0]+l2[1]+l2[3]+l2[4] - 3*l1[2] )%mod\\n            \\n            temp[3] = (l2[0]+l2[2]+l2[4] - 2*l1[3])%mod\\n            \\n            temp[4] = (sum(l2[:4])+l2[5] - 4*l1[4])%mod\\n            \\n            temp[5] = (l2[0]+l2[4] - 1*l1[5] )%mod\\n            \\n            l1, l2 = l2, temp\\n\\n        return sum(l2)%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513054,
                "title": "python-2318",
                "content": "\\tclass Solution:\\n\\t\\tdef distinctSequences(self, n: int) -> int:\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dfs(rem,prev,prevprev):\\n\\t\\t\\t\\tif rem == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\t\\tans = 0\\n\\n\\t\\t\\t\\tfor i in range(1,7):\\n\\t\\t\\t\\t\\tif i != prev and i != prevprev and (prev == 0 or math.gcd(prev,i) == 1):\\n\\t\\t\\t\\t\\t\\tans += dfs(rem-1,i,prev)\\n\\t\\t\\t\\t\\t\\tans %= mod\\n\\t\\t\\t\\treturn ans%mod\\n\\n\\t\\t\\treturn dfs(n,0,0)%mod",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef distinctSequences(self, n: int) -> int:\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dfs(rem,prev,prevprev):\\n\\t\\t\\t\\tif rem == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\t\\tans = 0\\n\\n\\t\\t\\t\\tfor i in range(1,7):\\n\\t\\t\\t\\t\\tif i != prev and i != prevprev and (prev == 0 or math.gcd(prev,i) == 1):\\n\\t\\t\\t\\t\\t\\tans += dfs(rem-1,i,prev)\\n\\t\\t\\t\\t\\t\\tans %= mod\\n\\t\\t\\t\\treturn ans%mod\\n\\n\\t\\t\\treturn dfs(n,0,0)%mod",
                "codeTag": "Java"
            },
            {
                "id": 2254158,
                "title": "c-memoization-3d-without-explaination",
                "content": "```\\n int distinctSequences(int n) {\\n        x=n;\\n        auto count=f(0,0,0);\\n        count%=M;\\n        return count;\\n    }\\n    \\n    private:\\n    int dp[10005][8][8]={};\\n    int M=1e9 + 7;\\n    int x;\\n    int f(int idx,int SecondLast, int last){       \\n        if(idx==x) return 1;\\n        \\n        if(dp[idx][SecondLast][last]) return dp[idx][SecondLast][last];\\n        \\n        int ans=0;\\n        for(int i=1;i<=6;i++){\\n            if(i==last || i==SecondLast) continue;    \\n            if(last!=0 and __gcd(last,i)!=1) continue;\\n            \\n            ans+= f(idx+1,last,i);\\n            ans%=M;\\n        }\\n        return dp[idx][SecondLast][last]=ans%M;\\n    }\\n```\\n**Time- O(n x6 x6)\\nSpace- O(n x7 x7) ~O(n)**",
                "solutionTags": [],
                "code": "```\\n int distinctSequences(int n) {\\n        x=n;\\n        auto count=f(0,0,0);\\n        count%=M;\\n        return count;\\n    }\\n    \\n    private:\\n    int dp[10005][8][8]={};\\n    int M=1e9 + 7;\\n    int x;\\n    int f(int idx,int SecondLast, int last){       \\n        if(idx==x) return 1;\\n        \\n        if(dp[idx][SecondLast][last]) return dp[idx][SecondLast][last];\\n        \\n        int ans=0;\\n        for(int i=1;i<=6;i++){\\n            if(i==last || i==SecondLast) continue;    \\n            if(last!=0 and __gcd(last,i)!=1) continue;\\n            \\n            ans+= f(idx+1,last,i);\\n            ans%=M;\\n        }\\n        return dp[idx][SecondLast][last]=ans%M;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2232885,
                "title": "o-n-tabulation-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    typedef long double ld;\\n#define vi(x) vector<x>\\n    typedef pair<ll, vi(ll)> pi;\\n#define li(x) list<x>\\n#define pb push_back\\n    const ll mod = 1e9 + 7;\\n    const char nl = \\'\\\\n\\';\\n\\n    ll sum(const vi(ll)& v, ll j) {\\n        ll res = 0;\\n        for (ll i = 0;i < v.size();++i)\\n            if (i != j)\\n                res = (res + v[i]) % mod;\\n        return res;\\n    }\\n\\n    int distinctSequences(ll n) {\\n        if (n == 1)\\n            return 6;\\n        vi(vi(ll))dp(6);\\n        dp[0] = { 0,1,1,1,1,1 };\\n        dp[1] = { 1,0,1,0,1,0 };\\n        dp[2] = { 1,1,0,1,1,0 };\\n        dp[3] = { 1,0,1,0,1,0 };\\n        dp[4] = { 1,1,1,1,0,1 };\\n        dp[5] = { 1,0,0,0,1,0 };\\n        for (ll i = 3;i <= n;++i) {\\n            vi(vi(ll))tmp(6, vi(ll)(6));\\n            for (ll j = 0;j < 6;++j) {\\n                for (ll k = 0;k < 6;++k)\\n                    if (j != k && gcd(j + 1, k + 1) == 1)\\n                        tmp[j][k] = sum(dp[k], j);\\n            }\\n            dp = tmp;\\n        }\\n        ll ans = 0;\\n        for (const vi(ll)& it : dp)\\n            for (const ll& ti : it)\\n                ans = (ans + ti) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    typedef long double ld;\\n#define vi(x) vector<x>\\n    typedef pair<ll, vi(ll)> pi;\\n#define li(x) list<x>\\n#define pb push_back\\n    const ll mod = 1e9 + 7;\\n    const char nl = \\'\\\\n\\';\\n\\n    ll sum(const vi(ll)& v, ll j) {\\n        ll res = 0;\\n        for (ll i = 0;i < v.size();++i)\\n            if (i != j)\\n                res = (res + v[i]) % mod;\\n        return res;\\n    }\\n\\n    int distinctSequences(ll n) {\\n        if (n == 1)\\n            return 6;\\n        vi(vi(ll))dp(6);\\n        dp[0] = { 0,1,1,1,1,1 };\\n        dp[1] = { 1,0,1,0,1,0 };\\n        dp[2] = { 1,1,0,1,1,0 };\\n        dp[3] = { 1,0,1,0,1,0 };\\n        dp[4] = { 1,1,1,1,0,1 };\\n        dp[5] = { 1,0,0,0,1,0 };\\n        for (ll i = 3;i <= n;++i) {\\n            vi(vi(ll))tmp(6, vi(ll)(6));\\n            for (ll j = 0;j < 6;++j) {\\n                for (ll k = 0;k < 6;++k)\\n                    if (j != k && gcd(j + 1, k + 1) == 1)\\n                        tmp[j][k] = sum(dp[k], j);\\n            }\\n            dp = tmp;\\n        }\\n        ll ans = 0;\\n        for (const vi(ll)& it : dp)\\n            for (const ll& ti : it)\\n                ans = (ans + ti) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225751,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> hcf;\\n    int dp[10004][7][7];\\n    int mod = 1e9 + 7;\\n\\n    int gcd(int a, int b) {\\n        if (a == 0) return b;\\n        if (b == 0) return a;\\n\\n        return a > b ? gcd(b, a % b) : gcd(a, b % a);\\n    }\\n\\n    int solve(int i, int prev, int pre_prev, int &n) {\\n        if (i == n) return 1;\\n\\n        int ans = 0;\\n        if (prev != -1 && pre_prev != -1 && dp[i][prev][pre_prev] != -1) return dp[i][prev][pre_prev];\\n        for (int x = 1; x <= 6; x++) {\\n            if ((i == 0) || (x != prev && x != pre_prev && hcf[x][prev] == 1)) {\\n                int res = solve(i + 1, x, prev, n);\\n                ans += res;\\n                ans %= mod;\\n            }\\n        }\\n\\n        if (prev != -1 && pre_prev != -1) dp[i][prev][pre_prev] = ans;\\n        return ans;\\n    }\\n    int distinctSequences(int n) {\\n\\n        hcf.resize(7, vector<int> (7));\\n        memset(dp, -1, sizeof(dp));\\n\\n        for (int i = 1; i <= 6; i++) {\\n            for (int j = 1; j <= 6; j++) {\\n                if (i == 1 || j == 1) hcf[i][j] = 1;\\n                else if (i == 0 || j == 0) hcf[i][j] = i + j;\\n                else hcf[i][j] = gcd(i, j);\\n            }\\n        }\\n\\n        return solve(0, -1, -1, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> hcf;\\n    int dp[10004][7][7];\\n    int mod = 1e9 + 7;\\n\\n    int gcd(int a, int b) {\\n        if (a == 0) return b;\\n        if (b == 0) return a;\\n\\n        return a > b ? gcd(b, a % b) : gcd(a, b % a);\\n    }\\n\\n    int solve(int i, int prev, int pre_prev, int &n) {\\n        if (i == n) return 1;\\n\\n        int ans = 0;\\n        if (prev != -1 && pre_prev != -1 && dp[i][prev][pre_prev] != -1) return dp[i][prev][pre_prev];\\n        for (int x = 1; x <= 6; x++) {\\n            if ((i == 0) || (x != prev && x != pre_prev && hcf[x][prev] == 1)) {\\n                int res = solve(i + 1, x, prev, n);\\n                ans += res;\\n                ans %= mod;\\n            }\\n        }\\n\\n        if (prev != -1 && pre_prev != -1) dp[i][prev][pre_prev] = ans;\\n        return ans;\\n    }\\n    int distinctSequences(int n) {\\n\\n        hcf.resize(7, vector<int> (7));\\n        memset(dp, -1, sizeof(dp));\\n\\n        for (int i = 1; i <= 6; i++) {\\n            for (int j = 1; j <= 6; j++) {\\n                if (i == 1 || j == 1) hcf[i][j] = 1;\\n                else if (i == 0 || j == 0) hcf[i][j] = i + j;\\n                else hcf[i][j] = gcd(i, j);\\n            }\\n        }\\n\\n        return solve(0, -1, -1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207071,
                "title": "java-3d-or-2d-dp-bottom-up-97-speed",
                "content": "because we care about the last 2 numbers in the sequence, we need a state for each of them.\\n- `dp[i][j][k]` means the number of valid sequences at `i+1` th roll, and end with `j` and `k`, with `k` being the last.\\n- To speed things up a bit, we can create a 2D array caching the numbers with `gcd(i,j) = 0`.\\n- We can make it 2D by creating a new 2D array for each roll. \\n```Java\\nclass Solution {\\n    public int distinctSequences(int n) {\\n        if (n==1)\\n            return 6;\\n        int[][][] dp = new int[n][7][7];\\n        int M = (int)1e9+7;\\n        int[][] valid = {\\n            {},\\n            {1, 2, 3, 4, 5, 6}, // gcd(1, x) = 1\\n            {1, 3, 5},          // gcd(2, x) = 1\\n            {1, 2, 4, 5},       // gcd(3, x) = 1\\n            {1, 3, 5},\\n            {1, 2, 3, 4, 6},\\n            {1, 5}\\n        };\\n        for (int i = 1; i <= 6; i++){ // base case\\n            for (int j : valid[i]){\\n                if (j!=i){\\n                    dp[0][j][i]=1;\\n                }\\n            }\\n        }\\n        for (int i = 1; i < n-1; i++){       // for each roll\\n            for (int j = 1; j <= 6; j++){    // for each ending number\\n                for (int k : valid[j]){      // for each last valid number\\n                    for (int m : valid[k]){  // for each 2nd to last valid number\\n                        if (k!=m&&j!=k&&j!=m){ // if they are not the same,\\n                            dp[i][k][j]=(dp[i][k][j]+dp[i-1][m][k])%M; // update the count\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        long ans = 0;\\n        for (int i = 1; i <= 6; i++){\\n            for (int j = 1; j <= 6; j++){\\n                ans += dp[n-2][i][j];\\n            }\\n        }\\n        return (int)(ans % M);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int distinctSequences(int n) {\\n        if (n==1)\\n            return 6;\\n        int[][][] dp = new int[n][7][7];\\n        int M = (int)1e9+7;\\n        int[][] valid = {\\n            {},\\n            {1, 2, 3, 4, 5, 6}, // gcd(1, x) = 1\\n            {1, 3, 5},          // gcd(2, x) = 1\\n            {1, 2, 4, 5},       // gcd(3, x) = 1\\n            {1, 3, 5},\\n            {1, 2, 3, 4, 6},\\n            {1, 5}\\n        };\\n        for (int i = 1; i <= 6; i++){ // base case\\n            for (int j : valid[i]){\\n                if (j!=i){\\n                    dp[0][j][i]=1;\\n                }\\n            }\\n        }\\n        for (int i = 1; i < n-1; i++){       // for each roll\\n            for (int j = 1; j <= 6; j++){    // for each ending number\\n                for (int k : valid[j]){      // for each last valid number\\n                    for (int m : valid[k]){  // for each 2nd to last valid number\\n                        if (k!=m&&j!=k&&j!=m){ // if they are not the same,\\n                            dp[i][k][j]=(dp[i][k][j]+dp[i-1][m][k])%M; // update the count\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        long ans = 0;\\n        for (int i = 1; i <= 6; i++){\\n            for (int j = 1; j <= 6; j++){\\n                ans += dp[n-2][i][j];\\n            }\\n        }\\n        return (int)(ans % M);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202377,
                "title": "why-this-fails",
                "content": "My solution looks too correct to be true; Spend hours but cannot find why it fails. It is super intuitive.\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        map<int, vector<int>> m;\\n        m[1] = {2,3,4,5,6};\\n        m[2] = {1,3,5};\\n        m[3] = {1,2,4,5};\\n        m[4] = {1,3,5};\\n        m[5] = {1,2,3,4,6};\\n        m[6] = {1,5};\\n        VVI dp(n, VI(7, 0));\\n        for(int i=1;i<7;i++) dp[0][i]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<7;j++){\\n                for(auto prev: m[j]){\\n                    dp[i][j] += (dp[i-1][prev] - (i-2 >=0 ? dp[i-2][j] : 0));\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=1;i<7;i++) ans += dp[n-1][i];\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        map<int, vector<int>> m;\\n        m[1] = {2,3,4,5,6};\\n        m[2] = {1,3,5};\\n        m[3] = {1,2,4,5};\\n        m[4] = {1,3,5};\\n        m[5] = {1,2,3,4,6};\\n        m[6] = {1,5};\\n        VVI dp(n, VI(7, 0));\\n        for(int i=1;i<7;i++) dp[0][i]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<7;j++){\\n                for(auto prev: m[j]){\\n                    dp[i][j] += (dp[i-1][prev] - (i-2 >=0 ? dp[i-2][j] : 0));\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=1;i<7;i++) ans += dp[n-1][i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202092,
                "title": "c-bottom-up-dp-o-216-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n    int distinctSequences(int n) {\\n        if(n == 1){\\n            return 6;\\n        }\\n        \\n        vector<vector<long long>> dp(6, vector<long long> (6));\\n        vector<vector<long long>> temp(6, vector<long long> (6));\\n        \\n        int i, j, k, l;\\n        const int mod = 1e9 + 7;\\n\\n        for(i = 0; i < 6; i++){\\n            for(j = 0; j < 6; j++){\\n                if(gcd(i + 1, j + 1) == 1 && i != j){\\n                    dp[i][j]++;\\n                }\\n            }\\n        }\\n        \\n        for(i = 1; i < n - 1; i++){\\n            for(j = 0; j < 6; j++){\\n                for(k = 0; k < 6; k++){\\n                    if(gcd(j + 1, k + 1) == 1 && j != k){\\n                        for(l = 0; l < 6; l++){\\n                            if(gcd(l + 1, j + 1) == 1 && l != j && l != k){\\n                                temp[j][k] += dp[l][j];\\n                                temp[j][k] %= mod;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            dp = temp;\\n            for(j = 0; j < 6; j++){\\n                for(k = 0; k < 6; k++){\\n                    temp[j][k] = 0;\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(i = 0; i < 6; i++){\\n            for(j = 0; j < 6; j++){\\n                ans += dp[i][j];\\n                ans %= mod;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n    int distinctSequences(int n) {\\n        if(n == 1){\\n            return 6;\\n        }\\n        \\n        vector<vector<long long>> dp(6, vector<long long> (6));\\n        vector<vector<long long>> temp(6, vector<long long> (6));\\n        \\n        int i, j, k, l;\\n        const int mod = 1e9 + 7;\\n\\n        for(i = 0; i < 6; i++){\\n            for(j = 0; j < 6; j++){\\n                if(gcd(i + 1, j + 1) == 1 && i != j){\\n                    dp[i][j]++;\\n                }\\n            }\\n        }\\n        \\n        for(i = 1; i < n - 1; i++){\\n            for(j = 0; j < 6; j++){\\n                for(k = 0; k < 6; k++){\\n                    if(gcd(j + 1, k + 1) == 1 && j != k){\\n                        for(l = 0; l < 6; l++){\\n                            if(gcd(l + 1, j + 1) == 1 && l != j && l != k){\\n                                temp[j][k] += dp[l][j];\\n                                temp[j][k] %= mod;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            dp = temp;\\n            for(j = 0; j < 6; j++){\\n                for(k = 0; k < 6; k++){\\n                    temp[j][k] = 0;\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(i = 0; i < 6; i++){\\n            for(j = 0; j < 6; j++){\\n                ans += dp[i][j];\\n                ans %= mod;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200676,
                "title": "c-dp-bottom-up-iteration-easy-to-understand-with-explain",
                "content": "Sadly, I couldn\\'t solve this in contest...\\n\\n```\\n        public int DistinctSequences(int n)\\n        {\\n            long res = 0;\\n            long mod = 10_0000_0007;\\n\\t\\t\\t//init non-GCD dictionary either same dictionary\\n\\t\\t\\t//eg. for 1, all [1,6] meet the GCD<=1 rule , but 1 is same , so dict[1] = {2,3,4,5,6}\\n            Dictionary<int, List<int>> dict = new Dictionary<int, List<int>>();\\n            dict.Add(1, new List<int>() { 2, 3, 4, 5, 6 });\\n            dict.Add(2, new List<int>() { 1, 3, 5, });\\n            dict.Add(3, new List<int>() { 1, 2, 4, 5 });\\n            dict.Add(4, new List<int>() { 1, 3, 5 });\\n            dict.Add(5, new List<int>() { 1, 2, 3, 4, 6 });\\n            dict.Add(6, new List<int>() { 1, 5, });\\n\\t\\t\\t\\n\\t\\t\\t//must use 3D matrix array, init seed data\\n            long[,,] dp = new long[n + 1,7,7];\\n            for(int i=1;i<=6;i++)\\n                dp[1, i, i] = 1;// normally index1 cannot equal index2, this is a tricky\\n\\n\\t\\t    //i is round\\n            for (int i = 2; i <= n; i++)\\n            {\\n\\t\\t\\t    //j means current number\\n                for (int j = 1; j <= 6; j++)\\n                {\\n\\t\\t\\t\\t    //k means that last row number, eg dp[i,j,k] came from dp[i-1,k,x], x cannot be j due to abs(i,j)>2 rule\\n                    for(int k=1;k<=6; k++)\\n                    {\\n                        if (!dict[j].Contains(k)) continue;\\n                        for (int l = 1; l <= 6; l++)\\n                        {\\n                            if (l == j) continue;//no need check l==k, this will make the tricky work\\n                            dp[i, j, k] += dp[i - 1, k, l];\\n                            dp[i, j, k] %= mod;\\n                        }\\n                    }\\n                }\\n            }\\n            for (int i=1;i<=6;i++)\\n            {\\n                for(int j = 1; j <= 6; j++)\\n                {\\n                    res = (res + dp[n,i,j]) % mod;// sum of all last round\\n                }\\n            }\\n            return (int)((res + mod) % mod);\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public int DistinctSequences(int n)\\n        {\\n            long res = 0;\\n            long mod = 10_0000_0007;\\n\\t\\t\\t//init non-GCD dictionary either same dictionary\\n\\t\\t\\t//eg. for 1, all [1,6] meet the GCD<=1 rule , but 1 is same , so dict[1] = {2,3,4,5,6}\\n            Dictionary<int, List<int>> dict = new Dictionary<int, List<int>>();\\n            dict.Add(1, new List<int>() { 2, 3, 4, 5, 6 });\\n            dict.Add(2, new List<int>() { 1, 3, 5, });\\n            dict.Add(3, new List<int>() { 1, 2, 4, 5 });\\n            dict.Add(4, new List<int>() { 1, 3, 5 });\\n            dict.Add(5, new List<int>() { 1, 2, 3, 4, 6 });\\n            dict.Add(6, new List<int>() { 1, 5, });\\n\\t\\t\\t\\n\\t\\t\\t//must use 3D matrix array, init seed data\\n            long[,,] dp = new long[n + 1,7,7];\\n            for(int i=1;i<=6;i++)\\n                dp[1, i, i] = 1;// normally index1 cannot equal index2, this is a tricky\\n\\n\\t\\t    //i is round\\n            for (int i = 2; i <= n; i++)\\n            {\\n\\t\\t\\t    //j means current number\\n                for (int j = 1; j <= 6; j++)\\n                {\\n\\t\\t\\t\\t    //k means that last row number, eg dp[i,j,k] came from dp[i-1,k,x], x cannot be j due to abs(i,j)>2 rule\\n                    for(int k=1;k<=6; k++)\\n                    {\\n                        if (!dict[j].Contains(k)) continue;\\n                        for (int l = 1; l <= 6; l++)\\n                        {\\n                            if (l == j) continue;//no need check l==k, this will make the tricky work\\n                            dp[i, j, k] += dp[i - 1, k, l];\\n                            dp[i, j, k] %= mod;\\n                        }\\n                    }\\n                }\\n            }\\n            for (int i=1;i<=6;i++)\\n            {\\n                for(int j = 1; j <= 6; j++)\\n                {\\n                    res = (res + dp[n,i,j]) % mod;// sum of all last round\\n                }\\n            }\\n            return (int)((res + mod) % mod);\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2197322,
                "title": "easy-and-intuitive-solution-clean-and-crisp-code",
                "content": "```\\nclass Solution {\\n    int mod = 1000000000 +7;\\n    public int distinctSequences(int n) {\\n        \\n        if(n == 1) return 6; // Corner case\\n                \\n        Integer dp[][][] = new Integer[n][7][7];\\n        \\n        int ans = 0;\\n        for(int i=1; i<=6; i++){\\n            for(int j=1; j<=6; j++){ // reverse iteration from n-1\\n                if(i != j && gcd(i, j) == 1) ans = (ans + solve(n-1, i, j, dp)) % mod; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int solve(int i, int cur, int prev, Integer dp[][][]){\\n        \\n        if(i == 1) return 1; // only 1 pair possible\\n        \\n        if(dp[i][cur][prev] != null) return dp[i][cur][prev];\\n        \\n        int count = 0;\\n        for(int x=1; x<=6; x++){\\n            if(x != prev && x != cur && gcd(x, cur) == 1){ // given conditions\\n                count = (count + solve(i-1, x, cur, dp)) % mod;\\n            }\\n        }\\n        \\n        return dp[i][cur][prev] = count;\\n    }\\n    \\n    \\n    public static int gcd(int a, int b){\\n        \\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000000 +7;\\n    public int distinctSequences(int n) {\\n        \\n        if(n == 1) return 6; // Corner case\\n                \\n        Integer dp[][][] = new Integer[n][7][7];\\n        \\n        int ans = 0;\\n        for(int i=1; i<=6; i++){\\n            for(int j=1; j<=6; j++){ // reverse iteration from n-1\\n                if(i != j && gcd(i, j) == 1) ans = (ans + solve(n-1, i, j, dp)) % mod; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int solve(int i, int cur, int prev, Integer dp[][][]){\\n        \\n        if(i == 1) return 1; // only 1 pair possible\\n        \\n        if(dp[i][cur][prev] != null) return dp[i][cur][prev];\\n        \\n        int count = 0;\\n        for(int x=1; x<=6; x++){\\n            if(x != prev && x != cur && gcd(x, cur) == 1){ // given conditions\\n                count = (count + solve(i-1, x, cur, dp)) % mod;\\n            }\\n        }\\n        \\n        return dp[i][cur][prev] = count;\\n    }\\n    \\n    \\n    public static int gcd(int a, int b){\\n        \\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197302,
                "title": "dp-solution-in-easy-way",
                "content": "```\\nclass Solution {\\npublic:\\n    #define MOD 1000000007\\n    int dp[10001][7][7];\\n    int f(int idx,int last,int slast,int n){\\n        if(idx>=n)return 1;\\n        if(dp[idx][last][slast]!=-1)return dp[idx][last][slast];\\n        int ans=0;\\n        for(int i=1;i<=6;i++){\\n            if(idx==0){\\n                ans=(ans+f(idx+1,i,0,n))%MOD;\\n            }\\n            else{\\n                if(__gcd(i,last)==1 && i!=last && i!=slast){\\n                    ans=(ans+f(idx+1,i,last,n))%MOD;\\n                }\\n            }\\n        }\\n        return dp[idx][last][slast]= ans%MOD;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof dp);\\n        int ans=f(0,0,0,n)%MOD;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    #define MOD 1000000007\\n    int dp[10001][7][7];\\n    int f(int idx,int last,int slast,int n){\\n        if(idx>=n)return 1;\\n        if(dp[idx][last][slast]!=-1)return dp[idx][last][slast];\\n        int ans=0;\\n        for(int i=1;i<=6;i++){\\n            if(idx==0){\\n                ans=(ans+f(idx+1,i,0,n))%MOD;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2197109,
                "title": "java-dfs-memorization-faster-than-100",
                "content": "```java\\nclass Solution {\\n    List<Integer>[][] next;\\n    int[][][] memo;\\n    public int distinctSequences(int n) {\\n        next = new ArrayList[7][7];\\n        for(int i = 0; i <= 6; i++){\\n            for(int j = 0; j <= 6; j++){\\n                next[i][j] = getValidNext(i, j);\\n            }\\n        }\\n        memo = new int[7][7][10001];\\n        return count(n, 0, 0);\\n    }\\n    \\n    private int count(int n, int x, int y){\\n        if(n == 0) return 1;\\n        if(memo[x][y][n] != 0) return memo[x][y][n];\\n        List<Integer> validNext = next[x][y];\\n        int sum = 0;\\n        for(int z : validNext){\\n            sum += count(n-1, y, z);\\n            sum %= 1000000007;\\n        }\\n        memo[x][y][n] = sum;\\n        return sum;\\n    }\\n    \\n    private List<Integer> getValidNext(int last1, int last2){\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i = 1; i <= 6; i++){\\n            if(last1 == 0 && last2 == 0) arr.add(i);\\n            else if(i == last1 || i == last2) continue;\\n            else if((last2 & 1) == 0 && (i & 1) == 0) continue;\\n            else if((last2 == 3 || last2 == 6) && (i == 3 || i == 6)) continue;\\n            else arr.add(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    List<Integer>[][] next;\\n    int[][][] memo;\\n    public int distinctSequences(int n) {\\n        next = new ArrayList[7][7];\\n        for(int i = 0; i <= 6; i++){\\n            for(int j = 0; j <= 6; j++){\\n                next[i][j] = getValidNext(i, j);\\n            }\\n        }\\n        memo = new int[7][7][10001];\\n        return count(n, 0, 0);\\n    }\\n    \\n    private int count(int n, int x, int y){\\n        if(n == 0) return 1;\\n        if(memo[x][y][n] != 0) return memo[x][y][n];\\n        List<Integer> validNext = next[x][y];\\n        int sum = 0;\\n        for(int z : validNext){\\n            sum += count(n-1, y, z);\\n            sum %= 1000000007;\\n        }\\n        memo[x][y][n] = sum;\\n        return sum;\\n    }\\n    \\n    private List<Integer> getValidNext(int last1, int last2){\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i = 1; i <= 6; i++){\\n            if(last1 == 0 && last2 == 0) arr.add(i);\\n            else if(i == last1 || i == last2) continue;\\n            else if((last2 & 1) == 0 && (i & 1) == 0) continue;\\n            else if((last2 == 3 || last2 == 6) && (i == 3 || i == 6)) continue;\\n            else arr.add(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197043,
                "title": "c-recursion-memoization-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10001][7][7];\\n    int mod = 1000000007;\\n    \\n    int helper(int idx, int n, int prev1, int prev2){\\n        //base check\\n        if(idx == n) return 1;\\n        \\n        //memo check\\n        if(dp[idx][prev1][prev2] != -1) return dp[idx][prev1][prev2];\\n        \\n        int cnt = 0;\\n        //Loop check for all combination for next number\\n        for(int i=1; i<=6; i++){\\n            //conditions check before calling next helper\\n            if((__gcd(i, prev1)==1 && i != prev1 && i != prev2) || prev1==0)\\n                //incrementing index and setting prev1 = i, prev2 = prev1\\n                cnt  = (cnt%mod + helper(idx+1, n, i, prev1)%mod)%mod;\\n        }\\n        \\n        return dp[idx][prev1][prev2] = cnt;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        //parameters : {index, n, just previous, previous before previous}\\n        return helper(0, n, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10001][7][7];\\n    int mod = 1000000007;\\n    \\n    int helper(int idx, int n, int prev1, int prev2){\\n        //base check\\n        if(idx == n) return 1;\\n        \\n        //memo check\\n        if(dp[idx][prev1][prev2] != -1) return dp[idx][prev1][prev2];\\n        \\n        int cnt = 0;\\n        //Loop check for all combination for next number\\n        for(int i=1; i<=6; i++){\\n            //conditions check before calling next helper\\n            if((__gcd(i, prev1)==1 && i != prev1 && i != prev2) || prev1==0)\\n                //incrementing index and setting prev1 = i, prev2 = prev1\\n                cnt  = (cnt%mod + helper(idx+1, n, i, prev1)%mod)%mod;\\n        }\\n        \\n        return dp[idx][prev1][prev2] = cnt;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        //parameters : {index, n, just previous, previous before previous}\\n        return helper(0, n, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196985,
                "title": "c-100-faster-100-memory-efficient-recursive-dp",
                "content": "![image](https://assets.leetcode.com/users/images/d2cab370-2b79-4d9d-a33f-c234b6848cd4_1656182672.681709.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[10004][8][8];\\n    int mod = 1000000007;\\n    \\n    int cal(int prev, int now, int n, int pos){\\n        if(pos==n)\\n            return 1;\\n        \\n        if(dp[pos][prev][now]!=-1)\\n            return dp[pos][prev][now];\\n        dp[pos][prev][now]=0;\\n        \\n        for(int i=1; i<=6; i++)\\n        {\\n            if(i!=prev && i!=now && __gcd(now, i)==1){\\n                dp[pos][prev][now] += cal(now, i, n, pos+1) % mod;\\n                dp[pos][prev][now] %= mod;\\n            }\\n        }\\n        \\n        return dp[pos][prev][now];\\n    }\\n    \\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return cal(7, 7, n, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10004][8][8];\\n    int mod = 1000000007;\\n    \\n    int cal(int prev, int now, int n, int pos){\\n        if(pos==n)\\n            return 1;\\n        \\n        if(dp[pos][prev][now]!=-1)\\n            return dp[pos][prev][now];\\n        dp[pos][prev][now]=0;\\n        \\n        for(int i=1; i<=6; i++)\\n        {\\n            if(i!=prev && i!=now && __gcd(now, i)==1){\\n                dp[pos][prev][now] += cal(now, i, n, pos+1) % mod;\\n                dp[pos][prev][now] %= mod;\\n            }\\n        }\\n        \\n        return dp[pos][prev][now];\\n    }\\n    \\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return cal(7, 7, n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196822,
                "title": "easy-to-understand-top-down-dp-solution-beats-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int solve(int n,int i,int last,vector<vector<vector<int>>> &dp)\\n    {\\n        if(n==0)\\n        {\\n            return 1;\\n        }\\n        if(last!=-1 and dp[n][i][last]!=-1)\\n        {\\n            return dp[n][i][last];\\n        }\\n        int store = 0;\\n        for(int j=1;j<=6;j++)\\n        {\\n            if(j!=i and __gcd(j,i)==1 and j!=last)\\n            {\\n                store = (store+solve(n-1,j,i,dp))%mod;\\n            }\\n        }\\n        return dp[n][i][last]=store;\\n    }\\n    int distinctSequences(int n) {\\n        \\n        int subs = 0;\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(7,vector<int>(7,-1))); \\n        for(int i=1;i<=6;i++)\\n        {\\n            subs = (subs+solve(n-1,i,0,dp))%mod;\\n        }\\n        return subs;\\n    }\\n};\\n```\\nTime Complexity O(6 x 6 x 6 x N) ~ O(N)\\nSpace Complexity O(7 x 7 x N) ~ O(N)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int solve(int n,int i,int last,vector<vector<vector<int>>> &dp)\\n    {\\n        if(n==0)\\n        {\\n            return 1;\\n        }\\n        if(last!=-1 and dp[n][i][last]!=-1)\\n        {\\n            return dp[n][i][last];\\n        }\\n        int store = 0;\\n        for(int j=1;j<=6;j++)\\n        {\\n            if(j!=i and __gcd(j,i)==1 and j!=last)\\n            {\\n                store = (store+solve(n-1,j,i,dp))%mod;\\n            }\\n        }\\n        return dp[n][i][last]=store;\\n    }\\n    int distinctSequences(int n) {\\n        \\n        int subs = 0;\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(7,vector<int>(7,-1))); \\n        for(int i=1;i<=6;i++)\\n        {\\n            subs = (subs+solve(n-1,i,0,dp))%mod;\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196704,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10004][7][7];\\n    int mod=1e9+7;\\n    int find(int n,int index,int prev1,int prev2)\\n    {\\n        if(index==n)\\n        {\\n            return 1;\\n        }\\n        if(dp[index][prev1][prev2]!=-1)\\n        {\\n            return dp[index][prev1][prev2]%mod;\\n        }\\n        int ans=0;\\n        for(int i=1;i<=6;i++)\\n        {\\n            if(prev1!=i&&prev2!=i&&(prev1==0||(__gcd(i,prev1)==1)))\\n            {\\n                ans=(ans+find(n,index+1,i,prev1))%mod;\\n            }\\n        }\\n        return dp[index][prev1][prev2]=ans%mod;\\n    }\\n    int distinctSequences(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return find(n,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10004][7][7];\\n    int mod=1e9+7;\\n    int find(int n,int index,int prev1,int prev2)\\n    {\\n        if(index==n)\\n        {\\n            return 1;\\n        }\\n        if(dp[index][prev1][prev2]!=-1)\\n        {\\n            return dp[index][prev1][prev2]%mod;\\n        }\\n        int ans=0;\\n        for(int i=1;i<=6;i++)\\n        {\\n            if(prev1!=i&&prev2!=i&&(prev1==0||(__gcd(i,prev1)==1)))\\n            {\\n                ans=(ans+find(n,index+1,i,prev1))%mod;\\n            }\\n        }\\n        return dp[index][prev1][prev2]=ans%mod;\\n    }\\n    int distinctSequences(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return find(n,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196556,
                "title": "simple-dp-memoization-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[100008][7][7];\\n    int mod=1e9+7;\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=util(0,n,0,0);\\n        return ans;\\n    }\\n    \\n    \\n    int util(int i , int n,int prev1,int prev2){\\n        if(i==n)\\n            return 1;\\n        if(dp[i][prev1][prev2]!=-1)\\n            return dp[i][prev1][prev2];\\n        int ans=0;\\n        for(int j=1;j<7;j++){\\n            if(j==prev1 || j==prev2 || gcd(j,prev1)!=1 && prev1!=0)\\n                continue;\\n            ans=(ans+util(i+1,n,j,prev1))%mod;\\n        }\\n        return dp[i][prev1][prev2]=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100008][7][7];\\n    int mod=1e9+7;\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=util(0,n,0,0);\\n        return ans;\\n    }\\n    \\n    \\n    int util(int i , int n,int prev1,int prev2){\\n        if(i==n)\\n            return 1;\\n        if(dp[i][prev1][prev2]!=-1)\\n            return dp[i][prev1][prev2];\\n        int ans=0;\\n        for(int j=1;j<7;j++){\\n            if(j==prev1 || j==prev2 || gcd(j,prev1)!=1 && prev1!=0)\\n                continue;\\n            ans=(ans+util(i+1,n,j,prev1))%mod;\\n        }\\n        return dp[i][prev1][prev2]=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196388,
                "title": "top-down-dp-c",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<vector<vector<int>>> dp;\\n    int go(int n,int a,int b)\\n    {\\n        if(n==0) return 1;\\n        if(dp[n][a][b]!=-1) return dp[n][a][b];\\n        ll ans{};\\n        for(int i=1;i<=6;i++)\\n        {\\n            if(i!=a && i!=b && (a==0 || __gcd(i,a)==1))\\n            {\\n                ans=(ans+go(n-1,i,a))%mod;\\n            }\\n        }\\n        return dp[n][a][b]=ans;\\n    }\\n    int distinctSequences(int n) {\\n        dp.assign(n+1,vector<vector<int>>(7,(vector<int>(7,-1))));\\n        return go(n,0,0);\\n    }\\n};\\n// TC-o(216n)\\n// SC-o(36n)\\n// can reduce space to o(36)\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<vector<vector<int>>> dp;\\n    int go(int n,int a,int b)\\n    {\\n        if(n==0) return 1;\\n        if(dp[n][a][b]!=-1) return dp[n][a][b];\\n        ll ans{};\\n        for(int i=1;i<=6;i++)\\n        {\\n            if(i!=a && i!=b && (a==0 || __gcd(i,a)==1))\\n            {\\n                ans=(ans+go(n-1,i,a))%mod;\\n            }\\n        }\\n        return dp[n][a][b]=ans;\\n    }\\n    int distinctSequences(int n) {\\n        dp.assign(n+1,vector<vector<int>>(7,(vector<int>(7,-1))));\\n        return go(n,0,0);\\n    }\\n};\\n// TC-o(216n)\\n// SC-o(36n)\\n// can reduce space to o(36)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196322,
                "title": "c-model-the-problem-as-graph-dp",
                "content": "Consider the GCD graph\\n![image](https://assets.leetcode.com/users/images/533b6a33-2b25-4636-960f-4a213adf33b0_1656174503.9274457.png)\\n\\n\\nWe put this graph as an adjacency list, and perform dfs starting at each vertex while keeping track of previous and no. of steps left.\\n\\n```\\nclass Solution {\\npublic:\\n    // GCD graph (undirected). Shows what all vertices can be visited starting from a particular node\\n    vector<vector<int>> adj = {{}, {2,3,4,5,6}, {1,3,5}, {1,2,4,5}, {1, 3, 5}, {1,2,3,4,6}, {1, 5}};\\n    vector<vector<vector<int>>> v;\\n    int MOD = 1000000007;\\n    \\n    \\n    int distinctSequences(int n) {\\n        v.resize(7, vector<vector<int>>(7, vector<int>(n + 1, -1)));\\n\\n        int ans = 0;\\n        for(int i = 1; i <= 6; i++)\\n            ans = (ans % MOD  + count(i, 0, n) % MOD) % MOD;\\n        \\n        return ans % MOD;\\n    }\\n    \\n    int count(int curr, int prev, int n) {\\n        if (n == 1)\\n            return 1;\\n        \\n        if (v[curr][prev][n] != -1)\\n            return v[curr][prev][n];\\n        \\n        int ans = 0;\\n        for(auto j: adj[curr]) {\\n            if (j == prev)\\n                continue;\\n            ans = (ans % MOD +   count(j, curr, n - 1) % MOD) % MOD;\\n        }\\n        \\n        return v[curr][prev][n] = ans;\\n    }\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Graph",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // GCD graph (undirected). Shows what all vertices can be visited starting from a particular node\\n    vector<vector<int>> adj = {{}, {2,3,4,5,6}, {1,3,5}, {1,2,4,5}, {1, 3, 5}, {1,2,3,4,6}, {1, 5}};\\n    vector<vector<vector<int>>> v;\\n    int MOD = 1000000007;\\n    \\n    \\n    int distinctSequences(int n) {\\n        v.resize(7, vector<vector<int>>(7, vector<int>(n + 1, -1)));\\n\\n        int ans = 0;\\n        for(int i = 1; i <= 6; i++)\\n            ans = (ans % MOD  + count(i, 0, n) % MOD) % MOD;\\n        \\n        return ans % MOD;\\n    }\\n    \\n    int count(int curr, int prev, int n) {\\n        if (n == 1)\\n            return 1;\\n        \\n        if (v[curr][prev][n] != -1)\\n            return v[curr][prev][n];\\n        \\n        int ans = 0;\\n        for(auto j: adj[curr]) {\\n            if (j == prev)\\n                continue;\\n            ans = (ans % MOD +   count(j, curr, n - 1) % MOD) % MOD;\\n        }\\n        \\n        return v[curr][prev][n] = ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196100,
                "title": "o-n-time-o-1-space-c-with-24ms-pass-bonus-o-1-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        const int mod = 1e9 + 7;\\n        vector<int64_t> v(67, 0);\\n        if (n == 1) return 6;\\n        for (int i = 1; i <= 6; ++i) {\\n            for (int j = 1; j <= 6; ++j) {\\n                if (i == j) continue;\\n                if (gcd(i, j) != 1) continue;\\n                v[i * 10 + j] = 1;\\n            }\\n        }\\n        for (int i = 3; i <= n; ++i) {\\n            vector<int64_t> nv(67, 0);\\n            for (int i = 1; i <= 6; ++i) {\\n                for (int j = 1; j <= 6; ++j) {\\n                    if (i == j) continue;\\n                    if (gcd(i, j) != 1) continue;\\n                    for (int q = 1; q <= 6; ++q) {\\n                        if (q == j || q == i) continue;\\n                        nv[i * 10 + j] += v[j * 10 + q];\\n                        nv[i * 10 + j] %= mod;\\n                    }\\n                }\\n            }\\n            swap(nv, v);\\n        }\\n\\n        int64_t res = 0;\\n        for (int i : v) {\\n            res += i;\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nalso, because the input only 10000 cases so we can precache all results\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        return res[n];\\n    }\\n\\n    Solution() {\\n        if (res.size()) return;\\n        res.resize(10001, 0);\\n        res[1] = 6;\\n        const int mod = 1e9 + 7;\\n        vector<int64_t> v(67, 0);\\n        for (int i = 1; i <= 6; ++i) {\\n            for (int j = 1; j <= 6; ++j) {\\n                if (i == j) continue;\\n                if (gcd(i, j) != 1) continue;\\n                v[i * 10 + j] = 1;\\n                res[2] += 1;\\n            }\\n        }\\n        for (int i = 3; i <= 10000; ++i) {\\n            vector<int64_t> nv(67, 0);\\n            for (int i = 1; i <= 6; ++i) {\\n                for (int j = 1; j <= 6; ++j) {\\n                    if (i == j) continue;\\n                    if (gcd(i, j) != 1) continue;\\n                    for (int q = 1; q <= 6; ++q) {\\n                        if (q == j || q == i) continue;\\n                        nv[i * 10 + j] += v[j * 10 + q];\\n                        nv[i * 10 + j] %= mod;\\n                    }\\n                }\\n            }\\n            swap(nv, v);\\n            for (auto e : v) {\\n                res[i] += e;\\n                res[i] %= mod;\\n            }\\n        }\\n    }\\n\\n    static vector<int64_t> res;\\n};\\n\\nvector<int64_t> Solution::res;\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        const int mod = 1e9 + 7;\\n        vector<int64_t> v(67, 0);\\n        if (n == 1) return 6;\\n        for (int i = 1; i <= 6; ++i) {\\n            for (int j = 1; j <= 6; ++j) {\\n                if (i == j) continue;\\n                if (gcd(i, j) != 1) continue;\\n                v[i * 10 + j] = 1;\\n            }\\n        }\\n        for (int i = 3; i <= n; ++i) {\\n            vector<int64_t> nv(67, 0);\\n            for (int i = 1; i <= 6; ++i) {\\n                for (int j = 1; j <= 6; ++j) {\\n                    if (i == j) continue;\\n                    if (gcd(i, j) != 1) continue;\\n                    for (int q = 1; q <= 6; ++q) {\\n                        if (q == j || q == i) continue;\\n                        nv[i * 10 + j] += v[j * 10 + q];\\n                        nv[i * 10 + j] %= mod;\\n                    }\\n                }\\n            }\\n            swap(nv, v);\\n        }\\n\\n        int64_t res = 0;\\n        for (int i : v) {\\n            res += i;\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        return res[n];\\n    }\\n\\n    Solution() {\\n        if (res.size()) return;\\n        res.resize(10001, 0);\\n        res[1] = 6;\\n        const int mod = 1e9 + 7;\\n        vector<int64_t> v(67, 0);\\n        for (int i = 1; i <= 6; ++i) {\\n            for (int j = 1; j <= 6; ++j) {\\n                if (i == j) continue;\\n                if (gcd(i, j) != 1) continue;\\n                v[i * 10 + j] = 1;\\n                res[2] += 1;\\n            }\\n        }\\n        for (int i = 3; i <= 10000; ++i) {\\n            vector<int64_t> nv(67, 0);\\n            for (int i = 1; i <= 6; ++i) {\\n                for (int j = 1; j <= 6; ++j) {\\n                    if (i == j) continue;\\n                    if (gcd(i, j) != 1) continue;\\n                    for (int q = 1; q <= 6; ++q) {\\n                        if (q == j || q == i) continue;\\n                        nv[i * 10 + j] += v[j * 10 + q];\\n                        nv[i * 10 + j] %= mod;\\n                    }\\n                }\\n            }\\n            swap(nv, v);\\n            for (auto e : v) {\\n                res[i] += e;\\n                res[i] %= mod;\\n            }\\n        }\\n    }\\n\\n    static vector<int64_t> res;\\n};\\n\\nvector<int64_t> Solution::res;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196018,
                "title": "cpp-memorization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long int dp[7][7][10001];\\n    long long int solve(int a, int b, int i, int n){\\n        if (i>=n){\\n            return 1;\\n        }\\n        long long int ways = 0;\\n        if (dp[a][b][i]!=-1){\\n            return dp[a][b][i];\\n        }\\n        for (int j =1;j<=6; j++){\\n            if (i>1){\\n            if (j!=a && j!=b){\\n                if (__gcd(j,b)==1){\\n                    ways+=solve(b,j,i+1,n);\\n                }\\n            }}\\n```\\n            else if(i==0){\\n                ways+=solve(b,j,i+1,n);\\n            }\\n            else if(i==1){\\n                if (j!=b){\\n```\\n                if (__gcd(j,b)==1){\\n                    ways+=solve(b,j,i+1,n);\\n                }\\n            }\\n            }\\n        \\n            ways%=mod;\\n        }\\n        return dp[a][b][i] = ways;\\n    }\\n    int distinctSequences(int n) {\\n \\xA0 \\xA0 \\xA0  memset(dp,-1,sizeof dp);\\n        return solve(0,0,0,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long int dp[7][7][10001];\\n    long long int solve(int a, int b, int i, int n){\\n        if (i>=n){\\n            return 1;\\n        }\\n        long long int ways = 0;\\n        if (dp[a][b][i]!=-1){\\n            return dp[a][b][i];\\n        }\\n        for (int j =1;j<=6; j++){\\n            if (i>1){\\n            if (j!=a && j!=b){\\n                if (__gcd(j,b)==1){\\n                    ways+=solve(b,j,i+1,n);\\n                }\\n            }}\\n```\n```\\n                if (__gcd(j,b)==1){\\n                    ways+=solve(b,j,i+1,n);\\n                }\\n            }\\n            }\\n        \\n            ways%=mod;\\n        }\\n        return dp[a][b][i] = ways;\\n    }\\n    int distinctSequences(int n) {\\n \\xA0 \\xA0 \\xA0  memset(dp,-1,sizeof dp);\\n        return solve(0,0,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196013,
                "title": "easy-c-solution-o-n-dp-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int dp[10005][7][7];\\n    int N;\\n    int calc(int idx,int a,int b)\\n    {\\n        int i,ans=0;\\n        //Base case\\n        if(idx==N)\\n        {\\n            return 1;\\n        }\\n        //if valuue is precomputed\\n        if(dp[idx][a][b]!=-1)\\n        {\\n            return dp[idx][a][b];\\n        }\\n        //try with all 6 possiblities\\n        for(i=1;i<=6;i++)\\n        {\\n            //2nd condn -> if the cureent values is matches with any of the past two values\\n            if(i==a || i==b)\\n            {\\n                continue;\\n            }\\n            //if past value exist and the gcd of this two values is greater than 1\\n            if(b>0 && __gcd(b,i)>1)\\n            {\\n                continue;\\n            }\\n            // add to the ans\\n            ans+=(calc(idx+1,b,i)%mod);\\n            ans%=mod;\\n        }\\n        return dp[idx][a][b]=ans;\\n    }\\n    int distinctSequences(int n) \\n    {\\n        N=n;\\n        memset(dp,-1,sizeof(dp));\\n        return calc(0,0,0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int dp[10005][7][7];\\n    int N;\\n    int calc(int idx,int a,int b)\\n    {\\n        int i,ans=0;\\n        //Base case\\n        if(idx==N)\\n        {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2196004,
                "title": "memoized-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10001][7][7][7];\\n    int mod = 1e9 + 7;\\n    int helper(int currRoll, int prev, int prev2, int remRolls){\\n        if(remRolls == 0)   return 1;\\n        if(dp[remRolls][currRoll][prev][prev2] != -1)   return dp[remRolls][currRoll][prev][prev2];\\n        int currAns = 0;\\n        for(int i = 1; i <= 6; ++i){\\n            if(i != currRoll && __gcd(i, currRoll) == 1 && i != prev)\\n                currAns = (currAns + helper(i, currRoll, prev, remRolls - 1)) % mod;\\n        }\\n        return dp[remRolls][currRoll][prev][prev2] = currAns;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        int ans = 0;\\n        for(int i = 1; i <= 6; ++i){\\n            ans = (ans + helper(i, 0, 0, n - 1)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10001][7][7][7];\\n    int mod = 1e9 + 7;\\n    int helper(int currRoll, int prev, int prev2, int remRolls){\\n        if(remRolls == 0)   return 1;\\n        if(dp[remRolls][currRoll][prev][prev2] != -1)   return dp[remRolls][currRoll][prev][prev2];\\n        int currAns = 0;\\n        for(int i = 1; i <= 6; ++i){\\n            if(i != currRoll && __gcd(i, currRoll) == 1 && i != prev)\\n                currAns = (currAns + helper(i, currRoll, prev, remRolls - 1)) % mod;\\n        }\\n        return dp[remRolls][currRoll][prev][prev2] = currAns;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        int ans = 0;\\n        for(int i = 1; i <= 6; ++i){\\n            ans = (ans + helper(i, 0, 0, n - 1)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195962,
                "title": "c-3d-dp-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int dp[10001][7][7];\\n    int solve(int n, int cur, int prev, vector<vector<int>> &arr) {\\n        if (n == 0) return 1;\\n        \\n        if (dp[n][cur][prev] != -1) return dp[n][cur][prev];\\n        \\n        int ans = 0;\\n        for (auto x: arr[cur]) {\\n            if (prev != x) {\\n                ans = (ans + solve(n-1,x,cur,arr))%mod;\\n            }\\n        }\\n        \\n        return dp[n][cur][prev] = ans;\\n    }\\n    int distinctSequences(int n) {\\n        vector<vector<int>> arr(7);\\n        arr[1] = {2,3,4,5,6};\\n        arr[2] = {1,3,5};\\n        arr[3] = {1,2,4,5};\\n        arr[4] = {1,3,5};\\n        arr[5] = {1,2,3,4,6};\\n        arr[6] = {1,5};\\n        \\n        memset(dp, -1, sizeof dp);\\n        int ans = 0;\\n        for (int i = 1; i <= 6; i++) {\\n            ans = (ans + solve(n-1, i, 0, arr))%mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int dp[10001][7][7];\\n    int solve(int n, int cur, int prev, vector<vector<int>> &arr) {\\n        if (n == 0) return 1;\\n        \\n        if (dp[n][cur][prev] != -1) return dp[n][cur][prev];\\n        \\n        int ans = 0;\\n        for (auto x: arr[cur]) {\\n            if (prev != x) {\\n                ans = (ans + solve(n-1,x,cur,arr))%mod;\\n            }\\n        }\\n        \\n        return dp[n][cur][prev] = ans;\\n    }\\n    int distinctSequences(int n) {\\n        vector<vector<int>> arr(7);\\n        arr[1] = {2,3,4,5,6};\\n        arr[2] = {1,3,5};\\n        arr[3] = {1,2,4,5};\\n        arr[4] = {1,3,5};\\n        arr[5] = {1,2,3,4,6};\\n        arr[6] = {1,5};\\n        \\n        memset(dp, -1, sizeof dp);\\n        int ans = 0;\\n        for (int i = 1; i <= 6; i++) {\\n            ans = (ans + solve(n-1, i, 0, arr))%mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195942,
                "title": "c-easy-bottom-up-dp-with-explaination-time-space-o-n-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    // time complexity: O(216 * N) => O(N)\\n    // space complexity: O(36 * N) => O(N)\\n    int distinctSequences(int n) {\\n        // edge case\\n        if (n == 1) return 6;\\n        \\n        const long long mod = 1e9 + 7;\\n        // define valid move: 0-indexed\\n        // e.g., 1 can move to {2, 3, 4, 5, 6} => valid[0] = {0,1,1,1,1,1}\\n        // e.g., 2 can move to {1, 3, 5} => valid[1] = {1,0,1,0,1,0}\\n        vector<vector<bool>> valid = {{0,1,1,1,1,1},{1,0,1,0,1,0},{1,1,0,1,1,0},{1,0,1,0,1,0},{1,1,1,1,0,1},{1,0,0,0,1,0}};\\n        \\n        // dp[l][i][j]: # of valid sequences if the length of sequence \\n        //              is \"l - 1\"(0-indexed) and end with \"j\" considering previous one is \"i\"\\n        vector<vector<vector<long long>>> dp(n, vector<vector<long long>>(6, vector<long long>(6, 0)));\\n        \\n        // initial state\\n        for (int i = 0; i < 6; ++i) {\\n            for (int j = 0; j < 6; ++j) {\\n                dp[0][i][j] = 1;\\n            }\\n        }\\n        \\n        // length = 2 => not need to consider \"at least a gap of 2 rolls between equal valued rolls.\"\\n        for (int i = 0; i < 6; ++i) {\\n            for (int j = 0; j < 6; ++j) {\\n                if (valid[i][j]) dp[1][i][j] += dp[0][i][j];\\n            }\\n        }\\n        \\n        // length = [3, n] => need to consider \"at least a gap of 2 rolls between equal valued rolls.\"\\n        for (int k = 2; k < n; ++k) {\\n            for (int i = 0; i < 6; ++i) {\\n                for (int j = 0; j < 6; ++j) {\\n                    if (valid[i][j]) {\\n                        // a move (t->i->j) is valid only when valid[t][i] && valid[i][j] && (t != j)\\n                        for (int t = 0; t < 6; ++t) {\\n                            if (valid[t][i] && t != j) dp[k][i][j] += dp[k - 1][t][i];\\n                        }\\n                        dp[k][i][j] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // sum up the last state, which is the answer\\n        // dp[n - 1][*][*]\\n        long long res = 0;\\n        for (int i = 0; i < 6; ++i) {\\n            for (int j = 0; j < 6; ++j) {\\n                if (valid[i][j]) {\\n                    res += dp[n - 1][i][j];\\n                    res %= mod;\\n                }\\n            }\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // time complexity: O(216 * N) => O(N)\\n    // space complexity: O(36 * N) => O(N)\\n    int distinctSequences(int n) {\\n        // edge case\\n        if (n == 1) return 6;\\n        \\n        const long long mod = 1e9 + 7;\\n        // define valid move: 0-indexed\\n        // e.g., 1 can move to {2, 3, 4, 5, 6} => valid[0] = {0,1,1,1,1,1}\\n        // e.g., 2 can move to {1, 3, 5} => valid[1] = {1,0,1,0,1,0}\\n        vector<vector<bool>> valid = {{0,1,1,1,1,1},{1,0,1,0,1,0},{1,1,0,1,1,0},{1,0,1,0,1,0},{1,1,1,1,0,1},{1,0,0,0,1,0}};\\n        \\n        // dp[l][i][j]: # of valid sequences if the length of sequence \\n        //              is \"l - 1\"(0-indexed) and end with \"j\" considering previous one is \"i\"\\n        vector<vector<vector<long long>>> dp(n, vector<vector<long long>>(6, vector<long long>(6, 0)));\\n        \\n        // initial state\\n        for (int i = 0; i < 6; ++i) {\\n            for (int j = 0; j < 6; ++j) {\\n                dp[0][i][j] = 1;\\n            }\\n        }\\n        \\n        // length = 2 => not need to consider \"at least a gap of 2 rolls between equal valued rolls.\"\\n        for (int i = 0; i < 6; ++i) {\\n            for (int j = 0; j < 6; ++j) {\\n                if (valid[i][j]) dp[1][i][j] += dp[0][i][j];\\n            }\\n        }\\n        \\n        // length = [3, n] => need to consider \"at least a gap of 2 rolls between equal valued rolls.\"\\n        for (int k = 2; k < n; ++k) {\\n            for (int i = 0; i < 6; ++i) {\\n                for (int j = 0; j < 6; ++j) {\\n                    if (valid[i][j]) {\\n                        // a move (t->i->j) is valid only when valid[t][i] && valid[i][j] && (t != j)\\n                        for (int t = 0; t < 6; ++t) {\\n                            if (valid[t][i] && t != j) dp[k][i][j] += dp[k - 1][t][i];\\n                        }\\n                        dp[k][i][j] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // sum up the last state, which is the answer\\n        // dp[n - 1][*][*]\\n        long long res = 0;\\n        for (int i = 0; i < 6; ++i) {\\n            for (int j = 0; j < 6; ++j) {\\n                if (valid[i][j]) {\\n                    res += dp[n - 1][i][j];\\n                    res %= mod;\\n                }\\n            }\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195888,
                "title": "c-easy-and-concise-dp",
                "content": "**Just keep previous two elements and check the conditions**\\n1. When i am going roll ith dice then what information do i need to get all possible ith dice numbers?\\n2. 1st is previous element and 2nd is previoud of previous element\\n```\\nclass Solution {\\npublic:\\n    long m=1e9+7;\\n    int dp[10001][7][7];\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(7,7,1,n);\\n    }\\n    long helper(int pre1,int pre,int idx,int &n){\\n        if(idx==n+1)\\n            return 1;\\n        if(dp[idx][pre-1][pre1-1]!=-1)\\n            return dp[idx][pre-1][pre1-1];\\n        long ans=0;\\n        for(int i=1;i<=6;i++)\\n            if(__gcd(i,pre)==1 && i!=pre && i!=pre1)\\n                    ans=(ans+helper(pre,i,idx+1,n))%m;\\n        dp[idx][pre-1][pre1-1]=ans;\\n        return ans;\\n    }\\n};\\n```\\nDo **Upvote** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long m=1e9+7;\\n    int dp[10001][7][7];\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(7,7,1,n);\\n    }\\n    long helper(int pre1,int pre,int idx,int &n){\\n        if(idx==n+1)\\n            return 1;\\n        if(dp[idx][pre-1][pre1-1]!=-1)\\n            return dp[idx][pre-1][pre1-1];\\n        long ans=0;\\n        for(int i=1;i<=6;i++)\\n            if(__gcd(i,pre)==1 && i!=pre && i!=pre1)\\n                    ans=(ans+helper(pre,i,idx+1,n))%m;\\n        dp[idx][pre-1][pre1-1]=ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195857,
                "title": "c-dp-brute-force-o-n",
                "content": "dp[i][j][k] means the total number of distinct sequences with\\n\\ni: length of the sequence, \\nj: the second to last number of the sequence, \\nk: the last number of the sequence\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        long long dp[10005][7][7] = {}, mod = 1e9+7;\\n        dp[2][1][1] = 0, dp[2][1][2] = 1, dp[2][1][3] = 1, dp[2][1][4] = 1, dp[2][1][5] = 1, dp[2][1][6] = 1;\\n        dp[2][2][1] = 1, dp[2][2][2] = 0, dp[2][2][3] = 1, dp[2][2][4] = 0, dp[2][2][5] = 1, dp[2][2][6] = 0;\\n        dp[2][3][1] = 1, dp[2][3][2] = 1, dp[2][3][3] = 0, dp[2][3][4] = 1, dp[2][3][5] = 1, dp[2][3][6] = 0;\\n        dp[2][4][1] = 1, dp[2][4][2] = 0, dp[2][4][3] = 1, dp[2][4][4] = 0, dp[2][4][5] = 1, dp[2][4][6] = 0;\\n        dp[2][5][1] = 1, dp[2][5][2] = 1, dp[2][5][3] = 1, dp[2][5][4] = 1, dp[2][5][5] = 0, dp[2][5][6] = 1;\\n        dp[2][6][1] = 1, dp[2][6][2] = 0, dp[2][6][3] = 0, dp[2][6][4] = 0, dp[2][6][5] = 1, dp[2][6][6] = 0;\\n        for(int i = 3; i <= n; i++){\\n            dp[i][1][2] = (dp[i-1][1][1]+dp[i-1][3][1]+dp[i-1][4][1]+dp[i-1][5][1]+dp[i-1][6][1])%mod;\\n            dp[i][1][3] = (dp[i-1][1][1]+dp[i-1][2][1]+dp[i-1][4][1]+dp[i-1][5][1]+dp[i-1][6][1])%mod;\\n            dp[i][1][4] = (dp[i-1][1][1]+dp[i-1][2][1]+dp[i-1][3][1]+dp[i-1][5][1]+dp[i-1][6][1])%mod;\\n            dp[i][1][5] = (dp[i-1][1][1]+dp[i-1][2][1]+dp[i-1][3][1]+dp[i-1][4][1]+dp[i-1][6][1])%mod;\\n            dp[i][1][6] = (dp[i-1][1][1]+dp[i-1][2][1]+dp[i-1][3][1]+dp[i-1][4][1]+dp[i-1][5][1])%mod;\\n            \\n            dp[i][2][1] = (dp[i-1][2][2]+dp[i-1][3][2]+dp[i-1][4][2]+dp[i-1][5][2]+dp[i-1][6][2])%mod;\\n            dp[i][2][3] = (dp[i-1][1][2]+dp[i-1][2][2]+dp[i-1][4][2]+dp[i-1][5][2]+dp[i-1][6][2])%mod;\\n            dp[i][2][5] = (dp[i-1][1][2]+dp[i-1][2][2]+dp[i-1][3][2]+dp[i-1][4][2]+dp[i-1][6][2])%mod;\\n            \\n            dp[i][3][1] = (dp[i-1][2][3]+dp[i-1][3][3]+dp[i-1][4][3]+dp[i-1][5][3]+dp[i-1][6][3])%mod;\\n            dp[i][3][2] = (dp[i-1][1][3]+dp[i-1][3][3]+dp[i-1][4][3]+dp[i-1][5][3]+dp[i-1][6][3])%mod;\\n            dp[i][3][4] = (dp[i-1][1][3]+dp[i-1][2][3]+dp[i-1][3][3]+dp[i-1][5][3]+dp[i-1][6][3])%mod;\\n            dp[i][3][5] = (dp[i-1][1][3]+dp[i-1][2][3]+dp[i-1][3][3]+dp[i-1][4][3]+dp[i-1][6][3])%mod;\\n                \\n            dp[i][4][1] = (dp[i-1][2][4]+dp[i-1][3][4]+dp[i-1][4][4]+dp[i-1][5][4]+dp[i-1][6][4])%mod;\\n            dp[i][4][3] = (dp[i-1][1][4]+dp[i-1][2][4]+dp[i-1][4][4]+dp[i-1][5][4]+dp[i-1][6][4])%mod;\\n            dp[i][4][5] = (dp[i-1][1][4]+dp[i-1][2][4]+dp[i-1][3][4]+dp[i-1][4][4]+dp[i-1][6][4])%mod;\\n            \\n            dp[i][5][1] = (dp[i-1][2][5]+dp[i-1][3][5]+dp[i-1][4][5]+dp[i-1][5][5]+dp[i-1][6][5])%mod;\\n            dp[i][5][2] = (dp[i-1][1][5]+dp[i-1][3][5]+dp[i-1][4][5]+dp[i-1][5][5]+dp[i-1][6][5])%mod;\\n            dp[i][5][3] = (dp[i-1][1][5]+dp[i-1][2][5]+dp[i-1][4][5]+dp[i-1][5][5]+dp[i-1][6][5])%mod;\\n            dp[i][5][4] = (dp[i-1][1][5]+dp[i-1][2][5]+dp[i-1][3][5]+dp[i-1][5][5]+dp[i-1][6][5])%mod;\\n            dp[i][5][6] = (dp[i-1][1][5]+dp[i-1][2][5]+dp[i-1][3][5]+dp[i-1][4][5]+dp[i-1][5][5])%mod;\\n            \\n            dp[i][6][1] = (dp[i-1][2][6]+dp[i-1][3][6]+dp[i-1][4][6]+dp[i-1][5][6]+dp[i-1][6][6])%mod;\\n            dp[i][6][5] = (dp[i-1][1][6]+dp[i-1][2][6]+dp[i-1][3][6]+dp[i-1][4][6]+dp[i-1][6][6])%mod;\\n        }\\n        long long res = 0;\\n        for(int i = 1; i <= 6; i++){\\n            for(int j = 1; j <= 6; j++){\\n                res = (res+dp[n][i][j])%mod;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nsimplify version\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        long long dp[10005][7][7] = {}, mod = 1e9+7;\\n        for(int i = 1; i <= 6; i++)\\n            for(int j = 1; j <= 6; j++)\\n                if(i!=j && gcd(i, j)==1)\\n                    dp[2][i][j] = 1;\\n        for(int len = 3; len <= n; len++)\\n            for(int i = 1; i <= 6; i++)\\n                for(int j = 1; j <= 6; j++){\\n                    if(i==j || gcd(i, j)!=1) continue;\\n                    for(int k = 1; k <= 6; k++){\\n                        if(k == j) continue;\\n                        dp[len][i][j] = (dp[len][i][j]+dp[len-1][k][i])%mod;\\n                    }\\n                }\\n        long long res = 0;\\n        for(int i = 1; i <= 6; i++)\\n            for(int j = 1; j <= 6; j++)\\n                res = (res+dp[n][i][j])%mod;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        long long dp[10005][7][7] = {}, mod = 1e9+7;\\n        dp[2][1][1] = 0, dp[2][1][2] = 1, dp[2][1][3] = 1, dp[2][1][4] = 1, dp[2][1][5] = 1, dp[2][1][6] = 1;\\n        dp[2][2][1] = 1, dp[2][2][2] = 0, dp[2][2][3] = 1, dp[2][2][4] = 0, dp[2][2][5] = 1, dp[2][2][6] = 0;\\n        dp[2][3][1] = 1, dp[2][3][2] = 1, dp[2][3][3] = 0, dp[2][3][4] = 1, dp[2][3][5] = 1, dp[2][3][6] = 0;\\n        dp[2][4][1] = 1, dp[2][4][2] = 0, dp[2][4][3] = 1, dp[2][4][4] = 0, dp[2][4][5] = 1, dp[2][4][6] = 0;\\n        dp[2][5][1] = 1, dp[2][5][2] = 1, dp[2][5][3] = 1, dp[2][5][4] = 1, dp[2][5][5] = 0, dp[2][5][6] = 1;\\n        dp[2][6][1] = 1, dp[2][6][2] = 0, dp[2][6][3] = 0, dp[2][6][4] = 0, dp[2][6][5] = 1, dp[2][6][6] = 0;\\n        for(int i = 3; i <= n; i++){\\n            dp[i][1][2] = (dp[i-1][1][1]+dp[i-1][3][1]+dp[i-1][4][1]+dp[i-1][5][1]+dp[i-1][6][1])%mod;\\n            dp[i][1][3] = (dp[i-1][1][1]+dp[i-1][2][1]+dp[i-1][4][1]+dp[i-1][5][1]+dp[i-1][6][1])%mod;\\n            dp[i][1][4] = (dp[i-1][1][1]+dp[i-1][2][1]+dp[i-1][3][1]+dp[i-1][5][1]+dp[i-1][6][1])%mod;\\n            dp[i][1][5] = (dp[i-1][1][1]+dp[i-1][2][1]+dp[i-1][3][1]+dp[i-1][4][1]+dp[i-1][6][1])%mod;\\n            dp[i][1][6] = (dp[i-1][1][1]+dp[i-1][2][1]+dp[i-1][3][1]+dp[i-1][4][1]+dp[i-1][5][1])%mod;\\n            \\n            dp[i][2][1] = (dp[i-1][2][2]+dp[i-1][3][2]+dp[i-1][4][2]+dp[i-1][5][2]+dp[i-1][6][2])%mod;\\n            dp[i][2][3] = (dp[i-1][1][2]+dp[i-1][2][2]+dp[i-1][4][2]+dp[i-1][5][2]+dp[i-1][6][2])%mod;\\n            dp[i][2][5] = (dp[i-1][1][2]+dp[i-1][2][2]+dp[i-1][3][2]+dp[i-1][4][2]+dp[i-1][6][2])%mod;\\n            \\n            dp[i][3][1] = (dp[i-1][2][3]+dp[i-1][3][3]+dp[i-1][4][3]+dp[i-1][5][3]+dp[i-1][6][3])%mod;\\n            dp[i][3][2] = (dp[i-1][1][3]+dp[i-1][3][3]+dp[i-1][4][3]+dp[i-1][5][3]+dp[i-1][6][3])%mod;\\n            dp[i][3][4] = (dp[i-1][1][3]+dp[i-1][2][3]+dp[i-1][3][3]+dp[i-1][5][3]+dp[i-1][6][3])%mod;\\n            dp[i][3][5] = (dp[i-1][1][3]+dp[i-1][2][3]+dp[i-1][3][3]+dp[i-1][4][3]+dp[i-1][6][3])%mod;\\n                \\n            dp[i][4][1] = (dp[i-1][2][4]+dp[i-1][3][4]+dp[i-1][4][4]+dp[i-1][5][4]+dp[i-1][6][4])%mod;\\n            dp[i][4][3] = (dp[i-1][1][4]+dp[i-1][2][4]+dp[i-1][4][4]+dp[i-1][5][4]+dp[i-1][6][4])%mod;\\n            dp[i][4][5] = (dp[i-1][1][4]+dp[i-1][2][4]+dp[i-1][3][4]+dp[i-1][4][4]+dp[i-1][6][4])%mod;\\n            \\n            dp[i][5][1] = (dp[i-1][2][5]+dp[i-1][3][5]+dp[i-1][4][5]+dp[i-1][5][5]+dp[i-1][6][5])%mod;\\n            dp[i][5][2] = (dp[i-1][1][5]+dp[i-1][3][5]+dp[i-1][4][5]+dp[i-1][5][5]+dp[i-1][6][5])%mod;\\n            dp[i][5][3] = (dp[i-1][1][5]+dp[i-1][2][5]+dp[i-1][4][5]+dp[i-1][5][5]+dp[i-1][6][5])%mod;\\n            dp[i][5][4] = (dp[i-1][1][5]+dp[i-1][2][5]+dp[i-1][3][5]+dp[i-1][5][5]+dp[i-1][6][5])%mod;\\n            dp[i][5][6] = (dp[i-1][1][5]+dp[i-1][2][5]+dp[i-1][3][5]+dp[i-1][4][5]+dp[i-1][5][5])%mod;\\n            \\n            dp[i][6][1] = (dp[i-1][2][6]+dp[i-1][3][6]+dp[i-1][4][6]+dp[i-1][5][6]+dp[i-1][6][6])%mod;\\n            dp[i][6][5] = (dp[i-1][1][6]+dp[i-1][2][6]+dp[i-1][3][6]+dp[i-1][4][6]+dp[i-1][6][6])%mod;\\n        }\\n        long long res = 0;\\n        for(int i = 1; i <= 6; i++){\\n            for(int j = 1; j <= 6; j++){\\n                res = (res+dp[n][i][j])%mod;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        long long dp[10005][7][7] = {}, mod = 1e9+7;\\n        for(int i = 1; i <= 6; i++)\\n            for(int j = 1; j <= 6; j++)\\n                if(i!=j && gcd(i, j)==1)\\n                    dp[2][i][j] = 1;\\n        for(int len = 3; len <= n; len++)\\n            for(int i = 1; i <= 6; i++)\\n                for(int j = 1; j <= 6; j++){\\n                    if(i==j || gcd(i, j)!=1) continue;\\n                    for(int k = 1; k <= 6; k++){\\n                        if(k == j) continue;\\n                        dp[len][i][j] = (dp[len][i][j]+dp[len-1][k][i])%mod;\\n                    }\\n                }\\n        long long res = 0;\\n        for(int i = 1; i <= 6; i++)\\n            for(int j = 1; j <= 6; j++)\\n                res = (res+dp[n][i][j])%mod;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195848,
                "title": "easy-to-understand-c-memoisation",
                "content": "We can try out all the possibilities as per the condition given in the problem and then use memoisation to calculate the total number of sequences effectively. We keep track of lastDice and secondLast Dice, the current dice Roll should not be equal to last or secLast dice and gcd(lastDice,currentDice) == 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    //dp[rollCount][lastDiceValue][secLastValue]\\n    int dp[10001][7][7];\\n    int helper(int pos,int lastDice,int secLastDice,int n) {\\n        //all dice rolls exhaused , so this makes up 1 sequence\\n        if(pos == n) return 1;\\n        if(dp[pos][lastDice-1][secLastDice-1] != -1) return dp[pos][lastDice-1][secLastDice-1];\\n        \\n        long long ans = 0;\\n        for(int i=1;i<=6;i++) {\\n            //As per the required condition in problem\\n            if(secLastDice == i || lastDice == i || gcd(i,lastDice) != 1)   continue;\\n            // lastDice now becomes secLastDice\\n            ans += helper(pos+1,i,lastDice,n);\\n            ans %= mod;\\n        }\\n        return dp[pos][lastDice-1][secLastDice-1] = ans % mod;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof dp);\\n        // We assume that the lastDice was 7 and secLast dice was also 7 for simplicity in our helper function, when we had not not rolled dice even once\\n        return helper(0,7,7,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    //dp[rollCount][lastDiceValue][secLastValue]\\n    int dp[10001][7][7];\\n    int helper(int pos,int lastDice,int secLastDice,int n) {\\n        //all dice rolls exhaused , so this makes up 1 sequence\\n        if(pos == n) return 1;\\n        if(dp[pos][lastDice-1][secLastDice-1] != -1) return dp[pos][lastDice-1][secLastDice-1];\\n        \\n        long long ans = 0;\\n        for(int i=1;i<=6;i++) {\\n            //As per the required condition in problem\\n            if(secLastDice == i || lastDice == i || gcd(i,lastDice) != 1)   continue;\\n            // lastDice now becomes secLastDice\\n            ans += helper(pos+1,i,lastDice,n);\\n            ans %= mod;\\n        }\\n        return dp[pos][lastDice-1][secLastDice-1] = ans % mod;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof dp);\\n        // We assume that the lastDice was 7 and secLast dice was also 7 for simplicity in our helper function, when we had not not rolled dice even once\\n        return helper(0,7,7,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088693,
                "title": "recursion-with-memoization-small-and-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use dynamic programming with the variables being *number of rolls* **(i)** ,*previous rolled* **(prev)** and *the roll before previous* **(pprev)**,since the total number of combinations depend on just these 3 factors,we compute this.\\n\\nJust check if my **current roll has gcd of 1 with previous roll** and **is not previous roll** and **is not previous to previous roll.** as given in the question.Then dp will do its magic.\\n\\n\\n# Complexity\\n- Time complexity:\\n**O(36*n)**\\n\\n- Space complexity:\\n**O(64*n)**\\n\\n# Code\\n```\\nint num(int i,int prev,int pprev,int n,vector<vector<vector<int>>>&dp){\\n    if(i==n+1)return 1;\\n    if(dp[i][prev][pprev]!=-1)return dp[i][prev][pprev];\\n    int ans=0;\\n    for(int j=1;j<=6;j++){\\n        if(__gcd(j,prev)==1&&j!=prev&&j!=pprev)\\n            ans=(ans+num(i+1,j,prev,n,dp))%(1000000007);\\n    }\\n    return dp[i][prev][pprev]=ans;\\n}\\n\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(8,vector<int>(8,-1)));\\n        return num(1,7,7,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint num(int i,int prev,int pprev,int n,vector<vector<vector<int>>>&dp){\\n    if(i==n+1)return 1;\\n    if(dp[i][prev][pprev]!=-1)return dp[i][prev][pprev];\\n    int ans=0;\\n    for(int j=1;j<=6;j++){\\n        if(__gcd(j,prev)==1&&j!=prev&&j!=pprev)\\n            ans=(ans+num(i+1,j,prev,n,dp))%(1000000007);\\n    }\\n    return dp[i][prev][pprev]=ans;\\n}\\n\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(8,vector<int>(8,-1)));\\n        return num(1,7,7,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077193,
                "title": "simple-and-clear-solution-bottom-up-dynamic-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nfrom math import gcd\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        modulo = 1_000_000_007\\n\\n        # any prime number greater than 6\\n        prev = {(7, 7): 1}\\n\\n        @cache\\n        def get_next(u, v):\\n            result = []\\n            for w in range(1, 7):\\n                if u != w and v != w and gcd(v, w) == 1:\\n                    result.append(w)\\n            return tuple(result)\\n\\n        for _ in range(n):\\n            current = Counter()\\n            for (a, b), cnt in prev.items():\\n                for c in get_next(a, b):\\n                    current[(b, c)] += cnt\\n                    current[(b, c)] %= modulo\\n            prev = current\\n        \\n        result = 0\\n        for cnt in prev.values():\\n            result += cnt\\n            result %= modulo\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` python3 []\\nfrom math import gcd\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        modulo = 1_000_000_007\\n\\n        # any prime number greater than 6\\n        prev = {(7, 7): 1}\\n\\n        @cache\\n        def get_next(u, v):\\n            result = []\\n            for w in range(1, 7):\\n                if u != w and v != w and gcd(v, w) == 1:\\n                    result.append(w)\\n            return tuple(result)\\n\\n        for _ in range(n):\\n            current = Counter()\\n            for (a, b), cnt in prev.items():\\n                for c in get_next(a, b):\\n                    current[(b, c)] += cnt\\n                    current[(b, c)] %= modulo\\n            prev = current\\n        \\n        result = 0\\n        for cnt in prev.values():\\n            result += cnt\\n            result %= modulo\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065326,
                "title": "recursion-memoization-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[7][7][10011];\\n    int mod=1e9+7;\\n    int f(int prev1, int prev2, int n)\\n    {\\n        if(n==0) return 1;\\n        if(dp[prev1][prev2][n]!=-1) return dp[prev1][prev2][n];\\n        int ans=0;\\n        for(int x=1; x<=6; x++)\\n        {\\n            if(prev1!=x && prev2!=x && (prev2==0 || (prev2!=0 && __gcd(prev2,x)==1))) ans=(ans+f(prev2,x,n-1))%mod;\\n        }\\n        return dp[prev1][prev2][n]=ans;\\n    }\\n    int distinctSequences(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dp[7][7][10011];\\n    int mod=1e9+7;\\n    int f(int prev1, int prev2, int n)\\n    {\\n        if(n==0) return 1;\\n        if(dp[prev1][prev2][n]!=-1) return dp[prev1][prev2][n];\\n        int ans=0;\\n        for(int x=1; x<=6; x++)\\n        {\\n            if(prev1!=x && prev2!=x && (prev2==0 || (prev2!=0 && __gcd(prev2,x)==1))) ans=(ans+f(prev2,x,n-1))%mod;\\n        }\\n        return dp[prev1][prev2][n]=ans;\\n    }\\n    int distinctSequences(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961644,
                "title": "just-do-what-is-told",
                "content": "**NOTHING COMPLEX **\\n\\nJUST DO WHAT IS TOLD TO BE DONE + MEMOIZATION \\n\\nTHE CODE IS SELF EXPLAINATORY \\n\\n# Code\\n```\\nclass Solution {\\n    long mod = (long)Math.pow(10,  9 ) + 7 ; \\n    long[][][] dp ; \\n    public int distinctSequences(int n) {\\n        dp = new long[n+1][8][8] ; \\n        for( long[][] arr : dp ) for( long[] brr : arr ) Arrays.fill( brr , -1 )  ;\\n        \\n        long ans = solve( n, 7 , 7  ) ; \\n        return (int)ans ; \\n        \\n    }\\n    long solve( int n , int preva , int prevb   ){\\n\\n        if( n == 0 ) {\\n            // System.out.println( pat ) ; \\n            return 1 ; \\n        }\\n        if( dp[n][preva][prevb] != -1 ) return dp[n][preva][prevb] ; \\n        long ans = 0 ; \\n        for( int k = 1 ; k <=6 ; k++ ){\\n\\n            if( k == preva || k == prevb ) continue ; \\n\\n            \\n            if( preva == 7 ){\\n                long a = solve( n-1, k, 7  ) ;\\n                ans = ( ans + a ) %mod ; \\n            }else if( prevb == 7  ){\\n                int gcda = gcd(k, preva ) ; \\n                if( gcda == 1 ){\\n                    long res = solve( n-1, k  , preva   ) ;\\n                    ans = ( ans + res) %mod ;  \\n                }\\n            }else{\\n                int gcda = gcd( k, preva) ; \\n                if( gcda == 1 ){\\n                    long res = solve( n-1,  k, preva ) ;\\n                    ans = ( ans + res )%mod ;  \\n                }\\n\\n            }\\n        }\\n        dp[n][preva][prevb] = ans ; \\n        return ans ; \\n    }\\n    int gcd( int a , int b ){\\n\\n        if( b == 0 ) return a ; \\n        return gcd( b,  a%b ) ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long mod = (long)Math.pow(10,  9 ) + 7 ; \\n    long[][][] dp ; \\n    public int distinctSequences(int n) {\\n        dp = new long[n+1][8][8] ; \\n        for( long[][] arr : dp ) for( long[] brr : arr ) Arrays.fill( brr , -1 )  ;\\n        \\n        long ans = solve( n, 7 , 7  ) ; \\n        return (int)ans ; \\n        \\n    }\\n    long solve( int n , int preva , int prevb   ){\\n\\n        if( n == 0 ) {\\n            // System.out.println( pat ) ; \\n            return 1 ; \\n        }\\n        if( dp[n][preva][prevb] != -1 ) return dp[n][preva][prevb] ; \\n        long ans = 0 ; \\n        for( int k = 1 ; k <=6 ; k++ ){\\n\\n            if( k == preva || k == prevb ) continue ; \\n\\n            \\n            if( preva == 7 ){\\n                long a = solve( n-1, k, 7  ) ;\\n                ans = ( ans + a ) %mod ; \\n            }else if( prevb == 7  ){\\n                int gcda = gcd(k, preva ) ; \\n                if( gcda == 1 ){\\n                    long res = solve( n-1, k  , preva   ) ;\\n                    ans = ( ans + res) %mod ;  \\n                }\\n            }else{\\n                int gcda = gcd( k, preva) ; \\n                if( gcda == 1 ){\\n                    long res = solve( n-1,  k, preva ) ;\\n                    ans = ( ans + res )%mod ;  \\n                }\\n\\n            }\\n        }\\n        dp[n][preva][prevb] = ans ; \\n        return ans ; \\n    }\\n    int gcd( int a , int b ){\\n\\n        if( b == 0 ) return a ; \\n        return gcd( b,  a%b ) ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893701,
                "title": "c-3d-dp-with-logic-to-print-all-combinations",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int cache[10005][7][7];\\n    const int mod = 1e9 + 7;\\n    bool canAdd(int i, vector<int> &rolls) {\\n        int n = rolls.size(), r = n - 1, l = max(0, n - 2);\\n        if(n == 0) return true;\\n        int a = __gcd(rolls[n - 1], i);\\n        while(r >= l) {\\n            if(i == rolls[r]) return false;\\n            --r;\\n        }\\n        return a == 1;\\n        \\n    }\\n    int get(int n, int last, int secondLast, vector<int> &rolls) {\\n        if(n <= 0) {\\n            //You can print Rolls to see all combinations. \\n            return 1;\\n        }\\n        if(cache[n][last][secondLast] != -1) return cache[n][last][secondLast];\\n        int res = 0;\\n        for(int i = 1; i <= 6; ++i) {\\n            if(canAdd(i, rolls)) {\\n                rolls.push_back(i);\\n                res = (res + get(n - 1, secondLast, i, rolls) % mod) % mod;\\n                rolls.pop_back();\\n            }\\n        }\\n        return cache[n][last][secondLast] = res % mod;\\n    }\\n    int distinctSequences(int n) {\\n        vector<int> rolls;\\n        memset(cache, -1, sizeof(cache));\\n        return get(n, 0, 0, rolls);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int cache[10005][7][7];\\n    const int mod = 1e9 + 7;\\n    bool canAdd(int i, vector<int> &rolls) {\\n        int n = rolls.size(), r = n - 1, l = max(0, n - 2);\\n        if(n == 0) return true;\\n        int a = __gcd(rolls[n - 1], i);\\n        while(r >= l) {\\n            if(i == rolls[r]) return false;\\n            --r;\\n        }\\n        return a == 1;\\n        \\n    }\\n    int get(int n, int last, int secondLast, vector<int> &rolls) {\\n        if(n <= 0) {\\n            //You can print Rolls to see all combinations. \\n            return 1;\\n        }\\n        if(cache[n][last][secondLast] != -1) return cache[n][last][secondLast];\\n        int res = 0;\\n        for(int i = 1; i <= 6; ++i) {\\n            if(canAdd(i, rolls)) {\\n                rolls.push_back(i);\\n                res = (res + get(n - 1, secondLast, i, rolls) % mod) % mod;\\n                rolls.pop_back();\\n            }\\n        }\\n        return cache[n][last][secondLast] = res % mod;\\n    }\\n    int distinctSequences(int n) {\\n        vector<int> rolls;\\n        memset(cache, -1, sizeof(cache));\\n        return get(n, 0, 0, rolls);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883539,
                "title": "rust-dynamic-programming-o-1-space",
                "content": "# Code\\n```\\nconst DICE_LEN: usize = 7;\\nconst MOD: usize = 1_000_000_007;\\n\\npub fn gen_next_map() -> [u8; DICE_LEN] {\\n    [\\n        0b1111110, // 0 -> [1, 2, 3, 4, 5, 6]\\n        0b1111100, // 1 -> [2, 3, 4, 5, 6]\\n        0b0101010, // 2 -> [1, 3, 5]\\n        0b0110110, // 3 -> [1, 2, 4, 5]\\n        0b0101010, // 4 -> [1, 3, 5]\\n        0b1011110, // 5 -> [1, 2, 3, 4, 6]\\n        0b0100010, // 6 -> [1, 5]\\n    ]\\n}\\n\\nimpl Solution {\\n    pub fn distinct_sequences(n: i32) -> i32 {\\n        let n = n as usize - 1;\\n\\n        let next_map = gen_next_map();\\n\\n        let mut dp = [[usize::MIN; DICE_LEN]; DICE_LEN];\\n        for j in 1..DICE_LEN {\\n            dp[usize::MIN][j] = 1;\\n        }\\n\\n        for _ in 0..n {\\n            let mut dp_next = [[usize::MIN; DICE_LEN]; DICE_LEN];\\n\\n            for prev in 0..DICE_LEN {\\n                for i in 0..DICE_LEN {\\n                    let flags = next_map[i] & !(1 << prev);\\n\\n                    for j in 0..DICE_LEN {\\n                        if (flags >> j) & 1 < 1 { continue; }\\n                        \\n                        dp_next[i][j] += dp[prev][i];\\n                    }\\n                }\\n            }\\n\\n            for i in 0..DICE_LEN {\\n                for j in 0..DICE_LEN {\\n                    dp_next[i][j] %= MOD;\\n                }\\n            }\\n            dp = dp_next;\\n        }\\n\\n        let ret = dp.into_iter()\\n            .map(|v| v.into_iter().sum::<usize>() % MOD)\\n            .sum::<usize>() % MOD;\\n        ret as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst DICE_LEN: usize = 7;\\nconst MOD: usize = 1_000_000_007;\\n\\npub fn gen_next_map() -> [u8; DICE_LEN] {\\n    [\\n        0b1111110, // 0 -> [1, 2, 3, 4, 5, 6]\\n        0b1111100, // 1 -> [2, 3, 4, 5, 6]\\n        0b0101010, // 2 -> [1, 3, 5]\\n        0b0110110, // 3 -> [1, 2, 4, 5]\\n        0b0101010, // 4 -> [1, 3, 5]\\n        0b1011110, // 5 -> [1, 2, 3, 4, 6]\\n        0b0100010, // 6 -> [1, 5]\\n    ]\\n}\\n\\nimpl Solution {\\n    pub fn distinct_sequences(n: i32) -> i32 {\\n        let n = n as usize - 1;\\n\\n        let next_map = gen_next_map();\\n\\n        let mut dp = [[usize::MIN; DICE_LEN]; DICE_LEN];\\n        for j in 1..DICE_LEN {\\n            dp[usize::MIN][j] = 1;\\n        }\\n\\n        for _ in 0..n {\\n            let mut dp_next = [[usize::MIN; DICE_LEN]; DICE_LEN];\\n\\n            for prev in 0..DICE_LEN {\\n                for i in 0..DICE_LEN {\\n                    let flags = next_map[i] & !(1 << prev);\\n\\n                    for j in 0..DICE_LEN {\\n                        if (flags >> j) & 1 < 1 { continue; }\\n                        \\n                        dp_next[i][j] += dp[prev][i];\\n                    }\\n                }\\n            }\\n\\n            for i in 0..DICE_LEN {\\n                for j in 0..DICE_LEN {\\n                    dp_next[i][j] %= MOD;\\n                }\\n            }\\n            dp = dp_next;\\n        }\\n\\n        let ret = dp.into_iter()\\n            .map(|v| v.into_iter().sum::<usize>() % MOD)\\n            .sum::<usize>() % MOD;\\n        ret as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806350,
                "title": "c-solution-using-dp",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    int mod = 1e9+7;\\n    vector<int>possibleNumbers[7];\\n    #define ll long long\\n\\n    ll dp[10001][7][7];\\n\\n    ll solve(int n, int prev1, int prev2){\\n\\n        if(n == 0){\\n            return 1;\\n        }\\n\\n        if(dp[n][prev1][prev2]!=-1)\\n            return dp[n][prev1][prev2];\\n\\n        ll res = 0;\\n        for(auto it: possibleNumbers[prev1]){\\n            if(prev2!=it){\\n                res+=solve(n-1, it, prev1)%mod;\\n            }\\n        }\\n\\n        return dp[n][prev1][prev2] = res%mod;\\n    }\\n\\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=1;i<=6;i++){\\n            for(int j=1;j<=6;j++){\\n                if(i==j) continue;\\n                int gcd = __gcd(i, j);\\n                if(gcd == 1){\\n                    possibleNumbers[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        ll res = 0;\\n        for(int i=1;i<=6;i++){\\n            res+=solve(n-1, i, 0);\\n            res%=mod;\\n        }\\n\\n        return (int)res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int mod = 1e9+7;\\n    vector<int>possibleNumbers[7];\\n    #define ll long long\\n\\n    ll dp[10001][7][7];\\n\\n    ll solve(int n, int prev1, int prev2){\\n\\n        if(n == 0){\\n            return 1;\\n        }\\n\\n        if(dp[n][prev1][prev2]!=-1)\\n            return dp[n][prev1][prev2];\\n\\n        ll res = 0;\\n        for(auto it: possibleNumbers[prev1]){\\n            if(prev2!=it){\\n                res+=solve(n-1, it, prev1)%mod;\\n            }\\n        }\\n\\n        return dp[n][prev1][prev2] = res%mod;\\n    }\\n\\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=1;i<=6;i++){\\n            for(int j=1;j<=6;j++){\\n                if(i==j) continue;\\n                int gcd = __gcd(i, j);\\n                if(gcd == 1){\\n                    possibleNumbers[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        ll res = 0;\\n        for(int i=1;i<=6;i++){\\n            res+=solve(n-1, i, 0);\\n            res%=mod;\\n        }\\n\\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763367,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "```dp[i][x][y]``` is a sequence whose length is ```i``` and last two numbers are x and y.\\nfor each length 3 ~ n,\\nenumerating each possible pairs (x, y),\\nif x != y and gcd of x and y is 1,\\ndp[i][x][y] = sum(dp[i-1][y][z] for z in 1...6 if z != x)\\n\\ntc is O(6 * 6 * 6 * n), sc is O(6 * 6 * n)\\n### python\\n```python\\nmod = int(10**9 + 7)\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        def gcd(x, y):\\n            return x if y == 0 else gcd(y, x % y)\\n        \\n        dp = [[[0] * 6 for _ in range(6)] for _ in range(n+1)]\\n        dp[2] = [[int(i != j and gcd(i+1, j+1) == 1) for j in range(6)] for i in range(6)]\\n        for i in range(3, n+1):\\n            for x in range(6):\\n                for y in range(6):\\n                    if x != y and gcd(x+1, y+1) == 1:\\n                        dp[i][x][y] = sum(dp[i-1][y][z] for z in range(6) if z != x) % mod\\n        return sum(sum(row) for row in dp[n]) % mod\\n```\\n\\n### c++\\n```cpp\\nconst int mod = 1e9 + 7; \\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        function<int(int, int)> gcd = [&gcd] (int x, int y) { return y == 0 ? x:  gcd(y, x % y);};\\n        if (n == 1) return 6;\\n        vector<vector<vector<int>>> dp (n+1, vector<vector<int>> (6, vector<int>(6, 0)));\\n        for (int i = 0; i < 6; i++) {\\n            for (int j = 0; j < 6; j++)\\n                dp[2][i][j] = i != j && gcd(i+1, j+1) == 1; \\n        }\\n        \\n        for (int i = 3; i <= n; i++) {\\n            for (int x = 0; x < 6; x++) {\\n                for (int y = 0; y < 6; y++) {\\n                    if (x != y && gcd(x+1, y+1) == 1) {\\n                        for (int z = 0; z < 6; z++) {\\n                            if (z != x) dp[i][x][y] = (dp[i][x][y] + dp[i-1][y][z]) % mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < 6; i++) {\\n            for (int j = 0; j < 6; j++)\\n                ans = (ans + dp[n][i][j]) % mod;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][x][y]```\n```i```\n```python\\nmod = int(10**9 + 7)\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        def gcd(x, y):\\n            return x if y == 0 else gcd(y, x % y)\\n        \\n        dp = [[[0] * 6 for _ in range(6)] for _ in range(n+1)]\\n        dp[2] = [[int(i != j and gcd(i+1, j+1) == 1) for j in range(6)] for i in range(6)]\\n        for i in range(3, n+1):\\n            for x in range(6):\\n                for y in range(6):\\n                    if x != y and gcd(x+1, y+1) == 1:\\n                        dp[i][x][y] = sum(dp[i-1][y][z] for z in range(6) if z != x) % mod\\n        return sum(sum(row) for row in dp[n]) % mod\\n```\n```cpp\\nconst int mod = 1e9 + 7; \\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        function<int(int, int)> gcd = [&gcd] (int x, int y) { return y == 0 ? x:  gcd(y, x % y);};\\n        if (n == 1) return 6;\\n        vector<vector<vector<int>>> dp (n+1, vector<vector<int>> (6, vector<int>(6, 0)));\\n        for (int i = 0; i < 6; i++) {\\n            for (int j = 0; j < 6; j++)\\n                dp[2][i][j] = i != j && gcd(i+1, j+1) == 1; \\n        }\\n        \\n        for (int i = 3; i <= n; i++) {\\n            for (int x = 0; x < 6; x++) {\\n                for (int y = 0; y < 6; y++) {\\n                    if (x != y && gcd(x+1, y+1) == 1) {\\n                        for (int z = 0; z < 6; z++) {\\n                            if (z != x) dp[i][x][y] = (dp[i][x][y] + dp[i-1][y][z]) % mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < 6; i++) {\\n            for (int j = 0; j < 6; j++)\\n                ans = (ans + dp[n][i][j]) % mod;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759830,
                "title": "don-t-understand-why-adding-lru-cache-makes-output-change",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is still using DFS. Just I use dictionary to track the index of each number being used for the last time. And if the current index - last time > 2, then this number can be used this time.\\n\\nIt works when not adding lru_cache, but gets TLE. I add lru_cache(), but get a different answer for test cases. Dont\\' understand why this happened. \\n\\n# Code\\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        d = defaultdict( lambda: float(\\'Inf\\'))\\n\\n        mod = 10**9 + 7\\n        @lru_cache()\\n        def traverse(pre, cnt):\\n            \\n            if cnt ==n:\\n                return 1\\n            res = 0\\n            for i in range(1, 7):\\n               \\n                if gcd(pre, i) == 1 and abs(cnt-d[i]) >2:\\n                   \\n                    t = d[i]\\n                    d[i] = cnt\\n                    res += (traverse(i, cnt + 1) )\\n                    d[i] = t\\n         \\n            return res%mod\\n        \\n        return traverse(-1, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        d = defaultdict( lambda: float(\\'Inf\\'))\\n\\n        mod = 10**9 + 7\\n        @lru_cache()\\n        def traverse(pre, cnt):\\n            \\n            if cnt ==n:\\n                return 1\\n            res = 0\\n            for i in range(1, 7):\\n               \\n                if gcd(pre, i) == 1 and abs(cnt-d[i]) >2:\\n                   \\n                    t = d[i]\\n                    d[i] = cnt\\n                    res += (traverse(i, cnt + 1) )\\n                    d[i] = t\\n         \\n            return res%mod\\n        \\n        return traverse(-1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659769,
                "title": "python3-simple-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        MOD = 1_000_000_007\\n        \\n        def gcd(a, b):\\n            if b==0: return a\\n            return gcd(b, a%b)\\n        gcdMap = defaultdict(list)\\n        for i in range(1, 7):\\n            for j in range(1, 7):\\n                if gcd(i, j) == 1:\\n                    gcdMap[i].append(j)\\n        gcdMap[-1] = [1,2,3,4,5,6]\\n\\n        @cache\\n        def helper(prev1, prev2, cnt):\\n            if cnt==n: return 1\\n            ret = 0\\n            for i in gcdMap[prev2]:\\n                if prev1 == i or prev2 == i: continue\\n                ret = (ret + helper(prev2, i, cnt+1)) % MOD\\n            return ret\\n\\n        ans = helper(-1, -1, 0) % MOD\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        MOD = 1_000_000_007\\n        \\n        def gcd(a, b):\\n            if b==0: return a\\n            return gcd(b, a%b)\\n        gcdMap = defaultdict(list)\\n        for i in range(1, 7):\\n            for j in range(1, 7):\\n                if gcd(i, j) == 1:\\n                    gcdMap[i].append(j)\\n        gcdMap[-1] = [1,2,3,4,5,6]\\n\\n        @cache\\n        def helper(prev1, prev2, cnt):\\n            if cnt==n: return 1\\n            ret = 0\\n            for i in gcdMap[prev2]:\\n                if prev1 == i or prev2 == i: continue\\n                ret = (ret + helper(prev2, i, cnt+1)) % MOD\\n            return ret\\n\\n        ans = helper(-1, -1, 0) % MOD\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608197,
                "title": "recursion-and-memoization",
                "content": "# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int ind, int prev1, int prev2, int n)\\n{\\n    if (ind == n)\\n    {\\n        return 1;\\n    }\\n\\n    int count = 0;\\n    for (int i = 1; i <= 6; i++)\\n    {\\n        if (prev1 != i and prev2 != i and (prev1 == 0 or __gcd(prev1, i) == 1))\\n        {\\n            count += solve(ind + 1, i, prev1, n);\\n        }\\n    }\\n    return count;\\n}\\n\\nint DP(int ind, int prev1, int prev2, int n, vector<vector<vector<int>>> &dp)\\n{\\n    if (ind == n)\\n    {\\n        return 1;\\n    }\\n\\n    if (dp[ind][prev1][prev2] != -1)\\n    {\\n        return dp[ind][prev1][prev2];\\n    }\\n\\n    int count = 0;\\n    for (int i = 1; i <= 6; i++)\\n    {\\n        if (prev1 != i and prev2 != i and (prev1 == 0 or __gcd(prev1, i) == 1))\\n        {\\n            count += DP(ind + 1, i, prev1, n, dp);\\n            count %= mod;\\n        }\\n    }\\n    return dp[ind][prev1][prev2] = count;\\n}\\n\\nint distinctSequences(int n)\\n{\\n    // return solve(0, 0, 0, n);\\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(7, vector<int>(7, -1)));\\n    return DP(0, 0, 0, n, dp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int ind, int prev1, int prev2, int n)\\n{\\n    if (ind == n)\\n    {\\n        return 1;\\n    }\\n\\n    int count = 0;\\n    for (int i = 1; i <= 6; i++)\\n    {\\n        if (prev1 != i and prev2 != i and (prev1 == 0 or __gcd(prev1, i) == 1))\\n        {\\n            count += solve(ind + 1, i, prev1, n);\\n        }\\n    }\\n    return count;\\n}\\n\\nint DP(int ind, int prev1, int prev2, int n, vector<vector<vector<int>>> &dp)\\n{\\n    if (ind == n)\\n    {\\n        return 1;\\n    }\\n\\n    if (dp[ind][prev1][prev2] != -1)\\n    {\\n        return dp[ind][prev1][prev2];\\n    }\\n\\n    int count = 0;\\n    for (int i = 1; i <= 6; i++)\\n    {\\n        if (prev1 != i and prev2 != i and (prev1 == 0 or __gcd(prev1, i) == 1))\\n        {\\n            count += DP(ind + 1, i, prev1, n, dp);\\n            count %= mod;\\n        }\\n    }\\n    return dp[ind][prev1][prev2] = count;\\n}\\n\\nint distinctSequences(int n)\\n{\\n    // return solve(0, 0, 0, n);\\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(7, vector<int>(7, -1)));\\n    return DP(0, 0, 0, n, dp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608189,
                "title": "recursive-and-memoization-approach",
                "content": "# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int ind, int prev1, int prev2, int n)\\n{\\n    if (ind == n)\\n    {\\n        return 1;\\n    }\\n\\n    int count = 0;\\n    for (int i = 1; i <= 6; i++)\\n    {\\n        if (prev1 != i and prev2 != i and (prev1 == 0 or __gcd(prev1, i) == 1))\\n        {\\n            count += solve(ind + 1, i, prev1, n);\\n        }\\n    }\\n    return count;\\n}\\n\\nint DP(int ind, int prev1, int prev2, int n, vector<vector<vector<int>>> &dp)\\n{\\n    if (ind == n)\\n    {\\n        return 1;\\n    }\\n\\n    if (dp[ind][prev1][prev2] != -1)\\n    {\\n        return dp[ind][prev1][prev2];\\n    }\\n\\n    int count = 0;\\n    for (int i = 1; i <= 6; i++)\\n    {\\n        if (prev1 != i and prev2 != i and (prev1 == 0 or __gcd(prev1, i) == 1))\\n        {\\n            count += DP(ind + 1, i, prev1, n, dp);\\n            count %= mod;\\n        }\\n    }\\n    return dp[ind][prev1][prev2] = count;\\n}\\n\\nint distinctSequences(int n)\\n{\\n    // return solve(0, 0, 0, n);\\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(7, vector<int>(7, -1)));\\n    return DP(0, 0, 0, n, dp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int ind, int prev1, int prev2, int n)\\n{\\n    if (ind == n)\\n    {\\n        return 1;\\n    }\\n\\n    int count = 0;\\n    for (int i = 1; i <= 6; i++)\\n    {\\n        if (prev1 != i and prev2 != i and (prev1 == 0 or __gcd(prev1, i) == 1))\\n        {\\n            count += solve(ind + 1, i, prev1, n);\\n        }\\n    }\\n    return count;\\n}\\n\\nint DP(int ind, int prev1, int prev2, int n, vector<vector<vector<int>>> &dp)\\n{\\n    if (ind == n)\\n    {\\n        return 1;\\n    }\\n\\n    if (dp[ind][prev1][prev2] != -1)\\n    {\\n        return dp[ind][prev1][prev2];\\n    }\\n\\n    int count = 0;\\n    for (int i = 1; i <= 6; i++)\\n    {\\n        if (prev1 != i and prev2 != i and (prev1 == 0 or __gcd(prev1, i) == 1))\\n        {\\n            count += DP(ind + 1, i, prev1, n, dp);\\n            count %= mod;\\n        }\\n    }\\n    return dp[ind][prev1][prev2] = count;\\n}\\n\\nint distinctSequences(int n)\\n{\\n    // return solve(0, 0, 0, n);\\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(7, vector<int>(7, -1)));\\n    return DP(0, 0, 0, n, dp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561993,
                "title": "c-recursion-memoization-tabulation-3-d-dp-space-optimisation",
                "content": "```\\n2 conditions --> \\n1). gcd of adjacent pairs must be 1.\\n2). Repetitive values can be taken at a gap of 2 or more.\\n```\\n```\\nIn order to simulate the process according to the given condition, we need to keep \\ntrack of the previously taken outcome and previous of the previous outcome (prev2).\\nSo, try out all the possibilities and count the number of ways to make a distinct \\nsequence. Now, observe here, we have 3 changing parameters i.e. n, prev, prev2.\\nSo, to futher apply dynamic programming, we need to use a 3-D DP.\\n```\\n\\n```\\nApproach 1 --> Recursion (TLE)\\nTime Complexity --> exponential\\nSpace Complexity --> O(n)\\n```\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int n, int prev, int prev2) {\\n        if(n == 0) {  // Base case\\n            return 1;\\n        }\\n        int curr = 0;\\n        for(int roll = 1; roll <= 6; roll++) {\\n            if(prev == 0) {  // first pick\\n                curr = (curr + solve(n - 1, roll, prev)) % mod;\\n            }\\n            else if(prev2 == 0) {  // second pick\\n                if(prev != roll && __gcd(prev, roll) == 1) {\\n                    curr = (curr + solve(n - 1, roll, prev)) % mod;\\n                }\\n            }\\n            else if(prev2 != roll && prev != roll && __gcd(prev, roll) == 1) {\\n                curr = (curr + solve(n - 1, roll, prev)) % mod;\\n            }\\n        }\\n        return curr;\\n    }\\n    int distinctSequences(int n) {\\n\\t\\t// initially nothing in the sequence, so take prev and prev2 as 0.\\n        return solve(n, 0, 0);\\n    }\\n};\\n```\\n```\\nApproach 2 --> Memoization (Accepted)\\nTime Complexity --> O(n*6*6*6)\\nSpace Complexity --> O(n*7*7) + stack space\\n```\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int n, int prev, int prev2, vector<vector<vector<int>>>& dp) {\\n        if(n == 0) {  // Base case\\n            return 1;\\n        }\\n\\t\\tif(dp[n][prev][prev2] != -1) {\\n\\t\\t\\treturn dp[n][prev][prev2];\\n\\t\\t}\\n        int curr = 0;\\n        for(int roll = 1; roll <= 6; roll++) {\\n            if(prev == 0) {  // first pick\\n                curr = (curr + solve(n - 1, roll, prev, dp)) % mod;\\n            }\\n            else if(prev2 == 0) {  // second pick\\n                if(prev != roll && __gcd(prev, roll) == 1) {\\n                    curr = (curr + solve(n - 1, roll, prev, dp)) % mod;\\n                }\\n            }\\n            else if(prev2 != roll && prev != roll && __gcd(prev, roll) == 1) {\\n                curr = (curr + solve(n - 1, roll, prev, dp)) % mod;\\n            }\\n        }\\n        return dp[n][prev][prev2] curr;\\n    }\\n    int distinctSequences(int n) {\\n\\t\\tvector<vector<vector<int>>> dp(n + 1, \\n\\t\\t\\t\\tvector<vector<int>> (7, vector<int> (7, -1)));\\n        return solve(n, 0, 0, dp);\\n    }\\n};\\n```\\n```\\nApproach 3 --> Tabulation \\nTime Complexity --> O(n*6*6*6)\\nSpace Complexity --> O(n*7*7)\\n```\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<vector<int>>> dp(n + 1, \\n                vector<vector<int>> (7, vector<int> (7, 0)));  \\n        // Base case\\n        for(int prev = 0; prev <= 6; prev++) {\\n            for(int prev2 = 0; prev2 <= 6; prev2++) {\\n                dp[0][prev][prev2] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            for(int prev = 0; prev <= 6; prev++) {\\n                for(int prev2 = 0; prev2 <= 6; prev2++) {\\n                    int curr = 0;\\n                    for(int roll = 1; roll <= 6; roll++) {\\n                        if(prev == 0) {  // first pick\\n                            curr = (curr + dp[i - 1][roll][prev]) % mod;\\n                        }\\n                        else if(prev2 == 0) {  // second pick\\n                            if(prev != roll && __gcd(prev, roll) == 1) {\\n                                curr = (curr + dp[i - 1][roll][prev]) % mod;\\n                            }\\n                        }\\n                        else if(prev2 != roll && prev != roll && __gcd(prev, roll) == 1) {\\n                            curr = (curr + dp[i - 1][roll][prev]) % mod;\\n                        }\\n                    }\\n                    dp[i][prev][prev2] = curr;\\n                }\\n            }\\n        }\\n        return dp[n][0][0];\\n    }\\n};\\n```\\n```\\nApproach 4 --> Space Optimisation \\nTime Complexity --> O(n*6*6*6)\\nSpace Complexity --> O(7*7 + 7*7)\\n```\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n\\t\\n        vector<vector<int>> dp(7, vector<int> (7, 0));\\n        vector<vector<int>> cur(7, vector<int> (7, 0));\\n        \\n        // Base case\\n        for(int prev = 0; prev <= 6; prev++) {\\n            for(int prev2 = 0; prev2 <= 6; prev2++) {\\n                dp[prev][prev2] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            for(int prev = 0; prev <= 6; prev++) {\\n                for(int prev2 = 0; prev2 <= 6; prev2++) {\\n                    int curr = 0;\\n                    for(int roll = 1; roll <= 6; roll++) {\\n                        if(prev == 0) {  // first pick\\n                            curr = (curr + dp[roll][prev]) % mod;\\n                        }\\n                        else if(prev2 == 0) {  // second pick\\n                            if(prev != roll && __gcd(prev, roll) == 1) {\\n                                curr = (curr + dp[roll][prev]) % mod;\\n                            }\\n                        }\\n                        else if(prev2 != roll && prev != roll && __gcd(prev, roll) == 1) {\\n                            curr = (curr + dp[roll][prev]) % mod;\\n                        }\\n                    }\\n                    cur[prev][prev2] = curr;\\n                }\\n            }\\n            dp = cur;\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n2 conditions --> \\n1). gcd of adjacent pairs must be 1.\\n2). Repetitive values can be taken at a gap of 2 or more.\\n```\n```\\nIn order to simulate the process according to the given condition, we need to keep \\ntrack of the previously taken outcome and previous of the previous outcome (prev2).\\nSo, try out all the possibilities and count the number of ways to make a distinct \\nsequence. Now, observe here, we have 3 changing parameters i.e. n, prev, prev2.\\nSo, to futher apply dynamic programming, we need to use a 3-D DP.\\n```\n```\\nApproach 1 --> Recursion (TLE)\\nTime Complexity --> exponential\\nSpace Complexity --> O(n)\\n```\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int n, int prev, int prev2) {\\n        if(n == 0) {  // Base case\\n            return 1;\\n        }\\n        int curr = 0;\\n        for(int roll = 1; roll <= 6; roll++) {\\n            if(prev == 0) {  // first pick\\n                curr = (curr + solve(n - 1, roll, prev)) % mod;\\n            }\\n            else if(prev2 == 0) {  // second pick\\n                if(prev != roll && __gcd(prev, roll) == 1) {\\n                    curr = (curr + solve(n - 1, roll, prev)) % mod;\\n                }\\n            }\\n            else if(prev2 != roll && prev != roll && __gcd(prev, roll) == 1) {\\n                curr = (curr + solve(n - 1, roll, prev)) % mod;\\n            }\\n        }\\n        return curr;\\n    }\\n    int distinctSequences(int n) {\\n\\t\\t// initially nothing in the sequence, so take prev and prev2 as 0.\\n        return solve(n, 0, 0);\\n    }\\n};\\n```\n```\\nApproach 2 --> Memoization (Accepted)\\nTime Complexity --> O(n*6*6*6)\\nSpace Complexity --> O(n*7*7) + stack space\\n```\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int n, int prev, int prev2, vector<vector<vector<int>>>& dp) {\\n        if(n == 0) {  // Base case\\n            return 1;\\n        }\\n\\t\\tif(dp[n][prev][prev2] != -1) {\\n\\t\\t\\treturn dp[n][prev][prev2];\\n\\t\\t}\\n        int curr = 0;\\n        for(int roll = 1; roll <= 6; roll++) {\\n            if(prev == 0) {  // first pick\\n                curr = (curr + solve(n - 1, roll, prev, dp)) % mod;\\n            }\\n            else if(prev2 == 0) {  // second pick\\n                if(prev != roll && __gcd(prev, roll) == 1) {\\n                    curr = (curr + solve(n - 1, roll, prev, dp)) % mod;\\n                }\\n            }\\n            else if(prev2 != roll && prev != roll && __gcd(prev, roll) == 1) {\\n                curr = (curr + solve(n - 1, roll, prev, dp)) % mod;\\n            }\\n        }\\n        return dp[n][prev][prev2] curr;\\n    }\\n    int distinctSequences(int n) {\\n\\t\\tvector<vector<vector<int>>> dp(n + 1, \\n\\t\\t\\t\\tvector<vector<int>> (7, vector<int> (7, -1)));\\n        return solve(n, 0, 0, dp);\\n    }\\n};\\n```\n```\\nApproach 3 --> Tabulation \\nTime Complexity --> O(n*6*6*6)\\nSpace Complexity --> O(n*7*7)\\n```\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<vector<int>>> dp(n + 1, \\n                vector<vector<int>> (7, vector<int> (7, 0)));  \\n        // Base case\\n        for(int prev = 0; prev <= 6; prev++) {\\n            for(int prev2 = 0; prev2 <= 6; prev2++) {\\n                dp[0][prev][prev2] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            for(int prev = 0; prev <= 6; prev++) {\\n                for(int prev2 = 0; prev2 <= 6; prev2++) {\\n                    int curr = 0;\\n                    for(int roll = 1; roll <= 6; roll++) {\\n                        if(prev == 0) {  // first pick\\n                            curr = (curr + dp[i - 1][roll][prev]) % mod;\\n                        }\\n                        else if(prev2 == 0) {  // second pick\\n                            if(prev != roll && __gcd(prev, roll) == 1) {\\n                                curr = (curr + dp[i - 1][roll][prev]) % mod;\\n                            }\\n                        }\\n                        else if(prev2 != roll && prev != roll && __gcd(prev, roll) == 1) {\\n                            curr = (curr + dp[i - 1][roll][prev]) % mod;\\n                        }\\n                    }\\n                    dp[i][prev][prev2] = curr;\\n                }\\n            }\\n        }\\n        return dp[n][0][0];\\n    }\\n};\\n```\n```\\nApproach 4 --> Space Optimisation \\nTime Complexity --> O(n*6*6*6)\\nSpace Complexity --> O(7*7 + 7*7)\\n```\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n\\t\\n        vector<vector<int>> dp(7, vector<int> (7, 0));\\n        vector<vector<int>> cur(7, vector<int> (7, 0));\\n        \\n        // Base case\\n        for(int prev = 0; prev <= 6; prev++) {\\n            for(int prev2 = 0; prev2 <= 6; prev2++) {\\n                dp[prev][prev2] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            for(int prev = 0; prev <= 6; prev++) {\\n                for(int prev2 = 0; prev2 <= 6; prev2++) {\\n                    int curr = 0;\\n                    for(int roll = 1; roll <= 6; roll++) {\\n                        if(prev == 0) {  // first pick\\n                            curr = (curr + dp[roll][prev]) % mod;\\n                        }\\n                        else if(prev2 == 0) {  // second pick\\n                            if(prev != roll && __gcd(prev, roll) == 1) {\\n                                curr = (curr + dp[roll][prev]) % mod;\\n                            }\\n                        }\\n                        else if(prev2 != roll && prev != roll && __gcd(prev, roll) == 1) {\\n                            curr = (curr + dp[roll][prev]) % mod;\\n                        }\\n                    }\\n                    cur[prev][prev2] = curr;\\n                }\\n            }\\n            dp = cur;\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539571,
                "title": "c-iterative-dynamic-programming",
                "content": "- state `(i, j)`: a roll of number `j` preceded by a roll of number `i`: `i/j = 1,2,3,4,5,6`\\n- state `(j, k)` contributes to next state `(i, j)` for all `i` and `k` if constraints met\\n- add sentinel states `dp(i, 0) = 1` to avoid edge case\\n```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        int dp[7][7] { {}, {1}, {1}, {1}, {1}, {1}, {1} };\\n        \\n        for(; n > 1; --n) {\\n            int dp2[7][7] {};\\n            for(int j = 1; j <= 6; ++j)\\n                for(int k = 0; k <= 6; ++k)\\n                    if(j != k) {\\n                        for(auto i : {1,2,3,4,5,6}) {\\n                            if(i != k && i != j && gcd(i,j) == 1) \\n                                dp2[i][j] = (dp2[i][j] + dp[j][k]) % 1\\'000\\'000\\'007;\\n                        }\\n                    }\\n            \\n            swap(dp, dp2);\\n        }\\n        \\n        return accumulate((int*)dp, ((int*)dp) + 49, 0LL, [](auto s, auto n) { return (s + n) % 1\\'000\\'000\\'007; });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        int dp[7][7] { {}, {1}, {1}, {1}, {1}, {1}, {1} };\\n        \\n        for(; n > 1; --n) {\\n            int dp2[7][7] {};\\n            for(int j = 1; j <= 6; ++j)\\n                for(int k = 0; k <= 6; ++k)\\n                    if(j != k) {\\n                        for(auto i : {1,2,3,4,5,6}) {\\n                            if(i != k && i != j && gcd(i,j) == 1) \\n                                dp2[i][j] = (dp2[i][j] + dp[j][k]) % 1\\'000\\'000\\'007;\\n                        }\\n                    }\\n            \\n            swap(dp, dp2);\\n        }\\n        \\n        return accumulate((int*)dp, ((int*)dp) + 49, 0LL, [](auto s, auto n) { return (s + n) % 1\\'000\\'000\\'007; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388888,
                "title": "recursion-memo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[7][7][10003];\\nint m=1e9+7;\\nint gcd(int a,int b)\\n{\\n    if(b==0)\\n    return a;\\n    return gcd(b,a%b);\\n}\\nint f(int i,int prev,int n)\\n{\\n    if(n==0)\\n    return 1;\\n    if(dp[i][prev][n]!=-1)\\n    return dp[i][prev][n];\\n    int ans=0;\\n    for(int it=1;it<=6;it++)\\n    {\\n      if(gcd(it,i)==1 && it!=i && it!=prev)\\n      {\\n         ans=(ans+(f(it,i,n-1)%m))%m ;\\n      }\\n    }\\n    return dp[i][prev][n]=ans;\\n}\\n    int distinctSequences(int n) {\\n        int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n\\n       for(int i=1;i<=6;i++)\\n       {\\n   \\n          ans=(ans+(f(i,0,n-1)%m))%m ;\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[7][7][10003];\\nint m=1e9+7;\\nint gcd(int a,int b)\\n{\\n    if(b==0)\\n    return a;\\n    return gcd(b,a%b);\\n}\\nint f(int i,int prev,int n)\\n{\\n    if(n==0)\\n    return 1;\\n    if(dp[i][prev][n]!=-1)\\n    return dp[i][prev][n];\\n    int ans=0;\\n    for(int it=1;it<=6;it++)\\n    {\\n      if(gcd(it,i)==1 && it!=i && it!=prev)\\n      {\\n         ans=(ans+(f(it,i,n-1)%m))%m ;\\n      }\\n    }\\n    return dp[i][prev][n]=ans;\\n}\\n    int distinctSequences(int n) {\\n        int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n\\n       for(int i=1;i<=6;i++)\\n       {\\n   \\n          ans=(ans+(f(i,0,n-1)%m))%m ;\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383780,
                "title": "clear-explanation-and-recursive-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs question states, we can only have two adjacent numbers i and j, if their GCD is 1. Hence create an array so that we can decide from i, we can move to which j\\nFor example : from 4 we can go to 1,3 and 5, coz their GCD is 1.\\nAlso the previous element of 4 can\\'t be 1,3,5. So, if our previous element is 3 and current element is 4, we can have our next number 1 and 5 only.\\n\\n# Recursive Code\\n```\\nclass Solution {\\n    int mod = (int)1e9+7;\\n    int f(int prev, int curr, int n, vector<vector<int>>& v){\\n        if(n<=0) return 1;\\n\\n        int ans =0;\\n        for(int el : v[curr]){\\n            if(el != prev){\\n                ans += f(curr, el, n-1, v);\\n                ans = ans%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<int>> v = {{}, {2,3,4,5,6}, {1,3,5}, {1,2,4,5}, {1,3,5}, {1,2,3,4,6}, {1,5}};\\n        int ans =0;\\n        for(int i=1; i<=6; i++){\\n            ans += f(0,i, n-1, v);\\n            ans = ans%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Recursive Code with Memoization\\n```\\nclass Solution {\\n    int dp[7][7][10001];\\n    int mod = (int)1e9+7;\\n    int f(int prev, int curr, int n, vector<vector<int>>& v){\\n        if(n<=0) return 1;\\n        if(dp[prev][curr][n] != -1) return dp[prev][curr][n];\\n        int ans =0;\\n        for(int el : v[curr]){\\n            if(el != prev){\\n                ans += f(curr, el, n-1, v);\\n                ans = ans%mod;\\n            }\\n        }\\n        return dp[prev][curr][n]=ans;\\n    }\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<int>> v = {{}, {2,3,4,5,6}, {1,3,5}, {1,2,4,5}, {1,3,5}, {1,2,3,4,6}, {1,5}};\\n        memset(dp, -1, sizeof(dp));\\n        int ans =0;\\n        for(int i=1; i<=6; i++){\\n            ans += f(0,i, n-1, v);\\n            ans = ans%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)1e9+7;\\n    int f(int prev, int curr, int n, vector<vector<int>>& v){\\n        if(n<=0) return 1;\\n\\n        int ans =0;\\n        for(int el : v[curr]){\\n            if(el != prev){\\n                ans += f(curr, el, n-1, v);\\n                ans = ans%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<int>> v = {{}, {2,3,4,5,6}, {1,3,5}, {1,2,4,5}, {1,3,5}, {1,2,3,4,6}, {1,5}};\\n        int ans =0;\\n        for(int i=1; i<=6; i++){\\n            ans += f(0,i, n-1, v);\\n            ans = ans%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int dp[7][7][10001];\\n    int mod = (int)1e9+7;\\n    int f(int prev, int curr, int n, vector<vector<int>>& v){\\n        if(n<=0) return 1;\\n        if(dp[prev][curr][n] != -1) return dp[prev][curr][n];\\n        int ans =0;\\n        for(int el : v[curr]){\\n            if(el != prev){\\n                ans += f(curr, el, n-1, v);\\n                ans = ans%mod;\\n            }\\n        }\\n        return dp[prev][curr][n]=ans;\\n    }\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<int>> v = {{}, {2,3,4,5,6}, {1,3,5}, {1,2,4,5}, {1,3,5}, {1,2,3,4,6}, {1,5}};\\n        memset(dp, -1, sizeof(dp));\\n        int ans =0;\\n        for(int i=1; i<=6; i++){\\n            ans += f(0,i, n-1, v);\\n            ans = ans%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338477,
                "title": "dp-tabulation-space-optimised-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nMemo -> O(N*7*7);\\nTabulation -> O(N*7*7);\\nSpaceOptimisedTabulation -> O(7*7) ie. O(1) **constant** **space**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// **Memoization**\\n    int solve(int l,int ll,int n,vector<vector<vector<int>>>& dp){\\n        if(n == 0)\\n            return 1;\\n        \\n        if(dp[n][l][ll] != -1)  \\n            return dp[n][l][ll]%1000000007;\\n\\n        long long ans = 0;\\n        for(int op=1;op<=6;op++){\\n            if(op!=ll && op!=l  && (l ==0 || gcd(l,op) ==1) )\\n                ans += solve(op,l,n-1,dp);\\n        }\\n        \\n        return dp[n][l][ll] = ans%1000000007;\\n    }\\n\\n// Tabulation\\n    int solveTab(int N){\\n        vector<vector<vector<int>>> dp(N+1,vector<vector<int>>(7,vector<int>(7,0)));\\n        for(int i=0;i<7;i++){\\n            for(int j=0;j<7;j++)\\n                dp[0][i][j]  = 1;\\n        }\\n\\n        for(int n = 1;n<=N;n++){\\n            for(int l = 6;l>=0;l--){\\n                for(int ll=6;ll>=0;ll--){\\n                    long long ans = 0;\\n                    for(int op=1;op<=6;op++){\\n                        if(op!=ll && op!=l  && (l ==0 || gcd(l,op) ==1) )\\n                            ans += dp[n-1][op][l];\\n                    }\\n        \\n                    dp[n][l][ll] = ans%1000000007;\\n                }\\n            }\\n        }\\n        return dp[N][0][0];\\n    }\\n\\n    int solveTabOpti(int N){\\n\\n        vector<vector<int>> prev (7,vector<int>(7,1));\\n        vector<vector<int>> curr (7,vector<int>(7,0));\\n\\n        for(int n = 1;n<=N;n++){\\n            for(int l = 6;l>=0;l--){\\n                for(int ll=6;ll>=0;ll--){\\n                    long long ans = 0;\\n                    for(int op=1;op<=6;op++){\\n                        if(op!=ll && op!=l  && (l ==0 || gcd(l,op) ==1) )\\n                            ans += prev[op][l];\\n                    }\\n                    curr[l][ll] = ans%1000000007;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[0][0];\\n    }\\n    int distinctSequences(int n) {\\n        // vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(7,vector<int>(7,-1)));\\n        // return solve(0,0,n,dp);\\n        // return solveTab(n);\\n        return solveTabOpti(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// **Memoization**\\n    int solve(int l,int ll,int n,vector<vector<vector<int>>>& dp){\\n        if(n == 0)\\n            return 1;\\n        \\n        if(dp[n][l][ll] != -1)  \\n            return dp[n][l][ll]%1000000007;\\n\\n        long long ans = 0;\\n        for(int op=1;op<=6;op++){\\n            if(op!=ll && op!=l  && (l ==0 || gcd(l,op) ==1) )\\n                ans += solve(op,l,n-1,dp);\\n        }\\n        \\n        return dp[n][l][ll] = ans%1000000007;\\n    }\\n\\n// Tabulation\\n    int solveTab(int N){\\n        vector<vector<vector<int>>> dp(N+1,vector<vector<int>>(7,vector<int>(7,0)));\\n        for(int i=0;i<7;i++){\\n            for(int j=0;j<7;j++)\\n                dp[0][i][j]  = 1;\\n        }\\n\\n        for(int n = 1;n<=N;n++){\\n            for(int l = 6;l>=0;l--){\\n                for(int ll=6;ll>=0;ll--){\\n                    long long ans = 0;\\n                    for(int op=1;op<=6;op++){\\n                        if(op!=ll && op!=l  && (l ==0 || gcd(l,op) ==1) )\\n                            ans += dp[n-1][op][l];\\n                    }\\n        \\n                    dp[n][l][ll] = ans%1000000007;\\n                }\\n            }\\n        }\\n        return dp[N][0][0];\\n    }\\n\\n    int solveTabOpti(int N){\\n\\n        vector<vector<int>> prev (7,vector<int>(7,1));\\n        vector<vector<int>> curr (7,vector<int>(7,0));\\n\\n        for(int n = 1;n<=N;n++){\\n            for(int l = 6;l>=0;l--){\\n                for(int ll=6;ll>=0;ll--){\\n                    long long ans = 0;\\n                    for(int op=1;op<=6;op++){\\n                        if(op!=ll && op!=l  && (l ==0 || gcd(l,op) ==1) )\\n                            ans += prev[op][l];\\n                    }\\n                    curr[l][ll] = ans%1000000007;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[0][0];\\n    }\\n    int distinctSequences(int n) {\\n        // vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(7,vector<int>(7,-1)));\\n        // return solve(0,0,n,dp);\\n        // return solveTab(n);\\n        return solveTabOpti(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338102,
                "title": "simple-3d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJUST SEE THE SOLUTION YOU WILL UNDERSTAND EVERYTHING.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    const long long int mod=1e9+7;\\n    int solve(int k,int prev,int more_prev,vector<vector<vector<long long int>>> &dp){\\n\\n        if(k==0){\\n            return 1%mod;\\n        }\\n\\n        if(dp[k][prev][more_prev]!=-1){\\n            return dp[k][prev][more_prev]%mod;\\n        }\\n\\n        long long int ans=0;\\n        for(int i=1;i<=6;i++){\\n            if(__gcd(i,prev)==1){\\n                if(i!=prev && i!=more_prev){\\n                    ans=ans+solve(k-1,i,prev,dp)%mod;\\n                }\\n            }\\n        }\\n        return dp[k][prev][more_prev]=ans%mod;\\n    }\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<vector<long long int>>> dp(n+1,vector<vector<long long int>>(7,vector<long long int>(7,-1)));\\n\\n        long long int dem=0;\\n        for(int i=1;i<=6;i++){\\n            dem=dem+solve(n-1,i,0,dp)%mod;\\n        }\\n\\n        return dem%mod;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const long long int mod=1e9+7;\\n    int solve(int k,int prev,int more_prev,vector<vector<vector<long long int>>> &dp){\\n\\n        if(k==0){\\n            return 1%mod;\\n        }\\n\\n        if(dp[k][prev][more_prev]!=-1){\\n            return dp[k][prev][more_prev]%mod;\\n        }\\n\\n        long long int ans=0;\\n        for(int i=1;i<=6;i++){\\n            if(__gcd(i,prev)==1){\\n                if(i!=prev && i!=more_prev){\\n                    ans=ans+solve(k-1,i,prev,dp)%mod;\\n                }\\n            }\\n        }\\n        return dp[k][prev][more_prev]=ans%mod;\\n    }\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<vector<long long int>>> dp(n+1,vector<vector<long long int>>(7,vector<long long int>(7,-1)));\\n\\n        long long int dem=0;\\n        for(int i=1;i<=6;i++){\\n            dem=dem+solve(n-1,i,0,dp)%mod;\\n        }\\n\\n        return dem%mod;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337857,
                "title": "java-easy-solution-no-time-taken-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/be563ebe-02bd-4384-84cc-54cd6fc21b0d_1679715852.6562078.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    private static final int k = 6, p = 1_000_000_007;\\n\\n    public int distinctSequences(int n) {\\n        if (n == 1) return 6;\\n        int counter = 0;\\n        Map<Pair, Integer> map = new HashMap<>();\\n\\t\\t//enumerate possible pairs\\n        for (int i = 1; i < k; i++) {\\n            for (int j = i + 1; j <= k; j++) {\\n                if ((i % 2 != 0 || j % 2 != 0) && (i % 3 != 0 || j % 3 != 0)) {\\n                    map.put(new Pair(i, j), counter++);\\n                    map.put(new Pair(j, i), counter++);\\n                }\\n            }\\n        }\\n\\n        if (n == 2) return counter;\\n\\n        long[][] matrix = new long[counter][counter];\\n\\t\\t//for every possible pairs (a,b) check if (a,b,c) is possible\\n\\t\\t// if so set A[index of (b,c)][index of (a,b)] = 1\\n        for (Map.Entry<Pair, Integer> entry : map.entrySet()) {\\n            int a = entry.getKey().x, b = entry.getKey().y;\\n            for (int c = 1; c <= k; c++) {\\n                if (a == c || b == c || b % 2 == 0 && c % 2 == 0 || b % 3 == 0 && c % 3 == 0) continue;\\n                matrix[map.get(new Pair(b, c))][entry.getValue()] = 1;\\n            }\\n        }\\n\\n        long[][] power = matrixPower(matrix, n - 2);\\n        int ans = 0;\\n        for (long[] row : power) {\\n            for (long a : row) {\\n                ans += a;\\n                if (ans >= p) ans -= p;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private record Pair(int x, int y) {\\n    }\\n\\n\\n    private static long[][] matrixPower(long[][] base, long pow) {\\n        int n = base.length;\\n        long[][] res = new long[n][n];\\n        for (int i = 0; i < n; i++) {\\n            res[i][i] = 1;\\n        }\\n        while (pow != 0) {\\n            if ((pow & 1) != 0) {\\n                res = multiplyMatrix(res, base);\\n                --pow;\\n            } else {\\n                base = multiplyMatrix(base, base);\\n                pow >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private static long[][] multiplyMatrix(long[][] a, long[][] b) {\\n        int n = a.length;\\n        long[][] ans = new long[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < n; k++) {\\n                    ans[i][j] += a[i][k] * b[k][j];\\n                    if (ans[i][j] >= p) ans[i][j] %= p; // remove if not modular\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    private static final int k = 6, p = 1_000_000_007;\\n\\n    public int distinctSequences(int n) {\\n        if (n == 1) return 6;\\n        int counter = 0;\\n        Map<Pair, Integer> map = new HashMap<>();\\n\\t\\t//enumerate possible pairs\\n        for (int i = 1; i < k; i++) {\\n            for (int j = i + 1; j <= k; j++) {\\n                if ((i % 2 != 0 || j % 2 != 0) && (i % 3 != 0 || j % 3 != 0)) {\\n                    map.put(new Pair(i, j), counter++);\\n                    map.put(new Pair(j, i), counter++);\\n                }\\n            }\\n        }\\n\\n        if (n == 2) return counter;\\n\\n        long[][] matrix = new long[counter][counter];\\n\\t\\t//for every possible pairs (a,b) check if (a,b,c) is possible\\n\\t\\t// if so set A[index of (b,c)][index of (a,b)] = 1\\n        for (Map.Entry<Pair, Integer> entry : map.entrySet()) {\\n            int a = entry.getKey().x, b = entry.getKey().y;\\n            for (int c = 1; c <= k; c++) {\\n                if (a == c || b == c || b % 2 == 0 && c % 2 == 0 || b % 3 == 0 && c % 3 == 0) continue;\\n                matrix[map.get(new Pair(b, c))][entry.getValue()] = 1;\\n            }\\n        }\\n\\n        long[][] power = matrixPower(matrix, n - 2);\\n        int ans = 0;\\n        for (long[] row : power) {\\n            for (long a : row) {\\n                ans += a;\\n                if (ans >= p) ans -= p;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private record Pair(int x, int y) {\\n    }\\n\\n\\n    private static long[][] matrixPower(long[][] base, long pow) {\\n        int n = base.length;\\n        long[][] res = new long[n][n];\\n        for (int i = 0; i < n; i++) {\\n            res[i][i] = 1;\\n        }\\n        while (pow != 0) {\\n            if ((pow & 1) != 0) {\\n                res = multiplyMatrix(res, base);\\n                --pow;\\n            } else {\\n                base = multiplyMatrix(base, base);\\n                pow >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private static long[][] multiplyMatrix(long[][] a, long[][] b) {\\n        int n = a.length;\\n        long[][] ans = new long[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < n; k++) {\\n                    ans[i][j] += a[i][k] * b[k][j];\\n                    if (ans[i][j] >= p) ans[i][j] %= p; // remove if not modular\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272726,
                "title": "c-easy-solution-dp-memoization-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //dp and memoization\\n    //tc=o(n*9*9)\\n    //sc=o(n*9*9)\\n    //bfs variation\\n    int mod=1e9+7;\\n    int find(int i,int pre1,int pre2,vector<vector<vector<int>>>& dp){\\n        if(i==0){\\n            return 1;\\n        }\\n        if(dp[i][pre1+1][pre2+1]!=-1){\\n            return dp[i][pre1+1][pre2+1]%mod;\\n        }\\n        int ways=0;\\n        for(int k=1;k<=6;k++){\\n            if(k!=pre1 && k!=pre2 && (pre1==-1 || __gcd(k,pre1)==1)){\\n                ways=(ways+find(i-1,k,pre1,dp))%mod;\\n            }\\n        }\\n        return dp[i][pre1+1][pre2+1]=ways%mod;\\n    }\\n    int distinctSequences(int n) {\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(10,vector<int>(10,-1)));\\n        return find(n,-1,-1,dp);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //dp and memoization\\n    //tc=o(n*9*9)\\n    //sc=o(n*9*9)\\n    //bfs variation\\n    int mod=1e9+7;\\n    int find(int i,int pre1,int pre2,vector<vector<vector<int>>>& dp){\\n        if(i==0){\\n            return 1;\\n        }\\n        if(dp[i][pre1+1][pre2+1]!=-1){\\n            return dp[i][pre1+1][pre2+1]%mod;\\n        }\\n        int ways=0;\\n        for(int k=1;k<=6;k++){\\n            if(k!=pre1 && k!=pre2 && (pre1==-1 || __gcd(k,pre1)==1)){\\n                ways=(ways+find(i-1,k,pre1,dp))%mod;\\n            }\\n        }\\n        return dp[i][pre1+1][pre2+1]=ways%mod;\\n    }\\n    int distinctSequences(int n) {\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(10,vector<int>(10,-1)));\\n        return find(n,-1,-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267011,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn distinct_sequences(n: i32) -> i32 {\\n        fn _distinct_sequences(dp: &mut Vec<Vec<Vec<i32>>>, n: usize, p: usize, pp: usize) -> i32 {\\n            if n == 0 {\\n                return 1;\\n            }\\n            if dp[n][p][pp] == 0 {\\n                for d in 1..7 {\\n                    if d != p && d != pp && (p == 0 || gcd(d, p) == 1) {\\n                        dp[n][p][pp] = (dp[n][p][pp] + _distinct_sequences(dp, n - 1, d, p)) % 1000000007;\\n                    }\\n                }\\n            }\\n            dp[n][p][pp]\\n        }\\n\\n        fn gcd(a: usize, b: usize) -> usize {\\n            if a == 0 {\\n                return b;\\n            }\\n            gcd(b % a, a)\\n        }\\n\\n        let n = n as usize;\\n        let mut dp = vec![vec![vec![0; 7]; 7]; n + 1];\\n        _distinct_sequences(&mut dp, n, 0, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distinct_sequences(n: i32) -> i32 {\\n        fn _distinct_sequences(dp: &mut Vec<Vec<Vec<i32>>>, n: usize, p: usize, pp: usize) -> i32 {\\n            if n == 0 {\\n                return 1;\\n            }\\n            if dp[n][p][pp] == 0 {\\n                for d in 1..7 {\\n                    if d != p && d != pp && (p == 0 || gcd(d, p) == 1) {\\n                        dp[n][p][pp] = (dp[n][p][pp] + _distinct_sequences(dp, n - 1, d, p)) % 1000000007;\\n                    }\\n                }\\n            }\\n            dp[n][p][pp]\\n        }\\n\\n        fn gcd(a: usize, b: usize) -> usize {\\n            if a == 0 {\\n                return b;\\n            }\\n            gcd(b % a, a)\\n        }\\n\\n        let n = n as usize;\\n        let mut dp = vec![vec![vec![0; 7]; 7]; n + 1];\\n        _distinct_sequences(&mut dp, n, 0, 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3229559,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctSequences(self, n):\\n        mod = 10**9 + 7\\n\\n        @lru_cache(None)\\n        def dfs(i,p0,p1):\\n            if i == n:\\n                return 1\\n\\n            total = 0\\n\\n            for j in range(1,7):\\n                if j not in (p0,p1) and math.gcd(p0,j) == 1: total += dfs(i+1,j,p0)\\n\\n            return total%mod\\n\\n        return dfs(0,-1,-1)\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n):\\n        mod = 10**9 + 7\\n\\n        @lru_cache(None)\\n        def dfs(i,p0,p1):\\n            if i == n:\\n                return 1\\n\\n            total = 0\\n\\n            for j in range(1,7):\\n                if j not in (p0,p1) and math.gcd(p0,j) == 1: total += dfs(i+1,j,p0)\\n\\n            return total%mod\\n\\n        return dfs(0,-1,-1)\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222539,
                "title": "c-matrix-power-solution-o-logn-time-matrix-size-9-9",
                "content": "Throw the dice `n` times, how many kinds of results will be at the end? With corresponding restrictions.\\n\\nThe results allowed for each roll of the dice are only related to the previous two, so we can combine the values of the two dice as a state. `22` of the total `6*6` states are legal. Then search and construct a `22*22` transition matrix in this way to calculate the result, the final complexity is O(22<sup>3</sup>log(n)), directly write the code and submit it should also pass (I have not tried it).\\n\\n\\n#### My optimization:\\nBy grouping different states and using the grouped group as the number of states, a smaller matrix can be constructed to calculate. Search the previous `k` states, classify according to the states of the first twice, until the number of groups will no longer increase. I started to try from `3`, and after trying to `8`, I found that `6` times is the smallest number that can distinguish different prefix groups, and the final number of groups is `9`, so that a `9*9` matrix can be constructed for calculation. The time complexity is O(9<sup>3</sup>log(n)).\\n\\n<iframe src=\"https://leetcode.com/playground/MxQirrAo/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nDirectly hardcoding the calculated matrix values can speed up the time slightly, but it is not obvious. This is my code for hardcoding the matrix, which takes only `7ms` and is faster than `100.00%` of C++ online submissions, while the previous solution takes `15ms`.\\n\\n<iframe src=\"https://leetcode.com/playground/DrgKeSjp/shared\" frameBorder=\"0\" width=\"100%\" height=\"590\"></iframe>\\n\\n##### Why can it be grouped like this?\\nIt can be observed that `1` and `5` are equivalent, and `2` and `4` are equivalent. They share same `gcd` value with others. The grouped transition matrix just puts the corresponding sequences into the same group. You can directly write the smaller transfer matrix by hand if you encounter a similar situation in the future.\\n\\nVote up if it helps",
                "solutionTags": [],
                "code": "Throw the dice `n` times, how many kinds of results will be at the end? With corresponding restrictions.\\n\\nThe results allowed for each roll of the dice are only related to the previous two, so we can combine the values of the two dice as a state. `22` of the total `6*6` states are legal. Then search and construct a `22*22` transition matrix in this way to calculate the result, the final complexity is O(22<sup>3</sup>log(n)), directly write the code and submit it should also pass (I have not tried it).\\n\\n\\n#### My optimization:\\nBy grouping different states and using the grouped group as the number of states, a smaller matrix can be constructed to calculate. Search the previous `k` states, classify according to the states of the first twice, until the number of groups will no longer increase. I started to try from `3`, and after trying to `8`, I found that `6` times is the smallest number that can distinguish different prefix groups, and the final number of groups is `9`, so that a `9*9` matrix can be constructed for calculation. The time complexity is O(9<sup>3</sup>log(n)).\\n\\n<iframe src=\"https://leetcode.com/playground/MxQirrAo/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nDirectly hardcoding the calculated matrix values can speed up the time slightly, but it is not obvious. This is my code for hardcoding the matrix, which takes only `7ms` and is faster than `100.00%` of C++ online submissions, while the previous solution takes `15ms`.\\n\\n<iframe src=\"https://leetcode.com/playground/DrgKeSjp/shared\" frameBorder=\"0\" width=\"100%\" height=\"590\"></iframe>\\n\\n##### Why can it be grouped like this?\\nIt can be observed that `1` and `5` are equivalent, and `2` and `4` are equivalent. They share same `gcd` value with others. The grouped transition matrix just puts the corresponding sequences into the same group. You can directly write the smaller transfer matrix by hand if you encounter a similar situation in the future.\\n\\nVote up if it helps",
                "codeTag": "Java"
            },
            {
                "id": 3161873,
                "title": "java-beats-96-15-time-84-62-memory",
                "content": "# Intuition\\nWhen choosing the possible outcome for the current state, we need to check for two possibilities\\n1. GCD between prev number and current should be 1\\n2. This number should not be equal to prev prev number\\n\\nThis would be a dp approach as there would be cases overlapping\\n\\n# Approach\\nTook a 2D matrix named possibilities where the entries in possibilities[i] represents the outcomes that are possible given that previous outcome is i(GCD should be 1)\\n\\nWhenever choosing a number for current state, took the possible outcomes from the array possibilities and made sure that this number is not equal to the previous previous number. Wrote a dp code for the same\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] possibilities = {\\n        {},\\n        {2,3,4,5,6},\\n        {1,3,5},\\n        {1,2,4,5},\\n        {1,3,5},\\n        {1,2,3,4,6},\\n        {1,5}\\n    };\\n\\n    int mod = 1000000007;\\n\\n    int[][][] dp = new int[7][7][10004];\\n    private int getCount(int prevPrev, int prev, int remainingCounts) {\\n        if(remainingCounts == 0) return 1;\\n        if(prev==-1) {\\n            int ans = getCount(-1,1,remainingCounts-1);\\n            ans %= mod;\\n            ans += getCount(-1,2,remainingCounts-1);\\n            ans %= mod;\\n            ans += getCount(-1,3,remainingCounts-1);\\n            ans %= mod;\\n            ans += getCount(-1,4,remainingCounts-1);\\n            ans %= mod;\\n            ans += getCount(-1,5,remainingCounts-1);\\n            ans %= mod;\\n            ans += getCount(-1,6,remainingCounts-1);\\n            ans %= mod;\\n            return ans;\\n        }\\n\\n        if(prevPrev==-1) {\\n            int ans = 0;\\n            for(int i=0; i<possibilities[prev].length; i++) {\\n                ans += getCount(prev,possibilities[prev][i], remainingCounts-1);\\n                ans %= mod;\\n            }\\n            return ans;\\n        }\\n        if(dp[prevPrev][prev][remainingCounts] != -1) return dp[prevPrev][prev][remainingCounts];\\n        int ans = 0;\\n        for(int i=0; i<possibilities[prev].length; i++) if(prevPrev != possibilities[prev][i]) {\\n            ans += getCount(prev,possibilities[prev][i], remainingCounts-1);\\n            ans %= mod;\\n        }\\n        return dp[prevPrev][prev][remainingCounts] = ans;\\n    }\\n    public int distinctSequences(int n) {\\n        for(int i=1; i<=6; i++) for(int j=1; j<=6; j++) for(int k=0; k<=n; k++) dp[i][j][k] = -1;\\n        return getCount(-1,-1,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] possibilities = {\\n        {},\\n        {2,3,4,5,6},\\n        {1,3,5},\\n        {1,2,4,5},\\n        {1,3,5},\\n        {1,2,3,4,6},\\n        {1,5}\\n    };\\n\\n    int mod = 1000000007;\\n\\n    int[][][] dp = new int[7][7][10004];\\n    private int getCount(int prevPrev, int prev, int remainingCounts) {\\n        if(remainingCounts == 0) return 1;\\n        if(prev==-1) {\\n            int ans = getCount(-1,1,remainingCounts-1);\\n            ans %= mod;\\n            ans += getCount(-1,2,remainingCounts-1);\\n            ans %= mod;\\n            ans += getCount(-1,3,remainingCounts-1);\\n            ans %= mod;\\n            ans += getCount(-1,4,remainingCounts-1);\\n            ans %= mod;\\n            ans += getCount(-1,5,remainingCounts-1);\\n            ans %= mod;\\n            ans += getCount(-1,6,remainingCounts-1);\\n            ans %= mod;\\n            return ans;\\n        }\\n\\n        if(prevPrev==-1) {\\n            int ans = 0;\\n            for(int i=0; i<possibilities[prev].length; i++) {\\n                ans += getCount(prev,possibilities[prev][i], remainingCounts-1);\\n                ans %= mod;\\n            }\\n            return ans;\\n        }\\n        if(dp[prevPrev][prev][remainingCounts] != -1) return dp[prevPrev][prev][remainingCounts];\\n        int ans = 0;\\n        for(int i=0; i<possibilities[prev].length; i++) if(prevPrev != possibilities[prev][i]) {\\n            ans += getCount(prev,possibilities[prev][i], remainingCounts-1);\\n            ans %= mod;\\n        }\\n        return dp[prevPrev][prev][remainingCounts] = ans;\\n    }\\n    public int distinctSequences(int n) {\\n        for(int i=1; i<=6; i++) for(int j=1; j<=6; j++) for(int k=0; k<=n; k++) dp[i][j][k] = -1;\\n        return getCount(-1,-1,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140905,
                "title": "c-easy-fast-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[7][7][10002];\\n    int solve(int prev1,int prev2,int n)\\n    {\\n\\n        if(n==0)\\n        return 1;\\n\\n        if(dp[prev1][prev2][n]!=-1)\\n        return dp[prev1][prev2][n];\\n\\n        int res=0;\\n        for(int i=1;i<=6;i++)\\n        {\\n            if((prev1!=i and prev2!=i) and (prev1==0 || gcd(prev1,i)==1))\\n            res=res%mod+solve(i,prev1,n-1);\\n        }\\n        return dp[prev1][prev2][n]=res%mod;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[7][7][10002];\\n    int solve(int prev1,int prev2,int n)\\n    {\\n\\n        if(n==0)\\n        return 1;\\n\\n        if(dp[prev1][prev2][n]!=-1)\\n        return dp[prev1][prev2][n];\\n\\n        int res=0;\\n        for(int i=1;i<=6;i++)\\n        {\\n            if((prev1!=i and prev2!=i) and (prev1==0 || gcd(prev1,i)==1))\\n            res=res%mod+solve(i,prev1,n-1);\\n        }\\n        return dp[prev1][prev2][n]=res%mod;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103393,
                "title": "video-solution",
                "content": "Here is a video solution to it.\\n\\nhttps://youtu.be/7BBPd5YTFQI\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    int count(int n,int prev1,int prev2,vector<vector<vector<int>>> &Mem){\\n        if(Mem[n][prev1+1][prev2+1] != -1){\\n            return Mem[n][prev1+1][prev2+1];\\n        }\\n        if(n == 0){\\n            return Mem[n][prev1+1][prev2+1] = 1;\\n        }\\n        int ans = 0;\\n        const int mod = 1e9+7;\\n        for(int num = 1; num<=6; ++num){\\n            if(prev1 == -1){\\n                ans = (ans + count( n-1, num, prev1, Mem)) % mod;\\n            }else if(prev2 == -1 && __gcd( num, prev1) == 1 && prev1 != num){\\n                ans = (ans + count( n-1, num, prev1, Mem)) % mod;\\n            }else{\\n                if(__gcd( num, prev1) == 1 && num != prev1 && num != prev2){\\n                    ans = (ans + count( n-1, num, prev1, Mem)) % mod;\\n                }\\n            }\\n        }\\n        return Mem[n][prev1+1][prev2+1] = ans;\\n    }\\n    int distinctSequences(int n) { \\n        // n = 5\\n        // 2,_,_,_,_\\n        // f( n, prev1, prev2)\\n        // n,prev1,prev2\\n        vector<vector<vector<int>>> Mem(n+1,vector<vector<int>>(10,vector<int>(10,-1)));\\n        return count( n, -1, -1, Mem);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int count(int n,int prev1,int prev2,vector<vector<vector<int>>> &Mem){\\n        if(Mem[n][prev1+1][prev2+1] != -1){\\n            return Mem[n][prev1+1][prev2+1];\\n        }\\n        if(n == 0){\\n            return Mem[n][prev1+1][prev2+1] = 1;\\n        }\\n        int ans = 0;\\n        const int mod = 1e9+7;\\n        for(int num = 1; num<=6; ++num){\\n            if(prev1 == -1){\\n                ans = (ans + count( n-1, num, prev1, Mem)) % mod;\\n            }else if(prev2 == -1 && __gcd( num, prev1) == 1 && prev1 != num){\\n                ans = (ans + count( n-1, num, prev1, Mem)) % mod;\\n            }else{\\n                if(__gcd( num, prev1) == 1 && num != prev1 && num != prev2){\\n                    ans = (ans + count( n-1, num, prev1, Mem)) % mod;\\n                }\\n            }\\n        }\\n        return Mem[n][prev1+1][prev2+1] = ans;\\n    }\\n    int distinctSequences(int n) { \\n        // n = 5\\n        // 2,_,_,_,_\\n        // f( n, prev1, prev2)\\n        // n,prev1,prev2\\n        vector<vector<vector<int>>> Mem(n+1,vector<vector<int>>(10,vector<int>(10,-1)));\\n        return count( n, -1, -1, Mem);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975967,
                "title": "java-simple-readable-memorization-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=1000000007;\\n    public int distinctSequences(int n) {\\n        int dp[][][]=new int[n][7][7];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=6;j++){\\n                for(int k=0;k<=6;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n        return dfs(0,0,0,n,dp);\\n    }\\n    int dfs(int indx, int prev,int prev2,int n,int dp[][][]){\\n        if(indx==n)return 1;\\n        if(dp[indx][prev][prev2]!=-1)return dp[indx][prev][prev2];\\n        int res=0;\\n        for(int i=1;i<=6;i++){\\n            if(i==prev || i==prev2 || (prev!=0 && gcd(prev,i)!=1))continue;\\n            res=(res+dfs(indx+1,i,prev,n,dp))%mod;\\n        }\\n        return dp[indx][prev][prev2]=res;\\n    }\\n    int gcd(int a, int b){\\n        if(b==0)return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    public int distinctSequences(int n) {\\n        int dp[][][]=new int[n][7][7];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=6;j++){\\n                for(int k=0;k<=6;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n        return dfs(0,0,0,n,dp);\\n    }\\n    int dfs(int indx, int prev,int prev2,int n,int dp[][][]){\\n        if(indx==n)return 1;\\n        if(dp[indx][prev][prev2]!=-1)return dp[indx][prev][prev2];\\n        int res=0;\\n        for(int i=1;i<=6;i++){\\n            if(i==prev || i==prev2 || (prev!=0 && gcd(prev,i)!=1))continue;\\n            res=(res+dfs(indx+1,i,prev,n,dp))%mod;\\n        }\\n        return dp[indx][prev][prev2]=res;\\n    }\\n    int gcd(int a, int b){\\n        if(b==0)return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970604,
                "title": "javascript-3-solutions-dp-itirative-dp-recursion",
                "content": "# Approach\\n- curState[number_at_current_index][number_at_previous_index]\\n- curState[2][prev] = $\\u03A3$ prevState[prev][prevOfPrev] $(prevOfPrev = 1$ $to$ $prevOfPrev = 6)$ $and$ $prevofPrev$ $!=$ $2$\\n- curState[4][prev] = $\\u03A3$ prevState[prev][prevOfPrev] $(prevOfPrev = 1$ $to$ $prevOfPrev = 6)$ $and$ $prevofPrev$ $!=$ $4$\\n- curState[5][prev] = $\\u03A3$ prevState[prev][prevOfPrev] $(prevOfPrev = 1$ $to$ $prevOfPrev = 6)$ $and$ $prevofPrev$ $!=$ $5$\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nconst coPrimes = [[], [2, 3, 4, 5, 6], [1, 3, 5], [1, 2, 4, 5],\\n    [1, 3, 5], [1, 2, 3, 4, 6], [1, 5]];\\n\\nvar distinctSequences = function(n) {\\n    if (n == 1) return 6;\\n\\n    let prevState = Array.from({ length: 7 }, () => Array(7).fill(0));\\n    const mod = 1000000007;\\n\\n    for (let i = 1; i <= 6; i++)\\n        prevState[i][i] = 1;\\n\\n    while (--n > 0) {\\n        const curState = Array.from({ length: 7 }, () => Array(7).fill(0));\\n\\n        for (let i = 1; i <= 6; i++)\\n            for (const coPrime of coPrimes[i])\\n                curState[i][coPrime] = prevState[coPrime].reduce((acc, count, prevOfPrev) =>\\n                    (acc + (prevOfPrev != i ? count : 0)) % mod, 0);\\n        \\n        prevState = curState;\\n    }\\n\\n    return prevState.reduce((acc, prev) => \\n        (acc + prev.reduce((acc, count) => acc + count)) % mod, 0);\\n};\\n```\\n# Recursion + Memorization\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n```\\nconst coPrimes = [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6], [1, 3, 5],\\n    [1, 2, 4, 5], [1, 3, 5], [1, 2, 3, 4, 6], [1, 5]];\\n\\nvar distinctSequences = function(n) {\\n    const dp = Array.from({ length: n }, \\n        () => Array.from({ length: 7 }, () => Array(7).fill(-1)));\\n\\n    const recursion = (index, prev, prevOfPrev) => {\\n        if (index == n) return 1;\\n        if (dp[index][prev][prevOfPrev] > -1) return dp[index][prev][prevOfPrev];\\n\\n        dp[index][prev][prevOfPrev] = 0;\\n\\n        for (const coPrime of coPrimes[prev])\\n            if (prevOfPrev !== coPrime)\\n                dp[index][prev][prevOfPrev] = (dp[index][prev][prevOfPrev] + \\n                    recursion(index + 1, coPrime, prev)) % 1000000007;\\n\\n        return dp[index][prev][prevOfPrev];\\n    };\\n\\n    return recursion(0, 0, 0);\\n};\\n```\\n# Generic solution for dice of any sides\\nTime complexity: $$O(n * dice * dice)$$\\nSpace complexity: $$O(n * dice * dice)$$\\n```\\nconst dice = 6, coPrimes = Array.from({ length: dice + 1 }, () => []);\\nconst gcd = (x, y) => x == 0 ? y : gcd(y % x, x);\\n\\nfor (let i = 1; i <= dice; i++)\\n    coPrimes[0].push(i);\\n\\nfor (let i = 1; i <= dice; i++)\\n    for (let j = i + 1; j <= dice; j++)\\n        if (gcd(i, j) == 1)\\n            coPrimes[i].push(j), coPrimes[j].push(i);\\n\\nvar distinctSequences = function(n) {\\n    const dp = Array.from({ length: n }, \\n        () => Array.from({ length: dice + 1 }, () => Array(dice + 1).fill(-1)));\\n\\n    const recursion = (index, prev, prevOfPrev) => {\\n        if (index == n) return 1;\\n        if (dp[index][prev][prevOfPrev] > -1) return dp[index][prev][prevOfPrev];\\n\\n        dp[index][prev][prevOfPrev] = 0;\\n\\n        for (const coPrime of coPrimes[prev])\\n            if (prevOfPrev !== coPrime)\\n                dp[index][prev][prevOfPrev] = (dp[index][prev][prevOfPrev] + \\n                    recursion(index + 1, coPrime, prev)) % 1000000007;\\n\\n        return dp[index][prev][prevOfPrev];\\n    };\\n\\n    return recursion(0, 0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nconst coPrimes = [[], [2, 3, 4, 5, 6], [1, 3, 5], [1, 2, 4, 5],\\n    [1, 3, 5], [1, 2, 3, 4, 6], [1, 5]];\\n\\nvar distinctSequences = function(n) {\\n    if (n == 1) return 6;\\n\\n    let prevState = Array.from({ length: 7 }, () => Array(7).fill(0));\\n    const mod = 1000000007;\\n\\n    for (let i = 1; i <= 6; i++)\\n        prevState[i][i] = 1;\\n\\n    while (--n > 0) {\\n        const curState = Array.from({ length: 7 }, () => Array(7).fill(0));\\n\\n        for (let i = 1; i <= 6; i++)\\n            for (const coPrime of coPrimes[i])\\n                curState[i][coPrime] = prevState[coPrime].reduce((acc, count, prevOfPrev) =>\\n                    (acc + (prevOfPrev != i ? count : 0)) % mod, 0);\\n        \\n        prevState = curState;\\n    }\\n\\n    return prevState.reduce((acc, prev) => \\n        (acc + prev.reduce((acc, count) => acc + count)) % mod, 0);\\n};\\n```\n```\\nconst coPrimes = [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6], [1, 3, 5],\\n    [1, 2, 4, 5], [1, 3, 5], [1, 2, 3, 4, 6], [1, 5]];\\n\\nvar distinctSequences = function(n) {\\n    const dp = Array.from({ length: n }, \\n        () => Array.from({ length: 7 }, () => Array(7).fill(-1)));\\n\\n    const recursion = (index, prev, prevOfPrev) => {\\n        if (index == n) return 1;\\n        if (dp[index][prev][prevOfPrev] > -1) return dp[index][prev][prevOfPrev];\\n\\n        dp[index][prev][prevOfPrev] = 0;\\n\\n        for (const coPrime of coPrimes[prev])\\n            if (prevOfPrev !== coPrime)\\n                dp[index][prev][prevOfPrev] = (dp[index][prev][prevOfPrev] + \\n                    recursion(index + 1, coPrime, prev)) % 1000000007;\\n\\n        return dp[index][prev][prevOfPrev];\\n    };\\n\\n    return recursion(0, 0, 0);\\n};\\n```\n```\\nconst dice = 6, coPrimes = Array.from({ length: dice + 1 }, () => []);\\nconst gcd = (x, y) => x == 0 ? y : gcd(y % x, x);\\n\\nfor (let i = 1; i <= dice; i++)\\n    coPrimes[0].push(i);\\n\\nfor (let i = 1; i <= dice; i++)\\n    for (let j = i + 1; j <= dice; j++)\\n        if (gcd(i, j) == 1)\\n            coPrimes[i].push(j), coPrimes[j].push(i);\\n\\nvar distinctSequences = function(n) {\\n    const dp = Array.from({ length: n }, \\n        () => Array.from({ length: dice + 1 }, () => Array(dice + 1).fill(-1)));\\n\\n    const recursion = (index, prev, prevOfPrev) => {\\n        if (index == n) return 1;\\n        if (dp[index][prev][prevOfPrev] > -1) return dp[index][prev][prevOfPrev];\\n\\n        dp[index][prev][prevOfPrev] = 0;\\n\\n        for (const coPrime of coPrimes[prev])\\n            if (prevOfPrev !== coPrime)\\n                dp[index][prev][prevOfPrev] = (dp[index][prev][prevOfPrev] + \\n                    recursion(index + 1, coPrime, prev)) % 1000000007;\\n\\n        return dp[index][prev][prevOfPrev];\\n    };\\n\\n    return recursion(0, 0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2951652,
                "title": "python-memoization-hard-coding-candidates",
                "content": "# Intuition\\nOn each step, generate a set of all numbers that are allowed to be used, then recurse on subproblems and sum all solutions.\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n\\n        mod = 10**9 + 7\\n\\n        allowed = {\\n            6: set([1,5]),\\n            5: set([1,2,3,4,6]),\\n            4: set([1,3,5]),\\n            3: set([1,2,4,5]),\\n            2: set([1,3,5]),\\n            1: set([2,3,4,5,6]),\\n            0: set([1,2,3,4,5,6])\\n        }\\n\\n        @cache\\n        def dfs(i, sec_prev, prev):\\n            if i == n:\\n                return 1\\n            cand = allowed[prev] - set([sec_prev])\\n            return sum(dfs(i+1, prev, c) for c in cand)%mod\\n    \\n        return dfs(0, -1, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n\\n        mod = 10**9 + 7\\n\\n        allowed = {\\n            6: set([1,5]),\\n            5: set([1,2,3,4,6]),\\n            4: set([1,3,5]),\\n            3: set([1,2,4,5]),\\n            2: set([1,3,5]),\\n            1: set([2,3,4,5,6]),\\n            0: set([1,2,3,4,5,6])\\n        }\\n\\n        @cache\\n        def dfs(i, sec_prev, prev):\\n            if i == n:\\n                return 1\\n            cand = allowed[prev] - set([sec_prev])\\n            return sum(dfs(i+1, prev, c) for c in cand)%mod\\n    \\n        return dfs(0, -1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935223,
                "title": "c-3d-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        long dp[10001][7][7]{};\\n        vector<vector<int>> mp = {{}, {2, 3,4,5,6}, {1,3,5}, {1,2,4,5}, {1,3,5}, {1,2,3,4,6},{1,5}};\\n        long res = 0, mod = 1e9+7;\\n        for(int i = 2; i <= n; i++) {\\n            for(int j = 1; j <= 6; j++) {\\n                for(int p : mp[j]) {\\n                    if(i == 2) dp[i][j][p] = 1;\\n                    else for(int pp : mp[p]) if(pp != j) dp[i][j][p] = (dp[i][j][p]+dp[i-1][p][pp])%mod;\\n                    if(i == n) res = (res + dp[i][j][p])%mod;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        long dp[10001][7][7]{};\\n        vector<vector<int>> mp = {{}, {2, 3,4,5,6}, {1,3,5}, {1,2,4,5}, {1,3,5}, {1,2,3,4,6},{1,5}};\\n        long res = 0, mod = 1e9+7;\\n        for(int i = 2; i <= n; i++) {\\n            for(int j = 1; j <= 6; j++) {\\n                for(int p : mp[j]) {\\n                    if(i == 2) dp[i][j][p] = 1;\\n                    else for(int pp : mp[p]) if(pp != j) dp[i][j][p] = (dp[i][j][p]+dp[i-1][p][pp])%mod;\\n                    if(i == n) res = (res + dp[i][j][p])%mod;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921709,
                "title": "c-o-n-most-beautiful-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[10007][7][7], mod = 1e9+7;\\n    vector<int> prev[7];\\n\\n    int distinctSequences(int n) {\\n        if (n == 1) return 6;\\n        for (int i = 1; i <= 6; i++){\\n            for (int j = 1; j <= 6; j++){\\n                if (i != j && __gcd(i, j) == 1){\\n                    dp[2][i][j] = 1;\\n                    prev[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        for (int i = 3; i <= n; i++){\\n            for (int j = 1; j <= 6; j++){\\n                for (int k : prev[j]){\\n                    for (int l : prev[k]){\\n                        if (j != l) dp[i][j][k] = (dp[i][j][k] + dp[i-1][k][l]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int j = 1; j <= 6; j++){\\n            for (int k : prev[j]){\\n                ans = (ans + dp[n][j][k]) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10007][7][7], mod = 1e9+7;\\n    vector<int> prev[7];\\n\\n    int distinctSequences(int n) {\\n        if (n == 1) return 6;\\n        for (int i = 1; i <= 6; i++){\\n            for (int j = 1; j <= 6; j++){\\n                if (i != j && __gcd(i, j) == 1){\\n                    dp[2][i][j] = 1;\\n                    prev[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        for (int i = 3; i <= n; i++){\\n            for (int j = 1; j <= 6; j++){\\n                for (int k : prev[j]){\\n                    for (int l : prev[k]){\\n                        if (j != l) dp[i][j][k] = (dp[i][j][k] + dp[i-1][k][l]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int j = 1; j <= 6; j++){\\n            for (int k : prev[j]){\\n                ans = (ans + dp[n][j][k]) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744546,
                "title": "python-recursive-dp-68-time-7-space",
                "content": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        MOD = 10 ** 9 + 7\\n\\n        @cache\\n        def roll(n, one, two):\\n            if not n: return 1\\n            count = 0 \\n            for i in range(1, 7):\\n                if one:\\n                    if i % 2 == 0 and one % 2 == 0: continue\\n                    if (i != 1 and one != 1) and (i % one == 0 or one % i == 0): continue\\n                if i == one or i == two: continue\\n                count += roll(n - 1, i, one)\\n            return count % MOD\\n        \\n        return roll(n, 0, 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        MOD = 10 ** 9 + 7\\n\\n        @cache\\n        def roll(n, one, two):\\n            if not n: return 1\\n            count = 0 \\n            for i in range(1, 7):\\n                if one:\\n                    if i % 2 == 0 and one % 2 == 0: continue\\n                    if (i != 1 and one != 1) and (i % one == 0 or one % i == 0): continue\\n                if i == one or i == two: continue\\n                count += roll(n - 1, i, one)\\n            return count % MOD\\n        \\n        return roll(n, 0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 2707615,
                "title": "simple-dp-python",
                "content": "There are only two state parameters (rolls_left, prev_two_rolls)\\n```\\ndef distinctSequences(self, n: int) -> int:\\n    \\n    @lru_cache(None)\\n    def dp(roll, prev_two):\\n        if roll == n:\\n            return 1\\n        \\n        prev_two = list(prev_two)\\n        \\n        sequences = 0\\n        for i in range(1, 6+1):\\n            if i not in prev_two and gcd(i, prev_two[-1]) == 1:\\n                sequences += dp(roll+1, tuple([prev_two[1], i]))\\n        \\n        return sequences%1000000007\\n    \\n    return dp(0, tuple([-1, -1]))\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef distinctSequences(self, n: int) -> int:\\n    \\n    @lru_cache(None)\\n    def dp(roll, prev_two):\\n        if roll == n:\\n            return 1\\n        \\n        prev_two = list(prev_two)\\n        \\n        sequences = 0\\n        for i in range(1, 6+1):\\n            if i not in prev_two and gcd(i, prev_two[-1]) == 1:\\n                sequences += dp(roll+1, tuple([prev_two[1], i]))\\n        \\n        return sequences%1000000007\\n    \\n    return dp(0, tuple([-1, -1]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2681758,
                "title": "memoization-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    set<pair<int,int>> st;\\n    int mod=1000000007;\\n    int dp[10001][7][7];\\n    int solve(int n,int prev,int nprev)\\n    {\\n        if(n==1)\\n        {\\n            return 1;\\n        }\\n        if(dp[n][prev][nprev]!=-1)\\n        {\\n            return dp[n][prev][nprev];\\n        }\\n        int ans=0;\\n        for(int i=1;i<=6;++i)\\n        {\\n            if(st.find({prev,i})!=st.end() && i!=prev && i!=nprev)\\n            {\\n                ans=(ans%mod+solve(n-1,i,prev)%mod)%mod;\\n            }\\n        }\\n        return dp[n][prev][nprev]=ans%mod;\\n    }\\n    int distinctSequences(int n) {\\n        st.insert({1,2});st.insert({1,3});st.insert({1,4});st.insert({1,5});st.insert({1,6});\\n        st.insert({2,1});st.insert({2,3});st.insert({2,5});\\n        st.insert({3,1});st.insert({3,2});st.insert({3,4});st.insert({3,5});\\n        st.insert({4,1});st.insert({4,3});st.insert({4,5});\\n        st.insert({5,1});st.insert({5,2});st.insert({5,3});st.insert({5,4});st.insert({5,6});\\n        st.insert({6,1});st.insert({6,5});\\n        int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=1;i<=6;++i)\\n        {\\n            ans=(ans%mod+solve(n,i,0)%mod)%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<pair<int,int>> st;\\n    int mod=1000000007;\\n    int dp[10001][7][7];\\n    int solve(int n,int prev,int nprev)\\n    {\\n        if(n==1)\\n        {\\n            return 1;\\n        }\\n        if(dp[n][prev][nprev]!=-1)\\n        {\\n            return dp[n][prev][nprev];\\n        }\\n        int ans=0;\\n        for(int i=1;i<=6;++i)\\n        {\\n            if(st.find({prev,i})!=st.end() && i!=prev && i!=nprev)\\n            {\\n                ans=(ans%mod+solve(n-1,i,prev)%mod)%mod;\\n            }\\n        }\\n        return dp[n][prev][nprev]=ans%mod;\\n    }\\n    int distinctSequences(int n) {\\n        st.insert({1,2});st.insert({1,3});st.insert({1,4});st.insert({1,5});st.insert({1,6});\\n        st.insert({2,1});st.insert({2,3});st.insert({2,5});\\n        st.insert({3,1});st.insert({3,2});st.insert({3,4});st.insert({3,5});\\n        st.insert({4,1});st.insert({4,3});st.insert({4,5});\\n        st.insert({5,1});st.insert({5,2});st.insert({5,3});st.insert({5,4});st.insert({5,6});\\n        st.insert({6,1});st.insert({6,5});\\n        int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=1;i<=6;++i)\\n        {\\n            ans=(ans%mod+solve(n,i,0)%mod)%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667580,
                "title": "dp-iterative-c",
                "content": "```\\nint dp[10002][7][7];\\nint valid[7][7];\\nclass Solution {\\npublic:\\n    void createValidPairs(){\\n        valid[1][2]=1,valid[1][3]=1,valid[1][4]=1,valid[1][5]=1,valid[1][6]=1;\\n        valid[2][1]=1,valid[2][3]=1,valid[2][5]=1;\\n        valid[3][1]=1,valid[3][2]=1,valid[3][4]=1,valid[3][5]=1;\\n        valid[4][1]=1,valid[4][3]=1,valid[4][5]=1;\\n        valid[5][1]=1,valid[5][2]=1,valid[5][3]=1,valid[5][4]=1,valid[5][6]=1;\\n        valid[6][1]=1,valid[6][5]=1;\\n    }\\n    int distinctSequences(int n) {\\n        long mod = 1e9 +7;\\n        createValidPairs();\\n        if(n==1)\\n            return 6;\\n        if(n==2)\\n            return 22;\\n        for(int i=0;i<=n;i++){\\n            for(int p1=1;p1<=6;p1++){\\n                for(int p2=1;p2<=6;p2++){\\n                    dp[i][p1][p2]=0;\\n                    if(valid[p1][p2]){\\n                        if(i == 0 )\\n                            dp[i][p1][p2] = 1;\\n                        else{\\n                            for(int chosen=1;chosen<=6;chosen++){\\n                                if(valid[p2][chosen] && p1!=chosen)\\n                                    dp[i][p1][p2] =  (dp[i][p1][p2] + dp[i-1][p2][chosen])%mod;  \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        long long ans = 0;\\n        for(int p1=1;p1<=6;p1++){\\n            for(int p2=1;p2<=6;p2++){\\n                if(valid[p1][p2])\\n                    ans = (ans + dp[n-2][p1][p2])%mod;    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint dp[10002][7][7];\\nint valid[7][7];\\nclass Solution {\\npublic:\\n    void createValidPairs(){\\n        valid[1][2]=1,valid[1][3]=1,valid[1][4]=1,valid[1][5]=1,valid[1][6]=1;\\n        valid[2][1]=1,valid[2][3]=1,valid[2][5]=1;\\n        valid[3][1]=1,valid[3][2]=1,valid[3][4]=1,valid[3][5]=1;\\n        valid[4][1]=1,valid[4][3]=1,valid[4][5]=1;\\n        valid[5][1]=1,valid[5][2]=1,valid[5][3]=1,valid[5][4]=1,valid[5][6]=1;\\n        valid[6][1]=1,valid[6][5]=1;\\n    }\\n    int distinctSequences(int n) {\\n        long mod = 1e9 +7;\\n        createValidPairs();\\n        if(n==1)\\n            return 6;\\n        if(n==2)\\n            return 22;\\n        for(int i=0;i<=n;i++){\\n            for(int p1=1;p1<=6;p1++){\\n                for(int p2=1;p2<=6;p2++){\\n                    dp[i][p1][p2]=0;\\n                    if(valid[p1][p2]){\\n                        if(i == 0 )\\n                            dp[i][p1][p2] = 1;\\n                        else{\\n                            for(int chosen=1;chosen<=6;chosen++){\\n                                if(valid[p2][chosen] && p1!=chosen)\\n                                    dp[i][p1][p2] =  (dp[i][p1][p2] + dp[i-1][p2][chosen])%mod;  \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        long long ans = 0;\\n        for(int p1=1;p1<=6;p1++){\\n            for(int p2=1;p2<=6;p2++){\\n                if(valid[p1][p2])\\n                    ans = (ans + dp[n-2][p1][p2])%mod;    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617885,
                "title": "dp-commented-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int distinctSequences(int n) {\\n        vector<vector<int>> dp(6,vector<int>(n,0));\\n        for(int i=0;i<6;i++){\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<6;j++){\\n                for(int k=0;k<6;k++){\\n                    if(j!=k && __gcd(j+1,k+1)==1){\\n                        // calculate cnt of dice which have gcd==1\\n                        dp[j][i]=(dp[j][i]+dp[k][i-1])%mod;\\n                        if(i>=2){\\n                            // remove duplicate values cnt\\n                            dp[j][i]=(mod+dp[j][i]-dp[j][i-2])%mod;\\n                        }\\n                    }\\n                }\\n                if(i>=3){\\n                    // add duplicate value cnt which 2 rows back\\n                    dp[j][i]=(dp[j][i]+dp[j][i-2])%mod;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        // cnt occurence of all dice value\\n        for(int i=0;i<6;i++){\\n            ans=(ans+dp[i][n-1])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int distinctSequences(int n) {\\n        vector<vector<int>> dp(6,vector<int>(n,0));\\n        for(int i=0;i<6;i++){\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<6;j++){\\n                for(int k=0;k<6;k++){\\n                    if(j!=k && __gcd(j+1,k+1)==1){\\n                        // calculate cnt of dice which have gcd==1\\n                        dp[j][i]=(dp[j][i]+dp[k][i-1])%mod;\\n                        if(i>=2){\\n                            // remove duplicate values cnt\\n                            dp[j][i]=(mod+dp[j][i]-dp[j][i-2])%mod;\\n                        }\\n                    }\\n                }\\n                if(i>=3){\\n                    // add duplicate value cnt which 2 rows back\\n                    dp[j][i]=(dp[j][i]+dp[j][i-2])%mod;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        // cnt occurence of all dice value\\n        for(int i=0;i<6;i++){\\n            ans=(ans+dp[i][n-1])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585576,
                "title": "matrix-solution",
                "content": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    public int distinctSequences(int n){\\n        if(n==1) return 6;\\n        if(n==2) return 22;\\n        long[][] matrixOld = {{0,0,0,0,0,0,0},{5,0,1,1,1,1,1},{3,1,0,1,0,1,0},{4,1,1,0,1,1,0},{3,1,0,1,0,1,0},{5,1,1,1,1,0,1},{2,1,0,0,0,1,0}};\\n        for(int num=3;num<=n;num++){\\n            long[][] matrixNew = new long[7][7];\\n            for(int firstNumber=1;firstNumber<=6;firstNumber++){\\n                for(int secondNumber=1;secondNumber<=6;secondNumber++){\\n                    if(firstNumber==secondNumber || getGCD(firstNumber,secondNumber)!=1) continue;\\n                    matrixNew[firstNumber][secondNumber] = Math.floorMod(matrixOld[secondNumber][0] - matrixOld[secondNumber][firstNumber],MOD);\\n                }\\n            }\\n            for(int i=1;i<=6;i++){\\n                for(int j=1;j<=6;j++) matrixNew[i][0] = (matrixNew[i][0]+matrixNew[i][j])%MOD;\\n            }\\n            matrixOld = matrixNew;\\n        }\\n        return (int)((matrixOld[1][0] + matrixOld[2][0] +matrixOld[3][0] +matrixOld[4][0] +matrixOld[5][0] +matrixOld[6][0])%MOD);\\n    }\\n    public static int getGCD(int x, int y){\\n        int a = Math.max(x,y);\\n        int b = Math.min(x,y);\\n        while(b!=0){\\n            int temp = b;\\n            b = a%b;\\n            a = temp;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    public int distinctSequences(int n){\\n        if(n==1) return 6;\\n        if(n==2) return 22;\\n        long[][] matrixOld = {{0,0,0,0,0,0,0},{5,0,1,1,1,1,1},{3,1,0,1,0,1,0},{4,1,1,0,1,1,0},{3,1,0,1,0,1,0},{5,1,1,1,1,0,1},{2,1,0,0,0,1,0}};\\n        for(int num=3;num<=n;num++){\\n            long[][] matrixNew = new long[7][7];\\n            for(int firstNumber=1;firstNumber<=6;firstNumber++){\\n                for(int secondNumber=1;secondNumber<=6;secondNumber++){\\n                    if(firstNumber==secondNumber || getGCD(firstNumber,secondNumber)!=1) continue;\\n                    matrixNew[firstNumber][secondNumber] = Math.floorMod(matrixOld[secondNumber][0] - matrixOld[secondNumber][firstNumber],MOD);\\n                }\\n            }\\n            for(int i=1;i<=6;i++){\\n                for(int j=1;j<=6;j++) matrixNew[i][0] = (matrixNew[i][0]+matrixNew[i][j])%MOD;\\n            }\\n            matrixOld = matrixNew;\\n        }\\n        return (int)((matrixOld[1][0] + matrixOld[2][0] +matrixOld[3][0] +matrixOld[4][0] +matrixOld[5][0] +matrixOld[6][0])%MOD);\\n    }\\n    public static int getGCD(int x, int y){\\n        int a = Math.max(x,y);\\n        int b = Math.min(x,y);\\n        while(b!=0){\\n            int temp = b;\\n            b = a%b;\\n            a = temp;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542990,
                "title": "python-easy-sol-with-dp-memorisation-vs-lru-cache-none",
                "content": "----\\n* Simply trying DP Memorisation gave TLE\\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        \\n        dp = defaultdict(int)\\n        nxt = dict()\\n        for i in range(1,7):\\n            nxt[i] = []\\n            for v in range(1,7):\\n                if gcd(i,v)==1 and i!=v:\\n                    nxt[i].append(v)\\n        \\n        def find(i,j,k):\\n            nonlocal n\\n            if i==n:\\n                return 1\\n            if i>=n:\\n                return 0\\n            \\n            if (i,j,k) not in dp:\\n                for v in nxt[k]:\\n                    if v!=j:\\n                        dp[i,j,k] += find(i+1,k,v)\\n            return dp[i,j,k]%1000000007\\n        \\n        res = 0\\n        for i in range(1,7):\\n            res += find(1,0,i)\\n        return res%1000000007\\n```\\n----\\n----\\n\\n* But, using the same code with @lru_cache(None) it got submitted with 69.08% faster\\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        \\n        nxt = dict()\\n        for i in range(1,7):\\n            nxt[i] = []\\n            for v in range(1,7):\\n                if gcd(i,v)==1 and i!=v:\\n                    nxt[i].append(v)\\n        \\n        @lru_cache(None)\\n        def find(i,j,k):\\n            nonlocal n\\n            if i==n:\\n                return 1\\n            if i>=n:\\n                return 0\\n            \\n            t = 0\\n            for v in nxt[k]:\\n                if v!=j:\\n                    t += find(i+1,k,v)\\n            return t%1000000007\\n            \\n        res = 0\\n        for i in range(1,7):\\n            res += find(1,0,i)\\n        return res%1000000007\\n```\\n----",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        \\n        dp = defaultdict(int)\\n        nxt = dict()\\n        for i in range(1,7):\\n            nxt[i] = []\\n            for v in range(1,7):\\n                if gcd(i,v)==1 and i!=v:\\n                    nxt[i].append(v)\\n        \\n        def find(i,j,k):\\n            nonlocal n\\n            if i==n:\\n                return 1\\n            if i>=n:\\n                return 0\\n            \\n            if (i,j,k) not in dp:\\n                for v in nxt[k]:\\n                    if v!=j:\\n                        dp[i,j,k] += find(i+1,k,v)\\n            return dp[i,j,k]%1000000007\\n        \\n        res = 0\\n        for i in range(1,7):\\n            res += find(1,0,i)\\n        return res%1000000007\\n```\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        \\n        nxt = dict()\\n        for i in range(1,7):\\n            nxt[i] = []\\n            for v in range(1,7):\\n                if gcd(i,v)==1 and i!=v:\\n                    nxt[i].append(v)\\n        \\n        @lru_cache(None)\\n        def find(i,j,k):\\n            nonlocal n\\n            if i==n:\\n                return 1\\n            if i>=n:\\n                return 0\\n            \\n            t = 0\\n            for v in nxt[k]:\\n                if v!=j:\\n                    t += find(i+1,k,v)\\n            return t%1000000007\\n            \\n        res = 0\\n        for i in range(1,7):\\n            res += find(1,0,i)\\n        return res%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503373,
                "title": "python-solution-using-3d-dp",
                "content": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        dp = [[[-1 for _ in range(10 ** 4 + 5)] for _ in range(7)] for _ in range(7)]\\n        \\n        def helper(prev2: int, prev1: int, idx: int, sz: int) -> int:\\n            if idx == sz:\\n                return 1\\n            if dp[prev2][prev1][idx] != -1:\\n                return dp[prev2][prev1][idx] % (10 ** 9 + 7)\\n            ans = 0\\n            for cur in range(1, 7):\\n                if cur != prev2 and cur != prev1 and (prev1 == 0 or math.gcd(cur, prev1) == 1):\\n                    ans = ans + helper(prev1, cur, idx + 1, sz)\\n            dp[prev2][prev1][idx] = ans\\n            return ans % (10 ** 9 + 7)\\n        \\n        return helper(0, 0, 0, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        dp = [[[-1 for _ in range(10 ** 4 + 5)] for _ in range(7)] for _ in range(7)]\\n        \\n        def helper(prev2: int, prev1: int, idx: int, sz: int) -> int:\\n            if idx == sz:\\n                return 1\\n            if dp[prev2][prev1][idx] != -1:\\n                return dp[prev2][prev1][idx] % (10 ** 9 + 7)\\n            ans = 0\\n            for cur in range(1, 7):\\n                if cur != prev2 and cur != prev1 and (prev1 == 0 or math.gcd(cur, prev1) == 1):\\n                    ans = ans + helper(prev1, cur, idx + 1, sz)\\n            dp[prev2][prev1][idx] = ans\\n            return ans % (10 ** 9 + 7)\\n        \\n        return helper(0, 0, 0, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495385,
                "title": "alternative-approach-unable-to-figure-out-the-error",
                "content": "I had written this code for the problem but unable to understand the error in it, it overcounts for n = 4 as to 250, given answer was 184.\\n\\n`dp[i][j] => represents number of sequences of length i ending with j.`\\n\\n\\tSo, dp[i][j] = summation(mp[{j,k}] * dp[i-2][k]) over all k s.t. 1<=k<=6\\n\\tmp[{j,k}] => Number of numbers i s.t. gcd(i,j) and gcd(i,k) = 1 and i!=j and k\\n\\tThis is basically the number of numbers possible in the (i-1)th index\\n\\tBy default mp[{x,x}] has been set to 0. \\n```\\nclass Solution {\\npublic:\\n    const int mod =1e9+7;\\n    int distinctSequences(int n) {\\n        vector<vector<int> >dp(n+1,vector<int>(7,0));\\n        for(int i=1;i<=6;i++)\\n            dp[1][i] = 1;\\n        dp[2][1] = 5;\\n        dp[2][2] = 3;\\n        dp[2][3] = 4;\\n        dp[2][4] = 3;\\n        dp[2][5] = 5;\\n        dp[2][6] = 2;\\n        map<pair<int,int>,int>mp;\\n        for(int i=1;i<=6;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                int count = 0;\\n                for(int k=1;k<=6;k++)\\n                {\\n                    if(k==i or k==j)\\n                        continue;\\n                    if(i==j)\\n                        continue;\\n                    if(__gcd(k,i)==1 and __gcd(k,j)==1)\\n                        count++;\\n                }\\n                mp[{i,j}] = count;\\n            }\\n        }\\n        for(int i=3;i<=n;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                for(int k=1;k<=6; k++)\\n                {\\n                    dp[i][j] = (dp[i][j]%mod + (mp[{j,k}]*dp[i-2][k])%mod)%mod;\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=1;i<=6;i++)\\n            sum = (sum + dp[n][i])%mod;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod =1e9+7;\\n    int distinctSequences(int n) {\\n        vector<vector<int> >dp(n+1,vector<int>(7,0));\\n        for(int i=1;i<=6;i++)\\n            dp[1][i] = 1;\\n        dp[2][1] = 5;\\n        dp[2][2] = 3;\\n        dp[2][3] = 4;\\n        dp[2][4] = 3;\\n        dp[2][5] = 5;\\n        dp[2][6] = 2;\\n        map<pair<int,int>,int>mp;\\n        for(int i=1;i<=6;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                int count = 0;\\n                for(int k=1;k<=6;k++)\\n                {\\n                    if(k==i or k==j)\\n                        continue;\\n                    if(i==j)\\n                        continue;\\n                    if(__gcd(k,i)==1 and __gcd(k,j)==1)\\n                        count++;\\n                }\\n                mp[{i,j}] = count;\\n            }\\n        }\\n        for(int i=3;i<=n;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                for(int k=1;k<=6; k++)\\n                {\\n                    dp[i][j] = (dp[i][j]%mod + (mp[{j,k}]*dp[i-2][k])%mod)%mod;\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=1;i<=6;i++)\\n            sum = (sum + dp[n][i])%mod;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468579,
                "title": "very-easy-solution-3d-dp-c",
                "content": "*    **Memoization**\\n```\\n//                                 range [1-6]    range [1-6]\\n//index          -2        -1          0              1             (for n=n , n-1 index,here n=2)\\n\\n//              _______   ______   ---------    ----------\\n// (inititally)  prev2=0  prev1=0   cur(loop from 1 to 6)\\n\\nclass Solution {\\npublic:\\n    int dp[7][7][10005];         // all three variable are changing so make a 3d array\\n    int help(int prev2,int prev1,int idx,int sz){\\n        if(idx==sz) return 1;  // you get one valid sequence\\n        if(dp[prev2][prev1][idx]!=-1) return dp[prev2][prev1][idx];\\n        int ans=0;\\n        for(int cur=1;cur<=6;cur++){\\n            if(cur!=prev2 and cur!=prev1 and (prev1==0 or __gcd(cur,prev1)==1)){\\n                ans=(ans+help(prev1,cur,idx+1,sz))%1000000007;\\n            }\\n        }\\n        return dp[prev2][prev1][idx]=ans;\\n        \\n    }\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return help(0,0,0,n);\\n    }\\n};\\n```\\n\\n*  **Tabulation**\\n  ![image](https://assets.leetcode.com/users/images/89555ff8-0919-40e4-92f9-6aa16f85b383_1661266539.275428.png)\\n\\n\\n```\\nclass Solution {\\nprivate:\\n\\tint mod = 1e9 + 7;\\npublic:\\n\\tint distinctSequences(int n) {\\n\\t\\tint dp[n+1][7][7];\\n        memset(dp,-1,sizeof(dp));\\n        \\n\\t\\t//Base Case\\n\\t\\tfor(int prev1 = 0;prev1 < 7;prev1++)\\n\\t\\t\\tfor(int prev2 = 0;prev2 < 7;prev2++)\\n\\t\\t\\t\\tdp[n][prev1][prev2] = 1;\\n\\n\\n\\t\\tfor(int ind = n-1;ind >= 0;ind--){ //Loop Reversed\\n\\t\\t\\tfor(int prev1 = 0;prev1 < 7;prev1++){\\n\\t\\t\\t\\tfor(int prev2 = 0;prev2 < 7 ;prev2++){\\n\\t\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\t\\tfor(int i = 1;i <= 6;i++)\\n\\t\\t\\t\\t\\t\\tif(prev1 != i && prev2 != i && (prev1 == 0 || __gcd(prev1,i) == 1))\\n\\t\\t\\t\\t\\t\\t\\tans = (ans + dp[ind+1][i][prev1])%mod;\\n\\n\\t\\t\\t\\t\\tdp[ind][prev1][prev2] = ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][0][0];\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n//                                 range [1-6]    range [1-6]\\n//index          -2        -1          0              1             (for n=n , n-1 index,here n=2)\\n\\n//              _______   ______   ---------    ----------\\n// (inititally)  prev2=0  prev1=0   cur(loop from 1 to 6)\\n\\nclass Solution {\\npublic:\\n    int dp[7][7][10005];         // all three variable are changing so make a 3d array\\n    int help(int prev2,int prev1,int idx,int sz){\\n        if(idx==sz) return 1;  // you get one valid sequence\\n        if(dp[prev2][prev1][idx]!=-1) return dp[prev2][prev1][idx];\\n        int ans=0;\\n        for(int cur=1;cur<=6;cur++){\\n            if(cur!=prev2 and cur!=prev1 and (prev1==0 or __gcd(cur,prev1)==1)){\\n                ans=(ans+help(prev1,cur,idx+1,sz))%1000000007;\\n            }\\n        }\\n        return dp[prev2][prev1][idx]=ans;\\n        \\n    }\\n    int distinctSequences(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return help(0,0,0,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n\\tint mod = 1e9 + 7;\\npublic:\\n\\tint distinctSequences(int n) {\\n\\t\\tint dp[n+1][7][7];\\n        memset(dp,-1,sizeof(dp));\\n        \\n\\t\\t//Base Case\\n\\t\\tfor(int prev1 = 0;prev1 < 7;prev1++)\\n\\t\\t\\tfor(int prev2 = 0;prev2 < 7;prev2++)\\n\\t\\t\\t\\tdp[n][prev1][prev2] = 1;\\n\\n\\n\\t\\tfor(int ind = n-1;ind >= 0;ind--){ //Loop Reversed\\n\\t\\t\\tfor(int prev1 = 0;prev1 < 7;prev1++){\\n\\t\\t\\t\\tfor(int prev2 = 0;prev2 < 7 ;prev2++){\\n\\t\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\t\\tfor(int i = 1;i <= 6;i++)\\n\\t\\t\\t\\t\\t\\tif(prev1 != i && prev2 != i && (prev1 == 0 || __gcd(prev1,i) == 1))\\n\\t\\t\\t\\t\\t\\t\\tans = (ans + dp[ind+1][i][prev1])%mod;\\n\\n\\t\\t\\t\\t\\tdp[ind][prev1][prev2] = ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][0][0];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466354,
                "title": "top-down-dp-optimal-for-interview",
                "content": "Remember, the goal of an interview is to come up with a solution that works quickly and elegantly. It doesn\\'t need to be 100% runtime (this certainly isn\\'t) but it is quick to write and gets the job done.\\n\\n```\\nfrom functools import cache\\nfrom math import gcd\\n\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        \\n        @cache\\n        def dp(i=0, roll_minus_1=0, roll_minus_2=0):\\n            if i == n:\\n                return 1\\n            \\n            res = 0\\n            for k in range(1, 7):\\n                if (\\n                    (not roll_minus_1 or gcd(roll_minus_1, k) == 1)\\n                    and k not in [roll_minus_1, roll_minus_2]\\n                ):\\n                    res = (res + dp(i + 1, k, roll_minus_1)) % mod\\n            \\n            return res % mod\\n            \\n        return dp()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import cache\\nfrom math import gcd\\n\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        \\n        @cache\\n        def dp(i=0, roll_minus_1=0, roll_minus_2=0):\\n            if i == n:\\n                return 1\\n            \\n            res = 0\\n            for k in range(1, 7):\\n                if (\\n                    (not roll_minus_1 or gcd(roll_minus_1, k) == 1)\\n                    and k not in [roll_minus_1, roll_minus_2]\\n                ):\\n                    res = (res + dp(i + 1, k, roll_minus_1)) % mod\\n            \\n            return res % mod\\n            \\n        return dp()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439809,
                "title": "java-dp-16-28-ms-39-1-41-1-mb-faster-than-99-90-less-than-97-83",
                "content": "## Thinking\\n\\n* **Group 6 numbers into 4 groups**\\n\\t* Group A : number cannot be divided by 2 and 3 -> 1 and 5\\n\\t* Group B : number can only be divided by 2 -> 2 and 4\\n\\t* Group C : number can only be divided by 3 -> 3\\n\\t* Group D : number can be divided by 2 and 3 -> 6\\n* **List all possible pathes between two rolls**\\n\\t* path A -> A : 1 -> 5 and 5 -> 1 (1 -> 1 and 5 -> 5 are not allowed)\\n\\t* path A -> B : 1 -> 2, 1 -> 4, 5 -> 2, and 5 -> 4\\n\\t* path A -> C : 1 -> 3 and 5 -> 3\\n\\t* path A -> D : 1 -> 6 and 5 -> 6\\n\\t* path B -> A : 2 -> 1, 2 -> 5, 4 -> 1, and 4 -> 5\\n\\t* path B -> C : 2 -> 3 and 4 -> 3\\n\\t* path C -> A : 3 -> 1 and 3 -> 5\\n\\t* path C -> B : 3 -> 2 and 3 -> 4\\n\\t* path D -> A : 6 -> 1 and 6 -> 5\\n* **Path Calculation**\\n\\t*  **Next Path A -> A = Group A - Currnt Path A -> A**\\n\\t\\t* EX: 1 -> 5 -> 1 is not allowed.\\n\\t\\t\\t* 1 -> 5 is current Path A -> A\\n\\t\\t\\t* 5 -> 1 is next Path A -> A\\n\\t* **Next Path B -> A = Group B - Currnt Path A -> B**\\n\\t\\t* EX: 5 -> 2 -> 5 is not allowed\\n\\t\\t\\t* 5 -> 2 is current Path A -> B\\n\\t\\t\\t* 2 -> 5 is next Path B -> A\\n\\t* **Summary : X -> Y -> X pattern is not allowed**\\n\\t\\t* Always count Group X - Path X -> Y\\n* **Group Combination**\\n\\t* Group A = AA + 2*BA + CA + DA\\n\\t* Group B = 2*AB + CA\\n\\t* Group C = 2*AC + 2*BC\\n\\t* Group D = 2*AD\\n\\nTime Complexity O(n)\\nSpace Complexity O(1)\\n\\n```\\nclass Solution {\\n    public int distinctSequences(int n) {\\n        // curr\\n        long[] currPath = new long[9];\\n        long[] nextPath = new long[9];\\n        long[] group = new long[4];\\n        Arrays.fill(group, 1L);\\n        \\n        for (int i = 1; i < n; i++) {\\n            nextPath[0] = group[0]-currPath[0];\\n            nextPath[1] = group[0]-currPath[4];\\n            nextPath[2] = group[0]-currPath[6];\\n            nextPath[3] = group[0]-currPath[8];\\n            nextPath[4] = group[1]-currPath[1];\\n            nextPath[5] = group[1]-currPath[7];\\n            nextPath[6] = group[2]-currPath[2];\\n            nextPath[7] = group[2]-currPath[5];\\n            nextPath[8] = group[3]-currPath[3];\\n            for (int j = 0; j < 4; j++) while (nextPath[j] < 0) nextPath[j] += 1000000007;\\n            for (int j = 0; j < 4; j++) if (nextPath[j] > 1000000007) nextPath[j] %= 1000000007;\\n            \\n            group[0] = nextPath[0]+2*nextPath[4]+nextPath[6]+nextPath[8];\\n            group[1] = 2*nextPath[1]+nextPath[7];\\n            group[2] = 2*nextPath[2]+2*nextPath[5];\\n            group[3] = 2*nextPath[3];\\n            for (int j = 0; j < 4; j++) while (group[j] < 0) group[j] += 1000000007;\\n            for (int j = 0; j < 4; j++) if (group[j] > 1000000007) group[j] %= 1000000007;\\n            \\n            long[] temp = currPath;\\n            currPath = nextPath;\\n            nextPath = temp;\\n        }\\n        long sum = 0;\\n        sum += 2*group[0]+2*group[1]+group[2]+group[3];\\n        sum %= 1000000007;\\n        return (int)sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctSequences(int n) {\\n        // curr\\n        long[] currPath = new long[9];\\n        long[] nextPath = new long[9];\\n        long[] group = new long[4];\\n        Arrays.fill(group, 1L);\\n        \\n        for (int i = 1; i < n; i++) {\\n            nextPath[0] = group[0]-currPath[0];\\n            nextPath[1] = group[0]-currPath[4];\\n            nextPath[2] = group[0]-currPath[6];\\n            nextPath[3] = group[0]-currPath[8];\\n            nextPath[4] = group[1]-currPath[1];\\n            nextPath[5] = group[1]-currPath[7];\\n            nextPath[6] = group[2]-currPath[2];\\n            nextPath[7] = group[2]-currPath[5];\\n            nextPath[8] = group[3]-currPath[3];\\n            for (int j = 0; j < 4; j++) while (nextPath[j] < 0) nextPath[j] += 1000000007;\\n            for (int j = 0; j < 4; j++) if (nextPath[j] > 1000000007) nextPath[j] %= 1000000007;\\n            \\n            group[0] = nextPath[0]+2*nextPath[4]+nextPath[6]+nextPath[8];\\n            group[1] = 2*nextPath[1]+nextPath[7];\\n            group[2] = 2*nextPath[2]+2*nextPath[5];\\n            group[3] = 2*nextPath[3];\\n            for (int j = 0; j < 4; j++) while (group[j] < 0) group[j] += 1000000007;\\n            for (int j = 0; j < 4; j++) if (group[j] > 1000000007) group[j] %= 1000000007;\\n            \\n            long[] temp = currPath;\\n            currPath = nextPath;\\n            nextPath = temp;\\n        }\\n        long sum = 0;\\n        sum += 2*group[0]+2*group[1]+group[2]+group[3];\\n        sum %= 1000000007;\\n        return (int)sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437977,
                "title": "python-clean-code",
                "content": "```\\nclass Solution:\\n    def distinctSequences(self, n):\\n        if n == 1: return 6\\n        if n == 2: return 22\\n\\n        mod = 10 ** 9 + 7\\n        triples = []\\n        t2ind = {}\\n        # Create valid triples\\n        for i in range(1, 7):\\n            for j in range(1, 7):\\n                if gcd(i, j) != 1 or j == i: continue\\n                for k in range(1, 7):\\n                    if gcd(j, k) != 1 or k == j or k == i: continue\\n\\n                    t2ind[(i, j, k)] = len(triples)\\n                    triples.append((i, j, k))\\n\\n        m = len(triples)\\n        gr = [[] for _ in range(m)]\\n        # Create transition graph\\n        for i, tr in enumerate(triples):\\n            a, b, c = tr\\n            for k in range(1, 7):\\n                if b == k or c == k or gcd(c, k) != 1: continue\\n\\n                to = (b, c, k)\\n                gr[i].append(t2ind[to])\\n\\n        cvals = [1] * m\\n        # Count backwards using transitions\\n        for _ in range(n - 3):\\n            nvals = [0] * m\\n            for i in range(m):\\n                nvals[i] = sum(cvals[j] for j in gr[i]) % mod\\n            cvals = nvals\\n\\n        return sum(cvals) % mod\\n```\\t\\t\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n):\\n        if n == 1: return 6\\n        if n == 2: return 22\\n\\n        mod = 10 ** 9 + 7\\n        triples = []\\n        t2ind = {}\\n        # Create valid triples\\n        for i in range(1, 7):\\n            for j in range(1, 7):\\n                if gcd(i, j) != 1 or j == i: continue\\n                for k in range(1, 7):\\n                    if gcd(j, k) != 1 or k == j or k == i: continue\\n\\n                    t2ind[(i, j, k)] = len(triples)\\n                    triples.append((i, j, k))\\n\\n        m = len(triples)\\n        gr = [[] for _ in range(m)]\\n        # Create transition graph\\n        for i, tr in enumerate(triples):\\n            a, b, c = tr\\n            for k in range(1, 7):\\n                if b == k or c == k or gcd(c, k) != 1: continue\\n\\n                to = (b, c, k)\\n                gr[i].append(t2ind[to])\\n\\n        cvals = [1] * m\\n        # Count backwards using transitions\\n        for _ in range(n - 3):\\n            nvals = [0] * m\\n            for i in range(m):\\n                nvals[i] = sum(cvals[j] for j in gr[i]) % mod\\n            cvals = nvals\\n\\n        return sum(cvals) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410853,
                "title": "python3-dp-simple-to-understand",
                "content": "- We precalculate the possibilities in dct, based on the gcd being 1. (every key can only be followed by each of it\\'s values)\\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        dct={0:[1,2,3,4,5,6],1:[2,3,4,5,6],2:[1,3,5],3:[1,2,4,5],4:[1,3,5],5:[1,2,3,4,6],6:[1,5]}\\n        mod=10**9+7\\n        \\n        @functools.cache\\n        def helper(prev2,prev1,idx):\\n            if idx==n: return 1\\n            total=0\\n            for j in dct[prev1]:\\n                if j!=prev2 or prev1==0:\\n                    total+=helper(prev1,j,idx+1)\\n            return total%mod\\n    \\n        return helper(0,0,0)%mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        dct={0:[1,2,3,4,5,6],1:[2,3,4,5,6],2:[1,3,5],3:[1,2,4,5],4:[1,3,5],5:[1,2,3,4,6],6:[1,5]}\\n        mod=10**9+7\\n        \\n        @functools.cache\\n        def helper(prev2,prev1,idx):\\n            if idx==n: return 1\\n            total=0\\n            for j in dct[prev1]:\\n                if j!=prev2 or prev1==0:\\n                    total+=helper(prev1,j,idx+1)\\n            return total%mod\\n    \\n        return helper(0,0,0)%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398929,
                "title": "c-92-faster-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        int dp[n+1][7][7];\\n        memset(dp, 0, sizeof(dp));\\n        int MOD=1e9+7;\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                for(int k=1;k<=6;k++)\\n                {\\n                    if(i==1)\\n                    {\\n                        dp[i][j][j]=1;\\n                    }\\n                    else if(j==k)\\n                    {\\n                        dp[i][j][k]=0;\\n                    }\\n                    else if(i==2)\\n                    {\\n                        if(__gcd(j,k)==1 && j!=k)\\n                            dp[i][j][k]=1;\\n                    }\\n                    else {\\n                        if(__gcd(j,k)==1 && j!=k)\\n                        {\\n                            for(int d=1;d<=6;d++)\\n                            {\\n                                if(d==j)\\n                                    continue;\\n                                dp[i][j][k]+=dp[i-1][k][d];\\n                                dp[i][j][k]%=MOD;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=6;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                ans+=dp[n][i][j];\\n                ans%=MOD;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        int dp[n+1][7][7];\\n        memset(dp, 0, sizeof(dp));\\n        int MOD=1e9+7;\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                for(int k=1;k<=6;k++)\\n                {\\n                    if(i==1)\\n                    {\\n                        dp[i][j][j]=1;\\n                    }\\n                    else if(j==k)\\n                    {\\n                        dp[i][j][k]=0;\\n                    }\\n                    else if(i==2)\\n                    {\\n                        if(__gcd(j,k)==1 && j!=k)\\n                            dp[i][j][k]=1;\\n                    }\\n                    else {\\n                        if(__gcd(j,k)==1 && j!=k)\\n                        {\\n                            for(int d=1;d<=6;d++)\\n                            {\\n                                if(d==j)\\n                                    continue;\\n                                dp[i][j][k]+=dp[i-1][k][d];\\n                                dp[i][j][k]%=MOD;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=6;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                ans+=dp[n][i][j];\\n                ans%=MOD;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391890,
                "title": "python-simplest-recursive-top-down",
                "content": "```class Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        m = 1000000007\\n        def f(n,l,sl):\\n            if n == 0:\\n                return 1\\n            if dp[n][l][sl] != -1:\\n                return dp[n][l][sl]\\n            ans = 0\\n            for i in range(1,7):\\n                if (i != l and i != sl and (l == 0 or gcd(i,l) == 1)):\\n                    ans = (ans + f(n-1,i,l)%m)%m\\n            dp[n][l][sl] = ans%m\\n            return ans\\n        \\n        dp = [[[-1 for i in range(8)] for _ in range(8)] for _ in range(n+1)]\\n        return f(n,0,0)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        m = 1000000007\\n        def f(n,l,sl):\\n            if n == 0:\\n                return 1\\n            if dp[n][l][sl] != -1:\\n                return dp[n][l][sl]\\n            ans = 0\\n            for i in range(1,7):\\n                if (i != l and i != sl and (l == 0 or gcd(i,l) == 1)):\\n                    ans = (ans + f(n-1,i,l)%m)%m\\n            dp[n][l][sl] = ans%m\\n            return ans\\n        \\n        dp = [[[-1 for i in range(8)] for _ in range(8)] for _ in range(n+1)]\\n        return f(n,0,0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2382563,
                "title": "c-bottom-up-dp",
                "content": "We need to maintain counts for the digits at position `n-1` and position `n-2` if we want to add a new dice roll digit at position `n`.\\n\\nFor condition #1, need to make sure that the greatest common divisor of the two digits (at `n` and at `n-1`) are 1. Since there are only 6 possible digits at each position, this can be done using a map. Note that the two digits cannot be equal, so `{1,1}` should be excluded.\\nFor condition #2, need to make sure that the newly added digits at position `n` and `n-2` are not equal. We don\\'t need to worry about the digit at position `n-3` and before.\\n\\nSo let `dp[n][i][j]` = the number of distinct roll sequences of length `n` such that at position `n` the roll digit is `i` and at position `n-1` the roll digit is `j`. Based on the above analysis, the bottom-up update rule is straight-forward:\\n```\\ndp[n][i][j] = (dp[n-1][j][1] + ... + dp[n-1][j][6]) - dp[n-1][j][i]\\n```\\nNote that here `j` only include those digits that are compatible to `i` according to condition #1 (which are stored in the map). On the R.H.S., basically we start from the counts for sequences of length `n-1`, and we find all the counts with digit = `j` at position `n-1`, then we subtract the counts with digit=`i` at position `n-2` to meet condition #2.\\nSince for each update we need to do the summation again and again, for convenience let\\'s just record the sum in `dp[n][i][0]` (number of sequences with digit=`i` at position `n` and any compatible digit at position `n-1`) and `dp[n][0][0]` (number of sequences with any compatible digits at positions `n` and `n-1`). With this information the update rule can be simplified to:\\n```\\ndp[n][i][j] = dp[n-1][j][0] - dp[n-1][j][i]\\n```\\nAnd we need to return the value `dp[n][0][0]` when program ends. Below are the C++ codes that run in <90ms. Note that since the DP is bottom-up, we don\\'t really need 3D arrays, the `n` axis can be re-used and the array might be reduced to 2D to further reduce space complexity.\\n```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n\\n        map<int, vector<int>> mp;\\n        mp.insert({1, {2, 3, 4, 5, 6}});\\n        mp.insert({2, {1, 3, 5}});\\n        mp.insert({3, {1, 2, 4, 5}});\\n        mp.insert({4, {1, 3, 5}});\\n        mp.insert({5, {1, 2, 3, 4, 6}});\\n        mp.insert({6, {1, 5}});\\n\\n        long long dp[n][7][7];\\n        memset(dp, 0, sizeof(dp));\\n        long long mod = 1e9+7;\\n\\n\\t\\t// initialization for n=1 (one dice roll)\\n        for (int i = 1; i <= 6; ++i) {\\n            dp[0][i][0] = 1;\\n            dp[0][0][0] += dp[0][i][0];\\n        }\\n\\n        for (int k = 1; k < n; ++k) {\\n            for (int i = 1; i <= 6; ++i) {\\n\\t\\t\\t\\t// update rule\\n                for (int j : mp[i]) {\\n                    dp[k][i][j] = (dp[k - 1][j][0] - dp[k - 1][j][i]) % mod;\\n                }\\n\\t\\t\\t\\t// summation for position `n-1`\\n                for (int j : mp[i]) {\\n                    dp[k][i][0] = (dp[k][i][0] + dp[k][i][j]) % mod;\\n                }\\n            }\\n\\t\\t\\t// summation for position `n`\\n            for (int i = 1; i <= 6; ++i) {\\n                dp[k][0][0] = (dp[k][0][0] + dp[k][i][0]) % mod;\\n            }\\n        }\\n\\n\\t\\t// for some reasons the modulo results might be negative (maybe due to the subtraction in the update rule), so\\n\\t\\t// add mod first then do modulo would solve the problem\\n        return (dp[n-1][0][0] + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[n][i][j] = (dp[n-1][j][1] + ... + dp[n-1][j][6]) - dp[n-1][j][i]\\n```\n```\\ndp[n][i][j] = dp[n-1][j][0] - dp[n-1][j][i]\\n```\n```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n\\n        map<int, vector<int>> mp;\\n        mp.insert({1, {2, 3, 4, 5, 6}});\\n        mp.insert({2, {1, 3, 5}});\\n        mp.insert({3, {1, 2, 4, 5}});\\n        mp.insert({4, {1, 3, 5}});\\n        mp.insert({5, {1, 2, 3, 4, 6}});\\n        mp.insert({6, {1, 5}});\\n\\n        long long dp[n][7][7];\\n        memset(dp, 0, sizeof(dp));\\n        long long mod = 1e9+7;\\n\\n\\t\\t// initialization for n=1 (one dice roll)\\n        for (int i = 1; i <= 6; ++i) {\\n            dp[0][i][0] = 1;\\n            dp[0][0][0] += dp[0][i][0];\\n        }\\n\\n        for (int k = 1; k < n; ++k) {\\n            for (int i = 1; i <= 6; ++i) {\\n\\t\\t\\t\\t// update rule\\n                for (int j : mp[i]) {\\n                    dp[k][i][j] = (dp[k - 1][j][0] - dp[k - 1][j][i]) % mod;\\n                }\\n\\t\\t\\t\\t// summation for position `n-1`\\n                for (int j : mp[i]) {\\n                    dp[k][i][0] = (dp[k][i][0] + dp[k][i][j]) % mod;\\n                }\\n            }\\n\\t\\t\\t// summation for position `n`\\n            for (int i = 1; i <= 6; ++i) {\\n                dp[k][0][0] = (dp[k][0][0] + dp[k][i][0]) % mod;\\n            }\\n        }\\n\\n\\t\\t// for some reasons the modulo results might be negative (maybe due to the subtraction in the update rule), so\\n\\t\\t// add mod first then do modulo would solve the problem\\n        return (dp[n-1][0][0] + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379184,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    void add(int& a, int b) {\\n        a += b;\\n        if (a >= mod) {\\n            a -= mod;\\n        }\\n    }\\n    int distinctSequences(int n) {\\n        if (n == 1) return 6;\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>> (7, vector<int> (7)));\\n        for (int i = 1; i <= 6; i++) {\\n            for (int j = 1; j <= 6; j++) {\\n                if (i != j && __gcd(i, j) == 1) {\\n                    dp[2][i][j] = 1;\\n                }\\n            }\\n        }\\n        for (int i = 2; i < n; i++) {\\n            for (int lv = 1; lv <= 6; lv++) {\\n                for (int plv = 1; plv <= 6; plv++) {\\n                    for (int pplv = 1; pplv <= 6; pplv++) {\\n                        if (lv == plv || lv == pplv || __gcd(lv, plv) != 1) continue;\\n                        add(dp[i + 1][lv][plv], dp[i][plv][pplv]);\\n                    }\\n                }\\n            }\\n        }\\n        int sol = 0;\\n        for (int i = 1; i <= 6; i++) {\\n            for (int j = 1; j <= 6; j++) {\\n                add(sol, dp[n][i][j]);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    void add(int& a, int b) {\\n        a += b;\\n        if (a >= mod) {\\n            a -= mod;\\n        }\\n    }\\n    int distinctSequences(int n) {\\n        if (n == 1) return 6;\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>> (7, vector<int> (7)));\\n        for (int i = 1; i <= 6; i++) {\\n            for (int j = 1; j <= 6; j++) {\\n                if (i != j && __gcd(i, j) == 1) {\\n                    dp[2][i][j] = 1;\\n                }\\n            }\\n        }\\n        for (int i = 2; i < n; i++) {\\n            for (int lv = 1; lv <= 6; lv++) {\\n                for (int plv = 1; plv <= 6; plv++) {\\n                    for (int pplv = 1; pplv <= 6; pplv++) {\\n                        if (lv == plv || lv == pplv || __gcd(lv, plv) != 1) continue;\\n                        add(dp[i + 1][lv][plv], dp[i][plv][pplv]);\\n                    }\\n                }\\n            }\\n        }\\n        int sol = 0;\\n        for (int i = 1; i <= 6; i++) {\\n            for (int j = 1; j <= 6; j++) {\\n                add(sol, dp[n][i][j]);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355930,
                "title": "dp-approach-c-idea-behind-approach",
                "content": "\\t// We have to ensure that the last two digits have gcd = 1 & 3rd last digit should be different than the last digit. \\n\\t//This leads to easy dp solution. We just have to use some \"if\" checks.\\n\\tclass Solution {\\n\\tpublic:\\n    bool gcd(int i,int j)\\n    {\\n        for(int k=2;k<=6;k++)\\n        {\\n            if(i%k==0 && j%k==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int distinctSequences(int n) {\\n        if(n==1)\\n            return 6;\\n        vector<vector<vector<long long>>> dp(n+1,vector<vector<long long>>(7,vector<long long>(7,0)));\\n        int mod =1e9 +7;\\n        vector<vector<int>> ls(7,vector<int>());\\n        for(int i=1;i<=6;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(gcd(i,j)==1)\\n                    ls[i].push_back(j);\\n            }\\n        }\\n        int s=0;\\n        for(int i=1;i<=6;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                if(gcd(i,j)&& i!=j)\\n                {\\n                    dp[2][i][j]=1;\\n                    s+=1;\\n                }\\n            }\\n        }\\n        if(n==2)\\n            return s;\\n        for(int i=1;i<=6;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n            {\\n                if(gcd(i,j)!=1 || i==j)\\n                    continue;\\n                for(int k=1;k<=6;k++)\\n                {\\n                    if(k==j || gcd(k,i)!=1||k==i)\\n                        continue;\\n                    dp[3][i][j]+=1;\\n                }\\n            }\\n        }\\n        \\n        for(int k2=4;k2<=n;k2++)\\n        {\\n            for(int i=1;i<=6;i++)\\n            {\\n                for(int j=1;j<=6;j++)\\n                {\\n                    if(i==j ||gcd(i,j)!=1)\\n                        continue;\\n                    for(int k=1;k<=6;k++)\\n                    {\\n                        if(j==k || i==k||gcd(k,i)!=1)\\n                        {\\n                            continue;\\n                        }\\n                        dp[k2][i][j]+=dp[k2-1][k][i];\\n                        dp[k2][i][j]=dp[k2][i][j]%mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long long sum=0;\\n        for(int i=1;i<=6;i++)\\n        {\\n            for(int j=0;j<=6;j++)\\n            {\\n                sum+=dp[n][i][j];\\n                sum=sum%mod;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool gcd(int i,int j)\\n    {\\n        for(int k=2;k<=6;k++)\\n        {\\n            if(i%k==0 && j%k==0)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2349033,
                "title": "easy-recursion-memoization",
                "content": "Well if we look at the problem we just have to keep track of the last and the lasst to last number we got in a row.\\nand offcourse the first condition that gcd of two numbers in a row must be 1;\\n\\nHere is a simple code:-\\n\\n    int dp[10005][7][7];\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int recur(int num,int n,int parent){\\n        if(n<0){\\n            return 0;\\n        }\\n        if(n==0){\\n            return 1;\\n        }\\n        if(dp[n][num][parent]!=-1){  // if we have already encountered this index such that the last number was   num, and last to last number was parent then return that\\n            return dp[n][num][parent]%mod;\\n            \\n        }\\n        int ans=0;  //storing the answer for current index with last number to be num and the last to last be parent\\n        for(int i=1;i<=6;i++){\\n            if(__gcd(i,num)==1 && i!=num && i!=parent){ //putting in the given 2 conditions(gcd, last two numbers)\\n                ans = (ans%mod + recur(i,n-1,num)%mod)%mod;    // adding the possibilities of next vald numbers\\n            }\\n        }\\n        return dp[n][num][parent] = ans%mod;\\n    }\\n    \\n    \\n    \\n    \\n    int distinctSequences(int n) {\\n        int ans=0; // our final answer\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=1;i<=6;i++){  // this loop we are adding up the possibilities of the first number be 1,2,3..6\\n            ans=(ans%mod + recur(i,n-1,0)%mod)%mod; \\n        }\\n        return ans;\\n    }\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "Well if we look at the problem we just have to keep track of the last and the lasst to last number we got in a row.\\nand offcourse the first condition that gcd of two numbers in a row must be 1;\\n\\nHere is a simple code:-\\n\\n    int dp[10005][7][7];\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int recur(int num,int n,int parent){\\n        if(n<0){\\n            return 0;\\n        }\\n        if(n==0){\\n            return 1;\\n        }\\n        if(dp[n][num][parent]!=-1){  // if we have already encountered this index such that the last number was   num, and last to last number was parent then return that\\n            return dp[n][num][parent]%mod;\\n            \\n        }\\n        int ans=0;  //storing the answer for current index with last number to be num and the last to last be parent\\n        for(int i=1;i<=6;i++){\\n            if(__gcd(i,num)==1 && i!=num && i!=parent){ //putting in the given 2 conditions(gcd, last two numbers)\\n                ans = (ans%mod + recur(i,n-1,num)%mod)%mod;    // adding the possibilities of next vald numbers\\n            }\\n        }\\n        return dp[n][num][parent] = ans%mod;\\n    }\\n    \\n    \\n    \\n    \\n    int distinctSequences(int n) {\\n        int ans=0; // our final answer\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=1;i<=6;i++){  // this loop we are adding up the possibilities of the first number be 1,2,3..6\\n            ans=(ans%mod + recur(i,n-1,0)%mod)%mod; \\n        }\\n        return ans;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2340548,
                "title": "bottom-up-dp-clean-code-c",
                "content": "dp[i][x][y] := total number of sequences when value of i th roll is x and value of previous roll is y\\n```\\nint distinctSequences(int n) {\\n        \\n        if(n==1)\\n            return 6;\\n        vector<vector<vector<int>>> dp(n-1,vector<vector<int>>(7,vector<int>(7)));\\n        \\n        for(int i=1;i<7;i++){\\n            for(int j=1;j<7;j++){\\n                if(i!=j && __gcd(i,j)==1)\\n                    dp[0][i][j]=1;\\n            }\\n        }\\n        \\n        int mod=1e9+7;\\n        for(int i=1;i<n-1;i++){\\n            for(int x=1;x<=6;x++){\\n                for(int y=1;y<=6;y++){\\n                    for(int p=1;p<=6;p++){\\n                        if(x!=p && x!=y && __gcd(x,y)==1)\\n                            dp[i][x][y]=(dp[i][x][y]+dp[i-1][y][p])%mod;\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<=6;i++){\\n            for(int j=1;j<=6;j++)\\n                ans=(ans+dp[n-2][i][j])%mod;\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint distinctSequences(int n) {\\n        \\n        if(n==1)\\n            return 6;\\n        vector<vector<vector<int>>> dp(n-1,vector<vector<int>>(7,vector<int>(7)));\\n        \\n        for(int i=1;i<7;i++){\\n            for(int j=1;j<7;j++){\\n                if(i!=j && __gcd(i,j)==1)\\n                    dp[0][i][j]=1;\\n            }\\n        }\\n        \\n        int mod=1e9+7;\\n        for(int i=1;i<n-1;i++){\\n            for(int x=1;x<=6;x++){\\n                for(int y=1;y<=6;y++){\\n                    for(int p=1;p<=6;p++){\\n                        if(x!=p && x!=y && __gcd(x,y)==1)\\n                            dp[i][x][y]=(dp[i][x][y]+dp[i-1][y][p])%mod;\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<=6;i++){\\n            for(int j=1;j<=6;j++)\\n                ans=(ans+dp[n-2][i][j])%mod;\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2300936,
                "title": "c-top-down-dp-o-36-n-space-and-time",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\n    const ll mod = (ll)1e9+7;\\n    int dp[7][7][10001];\\npublic:\\n    int dfs(int first, int start, int len){\\n        if(len==0)\\n            return 1;\\n        if(dp[first][start][len]!=-1)\\n            return dp[first][start][len];\\n        ll res=0;\\n        for(int x=1;x<=6;x++){\\n            if(start==0 or __gcd(x,start)==1 and x!=start and x!=first)\\n                res=(res+dfs(start,x,len-1))%mod;\\n        }\\n        return dp[first][start][len]=res;\\n    }\\n    int distinctSequences(int n) {\\n        if(n==1)\\n            return 6;\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(0,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\n    const ll mod = (ll)1e9+7;\\n    int dp[7][7][10001];\\npublic:\\n    int dfs(int first, int start, int len){\\n        if(len==0)\\n            return 1;\\n        if(dp[first][start][len]!=-1)\\n            return dp[first][start][len];\\n        ll res=0;\\n        for(int x=1;x<=6;x++){\\n            if(start==0 or __gcd(x,start)==1 and x!=start and x!=first)\\n                res=(res+dfs(start,x,len-1))%mod;\\n        }\\n        return dp[first][start][len]=res;\\n    }\\n    int distinctSequences(int n) {\\n        if(n==1)\\n            return 6;\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(0,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296085,
                "title": "python3",
                "content": "class Solution:\\n\\n    def distinctSequences(self, n: int) -> int:\\n        MOD = 10**9+7\\n        \\n        @cache\\n        def calculate(idx,prev,prevprev):\\n            if idx == n:\\n                return 1\\n            res = 0\\n            for curr in range(1,7):\\n                if curr not in [prev,prevprev] and math.gcd(curr,prev)==1:\\n                    res = (res + calculate(idx+1,curr,prev))%MOD\\n            return res%MOD\\n        \\n        res = 0\\n        for curr in range(1,7):\\n            res = (res + calculate(1,curr,0))%MOD\\n        return res%MOD",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def distinctSequences(self, n: int) -> int:\\n        MOD = 10**9+7\\n        \\n        @cache\\n        def calculate(idx,prev,prevprev):\\n            if idx == n:\\n                return 1\\n            res = 0\\n            for curr in range(1,7):\\n                if curr not in [prev,prevprev] and math.gcd(curr,prev)==1:\\n                    res = (res + calculate(idx+1,curr,prev))%MOD\\n            return res%MOD\\n        \\n        res = 0\\n        for curr in range(1,7):\\n            res = (res + calculate(1,curr,0))%MOD\\n        return res%MOD",
                "codeTag": "Java"
            },
            {
                "id": 2268390,
                "title": "easy-java-explanation-recursion-memo",
                "content": "```\\nclass Solution {\\n    long MOD = 1000000000 + 7;\\n    \\n    int[][] gcdValue;\\n    \\n    int gcd(int n1, int n2){\\n     if(gcdValue[n1][n2] != -1) return gcdValue[n1][n2];\\n     if(gcdValue[n2][n1] != -1) return gcdValue[n2][n1];\\n        \\n    int gcd = 1;\\n    for (int i = 1; i <= n1 && i <= n2; ++i) {\\n      // check if i perfectly divides both n1 and n2\\n      if (n1 % i == 0 && n2 % i == 0)\\n        gcd = i;\\n      }\\n        gcdValue[n1][n2] = gcd;\\n        gcdValue[n2][n1] = gcd;\\n        return gcd;\\n    }\\n    \\n    Long[][][] dp;\\n    long helper(int i, int prev, int prevPrev){\\n        if(i == 0){\\n            // System.out.println(\" --> \" + i);\\n            return 1;\\n        }\\n        if(dp[i][prev][prevPrev] != null) return dp[i][prev][prevPrev];\\n        \\n        long cnt = 0;\\n        for(int j = 1; j < 7; j++){\\n            // System.out.println(\" ==> \" + gcd(j, prev) + \" \" + i );\\n            if(j != prev && j != prevPrev && (gcd(j, prev) == 1 || prev == 0)){\\n                cnt += helper(i-1, j, prev);\\n                cnt = cnt%MOD;\\n            }\\n        }\\n        // System.out.println(\" cnt \" + cnt + \" \"  + i);\\n        return dp[i][prev][prevPrev] = cnt%MOD;\\n    }\\n    \\n    public int distinctSequences(int n) {\\n        gcdValue = new int[7][7];\\n        for(int[] i: gcdValue) Arrays.fill(i, -1);\\n        \\n        dp = new Long[n+1][7][7];\\n        \\n        for(int i = 1; i < 7; i++){\\n            for(int j = 1; j < 7; j++){\\n                int a = gcd(i, j);\\n            }\\n        }\\n        \\n        long ans = helper(n, 0, 0);\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long MOD = 1000000000 + 7;\\n    \\n    int[][] gcdValue;\\n    \\n    int gcd(int n1, int n2){\\n     if(gcdValue[n1][n2] != -1) return gcdValue[n1][n2];\\n     if(gcdValue[n2][n1] != -1) return gcdValue[n2][n1];\\n        \\n    int gcd = 1;\\n    for (int i = 1; i <= n1 && i <= n2; ++i) {\\n      // check if i perfectly divides both n1 and n2\\n      if (n1 % i == 0 && n2 % i == 0)\\n        gcd = i;\\n      }\\n        gcdValue[n1][n2] = gcd;\\n        gcdValue[n2][n1] = gcd;\\n        return gcd;\\n    }\\n    \\n    Long[][][] dp;\\n    long helper(int i, int prev, int prevPrev){\\n        if(i == 0){\\n            // System.out.println(\" --> \" + i);\\n            return 1;\\n        }\\n        if(dp[i][prev][prevPrev] != null) return dp[i][prev][prevPrev];\\n        \\n        long cnt = 0;\\n        for(int j = 1; j < 7; j++){\\n            // System.out.println(\" ==> \" + gcd(j, prev) + \" \" + i );\\n            if(j != prev && j != prevPrev && (gcd(j, prev) == 1 || prev == 0)){\\n                cnt += helper(i-1, j, prev);\\n                cnt = cnt%MOD;\\n            }\\n        }\\n        // System.out.println(\" cnt \" + cnt + \" \"  + i);\\n        return dp[i][prev][prevPrev] = cnt%MOD;\\n    }\\n    \\n    public int distinctSequences(int n) {\\n        gcdValue = new int[7][7];\\n        for(int[] i: gcdValue) Arrays.fill(i, -1);\\n        \\n        dp = new Long[n+1][7][7];\\n        \\n        for(int i = 1; i < 7; i++){\\n            for(int j = 1; j < 7; j++){\\n                int a = gcd(i, j);\\n            }\\n        }\\n        \\n        long ans = helper(n, 0, 0);\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257386,
                "title": "3d-dp-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dp[10001][7][7];\\n    int solve(int n, int prev, int prev_of_prev) {\\n        if(n == 0)\\n            return 1;\\n        if(dp[n][prev][prev_of_prev] != -1)\\n            return dp[n][prev][prev_of_prev];\\n        long ways = 0;\\n        for(int i=1; i<=6; i++) {\\n            if(i != prev && i != prev_of_prev && (__gcd(i, prev) == 1 || prev == 0)) {\\n                ways += solve(n-1, i, prev);\\n            }\\n        }\\n        return dp[n][prev][prev_of_prev] = ways % mod;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(n, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dp[10001][7][7];\\n    int solve(int n, int prev, int prev_of_prev) {\\n        if(n == 0)\\n            return 1;\\n        if(dp[n][prev][prev_of_prev] != -1)\\n            return dp[n][prev][prev_of_prev];\\n        long ways = 0;\\n        for(int i=1; i<=6; i++) {\\n            if(i != prev && i != prev_of_prev && (__gcd(i, prev) == 1 || prev == 0)) {\\n                ways += solve(n-1, i, prev);\\n            }\\n        }\\n        return dp[n][prev][prev_of_prev] = ways % mod;\\n    }\\n    int distinctSequences(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(n, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255709,
                "title": "c-easy-dp",
                "content": "```class Solution {\\npublic:\\n    int distinctSequences(int n) \\n    {\\n        if (n == 1)\\n            return 6;\\n        \\n        int dp[n + 1][7][7]; // dp[i][j][k] denotes sequence of length i with last number k, ans last second number j\\n        for (int i = 0; i <= n; i++)\\n            for (int j = 0; j <= 6; j++)\\n                for (int k = 0; k <= 6; k++)\\n                    dp[i][j][k] = 0;\\n        \\n        for (int i = 1; i <= 6; i++)\\n            dp[1][0][i] = 1;\\n        \\n        for (int i = 1; i <= 6; i++)\\n        {\\n            for (int j = 1; j <= 6; j++)\\n            {\\n                if (__gcd(i, j) == 1 && i != j)\\n                    dp[2][i][j] += dp[1][0][i];\\n            }\\n        }\\n        \\n        const int mod = 1e9 + 7;\\n        for (int i = 3; i <= n; i++)\\n        {\\n            for (int j = 1; j <= 6; j++) // last second number\\n            {\\n                for (int k = 1; k <= 6; k++) // last number\\n                {\\n                    for (int curr = 1; curr <= 6; curr++) // current number that can be part of sequence\\n                    {\\n                        if (curr == j || curr == k)\\n                            continue;\\n                        \\n                        if (__gcd(k, curr) == 1)\\n                            dp[i][k][curr] += dp[i - 1][j][k]; // k becomes second last for length i\\n                        \\n                        dp[i][k][curr] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= 6; i++)\\n        {\\n            for (int j = 1; j <= 6; j++)\\n            {\\n                ans += dp[n][i][j]; // for all possible last two numbers for sequence of length n\\n                ans %= mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int distinctSequences(int n) \\n    {\\n        if (n == 1)\\n            return 6;\\n        \\n        int dp[n + 1][7][7]; // dp[i][j][k] denotes sequence of length i with last number k, ans last second number j\\n        for (int i = 0; i <= n; i++)\\n            for (int j = 0; j <= 6; j++)\\n                for (int k = 0; k <= 6; k++)\\n                    dp[i][j][k] = 0;\\n        \\n        for (int i = 1; i <= 6; i++)\\n            dp[1][0][i] = 1;\\n        \\n        for (int i = 1; i <= 6; i++)\\n        {\\n            for (int j = 1; j <= 6; j++)\\n            {\\n                if (__gcd(i, j) == 1 && i != j)\\n                    dp[2][i][j] += dp[1][0][i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2255441,
                "title": "rust-recursion",
                "content": "```rust\\nconst MODULO: i32 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn distinct_sequences(n: i32) -> i32 {\\n        let n = n as usize;\\n        let mut dp = vec![vec![vec![0; 7]; 7]; n + 1];\\n\\n        fn greatest_common_divisor(a: usize, b: usize) -> usize {\\n            if b != 0 {\\n                greatest_common_divisor(b, a % b)\\n            } else {\\n                a\\n            }\\n        }\\n\\n        fn distinct_sequences_recursion(\\n            n: usize,\\n            prev: usize,\\n            prev_prev: usize,\\n            dp: &mut Vec<Vec<Vec<i32>>>,\\n        ) -> i32 {\\n            if n == 0 {\\n                return 1;\\n            }\\n\\n            if dp[n][prev][prev_prev] == 0 {\\n                for dice in 1..=6 {\\n                    if dice != prev\\n                        && dice != prev_prev\\n                        && (prev == 0 || greatest_common_divisor(dice, prev) == 1)\\n                    {\\n                        dp[n][prev][prev_prev] +=\\n                            distinct_sequences_recursion(n - 1, dice, prev, dp);\\n                        dp[n][prev][prev_prev] %= MODULO;\\n                    }\\n                }\\n            }\\n\\n            dp[n][prev][prev_prev]\\n        }\\n\\n        distinct_sequences_recursion(n, 0, 0, &mut dp)\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nconst MODULO: i32 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn distinct_sequences(n: i32) -> i32 {\\n        let n = n as usize;\\n        let mut dp = vec![vec![vec![0; 7]; 7]; n + 1];\\n\\n        fn greatest_common_divisor(a: usize, b: usize) -> usize {\\n            if b != 0 {\\n                greatest_common_divisor(b, a % b)\\n            } else {\\n                a\\n            }\\n        }\\n\\n        fn distinct_sequences_recursion(\\n            n: usize,\\n            prev: usize,\\n            prev_prev: usize,\\n            dp: &mut Vec<Vec<Vec<i32>>>,\\n        ) -> i32 {\\n            if n == 0 {\\n                return 1;\\n            }\\n\\n            if dp[n][prev][prev_prev] == 0 {\\n                for dice in 1..=6 {\\n                    if dice != prev\\n                        && dice != prev_prev\\n                        && (prev == 0 || greatest_common_divisor(dice, prev) == 1)\\n                    {\\n                        dp[n][prev][prev_prev] +=\\n                            distinct_sequences_recursion(n - 1, dice, prev, dp);\\n                        dp[n][prev][prev_prev] %= MODULO;\\n                    }\\n                }\\n            }\\n\\n            dp[n][prev][prev_prev]\\n        }\\n\\n        distinct_sequences_recursion(n, 0, 0, &mut dp)\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2254959,
                "title": "c-constant-space-and-linear-time-tc-o-n-and-sc-o-1-using-two-2d-vectors-all-approaches-covered",
                "content": "Your may avoid the commented parts\\n```\\nclass Solution {\\npublic:\\n\\t//Function to checkGCD condition\\n    bool checkGCD(int a,int b)\\n    {\\n        if(a==1 or b==1)\\n            return true;\\n        if((a==4 and b==6) or(a==6 and b==4))\\n            return false;\\n        if(a%b==0 or b%a==0)\\n            return false;\\n        return true;\\n    }\\n\\t//The recursive solution \\n//     int solve(int ind,int prev,int prev2,int n,vector<vector<vector<int>>>&dp)\\n//     {\\n//         if(ind==n)\\n//         {\\n//             return 1; \\n            \\n//         }\\n//         if(dp[ind][prev][prev2]!=-1) return dp[ind][prev][prev2];\\n//         long long int count=0;\\n//         for(int i=1;i<=6;i++)\\n//         {\\n//             if((prev==0 or checkGCD(prev,i)) and (i!=prev and i!=prev2))//checking all conditions\\n//             {\\n//                 prev becomes i ,prev2  becomes what was prev\\n//                 count+=solve(ind+1,i,prev,n,dp);\\n//             }\\n//         }\\n//         return dp[ind][prev][prev2]=count%(1000000007);\\n//     }\\n\\n    int distinctSequences(int n) {\\n\\t\\t//Below dp is for memoization , initialised to -1\\n\\t\\t//vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(7,vector<int>(7,-1))); \\n\\t\\t\\n\\t\\t//Below dp is for tabulation\\n        // vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(7,vector<int>(7,0)));     \\n\\t\\t\\n\\t\\t//The two vectors of 7x7 .Next points to the row below the current(curr) row of the dp table\\n\\t\\t//next is firstly dp[n][][]\\n        vector<vector<int>>next(vector<vector<int>>(7,vector<int>(7,0))),curr(vector<vector<int>>(7,vector<int>(7,0)));\\n        \\n\\t\\t//Bases case from recurrsion \\n        for(int prev=0;prev<=6;prev++)\\n        {\\n            for(int prev2=0;prev2<=6;prev2++)\\n            {\\n                next[prev][prev2]=1;\\n            }\\n        }\\n        \\n\\t\\t//Traversing in reverse order of the recursion\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int prev=6;prev>=0;prev--)\\n            {\\n                for(int prev2=6;prev2>=0;prev2--)\\n                {\\n\\t\\t\\t\\t\\t//long long to avoid integer overflow\\n                    long long int count=0;\\n                    for(int i=1;i<=6;i++)\\n                    {\\n\\t\\t\\t\\t\\t\\t//checking both the given conditions\\n                        if((prev==0 or checkGCD(prev,i)) and (i!=prev and i!=prev2))//GCB should be 1\\n                        {\\n\\t\\t\\t\\t\\t\\t\\t// prev becomes i ,prev2  becomes what was prev\\n                            count+=next[i][prev];\\n                        }\\n                    }\\n                    curr[prev][prev2]=count%(1000000007);\\n                }\\n            }\\n            next=curr;\\n        }\\n        return next[0][0]; \\n\\t\\t//Below call is for the recursive solution (dp should be all -1 )\\n        // return solve(0,0,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//Function to checkGCD condition\\n    bool checkGCD(int a,int b)\\n    {\\n        if(a==1 or b==1)\\n            return true;\\n        if((a==4 and b==6) or(a==6 and b==4))\\n            return false;\\n        if(a%b==0 or b%a==0)\\n            return false;\\n        return true;\\n    }\\n\\t//The recursive solution \\n//     int solve(int ind,int prev,int prev2,int n,vector<vector<vector<int>>>&dp)\\n//     {\\n//         if(ind==n)\\n//         {\\n//             return 1; \\n            \\n//         }\\n//         if(dp[ind][prev][prev2]!=-1) return dp[ind][prev][prev2];\\n//         long long int count=0;\\n//         for(int i=1;i<=6;i++)\\n//         {\\n//             if((prev==0 or checkGCD(prev,i)) and (i!=prev and i!=prev2))//checking all conditions\\n//             {\\n//                 prev becomes i ,prev2  becomes what was prev\\n//                 count+=solve(ind+1,i,prev,n,dp);\\n//             }\\n//         }\\n//         return dp[ind][prev][prev2]=count%(1000000007);\\n//     }\\n\\n    int distinctSequences(int n) {\\n\\t\\t//Below dp is for memoization , initialised to -1\\n\\t\\t//vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(7,vector<int>(7,-1))); \\n\\t\\t\\n\\t\\t//Below dp is for tabulation\\n        // vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(7,vector<int>(7,0)));     \\n\\t\\t\\n\\t\\t//The two vectors of 7x7 .Next points to the row below the current(curr) row of the dp table\\n\\t\\t//next is firstly dp[n][][]\\n        vector<vector<int>>next(vector<vector<int>>(7,vector<int>(7,0))),curr(vector<vector<int>>(7,vector<int>(7,0)));\\n        \\n\\t\\t//Bases case from recurrsion \\n        for(int prev=0;prev<=6;prev++)\\n        {\\n            for(int prev2=0;prev2<=6;prev2++)\\n            {\\n                next[prev][prev2]=1;\\n            }\\n        }\\n        \\n\\t\\t//Traversing in reverse order of the recursion\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int prev=6;prev>=0;prev--)\\n            {\\n                for(int prev2=6;prev2>=0;prev2--)\\n                {\\n\\t\\t\\t\\t\\t//long long to avoid integer overflow\\n                    long long int count=0;\\n                    for(int i=1;i<=6;i++)\\n                    {\\n\\t\\t\\t\\t\\t\\t//checking both the given conditions\\n                        if((prev==0 or checkGCD(prev,i)) and (i!=prev and i!=prev2))//GCB should be 1\\n                        {\\n\\t\\t\\t\\t\\t\\t\\t// prev becomes i ,prev2  becomes what was prev\\n                            count+=next[i][prev];\\n                        }\\n                    }\\n                    curr[prev][prev2]=count%(1000000007);\\n                }\\n            }\\n            next=curr;\\n        }\\n        return next[0][0]; \\n\\t\\t//Below call is for the recursive solution (dp should be all -1 )\\n        // return solve(0,0,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254313,
                "title": "golang-dp-with-explained",
                "content": "Construct a 2d array (dp) representing the number of distinct sequence after 2 rolls.\\nInitialize the array with value 1 at dp[i][j] if the 2 rolls are valid, 0 otherwise.\\ne.g.\\nfirst roll: 1, second roll: 2, gcm(1, 2) = 1 and 1 != 2 -> dp[1][2] = 1,\\nfirst roll: 3, second roll: 6, gcm(3, 6) = 3 -> dp[3][6] = 0\\n\\nFor each roll, update the array according to the following,\\n\\nwe know that for any 2 consecutive rolls with values a and b, if dp[a][b] > 0 then it is a valid sequence. \\nLet\\'s assume we have 2 consecutive rolls with values j and k. Consider a third roll which is before the 2 rolls with value i, the number of sequence of i -> j should be equal to all valid sequence starting from j in the array, which means the sum of dp[j] - dp[j][i] (the first and third roll cannot be same).\\nSo each element in the array dp[i][j] will have the new value sum(dp[j]) - dp[j][k] if the i -> j is valid, we can validate by checking if dp[i][j] is 0 or not mentioned above.\\n\\nAt the end, we can calculate the total number of valid sequence by sum up all the elements in the array\\n\\n```go\\nfunc distinctSequences(n int) int {\\n    if n == 1 {\\n        return 6\\n    }\\n    dp := make([][]int, 7)\\n    for i := 1; i < 7; i++ {\\n        dp[i] = make([]int, 7)\\n        for j := 1; j < 7; j++ {\\n            if i != j && i % 2 + j % 2 > 0 && i % 3 + j % 3 > 0 {\\n                dp[i][j] = 1\\n            }\\n        }\\n    }\\n    for i := 2; i < n; i++ {\\n        dp = next(dp)\\n    }\\n    sum := 0\\n    for _, last := range dp {\\n        for _, c := range last {\\n            sum = (sum + c) % 1000000007\\n        }\\n    }\\n    return sum\\n}\\n\\nfunc next(dp [][]int) [][]int {\\n    nextDp := make([][]int, 7)\\n    for i := 1; i < 7; i++ {\\n        nextDp[i] = make([]int, 7)\\n        for j := range dp[i] {\\n            if dp[i][j] == 0 {\\n                continue\\n            }\\n            sum := 0\\n            for k, c := range dp[j] {\\n                if k != i {\\n                    sum = (sum + c) % 1000000007\\n                }\\n            }\\n            nextDp[i][j] = sum\\n        }\\n    }\\n    return nextDp\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc distinctSequences(n int) int {\\n    if n == 1 {\\n        return 6\\n    }\\n    dp := make([][]int, 7)\\n    for i := 1; i < 7; i++ {\\n        dp[i] = make([]int, 7)\\n        for j := 1; j < 7; j++ {\\n            if i != j && i % 2 + j % 2 > 0 && i % 3 + j % 3 > 0 {\\n                dp[i][j] = 1\\n            }\\n        }\\n    }\\n    for i := 2; i < n; i++ {\\n        dp = next(dp)\\n    }\\n    sum := 0\\n    for _, last := range dp {\\n        for _, c := range last {\\n            sum = (sum + c) % 1000000007\\n        }\\n    }\\n    return sum\\n}\\n\\nfunc next(dp [][]int) [][]int {\\n    nextDp := make([][]int, 7)\\n    for i := 1; i < 7; i++ {\\n        nextDp[i] = make([]int, 7)\\n        for j := range dp[i] {\\n            if dp[i][j] == 0 {\\n                continue\\n            }\\n            sum := 0\\n            for k, c := range dp[j] {\\n                if k != i {\\n                    sum = (sum + c) % 1000000007\\n                }\\n            }\\n            nextDp[i][j] = sum\\n        }\\n    }\\n    return nextDp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2253269,
                "title": "simple-python-solution",
                "content": "```\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        dp={}\\n        def dfs(n, i, firstprev, secondprev): \\n            if i==0: \\n                return 1 \\n            \\n            key= (i, firstprev, secondprev)\\n            if key in dp:\\n                return dp[key]\\n            ans=0 \\n            for j in range(1, 7): \\n                if i==n: \\n                    ans+= dfs(n, i-1, j, secondprev)  \\n                else:\\n                    if firstprev==0 or math.gcd(j, firstprev)==1:  \\n                        if (j!=firstprev and j!= secondprev) :\\n                            ans= (ans+ dfs(n, i-1, j, firstprev) )%(10**9 + 7)\\n\\n                         \\n            dp[key]= ans%(10**9 +7 )  \\n            return dp[key]          \\n                    \\n               \\n        res= dfs(n, n, 0, 0) \\n        return res%(10**9+ 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        dp={}\\n        def dfs(n, i, firstprev, secondprev): \\n            if i==0: \\n                return 1 \\n            \\n            key= (i, firstprev, secondprev)\\n            if key in dp:\\n                return dp[key]\\n            ans=0 \\n            for j in range(1, 7): \\n                if i==n: \\n                    ans+= dfs(n, i-1, j, secondprev)  \\n                else:\\n                    if firstprev==0 or math.gcd(j, firstprev)==1:  \\n                        if (j!=firstprev and j!= secondprev) :\\n                            ans= (ans+ dfs(n, i-1, j, firstprev) )%(10**9 + 7)\\n\\n                         \\n            dp[key]= ans%(10**9 +7 )  \\n            return dp[key]          \\n                    \\n               \\n        res= dfs(n, n, 0, 0) \\n        return res%(10**9+ 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244398,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    public int distinctSequences(int n) {\\n        \\n     \\n    Long dp[][][] = new Long[n+1][7][7];\\n        \\n    return   (int)( helper(1, 0, 0,  n ,dp)%mod); \\n        \\n    }\\n    static long helper(int i ,int last , int secondlast , int n , Long dp[][][]){\\n       if(i>n){\\n           return 1;\\n       }\\n        if(dp[i][last][secondlast]!=null)return dp[i][last][secondlast];\\n        long ans=0;\\n        for(int j=1;j<=6;j++){\\n             \\n            if(j==last || j== secondlast || last!=0 && gcd(last ,j)!=1 ){\\n                continue;}\\n            ans=(ans%mod+helper(i+1, j, last , n,dp)%mod)%mod;\\n            \\n        }\\n        return dp[i][last][secondlast]=ans;\\n    }\\n    \\n    \\n    static int gcd(int a, int b) {\\n\\t\\tif (a == 0)\\n\\t\\t\\treturn b;\\n\\t\\telse\\n\\t\\t\\treturn gcd(b % a, a);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    public int distinctSequences(int n) {\\n        \\n     \\n    Long dp[][][] = new Long[n+1][7][7];\\n        \\n    return   (int)( helper(1, 0, 0,  n ,dp)%mod); \\n        \\n    }\\n    static long helper(int i ,int last , int secondlast , int n , Long dp[][][]){\\n       if(i>n){\\n           return 1;\\n       }\\n        if(dp[i][last][secondlast]!=null)return dp[i][last][secondlast];\\n        long ans=0;\\n        for(int j=1;j<=6;j++){\\n             \\n            if(j==last || j== secondlast || last!=0 && gcd(last ,j)!=1 ){\\n                continue;}\\n            ans=(ans%mod+helper(i+1, j, last , n,dp)%mod)%mod;\\n            \\n        }\\n        return dp[i][last][secondlast]=ans;\\n    }\\n    \\n    \\n    static int gcd(int a, int b) {\\n\\t\\tif (a == 0)\\n\\t\\t\\treturn b;\\n\\t\\telse\\n\\t\\t\\treturn gcd(b % a, a);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243584,
                "title": "tabulation-highly-intutive-c",
                "content": "In the final sequence A for every ```A[i]``` we will check that is possible to based on known values of ```A[i-1]``` and ```A[i-2]``` thus at every instance we need to know the value of previous two palces thus base initialisation of matrix will be for ```n = 2 ``` so returing ```6``` directly for ```n = 1``` as we are focusing only ```n >= 2``` in this. \\nFor given n we are first finding ```n = 2, 3, 4, ..., i-2, i-1, i, ...., n```. If a ```A[i]``` can be added in sequence then we will add the count of possible sequences we can create with ```A[i-1]``` and ```A[i]``` for the places coming after ```i``` upto ```n``` as we would have solved it for the ```n-1``` case.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        vector <vector<vector<int>>> dp(2, vector<vector<int>>(7, vector<int>(7, 0)));\\n        long long ans = 0;\\n        for(int i = 1; i < 7; i++)\\n        {\\n            for(int j = 1; j < 7; j++)\\n            {\\n                if(i != j && __gcd(i, j) == 1)\\n                    dp[0][i][j] = 1;\\n            }\\n        }\\n        for(int i = 2; i < n; i++)\\n        {\\n            for(int b = 1; b < 7; b++)\\n            {\\n                for(int a = 1; a < 7; a++)\\n                {\\n                    dp[1][a][b] = 0;\\n                    ans = 0;\\n                    if(a == b || __gcd(a, b)!=1) continue;\\n                    for(int j = 1; j < 7; j++)\\n                    {\\n                        if(j == a || j == b || (__gcd(j, a) != 1)) continue;\\n                        ans += dp[0][j][a];\\n                        ans %= ((long long)1e9+7);\\n                    }\\n                    dp[1][a][b] = ans;\\n                }\\n            }\\n            dp[0] = dp[1];\\n        }\\n        ans = 0;\\n        for(auto j : dp[0])\\n        {\\n            for(auto k : j)\\n            {\\n                ans += k;\\n                ans %= ((long long)1e9+7);\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```A[i]```\n```A[i-1]```\n```A[i-2]```\n```n = 2 ```\n```6```\n```n = 1```\n```n >= 2```\n```n = 2, 3, 4, ..., i-2, i-1, i, ...., n```\n```A[i]```\n```A[i-1]```\n```A[i]```\n```i```\n```n```\n```n-1```\n```cpp\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if(n == 1) return 6;\\n        vector <vector<vector<int>>> dp(2, vector<vector<int>>(7, vector<int>(7, 0)));\\n        long long ans = 0;\\n        for(int i = 1; i < 7; i++)\\n        {\\n            for(int j = 1; j < 7; j++)\\n            {\\n                if(i != j && __gcd(i, j) == 1)\\n                    dp[0][i][j] = 1;\\n            }\\n        }\\n        for(int i = 2; i < n; i++)\\n        {\\n            for(int b = 1; b < 7; b++)\\n            {\\n                for(int a = 1; a < 7; a++)\\n                {\\n                    dp[1][a][b] = 0;\\n                    ans = 0;\\n                    if(a == b || __gcd(a, b)!=1) continue;\\n                    for(int j = 1; j < 7; j++)\\n                    {\\n                        if(j == a || j == b || (__gcd(j, a) != 1)) continue;\\n                        ans += dp[0][j][a];\\n                        ans %= ((long long)1e9+7);\\n                    }\\n                    dp[1][a][b] = ans;\\n                }\\n            }\\n            dp[0] = dp[1];\\n        }\\n        ans = 0;\\n        for(auto j : dp[0])\\n        {\\n            for(auto k : j)\\n            {\\n                ans += k;\\n                ans %= ((long long)1e9+7);\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233731,
                "title": "c-dp-keep-tracking-of-the-last-two-dices-in-the-previous-sequence-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        const int mod = 1e9 + 7; \\n        vector<unordered_set<int>> included; // if the previous last dice is i, what the next dice can be \\n        included.push_back ({1,2,3,4,5});  // 1 - 2,3,4,5,6;\\n        included.push_back ({0, 2, 4});  // 2 - 1,3,5;\\n        included.push_back ({0, 1, 3, 4});  // 3 - 1, 2, 4, 5\\n        included.push_back ({0, 2, 4}); // 4 - 1, 3, 5\\n        included.push_back ({0, 1, 2, 3, 5}); // 5 - 1, 2, 3, 4, 6;\\n        included.push_back ({0, 4}); // 6 - 1, 5; \\n\\t\\t// initialize the DP when n == 2; \\n        for (int i = 0; i < 6; i++){\\n            for (auto & j : included[i]){\\n                dp[i][j] = 1; \\n            }\\n        }\\n        if (n == 1) return 6; \\n        for (int k = 3; k <= n; k++){\\n            vector<vector<int>> newdp(6, vector<int> (6, 0));  \\n            for (int i = 0; i < 6; i++){\\n                 for (int j = 0; j < 6; j++){\\n                    if (dp[i][j] != 0){\\n                        for (int kk = 0; kk < 6; kk++){\\n                            if (kk!=i && kk!=j && included[j].count (kk)){ // the new indice cant be the same as the last two digits and have to satisfy gcd (j, kk) == 1 (kk is the next dice)\\n                                newdp[j][kk]+= dp[i][j];\\n                                newdp[j][kk] %= mod;\\n                            }\\n                        }\\n    \\n                    }\\n                     \\n             }\\n         }\\n            dp = newdp; \\n        }\\n        // sum over dp \\n        int ans = 0; \\n        for (int i = 0; i < 6; i++){\\n            for (int j = 0; j < 6; j++){\\n                ans =(ans + dp[i][j] % mod) %mod; \\n            }\\n        }\\n        return ans% mod; \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        const int mod = 1e9 + 7; \\n        vector<unordered_set<int>> included; // if the previous last dice is i, what the next dice can be \\n        included.push_back ({1,2,3,4,5}",
                "codeTag": "Java"
            },
            {
                "id": 2226824,
                "title": "c-bottom-up-dp-without-gcd",
                "content": "Let\\'s take `n=3` for example.\\nIf this is the 3rd roll and we rolled 1.\\nThe amount of valid sequences should be the sum of sequences of 2nd roll ended with 2~6.\\nHowever, there will be some invalid cases such as 121, 131 ... 161 need to be subtracted.\\nIn short, Let `dp[i][j]` denote the amount of valid sequences for `i`th roll if we rolled `j`.\\n`dp[i][1] = sum(dp[i-1][2~6]) - dp[i-2][1]*5(# of available next rolls for 1)`\\nThe above formula starts to go wrong after `n>=4`.\\nThe reason is that we subtacted `dp[i-2][1] * 5` from the result.\\nWhat it means is that for every `i-2`th roll ended with 1, it can be concatenated with (2~6) and 1. For example, 31 + 51.\\nHence, we will subtract some invalid cases such as 21 + 21 or 51 + 51.\\nLet\\'s say if the format we want to substract is `x1y1`. How do we find how many are there?\\nIf x=2, `21y1`, the available options for y are 3,4,5,6.\\nIf x=3, `31y1`, the available options for y are 2,4,5,6.\\n...\\nIf x=6, `61y1`, the available options for y are 2,3,4,5.\\nYou can see that no matter what `x` is, the avialable options for `y` are always 4(5 - itself).\\nWe can now modify the formula to be\\n`dp[i][1] = sum(dp[i-1][2~6]) - dp[i-2][1]*(5-1)(# of available next rolls for 1)`\\nThe reason why `n=3` is not affected is that `dp[i-2][1]` does not have a leading `x` to constrain `y`, the format is just `1y1` so you can just subtract all of them.\\nSorry for the weird convertions, I need them to prevent the type being changed after operations between `size_t` and `int64_t`.\\n```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        std::vector<int64_t> prev_1(7, 0);\\n        std::vector<int64_t> prev_2(7, 0);\\n\\n        for (int i = 0; i < n; ++i) {\\n            std::vector<int64_t> current(7, 0);\\n    \\n            for (int j = 1; j <= 6; ++j) {\\n                if (i == 0) {\\n                    current[j] = 1;\\n                } else {\\n                    for (int k : kOptions[j]) {\\n                        current[j] = (current[j]+prev_1[k]) % kMod;\\n                    }\\n                    if (i > 2) {\\n                        current[j] = (\\n                            current[j]-\\n                            (prev_2[j]*static_cast<int64_t>(kOptions[j].size()-1))% kMod\\n                        ) % kMod;\\n                        if (current[j] < 0) {\\n                            current[j] = current[j] + kMod;\\n                        }\\n                    } else if (i == 2) {\\n                         current[j] = (\\n                             current[j]-\\n                             (prev_2[j]*static_cast<int64_t>(kOptions[j].size()))% kMod\\n                         ) % kMod;\\n                    }\\n                }\\n            }\\n            prev_2 = std::move(prev_1);\\n            prev_1 = std::move(current);\\n        }\\n\\n        int64_t count = 0;\\n        for (int i = 1; i <= 6; ++i) {\\n            count = (count + prev_1[i]) % kMod;\\n        }\\n        \\n        return count;\\n    }\\n\\nprivate:\\n    int64_t kMod = std::pow(10, 9) + 7;\\n    const std::vector<std::vector<int>> kOptions = {\\n        {},\\n        {2,3,4,5,6},\\n        {1,3,5},\\n        {1,2,4,5},\\n        {1,3,5},\\n        {1,2,3,4,6},\\n        {1,5}\\n    };\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        std::vector<int64_t> prev_1(7, 0);\\n        std::vector<int64_t> prev_2(7, 0);\\n\\n        for (int i = 0; i < n; ++i) {\\n            std::vector<int64_t> current(7, 0);\\n    \\n            for (int j = 1; j <= 6; ++j) {\\n                if (i == 0) {\\n                    current[j] = 1;\\n                } else {\\n                    for (int k : kOptions[j]) {\\n                        current[j] = (current[j]+prev_1[k]) % kMod;\\n                    }\\n                    if (i > 2) {\\n                        current[j] = (\\n                            current[j]-\\n                            (prev_2[j]*static_cast<int64_t>(kOptions[j].size()-1))% kMod\\n                        ) % kMod;\\n                        if (current[j] < 0) {\\n                            current[j] = current[j] + kMod;\\n                        }\\n                    } else if (i == 2) {\\n                         current[j] = (\\n                             current[j]-\\n                             (prev_2[j]*static_cast<int64_t>(kOptions[j].size()))% kMod\\n                         ) % kMod;\\n                    }\\n                }\\n            }\\n            prev_2 = std::move(prev_1);\\n            prev_1 = std::move(current);\\n        }\\n\\n        int64_t count = 0;\\n        for (int i = 1; i <= 6; ++i) {\\n            count = (count + prev_1[i]) % kMod;\\n        }\\n        \\n        return count;\\n    }\\n\\nprivate:\\n    int64_t kMod = std::pow(10, 9) + 7;\\n    const std::vector<std::vector<int>> kOptions = {\\n        {},\\n        {2,3,4,5,6},\\n        {1,3,5},\\n        {1,2,4,5},\\n        {1,3,5},\\n        {1,2,3,4,6},\\n        {1,5}\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225261,
                "title": "python-top-down-dp-o-36-n-simple-solution",
                "content": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        mod=10**9+7\\n        def gcd(a,b):\\n            if b==0:\\n                return a\\n            return gcd(b,a%b)\\n        GCD={}\\n        for i in range(1,7):\\n            for j in range(1,7):\\n                GCD[(i,j)]=gcd(i,j)\\n        @lru_cache(None)\\n        def dp(idx,last_roll,last_last_roll):\\n            if idx==n: return 1\\n            ans=0\\n            for roll in range(1,7):\\n                if roll in (last_last_roll,last_roll):\\n                    continue\\n                if GCD[(roll,abs(last_roll))]==1:\\n                    ans+=dp(idx+1,roll,last_roll)\\n            return ans%mod\\n        return dp(0,-1,-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        mod=10**9+7\\n        def gcd(a,b):\\n            if b==0:\\n                return a\\n            return gcd(b,a%b)\\n        GCD={}\\n        for i in range(1,7):\\n            for j in range(1,7):\\n                GCD[(i,j)]=gcd(i,j)\\n        @lru_cache(None)\\n        def dp(idx,last_roll,last_last_roll):\\n            if idx==n: return 1\\n            ans=0\\n            for roll in range(1,7):\\n                if roll in (last_last_roll,last_roll):\\n                    continue\\n                if GCD[(roll,abs(last_roll))]==1:\\n                    ans+=dp(idx+1,roll,last_roll)\\n            return ans%mod\\n        return dp(0,-1,-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224332,
                "title": "java-top-down-dp-with-gcd-function",
                "content": "My Solution is pretty much the same as other 3D DP solutions but also added the Custom GCD Function incase needed.\\nWe will keep Track of the Last & prevLast Numbers for every Current Number & similarly Verify if the GCD for Current & last is <= 1\\n```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    long[][][] dp;\\n    public int distinctSequences(int n) {\\n        dp = new long[n + 1][7][7];\\n        if(n == 1) return 6;\\n        if(n == 2) return 22;\\n        for(long[][] mat: dp)\\n            for(long[] arr: mat)\\n                Arrays.fill(arr, -1);\\n        \\n        return (int)helper(n, 0, 0, 0);\\n    }\\n    \\n    private long helper(int n, int last, int prevLast, int idx)\\n    {\\n        if(idx == n) \\n            return 1;\\n        if(dp[idx][last][prevLast] != -1) \\n            return dp[idx][last][prevLast];\\n        long ans = 0;\\n        for(int i = 1; i <= 6; i++)\\n        {\\n            if(i == last || i == prevLast || last != 0 && gcd(i, last) != 1) continue;\\n            ans = (ans + helper(n, i, last, idx + 1)) % mod;\\n        }\\n        dp[idx][last][prevLast] = ans;\\n        return ans;\\n    }\\n    \\n    private int gcd(int low, int high)\\n    {\\n        for(int i = 2; i <= Math.min(low, high); i++)\\n            if(low % i == 0 && high % i == 0)\\n                return i;\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    long[][][] dp;\\n    public int distinctSequences(int n) {\\n        dp = new long[n + 1][7][7];\\n        if(n == 1) return 6;\\n        if(n == 2) return 22;\\n        for(long[][] mat: dp)\\n            for(long[] arr: mat)\\n                Arrays.fill(arr, -1);\\n        \\n        return (int)helper(n, 0, 0, 0);\\n    }\\n    \\n    private long helper(int n, int last, int prevLast, int idx)\\n    {\\n        if(idx == n) \\n            return 1;\\n        if(dp[idx][last][prevLast] != -1) \\n            return dp[idx][last][prevLast];\\n        long ans = 0;\\n        for(int i = 1; i <= 6; i++)\\n        {\\n            if(i == last || i == prevLast || last != 0 && gcd(i, last) != 1) continue;\\n            ans = (ans + helper(n, i, last, idx + 1)) % mod;\\n        }\\n        dp[idx][last][prevLast] = ans;\\n        return ans;\\n    }\\n    \\n    private int gcd(int low, int high)\\n    {\\n        for(int i = 2; i <= Math.min(low, high); i++)\\n            if(low % i == 0 && high % i == 0)\\n                return i;\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215664,
                "title": "python-dp-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        MOD = int(1e9+7)\\n        invalid = set([(2,4),(4,6),(2,6),(2,3),(4,2),(6,4),(6,2),(3,2)])\\n        dp = {(-1,-1): 1}\\n        for _ in range(1, n+1):\\n            new_dp = Counter()\\n            for x0, x1 in dp:\\n                for x2 in range(1, 7):\\n                    if x0 != x2 and x1 != x2 and (x1,x2) not in invalid:\\n                        new_dp[(x1, x2)] += dp[(x0, x1)] % MOD\\n            dp = new_dp\\n        return sum(dp.values()) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        MOD = int(1e9+7)\\n        invalid = set([(2,4),(4,6),(2,6),(2,3),(4,2),(6,4),(6,2),(3,2)])\\n        dp = {(-1,-1): 1}\\n        for _ in range(1, n+1):\\n            new_dp = Counter()\\n            for x0, x1 in dp:\\n                for x2 in range(1, 7):\\n                    if x0 != x2 and x1 != x2 and (x1,x2) not in invalid:\\n                        new_dp[(x1, x2)] += dp[(x0, x1)] % MOD\\n            dp = new_dp\\n        return sum(dp.values()) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214214,
                "title": "c-easy-understanding-counting-dp-memoization",
                "content": "\\'\\'\\'\\n```\\nlong long count;long long mod=1e9+7;\\n    long long int dp[8][7][10001]={};\\n    long long f(int prev2,int prev1,int idx,int n){\\n\\t//if idx reaches n+1 we have successfully created a combination of n dices so add 1 to total count\\n        if(idx>n){\\n            return 1;\\n        }\\n        if(dp[prev2][prev1][idx]!=-1)return dp[prev2][prev1][idx]%mod;//memoization\\n        int total=0;\\n        for(int i=1;i<=6;i++){\\n            if(i!=prev2&&i!=prev1&&__gcd(i,prev1)==1){\\n                total=(total+f(prev1,i,idx+1,n))%mod;\\n            }\\n            \\n        }\\n        return dp[prev2][prev1][idx]=total%mod;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        count=0;\\n        //set dp to -1 initially.\\n        for(int i=1;i<=7;i++){\\n            for(int j=1;j<=6;j++){\\n                for(int k=1;k<=10000;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        //set prev2 as a number which is not in [1-6] initially.i have kept 7 \\n        for(int i=1;i<=6;i++){\\n           count=(count+ f(7,i,2,n))%mod;\\n            \\n        }\\n        return count%mod;\\n        \\n        \\n        \\n        \\n    }\\n```\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "```\\nlong long count;long long mod=1e9+7;\\n    long long int dp[8][7][10001]={};\\n    long long f(int prev2,int prev1,int idx,int n){\\n\\t//if idx reaches n+1 we have successfully created a combination of n dices so add 1 to total count\\n        if(idx>n){\\n            return 1;\\n        }\\n        if(dp[prev2][prev1][idx]!=-1)return dp[prev2][prev1][idx]%mod;//memoization\\n        int total=0;\\n        for(int i=1;i<=6;i++){\\n            if(i!=prev2&&i!=prev1&&__gcd(i,prev1)==1){\\n                total=(total+f(prev1,i,idx+1,n))%mod;\\n            }\\n            \\n        }\\n        return dp[prev2][prev1][idx]=total%mod;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        count=0;\\n        //set dp to -1 initially.\\n        for(int i=1;i<=7;i++){\\n            for(int j=1;j<=6;j++){\\n                for(int k=1;k<=10000;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        //set prev2 as a number which is not in [1-6] initially.i have kept 7 \\n        for(int i=1;i<=6;i++){\\n           count=(count+ f(7,i,2,n))%mod;\\n            \\n        }\\n        return count%mod;\\n        \\n        \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2213859,
                "title": "python3-dp-using-dict",
                "content": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        # generate base case, e.g., if you roll 1 and 2 (1,2) then you can roll 3,5 as the next one\\n        d = defaultdict(list)\\n        for i in range(1,7):\\n            for j in range(1,7):\\n                if (i!=j) & (gcd(i,j)==1):\\n                    for k in range(1,7):\\n                        if (i!=k) & (k!=j) & (gcd(k,j)==1):\\n                            d[(i,j)].append(k)\\n                    \\n        if n==1:\\n            return 6\\n        elif n==2:\\n            return len(d.keys())\\n        else:\\n            cur = {}\\n            nex = defaultdict(int)\\n            for k in d.keys():\\n                cur[k] = 1\\n            x = 2\\n            m = (10**9+7)\\n            while x<n:\\n                for k in d.keys():\\n                    for j in d[k]:\\n                        nex[(k[1], j)] += (cur[k])%(10**9+7)\\n                cur = nex\\n                nex = defaultdict(int)\\n                x += 1\\n            return sum(cur.values())%(10**9+7)\\n            \\n                    \\n    def gcd(a, b):\\n        if(b == 0):\\n            return abs(a)\\n        else:\\n            return gcd(b, a % b)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        # generate base case, e.g., if you roll 1 and 2 (1,2) then you can roll 3,5 as the next one\\n        d = defaultdict(list)\\n        for i in range(1,7):\\n            for j in range(1,7):\\n                if (i!=j) & (gcd(i,j)==1):\\n                    for k in range(1,7):\\n                        if (i!=k) & (k!=j) & (gcd(k,j)==1):\\n                            d[(i,j)].append(k)\\n                    \\n        if n==1:\\n            return 6\\n        elif n==2:\\n            return len(d.keys())\\n        else:\\n            cur = {}",
                "codeTag": "Java"
            },
            {
                "id": 2211705,
                "title": "my-swift-solution",
                "content": "```\\n/* Next digit availability\\n1 : 2 3 4 5 6\\n2 : 1 3 5\\n3 : 1 2 4 5\\n4 : 1 3 5\\n5 : 1 2 3 4 6\\n6 : 1 5\\n*/\\n\\n\\nclass Solution {\\n    var dp: [[[Int]]] = []\\n    var N = 0\\n    let D = 1000000007\\n    \\n    let available: [Set<Int>] = [[1,2,3,4,5,6], [2,3,4,5,6], [1,3,5], [1,2,4,5], [1,3,5], [1,2,3,4,6], [1,5]]\\n    \\n    func distinctSequences(_ n: Int) -> Int {\\n        let a1 = Array<Int>(repeating: 0, count: 7)\\n        let a2: [[Int]] = Array(repeating: a1, count: 7)\\n        dp = Array(repeating: a2, count: n)\\n        N = n\\n        return dfs(0, 0, 0)\\n    }\\n    \\n    func dfs(_ i: Int, _ a: Int, _ b: Int) -> Int {\\n        if i == N {\\n            return 1\\n        }\\n        \\n        if dp[i][a][b] != 0 {\\n            return dp[i][a][b]\\n        }\\n        \\n        for j in 1...6 {\\n            if j != a && j != b && available[b].contains(j) {\\n                dp[i][a][b] += dfs(i+1, b, j)\\n                dp[i][a][b] %= D\\n            }\\n        }\\n        return dp[i][a][b]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\n/* Next digit availability\\n1 : 2 3 4 5 6\\n2 : 1 3 5\\n3 : 1 2 4 5\\n4 : 1 3 5\\n5 : 1 2 3 4 6\\n6 : 1 5\\n*/\\n\\n\\nclass Solution {\\n    var dp: [[[Int]]] = []\\n    var N = 0\\n    let D = 1000000007\\n    \\n    let available: [Set<Int>] = [[1,2,3,4,5,6], [2,3,4,5,6], [1,3,5], [1,2,4,5], [1,3,5], [1,2,3,4,6], [1,5]]\\n    \\n    func distinctSequences(_ n: Int) -> Int {\\n        let a1 = Array<Int>(repeating: 0, count: 7)\\n        let a2: [[Int]] = Array(repeating: a1, count: 7)\\n        dp = Array(repeating: a2, count: n)\\n        N = n\\n        return dfs(0, 0, 0)\\n    }\\n    \\n    func dfs(_ i: Int, _ a: Int, _ b: Int) -> Int {\\n        if i == N {\\n            return 1\\n        }\\n        \\n        if dp[i][a][b] != 0 {\\n            return dp[i][a][b]\\n        }\\n        \\n        for j in 1...6 {\\n            if j != a && j != b && available[b].contains(j) {\\n                dp[i][a][b] += dfs(i+1, b, j)\\n                dp[i][a][b] %= D\\n            }\\n        }\\n        return dp[i][a][b]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211283,
                "title": "c-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    //an array of \\n    int dp[10007][7][7]={};\\n    int mod=1e9+7;\\n    //prev-> previous element\\n    //pprev->previous of previous element\\n    int distinctSequences(int n,int prev=0,int pprev=0) {\\n        if(n==0)return 1;\\n        //if this is equal to 0 return since it is already being calculated\\n        if(dp[n][prev][pprev]!=0)return dp[n][prev][pprev]; \\n        // now from 1 to 6 check \\n        for(int i=1;i<=6;i++){\\n            //if it is not equal to prev or prev of prev element and gcd==1 somehow\\n            if(i!=prev&&i!=pprev&&(prev==0||__gcd(i,prev)==1))\\n                //add\\n            dp[n][prev][pprev]=(dp[n][prev][pprev]+distinctSequences(n-1,i,prev))%mod;\\n        }\\n        \\n        return dp[n][prev][pprev];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //an array of \\n    int dp[10007][7][7]={};\\n    int mod=1e9+7;\\n    //prev-> previous element\\n    //pprev->previous of previous element\\n    int distinctSequences(int n,int prev=0,int pprev=0) {\\n        if(n==0)return 1;\\n        //if this is equal to 0 return since it is already being calculated\\n        if(dp[n][prev][pprev]!=0)return dp[n][prev][pprev]; \\n        // now from 1 to 6 check \\n        for(int i=1;i<=6;i++){\\n            //if it is not equal to prev or prev of prev element and gcd==1 somehow\\n            if(i!=prev&&i!=pprev&&(prev==0||__gcd(i,prev)==1))\\n                //add\\n            dp[n][prev][pprev]=(dp[n][prev][pprev]+distinctSequences(n-1,i,prev))%mod;\\n        }\\n        \\n        return dp[n][prev][pprev];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208998,
                "title": "python-dp-top-down-bottom-up",
                "content": "**1. Top-down with memoization (O(N) time, O(N) space)**\\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        # Source: www.youtube.com/watch?v=dBs8vnvxZes&ab_channel=ProgrammingLivewithLarry\\n        # Inspiration: At least a gap of 2 -> need to keep track of last 2 numbers\\n    \\n        MOD = 1_000_000_007\\n        \\n        @lru_cache(maxsize = None)\\n        def helper(currIdx, prev, prevprev):\\n            nonlocal MOD\\n            if currIdx == n:\\n                return 1\\n            \\n            if prev is None:\\n                res = 0\\n                for i in range(1, 7):\\n                    res += helper(currIdx + 1, i, None)\\n                    res %= MOD\\n                return res\\n            \\n            res = 0\\n            for i in range(1, 7):\\n                if math.gcd(i, prev) == 1 and i != prev and i != prevprev:\\n                    res += helper(currIdx + 1, i, prev)\\n                    res %= MOD\\n            return res\\n                \\n        return helper(0, None, None)\\n```\\nRuntime: 8648 ms\\nMemory: 527.1 MB\\n\\n**2. Bottom-up with tabulation (O(N) time, O(1) space))**\\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1:\\n            return 6\\n        \\n        MOD = 1_000_000_007\\n        \\n        dp = [[0, 1, 1, 1, 1, 1],\\n              [1, 0, 1, 0, 1, 0],\\n              [1, 1, 0, 1, 1, 0], \\n              [1, 0, 1, 0, 1, 0], \\n              [1, 1, 1, 1, 0, 1], \\n              [1, 0, 0, 0, 1, 0]]\\n        \\n        allowable = set()\\n        for prevprev in range(1, 7):\\n            for prev in range(1, 7):\\n                for new in range(1, 7):\\n                    if new != prev and new != prevprev and math.gcd(new, prev) == 1:\\n                        allowable.add((prevprev, prev, new))\\n                        \\n        for i in range(3, n + 1):\\n            helper = [[0 for i in range(6)] for i in range(6)]\\n            \\n            for prevprev, prev, new in allowable:\\n                helper[prev-1][new-1] = (helper[prev-1][new-1] + dp[prevprev-1][prev-1]) % MOD\\n            dp = helper\\n        \\n        return sum(sum(row) for row in dp) % MOD\\n```\\nRuntime: 6711 ms\\nMemory: 14 MB\\n\\n**Remarks**:\\nEach value in the dp variable means the number of roll sequences with the second last number being (row-idx + 1) and the last number being (col-idx + 1). It is initialized with the length of roll sequences being 2. So for example, at row-0, col-0, it means \"11\", which cannot exist, so we put 0.\\n\\nThen we iterate through the rounds from 3 to n (inclusive), each round we initialize a new 2d array, and the way we map old array to the new array is that: col idx of the old 2d array (which represents the last number in the old sequence - 1) will become row idx of the new 2d array (which represents the second last number in the old sequence - 1). \\n\\n\\n**Notes (to myself)**:\\nThe hard part of the question is \"at least a gap of 2 rolls between equal valued rolls\". Initially, I wanted to do tabulation right away, as I could figure out how to the do the \\'mapping\\' from prev number to the next number (e.g. 2 can be followed by 1, 3, 5), yet I could not figure out how to enforce the \\'rule\\' from prevprev number to next number (e.g. \"12\" should only be followed by 3 and 5, not 1 as there is a 1 at index-0 already). After 2 days of thinking in my free time, I decided to watch ProgrammingLivewithLarry on Youtube, his \"At least a gap of 2 -> need to keep track of last 2 numbers\" was really insightful and that led me to work out the memoization approach.\\n\\nThe second hard part is converting the memoization to tabulation approach. There are a lot of solutions that do tabulation with O(n) space, where they keep an array of data structures, one for each idx. But since at each step, we are only referencing 1 step and 2 steps prior, I decided to only keep results from 1 step before and 2 steps before, rather than everything. This is a little challenging as well, to work out my own \\'mapping\\' logic from prior states to the current state (like how row-idx of old array will become col-idx of new array).\\n\\nBut this alone was not enough. Initially, I didn\\'t pre-compute allowable. Instead, I did 3 nested for-loops (prevprev from 1 to 6, prev from 1 to 6, new from 1 to 6), then I check to ensure that new != prev and new != prevprev and math.gcd(new, prev) == 1, which sum up to 6 * 6 * 6 * (1 + 1 + 1) = 648 operations for each round. This led to TLE. \\n\\nNext, I pre-computed this ```allowable``` variable, which is a set of permissible (prevprev, prev, new) combinations. Then I did the 3 nested for-loops again, and then for each (prevprev, prev, new) combination, I check to ensure it exists in ```allowable```. But this still leads to TLE occasionally, even though now it is only 6 * 6 * 6 = 216 lookup operations per round.\\n\\nThen I thought, why not just iterate through ```allowable``` directly LOL. The ```allowable``` contains only 110 permissible combinations, so now it is down to just 110 (add and modulo) operations per round. DONE! :D\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        # Source: www.youtube.com/watch?v=dBs8vnvxZes&ab_channel=ProgrammingLivewithLarry\\n        # Inspiration: At least a gap of 2 -> need to keep track of last 2 numbers\\n    \\n        MOD = 1_000_000_007\\n        \\n        @lru_cache(maxsize = None)\\n        def helper(currIdx, prev, prevprev):\\n            nonlocal MOD\\n            if currIdx == n:\\n                return 1\\n            \\n            if prev is None:\\n                res = 0\\n                for i in range(1, 7):\\n                    res += helper(currIdx + 1, i, None)\\n                    res %= MOD\\n                return res\\n            \\n            res = 0\\n            for i in range(1, 7):\\n                if math.gcd(i, prev) == 1 and i != prev and i != prevprev:\\n                    res += helper(currIdx + 1, i, prev)\\n                    res %= MOD\\n            return res\\n                \\n        return helper(0, None, None)\\n```\n```\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1:\\n            return 6\\n        \\n        MOD = 1_000_000_007\\n        \\n        dp = [[0, 1, 1, 1, 1, 1],\\n              [1, 0, 1, 0, 1, 0],\\n              [1, 1, 0, 1, 1, 0], \\n              [1, 0, 1, 0, 1, 0], \\n              [1, 1, 1, 1, 0, 1], \\n              [1, 0, 0, 0, 1, 0]]\\n        \\n        allowable = set()\\n        for prevprev in range(1, 7):\\n            for prev in range(1, 7):\\n                for new in range(1, 7):\\n                    if new != prev and new != prevprev and math.gcd(new, prev) == 1:\\n                        allowable.add((prevprev, prev, new))\\n                        \\n        for i in range(3, n + 1):\\n            helper = [[0 for i in range(6)] for i in range(6)]\\n            \\n            for prevprev, prev, new in allowable:\\n                helper[prev-1][new-1] = (helper[prev-1][new-1] + dp[prevprev-1][prev-1]) % MOD\\n            dp = helper\\n        \\n        return sum(sum(row) for row in dp) % MOD\\n```\n```allowable```\n```allowable```\n```allowable```\n```allowable```",
                "codeTag": "Java"
            },
            {
                "id": 2208236,
                "title": "python-attempts-to-achieve-an-o-logn-time-complexity",
                "content": "## 0x0. Linear Solution (Accepted)\\n\\nAs `n<=10^5`, an `O(n)` solution can be accepted quickly, and it is exactly what intends to be tested if this problem shows up in a regular interview. For example, my top-down `O(n)` DP solution, which takes advantage of function cache in a modulo level:\\n\\n```py\\nfrom functools import lru_cache\\nfrom itertools import product\\n\\nM = 10**9 + 7\\nforbidden = [(2,4),(2,6),(3,6),(4,6)]\\n\\n@lru_cache(None)\\ndef f(n,a,b):\\n    if n == 1: return 0\\n    if a==b or (a,b) in forbidden or (b,a) in forbidden:\\n        return 0\\n    if n == 2: return 1\\n    return sum(f(n-1,c,a) for c in range(1,7) if c!=b)%M\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        return sum(f(n,a,b) for (a,b) in product(range(1,7),repeat=2))%M\\n```\\n\\nIn this solution, I use `f(n,a,b)` to denote the counts of valid `n`-length sequences `seq` ends with `a` and `b` as `seq[-2]` and `seq[-1]`. It\\'s not hard to see that **`f(n,~,~)` is only related to `f(n-1,~,~)`**, and this is why we can solve this problem by dynamic programming even with `O(1)` space if implemented in a bottom-up way.\\n\\nThen I start to consider if we can squeeze the runtime further.\\n\\n## 0x1. A Funny Way to Divide and Conquer (TLE)\\n\\nI naturally thought about cut  a `n`-length sequence into two `n/2`-length sequences evenly. Then we need to record four parameters to denote a valid sequence apart from length `n`: they are `seq[0], seq[1], seq[-2], seq[-1]`, which are the first two numbers and the last two numbers of that sequence. The process of dividing and merging is explained in the pic below:\\n\\n![image](https://assets.leetcode.com/users/images/06a3a5cb-6b0d-4123-a92c-57e667631526_1656392674.7977839.png)\\n\\nFor every `f(n,a,b,c,d)`, we enumerate all `f(n/2,a,b,x,y)` and `f(n/2,g,h,c,d)` and check if the combination of `x,y,g,h` is egliable to merge. Though we use 4 elements to denote the head and tail as the state of sequence, we only need to check `f(n/2,~,~,~,~)` for every `f(n)`, thus we just need to go through `O(log(n))` numbers of unique lengths for every legal qudruple.\\n\\nMy stupid code implement:\\n\\n```py\\nfrom functools import lru_cache\\nfrom itertools import product\\n\\nM = 10**9 + 7\\n\\nforbidden = [(2,4),(2,6),(3,6),(4,6)]\\n\\n@lru_cache(None)\\ndef f(n,a,b,c,d):\\n    if n == 1: return 0\\n    for i,j in [(a,b),(c,d)]:\\n        if i == j or (i,j) in forbidden or (j,i) in forbidden:\\n            return 0\\n    if n == 2 and a==c and b==d:\\n        return 1\\n    if n % 2 == 1:\\n        return sum(f(n-1,a,b,e,c) for e in range(1,7) if e!=d)%M\\n    else:\\n        res = 0\\n        for x,y,g,h in product(range(1,7),repeat=4):\\n            if x!=g and y!=g and y!=h and (y,g) not in forbidden and (g,y) not in forbidden:\\n                res = (res + f(n//2,a,b,x,y) * f(n//2,g,h,c,d))%M\\n        return res\\n    \\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        return sum(f(n,a,b,c,d) for (a,b,c,d) in product(range(1,7),repeat=4))%M\\n```\\n\\nAs we use a quadruple to represent and calculate new states for each `n`, we still suffer from a huge constant factor `6^8` for each n, which leads to the TLE of this solution.\\n\\n## 0x2. Markov Process (Linear, Accepted)\\n\\nAs I said before, `f(n)` only depends on the value of `f(n-1)`, which indicates a typical [Markov process](https://math.libretexts.org/Bookshelves/Applied_Mathematics/Applied_Finite_Mathematics_(Sekhon_and_Bloom)/10%3A_Markov_Chains/10.01%3A_Introduction_to_Markov_Chains). Formally speaking, if we only record the values of the last two elements `i` and `j` to represent the sequece as state `(i,j)` at time `n`, then we can see that the number of valid sequences with this state is the sum of the ones in some valid `(k,i)` with the constraint `k!=i`.\\n\\nRecall that for a general Markov process, we represent the initial states for `m`-state problem as a vector of `m`-length called vector `S_0` at time 0, every element represent the count of that state. We still need a `m*m` **transition matrix** `T` to denote how the current state transit to the next state. Each element `t(i,j)` in this matrix denotes the probability of transit from state `i` to state `j`. Every time we time state vector `S` with matrix T to get a new state vector `S\\'`, as you know that \\n\\n```\\nS\\'(i) = sum(S(j)*t(j,i) for j in range(m))\\n```\\n\\nwhich is the definition of matrix multiplication and also sums up all counts of previous states `j` that can transit to the current state `i`. So it is very obvious that the state vector can be calculated by the recurrent formula:\\n\\n```\\nS_t = S_{t-1} * T\\n```\\n\\nIf we expand all `S_t` in rhs as the dot products above, we get the formula `S_t = S_0 * T * T * .. * T`, in which there is `n` `T`s in total.\\n\\nReturn to our problem, it is a special case that the transition matrix is a `0-1` matrix because either all sequences of state `state1` can turn into a state `state2` or none of them can. The initial state should be set at time `n=2`, we enumerate all valid 2-length sequences and then set `t(state1, state2)` as 1 if `state1` can turn to `state2`  otherwise as 0. Recall that we use the last 2 numbers `(i,j)` to represent a state, we need to encode it into a scalar number as an index in a vector. For example, I use `i*6+j` here and my code to initialize the state vector `S` and transition matrix `T` meanwhile is listed below:\\n\\n```py\\nimport numpy as np\\n\\nT = np.zeros((36,36),dtype=object)\\nS = np.zeros(36,dtype=int)\\nfor i in range(6):\\n  for j in range(6):\\n\\tif i!=j and math.gcd(i+1,j+1)==1:\\n\\t  S[i*6+j] = 1\\n\\t  for k in range(6):\\n\\t\\tif i!=k and j!=k and math.gcd(k+1,j+1) == 1:\\n\\t\\t  T[i*6+j][j*6+k] = 1\\n```\\n\\nThen if I calculate every `S_t` step by step using the formula above naively, I can still pass though slowly:\\n```py\\nif n == 1: return 6\\nM = 10**9 + 7\\nfor i in range(2,n):\\n\\tS = S.dot(T)%M\\nreturn int(S.sum()%M)\\n```\\n\\n## 0x3. Fast Exponentiation\\n\\nFine, there is only one small step forward to achieve `O(logn)` time. We know that the multiplication of matrices is associative, which means you can calculate `T^n` first. For the multiplication operation of associativity, we have a very famous optimization called [fast exponentiation by squaring](https://mathstats.uncg.edu/sites/pauli/112/HTML/secfastexp.html), which reduces the exponent `n` by half every time for every even `n`. I wrote a top-down version with modular `M` for matrices by recursion:\\n\\n```py\\ndef mat_pow(base,n):\\n\\tif n == 0:\\n\\t\\treturn np.eye(base.shape[0])\\n\\tif n == 1:\\n\\t\\treturn base\\n\\tif n % 2 == 1:\\n\\t\\treturn np.dot(mat_pow(base,n-1),base)%M\\n\\telse:\\n\\t\\thalf = mat_pow(base,n//2)\\n\\t\\treturn np.dot(half,half)%M\\n```\\n\\n[`numpy.linalg.matrix_power`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.matrix_power.html) implements the algorithm in a [bottom-up way](https://github.com/numpy/numpy/blob/v1.23.0/numpy/linalg/linalg.py#L560-L673) but unfortunately no built-in modulo operation supported in it so I have to write the function above. \\n\\nTherefore, the final full solution in O(logn) is written as:\\n\\n```py\\nimport numpy as np\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        M = 10**9 + 7\\n        T = np.zeros((36,36),dtype=object)\\n        S = np.zeros(36,dtype=int)\\n        for i in range(6):\\n          for j in range(6):\\n            if i!=j and math.gcd(i+1,j+1)==1:\\n              S[i*6+j] = 1\\n              for k in range(6):\\n                if i!=k and j!=k and math.gcd(k+1,j+1) == 1:\\n                  T[i*6+j][j*6+k] = 1\\n                \\n        def mat_pow(base,n):\\n            if n == 0:\\n                return np.eye(base.shape[0])\\n            if n == 1:\\n                return base\\n            if n % 2 == 1:\\n                return np.dot(mat_pow(base,n-1),base)%M\\n            else:\\n                half = mat_pow(base,n//2)\\n                return np.dot(half,half)%M\\n            \\n        return int(np.dot(S,mat_pow(T,n-2)%M).sum()%M)\\n```\\n\\nThe time complexity of matrix multiplication is supposed to be `O(m^3)` for two `m*m` matrice, but thanks to the amazing optimization in `numpy`, it was accepted very fast.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```py\\nfrom functools import lru_cache\\nfrom itertools import product\\n\\nM = 10**9 + 7\\nforbidden = [(2,4),(2,6),(3,6),(4,6)]\\n\\n@lru_cache(None)\\ndef f(n,a,b):\\n    if n == 1: return 0\\n    if a==b or (a,b) in forbidden or (b,a) in forbidden:\\n        return 0\\n    if n == 2: return 1\\n    return sum(f(n-1,c,a) for c in range(1,7) if c!=b)%M\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        return sum(f(n,a,b) for (a,b) in product(range(1,7),repeat=2))%M\\n```\n```py\\nfrom functools import lru_cache\\nfrom itertools import product\\n\\nM = 10**9 + 7\\n\\nforbidden = [(2,4),(2,6),(3,6),(4,6)]\\n\\n@lru_cache(None)\\ndef f(n,a,b,c,d):\\n    if n == 1: return 0\\n    for i,j in [(a,b),(c,d)]:\\n        if i == j or (i,j) in forbidden or (j,i) in forbidden:\\n            return 0\\n    if n == 2 and a==c and b==d:\\n        return 1\\n    if n % 2 == 1:\\n        return sum(f(n-1,a,b,e,c) for e in range(1,7) if e!=d)%M\\n    else:\\n        res = 0\\n        for x,y,g,h in product(range(1,7),repeat=4):\\n            if x!=g and y!=g and y!=h and (y,g) not in forbidden and (g,y) not in forbidden:\\n                res = (res + f(n//2,a,b,x,y) * f(n//2,g,h,c,d))%M\\n        return res\\n    \\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        return sum(f(n,a,b,c,d) for (a,b,c,d) in product(range(1,7),repeat=4))%M\\n```\n```\\nS\\'(i) = sum(S(j)*t(j,i) for j in range(m))\\n```\n```\\nS_t = S_{t-1} * T\\n```\n```py\\nimport numpy as np\\n\\nT = np.zeros((36,36),dtype=object)\\nS = np.zeros(36,dtype=int)\\nfor i in range(6):\\n  for j in range(6):\\n\\tif i!=j and math.gcd(i+1,j+1)==1:\\n\\t  S[i*6+j] = 1\\n\\t  for k in range(6):\\n\\t\\tif i!=k and j!=k and math.gcd(k+1,j+1) == 1:\\n\\t\\t  T[i*6+j][j*6+k] = 1\\n```\n```py\\nif n == 1: return 6\\nM = 10**9 + 7\\nfor i in range(2,n):\\n\\tS = S.dot(T)%M\\nreturn int(S.sum()%M)\\n```\n```py\\ndef mat_pow(base,n):\\n\\tif n == 0:\\n\\t\\treturn np.eye(base.shape[0])\\n\\tif n == 1:\\n\\t\\treturn base\\n\\tif n % 2 == 1:\\n\\t\\treturn np.dot(mat_pow(base,n-1),base)%M\\n\\telse:\\n\\t\\thalf = mat_pow(base,n//2)\\n\\t\\treturn np.dot(half,half)%M\\n```\n```py\\nimport numpy as np\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        M = 10**9 + 7\\n        T = np.zeros((36,36),dtype=object)\\n        S = np.zeros(36,dtype=int)\\n        for i in range(6):\\n          for j in range(6):\\n            if i!=j and math.gcd(i+1,j+1)==1:\\n              S[i*6+j] = 1\\n              for k in range(6):\\n                if i!=k and j!=k and math.gcd(k+1,j+1) == 1:\\n                  T[i*6+j][j*6+k] = 1\\n                \\n        def mat_pow(base,n):\\n            if n == 0:\\n                return np.eye(base.shape[0])\\n            if n == 1:\\n                return base\\n            if n % 2 == 1:\\n                return np.dot(mat_pow(base,n-1),base)%M\\n            else:\\n                half = mat_pow(base,n//2)\\n                return np.dot(half,half)%M\\n            \\n        return int(np.dot(S,mat_pow(T,n-2)%M).sum()%M)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207430,
                "title": "racket-solution",
                "content": "`dp[i][j][k]` means the number of sequences that have length `i+1` and ends with `[k, j]`.\\n`dp2[i][j]` means the number of sequences that have length `i+1` and ends with `[j]`.\\nSpecially, `dp2[i][j] = dp[i][j][1] + ... + dp[i][j][6]`.\\n\\n```scheme\\n(define/contract (distinct-sequences n)\\n  (-> exact-integer? exact-integer?)\\n\\n  (define (make-array . dims)\\n    (if (= (length dims) 1) (first dims)\\n        (build-vector (car dims) (lambda _ (apply make-array (cdr dims))))))\\n\\n  (define (aref arr . dims)\\n    (if (= (length dims) 0) arr\\n        (apply aref (vector-ref arr (car dims)) (cdr dims))))\\n\\n  (define (aset! arr . dims)\\n    (if (= (length dims) 2) (vector-set! arr (first dims) (second dims))\\n        (apply aset! (vector-ref arr (car dims)) (cdr dims))))\\n  \\n  (define (mod x) (modulo x (+ #e1e9 7)))\\n  (define (sum vec) (mod (foldl + 0 (vector->list vec))))\\n\\n  (let ([dp (make-array n 7 7 0)]\\n        [dp2 (make-array n 7 0)])\\n    (for ([j (range 1 7)])\\n      (aset! dp2 0 j 1))\\n    (for* ([i (range 1 n)]\\n           [j (range 1 7)])\\n      (for ([k (range 1 7)])\\n        (when (and (= 1 (gcd j k)) (not (= j k)))\\n            (aset! dp i j k\\n                   (- (aref dp2 (sub1 i) k)\\n                      (aref dp (sub1 i) k j)))))\\n      (aset! dp2 i j (sum (aref dp i j))))\\n    (sum (aref dp2 (sub1 n)))))\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```scheme\\n(define/contract (distinct-sequences n)\\n  (-> exact-integer? exact-integer?)\\n\\n  (define (make-array . dims)\\n    (if (= (length dims) 1) (first dims)\\n        (build-vector (car dims) (lambda _ (apply make-array (cdr dims))))))\\n\\n  (define (aref arr . dims)\\n    (if (= (length dims) 0) arr\\n        (apply aref (vector-ref arr (car dims)) (cdr dims))))\\n\\n  (define (aset! arr . dims)\\n    (if (= (length dims) 2) (vector-set! arr (first dims) (second dims))\\n        (apply aset! (vector-ref arr (car dims)) (cdr dims))))\\n  \\n  (define (mod x) (modulo x (+ #e1e9 7)))\\n  (define (sum vec) (mod (foldl + 0 (vector->list vec))))\\n\\n  (let ([dp (make-array n 7 7 0)]\\n        [dp2 (make-array n 7 0)])\\n    (for ([j (range 1 7)])\\n      (aset! dp2 0 j 1))\\n    (for* ([i (range 1 n)]\\n           [j (range 1 7)])\\n      (for ([k (range 1 7)])\\n        (when (and (= 1 (gcd j k)) (not (= j k)))\\n            (aset! dp i j k\\n                   (- (aref dp2 (sub1 i) k)\\n                      (aref dp (sub1 i) k j)))))\\n      (aset! dp2 i j (sum (aref dp i j))))\\n    (sum (aref dp2 (sub1 n)))))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2207285,
                "title": "c-dp",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n    int distinctSequences(int n) \\n    {\\n        if(n==1)return 6;\\n        ll f[n+1][7][7];\\n        ll tot[n+1][7];\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=6;j++)\\n                tot[i][j]=0;\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=6;j++)\\n                for(int k=0;k<=6;k++)\\n                    f[i][j][k]=0;\\n        for(int i=1;i<=6;i++)\\n            for(int j=1;j<=6;j++)\\n                f[2][i][j]+=1 ? ((i!=j)&&(gcd(i,j)==1)) : 0;\\n        for(int i=1;i<=6;i++)\\n            for(int j=1;j<=6;j++)\\n                tot[2][i]+=f[2][i][j];\\n        for(int i=3;i<=n;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n                for(int k=1;k<=6;k++)\\n                {\\n                    if((j==k)||(gcd(j,k)!=1))continue;\\n                    f[i][j][k]+=tot[i-1][k];\\n                    f[i][j][k]%=mod;\\n                    f[i][j][k]-=f[i-1][k][j];\\n                    f[i][j][k]=((f[i][j][k]%mod)+mod)%mod;\\n                }\\n            for(int j=1;j<=6;j++)\\n                for(int k=1;k<=6;k++)\\n                {\\n                    tot[i][j]+=f[i][j][k];\\n                    tot[i][j]%=mod;\\n                }\\n        }\\n        ll ans=0;\\n        for(int i=1;i<=6;i++)\\n        {\\n            ans+=tot[n][i];\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n    int distinctSequences(int n) \\n    {\\n        if(n==1)return 6;\\n        ll f[n+1][7][7];\\n        ll tot[n+1][7];\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=6;j++)\\n                tot[i][j]=0;\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=6;j++)\\n                for(int k=0;k<=6;k++)\\n                    f[i][j][k]=0;\\n        for(int i=1;i<=6;i++)\\n            for(int j=1;j<=6;j++)\\n                f[2][i][j]+=1 ? ((i!=j)&&(gcd(i,j)==1)) : 0;\\n        for(int i=1;i<=6;i++)\\n            for(int j=1;j<=6;j++)\\n                tot[2][i]+=f[2][i][j];\\n        for(int i=3;i<=n;i++)\\n        {\\n            for(int j=1;j<=6;j++)\\n                for(int k=1;k<=6;k++)\\n                {\\n                    if((j==k)||(gcd(j,k)!=1))continue;\\n                    f[i][j][k]+=tot[i-1][k];\\n                    f[i][j][k]%=mod;\\n                    f[i][j][k]-=f[i-1][k][j];\\n                    f[i][j][k]=((f[i][j][k]%mod)+mod)%mod;\\n                }\\n            for(int j=1;j<=6;j++)\\n                for(int k=1;k<=6;k++)\\n                {\\n                    tot[i][j]+=f[i][j][k];\\n                    tot[i][j]%=mod;\\n                }\\n        }\\n        ll ans=0;\\n        for(int i=1;i<=6;i++)\\n        {\\n            ans+=tot[n][i];\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206849,
                "title": "golang-dp-recursion",
                "content": "```\\nfunc distinctSequences(n int) int {\\n\\tmem := make([][7][7]int, n)\\n\\tfor i := range mem {\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tfor k := range mem[i][j] {\\n\\t\\t\\t\\tmem[i][j][k] = -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tM := 1000000007\\n\\tgcd := func(a, b int) int {\\n\\t\\tfor b != 0 {\\n\\t\\t\\tt := b\\n\\t\\t\\tb = a % b\\n\\t\\t\\ta = t\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\tvar dp func(i, p1, p2 int) int\\n\\tdp = func(k, p1, p2 int) int {\\n\\t\\tif k >= n {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tif mem[k][p1][p2] != -1 {\\n\\t\\t\\treturn mem[k][p1][p2]\\n\\t\\t}\\n\\t\\tmem[k][p1][p2] = 0\\n\\t\\tfor i := 1; i < 7; i++ {\\n\\t\\t\\tif (p2 != 0 && (p2 == i || gcd(p2, i) != 1)) || (p1 != 0 && p1 == i) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tmem[k][p1][p2] += dp(k+1, p2, i) % M\\n\\t\\t}\\n\\t\\treturn mem[k][p1][p2]\\n\\t}\\n\\treturn dp(0, 0, 0) % M\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc distinctSequences(n int) int {\\n\\tmem := make([][7][7]int, n)\\n\\tfor i := range mem {\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tfor k := range mem[i][j] {\\n\\t\\t\\t\\tmem[i][j][k] = -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tM := 1000000007\\n\\tgcd := func(a, b int) int {\\n\\t\\tfor b != 0 {\\n\\t\\t\\tt := b\\n\\t\\t\\tb = a % b\\n\\t\\t\\ta = t\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\tvar dp func(i, p1, p2 int) int\\n\\tdp = func(k, p1, p2 int) int {\\n\\t\\tif k >= n {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tif mem[k][p1][p2] != -1 {\\n\\t\\t\\treturn mem[k][p1][p2]\\n\\t\\t}\\n\\t\\tmem[k][p1][p2] = 0\\n\\t\\tfor i := 1; i < 7; i++ {\\n\\t\\t\\tif (p2 != 0 && (p2 == i || gcd(p2, i) != 1)) || (p1 != 0 && p1 == i) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tmem[k][p1][p2] += dp(k+1, p2, i) % M\\n\\t\\t}\\n\\t\\treturn mem[k][p1][p2]\\n\\t}\\n\\treturn dp(0, 0, 0) % M\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2206633,
                "title": "time-n-6-6-6",
                "content": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if(n==1)\\n            return 6;\\n        int sum = 0;\\n        int dp[7][7][10001]={0};\\n        --n;\\n        for(int i=1;i<7;i++)\\n            for(int j=1;j<7;j++)\\n                if(i!=j && __gcd(i,j)==1)\\n                    dp[i][j][1]=1;\\n        \\n        for(int i=2;i<=n;i++)\\n        {\\n            for(int j=1;j<7;j++)\\n            {\\n                for(int k=1;k<7;k++)\\n                {\\n                    for(int w=1;w<7;w++)\\n                    {\\n                        if(j!=k && __gcd(k,j)==1 && w!=k && w!=j && __gcd(w,k)==1)\\n                            dp[j][k][i] = (dp[j][k][i]%mod + dp[k][w][i-1]%mod)%mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<7;i++)\\n            for(int j=1;j<7;j++)\\n                sum = (sum%mod + dp[i][j][n]%mod)%mod;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        if(n==1)\\n            return 6;\\n        int sum = 0;\\n        int dp[7][7][10001]={0};\\n        --n;\\n        for(int i=1;i<7;i++)\\n            for(int j=1;j<7;j++)\\n                if(i!=j && __gcd(i,j)==1)\\n                    dp[i][j][1]=1;\\n        \\n        for(int i=2;i<=n;i++)\\n        {\\n            for(int j=1;j<7;j++)\\n            {\\n                for(int k=1;k<7;k++)\\n                {\\n                    for(int w=1;w<7;w++)\\n                    {\\n                        if(j!=k && __gcd(k,j)==1 && w!=k && w!=j && __gcd(w,k)==1)\\n                            dp[j][k][i] = (dp[j][k][i]%mod + dp[k][w][i-1]%mod)%mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<7;i++)\\n            for(int j=1;j<7;j++)\\n                sum = (sum%mod + dp[i][j][n]%mod)%mod;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205958,
                "title": "c-simple-dp-100",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    ll mod=1e9+7;\\n    ll dp[7][7][10001];\\n    vector<vector<int>>m{{},{2,3,4,5,6},{1,3,5},{1,2,4,5},{1,3,5},{1,2,3,4,6},{1,5}};\\n    ll find(int p,int pp,int n)\\n    {\\n        if(n==0)\\n            return 1;\\n        if(dp[p][pp][n]!=-1)\\n            return dp[p][pp][n];\\n        ll res=0;\\n        for(auto &x:m[p])\\n        {\\n            if(x!=pp)\\n                res=(res+find(x,p,n-1))%mod;\\n        }\\n        return dp[p][pp][n]=res;\\n    }\\n    int distinctSequences(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        ll res=0;\\n        for(int i=1;i<=6;i++)\\n            res=(res+find(i,0,n-1))%mod;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    ll mod=1e9+7;\\n    ll dp[7][7][10001];\\n    vector<vector<int>>m{{},{2,3,4,5,6},{1,3,5},{1,2,4,5},{1,3,5},{1,2,3,4,6},{1,5}};\\n    ll find(int p,int pp,int n)\\n    {\\n        if(n==0)\\n            return 1;\\n        if(dp[p][pp][n]!=-1)\\n            return dp[p][pp][n];\\n        ll res=0;\\n        for(auto &x:m[p])\\n        {\\n            if(x!=pp)\\n                res=(res+find(x,p,n-1))%mod;\\n        }\\n        return dp[p][pp][n]=res;\\n    }\\n    int distinctSequences(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        ll res=0;\\n        for(int i=1;i<=6;i++)\\n            res=(res+find(i,0,n-1))%mod;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204494,
                "title": "c-dp-solution",
                "content": "#### Explaination:\\n\\n**Brute Force**\\n\\n> DFS solution\\n\\ntime complexity: ```O(N^6) exponenetial time```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int r1[7][7] = {\\n        {0,1,1,1,1,1,1},// initial case\\n        {0,0,1,1,1,1,1},\\n        {0,1,0,1,0,1,0},\\n        {0,1,1,0,1,1,0},\\n        {0,1,0,1,0,1,0},\\n        {0,1,1,1,1,0,1},\\n        {0,1,0,0,0,1,0}\\n    };\\n    int mod = 1000000007, start;\\n    int solve(int n, int p, int pp){\\n        if(n == 0) return 1;\\n        int res = 0;\\n\\n        for(int i = 1; i < 7; i++)\\n        {\\n            if(r1[p][i] == 1 && pp != i)\\n            {\\n                res = (res + solve(n-1,i,p)) % mod;\\n            }\\n        }\\n        return res;\\n    }\\n    int distinctSequences(int n) {\\n        return solve(n,0,0);\\n    }\\n};\\n```\\n\\n**DP**\\n\\nOtherwise, we want to store previously calculated data, and reuse them.\\n\\nsuch as, we go though 1->2->3, and we stored that ```res``` value.\\nAnd when encounter 5->2->3, the 2->3 data can be reuse, therefore reduce the time complexity gigantically to ```O(N)``` linear time.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int r1[7][7] = {\\n        {0,1,1,1,1,1,1},// initial case\\n        {0,0,1,1,1,1,1},\\n        {0,1,0,1,0,1,0},\\n        {0,1,1,0,1,1,0},\\n        {0,1,0,1,0,1,0},\\n        {0,1,1,1,1,0,1},\\n        {0,1,0,0,0,1,0}\\n    };\\n    int mod = 1000000007, start;\\n    int dp[10001][7][7] = {};\\n    int solve(int n, int p, int pp){\\n        if(n == 0) return 1;\\n        if(dp[n][p][pp] > 0) return dp[n][p][pp];\\n        int res = 0;\\n\\n        for(int i = 1; i < 7; i++)\\n        {\\n            if(r1[p][i] == 1 && pp != i)\\n            {\\n                res = (res + solve(n-1,i,p)) % mod;\\n            }\\n        }\\n        dp[n][p][pp] = res;\\n        return res;\\n    }\\n    int distinctSequences(int n) {\\n        return solve(n,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```O(N^6) exponenetial time```\n```cpp\\nclass Solution {\\npublic:\\n    int r1[7][7] = {\\n        {0,1,1,1,1,1,1},// initial case\\n        {0,0,1,1,1,1,1},\\n        {0,1,0,1,0,1,0},\\n        {0,1,1,0,1,1,0},\\n        {0,1,0,1,0,1,0},\\n        {0,1,1,1,1,0,1},\\n        {0,1,0,0,0,1,0}\\n    };\\n    int mod = 1000000007, start;\\n    int solve(int n, int p, int pp){\\n        if(n == 0) return 1;\\n        int res = 0;\\n\\n        for(int i = 1; i < 7; i++)\\n        {\\n            if(r1[p][i] == 1 && pp != i)\\n            {\\n                res = (res + solve(n-1,i,p)) % mod;\\n            }\\n        }\\n        return res;\\n    }\\n    int distinctSequences(int n) {\\n        return solve(n,0,0);\\n    }\\n};\\n```\n```res```\n```O(N)```\n```cpp\\nclass Solution {\\npublic:\\n    int r1[7][7] = {\\n        {0,1,1,1,1,1,1},// initial case\\n        {0,0,1,1,1,1,1},\\n        {0,1,0,1,0,1,0},\\n        {0,1,1,0,1,1,0},\\n        {0,1,0,1,0,1,0},\\n        {0,1,1,1,1,0,1},\\n        {0,1,0,0,0,1,0}\\n    };\\n    int mod = 1000000007, start;\\n    int dp[10001][7][7] = {};\\n    int solve(int n, int p, int pp){\\n        if(n == 0) return 1;\\n        if(dp[n][p][pp] > 0) return dp[n][p][pp];\\n        int res = 0;\\n\\n        for(int i = 1; i < 7; i++)\\n        {\\n            if(r1[p][i] == 1 && pp != i)\\n            {\\n                res = (res + solve(n-1,i,p)) % mod;\\n            }\\n        }\\n        dp[n][p][pp] = res;\\n        return res;\\n    }\\n    int distinctSequences(int n) {\\n        return solve(n,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203871,
                "title": "python3-dp-o-n-time-and-o-1-space-beat-100",
                "content": "```\\nfrom itertools import product\\nfrom math import gcd\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        states = set([(i, j) for i, j in product(range(1, 7), range(1, 7)) if i != j and gcd(i, j) == 1])\\n        valid_pair = [set() for _ in range(7)]\\n        MOD, dp = 10 ** 9 + 7, [[[0] * 7 for _ in range(7)], []]\\n        for x, y in states:\\n            valid_pair[x].add(y)\\n            dp[0][x][y] = 1\\n        for v in range(3, n + 1):\\n            dp[v & 1] = [[0] * 7 for _ in range(7)]\\n            for i, j in states:\\n                for k in (valid_pair[j] - {i}): dp[v & 1][j][k] = (dp[v & 1][j][k] + dp[(v - 1) & 1][i][j]) % MOD\\n        return sum(sum(row) for row in dp[n & 1]) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\nfrom math import gcd\\n\\nclass Solution:\\n    def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        states = set([(i, j) for i, j in product(range(1, 7), range(1, 7)) if i != j and gcd(i, j) == 1])\\n        valid_pair = [set() for _ in range(7)]\\n        MOD, dp = 10 ** 9 + 7, [[[0] * 7 for _ in range(7)], []]\\n        for x, y in states:\\n            valid_pair[x].add(y)\\n            dp[0][x][y] = 1\\n        for v in range(3, n + 1):\\n            dp[v & 1] = [[0] * 7 for _ in range(7)]\\n            for i, j in states:\\n                for k in (valid_pair[j] - {i}): dp[v & 1][j][k] = (dp[v & 1][j][k] + dp[(v - 1) & 1][i][j]) % MOD\\n        return sum(sum(row) for row in dp[n & 1]) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202673,
                "title": "scala",
                "content": "```\\nimport scala.collection.immutable.BitSet\\n\\nobject Solution {\\n  private val Modulus = 1000000007\\n\\n  private val NextPossibleRolls = IndexedSeq(BitSet(2, 3, 4, 5, 6),\\n                                             BitSet(1, 3, 5),\\n                                             BitSet(1, 2, 4, 5),\\n                                             BitSet(1, 3, 5),\\n                                             BitSet(1, 2, 3, 4, 6),\\n                                             BitSet(1, 5))\\n\\n  def distinctSequences(n: Int): Int = n match {\\n    case 1 => 6\\n    case n => (2 until n)\\n      .foldLeft {\\n        NextPossibleRolls\\n          .iterator\\n          .zipWithIndex\\n          .flatMap { case (nextRolls, i) => nextRolls.iterator.map((i + 1) -> _ -> 1) }\\n          .toMap\\n      } {\\n        case (rollsToCount, _) => rollsToCount\\n          .view\\n          .flatMap {\\n            case roll1 -> roll2 -> count => (nextPossibleRolls(roll2) - roll1).iterator.map(roll2 -> _ -> count)\\n          }\\n          .groupMapReduce(_._1)(_._2)(add)\\n      }\\n      .valuesIterator\\n      .fold(0)(add)\\n  }\\n\\n  private def add(x: Int, y: Int) = (x + y) % Modulus\\n\\n  private def nextPossibleRolls(roll: Int) = NextPossibleRolls(roll - 1)\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport scala.collection.immutable.BitSet\\n\\nobject Solution {\\n  private val Modulus = 1000000007\\n\\n  private val NextPossibleRolls = IndexedSeq(BitSet(2, 3, 4, 5, 6),\\n                                             BitSet(1, 3, 5),\\n                                             BitSet(1, 2, 4, 5),\\n                                             BitSet(1, 3, 5),\\n                                             BitSet(1, 2, 3, 4, 6),\\n                                             BitSet(1, 5))\\n\\n  def distinctSequences(n: Int): Int = n match {\\n    case 1 => 6\\n    case n => (2 until n)\\n      .foldLeft {\\n        NextPossibleRolls\\n          .iterator\\n          .zipWithIndex\\n          .flatMap { case (nextRolls, i) => nextRolls.iterator.map((i + 1) -> _ -> 1) }\\n          .toMap\\n      } {\\n        case (rollsToCount, _) => rollsToCount\\n          .view\\n          .flatMap {\\n            case roll1 -> roll2 -> count => (nextPossibleRolls(roll2) - roll1).iterator.map(roll2 -> _ -> count)\\n          }\\n          .groupMapReduce(_._1)(_._2)(add)\\n      }\\n      .valuesIterator\\n      .fold(0)(add)\\n  }\\n\\n  private def add(x: Int, y: Int) = (x + y) % Modulus\\n\\n  private def nextPossibleRolls(roll: Int) = NextPossibleRolls(roll - 1)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2201762,
                "title": "dp-solution-with-comments",
                "content": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    int gcd(int x, int y) {\\n        if(x<y) swap(x, y);\\n        return y==0 ? x : gcd(y, x%y);\\n        \\n    }\\n    /*\\n    Assume we have n positions to fill and for each position we have 6 options(1, 2, 3, 4, 5, 6) and make sure the prev 2 positions does not match with your current choice and gcd of curr choice and just prev element is 1.\\n    If we follow this the problem reduces to backtracking where we need to count each and every possible option and since backtracking complexity is exponential so we have to memoize it so we\\'ll use dp.\\n    */\\n    int count(int idx, int prev1, int prev2, int &n, vector<vector<vector<int>>> &dp) {\\n        if(idx == n) return 1;\\n        if(dp[idx][prev1][prev2] != -1) return dp[idx][prev1][prev2];\\n        int res = 0;\\n        for(int i=1; i<=6; i++) {\\n            if(prev1 == 0 and prev2 == 0) res = (res%mod + count(idx+1, i, prev1, n, dp)%mod)%mod;\\n            else if(i != prev1 and i != prev2 and gcd(i, prev1) == 1) res = (res%mod + count(idx+1, i, prev1, n, dp)%mod)%mod;\\n        }\\n        return dp[idx][prev1][prev2] = res%mod;\\n    }\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (7, vector<int>(7, -1)));\\n        return count(0, 0, 0, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    int gcd(int x, int y) {\\n        if(x<y) swap(x, y);\\n        return y==0 ? x : gcd(y, x%y);\\n        \\n    }\\n    /*\\n    Assume we have n positions to fill and for each position we have 6 options(1, 2, 3, 4, 5, 6) and make sure the prev 2 positions does not match with your current choice and gcd of curr choice and just prev element is 1.\\n    If we follow this the problem reduces to backtracking where we need to count each and every possible option and since backtracking complexity is exponential so we have to memoize it so we\\'ll use dp.\\n    */\\n    int count(int idx, int prev1, int prev2, int &n, vector<vector<vector<int>>> &dp) {\\n        if(idx == n) return 1;\\n        if(dp[idx][prev1][prev2] != -1) return dp[idx][prev1][prev2];\\n        int res = 0;\\n        for(int i=1; i<=6; i++) {\\n            if(prev1 == 0 and prev2 == 0) res = (res%mod + count(idx+1, i, prev1, n, dp)%mod)%mod;\\n            else if(i != prev1 and i != prev2 and gcd(i, prev1) == 1) res = (res%mod + count(idx+1, i, prev1, n, dp)%mod)%mod;\\n        }\\n        return dp[idx][prev1][prev2] = res%mod;\\n    }\\npublic:\\n    int distinctSequences(int n) {\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (7, vector<int>(7, -1)));\\n        return count(0, 0, 0, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201514,
                "title": "c-dp-short-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        int mod = 1e9+7;\\n        vector<vector<long long>> dp(n+1,vector<long long>(7));\\n        dp[1][1] = dp[1][2] = dp[1][3] = dp[1][4] = dp[1][5] = dp[1][6] = 1;\\n        for(int i = 2;i<=n;i++)\\n        {\\n            for(int j = 1;j<=6;j++)\\n            {\\n                for(int k = 1;k<=6;k++)\\n                {\\n                    if(j == k)\\n                    {\\n                         if(i>3)\\n                            dp[i][j] += dp[i-2][k], dp[i][j]%=mod;\\n                    }\\n                    else if((j%2 != 0 || k%2!=0) && j*k != 18)\\n                    {\\n                        dp[i][j] += dp[i-1][k] - dp[i-2][j];\\n                        dp[i][j] = (dp[i][j] + mod)%mod;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        long long ans = 0;\\n        for(int i = 1;i<=6;i++)\\n        {\\n            ans += dp[n][i];\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        int mod = 1e9+7;\\n        vector<vector<long long>> dp(n+1,vector<long long>(7));\\n        dp[1][1] = dp[1][2] = dp[1][3] = dp[1][4] = dp[1][5] = dp[1][6] = 1;\\n        for(int i = 2;i<=n;i++)\\n        {\\n            for(int j = 1;j<=6;j++)\\n            {\\n                for(int k = 1;k<=6;k++)\\n                {\\n                    if(j == k)\\n                    {\\n                         if(i>3)\\n                            dp[i][j] += dp[i-2][k], dp[i][j]%=mod;\\n                    }\\n                    else if((j%2 != 0 || k%2!=0) && j*k != 18)\\n                    {\\n                        dp[i][j] += dp[i-1][k] - dp[i-2][j];\\n                        dp[i][j] = (dp[i][j] + mod)%mod;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        long long ans = 0;\\n        for(int i = 1;i<=6;i++)\\n        {\\n            ans += dp[n][i];\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200879,
                "title": "superfast-linear-recurrence-just-for-fun",
                "content": "As one can easily see, the answer must be a linear recurrence sequence. The length of recurrence relation shall be no more than 22  which is the number of valid states in DP, so theoretically we can derive the recurrence relation from the first 23 terms (except the special case n=1). Surprisingly due to some symmetry the relation is much simpler than expected, giving a very fast solution.\\n```\\nclass Solution(object):\\n    def distinctSequences(self, n):\\n        if n==1:\\n            return 6\\n        a,b,c,d,e,f,g=22, 66, 184, 516, 1472, 4136, 11672\\n        for _ in range(n-2):\\n            a,b,c,d,e,f,g=b,c,d,e,f,g,(12*e+15*d+32*c+18*b+24*a)%(10**9+7)\\n        return a\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctSequences(self, n):\\n        if n==1:\\n            return 6\\n        a,b,c,d,e,f,g=22, 66, 184, 516, 1472, 4136, 11672\\n        for _ in range(n-2):\\n            a,b,c,d,e,f,g=b,c,d,e,f,g,(12*e+15*d+32*c+18*b+24*a)%(10**9+7)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200827,
                "title": "op-solution",
                "content": "The idea is to create a 3d dp array, where dp[i][j][k] represents the value of valid sequences, upitll index(i), with the current digit being (j) and the digit just before j being (k). The only things we need to do consider are:\\n1. j and k are not same\\n2. j and k dont have their gcd>1\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL);cout.tie(NULL);\\n        ll dp[n+1][7][7],mod=1e9+7,ans=0;\\n        memset(dp,0,sizeof(dp));\\n        int i,j,k,t;\\n        for(i=1;i<=6;i++) dp[1][i][i]=1;\\n        for(i=2;i<=n;i++){\\n            for(j=1;j<=6;j++){\\n                for(k=1;k<=6;k++){\\n                    if(__gcd(j,k)!=1||(j==k)) continue;\\n                    for(t=1;t<=6;t++){\\n                        if(j==t) continue;\\n                        dp[i][j][k]=(dp[i][j][k]+dp[i-1][k][t])%mod;\\n                    }\\n                }\\n            }\\n        }\\n        for(i=1;i<=6;i++)\\n            for(j=1;j<=6;j++) ans=(ans+dp[n][i][j])%mod;\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL);cout.tie(NULL);\\n        ll dp[n+1][7][7],mod=1e9+7,ans=0;\\n        memset(dp,0,sizeof(dp));\\n        int i,j,k,t;\\n        for(i=1;i<=6;i++) dp[1][i][i]=1;\\n        for(i=2;i<=n;i++){\\n            for(j=1;j<=6;j++){\\n                for(k=1;k<=6;k++){\\n                    if(__gcd(j,k)!=1||(j==k)) continue;\\n                    for(t=1;t<=6;t++){\\n                        if(j==t) continue;\\n                        dp[i][j][k]=(dp[i][j][k]+dp[i-1][k][t])%mod;\\n                    }\\n                }\\n            }\\n        }\\n        for(i=1;i<=6;i++)\\n            for(j=1;j<=6;j++) ans=(ans+dp[n][i][j])%mod;\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2200767,
                "title": "dp-bottom-up-o-n-my-problem-solving-diary",
                "content": "# Idea\\n\\nSome keywords in this problem prompt me to use dp to solve the problem,\\nthe most obvious one is \\n**\"total number of distinct sequences possible\"**\\n\\nAnd we get only a limited amount of roll states (1to 6) ,  and the number of time to \\nroll the dice is 10^4, it\\'s still feasible to construct the dp array with this number .\\n\\nAnd my orginal idea ( incorrect)  is to create an dp[10000][6] array, \\ndp[i][j] means how many number of distinct sequence we can get \\nfor i th roll with the reuslt j , \\nFor example , dp[10][3]  means the total number of possible distinct sequence we can get at 10 th roll with the result value as 3 \\n\\nSo the return result is \\nfor i in (1 to 6)  result += dp[n][i] \\n\\nThe actual code is at the following section, this is incorrect and I \\nwill illustrate what is missing from this code and idea.\\n\\n\\nCorrect idea from [@lee215](https://leetcode.com/problems/number-of-distinct-roll-sequences/discuss/2195996/Python-DP-Solution-with-Explanation) and [@votrubac](https://leetcode.com/problems/number-of-distinct-roll-sequences/discuss/2195808/Top-Down-and-Bottom-Up-DP)\\nThanks to them, but I sitll spend long time trying to understand how to implement this correct idea and the code. I will try to explain the code at the third section.\\n\\n\\n# My first solution ( not ac\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        // dp [i][j] means how many distinct sequences we can get\\n\\t\\t// for i th roll with the value j as roll result\\n\\t\\tvector<vector<int>> dp(n+1, vector<int>(7,0));\\n        \\n\\t\\t// initialize \\n\\t\\t// at the start , number of distinct sequences we can get \\n\\t\\t// is just one for 1-6 value\\n        for(int i=1; i <= 6; i++) {\\n            dp[0][i] = 1;\\n           \\n        }\\n        int mod = 1000000007;\\n\\t\\t// all possible adjacent value for dice value 1-6 \\n\\t\\t// to follow the rule 1 \\n        vector<vector<int>> roll_adj_count = {{2,3,4,5,6}, {1,3,5}, {1,2,4,5}, {1,3,5}, {1,2,3,4,6}, {1,5}};\\n\\t\\t// start iterating for each round of roll\\n        for(int roll_idx =1; roll_idx < n; roll_idx++) {\\n            // each round we can get 6 possible values(1-6)\\n\\t\\t\\t// count results for each possible value \\n\\t\\t\\tfor(int val=1; val <= 6; val++) {\\n\\t\\t\\t\\t\\n                int roll_adj_idx = val -1;\\n                auto& nei = roll_adj_count[roll_adj_idx];\\n                // iterate all possible adjacent values for current value \\n\\t\\t\\t\\tfor(int nei_num: nei) {\\n\\t\\t\\t\\t\\t// dp[roll_idx][val] depends on dp[roll_idx-1][all possible nei number]\\n                    dp[roll_idx][val]+= dp[roll_idx-1][nei_num];\\n                    // I don\\'t know why this is wrong\\n\\t\\t\\t\\t\\t// My explanation would be\\n\\t\\t\\t\\t\\t// we need to follow the rule 2 \\n\\t\\t\\t\\t\\t// and subtract the previous 2 value from the current one \\n\\t\\t\\t\\t\\t// does not neccessarily brings us the correct answer\\n\\t\\t\\t\\t\\t//  I still don\\'t know why this doesn\\'t work,\\n\\t\\t\\t\\t\\t// I will just leave it here .\\n\\t\\t\\t\\t\\t int nei_idx = nei_num -1;\\n                    auto &nei_nei  = roll_adj_count[nei_idx];\\n                    if(roll_idx >= 2) {\\n                        for(int nei_nei_val: nei_nei) {\\n\\t\\t\\t\\t\\t\\t\\t// the number of distinct sequence \\n\\t\\t\\t\\t\\t\\t\\t// of previous val of current val \\n\\t\\t\\t\\t\\t\\t\\t// may depends on previous 2 val \\n\\t\\t\\t\\t\\t\\t\\t// so we try to subtract thouse values.\\n                            if(nei_nei_val == val) {\\n                                dp[roll_idx][val] -= dp[roll_idx-2][val];\\n                            }\\n                        }\\n                        \\n                        \\n                    }   \\n                    dp[roll_idx][val] %= mod;\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int val=1; val <=6; val++) {\\n            res += dp[n-1][val];\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\n\\n```\\n\\n\\nUpdate for reason why the above code not working:\\nThe way we count the number for dp[round_i][val] is wrong,\\nit depends on dp[round_i-1][nei_val] and dp[round_i-2][val]\\nbut dp[round_i-1][nei_val] depends on dp[round_i-3][val]\\n\\nsubtract dp[round_i-2][val] from dp[round_i-1][nei_val] is not what we want.\\n\\n\\n\\n\\n\\n\\n\\n# Second solution,  Correct solution \\nAlright, move on to the correct solution.\\n\\nThe idea is to use two dp array \\ndp[cur_val][pre_val]  store the number of distinct sequence we can get with cur_val as roll result with pre_val roll result. \\ndp[pre_val][pre2_val] is similar to dp[cur_val][pre_val] but store the dp states at \\none more previous roll.\\n\\nAnd we do not need to store result of each roll, since the current number of \\ndistinct only depends on previous roll and previous 2 roll .\\n\\nAnd the reason we need dp[pre_val][pre2_val] is that we need to follow the rule 2\\n\"There is at least a gap of 2 rolls between equal valued rolls abs(i-j) > 2\"\\n\\nand the state transfer formula is as follow:\\n```\\nfor all legal pre_val //(follow the rule 1, gcd(pre_val, cur_val) == 1 )\\n\\tfor all legal pre2_val // (follow the rule 2, pre2_val != cur_val)\\n\\t\\tdp[cur_val][pre_val]  =  dp[cur_val][pre_val] + dp[pre_val][pre2_val]\\n\\n\\n```\\n\\n\\nThe code is as below \\n```\\n\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        int mod = 1000000007;\\n\\t\\t// valid adjacent val for each roll value 1-6\\n        vector<vector<int>> roll_adj_count = {{2,3,4,5,6}, {1,3,5}, {1,2,4,5}, {1,3,5}, {1,2,3,4,6}, {1,5}};\\n        \\n\\t\\t// initial dp states\\n        vector<vector<int>> dp = {{0,1,1,1,1,1}, {1,0,1,0,1,0}, {1,1,0,1,1,0}, {1,0,1,0,1,0}, {1,1,1,1,0,1}, {1,0,0,0,1,0}};\\n        \\n\\t\\t// new dp state for cur_val \\n        vector<vector<int>> dp_next(6, vector<int>(6,0));\\n        if(n == 1) {\\n            return 6;\\n        }\\n\\t\\t// for each roll \\n        for(int i=3; i <= n ;i++ ){\\n\\t\\t\\t// for each possible roll \\n            for(int val=1; val <=6; val++) {\\n                int val_idx = val-1;\\n                auto& neis = roll_adj_count[val_idx];\\n                \\n\\t\\t\\t\\t// for each legal previous roll \\n                for(int nei_val: neis) {\\n                    int nei_idx = nei_val -1;\\n\\t\\t\\t\\t\\t// for each legal one more previous roll \\n                    for(int pp=1; pp <= 6; pp++) {\\n                        int pp_idx = pp-1;\\n\\t\\t\\t\\t\\t\\t// follow the rule 2, if not equal, then we can add to new dp state\\n                        if(pp != val) {\\n                            dp_next[val_idx][nei_idx] = (dp_next[val_idx][nei_idx] + dp[nei_idx][pp_idx] ) %mod;\\n                        }\\n                    }\\n                }\\n            }\\n            swap(dp, dp_next);\\n            // reset val\\n            for(int i=0; i< 6; i++) {\\n                for(int j=0; j <6; j++) {\\n                    dp_next[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n\\t\\t// for each current val\\n        for(int i=0; i < 6; i++) {\\n\\t\\t\\t// result of each current val is sumed up by previous val.\\n            for(int j=0; j < 6; j++) {\\n                res = (res + dp[i][j]) % mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n# What I learn \\nI learn how to quickly identify the dp problem. \\n1. Keywords like \" The number  of distinct sequences/ total possible number of xxx \"\\n2. \" the maximum or the minimum \" \\n\\nI learn what kind of data structures to use to represent what kind of dp status we need to keep to get the correct answer.\\n\\ndp[i][j] may depend on previous one step state or previous two step state.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        // dp [i][j] means how many distinct sequences we can get\\n\\t\\t// for i th roll with the value j as roll result\\n\\t\\tvector<vector<int>> dp(n+1, vector<int>(7,0));\\n        \\n\\t\\t// initialize \\n\\t\\t// at the start , number of distinct sequences we can get \\n\\t\\t// is just one for 1-6 value\\n        for(int i=1; i <= 6; i++) {\\n            dp[0][i] = 1;\\n           \\n        }\\n        int mod = 1000000007;\\n\\t\\t// all possible adjacent value for dice value 1-6 \\n\\t\\t// to follow the rule 1 \\n        vector<vector<int>> roll_adj_count = {{2,3,4,5,6}, {1,3,5}, {1,2,4,5}, {1,3,5}, {1,2,3,4,6}, {1,5}};\\n\\t\\t// start iterating for each round of roll\\n        for(int roll_idx =1; roll_idx < n; roll_idx++) {\\n            // each round we can get 6 possible values(1-6)\\n\\t\\t\\t// count results for each possible value \\n\\t\\t\\tfor(int val=1; val <= 6; val++) {\\n\\t\\t\\t\\t\\n                int roll_adj_idx = val -1;\\n                auto& nei = roll_adj_count[roll_adj_idx];\\n                // iterate all possible adjacent values for current value \\n\\t\\t\\t\\tfor(int nei_num: nei) {\\n\\t\\t\\t\\t\\t// dp[roll_idx][val] depends on dp[roll_idx-1][all possible nei number]\\n                    dp[roll_idx][val]+= dp[roll_idx-1][nei_num];\\n                    // I don\\'t know why this is wrong\\n\\t\\t\\t\\t\\t// My explanation would be\\n\\t\\t\\t\\t\\t// we need to follow the rule 2 \\n\\t\\t\\t\\t\\t// and subtract the previous 2 value from the current one \\n\\t\\t\\t\\t\\t// does not neccessarily brings us the correct answer\\n\\t\\t\\t\\t\\t//  I still don\\'t know why this doesn\\'t work,\\n\\t\\t\\t\\t\\t// I will just leave it here .\\n\\t\\t\\t\\t\\t int nei_idx = nei_num -1;\\n                    auto &nei_nei  = roll_adj_count[nei_idx];\\n                    if(roll_idx >= 2) {\\n                        for(int nei_nei_val: nei_nei) {\\n\\t\\t\\t\\t\\t\\t\\t// the number of distinct sequence \\n\\t\\t\\t\\t\\t\\t\\t// of previous val of current val \\n\\t\\t\\t\\t\\t\\t\\t// may depends on previous 2 val \\n\\t\\t\\t\\t\\t\\t\\t// so we try to subtract thouse values.\\n                            if(nei_nei_val == val) {\\n                                dp[roll_idx][val] -= dp[roll_idx-2][val];\\n                            }\\n                        }\\n                        \\n                        \\n                    }   \\n                    dp[roll_idx][val] %= mod;\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int val=1; val <=6; val++) {\\n            res += dp[n-1][val];\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\n\\n```\n```\\nfor all legal pre_val //(follow the rule 1, gcd(pre_val, cur_val) == 1 )\\n\\tfor all legal pre2_val // (follow the rule 2, pre2_val != cur_val)\\n\\t\\tdp[cur_val][pre_val]  =  dp[cur_val][pre_val] + dp[pre_val][pre2_val]\\n\\n\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int distinctSequences(int n) {\\n        int mod = 1000000007;\\n\\t\\t// valid adjacent val for each roll value 1-6\\n        vector<vector<int>> roll_adj_count = {{2,3,4,5,6}, {1,3,5}, {1,2,4,5}, {1,3,5}, {1,2,3,4,6}, {1,5}};\\n        \\n\\t\\t// initial dp states\\n        vector<vector<int>> dp = {{0,1,1,1,1,1}, {1,0,1,0,1,0}, {1,1,0,1,1,0}, {1,0,1,0,1,0}, {1,1,1,1,0,1}, {1,0,0,0,1,0}};\\n        \\n\\t\\t// new dp state for cur_val \\n        vector<vector<int>> dp_next(6, vector<int>(6,0));\\n        if(n == 1) {\\n            return 6;\\n        }\\n\\t\\t// for each roll \\n        for(int i=3; i <= n ;i++ ){\\n\\t\\t\\t// for each possible roll \\n            for(int val=1; val <=6; val++) {\\n                int val_idx = val-1;\\n                auto& neis = roll_adj_count[val_idx];\\n                \\n\\t\\t\\t\\t// for each legal previous roll \\n                for(int nei_val: neis) {\\n                    int nei_idx = nei_val -1;\\n\\t\\t\\t\\t\\t// for each legal one more previous roll \\n                    for(int pp=1; pp <= 6; pp++) {\\n                        int pp_idx = pp-1;\\n\\t\\t\\t\\t\\t\\t// follow the rule 2, if not equal, then we can add to new dp state\\n                        if(pp != val) {\\n                            dp_next[val_idx][nei_idx] = (dp_next[val_idx][nei_idx] + dp[nei_idx][pp_idx] ) %mod;\\n                        }\\n                    }\\n                }\\n            }\\n            swap(dp, dp_next);\\n            // reset val\\n            for(int i=0; i< 6; i++) {\\n                for(int j=0; j <6; j++) {\\n                    dp_next[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n\\t\\t// for each current val\\n        for(int i=0; i < 6; i++) {\\n\\t\\t\\t// result of each current val is sumed up by previous val.\\n            for(int j=0; j < 6; j++) {\\n                res = (res + dp[i][j]) % mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200360,
                "title": "c-dp-striver-dp-trick-dp-memoization-simple-code",
                "content": "**Upvote if you liked it!**\\n\\n\\nWe can keep three variables:\\n* \\tcurrent index = n = used to keep track of the dice count\\n* \\tprevious value = p = needed as we need to ensure the gcd of current value we are choosing and the previous value is 1\\n* \\tprevious to previous value = pp = (as per the second constraint)\\n\\nGCD Table is hard-coded to avoid compution time for GCD. For each number in the dice, there are 7 values. 1st value - No of next possible number, rest 6 values, ```1``` if the value is possible else ```0``` .\\n\\n```\\nclass Solution {\\npublic:\\n    int modd = 1e9 + 7;\\n    \\n    int f(vector<string>& dice, vector<vector<vector<int>>>& dp, int n, int pp, int p){\\n        if(n == 0){\\n            return 1;\\n        }\\n        \\n        if(dp[n][pp][p] != 0)\\n            return dp[n][pp][p];\\n        \\n        int count = 0;\\n        for(int i = 1; i < 7; ++i){\\n            if(i != pp && i != p && (p == 0 || dice[p][i] == \\'1\\')){\\n                count = (count + f(dice, dp, n - 1, p, i) % modd) % modd;\\n            }\\n        }\\n        \\n        return dp[n][pp][p] = count ;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        if(n == 1)\\n            return 6;\\n\\n        vector<string> dice = {\"\", \"5011111\",\"3101010\",\"4110110\",\"3101010\",\"5111101\",\"2100010\"};\\n        \\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(7, vector<int>(7, 0)));\\n            \\n        return f(dice, dp, n, 0, 0);\\n    }\\n};\\n```\\n\\nTime Complexity:\\nThe time complexity is equal to the number of states required * time for each state, the number of states is equal to N * 6 * 6 and for each such states, there is a loop of size 6. Hence the total number of operations will be N * 6 * 6 * 6. Therefore the time complexity is equal to O(N).",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```1```\n```0```\n```\\nclass Solution {\\npublic:\\n    int modd = 1e9 + 7;\\n    \\n    int f(vector<string>& dice, vector<vector<vector<int>>>& dp, int n, int pp, int p){\\n        if(n == 0){\\n            return 1;\\n        }\\n        \\n        if(dp[n][pp][p] != 0)\\n            return dp[n][pp][p];\\n        \\n        int count = 0;\\n        for(int i = 1; i < 7; ++i){\\n            if(i != pp && i != p && (p == 0 || dice[p][i] == \\'1\\')){\\n                count = (count + f(dice, dp, n - 1, p, i) % modd) % modd;\\n            }\\n        }\\n        \\n        return dp[n][pp][p] = count ;\\n    }\\n    \\n    int distinctSequences(int n) {\\n        if(n == 1)\\n            return 6;\\n\\n        vector<string> dice = {\"\", \"5011111\",\"3101010\",\"4110110\",\"3101010\",\"5111101\",\"2100010\"};\\n        \\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(7, vector<int>(7, 0)));\\n            \\n        return f(dice, dp, n, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200210,
                "title": "100-faster-both-in-runtime-and-memory-space-memoization-solution",
                "content": "class Solution {\\npublic:\\n    long long mod=1e9+7;\\n    vector<vector<vector<int>>>dp;\\n    vector<int>dies={1,2,3,4,5,6};\\n    int helpans(int n,int prev,int prevprev,int i){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(prevprev!=-1 && prev!=-1 &&   dp[prevprev][prev][i]!=-1){\\n            return dp[prevprev][prev][i];\\n        }\\n        int res=0;\\n        for(auto x:dies){\\n            if(x==prev || x==prevprev || (prev!=-1 && __gcd(prev,x)!=1)){\\n                continue;\\n            }\\n           res=(res %mod +helpans(n,x,prev,i+1)%mod)%mod;\\n        }\\n        if(prevprev==-1 || prev==-1){\\n            return res;\\n        }\\n        return dp[prevprev][prev][i]= res;\\n    }\\n    int distinctSequences(int n) {\\n       dp=vector<vector<vector<int>>>(7,(vector<vector<int>>(7,vector<int>(n+1,-1))));\\n       return  helpans(n,-1,-1,0);   \\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    long long mod=1e9+7;\\n    vector<vector<vector<int>>>dp;\\n    vector<int>dies={1,2,3,4,5,6}",
                "codeTag": "Java"
            },
            {
                "id": 2200141,
                "title": "top-down-dp-with-explanation-100-faster-using-go",
                "content": "```\\n// This map tells us about not allowed values\\n// This is used for to check 1st condition\\n// For example: if current value is 2 then previous value should not be 4 or 6\\n// (2,4), (2,6), (3,6), (4,2), (4,6), (6,2), (6,3), (6,4) are not allowed\\nvar notAllowedValues = map[int][]int{\\n  2 : []int{4,6},\\n  3 : []int{6},\\n  4: []int{2,6},\\n  6: []int{2,3,4},\\n}\\n\\nconst module  = 1000000007  //109 + 7\\nfunc distinctSequences(n int) int {\\n  dp := make([][][]int,n+1)\\n  // dp[n][8][8]\\n  for i:=0;i<len(dp);i++{\\n    dp[i] = make([][]int,8)\\n  }\\n  // dp[i][j][k] -> Number of Distinct Roll Sequences when N is i and last two rools are j,k\\n  for i:=0;i<len(dp);i++{\\n    for j:=0;j<len(dp[i]);j++{\\n      dp[i][j] = make([]int,8)\\n    }\\n  }\\n  for i:=0;i<len(dp);i++{\\n    for j:=0;j<8;j++{\\n      for k:=0;k<8;k++{\\n        dp[i][j][k] = -1\\n      } \\n    }\\n  }\\n  // intially there are no rolls, so we are starting from -1,-1\\n  return  getRoll(n,-1,-1,&dp)\\n}\\n\\n\\nfunc getRoll(n int,prev1,prev2 int,dp *[][][]int)int {\\n  // When n == 0, it means no more roll is left and a sequence is completed\\n  if n == 0 {\\n    return 1\\n  }\\n  if (*dp)[n][prev1+1][prev2+1]!= - 1{\\n    return (*dp)[n][prev1+1][prev2+1]\\n  }\\n\\n  count:=0\\n  // Loop from 1 to 6 and check the two conditions are valid or not\\n  for i:=1;i<7;i++{\\n    // 1. the current roll should not be equal to previous two roll\\n    // 2. greatest common divisor of current and previous roll is equal to 1\\n    if prev1 == i || prev2 == i || !isAllowed(i,prev2) {\\n      continue\\n    }\\n    newCount := getRoll(n-1,prev2,i,dp)%module\\n    count= (count + newCount)%module\\n  }\\n  (*dp)[n][prev1+1][prev2+1] = (count%module)\\n  return (*dp)[n][prev1+1][prev2+1]\\n  \\n}\\n\\n// If true, it means i roll is not allowed\\nfunc isAllowed(i,prev int)bool {\\n  for _, val := range notAllowedValues[i]{\\n    if val == prev {\\n      return false\\n    } \\n  }\\n  return true\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\n// This map tells us about not allowed values\\n// This is used for to check 1st condition\\n// For example: if current value is 2 then previous value should not be 4 or 6\\n// (2,4), (2,6), (3,6), (4,2), (4,6), (6,2), (6,3), (6,4) are not allowed\\nvar notAllowedValues = map[int][]int{\\n  2 : []int{4,6},\\n  3 : []int{6},\\n  4: []int{2,6},\\n  6: []int{2,3,4},\\n}\\n\\nconst module  = 1000000007  //109 + 7\\nfunc distinctSequences(n int) int {\\n  dp := make([][][]int,n+1)\\n  // dp[n][8][8]\\n  for i:=0;i<len(dp);i++{\\n    dp[i] = make([][]int,8)\\n  }\\n  // dp[i][j][k] -> Number of Distinct Roll Sequences when N is i and last two rools are j,k\\n  for i:=0;i<len(dp);i++{\\n    for j:=0;j<len(dp[i]);j++{\\n      dp[i][j] = make([]int,8)\\n    }\\n  }\\n  for i:=0;i<len(dp);i++{\\n    for j:=0;j<8;j++{\\n      for k:=0;k<8;k++{\\n        dp[i][j][k] = -1\\n      } \\n    }\\n  }\\n  // intially there are no rolls, so we are starting from -1,-1\\n  return  getRoll(n,-1,-1,&dp)\\n}\\n\\n\\nfunc getRoll(n int,prev1,prev2 int,dp *[][][]int)int {\\n  // When n == 0, it means no more roll is left and a sequence is completed\\n  if n == 0 {\\n    return 1\\n  }\\n  if (*dp)[n][prev1+1][prev2+1]!= - 1{\\n    return (*dp)[n][prev1+1][prev2+1]\\n  }\\n\\n  count:=0\\n  // Loop from 1 to 6 and check the two conditions are valid or not\\n  for i:=1;i<7;i++{\\n    // 1. the current roll should not be equal to previous two roll\\n    // 2. greatest common divisor of current and previous roll is equal to 1\\n    if prev1 == i || prev2 == i || !isAllowed(i,prev2) {\\n      continue\\n    }\\n    newCount := getRoll(n-1,prev2,i,dp)%module\\n    count= (count + newCount)%module\\n  }\\n  (*dp)[n][prev1+1][prev2+1] = (count%module)\\n  return (*dp)[n][prev1+1][prev2+1]\\n  \\n}\\n\\n// If true, it means i roll is not allowed\\nfunc isAllowed(i,prev int)bool {\\n  for _, val := range notAllowedValues[i]{\\n    if val == prev {\\n      return false\\n    } \\n  }\\n  return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200063,
                "title": "python-go-accelerated-dp-out-of-tle-o-n",
                "content": "*Python* solution w/ bottom-up in 5482ms ~~beat 100% :)~~\\n\\n```python\\ndef distinctSequences(self, n):\\n    X, Y = collections.defaultdict(int), {(-1, i): 1 for i in range(6)}\\n    A = [[j != k and math.gcd(j, k) == 1 for k in range(1, 7)] for j in range(1, 7)]\\n    for _ in range(n):\\n        for i, j in X:\\n            for k in range(6):\\n                if i != k and A[j][k]:\\n                    Y[j, k] += X[i, j]\\n        X, Y = Y, collections.defaultdict(int)\\n    return sum(X.values()) % (10 ** 9 + 7)\\n```\\n\\n*Python* solution w/ linear recurrence in math `@617280219` in 113ms :)\\n\\n```python\\ndef distinctSequences(self, n):\\n    A, C = [22, 66, 184, 516, 1472, 4136, 11672], [24, 18, 32, 15, 12]\\n    if n == 1: return 6\\n    for _ in range(n - 2): A[:-1], A[-1] = A[1:], sum(a * c for a, c in zip(A, C)) % (10 ** 9 + 7)\\n    return A[0]\\n```\\n\\n*Go* solution w/ bottom-up in 1127ms ~~beat 100% :)~~\\n\\n```go\\nfunc distinctSequences(n int) int {\\n\\tvar (\\n\\t\\tres int64\\n\\t\\tmod = int64(1000000007)\\n\\t\\tA   = [6][6]bool{[6]bool{false, true, true, true, true, true},\\n\\t\\t\\t[6]bool{true, false, true, false, true, false},\\n\\t\\t\\t[6]bool{true, true, false, true, true, false},\\n\\t\\t\\t[6]bool{true, false, true, false, true, false},\\n\\t\\t\\t[6]bool{true, true, true, true, false, true},\\n\\t\\t\\t[6]bool{true, false, false, false, true, false}}\\n\\t\\tX = make(map[[2]int]int64)\\n\\t\\tY = make(map[[2]int]int64)\\n\\t)\\n\\tfor i := 0; i < 6; i++ {\\n\\t\\tY[[2]int{-1, i}] = 1\\n\\t}\\n\\tfor m := 0; m < n; m++ {\\n\\t\\tfor x := range X {\\n\\t\\t\\ti, j := x[0], x[1]\\n\\t\\t\\tfor k := 0; k < 6; k++ {\\n\\t\\t\\t\\tif i != k && A[j][k] {\\n\\t\\t\\t\\t\\ty := [2]int{j, k}\\n\\t\\t\\t\\t\\tif val, ok := Y[y]; ok {\\n\\t\\t\\t\\t\\t\\tY[y] = (val + X[x]) % mod\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tY[y] = X[x]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tX, Y = Y, make(map[[2]int]int64)\\n\\t}\\n\\tfor _, val := range X {\\n\\t\\tres = (res + val) % mod\\n\\t}\\n\\treturn int(res)\\n}\\n```\\n\\n*Go* solution w/ linear recurrence in 2ms :)\\n\\n```go\\nfunc distinctSequences(n int) int {\\n\\tvar a, b, c, d, e, f, g int64\\n\\ta, b, c, d, e, f, g = 22, 66, 184, 516, 1472, 4136, 11672\\n\\tif n == 1 {\\n\\t\\treturn 6\\n\\t}\\n\\tfor i := 2; i < n; i++ {\\n\\t\\ta, b, c, d, e, f, g = b, c, d, e, f, g, (24*a+18*b+32*c+15*d+12*e)%(1000000007)\\n\\t}\\n\\treturn int(a)\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndef distinctSequences(self, n):\\n    X, Y = collections.defaultdict(int), {(-1, i): 1 for i in range(6)}\\n    A = [[j != k and math.gcd(j, k) == 1 for k in range(1, 7)] for j in range(1, 7)]\\n    for _ in range(n):\\n        for i, j in X:\\n            for k in range(6):\\n                if i != k and A[j][k]:\\n                    Y[j, k] += X[i, j]\\n        X, Y = Y, collections.defaultdict(int)\\n    return sum(X.values()) % (10 ** 9 + 7)\\n```\n```python\\ndef distinctSequences(self, n):\\n    A, C = [22, 66, 184, 516, 1472, 4136, 11672], [24, 18, 32, 15, 12]\\n    if n == 1: return 6\\n    for _ in range(n - 2): A[:-1], A[-1] = A[1:], sum(a * c for a, c in zip(A, C)) % (10 ** 9 + 7)\\n    return A[0]\\n```\n```go\\nfunc distinctSequences(n int) int {\\n\\tvar (\\n\\t\\tres int64\\n\\t\\tmod = int64(1000000007)\\n\\t\\tA   = [6][6]bool{[6]bool{false, true, true, true, true, true},\\n\\t\\t\\t[6]bool{true, false, true, false, true, false},\\n\\t\\t\\t[6]bool{true, true, false, true, true, false},\\n\\t\\t\\t[6]bool{true, false, true, false, true, false},\\n\\t\\t\\t[6]bool{true, true, true, true, false, true},\\n\\t\\t\\t[6]bool{true, false, false, false, true, false}}\\n\\t\\tX = make(map[[2]int]int64)\\n\\t\\tY = make(map[[2]int]int64)\\n\\t)\\n\\tfor i := 0; i < 6; i++ {\\n\\t\\tY[[2]int{-1, i}] = 1\\n\\t}\\n\\tfor m := 0; m < n; m++ {\\n\\t\\tfor x := range X {\\n\\t\\t\\ti, j := x[0], x[1]\\n\\t\\t\\tfor k := 0; k < 6; k++ {\\n\\t\\t\\t\\tif i != k && A[j][k] {\\n\\t\\t\\t\\t\\ty := [2]int{j, k}\\n\\t\\t\\t\\t\\tif val, ok := Y[y]; ok {\\n\\t\\t\\t\\t\\t\\tY[y] = (val + X[x]) % mod\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tY[y] = X[x]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tX, Y = Y, make(map[[2]int]int64)\\n\\t}\\n\\tfor _, val := range X {\\n\\t\\tres = (res + val) % mod\\n\\t}\\n\\treturn int(res)\\n}\\n```\n```go\\nfunc distinctSequences(n int) int {\\n\\tvar a, b, c, d, e, f, g int64\\n\\ta, b, c, d, e, f, g = 22, 66, 184, 516, 1472, 4136, 11672\\n\\tif n == 1 {\\n\\t\\treturn 6\\n\\t}\\n\\tfor i := 2; i < n; i++ {\\n\\t\\ta, b, c, d, e, f, g = b, c, d, e, f, g, (24*a+18*b+32*c+15*d+12*e)%(1000000007)\\n\\t}\\n\\treturn int(a)\\n}\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 2038230,
                "content": [
                    {
                        "username": "unordered_set",
                        "content": "First!!"
                    }
                ]
            }
        ]
    }
]