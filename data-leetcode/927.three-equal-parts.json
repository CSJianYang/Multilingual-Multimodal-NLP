[
    {
        "title": "Three Equal Parts",
        "question_content": "You are given an array arr which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value.\nIf it is possible, return any [i, j] with i + 1 < j, such that:\n\n\tarr[0], arr[1], ..., arr[i] is the first part,\n\tarr[i + 1], arr[i + 2], ..., arr[j - 1] is the second part, and\n\tarr[j], arr[j + 1], ..., arr[arr.length - 1] is the third part.\n\tAll three parts have equal binary values.\n\nIf it is not possible, return [-1, -1].\nNote that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.\n&nbsp;\nExample 1:\nInput: arr = [1,0,1,0,1]\nOutput: [0,3]\nExample 2:\nInput: arr = [1,1,0,1,1]\nOutput: [-1,-1]\nExample 3:\nInput: arr = [1,1,0,0,1]\nOutput: [0,2]\n&nbsp;\nConstraints:\n\n\t3 <= arr.length <= 3 * 104\n\tarr[i] is 0 or 1",
        "solutions": [
            {
                "id": 183922,
                "title": "c-o-n-time-o-1-space-12-ms-with-explanation-comments",
                "content": "Algorithm:\\n\\t1) Count no. of 1\\'s in the given array, say ```countNumberOfOnes```.\\n\\t2) If no 1 is found ie. ```countNumberOfOnes == 0```, just return ```{0,size-1}```\\n\\t3) If ``` countNumberOfOnes % 3 != 0``` , then we cannot partition the given array for sure. This is because, there is no way to put equal no. of 1\\'s in any partition and hence, we will get different binary representations.\\n\\t4) Let\\'s try to find if there is a valid partition possible now. We find the first 1 in the given array and represent it\\'s position by ```start```.\\n\\t5) Also, we know that each partition must have ``` countNumberOfOnes/3 ``` (for same reason as given in step 3). Therefore, after finding the first 1, leave  ```k = countNumberOfOnes/3 ``` 1\\'s for the first partition.\\n\\t6) Assign this position as ```mid``` that denotes the beginning of a possible second partition.\\n\\t7) Further leave ```k = countNumberOfOnes/3 ``` 1\\'s for this partition and assign the beginning of last partition as ```end```\\n\\t8) Now, all we need to do is verify whether all the partitions have same values in them. This can be done by iterating through to the end of the array.\\n\\t9) If ```end``` doesn\\'t reach the end of the array, we find a mismatch and hence, we need to return ```{-1, -1}```\\n\\t10) Otherwise, we have found our partition, return ```{start-1,mid}```\\n\\nTime Complexity: ```O(n)```\\nSpace Complexity: ```O(1)```\\n\\n```\\nstatic int x=[](){ios::sync_with_stdio(false); cin.tie(NULL); return 0;}();\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n        if(countNumberOfOnes == 0)      \\n            return {0, A.size()-1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // find the first 1 in the array\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1)\\n                break;\\n        int start = i;\\n        \\n        // find (k+1)th 1 in the array\\n        int count1 = 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == k + 1)\\n                break;\\n        }\\n        int mid = i;\\n        \\n        //find (2*k +1)th 1 in the array\\n        count1= 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == 2*k + 1)\\n                break;\\n        }\\n        int end = i;\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end])\\n        {\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n\\n```\\nCode written during contest, may be optimized further. :-)",
                "solutionTags": [],
                "code": "```countNumberOfOnes```\n```countNumberOfOnes == 0```\n```{0,size-1}```\n``` countNumberOfOnes % 3 != 0```\n```start```\n``` countNumberOfOnes/3 ```\n```k = countNumberOfOnes/3 ```\n```mid```\n```k = countNumberOfOnes/3 ```\n```end```\n```end```\n```{-1, -1}```\n```{start-1,mid}```\n```O(n)```\n```O(1)```\n```\\nstatic int x=[](){ios::sync_with_stdio(false); cin.tie(NULL); return 0;}();\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n        if(countNumberOfOnes == 0)      \\n            return {0, A.size()-1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // find the first 1 in the array\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1)\\n                break;\\n        int start = i;\\n        \\n        // find (k+1)th 1 in the array\\n        int count1 = 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == k + 1)\\n                break;\\n        }\\n        int mid = i;\\n        \\n        //find (2*k +1)th 1 in the array\\n        count1= 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == 2*k + 1)\\n                break;\\n        }\\n        int end = i;\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end])\\n        {\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 223886,
                "title": "java-o-n-simple-solution-don-t-know-why-official-solution-is-that-long",
                "content": "Key obseration is that three parts must have same number and pattern of 1s except the leading part.  My idea is to:\\n\\n1. count how many ones  (if num%3!=0 return [-1,-1])\\n2. search from right side to left, until we found num/3 1s.  This index is not final answer, but it defines patten of 1s\\n3. from feft, ignore leading 0s, and then match the pattern found in step 2, to get the first EndIndex\\n4. do another matching to found second EndIndex\\n\\n\\n```\\npublic int[] threeEqualParts(int[] A) {\\n\\t\\tint numOne = 0;\\n\\t\\tfor (int i: A){\\n\\t\\t\\tif (i==1) numOne++;\\n\\t\\t}\\n        \\n        int[] noRes = {-1, -1};\\n        if (numOne == 0) return new int[]{0,2};\\n        if (numOne%3 != 0) return noRes;\\n        \\n        //find index of starting 1 of third string\\n        int idxThird=0;\\n\\t\\tint temp = 0;\\n        for (int i = A.length-1; i>=0; i--){\\n            if (A[i]==1){\\n                temp++;\\n                if (temp == numOne / 3){\\n                    idxThird = i;\\n                    break;\\n                }\\n            } \\n        }\\n        \\n        int res1 = findEndIdx(A, 0, idxThird);\\n        if (res1<0) return noRes;\\n        \\n        int res2 = findEndIdx(A, res1+1, idxThird);\\n        if (res2<0) return noRes;\\n        \\n        return new int[]{res1, res2+1};\\n    }\\n    \\n\\t//right is the pattern to compare to.  \\n\\t//return EndIdx of left pattern that matches right side.\\n    private int findEndIdx(int[] A, int left, int right){\\n        while (A[left]==0) left++;\\n        while (right < A.length){\\n            if (A[left]!=A[right]) return -1;\\n            left++;\\n            right++;            \\n        }\\n        return left-1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] threeEqualParts(int[] A) {\\n\\t\\tint numOne = 0;\\n\\t\\tfor (int i: A){\\n\\t\\t\\tif (i==1) numOne++;\\n\\t\\t}\\n        \\n        int[] noRes = {-1, -1};\\n        if (numOne == 0) return new int[]{0,2};\\n        if (numOne%3 != 0) return noRes;\\n        \\n        //find index of starting 1 of third string\\n        int idxThird=0;\\n\\t\\tint temp = 0;\\n        for (int i = A.length-1; i>=0; i--){\\n            if (A[i]==1){\\n                temp++;\\n                if (temp == numOne / 3){\\n                    idxThird = i;\\n                    break;\\n                }\\n            } \\n        }\\n        \\n        int res1 = findEndIdx(A, 0, idxThird);\\n        if (res1<0) return noRes;\\n        \\n        int res2 = findEndIdx(A, res1+1, idxThird);\\n        if (res2<0) return noRes;\\n        \\n        return new int[]{res1, res2+1};\\n    }\\n    \\n\\t//right is the pattern to compare to.  \\n\\t//return EndIdx of left pattern that matches right side.\\n    private int findEndIdx(int[] A, int left, int right){\\n        while (A[left]==0) left++;\\n        while (right < A.length){\\n            if (A[left]!=A[right]) return -1;\\n            left++;\\n            right++;            \\n        }\\n        return left-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343665,
                "title": "python-o-n-fast-solution-explained",
                "content": "In this problem we need to split number into three parts, such that number in each part after removed all zeroes are equal.\\n1. Let us check all the places, where we have `1.` Let us have `m` elements such that.\\n2. If `m == 0`, it means that we have all zeroes, so we can split in any way, let us split it `[0, 2]`.\\n3. If `m` is not divisible by `3`, we can return `[-1, -1]` immedietly, because if we can have three equal parts, number of ones in these parts must be the same.\\n4. Let us find now `6` indexes: `p1, p2, p3, p4, p5, p6`, where `p1` is index of first `1`, `p2` is index of last one in first part, `p3` is index of fisrt one in second part, and so on. Then it is necessary that `A[p1:p2+1]` equal to `A[p3:p4+1]` equal to `A[p5:p6+1]`. Note that is is not sufficient though, because we can add some zeroes in the ends. So, if this condition do not holds, we return `[-1, -1]`.\\n5. Evaluate lengths of how many zeros we can add in the end: `l1, l2, l3`. For `l3` we do not have any choice: we need to take all there zeroes. For `l1` and `l2` we can put zeroes in the beginning of one number or to the end of the next, so the options we have are: `[0, ..., l1]` for the first, `[0, ..., l2]` for the second and `[l3]` for third. So, if `l3 > l2` or `l3 > l1`, we can not make parts equal and we return `[-1, -1]`.\\n6. In the end return `[p2 + l3, p4 + l3 + 1]`, in this way in each part we have `l3` zeroes in the end.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(n)` as well to keep array of indexes.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        n = len(A)\\n        indexes = [i for i in range(n) if A[i] == 1]\\n        m = len(indexes)\\n        \\n        if m == 0: return [0, 2]\\n        \\n        if m % 3 != 0: return [-1, -1]\\n        p1, p2 = indexes[0], indexes[m//3-1]\\n        p3, p4 = indexes[m//3], indexes[2*m//3-1]\\n        p5, p6 = indexes[2*m//3], indexes[-1]\\n        part1, part2, part3 = A[p1:p2+1], A[p3:p4+1], A[p5:p6+1]\\n        \\n        if part1 != part2 or part2 != part3: return [-1, -1]\\n        \\n        l1 = p3 - p2 - 1\\n        l2 = p5 - p4 - 1\\n        l3 = n - p6 - 1\\n        \\n        if l3 > l2 or l3 > l1: return [-1, -1]\\n        \\n        return [p2 + l3, p4 + l3 + 1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        n = len(A)\\n        indexes = [i for i in range(n) if A[i] == 1]\\n        m = len(indexes)\\n        \\n        if m == 0: return [0, 2]\\n        \\n        if m % 3 != 0: return [-1, -1]\\n        p1, p2 = indexes[0], indexes[m//3-1]\\n        p3, p4 = indexes[m//3], indexes[2*m//3-1]\\n        p5, p6 = indexes[2*m//3], indexes[-1]\\n        part1, part2, part3 = A[p1:p2+1], A[p3:p4+1], A[p5:p6+1]\\n        \\n        if part1 != part2 or part2 != part3: return [-1, -1]\\n        \\n        l1 = p3 - p2 - 1\\n        l2 = p5 - p4 - 1\\n        l3 = n - p6 - 1\\n        \\n        if l3 > l2 or l3 > l1: return [-1, -1]\\n        \\n        return [p2 + l3, p4 + l3 + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250203,
                "title": "logical-thinking",
                "content": "> What is \\'same binary value\\' like? \\n> Digits following first 1 in each part should be identical. \\n\\n> How could we decide which 1 is the first 1 of a divided part?\\n> \\n> Assuming `numOnes` is number of 1s in A, each part should be with `numOnesPerPart = numOnes / 3` 1s. \\n> So the first \\'1\\' in  left part is `1`st \\'1\\', first \\'1\\' in middle part is `numOnesPerPart + 1`th \\'1\\', first \\'1\\' in right part is `numOnesPerPart * 2 + 1`th \\'1\\'.\\n>\\n> Then we compare the rest part digit by digit. Hopefully, the pointer in right part will reach A.length, which means we can make three equal parts.\\n> \\n>There is a corner case such as all elements in A are 0s.\\n****\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        int numOnes = countOnes(A);\\n        if (numOnes % 3 != 0) return new int[]{-1, -1};\\n        else {\\n            int numOnesPerPart = numOnes / 3;\\n            \\n            // Set pointers at first one in each part.\\n            int leftPtr = locateOne(A, 1), midPtr = locateOne(A, numOnesPerPart + 1), rightPtr = locateOne(A, numOnesPerPart * 2 + 1);\\n            \\n            // Compare 3 parts digit by digit.\\n            while (leftPtr < midPtr && midPtr < rightPtr && rightPtr < A.length) {\\n                if (A[leftPtr] == A[midPtr] && A[rightPtr] == A[midPtr]) {\\n                    leftPtr++;\\n                    midPtr++;\\n                    rightPtr++;\\n                } else break;\\n            }\\n            \\n            if (rightPtr == A.length) return new int[]{leftPtr - 1, midPtr};\\n            else if (rightPtr == 0) return new int[]{0, A.length - 1};\\n            else return new int[]{-1, -1};\\n        }\\n    }\\n    \\n    private int countOnes(int[] A) {\\n        int numOnes = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                numOnes++;\\n            }\\n        }\\n        return numOnes;        \\n    }\\n    \\n    private int locateOne(int[] A, int targetOne) {\\n        int cntOne = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                cntOne++;\\n                if (cntOne == targetOne) return i;\\n            }\\n        }\\n        return 0; // When all elements in A are 0.\\n    }\\n}\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        int numOnes = countOnes(A);\\n        if (numOnes % 3 != 0) return new int[]{-1, -1};\\n        else {\\n            int numOnesPerPart = numOnes / 3;\\n            \\n            // Set pointers at first one in each part.\\n            int leftPtr = locateOne(A, 1), midPtr = locateOne(A, numOnesPerPart + 1), rightPtr = locateOne(A, numOnesPerPart * 2 + 1);\\n            \\n            // Compare 3 parts digit by digit.\\n            while (leftPtr < midPtr && midPtr < rightPtr && rightPtr < A.length) {\\n                if (A[leftPtr] == A[midPtr] && A[rightPtr] == A[midPtr]) {\\n                    leftPtr++;\\n                    midPtr++;\\n                    rightPtr++;\\n                } else break;\\n            }\\n            \\n            if (rightPtr == A.length) return new int[]{leftPtr - 1, midPtr};\\n            else if (rightPtr == 0) return new int[]{0, A.length - 1};\\n            else return new int[]{-1, -1};\\n        }\\n    }\\n    \\n    private int countOnes(int[] A) {\\n        int numOnes = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                numOnes++;\\n            }\\n        }\\n        return numOnes;        \\n    }\\n    \\n    private int locateOne(int[] A, int targetOne) {\\n        int cntOne = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                cntOne++;\\n                if (cntOne == targetOne) return i;\\n            }\\n        }\\n        return 0; // When all elements in A are 0.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343092,
                "title": "three-equal-parts-c-easy-solution-with-approach",
                "content": "# **APPROACH**\\n1. Store every 1\\'s position in a vector.\\n2. It is easy to know the first 1\\'s position of three parts as [x, y, z].\\n3. Then verify three parts whether equal\\n\\n***NOTE:***\\n* If in cases where number of ones are not a multiple of 3, there will be no case of equal parts so return {-1,-1}\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int n = arr.size() ;\\n        vector<int> one ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(arr[i])\\n            {\\n                one.push_back(i) ;\\n            }\\n        }\\n        int cnt = one.size() ;\\n        if(cnt == 0)\\n        {\\n            return {0 , n - 1} ;\\n        }\\n        if(cnt%3)          //IF NUMBER OF ONES IS NOT A MULTIPLE OF 3\\n        {\\n            return {-1 , -1} ;\\n        }\\n        int s = one[0] , t = one[cnt/3] , u = one[(cnt/3)*2] ;\\n        while(u < n && arr[s] == arr[t] && arr[s] == arr[u])\\n        {\\n            s++ ;\\n            t++ ;\\n            u++ ;\\n        }\\n        if(u == n)\\n        {\\n            return {s - 1 , t} ;\\n        }\\n        return {-1 , -1} ;\\n    }\\n};\\n```\\n**Time Complexity:  O(n)**\\n**Space Complexity:  O(n)**\\n# **Update:**\\nThis is the general approach once we know that number of ones are a multiple of three -->\\nWe can form intervals for `s , t & u` let\\'s say, `[i1, j1], [i2, j2], [i3, j3]` \\n__If there is only 3 ones, then this interval length will be one__\\nSo the **zeroes after \"one, on the position of u\"** *let\\'s assume z* , must be included in each part (i.e. in s & t)\\nMaking the new intervals, `[i1, j1+z] & [i2, j2+z]` for s & t respectively\\nIf all this is actually possible, then the final answer is **[j1+z , j2+z+1].**\\nHope this helps",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int n = arr.size() ;\\n        vector<int> one ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(arr[i])\\n            {\\n                one.push_back(i) ;\\n            }\\n        }\\n        int cnt = one.size() ;\\n        if(cnt == 0)\\n        {\\n            return {0 , n - 1} ;\\n        }\\n        if(cnt%3)          //IF NUMBER OF ONES IS NOT A MULTIPLE OF 3\\n        {\\n            return {-1 , -1} ;\\n        }\\n        int s = one[0] , t = one[cnt/3] , u = one[(cnt/3)*2] ;\\n        while(u < n && arr[s] == arr[t] && arr[s] == arr[u])\\n        {\\n            s++ ;\\n            t++ ;\\n            u++ ;\\n        }\\n        if(u == n)\\n        {\\n            return {s - 1 , t} ;\\n        }\\n        return {-1 , -1} ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344101,
                "title": "c-o-n-commented-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        \\n        int ones = 0;\\n        int n  = arr.size();\\n        \\n        for(int i : arr){\\n            if(i==1)\\n                ones++;\\n        }\\n        \\n        //if no ones\\n        if(ones == 0) return {0,n-1};\\n        //if irregular ones, that cannot be divided in 3 parts\\n        if(ones%3!=0) return {-1,-1};\\n        \\n        int k = ones/3;\\n        \\n        //we find the starting position of 3 parts since leading zeroes does not matter\\n        int firstOne = -1, secondOne = -1, thirdOne = -1;\\n        int cnt1 = 0, cnt2 = 0, cnt3 = 0;\\n        \\n        //Find first one\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1){\\n                firstOne = i;\\n                break;\\n            }\\n        }\\n        //Find second one\\n        for(int i=firstOne+1;i<n;i++){\\n            if(arr[i]==1) cnt2++;\\n            if(arr[i]==1 && cnt2==k){\\n                secondOne = i;\\n                break;\\n            }\\n        }\\n        //Find third one\\n        for(int i=secondOne+1;i<n;i++){\\n            if(arr[i]==1) cnt3++;\\n            if(arr[i]==1 && cnt3==k){\\n                thirdOne = i;\\n                break;\\n            }\\n        }\\n        \\n        //checking if they are equal\\n        int x = firstOne, y = secondOne, z = thirdOne;\\n        while(x<n && y<n && z<n){\\n            if(arr[x] == arr[y] && arr[y] == arr[z]){\\n                x++;y++;z++;\\n            }\\n            else\\n                return {-1,-1};\\n        }\\n        \\n        //after the while loop we\\'ll have the\\n        //    |      |\\n        //  1 | 0 1  | 0 1\\n        //    |      |\\n        //      ^      ^    ^\\n        //      |      |    |\\n        //      x      y    z\\n\\n        return {x-1,y};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        \\n        int ones = 0;\\n        int n  = arr.size();\\n        \\n        for(int i : arr){\\n            if(i==1)\\n                ones++;\\n        }\\n        \\n        //if no ones\\n        if(ones == 0) return {0,n-1};\\n        //if irregular ones, that cannot be divided in 3 parts\\n        if(ones%3!=0) return {-1,-1};\\n        \\n        int k = ones/3;\\n        \\n        //we find the starting position of 3 parts since leading zeroes does not matter\\n        int firstOne = -1, secondOne = -1, thirdOne = -1;\\n        int cnt1 = 0, cnt2 = 0, cnt3 = 0;\\n        \\n        //Find first one\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1){\\n                firstOne = i;\\n                break;\\n            }\\n        }\\n        //Find second one\\n        for(int i=firstOne+1;i<n;i++){\\n            if(arr[i]==1) cnt2++;\\n            if(arr[i]==1 && cnt2==k){\\n                secondOne = i;\\n                break;\\n            }\\n        }\\n        //Find third one\\n        for(int i=secondOne+1;i<n;i++){\\n            if(arr[i]==1) cnt3++;\\n            if(arr[i]==1 && cnt3==k){\\n                thirdOne = i;\\n                break;\\n            }\\n        }\\n        \\n        //checking if they are equal\\n        int x = firstOne, y = secondOne, z = thirdOne;\\n        while(x<n && y<n && z<n){\\n            if(arr[x] == arr[y] && arr[y] == arr[z]){\\n                x++;y++;z++;\\n            }\\n            else\\n                return {-1,-1};\\n        }\\n        \\n        //after the while loop we\\'ll have the\\n        //    |      |\\n        //  1 | 0 1  | 0 1\\n        //    |      |\\n        //      ^      ^    ^\\n        //      |      |    |\\n        //      x      y    z\\n\\n        return {x-1,y};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677626,
                "title": "python-o-n-straightforward-solution",
                "content": "The solution is inspired by this [Logical Thinking](https://leetcode.com/problems/three-equal-parts/discuss/250203/Logical-Thinking).\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        \\n        num_ones = sum(A)\\n        \\n        if num_ones == 0:\\n            return [0, 2]\\n        \\n        if num_ones % 3 != 0:\\n            return [-1, -1]\\n        \\n        c = 0\\n        s1 = s2 = s3 = -1\\n        for idx,x in enumerate(A):\\n\\t\\t\\t# Find the first 1 in each part\\n            if x == 1:\\n                c += 1\\n            \\n            if c == 1 and s1 < 0:\\n                s1 = idx\\n                \\n            if c == num_ones//3 + 1 and s2 < 0:\\n                s2 = idx\\n                \\n            if c == num_ones*2//3 + 1 and s3 < 0:\\n                s3 = idx\\n                break\\n                \\n        n = len(A[s3:]) # The length of each part when all the leading 0\\'s are removed\\n        \\n        if A[s1:s1+n] == A[s2:s2+n] and A[s2:s2+n] == A[s3:]:\\n            return [s1+n-1, s2+n]\\n        else:\\n            return [-1, -1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        \\n        num_ones = sum(A)\\n        \\n        if num_ones == 0:\\n            return [0, 2]\\n        \\n        if num_ones % 3 != 0:\\n            return [-1, -1]\\n        \\n        c = 0\\n        s1 = s2 = s3 = -1\\n        for idx,x in enumerate(A):\\n\\t\\t\\t# Find the first 1 in each part\\n            if x == 1:\\n                c += 1\\n            \\n            if c == 1 and s1 < 0:\\n                s1 = idx\\n                \\n            if c == num_ones//3 + 1 and s2 < 0:\\n                s2 = idx\\n                \\n            if c == num_ones*2//3 + 1 and s3 < 0:\\n                s3 = idx\\n                break\\n                \\n        n = len(A[s3:]) # The length of each part when all the leading 0\\'s are removed\\n        \\n        if A[s1:s1+n] == A[s2:s2+n] and A[s2:s2+n] == A[s3:]:\\n            return [s1+n-1, s2+n]\\n        else:\\n            return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183991,
                "title": "c-o-n-time-o-n-space-40ms-14-lines-2-loops-easy-understand-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        vector<int> dp;\\n        for(int i = 0 ; i < A.size(); i++) // this loop is used to store the index of all 1s\\n            if(A[i]) dp.push_back(i);\\n        if(dp.size() % 3) return {-1, -1}; // if the number of 1s cannot be devided perfectly by 3, the input is invalid\\n\\tif(dp.empty()) return {0,2}; // if the number of 1 is zero, then it is natually valid, return {0, 2}\\n        int l1 = 0, l2 = dp.size() / 3, l3 = l2 * 2; //if we want to devide into 3 parts, the distribution pattern of 1s in three parts should be the same\\n        for(int i = 1; i < l2; i++ ) {\\n            int diff = dp[i] - dp[i-1];\\n            if(dp[l2+i] - dp[l2+i-1] != diff || dp[l3+i] - dp[l3+i-1] != diff) //unmatched pattern\\n                return {-1, -1};\\n\\t}\\n        int tail0 = A.size() - dp.back(); // calculate how many 0s tail\\n        if(dp[l3] - dp[l3-1] < tail0 ||   dp[l2] - dp[l2-1] < tail0) return {-1,-1};// all three parts should tail with the same number of 0s with that in the last part\\n        return {dp[l2-1] + tail0 - 1, dp[l3-1] + tail0};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        vector<int> dp;\\n        for(int i = 0 ; i < A.size(); i++) // this loop is used to store the index of all 1s\\n            if(A[i]) dp.push_back(i);\\n        if(dp.size() % 3) return {-1, -1}; // if the number of 1s cannot be devided perfectly by 3, the input is invalid\\n\\tif(dp.empty()) return {0,2}; // if the number of 1 is zero, then it is natually valid, return {0, 2}\\n        int l1 = 0, l2 = dp.size() / 3, l3 = l2 * 2; //if we want to devide into 3 parts, the distribution pattern of 1s in three parts should be the same\\n        for(int i = 1; i < l2; i++ ) {\\n            int diff = dp[i] - dp[i-1];\\n            if(dp[l2+i] - dp[l2+i-1] != diff || dp[l3+i] - dp[l3+i-1] != diff) //unmatched pattern\\n                return {-1, -1};\\n\\t}\\n        int tail0 = A.size() - dp.back(); // calculate how many 0s tail\\n        if(dp[l3] - dp[l3-1] < tail0 ||   dp[l2] - dp[l2-1] < tail0) return {-1,-1};// all three parts should tail with the same number of 0s with that in the last part\\n        return {dp[l2-1] + tail0 - 1, dp[l3-1] + tail0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184040,
                "title": "python-easy-understand-solution-with-explanation",
                "content": "The idea is pretty straight forward, you just need some obervation before coding.\\n1. If the solution exists, the number of 1 in list should be times of 3.\\n2. Since the ending zeros affect the binary value ([1,1] != [1,1, 0]) and the leading zeros mean nothing, we can find the value of each part (I called potential in the following code) if we scan the list from the end to the beginning.\\n3. After we find this number, things become easier. we just need to find the effective points of each part (I mean the position of first 1), we can locate the end of each part. Then the answer is just some calculation.\\n```\\ndef threeEqualParts(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        c1 = A.count(1)\\n        if c1%3: return [-1, -1]\\n        if c1 == 0: return [0, len(A)-1]\\n        n1 = c1/3\\n        potential = []\\n        count = 0\\n\\t\\t\\t\\t# find the value of each part\\n        for a in A[::-1]:\\n            potential.insert(0, a)\\n            if a == 1:\\n                count += 1\\n                if count == n1:\\n                    break\\n        lp = len(potential)\\n        temp = []\\n        i = 0\\n\\t\\t\\t\\t# find the effective beginning of each part\\n        while i < (len(A)-lp):\\n            if A[i] == 1 and A[i:i+lp] == potential:\\n                temp.append(i)\\n                i += lp\\n            elif A[i] == 0:\\n                i += 1\\n            else:\\n                return [-1, -1]\\n        ans = [temp[0]+lp-1, temp[1]+lp]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef threeEqualParts(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        c1 = A.count(1)\\n        if c1%3: return [-1, -1]\\n        if c1 == 0: return [0, len(A)-1]\\n        n1 = c1/3\\n        potential = []\\n        count = 0\\n\\t\\t\\t\\t# find the value of each part\\n        for a in A[::-1]:\\n            potential.insert(0, a)\\n            if a == 1:\\n                count += 1\\n                if count == n1:\\n                    break\\n        lp = len(potential)\\n        temp = []\\n        i = 0\\n\\t\\t\\t\\t# find the effective beginning of each part\\n        while i < (len(A)-lp):\\n            if A[i] == 1 and A[i:i+lp] == potential:\\n                temp.append(i)\\n                i += lp\\n            elif A[i] == 0:\\n                i += 1\\n            else:\\n                return [-1, -1]\\n        ans = [temp[0]+lp-1, temp[1]+lp]\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 183902,
                "title": "java-o-n-solution",
                "content": "```\n// The solution can be optimized to O(1) space, by not using StringBuilder, but only record the index of  the first one digit of the right part.\n\nclass Solution {\n    public int[] threeEqualParts(int[] A) {\n        if (A == null || A.length < 3) return new int[] {-1, -1};\n        int n = A.length;\n        int cntOneBit = 0;\n        \n        for (int b : A) {\n            if (b == 1) cntOneBit++;\n        }\n        if (cntOneBit % 3 != 0) return new int[] {-1, -1};\n        \n        int cnt = cntOneBit / 3;\n        if (cnt == 0) return new int[] {0, n - 1};\n    \n        //construct the string using the right most part;\n        int j = n - 1, cntR = 0;\n        StringBuilder suffix = new StringBuilder();\n        for (;j >= 0 && cntR < cnt; j--) {\n            suffix.append(A[j]);\n            if (A[j] == 1) cntR++;\n         } \n    \n        String target = suffix.reverse().toString();\n        \n        //matching the left part with target string, omit all leading zero\n        int i = 0;\n        while (A[i] == 0) i++;\n    \n        int k = 0;\n        while (k < target.length()) {\n            if (A[i + k] == target.charAt(k) - '0') k++;\n            else return new int[] {-1, -1};\n        }\n        int left = i + k -1;\n        \n        //matching the middle part with target string, omit all leading zero\n        i = i + k;\n        while (A[i] == 0) i++;\n        k = 0;\n        while (k < target.length()) {\n        if (A[i + k] == target.charAt(k) - '0') k++;\n            else return new int[] {-1, -1};\n        }    \n        return new int[] {left, i + k}; \n    }\n}",
                "solutionTags": [],
                "code": "class Solution {\n    public int[] threeEqualParts(int[] A) {\n        if (A == null || A.length < 3) return new int[] {-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 184580,
                "title": "java-10ms-solution-with-o-n-time-and-o-1-space",
                "content": "It is obviously that if the array can be divided into three part. The 1\\'s number in each should be same. Besides, the 0\\'s number in the last part should be the true 0\\'s number in the end of each part.\\nWe get the 1\\'s number and divide them into 3 parts. If numOf1 % 3 is not a integer then just return [-1, -1]. Suppose the number of 1 is 3n. The three parts should shart from the first 1, the n + 1th 1 and the 2n + 1th 1. Then we just compare all of them with the last part and can get the answer easily.\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        int[] res = new int[2];\\n        res[0] = -1;\\n        res[1] = -1;\\n        // num Of 1\\n        int numOf1 = 0;\\n        for (int a : A) {\\n            if (a == 1) {\\n                numOf1++;\\n            }\\n        }\\n        \\n        if (numOf1 == 0) {\\n            return new int[]{0, 2};\\n        }\\n        \\n        if (numOf1 % 3 != 0) {\\n            return res;\\n        }\\n        \\n        int partLength = numOf1 / 3;\\n        int index0 = -1;\\n        int index1 = -1;\\n        int index2 = -1;\\n        numOf1 = 0;\\n        for (int i = 0; i < A.length; i ++) {\\n            if (A[i] == 1) {\\n                numOf1++;\\n                if (numOf1 == partLength + 1) {\\n                    index1 = i;\\n                } else if (numOf1 == 2 * partLength + 1) {\\n                    index2 = i;\\n                } else if (numOf1 == 1) {\\n                    index0 = i;\\n                }\\n            }\\n        }\\n       \\n        while (index2 < A.length) {\\n            if (A[index2] == A[index0] && A[index2] == A[index1]) {\\n                index2++;\\n                index1++;\\n                index0++;\\n            } else {\\n                return res;\\n            }\\n        }\\n        \\n        return new int[]{index0 - 1, index1};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        int[] res = new int[2];\\n        res[0] = -1;\\n        res[1] = -1;\\n        // num Of 1\\n        int numOf1 = 0;\\n        for (int a : A) {\\n            if (a == 1) {\\n                numOf1++;\\n            }\\n        }\\n        \\n        if (numOf1 == 0) {\\n            return new int[]{0, 2};\\n        }\\n        \\n        if (numOf1 % 3 != 0) {\\n            return res;\\n        }\\n        \\n        int partLength = numOf1 / 3;\\n        int index0 = -1;\\n        int index1 = -1;\\n        int index2 = -1;\\n        numOf1 = 0;\\n        for (int i = 0; i < A.length; i ++) {\\n            if (A[i] == 1) {\\n                numOf1++;\\n                if (numOf1 == partLength + 1) {\\n                    index1 = i;\\n                } else if (numOf1 == 2 * partLength + 1) {\\n                    index2 = i;\\n                } else if (numOf1 == 1) {\\n                    index0 = i;\\n                }\\n            }\\n        }\\n       \\n        while (index2 < A.length) {\\n            if (A[index2] == A[index0] && A[index2] == A[index1]) {\\n                index2++;\\n                index1++;\\n                index0++;\\n            } else {\\n                return res;\\n            }\\n        }\\n        \\n        return new int[]{index0 - 1, index1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343709,
                "title": "2-clean-python-linear-solutions",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # count number of ones\\n        ones = sum(arr)\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        elif ones == 0:  # special case: all zeros\\n            return [0, 2]\\n        \\n        # find the start index of each group of ones\\n        c = 0\\n        starts = []\\n        for i, d in enumerate(arr):\\n            if d == 1:\\n                if c % (ones // 3) == 0:\\n                    starts.append(i)\\n                c += 1\\n\\n        # scan the groups in parallel to compare digits\\n        i, j, k = starts\\n        while k < len(arr):  # note that the last/rightmost group must include all digits till the end\\n            if arr[i] == arr[j] == arr[k]:\\n                i += 1\\n                j += 1\\n                k += 1\\n            else:\\n                return [-1, -1]\\n        return [i-1, j]\\n```\\nRuntime: *O(n)*\\nSpace: *O(1)*\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # gather the indices of the ones\\n        ones = [i for i, d in enumerate(arr) if d == 1]\\n\\n        if not ones:\\n            return [0, 2]\\n        elif len(ones) % 3 != 0:\\n            return [-1, -1]\\n\\n        # get the start indices of the 3 groups\\n        i, j, k = ones[0], ones[len(ones)//3], ones[len(ones)//3*2]\\n\\n        # calculate the size/length of what each group should be\\n        length = len(arr) - k  # note that the last/rightmost group must include all digits till the end\\n                               # so we know that the size of each group is `len(arr) - k` (where `k` is start of third group)\\n\\n        # compare the three groups\\n        if arr[i:i+length] == arr[j:j+length] == arr[k:k+length]:\\n            return [i+length-1, j+length]\\n        \\n        return [-1, -1]\\n```\\nRuntime: *O(n)*\\nSpace: *O(n)*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # count number of ones\\n        ones = sum(arr)\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        elif ones == 0:  # special case: all zeros\\n            return [0, 2]\\n        \\n        # find the start index of each group of ones\\n        c = 0\\n        starts = []\\n        for i, d in enumerate(arr):\\n            if d == 1:\\n                if c % (ones // 3) == 0:\\n                    starts.append(i)\\n                c += 1\\n\\n        # scan the groups in parallel to compare digits\\n        i, j, k = starts\\n        while k < len(arr):  # note that the last/rightmost group must include all digits till the end\\n            if arr[i] == arr[j] == arr[k]:\\n                i += 1\\n                j += 1\\n                k += 1\\n            else:\\n                return [-1, -1]\\n        return [i-1, j]\\n```\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # gather the indices of the ones\\n        ones = [i for i, d in enumerate(arr) if d == 1]\\n\\n        if not ones:\\n            return [0, 2]\\n        elif len(ones) % 3 != 0:\\n            return [-1, -1]\\n\\n        # get the start indices of the 3 groups\\n        i, j, k = ones[0], ones[len(ones)//3], ones[len(ones)//3*2]\\n\\n        # calculate the size/length of what each group should be\\n        length = len(arr) - k  # note that the last/rightmost group must include all digits till the end\\n                               # so we know that the size of each group is `len(arr) - k` (where `k` is start of third group)\\n\\n        # compare the three groups\\n        if arr[i:i+length] == arr[j:j+length] == arr[k:k+length]:\\n            return [i+length-1, j+length]\\n        \\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344503,
                "title": "three-equal-parts-java-easy-to-understand-detailed-approach",
                "content": "**Intuition**\\n* We can easily see that in order for the array to have equal parts, in each part the number of ones should be equal.\\n* The above implies that the `totalOnes` should be divisible by 3.\\n* Now lets understand of basic cases\\n* `totalOnes = 0`: If this is the case any two indices can divide into 3 equal parts since all will be zero\\n* `totalOnes%3 !=0 `: Since total ones is not divisble solution is not possible, so we return `[-1,-1]`\\n* Next we know that each part will have `k = totalOnes/3` ones. Also if we start from the end the target which we want for each part will start as soon as we have taken `k` ones. So we can keep track of this index from where target starts. ***Note***: This index might not be the index `j` as there can be leading zeroes which will not change the target.\\n* Now we have to find if its possible to build the same target from start to the end.\\n* Now to get the index `i` we can start from index `0` and move to the index of first `1` (What we do here is ignore leading zeroes). Now we start comparing elements from the target index and index i. If its equal then this part can be equal to target.\\n* We do the similar operation for the second part.\\n\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int totalOnes = 0;\\n        for(int e:arr){\\n            if(e==1){\\n                totalOnes++;\\n            }\\n        }\\n        \\n        int l = arr.length;\\n        if(totalOnes==0){\\n            return new int[] {0, l-1};\\n        }\\n        if(totalOnes%3!=0){\\n            return new int[] {-1,-1};\\n        }\\n        \\n        int k=totalOnes/3; // Each part will have k number of 1\\'s\\n        int targetIdx = l; // This first index of \\'1\\' which starts the equal part\\n        \\n        while(k>0){\\n            targetIdx--;\\n            if(arr[targetIdx]==1){\\n                k--;\\n            }\\n        }\\n        \\n        int i = isPartPossible(arr, 0, targetIdx);\\n        if(i==-1){\\n            return new int[] {-1,-1};\\n        }\\n        int j = isPartPossible(arr, i, targetIdx);\\n        if(j==-1){\\n            return new int[] {-1,-1};\\n        }\\n        \\n        return new int[] {i-1,j};\\n    }\\n    \\n    private int isPartPossible(int[] arr, int i, int start) {\\n        while(arr[i]==0){\\n            i++;\\n        }\\n        while(start<arr.length){\\n            if(arr[i]!=arr[start]) {\\n                return -1;\\n            }\\n            i++;\\n            start++;\\n        }\\n        return i;\\n    }\\n}\\n```\\n\\nPS: Please upvote if you think it can help others to understand this question.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int totalOnes = 0;\\n        for(int e:arr){\\n            if(e==1){\\n                totalOnes++;\\n            }\\n        }\\n        \\n        int l = arr.length;\\n        if(totalOnes==0){\\n            return new int[] {0, l-1};\\n        }\\n        if(totalOnes%3!=0){\\n            return new int[] {-1,-1};\\n        }\\n        \\n        int k=totalOnes/3; // Each part will have k number of 1\\'s\\n        int targetIdx = l; // This first index of \\'1\\' which starts the equal part\\n        \\n        while(k>0){\\n            targetIdx--;\\n            if(arr[targetIdx]==1){\\n                k--;\\n            }\\n        }\\n        \\n        int i = isPartPossible(arr, 0, targetIdx);\\n        if(i==-1){\\n            return new int[] {-1,-1};\\n        }\\n        int j = isPartPossible(arr, i, targetIdx);\\n        if(j==-1){\\n            return new int[] {-1,-1};\\n        }\\n        \\n        return new int[] {i-1,j};\\n    }\\n    \\n    private int isPartPossible(int[] arr, int i, int start) {\\n        while(arr[i]==0){\\n            i++;\\n        }\\n        while(start<arr.length){\\n            if(arr[i]!=arr[start]) {\\n                return -1;\\n            }\\n            i++;\\n            start++;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344636,
                "title": "c-easy-clean-solution",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& ar) {\\n        int cnt0 = 0, cnt1 = 0;\\n        for(auto i: ar){\\n            if(i)\\n                cnt1++;\\n            else\\n                cnt0++;\\n        }\\n        \\n        if(cnt1 % 3 != 0)\\n            return {-1, -1};\\n        else\\n        {\\n            if(cnt1 == 0){\\n                return {0, 2};\\n            }\\n            else{\\n                int k = cnt1 / 3;\\n                int one = 0, two = 0, three = 0;\\n                int cnt = 0;\\n                for(int i = 0; i < ar.size(); i++){\\n                    if(ar[i]){\\n                        if(cnt == 0)\\n                            one = i;\\n                        cnt++;\\n                        \\n                        if(cnt == k + 1)\\n                            two = i;\\n                        \\n                        if(cnt == 2 * k + 1){\\n                            three = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                //now we have 3 indices.......\\n                //check if each increment in the indices results in similar integer 0/1....\\n                \\n                while(1){\\n                    if(ar[one] != ar[two] or ar[two] != ar[three] or three == ar.size())\\n                        break;\\n                    \\n                    one++;\\n                    two++;\\n                    three++;\\n                }\\n                \\n                if(three == ar.size())\\n                    return {one - 1, two};\\n                else\\n                    return {-1, -1};\\n            }     \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& ar) {\\n        int cnt0 = 0, cnt1 = 0;\\n        for(auto i: ar){\\n            if(i)\\n                cnt1++;\\n            else\\n                cnt0++;\\n        }\\n        \\n        if(cnt1 % 3 != 0)\\n            return {-1, -1};\\n        else\\n        {\\n            if(cnt1 == 0){\\n                return {0, 2};\\n            }\\n            else{\\n                int k = cnt1 / 3;\\n                int one = 0, two = 0, three = 0;\\n                int cnt = 0;\\n                for(int i = 0; i < ar.size(); i++){\\n                    if(ar[i]){\\n                        if(cnt == 0)\\n                            one = i;\\n                        cnt++;\\n                        \\n                        if(cnt == k + 1)\\n                            two = i;\\n                        \\n                        if(cnt == 2 * k + 1){\\n                            three = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                //now we have 3 indices.......\\n                //check if each increment in the indices results in similar integer 0/1....\\n                \\n                while(1){\\n                    if(ar[one] != ar[two] or ar[two] != ar[three] or three == ar.size())\\n                        break;\\n                    \\n                    one++;\\n                    two++;\\n                    three++;\\n                }\\n                \\n                if(three == ar.size())\\n                    return {one - 1, two};\\n                else\\n                    return {-1, -1};\\n            }     \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343907,
                "title": "java-solution-with-detailed-comments-examples",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ones = 0;\\n        for (int i : arr) if (i == 1) ones++;\\n\\n\\t\\t/**\\n\\t\\t * The first base case is a hardcoded case when there are only zeros in the array. \\n\\t\\t * Since the array size is at least 3 in the case of only zeros there are still available to cut the array and get three equal binary numbers. \\n\\t\\t * e.g. [0, 0, 0] we can devide into three parts |0, 0, 0| and those numbers are correct binary numbers. \\n\\t\\t * e.g. [0, 0, 0, 0, 0, ...] we can devide into three parts |0, 0, 0...| and those numbers are correct binary numbers. \\n\\t\\t\\n\\t\\t * arr = [0, 0, 0, 0, 0, ...]\\n\\t\\t * ind = [0, 1, 2, 3, 4]\\n         * i = 0 and j = 2 because first part is 0 - 0(0, i) indexes, second part is 1 - 1(i + 1, j - 1) indexes and third part is 2 - 2(j, n - 1) indexes\\n\\t\\t\\n\\t\\t * So taking into consideration above answer [0, 2] is the first correct answer that we can get in the case of only zeros. \\n\\t\\t*/\\n        if (ones == 0) return new int[]{0, 2};\\n\\t\\t\\n\\t\\t/**\\n\\t\\t * If there are ones in an array they should be dividable on 3. \\n\\t\\t * This is because we need to divide the array into three parts \\n\\t\\t * and each part should have the same amount of ones \\n\\t\\t * in the case of binary numbers to be equal\\n\\t\\t*/\\n        if (ones % 3 != 0) return new int[]{-1, -1};\\n\\n\\t\\t/**\\n\\t\\t* This is the most trickier part of this solution.\\n\\t\\t*  Basically what we are doing here is we are looking for the first occurrence of \\'1\\' for each chunk. \\n\\t\\t*  Let\\'s take an example: arr = [0, 1, 1, 0, | 0, 0, 1, 1, 0, | 1, 1, 0]\\n\\n\\t\\t* Since the count of ones is 6 and 6 / 3 = 2 it means that after every +2 index we are standing on the next chunk. 0 +, 2 +, 4 + ... \\n\\t\\t* Therefore:  \\n\\t\\t* First occurrence of \\'1\\' for the first chunk is on the index of 1\\n\\t\\t* First occurrence of \\'1\\' for the second chunk is on the index of 6\\n\\t\\t* First occurrence of \\'1\\' for the third chunk is on the index of 9\\n\\t\\t*/\\n        int point1 = 0, point2 = 0, point3 = 0;\\n        int unit = ones / 3;\\n        int oneCounter = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 1) {\\n                if (oneCounter == 0) point1 = i;\\n                else if (oneCounter == unit) point2 = i;\\n                else if (oneCounter == 2 * unit) point3 = i;\\n\\n                oneCounter++;\\n            }\\n        }\\n\\n\\t\\t/**\\n\\t\\t* The last part is pretty straightforward. \\n\\t\\t* We just need to start all pointers from the first occurrences of \\'1\\' and move three of them simultaneously to the right. \\n\\t\\t* As we know binary numbers are equals if all of their bits are equal. Otherwise we return {-1, -1}\\n\\t\\t*/\\n        while (point3 < arr.length) {\\n            if (arr[point1] != arr[point2] || arr[point2] != arr[point3]) return new int[]{-1, -1};\\n\\n            point1++;\\n            point2++;\\n            point3++;\\n        }\\n\\n        return new int[]{point1 - 1, point2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ones = 0;\\n        for (int i : arr) if (i == 1) ones++;\\n\\n\\t\\t/**\\n\\t\\t * The first base case is a hardcoded case when there are only zeros in the array. \\n\\t\\t * Since the array size is at least 3 in the case of only zeros there are still available to cut the array and get three equal binary numbers. \\n\\t\\t * e.g. [0, 0, 0] we can devide into three parts |0, 0, 0| and those numbers are correct binary numbers. \\n\\t\\t * e.g. [0, 0, 0, 0, 0, ...] we can devide into three parts |0, 0, 0...| and those numbers are correct binary numbers. \\n\\t\\t\\n\\t\\t * arr = [0, 0, 0, 0, 0, ...]\\n\\t\\t * ind = [0, 1, 2, 3, 4]\\n         * i = 0 and j = 2 because first part is 0 - 0(0, i) indexes, second part is 1 - 1(i + 1, j - 1) indexes and third part is 2 - 2(j, n - 1) indexes\\n\\t\\t\\n\\t\\t * So taking into consideration above answer [0, 2] is the first correct answer that we can get in the case of only zeros. \\n\\t\\t*/\\n        if (ones == 0) return new int[]{0, 2};\\n\\t\\t\\n\\t\\t/**\\n\\t\\t * If there are ones in an array they should be dividable on 3. \\n\\t\\t * This is because we need to divide the array into three parts \\n\\t\\t * and each part should have the same amount of ones \\n\\t\\t * in the case of binary numbers to be equal\\n\\t\\t*/\\n        if (ones % 3 != 0) return new int[]{-1, -1};\\n\\n\\t\\t/**\\n\\t\\t* This is the most trickier part of this solution.\\n\\t\\t*  Basically what we are doing here is we are looking for the first occurrence of \\'1\\' for each chunk. \\n\\t\\t*  Let\\'s take an example: arr = [0, 1, 1, 0, | 0, 0, 1, 1, 0, | 1, 1, 0]\\n\\n\\t\\t* Since the count of ones is 6 and 6 / 3 = 2 it means that after every +2 index we are standing on the next chunk. 0 +, 2 +, 4 + ... \\n\\t\\t* Therefore:  \\n\\t\\t* First occurrence of \\'1\\' for the first chunk is on the index of 1\\n\\t\\t* First occurrence of \\'1\\' for the second chunk is on the index of 6\\n\\t\\t* First occurrence of \\'1\\' for the third chunk is on the index of 9\\n\\t\\t*/\\n        int point1 = 0, point2 = 0, point3 = 0;\\n        int unit = ones / 3;\\n        int oneCounter = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 1) {\\n                if (oneCounter == 0) point1 = i;\\n                else if (oneCounter == unit) point2 = i;\\n                else if (oneCounter == 2 * unit) point3 = i;\\n\\n                oneCounter++;\\n            }\\n        }\\n\\n\\t\\t/**\\n\\t\\t* The last part is pretty straightforward. \\n\\t\\t* We just need to start all pointers from the first occurrences of \\'1\\' and move three of them simultaneously to the right. \\n\\t\\t* As we know binary numbers are equals if all of their bits are equal. Otherwise we return {-1, -1}\\n\\t\\t*/\\n        while (point3 < arr.length) {\\n            if (arr[point1] != arr[point2] || arr[point2] != arr[point3]) return new int[]{-1, -1};\\n\\n            point1++;\\n            point2++;\\n            point3++;\\n        }\\n\\n        return new int[]{point1 - 1, point2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343256,
                "title": "12-lines-js-solution-faster-than-100-js-solutions",
                "content": "First I found out how many ones are in the array. Then I checked if the array is dividable into 3 with the same amount of ones. Then I iterated from the end to find out the number. Once I had the number all I had to do is to validate if the sequence of first and second sets match.\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar threeEqualParts = function(arr) {\\n  const ones = arr.reduce((s, n) => s + n, 0);\\n  if (ones === 0) return [0, 2];\\n  if (ones % 3 !== 0) return [-1, -1];\\n  let onesToFind = ones / 3;\\n  let k = arr.length;\\n  while (onesToFind > 0) if (arr[--k] === 1) --onesToFind;\\n  const iter = arr.length - k;\\n  const firstOne = arr.indexOf(1);\\n  const secondOne = arr.indexOf(1, firstOne + iter);\\n  for (let i = 0; i < iter; i++)\\n    if (arr[i + firstOne] !== arr[k + i] || arr[i + secondOne] !== arr[k + i]) return [-1, -1];\\n  return [firstOne + iter - 1, secondOne + iter];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar threeEqualParts = function(arr) {\\n  const ones = arr.reduce((s, n) => s + n, 0);\\n  if (ones === 0) return [0, 2];\\n  if (ones % 3 !== 0) return [-1, -1];\\n  let onesToFind = ones / 3;\\n  let k = arr.length;\\n  while (onesToFind > 0) if (arr[--k] === 1) --onesToFind;\\n  const iter = arr.length - k;\\n  const firstOne = arr.indexOf(1);\\n  const secondOne = arr.indexOf(1, firstOne + iter);\\n  for (let i = 0; i < iter; i++)\\n    if (arr[i + firstOne] !== arr[k + i] || arr[i + secondOne] !== arr[k + i]) return [-1, -1];\\n  return [firstOne + iter - 1, secondOne + iter];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 694521,
                "title": "c-o-n-time-o-n-space-easy-to-implement",
                "content": "Store every 1\\'s position, easy to know the first 1\\'s position of three parts as [x, y, z].\\nThen verify three parts whether equal.\\n\\n```\\nclass Solution {\\npublic:\\nvector<int> threeEqualParts(vector<int>& v) {\\n  int n = v.size();\\n  vector<int> ones;\\n  for (int i = 0; i < n; ++i) if (v[i]) ones.push_back(i);\\n  int cnt = ones.size();\\n  if (!cnt) return {0, n - 1};\\n  if (cnt % 3) return {-1, -1};\\n  int x = ones[0], y = ones[cnt/3], z = ones[cnt/3*2];\\n  while (z < n && v[x] == v[y] && v[x] == v[z]) ++x, ++y, ++z;\\n  if (z == n) return {x-1, y};\\n  return {-1, -1};\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> threeEqualParts(vector<int>& v) {\\n  int n = v.size();\\n  vector<int> ones;\\n  for (int i = 0; i < n; ++i) if (v[i]) ones.push_back(i);\\n  int cnt = ones.size();\\n  if (!cnt) return {0, n - 1};\\n  if (cnt % 3) return {-1, -1};\\n  int x = ones[0], y = ones[cnt/3], z = ones[cnt/3*2];\\n  while (z < n && v[x] == v[y] && v[x] == v[z]) ++x, ++y, ++z;\\n  if (z == n) return {x-1, y};\\n  return {-1, -1};\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183880,
                "title": "python-o-n-108ms",
                "content": "```\nclass Solution:\n    def threeEqualParts(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        N = len(A)\n        if N < 3:\n            return [-1, -1]\n        \n        num_ones = sum(A)\n\t\t\t\t\n        if num_ones % 3 != 0:\n            return [-1, -1]\n        \n        if num_ones == 0:\n            return [0, 2]\n        \n        need_ones = num_ones // 3\n        str_input_reverse = ''.join(map(str, reversed(A)))\n        count_1 = 0\n        i = 0\n        while count_1 != need_ones:\n            if str_input_reverse[i] == '1':\n                count_1 += 1\n            i += 1\n            \n        second = str_input_reverse.find(str_input_reverse[:i], i)\n        if(second == -1):\n            return [-1, -1]\n        third = str_input_reverse.find(str_input_reverse[:i], second + i)\n        if(third == -1):\n            return [-1, -1]\n        return [N - 1 - third, N - second]\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def threeEqualParts(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        N = len(A)\n        if N < 3:\n            return [-1, -1]\n        \n        num_ones = sum(A)\n\t\t\t\t\n        if num_ones % 3 != 0:\n            return [-1, -1]\n        \n        if num_ones == 0:\n            return [0, 2]\n        \n        need_ones = num_ones // 3\n        str_input_reverse = ''.join(map(str, reversed(A)))\n        count_1 = 0\n        i = 0\n        while count_1 != need_ones:\n            if str_input_reverse[i] == '1':\n                count_1 += 1\n            i += 1\n            \n        second = str_input_reverse.find(str_input_reverse[:i], i)\n        if(second == -1):\n            return [-1, -1]\n        third = str_input_reverse.find(str_input_reverse[:i], second + i)\n        if(third == -1):\n            return [-1, -1]\n        return [N - 1 - third, N - second]\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104349,
                "title": "c-detailed-explanation-with-proofs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNot much intuitive as it does not invole any famous algorithm but a bit of observation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First and the only thing to notice is that if we have to divide the array into three parts with equal value then ***each part must have equal number of 1 in them.***\\nTake your time :) \\nProof->\\nAs each number must have equal value which means in binary form (After removing leading zeros ) each of them must be equivalent in the position of their bits.\\nAnd for all of them to be equivalent , the sufficient condition will be for them to have the equal number of set bits \\'1\\' in them, we can\\'t take zeros \\'0\\' as it can form leading zeros which will then become unsignificant.\\n\\n- So calculate the total number of ones and check for it to be a multiple of three. There will be a special case for 0 number of ones ( See the code for it ).\\nIf it\\'s a multiple of three then, again traverse the array to get the starting point of all the individual parts as\\n**First part -> first \\'1\\' index\\nsecond part -> total_one/3+1 th \\'1\\' index\\nthird part -> total_one/3 + total_one/3 + 1 th \\'1\\' index.**\\n\\n- Now we have our starting indexes we just have to check if we could actually make them equivalent and for that we simply traverse in our third part till last and correspondingly check the indices in first part and second part.\\nIf we reach the end of array ,which means we have the corresponding indices of each part equal, so we could actually divide them and the remaining values will serve as leading zeros for individual parts.\\n\\n***See the code for more details or try to dry run on any test case for better understanding.***\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ Traversing the array three times.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size(),ones=count(arr.begin(),arr.end(),1);\\n        if(ones==0) return {0,n-1}; // if full array is of zeros\\n        if(ones%3) return {-1,-1};\\n\\n        ones=ones/3; // calculating the size of each block with equal ones.\\n\\n\\n        int curr_one=0,first=-1,second=-1,third=-1;\\n        for(int i=0;i<n;i++) {\\n            if(arr[i]==1) curr_one++;\\n\\n            if(curr_one==1 and first==-1) first=i;\\n            else if(curr_one==ones+1 and second==-1) second=i;\\n            else if(curr_one==2*ones+1 and third==-1) third=i;\\n        }\\n\\n        int i,j,k;\\n        for(i=first,j=second,k=third;k<n;i++,j++,k++) {\\n            if(not (arr[i]==arr[j] and arr[j]==arr[k])) return {-1,-1};\\n        }\\n        return {i-1,j};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size(),ones=count(arr.begin(),arr.end(),1);\\n        if(ones==0) return {0,n-1}; // if full array is of zeros\\n        if(ones%3) return {-1,-1};\\n\\n        ones=ones/3; // calculating the size of each block with equal ones.\\n\\n\\n        int curr_one=0,first=-1,second=-1,third=-1;\\n        for(int i=0;i<n;i++) {\\n            if(arr[i]==1) curr_one++;\\n\\n            if(curr_one==1 and first==-1) first=i;\\n            else if(curr_one==ones+1 and second==-1) second=i;\\n            else if(curr_one==2*ones+1 and third==-1) third=i;\\n        }\\n\\n        int i,j,k;\\n        for(i=first,j=second,k=third;k<n;i++,j++,k++) {\\n            if(not (arr[i]==arr[j] and arr[j]==arr[k])) return {-1,-1};\\n        }\\n        return {i-1,j};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344393,
                "title": "c-python-observation-leads-to-solutions-3-pointer-solution",
                "content": "Approach 1:\\nTrain of thought [1]:\\nStep 1: observation: Find 1st 1 of 3rd sub-array\\nStep 2: locate the ending of 1st and 2nd sub-arrays\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int tot = 0;\\n        for(auto num: A) tot += num;\\n        if(tot % 3 != 0) return {-1, -1};\\n        int n = A.size();\\n        if(tot == 0) return {0, n - 1};\\n        \\n        int seg3_beg_candidate = n - 1;\\n        for(int i = n - 1, cnt = 0; i >= 0; i--){\\n            if(A[i]==1){\\n                cnt++;\\n                if(cnt == tot / 3){\\n                    seg3_beg_candidate = i;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int seg1_end = findSegEnd(A, 0, seg3_beg_candidate);\\n        if(seg1_end == -1) return {-1, -1};\\n        int seg2_end = findSegEnd(A, seg1_end + 1, seg3_beg_candidate);\\n        if(seg2_end == -1) return {-1, -1};\\n        else return {seg1_end, seg2_end + 1};\\n    }\\n    \\nprivate:\\n    int findSegEnd(const vector<int>& A, int l, int r){\\n        while(A[l] == 0) l++;\\n        while(r < A.size()){\\n            if(A[l] != A[r]) return -1;\\n            l++; r++;\\n        }\\n        return l - 1;\\n    }\\n};\\n```\\n\\nApproach 2: 3-pointer [2]\\nThis might be the only 3-pointer type question out of  1009 questions solved by me.\\nThe solution is from [2] with clear step by step illustration.\\n```\\nstatic int x=[](){ios::sync_with_stdio(false); cin.tie(NULL); return 0;}();\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n\\t\\tint n = A.size();\\n        if(countNumberOfOnes == 0)      \\n            return {0, n -1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // find the first 1 in the array\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1)\\n                break;\\n        int start = i;\\n        \\n        // find (k+1)th 1 in the array\\n        int count1 = 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == k + 1)\\n                break;\\n        }\\n        int mid = i;\\n        \\n        //find (2*k +1)th 1 in the array\\n        count1= 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == 2*k + 1)\\n                break;\\n        }\\n        int end = i;\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end])\\n        {\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n```\\n\\nApproach 3: Compact version of Approach 2\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        int n = A.size();\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n        if(countNumberOfOnes == 0)      \\n            return {0, n -1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // start: the first 1 in the array\\n        // mid:   the (k+1)th 1 in the array\\n        // end:   the (2k+1)th 1 in the array\\n        int oneIdx = 0;\\n        int start, mid, end;\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1){\\n                ++oneIdx;\\n                if( oneIdx == 1) start = i;\\n                if( oneIdx == k + 1) mid = i;\\n                if( oneIdx == 2*k + 1) {end = i;break;}\\n            }\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end]){\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n```\\n\\nApproach 4: 8-line python [3]\\n```\\ndef threeEqualParts(self, nums: List[int]) -> List[int]:\\n\\tn = nums.count(1)\\n\\tif n == 0: return [0, 2] # any split would satify\\n\\tif n % 3 != 0: return [-1, -1]\\n\\tidx = [i for i, num in enumerate(nums) if num == 1]\\n\\ts1, e1, s2, e2, s3, e3 = idx[0], idx[n//3-1], idx[n//3], idx[2*n//3-1], idx[2*n//3], idx[n-1]\\n\\ttracingZeros = len(nums) - 1 - e3\\n\\tif e1 + tracingZeros >= s2 or e2 + tracingZeros >= s3 or not nums[s1: e1] == nums[s2: e2] == nums[s3: e3]: return [-1, -1]\\n\\treturn [e1 + tracingZeros, e2 + tracingZeros + 1]\\n\\n```\\nReference:\\n[1] https://www.cnblogs.com/grandyang/p/12107091.html\\n[2] https://leetcode.com/problems/three-equal-parts/discuss/183922/C%2B%2B-O(n)-time-O(1)-space-12-ms-with-explanation-and-comments\\n[3] https://leetcode.com/problems/three-equal-parts/discuss/677626/Python-O(n)-Straightforward-Solution\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int tot = 0;\\n        for(auto num: A) tot += num;\\n        if(tot % 3 != 0) return {-1, -1};\\n        int n = A.size();\\n        if(tot == 0) return {0, n - 1};\\n        \\n        int seg3_beg_candidate = n - 1;\\n        for(int i = n - 1, cnt = 0; i >= 0; i--){\\n            if(A[i]==1){\\n                cnt++;\\n                if(cnt == tot / 3){\\n                    seg3_beg_candidate = i;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int seg1_end = findSegEnd(A, 0, seg3_beg_candidate);\\n        if(seg1_end == -1) return {-1, -1};\\n        int seg2_end = findSegEnd(A, seg1_end + 1, seg3_beg_candidate);\\n        if(seg2_end == -1) return {-1, -1};\\n        else return {seg1_end, seg2_end + 1};\\n    }\\n    \\nprivate:\\n    int findSegEnd(const vector<int>& A, int l, int r){\\n        while(A[l] == 0) l++;\\n        while(r < A.size()){\\n            if(A[l] != A[r]) return -1;\\n            l++; r++;\\n        }\\n        return l - 1;\\n    }\\n};\\n```\n```\\nstatic int x=[](){ios::sync_with_stdio(false); cin.tie(NULL); return 0;}();\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n\\t\\tint n = A.size();\\n        if(countNumberOfOnes == 0)      \\n            return {0, n -1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // find the first 1 in the array\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1)\\n                break;\\n        int start = i;\\n        \\n        // find (k+1)th 1 in the array\\n        int count1 = 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == k + 1)\\n                break;\\n        }\\n        int mid = i;\\n        \\n        //find (2*k +1)th 1 in the array\\n        count1= 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == 2*k + 1)\\n                break;\\n        }\\n        int end = i;\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end])\\n        {\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        int n = A.size();\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n        if(countNumberOfOnes == 0)      \\n            return {0, n -1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // start: the first 1 in the array\\n        // mid:   the (k+1)th 1 in the array\\n        // end:   the (2k+1)th 1 in the array\\n        int oneIdx = 0;\\n        int start, mid, end;\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1){\\n                ++oneIdx;\\n                if( oneIdx == 1) start = i;\\n                if( oneIdx == k + 1) mid = i;\\n                if( oneIdx == 2*k + 1) {end = i;break;}\\n            }\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end]){\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n```\n```\\ndef threeEqualParts(self, nums: List[int]) -> List[int]:\\n\\tn = nums.count(1)\\n\\tif n == 0: return [0, 2] # any split would satify\\n\\tif n % 3 != 0: return [-1, -1]\\n\\tidx = [i for i, num in enumerate(nums) if num == 1]\\n\\ts1, e1, s2, e2, s3, e3 = idx[0], idx[n//3-1], idx[n//3], idx[2*n//3-1], idx[2*n//3], idx[n-1]\\n\\ttracingZeros = len(nums) - 1 - e3\\n\\tif e1 + tracingZeros >= s2 or e2 + tracingZeros >= s3 or not nums[s1: e1] == nums[s2: e2] == nums[s3: e3]: return [-1, -1]\\n\\treturn [e1 + tracingZeros, e2 + tracingZeros + 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672781,
                "title": "ruby-with-regexp",
                "content": "```\\ndef three_equal_parts(a)\\n  return [0, a.size-1] if a.all?(&:zero?)\\n  s = a.join\\n  tmp = s.match(/^0*(1.*)0*(\\\\1)0*(\\\\1)$/)[1]\\n  i = s.index(tmp) + tmp.size - 1\\n  j = s.index(tmp, i+1) + tmp.size\\n  [ i , j ]\\nrescue => e\\n  [-1, -1]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef three_equal_parts(a)\\n  return [0, a.size-1] if a.all?(&:zero?)\\n  s = a.join\\n  tmp = s.match(/^0*(1.*)0*(\\\\1)0*(\\\\1)$/)[1]\\n  i = s.index(tmp) + tmp.size - 1\\n  j = s.index(tmp, i+1) + tmp.size\\n  [ i , j ]\\nrescue => e\\n  [-1, -1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 183895,
                "title": "java-50ms-with-my-thinking-process",
                "content": "thinking process is chinese:https://www.jianshu.com/p/c8dbaaf87644\\n```\\npublic int[] threeEqualParts(int[] A) {\\n        int i = 0, j = A.length-1;\\n        Deque<Integer> pre = new ArrayDeque<>();\\n        Deque<Integer> mid = new ArrayDeque<>();\\n        Deque<Integer> last = new ArrayDeque<>();\\n        if(A[0]!=0) pre.offerLast(1);\\n        if(A[j]!=0) last.offerLast(1);\\n        for(int k = 1; k < j; k++){\\n            if(mid.isEmpty() && A[k] == 0) continue;\\n            mid.offerLast(A[k]);\\n        } \\n        while(i < j){\\n            int cp = compare(pre,last);\\n            if(cp<0){\\n                i++;\\n                if(A[i] == 0){\\n                    if(!pre.isEmpty()) pre.offerLast(0);\\n                } \\n                else{\\n                    if(mid.isEmpty()) break;\\n                    pre.offerLast(mid.pollFirst());\\n                    while(!mid.isEmpty() && mid.peekFirst()==0) mid.pollFirst();\\n                }\\n            }else if(cp>0){\\n                j--;\\n                if(mid.isEmpty()) break;\\n                if(A[j] == 0) mid.pollLast();\\n                else moveMidToLast(A,mid,last,j);\\n            }else{\\n                int cp2 = compare(mid,last);\\n                \\n                if(cp2 == 0) return new int[]{i,j};\\n                if(cp2<0) break;\\n                else{\\n                    j--;\\n                    if(mid.isEmpty()) break;\\n                    if(A[j] == 0) mid.pollLast();\\n                    else moveMidToLast(A,mid,last,j);\\n                }\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n    private void moveMidToLast(int[] A,Deque<Integer> mid,Deque<Integer> last,int j){\\n        int idx = j+1;\\n        while(idx<A.length && A[idx++]==0)\\n            last.offerFirst(0);\\n        last.offerFirst(mid.pollLast());\\n    }\\n    \\n    private int compare(Deque<Integer> a, Deque<Integer> b){\\n        if(a.size() < b.size()) return -1;\\n        if(a.size() == b.size()){\\n            Iterator<Integer> itr = a.iterator();\\n            Iterator<Integer> itr2 = b.iterator();\\n            while(itr.hasNext()){\\n                int fa = itr.next();\\n                int fb = itr2.next();\\n                if(fa == fb) continue;\\n                return fa-fb;\\n            }\\n\\n            return 0;\\n        }\\n        return 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] threeEqualParts(int[] A) {\\n        int i = 0, j = A.length-1;\\n        Deque<Integer> pre = new ArrayDeque<>();\\n        Deque<Integer> mid = new ArrayDeque<>();\\n        Deque<Integer> last = new ArrayDeque<>();\\n        if(A[0]!=0) pre.offerLast(1);\\n        if(A[j]!=0) last.offerLast(1);\\n        for(int k = 1; k < j; k++){\\n            if(mid.isEmpty() && A[k] == 0) continue;\\n            mid.offerLast(A[k]);\\n        } \\n        while(i < j){\\n            int cp = compare(pre,last);\\n            if(cp<0){\\n                i++;\\n                if(A[i] == 0){\\n                    if(!pre.isEmpty()) pre.offerLast(0);\\n                } \\n                else{\\n                    if(mid.isEmpty()) break;\\n                    pre.offerLast(mid.pollFirst());\\n                    while(!mid.isEmpty() && mid.peekFirst()==0) mid.pollFirst();\\n                }\\n            }else if(cp>0){\\n                j--;\\n                if(mid.isEmpty()) break;\\n                if(A[j] == 0) mid.pollLast();\\n                else moveMidToLast(A,mid,last,j);\\n            }else{\\n                int cp2 = compare(mid,last);\\n                \\n                if(cp2 == 0) return new int[]{i,j};\\n                if(cp2<0) break;\\n                else{\\n                    j--;\\n                    if(mid.isEmpty()) break;\\n                    if(A[j] == 0) mid.pollLast();\\n                    else moveMidToLast(A,mid,last,j);\\n                }\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n    private void moveMidToLast(int[] A,Deque<Integer> mid,Deque<Integer> last,int j){\\n        int idx = j+1;\\n        while(idx<A.length && A[idx++]==0)\\n            last.offerFirst(0);\\n        last.offerFirst(mid.pollLast());\\n    }\\n    \\n    private int compare(Deque<Integer> a, Deque<Integer> b){\\n        if(a.size() < b.size()) return -1;\\n        if(a.size() == b.size()){\\n            Iterator<Integer> itr = a.iterator();\\n            Iterator<Integer> itr2 = b.iterator();\\n            while(itr.hasNext()){\\n                int fa = itr.next();\\n                int fb = itr2.next();\\n                if(fa == fb) continue;\\n                return fa-fb;\\n            }\\n\\n            return 0;\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2529351,
                "title": "100-tc-easy-python-solution",
                "content": "Hint\\nCount the num of ones, and think how they will be split between the 3 segments :)\\n```\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n\\tn = len(arr)\\n\\tpos = [i for i in range(n) if(arr[i])]\\n\\tl = len(pos)\\n\\tif(l == 0):\\n\\t\\treturn [0, 2]\\n\\tif(l % 3):\\n\\t\\treturn [-1, -1]\\n\\tones = l//3\\n\\tc = 0\\n\\tfor i in arr[::-1]:\\n\\t\\tif(i == 1):\\n\\t\\t\\tbreak\\n\\t\\tc += 1\\n\\tans = [-1, -1]\\n\\t# one hoga pos[ones-1] tak\\n\\t# uske bad chaiye meko c zeros\\n\\t# toh index pos[ones-1] + c tak first segment ho jayega\\n\\tans[0] = pos[ones-1] + c\\n\\tans[1] = pos[2*ones-1] + c + 1\\n\\tseg1, seg2, seg3 = arr[pos[0]:ans[0]+1], arr[pos[ones]:ans[1]], arr[pos[2*ones]:]\\n\\t# without leading zeros\\n\\tif(seg1 != seg2 or seg1 != seg3):\\n\\t\\treturn [-1, -1]\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n\\tn = len(arr)\\n\\tpos = [i for i in range(n) if(arr[i])]\\n\\tl = len(pos)\\n\\tif(l == 0):\\n\\t\\treturn [0, 2]\\n\\tif(l % 3):\\n\\t\\treturn [-1, -1]\\n\\tones = l//3\\n\\tc = 0\\n\\tfor i in arr[::-1]:\\n\\t\\tif(i == 1):\\n\\t\\t\\tbreak\\n\\t\\tc += 1\\n\\tans = [-1, -1]\\n\\t# one hoga pos[ones-1] tak\\n\\t# uske bad chaiye meko c zeros\\n\\t# toh index pos[ones-1] + c tak first segment ho jayega\\n\\tans[0] = pos[ones-1] + c\\n\\tans[1] = pos[2*ones-1] + c + 1\\n\\tseg1, seg2, seg3 = arr[pos[0]:ans[0]+1], arr[pos[ones]:ans[1]], arr[pos[2*ones]:]\\n\\t# without leading zeros\\n\\tif(seg1 != seg2 or seg1 != seg3):\\n\\t\\treturn [-1, -1]\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1345370,
                "title": "three-pointers-c-o-n-time-o-1-space",
                "content": "**Approach:** First of all, it is necessary for the given array to have sufficient count of ones which can be equally divided among three groups. If not, the answer is not possible. If yes, find the occurances of the first ones of each group. Now, simply iterate over these pointers and check whether you can atleast reach to the starting index of other group. If so, return the indexes else answer is not possible. \\n**Time complexity:** O(N)\\n**Space complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> check(vector<int> s, int i, int j, int k) {\\n        int n=s.size();\\n        while(i<j && j<k && k<n) {\\n            if(s[i]!=s[j] || s[j]!=s[k]) return {-1,-1};\\n            if(i==j || j==k || k==n) break;\\n            i++;\\n            j++;\\n            k++;\\n        }\\n        if(i==j || j==k || k==n) return {i-1, j};\\n        return {-1,-1};\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size();\\n        int ctr=count(arr.begin(), arr.end(),1);\\n        if(ctr % 3 != 0) return {-1,-1};\\n        \\n        vector<int> ans(3,-1);\\n        int k=0, ref=0;\\n        for(int i=0;i<n;i++) { \\n            if(arr[i] && !ref) {\\n                ans[k++]=i;\\n            }\\n            if(arr[i]) ref++;\\n            \\n            if(ref==ctr/3) {\\n                ref=0;\\n            }\\n        }\\n        if(ans[0]==ans[1] && ans[1]==ans[2]) return {0, n-1};\\n        return check(arr, ans[0], ans[1], ans[2]);\\n    }\\n};\\n```\\n**Upvote if u liked!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> check(vector<int> s, int i, int j, int k) {\\n        int n=s.size();\\n        while(i<j && j<k && k<n) {\\n            if(s[i]!=s[j] || s[j]!=s[k]) return {-1,-1};\\n            if(i==j || j==k || k==n) break;\\n            i++;\\n            j++;\\n            k++;\\n        }\\n        if(i==j || j==k || k==n) return {i-1, j};\\n        return {-1,-1};\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size();\\n        int ctr=count(arr.begin(), arr.end(),1);\\n        if(ctr % 3 != 0) return {-1,-1};\\n        \\n        vector<int> ans(3,-1);\\n        int k=0, ref=0;\\n        for(int i=0;i<n;i++) { \\n            if(arr[i] && !ref) {\\n                ans[k++]=i;\\n            }\\n            if(arr[i]) ref++;\\n            \\n            if(ref==ctr/3) {\\n                ref=0;\\n            }\\n        }\\n        if(ans[0]==ans[1] && ans[1]==ans[2]) return {0, n-1};\\n        return check(arr, ans[0], ans[1], ans[2]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344658,
                "title": "easy-approach-using-prefix-sum-2-sum-no-one-is-talking-about-this",
                "content": "### Prefix Sum\\nNo post is talking about this apporach, and I came up with this when sleeping.\\nTypically, sum of subarray problem can be resovled using prefix sum array. So is this. Similarly, the `prefix[i]` represents the integer with the binary representation of `nums[:i]`, then `prefix[j] - prefix[i]` is the integer represented by `nums[i:j]`. \\n\\n```\\nprefix[i + 1] = prefix[i] << 1 + num[i]\\nprefix[j + 1] - prefix[i + 1] = prefix[j + 1] - (prefix[i] << j - i)\\n```\\n\\nIn order to find out 3 subarrays with the same integer, we just need find out `[i, j]` such that \\n\\n```prefix[i - 1] == prefix[j] - prefix[i] == prefix[-1] - prefix[j]```\\n\\nThe naive solution is to iterate each possible pair of `(i, j)`, but we can reduce it to linear using hashmap/dictionary. Recall the 2 sum problem!\\nWe iterate each *j* and store the index *i* of `prefix[i]` seen up to *j*, then if `prefix[-1] - prefix[j]` is in the hashmap, then return the pair. Finally, reutrn `[-1, -1]` otherwise.\\n\\n```python\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n\\tprefix = [0]\\n    for num in arr:\\n\\t\\tprefix.append((prefix[-1] << 1) + num)\\n        \\n\\tseen = {}\\n    n = len(arr)\\n    for j in range(n): \\n\\t\\tx = prefix[-1] - (prefix[j + 1] << n - 1 - j)\\n        if x in seen and prefix[j + 1] == (x << j + 1 - seen[x]) + x:\\n\\t\\t\\treturn [seen[x] - 1, j + 1]\\n        seen[prefix[j + 1]] = j + 1\\n\\treturn [-1, -1]     \\n        \\n```\\n*Time Complexity* = **O(N)**\\n*Space Complexity* = **O(N)**",
                "solutionTags": [],
                "code": "```\\nprefix[i + 1] = prefix[i] << 1 + num[i]\\nprefix[j + 1] - prefix[i + 1] = prefix[j + 1] - (prefix[i] << j - i)\\n```\n```prefix[i - 1] == prefix[j] - prefix[i] == prefix[-1] - prefix[j]```\n```python\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n\\tprefix = [0]\\n    for num in arr:\\n\\t\\tprefix.append((prefix[-1] << 1) + num)\\n        \\n\\tseen = {}\\n    n = len(arr)\\n    for j in range(n): \\n\\t\\tx = prefix[-1] - (prefix[j + 1] << n - 1 - j)\\n        if x in seen and prefix[j + 1] == (x << j + 1 - seen[x]) + x:\\n\\t\\t\\treturn [seen[x] - 1, j + 1]\\n        seen[prefix[j + 1]] = j + 1\\n\\treturn [-1, -1]     \\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344388,
                "title": "c-single-pass-solution-explained-100-time-90-space",
                "content": "Nice problem that becomes much easier once you figure out a few tricks:\\n* first of all, in order for the problem to be solvable, we need an amount of `1`s divisible by `3`;\\n* with this insight, we can figure out that while we move on checking for the amount of `1`s, we might as well keep track of pointers separating the currently explored portion of the array into `3` parts;\\n* to get this pointer in place, we might think of doing something similar to navigating a linked list with the hare-tortoise approach, just this time we would have `3` pointers (`s1`, `s2` and `i`, later in my code), proceeding at 1X, 2X and 3X speed respectively.\\n\\nFor example, if we started with `{0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0}`, we would initially find all 3 pointers set when we meet the third `1`, so, it would be:\\n\\n```cpp\\ns1 == 1;  // position of the first 1\\ns2 == 2;  // position of the second 1\\n i == 5;  // position of the third 1\\n```\\n\\nOnce we met the sixth `1` we have:\\n\\n```cpp\\ns1 == 2;  // position of the second 1\\ns2 == 6;  // position of  the fourth 1\\n i == 13; // position of the sixth 1\\n```\\n\\nAnd so on; with that in mind, then it becomes much easier to figure out the limits of a partition (the position of the last one will dictate the padding `0`s to all the others) and we can proceed from that.\\n\\nIn order to code it, we will use a few support variables:\\n* `tot` is out ongoing total, initialised to `0`;\\n* `lastElem` is the position of the last element, initialised to be `arr.size()` (for now, we will fix it in a moment!);\\n* `lmt` gives us the upper limit of how many positions for either `s1` or `s2` we are going to store, initalised to be `lastElem / 3` (ie: we will never have more positions than one third of the length, if even if all elements were to be `1`s);\\n* `s1`, `s2` and `last` will keep track of where we found the delimiting `1`s for each session discovered so far;\\n* `curr1` and `curr2` will be the positions of the `s1` and `s2` pointers we will be using, both set to `0` initially;\\n* `pos1` and `pos2`, specularly, will point to where we are going to store them in their respective arrays;\\n* `s1s` and `s2s` are the arrays that will store pointers to our dividing points as we go.\\n\\nDone with the variables, we can now fix `lastElem` to correctly be the index of the last element and loop with `i` through `arr`, and:\\n* we will check if the currenlty pointed element `arr[i]` is  a `1` and, if so:\\n\\t* increase `tot` by `1`;\\n\\t* store the current position in `s1s`, provided we did not do so already for `lmt` elements;\\n\\t* store the current position in `s2s`, provided we did not do so already for `lmt` elements and that we parsed so far an even number of `1`s;\\n\\t* it `tot` is divisible by `3`, we will then:\\n\\t\\t* update the `last`, `s1` and `s2` pointers to new values.\\n\\nWith this out of the way, time to parse for a few edge cases:\\n * if no `1`s were found (ie: `!tot`), we will then just `return` `{0, lastElem}` (I think why not any other pointer for the second element was not very clear in the description, but okay);\\n * if `tot` is not divisible by `3`, clearly we cannot form `3` parts with the same amount of `1`s, so we will `return` `{-1, -1}`.\\n \\nOne last condition to check is that the sections have exactly the same binary value and this is a bit trickier.\\n \\nTo do so, we will use a new variable `diff` computed as the difference between `last` and `lastElem` to get the amount of necessary padding `0`s.\\n \\n We will then:\\n * increase `s1` by `diff` and check if it is still below `s2`, otherwise we will `return` `{-1, -1}`;\\n * increase `s2` by `diff` and check if it is still below `last`, otherwise we will `return` `{-1, -1}`;\\n * set `curr1` to be `s1`, `curr2` to be `s2`, `last` to `lastElem` and `tot` to one third of its original value;\\n * we will loop while `tot > 0` and:\\n\\t * check if `curr1`, `curr2` and `last` point to the same value (either all point to a `0` or to a `1`), otherwise `return` `{-1, -1}`;\\n\\t * reduce `tot` by the currently pointed value by any of the pointers;\\n\\t * decrease all three pointers by `1`.\\n\\nYou might notice that even if any of the sections still had leading `0`s, in this way we would not care, stopping at the last `1` of each session - assuming no mismatch was detected earlier.\\n\\nOnce done, we can `return` `{s1, s2 + 1}` (remember that the second pointer is requested to be where the last segment starts) and be done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int tot = 0, lastElem = arr.size(), lmt = lastElem / 3, s1, s2, last,\\n        curr1 = 0, curr2 = 0, pos1 = 0, pos2 = 0, s1s[lmt], s2s[lmt];\\n        lastElem--;\\n        for (int i = 0; i <= lastElem; i++) {\\n            // finding a `1`\\n            if (arr[i]) {\\n                tot++;\\n                // storing i in s1s if it is not full\\n                if (pos1 < lmt) s1s[pos1++] = i;\\n                // storing i in s2s every 2 1s if it is not full\\n                if (pos2 < lmt && !(tot & 1)) s2s[pos2++] = i;\\n                // updating pointers every 3 1s\\n                if (!(tot % 3)) {\\n                    last = i;\\n                    s1 = s1s[curr1++];\\n                    s2 = s2s[curr2++];\\n                }\\n            }\\n        }\\n        // edge case: no 1s\\n        if (!tot) return {0, lastElem};\\n        // exit case: can\\'t form 3 groups with the same number of 1s\\n        if (tot % 3) return {-1, -1};\\n        // moving the pointer to the last 0 of the sequence\\n        int diff = lastElem - last;\\n        // updating s1 and s2, plus exit case: not enough 0s between either s1 and s2 or s2 and last\\n        s1 += diff;\\n        if (s1 >= s2) return {-1, -1};\\n        s2 += diff;\\n        if (s2 >= last) return {-1, -1};\\n        // updating curr1, curr2, last and tot to check the segment structure\\n        curr1 = s1, curr2 = s2, last = lastElem, tot /= 3;\\n        while (tot) {\\n            // checking if all the elements match\\n            if (arr[curr1] != arr[curr2] || arr[curr2] != arr[last]) return {-1, -1};\\n            // updating variables for the next loop\\n            tot -= arr[curr1];\\n            curr1--, curr2--, last--;\\n        }\\n        // checking if the segments have the same structure\\n        return {s1, s2 + 1};\\n    }\\n};\\n```\\nMicro-optimisation, declaring and assigning `s1` and `s2` at the end and if it might be a proper solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int tot = 0, lastElem = arr.size(), lmt = lastElem / 3, last,\\n        curr1 = -1, curr2 = -1, pos1 = 0, pos2 = 0, s1s[lmt], s2s[lmt];\\n        lastElem--;\\n        for (int i = 0; i <= lastElem; i++) {\\n            // finding a `1`\\n            if (arr[i]) {\\n                tot++;\\n                // storing i in s1s if it is not full\\n                if (pos1 < lmt) s1s[pos1++] = i;\\n                // storing i in s2s every 2 1s if it is not full\\n                if (pos2 < lmt && !(tot & 1)) s2s[pos2++] = i;\\n                // updating pointers every 3 1s\\n                if (!(tot % 3)) {\\n                    last = i;\\n                    curr1++;\\n                    curr2++;\\n                }\\n            }\\n        }\\n        // edge case: no 1s\\n        if (!tot) return {0, lastElem};\\n        // exit case: can\\'t form 3 groups with the same number of 1s\\n        if (tot % 3) return {-1, -1};\\n        // moving the pointer to the last 0 of the sequence\\n        int diff = lastElem - last, s1 = s1s[curr1], s2 = s2s[curr2];\\n        // updating s1 and s2, plus exit case: not enough 0s between either s1 and s2 or s2 and last\\n        s1 += diff;\\n        if (s1 >= s2) return {-1, -1};\\n        s2 += diff;\\n        if (s2 >= last) return {-1, -1};\\n        // updating curr1, curr2, last and tot to check the segment structure\\n        curr1 = s1, curr2 = s2, last = lastElem, tot /= 3;\\n        while (tot) {\\n            // checking if all the elements match\\n            if (arr[curr1] != arr[curr2] || arr[curr2] != arr[last]) return {-1, -1};\\n            // updating variables for the next loop\\n            tot -= arr[curr1];\\n            curr1--, curr2--, last--;\\n        }\\n        // checking if the segments have the same structure\\n        return {s1, s2 + 1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\ns1 == 1;  // position of the first 1\\ns2 == 2;  // position of the second 1\\n i == 5;  // position of the third 1\\n```\n```cpp\\ns1 == 2;  // position of the second 1\\ns2 == 6;  // position of  the fourth 1\\n i == 13; // position of the sixth 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int tot = 0, lastElem = arr.size(), lmt = lastElem / 3, s1, s2, last,\\n        curr1 = 0, curr2 = 0, pos1 = 0, pos2 = 0, s1s[lmt], s2s[lmt];\\n        lastElem--;\\n        for (int i = 0; i <= lastElem; i++) {\\n            // finding a `1`\\n            if (arr[i]) {\\n                tot++;\\n                // storing i in s1s if it is not full\\n                if (pos1 < lmt) s1s[pos1++] = i;\\n                // storing i in s2s every 2 1s if it is not full\\n                if (pos2 < lmt && !(tot & 1)) s2s[pos2++] = i;\\n                // updating pointers every 3 1s\\n                if (!(tot % 3)) {\\n                    last = i;\\n                    s1 = s1s[curr1++];\\n                    s2 = s2s[curr2++];\\n                }\\n            }\\n        }\\n        // edge case: no 1s\\n        if (!tot) return {0, lastElem};\\n        // exit case: can\\'t form 3 groups with the same number of 1s\\n        if (tot % 3) return {-1, -1};\\n        // moving the pointer to the last 0 of the sequence\\n        int diff = lastElem - last;\\n        // updating s1 and s2, plus exit case: not enough 0s between either s1 and s2 or s2 and last\\n        s1 += diff;\\n        if (s1 >= s2) return {-1, -1};\\n        s2 += diff;\\n        if (s2 >= last) return {-1, -1};\\n        // updating curr1, curr2, last and tot to check the segment structure\\n        curr1 = s1, curr2 = s2, last = lastElem, tot /= 3;\\n        while (tot) {\\n            // checking if all the elements match\\n            if (arr[curr1] != arr[curr2] || arr[curr2] != arr[last]) return {-1, -1};\\n            // updating variables for the next loop\\n            tot -= arr[curr1];\\n            curr1--, curr2--, last--;\\n        }\\n        // checking if the segments have the same structure\\n        return {s1, s2 + 1};\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int tot = 0, lastElem = arr.size(), lmt = lastElem / 3, last,\\n        curr1 = -1, curr2 = -1, pos1 = 0, pos2 = 0, s1s[lmt], s2s[lmt];\\n        lastElem--;\\n        for (int i = 0; i <= lastElem; i++) {\\n            // finding a `1`\\n            if (arr[i]) {\\n                tot++;\\n                // storing i in s1s if it is not full\\n                if (pos1 < lmt) s1s[pos1++] = i;\\n                // storing i in s2s every 2 1s if it is not full\\n                if (pos2 < lmt && !(tot & 1)) s2s[pos2++] = i;\\n                // updating pointers every 3 1s\\n                if (!(tot % 3)) {\\n                    last = i;\\n                    curr1++;\\n                    curr2++;\\n                }\\n            }\\n        }\\n        // edge case: no 1s\\n        if (!tot) return {0, lastElem};\\n        // exit case: can\\'t form 3 groups with the same number of 1s\\n        if (tot % 3) return {-1, -1};\\n        // moving the pointer to the last 0 of the sequence\\n        int diff = lastElem - last, s1 = s1s[curr1], s2 = s2s[curr2];\\n        // updating s1 and s2, plus exit case: not enough 0s between either s1 and s2 or s2 and last\\n        s1 += diff;\\n        if (s1 >= s2) return {-1, -1};\\n        s2 += diff;\\n        if (s2 >= last) return {-1, -1};\\n        // updating curr1, curr2, last and tot to check the segment structure\\n        curr1 = s1, curr2 = s2, last = lastElem, tot /= 3;\\n        while (tot) {\\n            // checking if all the elements match\\n            if (arr[curr1] != arr[curr2] || arr[curr2] != arr[last]) return {-1, -1};\\n            // updating variables for the next loop\\n            tot -= arr[curr1];\\n            curr1--, curr2--, last--;\\n        }\\n        // checking if the segments have the same structure\\n        return {s1, s2 + 1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344252,
                "title": "easy-c-o-n-faster-than-99-4-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int i,j,x=0,n=arr.size();\\n        for(i=0;i<n;i++){\\n            if(arr[i]==1) x++;\\n        }\\n        vector<int>v(2);\\n        if(x%3!=0){\\n            v[1]=v[0]=-1;\\n            return v;\\n        }\\n        if(x==0){\\n            v[0]=0;v[1]=n-1;\\n            return v;\\n        }\\n        int k=0;\\n        for(i=n-1;i>=0;i--){\\n            if(arr[i]==1) break;\\n            k++;\\n        }\\n        int z=0;\\n        vector<int>a;\\n        for(i=n-1;i>=0;i--){\\n            if(arr[i]==1) z++;\\n            a.push_back(arr[i]);\\n            if(z==x/3){\\n                v[1]=i;break;\\n            }\\n            \\n        }\\n        z=0;\\n        for(i=v[1]-1;i>=0;i--){\\n            if(arr[i]==1) break;\\n            z++;\\n        }\\n        if(z<k){\\n            v[1]=v[0]=-1;\\n            return v;\\n        }\\n        z=i+k; v[1]=z+1;\\n        int sz=a.size();\\n        for(j=0;j<sz;j++){\\n            if(arr[z]!=a[j]){\\n                v[1]=v[0]=-1;\\n                return v;\\n            }\\n            z--;\\n        }\\n        v[0]=z;\\n        z=0;\\n        for(i=v[0];i>=0;i--){\\n            if(arr[i]==1) break;\\n            z++;\\n        }\\n        if(z<k){\\n            v[1]=v[0]=-1;\\n            return v;\\n        }\\n        z=i+k; v[0]=z;\\n        for(j=0;j<sz;j++){\\n            if(arr[z]!=a[j]){\\n                v[1]=v[0]=-1;\\n                return v;\\n            }\\n            z--;\\n        }\\n        while(z>=0){\\n            if(arr[z]==1){\\n                v[1]=v[0]=-1;\\n                return v;\\n            }\\n            z--;\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int i,j,x=0,n=arr.size();\\n        for(i=0;i<n;i++){\\n            if(arr[i]==1) x++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1344172,
                "title": "easy-java-o-n-100-fast-1-ms-time-count-hack-approach",
                "content": "**Added comments in java code to explain more deeply**\\n```\\n\\n// 927. Three Equal Parts\\n// Runtime: 1 ms, faster than 100.00% of Java online submissions for Three Equal Parts.\\n// Memory Usage: 44.9 MB, less than 60.58% of Java online submissions for Three Equal Parts.\\n\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int countOne=0,n=arr.length;\\n        \\n        //count number of zeroes\\n        for(int i:arr)\\n            countOne+=i;\\n        \\n        //if all 0 return return (0, length)\\n        if(countOne==0)\\n            return new int[]{0,n-1};\\n        //if not divisible by 3 then return (-1,-1)\\n        if(countOne%3!=0)\\n            return new int[]{-1,-1};  \\n        \\n        \\n        \\n        int start = 0,mid = 0,end = 0;\\n        int averageOneCount=countOne/3;\\n        countOne=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            //skip all zeroes\\n            if(arr[i]==0)\\n                continue;\\n             \\n            //mark 1st 1 as start\\n            if(countOne==0)\\n                start=i;\\n            \\n            countOne++;   \\n            //find mid \\'1\\' element\\n           if(countOne == averageOneCount + 1) \\n                mid = i;\\n            \\n            //find last \\'1\\' element\\n           if(countOne == 2 * averageOneCount + 1) \\n                end = i;\\n            \\n        }\\n        \\n        //skip all elements which are same\\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n        \\n        //if we reach end then its possible so return (start-1,end)\\n        if(end == n) {\\n            return new int[]{start-1,mid};\\n        }\\n        \\n        //else return as its not possible\\n        return new int[]{-1,-1}; \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\n\\n// 927. Three Equal Parts\\n// Runtime: 1 ms, faster than 100.00% of Java online submissions for Three Equal Parts.\\n// Memory Usage: 44.9 MB, less than 60.58% of Java online submissions for Three Equal Parts.\\n\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int countOne=0,n=arr.length;\\n        \\n        //count number of zeroes\\n        for(int i:arr)\\n            countOne+=i;\\n        \\n        //if all 0 return return (0, length)\\n        if(countOne==0)\\n            return new int[]{0,n-1};\\n        //if not divisible by 3 then return (-1,-1)\\n        if(countOne%3!=0)\\n            return new int[]{-1,-1};  \\n        \\n        \\n        \\n        int start = 0,mid = 0,end = 0;\\n        int averageOneCount=countOne/3;\\n        countOne=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            //skip all zeroes\\n            if(arr[i]==0)\\n                continue;\\n             \\n            //mark 1st 1 as start\\n            if(countOne==0)\\n                start=i;\\n            \\n            countOne++;   \\n            //find mid \\'1\\' element\\n           if(countOne == averageOneCount + 1) \\n                mid = i;\\n            \\n            //find last \\'1\\' element\\n           if(countOne == 2 * averageOneCount + 1) \\n                end = i;\\n            \\n        }\\n        \\n        //skip all elements which are same\\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n        \\n        //if we reach end then its possible so return (start-1,end)\\n        if(end == n) {\\n            return new int[]{start-1,mid};\\n        }\\n        \\n        //else return as its not possible\\n        return new int[]{-1,-1}; \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344159,
                "title": "hints-if-you-look-for-observations-hints-test-cases-come-over",
                "content": "**Observations**\\n1) Number of 1s should be dived by 3 with no remainder\\n2) We can skip the leading zeros in the middle except trailing zeros\\n3) Number of Middle zeros should be at least as num of trailing zeros\\n\\n**Some Good Test Cases**\\n```\\n[1,0,0,1,0,0,1,0,0]\\n[1,0,0,1,0,0,0,1,0,0]\\n[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]\\n[0,0,1,1,1]\\n[1,0,0,1,1]\\n[1,1,0,0,1]\\n[1,1,1,0,0]\\n[1,1,0,0,1,0,0]\\n[1,0,0,1,1,0,0]\\n[0,0,1,1,1]\\n[1,0,0,1,1]\\n[1,1,0,0,1]\\n[1,1,1,0,0]\\n[1,1,1]\\n[1,1,1,1]\\n[1,1,1,1,1]\\n[1,1,1,1,1,1]\\n```",
                "solutionTags": [],
                "code": "```\\n[1,0,0,1,0,0,1,0,0]\\n[1,0,0,1,0,0,0,1,0,0]\\n[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]\\n[0,0,1,1,1]\\n[1,0,0,1,1]\\n[1,1,0,0,1]\\n[1,1,1,0,0]\\n[1,1,0,0,1,0,0]\\n[1,0,0,1,1,0,0]\\n[0,0,1,1,1]\\n[1,0,0,1,1]\\n[1,1,0,0,1]\\n[1,1,1,0,0]\\n[1,1,1]\\n[1,1,1,1]\\n[1,1,1,1,1]\\n[1,1,1,1,1,1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343630,
                "title": "easy-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        // count 1\\n        int countone=count(arr.begin(),arr.end(),1);\\n        int n=arr.size();\\n        if(countone%3)\\n        {\\n            return {-1,-1};\\n        }\\n        if(countone==0)\\n        {\\n            return {0,n-1};\\n        }\\n        int total=countone/3;\\n        int p1=0,p2=0,p3=0;\\n        int count=0;\\n        // check first occurance of 1 for each part\\n        // lets take example\\n        //1 0 0 0 1 0 1 0 1 0 0 0 0 1 0 1\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                if(count==0)\\n                {\\n                    p1=i;\\n                }\\n                else if(count==total)\\n                {\\n                    p2=i;\\n                }\\n                else if(count==2*total)\\n                {\\n                    p3=i;\\n                }\\n                count+=1;\\n            }\\n        }\\n        // after this\\n        // p1 at index 0,p2 at index 6 and p3 at index 13\\n        // now check all element after of each part\\n        while(p3<n-1)\\n        {\\n            p1+=1;\\n            p2+=1;\\n            p3+=1;\\n            if(arr[p1]!=arr[p2] || arr[p2]!=arr[p3] || arr[p1]!=arr[p3])//if not equal \\n            {\\n                return {-1,-1};\\n            }\\n        }\\n        \\n        return {p1,p2+1};\\n        \\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        // count 1\\n        int countone=count(arr.begin(),arr.end(),1);\\n        int n=arr.size();\\n        if(countone%3)\\n        {\\n            return {-1,-1};\\n        }\\n        if(countone==0)\\n        {\\n            return {0,n-1};\\n        }\\n        int total=countone/3;\\n        int p1=0,p2=0,p3=0;\\n        int count=0;\\n        // check first occurance of 1 for each part\\n        // lets take example\\n        //1 0 0 0 1 0 1 0 1 0 0 0 0 1 0 1\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                if(count==0)\\n                {\\n                    p1=i;\\n                }\\n                else if(count==total)\\n                {\\n                    p2=i;\\n                }\\n                else if(count==2*total)\\n                {\\n                    p3=i;\\n                }\\n                count+=1;\\n            }\\n        }\\n        // after this\\n        // p1 at index 0,p2 at index 6 and p3 at index 13\\n        // now check all element after of each part\\n        while(p3<n-1)\\n        {\\n            p1+=1;\\n            p2+=1;\\n            p3+=1;\\n            if(arr[p1]!=arr[p2] || arr[p2]!=arr[p3] || arr[p1]!=arr[p3])//if not equal \\n            {\\n                return {-1,-1};\\n            }\\n        }\\n        \\n        return {p1,p2+1};\\n        \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343622,
                "title": "o-n-java-runtime-2-ms-faster-than-87-50-of-java-online-submissions",
                "content": "```\\npublic int[] threeEqualParts(int[] arr) {\\n        int oneCount = 0;\\n        int n = arr.length;\\n        for(int t : arr){\\n            if(t == 1) oneCount++;\\n        }\\n        if(oneCount == 0) return new int[]{0,n-1};\\n        if(oneCount % 3 != 0) return new int[]{-1,-1};\\n        int averageOneCount = oneCount / 3;\\n        int start = 0;\\n        int mid = 0;\\n        int end = 0;\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] == 0) continue;\\n            if(cnt == 0) {\\n                start = i;\\n            }\\n            cnt++;\\n            if(cnt == averageOneCount + 1) {\\n                mid = i;\\n            }\\n            if(cnt == 2 * averageOneCount + 1) {\\n                end = i;\\n            }\\n        }\\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n        if(end == n) {\\n            return new int[]{start-1,mid};\\n        }\\n        return new int[]{-1,-1};\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] threeEqualParts(int[] arr) {\\n        int oneCount = 0;\\n        int n = arr.length;\\n        for(int t : arr){\\n            if(t == 1) oneCount++;\\n        }\\n        if(oneCount == 0) return new int[]{0,n-1};\\n        if(oneCount % 3 != 0) return new int[]{-1,-1};\\n        int averageOneCount = oneCount / 3;\\n        int start = 0;\\n        int mid = 0;\\n        int end = 0;\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] == 0) continue;\\n            if(cnt == 0) {\\n                start = i;\\n            }\\n            cnt++;\\n            if(cnt == averageOneCount + 1) {\\n                mid = i;\\n            }\\n            if(cnt == 2 * averageOneCount + 1) {\\n                end = i;\\n            }\\n        }\\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n        if(end == n) {\\n            return new int[]{start-1,mid};\\n        }\\n        return new int[]{-1,-1};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343568,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int count = 0;\\n        for (auto i:arr)\\n        {\\n            if(i == 1)\\n                count++;\\n        }\\n        if(count == 0)\\n            return {0,2};\\n        if(count%3 != 0)\\n            return {-1,-1};\\n        int p1 = 0;\\n        int p2 = 0;\\n        int p3 = 0;\\n        count = count/3;\\n        int temp = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {  if(arr[i] == 1)\\n          { if(temp == 0)\\n              p1 = i;\\n            else if(temp == count)\\n                p2 = i;\\n             else if(temp == 2*count)\\n                p3 = i;\\n           temp++;\\n          }\\n        \\n        }\\n\\n        int oldp2 = p2;\\n        int oldp3 = p3;\\n        while(p1<oldp2 and p2<oldp3 and p3<arr.size())\\n        {\\n            if(arr[p1] != arr[p2] or arr[p2] != arr[p3])\\n                return {-1,-1};\\n            p1++;\\n            p2++;\\n            p3++;\\n        }\\n        if(p3 == arr.size())\\n        {\\n            return {p1-1,p2};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int count = 0;\\n        for (auto i:arr)\\n        {\\n            if(i == 1)\\n                count++;\\n        }\\n        if(count == 0)\\n            return {0,2};\\n        if(count%3 != 0)\\n            return {-1,-1};\\n        int p1 = 0;\\n        int p2 = 0;\\n        int p3 = 0;\\n        count = count/3;\\n        int temp = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {  if(arr[i] == 1)\\n          { if(temp == 0)\\n              p1 = i;\\n            else if(temp == count)\\n                p2 = i;\\n             else if(temp == 2*count)\\n                p3 = i;\\n           temp++;\\n          }\\n        \\n        }\\n\\n        int oldp2 = p2;\\n        int oldp3 = p3;\\n        while(p1<oldp2 and p2<oldp3 and p3<arr.size())\\n        {\\n            if(arr[p1] != arr[p2] or arr[p2] != arr[p3])\\n                return {-1,-1};\\n            p1++;\\n            p2++;\\n            p3++;\\n        }\\n        if(p3 == arr.size())\\n        {\\n            return {p1-1,p2};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343308,
                "title": "python-o-n-time-o-1-space",
                "content": "The idea is to count the trailing zero of the last session(must be counted)\\nAs the leading zero can be ignored, we can just make sure that each session will have enough trailing zeros.\\n\\nLeading zeros will be ignored automatically by accu sum\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        one_count = sum(arr)\\n        \\n        if one_count % 3 != 0: return [-1, -1]\\n        if one_count == 0: return [0, len(arr)-1]\\n        \\n        session_one_count = one_count // 3\\n        session_trailing_zero = 0 # padding for each session\\n        for i in range(len(arr)-1, -1, -1):\\n            if arr[i] == 0:\\n                session_trailing_zero += 1\\n            else:\\n                break\\n        \\n        last_accu = -1\\n        curr_count = 0\\n        curr_accu = 0\\n        session_id = []\\n        \\n        i = 0\\n        while(i < len(arr)):\\n            curr_count += arr[i]\\n            curr_accu = curr_accu * 2 + arr[i]\\n            i += 1\\n            if curr_count == session_one_count:\\n                curr_trailing = 0\\n                while(i < len(arr) and curr_trailing < session_trailing_zero):\\n                    # find trailing zeros\\n                    curr = arr[i]\\n                    if curr == 0:\\n                        curr_trailing += 1\\n                        i += 1\\n                    else:\\n                        return [-1, -1] # not enough trailing zeros\\n                    \\n                if (last_accu != -1) and (curr_accu != last_accu):\\n                    return [-1, -1]\\n                \\n\\t\\t\\t\\t# reset\\n                last_accu = curr_accu\\n                session_id.append(i)\\n                curr_count = 0\\n                curr_accu = 0\\n        \\n        return [session_id[0]-1, session_id[1]]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        one_count = sum(arr)\\n        \\n        if one_count % 3 != 0: return [-1, -1]\\n        if one_count == 0: return [0, len(arr)-1]\\n        \\n        session_one_count = one_count // 3\\n        session_trailing_zero = 0 # padding for each session\\n        for i in range(len(arr)-1, -1, -1):\\n            if arr[i] == 0:\\n                session_trailing_zero += 1\\n            else:\\n                break\\n        \\n        last_accu = -1\\n        curr_count = 0\\n        curr_accu = 0\\n        session_id = []\\n        \\n        i = 0\\n        while(i < len(arr)):\\n            curr_count += arr[i]\\n            curr_accu = curr_accu * 2 + arr[i]\\n            i += 1\\n            if curr_count == session_one_count:\\n                curr_trailing = 0\\n                while(i < len(arr) and curr_trailing < session_trailing_zero):\\n                    # find trailing zeros\\n                    curr = arr[i]\\n                    if curr == 0:\\n                        curr_trailing += 1\\n                        i += 1\\n                    else:\\n                        return [-1, -1] # not enough trailing zeros\\n                    \\n                if (last_accu != -1) and (curr_accu != last_accu):\\n                    return [-1, -1]\\n                \\n\\t\\t\\t\\t# reset\\n                last_accu = curr_accu\\n                session_id.append(i)\\n                curr_count = 0\\n                curr_accu = 0\\n        \\n        return [session_id[0]-1, session_id[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343255,
                "title": "python-o-n-beat-100-304ms",
                "content": "```\\nclass Solution(object):\\n    def threeEqualParts(self, arr):\\n        N = len(arr)\\n        \\n        # ones_number : number of \\'1\\' in arr\\n        ones_number = sum(arr)\\n        if ones_number % 3 != 0: return [-1,-1]\\n        if ones_number == 0: return [0,N-1]\\n        \\n        # ones_each : number of \\'1\\' in one part\\n        ones_each = ones_number // 3\\n        \\n        # ones_idx : idx of \\'1\\', divided in 3 parts\\n        ones_idx, tmp, count = [], [], 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                tmp += [i]\\n                count += 1\\n            \\n            if count == ones_each:\\n                ones_idx.append(tmp)\\n                tmp = []\\n                count = 0\\n        \\n        # ones_idx_shift : idx of \\'1\\', divided in 3 parts, but each subarr is shifted to start with one\\n\\t\\t# used for comparing the pattern\\n        ones_idx_shift = []\\n        for ls in ones_idx:\\n            ones_idx_shift.append([ls[i] - ls[0] for i in range(ones_each)])\\n        \\n        # zeros_tail : numbers of \\'0\\' behind the last \\'1\\'\\n        zeros_tail = N - ones_idx[2][-1] -1\\n        \\n        # Rule 1: Space for zero\\n        # no space for zeros for part1 and part2\\n        if ones_idx[1][0] - ones_idx[0][-1] -1 < zeros_tail or ones_idx[2][0] - ones_idx[1][-1] -1 < zeros_tail:\\n            return [-1,-1]\\n        \\n        # Rule 2: Pattern of three parts\\n        # compare the pattern of part1, part2, and part3\\n        if ones_idx_shift[0] == ones_idx_shift[1] and ones_idx_shift[1] == ones_idx_shift[2]:\\n            return [ones_idx[0][-1] + zeros_tail, ones_idx[1][-1] +1 + zeros_tail]\\n        \\n        return [-1,-1]\\n```\\n### Sum of arr needs to be 3n\\nSince the arr is divided into 3 equal parts, the number of \\'1\\' need to be the multiple of 3.\\n\\n\\n### Need to match two rule\\n\\n#### Rule 1: Space for zero\\nWe need to make sure that there are enough \\'0\\' between each part.\\n\\nBecause **the \\'0\\' behind the last \\'1\\' is used in part3 for sure**, we can count whether there are enough \\'0\\' between (part1 ,part2) and between (part2, part3), which meen more than the number of \\'0\\' behind the last \\'1\\'.\\n\\n#### Rule 2: Pattern of three parts\\nPattern of three parts need to be the same.\\n\\nWe divide arr based on the number of \\'1\\', each part only have 1/3 number of \\'1\\'.\\n\\nFor example:\\n[1, 0, 0, 1, 0, 1, 0] can be divided into [1,0], [1,0], [1,0] => same\\n[1, 1, 0, 1, 0, 1, 1, 0, 0, 1] can be divided into [1, 1, 0], [1, 0, 1], [1, 0, 0, 1] => not the same",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeEqualParts(self, arr):\\n        N = len(arr)\\n        \\n        # ones_number : number of \\'1\\' in arr\\n        ones_number = sum(arr)\\n        if ones_number % 3 != 0: return [-1,-1]\\n        if ones_number == 0: return [0,N-1]\\n        \\n        # ones_each : number of \\'1\\' in one part\\n        ones_each = ones_number // 3\\n        \\n        # ones_idx : idx of \\'1\\', divided in 3 parts\\n        ones_idx, tmp, count = [], [], 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                tmp += [i]\\n                count += 1\\n            \\n            if count == ones_each:\\n                ones_idx.append(tmp)\\n                tmp = []\\n                count = 0\\n        \\n        # ones_idx_shift : idx of \\'1\\', divided in 3 parts, but each subarr is shifted to start with one\\n\\t\\t# used for comparing the pattern\\n        ones_idx_shift = []\\n        for ls in ones_idx:\\n            ones_idx_shift.append([ls[i] - ls[0] for i in range(ones_each)])\\n        \\n        # zeros_tail : numbers of \\'0\\' behind the last \\'1\\'\\n        zeros_tail = N - ones_idx[2][-1] -1\\n        \\n        # Rule 1: Space for zero\\n        # no space for zeros for part1 and part2\\n        if ones_idx[1][0] - ones_idx[0][-1] -1 < zeros_tail or ones_idx[2][0] - ones_idx[1][-1] -1 < zeros_tail:\\n            return [-1,-1]\\n        \\n        # Rule 2: Pattern of three parts\\n        # compare the pattern of part1, part2, and part3\\n        if ones_idx_shift[0] == ones_idx_shift[1] and ones_idx_shift[1] == ones_idx_shift[2]:\\n            return [ones_idx[0][-1] + zeros_tail, ones_idx[1][-1] +1 + zeros_tail]\\n        \\n        return [-1,-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200387,
                "title": "scala-solution",
                "content": "```\\ndef findEndIdx(arr: Array[Int], i: Int, binary_value: String):Int = {\\n        if(arr.drop(i).dropWhile(_==0).take(binary_value.length).foldLeft(\"\")((b,a)=> a + b) != binary_value) return -1\\n        return arr.drop(i).takeWhile(_==0).length + i + binary_value.length\\n      }\\n      def threeEqualParts(arr: Array[Int]): Array[Int] = {\\n        val cnt = arr.count(_ == 1)\\n        val n = arr.length\\n        if (cnt%3 !=0) return Array(-1,-1)\\n        if(cnt == 0)  return Array(0,n - 1)\\n        val idxThird  =arr.zipWithIndex.filter(n=> n._1 == 1).takeRight(cnt/3).take(1)(0)._2\\n        val binary_value = arr.takeRight(n - idxThird).foldLeft(\"\")((b,a)=>{a + b})\\n        val res1 = findEndIdx(arr, 0, binary_value)\\n        if (res1 < 0) return Array(-1,-1)\\n        val res2 = findEndIdx(arr, res1, binary_value)\\n        if (res2 < 0) return Array(-1,-1)\\n        return Array(res1 - 1,res2)\\n      }\\n```",
                "solutionTags": [],
                "code": "```\\ndef findEndIdx(arr: Array[Int], i: Int, binary_value: String):Int = {\\n        if(arr.drop(i).dropWhile(_==0).take(binary_value.length).foldLeft(\"\")((b,a)=> a + b) != binary_value) return -1\\n        return arr.drop(i).takeWhile(_==0).length + i + binary_value.length\\n      }\\n      def threeEqualParts(arr: Array[Int]): Array[Int] = {\\n        val cnt = arr.count(_ == 1)\\n        val n = arr.length\\n        if (cnt%3 !=0) return Array(-1,-1)\\n        if(cnt == 0)  return Array(0,n - 1)\\n        val idxThird  =arr.zipWithIndex.filter(n=> n._1 == 1).takeRight(cnt/3).take(1)(0)._2\\n        val binary_value = arr.takeRight(n - idxThird).foldLeft(\"\")((b,a)=>{a + b})\\n        val res1 = findEndIdx(arr, 0, binary_value)\\n        if (res1 < 0) return Array(-1,-1)\\n        val res2 = findEndIdx(arr, res1, binary_value)\\n        if (res2 < 0) return Array(-1,-1)\\n        return Array(res1 - 1,res2)\\n      }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1051404,
                "title": "python-3-brutal-force-with-explanation",
                "content": "First, special cases:\\n* \\tIf there is no 1 in list, we can just return ```[0, len(n)-1]```.\\n* \\tIf number of 1 cant be divied by 3, return ```[-1, -1]```.\\n\\nThen we find the valid binary number, since the leading zeros dont matter here, we just need to find the binary start with \"1\", therefore we traverse the list until we find the ```2 * m / 3 + 1``` th \"1\", this \"1\" is the start of the 3rd binary number.\\nTherefore we esaily find what this binary number is.\\n\\nNext, we just need to find the ```1st``` \"1\" and the ```m / 3 + 1``` th \"1\", standing for the begining of 1st and 2nd binary number seperatly. Once we find this \"1\",  comparing the array consisting this \"1\" with the 3rd number we have already found.\\n\\nReturn the index of ```i``` and ```j``` if both arrays are same with 3rd binary number, otherwise ```[-1, -1]```.\\n\\n```\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        m = sum(arr)\\n\\t\\tif m == 0:\\n            return [0, n - 1]\\n        if m % 3:\\n            return [-1, -1]\\n\\t\\t\\t\\n        k = m // 3\\n        i = 0\\n        n = len(arr)\\n        \\n        \\n        #start with finding the third (last) binary value in the list\\n        for idx in range(n):\\n            if arr[idx] == 1:\\n                i += 1\\n            if i == 2 * k + 1:\\n                res = arr[idx :]\\n                break\\n        reslen = len(res)\\n        \\n        ans = []\\n        \\n        #find the first binary value in list\\n        for idx in range(n):\\n            if arr[idx] == 1:\\n                break\\n        if arr[idx : idx + reslen] == res:\\n            ans.append(idx + reslen - 1)\\n        else:\\n            return [-1, -1]\\n\\n        #find the second binary in the list\\n        for idx in range(idx + reslen, n):\\n            if arr[idx] == 1:\\n                break\\n        if arr[idx : idx + reslen] == res:\\n            ans.append(idx + reslen)\\n            return ans\\n        else:\\n            return [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```[0, len(n)-1]```\n```[-1, -1]```\n```2 * m / 3 + 1```\n```1st```\n```m / 3 + 1```\n```i```\n```j```\n```[-1, -1]```\n```\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        m = sum(arr)\\n\\t\\tif m == 0:\\n            return [0, n - 1]\\n        if m % 3:\\n            return [-1, -1]\\n\\t\\t\\t\\n        k = m // 3\\n        i = 0\\n        n = len(arr)\\n        \\n        \\n        #start with finding the third (last) binary value in the list\\n        for idx in range(n):\\n            if arr[idx] == 1:\\n                i += 1\\n            if i == 2 * k + 1:\\n                res = arr[idx :]\\n                break\\n        reslen = len(res)\\n        \\n        ans = []\\n        \\n        #find the first binary value in list\\n        for idx in range(n):\\n            if arr[idx] == 1:\\n                break\\n        if arr[idx : idx + reslen] == res:\\n            ans.append(idx + reslen - 1)\\n        else:\\n            return [-1, -1]\\n\\n        #find the second binary in the list\\n        for idx in range(idx + reslen, n):\\n            if arr[idx] == 1:\\n                break\\n        if arr[idx : idx + reslen] == res:\\n            ans.append(idx + reslen)\\n            return ans\\n        else:\\n            return [-1, -1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 418037,
                "title": "python-simple-solution",
                "content": "If the solution exists, the number of 1 in list should be times of 3.\\nSearch from right side to left, until we found num/3 1s. This index is not final answer, but we find the binary value.\\nFrom left side to right, find the first 1s and compare whether the first part value equal to bianay value and so on.\\n\\n```python\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        cnt1 = A.count(1)\\n        if cnt1%3 !=0:\\n            return [-1,-1]\\n        if cnt1 == 0:\\n            return [0,len(A)-1]\\n            \\n        cnt, binary_value = 0, 0\\n        # the binary value has been anchored\\n        for i in range(len(A)-1,-1,-1):\\n            if A[i]:\\n                cnt += 1\\n                if cnt == cnt1//3:\\n                    binary_value = A[i:]\\n                    length = len(binary_value)\\n                    break\\n        \\n        for i in range(0,len(A)):\\n            if A[i]:\\n                if A[i:i+length] == binary_value:\\n                    secondPart_startdx = i+length\\n                    for j in range(secondPart_startdx,len(A)):\\n                        if A[j]:\\n                            if A[j:j+length] == binary_value:\\n                                return [secondPart_startdx-1,j+length]\\n                            return [-1,-1]\\n                return [-1,-1]           \\n        return [-1,-1]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        cnt1 = A.count(1)\\n        if cnt1%3 !=0:\\n            return [-1,-1]\\n        if cnt1 == 0:\\n            return [0,len(A)-1]\\n            \\n        cnt, binary_value = 0, 0\\n        # the binary value has been anchored\\n        for i in range(len(A)-1,-1,-1):\\n            if A[i]:\\n                cnt += 1\\n                if cnt == cnt1//3:\\n                    binary_value = A[i:]\\n                    length = len(binary_value)\\n                    break\\n        \\n        for i in range(0,len(A)):\\n            if A[i]:\\n                if A[i:i+length] == binary_value:\\n                    secondPart_startdx = i+length\\n                    for j in range(secondPart_startdx,len(A)):\\n                        if A[j]:\\n                            if A[j:j+length] == binary_value:\\n                                return [secondPart_startdx-1,j+length]\\n                            return [-1,-1]\\n                return [-1,-1]           \\n        return [-1,-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 381367,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        List<Integer> plist = new ArrayList<>();\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                plist.add(i);\\n            }\\n        }\\n        // all zero\\n        if (plist.size() == 0) {\\n            return new int[]{0, 2};\\n        }\\n        // #1 is not 3x\\n        if (plist.size() % 3 != 0) {\\n            return new int[]{-1, -1};\\n        }\\n        // check gaps between 1s\\n        int count = plist.size()/3;\\n        int s1 = 0;\\n        int s2 = count;\\n        int s3 = 2*count;\\n        for (int i = 0; i < count-1; i++) {\\n            int gap1 = plist.get(s1+i+1) - plist.get(s1+i);\\n            int gap2 = plist.get(s2+i+1) - plist.get(s2+i);\\n            int gap3 = plist.get(s3+i+1) - plist.get(s3+i);\\n            if (gap1 != gap2 || gap2 != gap3) {\\n                return new int[]{-1, -1};\\n            }\\n        }\\n        // check right 0-padding for least significant bits\\n        int rpad1 = plist.get(s2) - plist.get(s2-1) - 1;\\n        int rpad2 = plist.get(s3) - plist.get(s3-1) - 1;\\n        int rpad3 = A.length - plist.get(plist.size()-1) - 1;\\n        if (rpad1 < rpad3 || rpad2 < rpad3) {\\n            return new int[]{-1, -1};\\n        }\\n        \\n        return new int[]{\\n            plist.get(s2-1)+rpad3, \\n            plist.get(s3-1)+rpad3+1\\n        };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        List<Integer> plist = new ArrayList<>();\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                plist.add(i);\\n            }\\n        }\\n        // all zero\\n        if (plist.size() == 0) {\\n            return new int[]{0, 2};\\n        }\\n        // #1 is not 3x\\n        if (plist.size() % 3 != 0) {\\n            return new int[]{-1, -1};\\n        }\\n        // check gaps between 1s\\n        int count = plist.size()/3;\\n        int s1 = 0;\\n        int s2 = count;\\n        int s3 = 2*count;\\n        for (int i = 0; i < count-1; i++) {\\n            int gap1 = plist.get(s1+i+1) - plist.get(s1+i);\\n            int gap2 = plist.get(s2+i+1) - plist.get(s2+i);\\n            int gap3 = plist.get(s3+i+1) - plist.get(s3+i);\\n            if (gap1 != gap2 || gap2 != gap3) {\\n                return new int[]{-1, -1};\\n            }\\n        }\\n        // check right 0-padding for least significant bits\\n        int rpad1 = plist.get(s2) - plist.get(s2-1) - 1;\\n        int rpad2 = plist.get(s3) - plist.get(s3-1) - 1;\\n        int rpad3 = A.length - plist.get(plist.size()-1) - 1;\\n        if (rpad1 < rpad3 || rpad2 < rpad3) {\\n            return new int[]{-1, -1};\\n        }\\n        \\n        return new int[]{\\n            plist.get(s2-1)+rpad3, \\n            plist.get(s3-1)+rpad3+1\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375386,
                "title": "simple-c-soultion-with-detailed-analysis",
                "content": "The core idea is:\\n1. if we look from backward, **the last element must be valid part of the 3-rd number.**\\n2. we can get *how many \\'1\\' should be in a part* by **counting how many one in array** and divde it into 3\\n3. if we get a fraction instead an integer, it must **not** equal.\\n4. then we just **count how many 1 has seen** to get every part\\'s start position\\n5. compare 3 parts of the array to ensure they\\'re equal.\\n\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* threeEqualParts(int* A, int ASize, int* returnSize){\\n    int n,i;\\n    int *r = (int *)malloc(sizeof(int)*2);\\n    r[0]=r[1]=-1;\\n    *returnSize = 2;\\n    //count how many ones in array\\n    for(n = i = 0; i < ASize; i++)\\n    {\\n        if(A[i])n++;\\n    }\\n    //if it\\'s worth trying, it must contain equal ones of each\\n    if(n && n % 3 == 0)\\n    {\\n        uint16_t d = 0; // length of a part\\n        uint16_t q = 0; // length counter of a part and its forehead\\n        uint16_t p=0; // counter of \\'1\\' has read\\n        uint16_t s=0; // current position record pointer\\n        uint16_t k[3]={0}; //begin positions of parts\\n        //every part has this amount of \\'1\\'\\n        n /= 3;\\n        //loop from backward in order to count acutal part size first.\\n        for(i = ASize - 1;i>=0;i--)\\n        {\\n            q++; // count how many chars gone though\\n            if(A[i] && (++p % n == 0 || n == 1)) // if \\'1\\' then test if reached a point to do segment\\n            {\\n                k[s++]=i; //record and move pointer to next record\\n                if(d == 0) d = ASize - i; //set corret length of a part\\n                else if(d < n || d > q) return r; // incorret length found, immediate return\\n                q = 0; // reset part char counter for next one\\n            }\\n        }\\n        //detect unmatch pattern\\n        for(i = 0; i < d; i++)\\n        {\\n            if(!((A+k[2])[i]==(A+k[0])[i] && (A+k[0])[i] == (A+k[1])[i]))return r;\\n        }\\n        //set position to first one\\'s last char and second one\\'s last char\\n        r[0] = k[2]+d-1;\\n        r[1] = k[1]+d;\\n    }\\n    else if(n == 0)\\n    {\\n        //wired, unwritten rule, even applies to empty input.\\n        r[0]=0;\\n        r[1]=ASize-1;\\n    }\\n    return r;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* threeEqualParts(int* A, int ASize, int* returnSize){\\n    int n,i;\\n    int *r = (int *)malloc(sizeof(int)*2);\\n    r[0]=r[1]=-1;\\n    *returnSize = 2;\\n    //count how many ones in array\\n    for(n = i = 0; i < ASize; i++)\\n    {\\n        if(A[i])n++;\\n    }\\n    //if it\\'s worth trying, it must contain equal ones of each\\n    if(n && n % 3 == 0)\\n    {\\n        uint16_t d = 0; // length of a part\\n        uint16_t q = 0; // length counter of a part and its forehead\\n        uint16_t p=0; // counter of \\'1\\' has read\\n        uint16_t s=0; // current position record pointer\\n        uint16_t k[3]={0}; //begin positions of parts\\n        //every part has this amount of \\'1\\'\\n        n /= 3;\\n        //loop from backward in order to count acutal part size first.\\n        for(i = ASize - 1;i>=0;i--)\\n        {\\n            q++; // count how many chars gone though\\n            if(A[i] && (++p % n == 0 || n == 1)) // if \\'1\\' then test if reached a point to do segment\\n            {\\n                k[s++]=i; //record and move pointer to next record\\n                if(d == 0) d = ASize - i; //set corret length of a part\\n                else if(d < n || d > q) return r; // incorret length found, immediate return\\n                q = 0; // reset part char counter for next one\\n            }\\n        }\\n        //detect unmatch pattern\\n        for(i = 0; i < d; i++)\\n        {\\n            if(!((A+k[2])[i]==(A+k[0])[i] && (A+k[0])[i] == (A+k[1])[i]))return r;\\n        }\\n        //set position to first one\\'s last char and second one\\'s last char\\n        r[0] = k[2]+d-1;\\n        r[1] = k[1]+d;\\n    }\\n    else if(n == 0)\\n    {\\n        //wired, unwritten rule, even applies to empty input.\\n        r[0]=0;\\n        r[1]=ASize-1;\\n    }\\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359936,
                "title": "my-o-n-c-solution",
                "content": "At first, we calculate the total number of \\'1\\', and check if it can be divided by 3. Because each part must contain the same number of \\'1\\'.\\nIf not, we just return { -1, -1 }.\\nThen, we calculate the number of \\'0\\' at the end of the array, which means that we won\\'t stop until we find the first \\'1\\' at the end. If the array can be split into 3 parts, each part must has the same number of \\'0\\' as the end of the array.\\nSince we have already got the total number of \\'1\\' and the number of \\'0\\' at the end of the array, we can check if the array can be divided into three parts with the exact number of 1 and 0 as we expected,  and whether the three parts are equal to each other ( pay attention that we should skip the leading zero ). If we can find the result, we record the index, and return it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        vector<int> res;  \\n        int n = A.size();\\n        int zeros = 0; // number of zero at the end\\n        int ones = 0; // total number of one\\n        \\n        // get number of zero at the end\\n        for(int i = n - 1; i >= 0;i--)\\n        {\\n            if(A[i] == 1) break;\\n            zeros++;\\n        }\\n        // get total number of one\\n        for(int i = 0;i < n;i++)\\n        {\\n            if(A[i] == 1) nums++;\\n        }\\n        \\n        // all data in this array is 0, we can divide the array at every place\\n        if(nums == 0)\\n        {\\n            return {0, n - 1};\\n        }\\n        \\n        // the total number of 1 can\\'t be divided by 3. return false.\\n        if(nums % 3) return {-1, -1};\\n\\n        int count = nums / 3;\\n        string target;\\n                \\n        // check if the array can be split into 3 parts\\n        // each parts has (ones/3)\\'s 1, and has (zeros)\\'s 0 at at the end\\n        int i = 0;\\n        for(int k = 0; k < 3;k++)\\n        {\\n            string str;\\n            int one_nums = 0;\\n            int zero_nums = 0;\\n            for(;i < n; i++)\\n            {\\n                if(one_nums == count && zero_nums == zeros) break;\\n                if(A[i] == 0)\\n                {\\n                    if(one_nums == count)\\n                    {\\n                        zero_nums++;\\n                    }\\n                    if(!str.empty()) // skip the leading 0.\\n                        str.push_back(A[i]);\\n                }\\n                else if(A[i] == 1)\\n                {\\n                    if(one_nums == count) // the number of 0 at the end is not match\\n                    {\\n                        return {-1, -1};\\n                    }\\n                    one_nums++;\\n                    str.push_back(A[i]);\\n                }   \\n            }\\n\\n            if(target.empty())\\n            {\\n                target = str;\\n            }\\n            else\\n            {\\n                if(target != str) return {-1, -1};  // current part and last part is not match             \\n            }\\n            if(k == 0) res.push_back(i - 1); // record the index\\n            else if(k == 1) res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        vector<int> res;  \\n        int n = A.size();\\n        int zeros = 0; // number of zero at the end\\n        int ones = 0; // total number of one\\n        \\n        // get number of zero at the end\\n        for(int i = n - 1; i >= 0;i--)\\n        {\\n            if(A[i] == 1) break;\\n            zeros++;\\n        }\\n        // get total number of one\\n        for(int i = 0;i < n;i++)\\n        {\\n            if(A[i] == 1) nums++;\\n        }\\n        \\n        // all data in this array is 0, we can divide the array at every place\\n        if(nums == 0)\\n        {\\n            return {0, n - 1};\\n        }\\n        \\n        // the total number of 1 can\\'t be divided by 3. return false.\\n        if(nums % 3) return {-1, -1};\\n\\n        int count = nums / 3;\\n        string target;\\n                \\n        // check if the array can be split into 3 parts\\n        // each parts has (ones/3)\\'s 1, and has (zeros)\\'s 0 at at the end\\n        int i = 0;\\n        for(int k = 0; k < 3;k++)\\n        {\\n            string str;\\n            int one_nums = 0;\\n            int zero_nums = 0;\\n            for(;i < n; i++)\\n            {\\n                if(one_nums == count && zero_nums == zeros) break;\\n                if(A[i] == 0)\\n                {\\n                    if(one_nums == count)\\n                    {\\n                        zero_nums++;\\n                    }\\n                    if(!str.empty()) // skip the leading 0.\\n                        str.push_back(A[i]);\\n                }\\n                else if(A[i] == 1)\\n                {\\n                    if(one_nums == count) // the number of 0 at the end is not match\\n                    {\\n                        return {-1, -1};\\n                    }\\n                    one_nums++;\\n                    str.push_back(A[i]);\\n                }   \\n            }\\n\\n            if(target.empty())\\n            {\\n                target = str;\\n            }\\n            else\\n            {\\n                if(target != str) return {-1, -1};  // current part and last part is not match             \\n            }\\n            if(k == 0) res.push_back(i - 1); // record the index\\n            else if(k == 1) res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279798,
                "title": "javascript-90ms",
                "content": "```\\nvar threeEqualParts = function(A) {\\n    const getOneCount = () => {\\n        const oneCount = A.reduce((acc, bit) => bit == 1 ? acc + 1 : acc, 0)\\n        if(oneCount % 3 == 0) \\n            return oneCount / 3\\n        return -1\\n    }\\n\\n    const getTail = oneCount => { \\n        let zeroCount = 0, idx = A.length -1\\n        let oneRemain = oneCount\\n        while(oneRemain > 0) {\\n            if(A[idx] == 1) {\\n                oneRemain--\\n            }\\n            if(A[idx] == 0 && oneRemain == oneCount) {\\n                zeroCount++\\n            }\\n            idx--\\n        }\\n        return {zeroCount, tailStart: idx + 1}\\n    }\\n\\n    const getHead = (oneCount, zeroCount) => {\\n        let idx = 0\\n        while(oneCount > 0) {\\n            if(A[idx] == 1)\\n                oneCount--\\n            idx++\\n        }\\n        if(zeroCount > 0) {\\n            while(A[idx] == 0 && zeroCount > 0){\\n                idx++\\n                zeroCount--\\n            }\\n        }\\n        return zeroCount == 0 ? idx-1 : -1\\n    }\\n\\n    const getMiddle = (oneCount, headEnd, tailStart) => {\\n        let idx = headEnd + 1\\n        let tailIdx = tailStart\\n        while(A[idx] != 1) idx++\\n        while(idx < tailStart && A[idx] == A[tailIdx]) {\\n            idx++\\n            tailIdx++\\n        }\\n        if(tailIdx != A.length)\\n            return -1\\n        return idx\\n\\n    }\\n\\n    const oneCount = getOneCount()\\n    if(oneCount == -1 || A.length < 3)\\n        return [-1, -1]\\n    if(oneCount == 0) return [0, A.length-1]\\n    const {tailStart, zeroCount} = getTail(oneCount)\\n    const headEnd = getHead(oneCount, zeroCount)\\n    if(headEnd == -1)\\n        return [-1, -1]\\n    const middleEnd = getMiddle(oneCount, headEnd, tailStart)\\n    if(middleEnd == -1)\\n        return [-1, -1]\\n    return [headEnd, middleEnd]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeEqualParts = function(A) {\\n    const getOneCount = () => {\\n        const oneCount = A.reduce((acc, bit) => bit == 1 ? acc + 1 : acc, 0)\\n        if(oneCount % 3 == 0) \\n            return oneCount / 3\\n        return -1\\n    }\\n\\n    const getTail = oneCount => { \\n        let zeroCount = 0, idx = A.length -1\\n        let oneRemain = oneCount\\n        while(oneRemain > 0) {\\n            if(A[idx] == 1) {\\n                oneRemain--\\n            }\\n            if(A[idx] == 0 && oneRemain == oneCount) {\\n                zeroCount++\\n            }\\n            idx--\\n        }\\n        return {zeroCount, tailStart: idx + 1}\\n    }\\n\\n    const getHead = (oneCount, zeroCount) => {\\n        let idx = 0\\n        while(oneCount > 0) {\\n            if(A[idx] == 1)\\n                oneCount--\\n            idx++\\n        }\\n        if(zeroCount > 0) {\\n            while(A[idx] == 0 && zeroCount > 0){\\n                idx++\\n                zeroCount--\\n            }\\n        }\\n        return zeroCount == 0 ? idx-1 : -1\\n    }\\n\\n    const getMiddle = (oneCount, headEnd, tailStart) => {\\n        let idx = headEnd + 1\\n        let tailIdx = tailStart\\n        while(A[idx] != 1) idx++\\n        while(idx < tailStart && A[idx] == A[tailIdx]) {\\n            idx++\\n            tailIdx++\\n        }\\n        if(tailIdx != A.length)\\n            return -1\\n        return idx\\n\\n    }\\n\\n    const oneCount = getOneCount()\\n    if(oneCount == -1 || A.length < 3)\\n        return [-1, -1]\\n    if(oneCount == 0) return [0, A.length-1]\\n    const {tailStart, zeroCount} = getTail(oneCount)\\n    const headEnd = getHead(oneCount, zeroCount)\\n    if(headEnd == -1)\\n        return [-1, -1]\\n    const middleEnd = getMiddle(oneCount, headEnd, tailStart)\\n    if(middleEnd == -1)\\n        return [-1, -1]\\n    return [headEnd, middleEnd]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184213,
                "title": "java-o-n-time-o-1-space-8-ms",
                "content": "1. Check if there are enough number of ones for three parts (aka number of ones is a multiple of 3).\n2. Iterate the array from the tail and find the spot that marks the start of a binary number with n/3 1s (n is total number of ones).\n3. Lets call the marker in step 2 \"part3\". We need to check to see if there are 2 more occurences of this part (part3 to end of array) between 0 and part3.\n4. In order to lookup the part, start from the beginning of the array, ignoring all the leading zeros (as they don't contribute to the value), try to match with  the number formed by part3 - end. \n5. Repeat step 4 one more time, this time starting at the end of first match.\n```\nclass Solution {\n    public int[] threeEqualParts(int[] A) {\n        int count = 0;\n        for(int i : A){\n            count = count+i;\n        }\n        if(count==0){\n            return new int[]{0,A.length-1};\n        }\n        if(count%3!=0){\n            return new int[]{-1,-1};\n        }\n        int part3 = A.length;\n        int soFar = 0;\n        while(soFar<count/3 && part3>-1){\n            part3--;\n            soFar += A[part3];            \n        }\n        int tracker = match(A, 0, part3);\n        if(tracker==-1){\n            return new int[]{-1, -1};\n        }\n        int end = match(A, tracker, part3);\n        if(end==-1){\n            return new int[]{-1, -1};\n        }        \n        return new int[]{tracker-1, end};\n    }\n    \n    private int match(int[] A, int start, int ref){      \n        while(A[start]==0){\n            start++;\n        }    \n        while(ref < A.length){\n            if(A[ref]!=A[start]){\n                return -1;\n            }\n            ref++;\n            start++;\n        }\n        return start;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int[] threeEqualParts(int[] A) {\n        int count = 0;\n        for(int i : A){\n            count = count+i;\n        }\n        if(count==0){\n            return new int[]{0,A.length-1};\n        }\n        if(count%3!=0){\n            return new int[]{-1,-1};\n        }\n        int part3 = A.length;\n        int soFar = 0;\n        while(soFar<count/3 && part3>-1){\n            part3--;\n            soFar += A[part3];            \n        }\n        int tracker = match(A, 0, part3);\n        if(tracker==-1){\n            return new int[]{-1, -1};\n        }\n        int end = match(A, tracker, part3);\n        if(end==-1){\n            return new int[]{-1, -1};\n        }        \n        return new int[]{tracker-1, end};\n    }\n    \n    private int match(int[] A, int start, int ref){      \n        while(A[start]==0){\n            start++;\n        }    \n        while(ref < A.length){\n            if(A[ref]!=A[start]){\n                return -1;\n            }\n            ref++;\n            start++;\n        }\n        return start;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 183986,
                "title": "c-easy-to-understand-o-n",
                "content": "If we can divide the number of 1s into 3 equal parts, we can just check the three parts for equality. \nDividing 1s into 3 partitions and checking for equality is a necessary and sufficient condition for the answer.\nWe need to take care of 0s only in the third partition because they will be trailing zeros always and will add to the third binary number representation always.\nAs long as first and second partition have the same number of trailing zeros as the third representation, we have a solution. We do not care about any other zeros in the first and second partition because trailing zeros of first can add to leading zeros of second and trailing zeros of second can add to leading zeros of third.\n\n```\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        int num1s=0;\n        for(int i:A) {\n            if(i==1)\n                num1s++;\n        }\n        if(num1s%3!=0)\n            return {-1,-1};\n        if(num1s==0)\n            return {0,A.size()-1};\n        int c=num1s/3;\n        vector<int> nums(3,0);\n        int count=0;\n        for(int i=0;i<A.size();i++) {\n            //If this is the start of the next binary representation(0 or 1 or 2 in vector nums)\n            if(A[i]==1) {\n                if(count%c==0) {\n                    nums[count/c]=i;  //assign current index to nums[0,1,2]\n                }\n                count++;\n            } \n        }\n        //Every other representation should follow Last representation \n        while(nums[2]!=A.size()) {   \n            if(A[nums[0]]!=A[nums[1]] || A[nums[0]]!=A[nums[2]])\n                return {-1,-1};\n            nums[0]++;\n            nums[1]++;\n            nums[2]++;\n        }\n        return {nums[0]-1, nums[1]};\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        int num1s=0;\n        for(int i:A) {\n            if(i==1)\n                num1s++;\n        }\n        if(num1s%3!=0)\n            return {-1,-1};\n        if(num1s==0)\n            return {0,A.size()-1};\n        int c=num1s/3;\n        vector<int> nums(3,0);\n        int count=0;\n        for(int i=0;i<A.size();i++) {\n            //If this is the start of the next binary representation(0 or 1 or 2 in vector nums)\n            if(A[i]==1) {\n                if(count%c==0) {\n                    nums[count/c]=i;  //assign current index to nums[0,1,2]\n                }\n                count++;\n            } \n        }\n        //Every other representation should follow Last representation \n        while(nums[2]!=A.size()) {   \n            if(A[nums[0]]!=A[nums[1]] || A[nums[0]]!=A[nums[2]])\n                return {-1,-1};\n            nums[0]++;\n            nums[1]++;\n            nums[2]++;\n        }\n        return {nums[0]-1, nums[1]};\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521758,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n     \\n        int countone=count(arr.begin(),arr.end(),1);\\n        int n=arr.size();\\n        if(countone%3)\\n        {\\n            return {-1,-1};\\n        }\\n        if(countone==0)\\n        {\\n            return {0,n-1};\\n        }\\n        int total=countone/3;\\n        int p1=0,p2=0,p3=0;\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                if(count==0)\\n                {\\n                    p1=i;\\n                }\\n                else if(count==total)\\n                {\\n                    p2=i;\\n                }\\n                else if(count==2*total)\\n                {\\n                    p3=i;\\n                }\\n                count+=1;\\n            }\\n        }\\n        while(p3<n-1)\\n        {\\n            p1+=1;\\n            p2+=1;\\n            p3+=1;\\n            if(arr[p1]!=arr[p2] || arr[p2]!=arr[p3] || arr[p1]!=arr[p3])\\n            {\\n                return {-1,-1};\\n            }\\n        }\\n        return {p1,p2+1};\\n    } \\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        ones = [i for i, j in enumerate(arr) if j==1]\\n        n=len(ones)\\n\\n        if not ones:\\n            return [0, 2]\\n        if n%3:\\n            return [-1, -1]\\n        \\n        i,j,k = ones[0], ones[n//3], ones[n//3*2]\\n        l = len(arr)-k\\n\\n        if arr[i:i+l]==arr[j:j+l]==arr[k:k+l]:\\n            return [i+l-1, j+l]\\n\\n        return [-1, -1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int oneSum = 0;\\n        for(int x : arr) oneSum +=x;\\n        if(oneSum % 3 !=0)return new int[]{-1,-1};\\n        if(oneSum == 0)return new int[]{0,2};\\n        int oneCount = oneSum / 3;\\n        int i = 0;\\n        int firstOne = -1;\\n        int n= arr.length;\\n        int lastZeroCount = 0;\\n        i = n-1;\\n        while(arr[i] ==0){\\n            lastZeroCount++;\\n            i--;\\n        }\\n        i=0;\\n        while(oneCount > 0){\\n            if(arr[i] == 1 && firstOne == -1)firstOne = i;\\n            oneCount-=arr[i++];\\n        }\\n        while(lastZeroCount > 0){\\n            if(arr[i++] == 1)return new int[]{-1,-1};\\n            lastZeroCount--;\\n        }\\n        int k = i--;\\n        int t = firstOne;\\n        while(arr[k] == 0)k++;\\n        while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        int j = k;\\n        while(arr[k] == 0)k++;\\n        firstOne = t;\\n         while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        return new int[]{i,j};\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n     \\n        int countone=count(arr.begin(),arr.end(),1);\\n        int n=arr.size();\\n        if(countone%3)\\n        {\\n            return {-1,-1};\\n        }\\n        if(countone==0)\\n        {\\n            return {0,n-1};\\n        }\\n        int total=countone/3;\\n        int p1=0,p2=0,p3=0;\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                if(count==0)\\n                {\\n                    p1=i;\\n                }\\n                else if(count==total)\\n                {\\n                    p2=i;\\n                }\\n                else if(count==2*total)\\n                {\\n                    p3=i;\\n                }\\n                count+=1;\\n            }\\n        }\\n        while(p3<n-1)\\n        {\\n            p1+=1;\\n            p2+=1;\\n            p3+=1;\\n            if(arr[p1]!=arr[p2] || arr[p2]!=arr[p3] || arr[p1]!=arr[p3])\\n            {\\n                return {-1,-1};\\n            }\\n        }\\n        return {p1,p2+1};\\n    } \\n};\\n```\n```Python3 []\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        ones = [i for i, j in enumerate(arr) if j==1]\\n        n=len(ones)\\n\\n        if not ones:\\n            return [0, 2]\\n        if n%3:\\n            return [-1, -1]\\n        \\n        i,j,k = ones[0], ones[n//3], ones[n//3*2]\\n        l = len(arr)-k\\n\\n        if arr[i:i+l]==arr[j:j+l]==arr[k:k+l]:\\n            return [i+l-1, j+l]\\n\\n        return [-1, -1]\\n```\n```Java []\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int oneSum = 0;\\n        for(int x : arr) oneSum +=x;\\n        if(oneSum % 3 !=0)return new int[]{-1,-1};\\n        if(oneSum == 0)return new int[]{0,2};\\n        int oneCount = oneSum / 3;\\n        int i = 0;\\n        int firstOne = -1;\\n        int n= arr.length;\\n        int lastZeroCount = 0;\\n        i = n-1;\\n        while(arr[i] ==0){\\n            lastZeroCount++;\\n            i--;\\n        }\\n        i=0;\\n        while(oneCount > 0){\\n            if(arr[i] == 1 && firstOne == -1)firstOne = i;\\n            oneCount-=arr[i++];\\n        }\\n        while(lastZeroCount > 0){\\n            if(arr[i++] == 1)return new int[]{-1,-1};\\n            lastZeroCount--;\\n        }\\n        int k = i--;\\n        int t = firstOne;\\n        while(arr[k] == 0)k++;\\n        while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        int j = k;\\n        while(arr[k] == 0)k++;\\n        firstOne = t;\\n         while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        return new int[]{i,j};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110888,
                "title": "easy-c-solution-using-strings-in-o-n-time-and-space-complexity",
                "content": "# Intuition\\nThree Simple observations :-\\n1.Total number of ones should be multiple of 3.\\n2.Leading zeroes do not contribute\\n3.Number of zeroes after the last one of all 3 parts will be equal to the number of zeroes after the last one in 3rd part.\\n\\n# Approach\\n1.Store the indexes of ones in a vector and check if the size is multiple of 3.\\n2.Check if the zeroes after the last 1s of first and second part are greater than or equal to zeroes after the last one in 3rd part.\\n3.Form strings for all 3 parts ignoring leading zeroes and check if they are equal.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& v) {\\n        vector<int> one;\\n        int n=v.size();\\n        for(int i=0;i<n;i++){\\n            if(v[i]==1) one.push_back(i+1);\\n        }\\n        if(one.size()==0){\\n            return {0,2};\\n        }\\n        if(one.size()%3)    return {-1,-1};\\n\\n        int ext=n-one.back(),sz=one.size();\\n        int gap1=one[sz/3]-one[sz/3-1]-1,gap2=one[2*sz/3]-one[2*sz/3-1]-1;\\n        // cout<<gap1<<\" \"<<gap2<<endl;\\n        if(gap1<ext || gap2<ext)    return {-1,-1};\\n\\n        string s1,s2,s3;\\n        for(int i=0;i<=one[sz/3-1]+ext-1;i++){\\n            if(s1.length()>0 || v[i])   s1+=to_string(v[i]);\\n        }\\n\\n        for(int i=one[sz/3-1]+ext;i<=one[2*sz/3-1]+ext-1;i++){\\n            if(s2.length()>0 || v[i])   s2+=to_string(v[i]);\\n        }\\n\\n        for(int i=one[2*sz/3-1]+ext;i<=n-1;i++){\\n            if(s3.length()>0 || v[i])   s3+=to_string(v[i]);\\n        }\\n        //All 3 Numbers in vector v :-\\n        // num1={0,one[sz/3-1]+ext-1};\\n        // num2={one[sz/3-1]+ext,one[2*sz/3-1]+ext-1}\\n        // num3={one[2*sz/3-1]+ext,n-1};\\n        if(s1==s2 && s2==s3)    return {one[sz/3-1]+ext-1,one[2*sz/3-1]+ext};\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& v) {\\n        vector<int> one;\\n        int n=v.size();\\n        for(int i=0;i<n;i++){\\n            if(v[i]==1) one.push_back(i+1);\\n        }\\n        if(one.size()==0){\\n            return {0,2};\\n        }\\n        if(one.size()%3)    return {-1,-1};\\n\\n        int ext=n-one.back(),sz=one.size();\\n        int gap1=one[sz/3]-one[sz/3-1]-1,gap2=one[2*sz/3]-one[2*sz/3-1]-1;\\n        // cout<<gap1<<\" \"<<gap2<<endl;\\n        if(gap1<ext || gap2<ext)    return {-1,-1};\\n\\n        string s1,s2,s3;\\n        for(int i=0;i<=one[sz/3-1]+ext-1;i++){\\n            if(s1.length()>0 || v[i])   s1+=to_string(v[i]);\\n        }\\n\\n        for(int i=one[sz/3-1]+ext;i<=one[2*sz/3-1]+ext-1;i++){\\n            if(s2.length()>0 || v[i])   s2+=to_string(v[i]);\\n        }\\n\\n        for(int i=one[2*sz/3-1]+ext;i<=n-1;i++){\\n            if(s3.length()>0 || v[i])   s3+=to_string(v[i]);\\n        }\\n        //All 3 Numbers in vector v :-\\n        // num1={0,one[sz/3-1]+ext-1};\\n        // num2={one[sz/3-1]+ext,one[2*sz/3-1]+ext-1}\\n        // num3={one[2*sz/3-1]+ext,n-1};\\n        if(s1==s2 && s2==s3)    return {one[sz/3-1]+ext-1,one[2*sz/3-1]+ext};\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3065197,
                "title": "simple-python-solution-with-explanation",
                "content": "# Approach\\n\\n> *divide the array into three non-empty parts such that all of these parts represent the same binary value*\\n\\nSame binary value means \\n\\n* each part has to have **<ins>equal number of ones<ins>** and zeroes\\n* order of ones and zeroes should be same\\n\\n\\n### Part 1: Equal number of ones and ending zeroes\\n\\n\\nLets take below array as an example for understanding:\\n\\n![Untitled-2023-01-11-1852(17).png](https://assets.leetcode.com/users/images/e38a4680-1a58-495f-b448-dd8ed52ef478_1673977794.7565248.png)\\n\\n\\n* These binary values will have equal number of ones, which means the total count of ones should be a multiple of 3\\n\\n\\n    ![Untitled-2023-01-11-1852(18).png](https://assets.leetcode.com/users/images/3deeed2e-67fb-4081-84b4-21022fe00271_1673977804.008318.png)\\n\\n\\n\\n* We know in a binary number, starting zeroes doesnt matter, however ending zeroes does matter. So I can find the `ending_zeroes` for my binary number using the location of last one:\\n\\n    ![Untitled-2023-01-11-1852(14).png](https://assets.leetcode.com/users/images/e0b8d6c8-fb23-4a46-94da-3f0e5f9a73c9_1673977354.461905.png)\\n\\n\\n* We need to add these ending_zeroes count after every `total_count_of_ones // 3` ie in the example after every 3 count of ones\\n\\n    ![Untitled-2023-01-11-1852(16).png](https://assets.leetcode.com/users/images/cd4192ca-1d8e-47ed-a2ed-3ab48d0670f0_1673977459.8463302.png)\\n\\n* Now, we know the location of `i` and `j`\\n\\n\\n\\nNOTE:\\n    \\n* All above steps can be done by traversing through the loop, \\n\\n    however in my code below I have used prefix sum and binary search --> using modified binary_search to fetch index of the first occurrence in the prefix_sum \\n\\n    for example: \\n    ```\\n    ending_zeroes = n - 1 - (index of first occurrence of total_count_of_ones in prefix_sum, ie 9 in this example)\\n    ```\\n    \\n\\n    ![Untitled-2023-01-11-1852(15).png](https://assets.leetcode.com/users/images/50ef8629-2165-40b8-b3f4-303596ecb423_1673980808.0708501.png)\\n\\n\\n    Creation of prefix sum takes `O(n)` time, so no major optimisation with this, this just looked clean to me :)\\n\\n\\n\\n### Part 2: Order of ones and zeroes\\n\\nThis is simple, for each identified part\\n\\n* disregard starting zeroes\\n* then, check if order of each ones and zeroes is same\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + log(n))$$ = $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ - for prefix_sum\\n\\n# Code\\n\\n```python []\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n\\n        # part 1\\n\\n        # get total_count and create prefix_sum\\n        total_count = 0\\n        prefix_sum = [0] * n\\n        for i in range(n):\\n            total_count += arr[i]\\n            prefix_sum[i] = total_count\\n\\n        # checking if multiple of 3\\n        if total_count % 3 != 0:\\n            return [-1, -1]\\n        elif total_count == 0:\\n            return [0, n - 1]\\n\\n        # binary search to get first occurrence of `val` using prefix_sum\\n        def bin_search(val):\\n            start = 0\\n            end = n - 1\\n            mid = 0\\n\\n            while start <= end:\\n                mid = (start + end) // 2\\n                if prefix_sum[mid] >= val:\\n                    if start == end:\\n                        return mid\\n                    end = mid\\n                else:\\n                    start = mid + 1\\n\\n            return mid\\n\\n        \\n        # count of ones in each part and count of ending_zeroes\\n        part_count = total_count // 3\\n        ending_zeroes = n - 1 - bin_search(total_count)\\n\\n        # value of i and j using binary_search and ending_zeroes\\n        i = bin_search(part_count) + ending_zeroes + 1\\n        j = bin_search(total_count - part_count) + ending_zeroes + 1\\n\\n\\n\\n        # part 2\\n\\n        # disregard starting zeroes in first part\\n        a = 0\\n        while a < n and arr[a] == 0:\\n            a += 1\\n\\n        # disregard starting zeroes in second part\\n        b = i\\n        while b < n and arr[b] == 0:\\n            b += 1\\n\\n        # disregard starting zeroes in third part\\n        c = j\\n        while c < n and arr[c] == 0:\\n            c += 1\\n\\n        # check if indices have same order of ones and zeroes\\n        while c < n:\\n            if arr[a] == arr[b] and arr[b] == arr[c]:\\n                a += 1\\n                b += 1\\n                c += 1\\n            else:\\n                return [-1, -1]\\n\\n        if a == i and b == j:\\n            return [i - 1, j]\\n        else:\\n            return [-1, -1]\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n    ending_zeroes = n - 1 - (index of first occurrence of total_count_of_ones in prefix_sum, ie 9 in this example)\\n    ```\n```python []\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n\\n        # part 1\\n\\n        # get total_count and create prefix_sum\\n        total_count = 0\\n        prefix_sum = [0] * n\\n        for i in range(n):\\n            total_count += arr[i]\\n            prefix_sum[i] = total_count\\n\\n        # checking if multiple of 3\\n        if total_count % 3 != 0:\\n            return [-1, -1]\\n        elif total_count == 0:\\n            return [0, n - 1]\\n\\n        # binary search to get first occurrence of `val` using prefix_sum\\n        def bin_search(val):\\n            start = 0\\n            end = n - 1\\n            mid = 0\\n\\n            while start <= end:\\n                mid = (start + end) // 2\\n                if prefix_sum[mid] >= val:\\n                    if start == end:\\n                        return mid\\n                    end = mid\\n                else:\\n                    start = mid + 1\\n\\n            return mid\\n\\n        \\n        # count of ones in each part and count of ending_zeroes\\n        part_count = total_count // 3\\n        ending_zeroes = n - 1 - bin_search(total_count)\\n\\n        # value of i and j using binary_search and ending_zeroes\\n        i = bin_search(part_count) + ending_zeroes + 1\\n        j = bin_search(total_count - part_count) + ending_zeroes + 1\\n\\n\\n\\n        # part 2\\n\\n        # disregard starting zeroes in first part\\n        a = 0\\n        while a < n and arr[a] == 0:\\n            a += 1\\n\\n        # disregard starting zeroes in second part\\n        b = i\\n        while b < n and arr[b] == 0:\\n            b += 1\\n\\n        # disregard starting zeroes in third part\\n        c = j\\n        while c < n and arr[c] == 0:\\n            c += 1\\n\\n        # check if indices have same order of ones and zeroes\\n        while c < n:\\n            if arr[a] == arr[b] and arr[b] == arr[c]:\\n                a += 1\\n                b += 1\\n                c += 1\\n            else:\\n                return [-1, -1]\\n\\n        if a == i and b == j:\\n            return [i - 1, j]\\n        else:\\n            return [-1, -1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790358,
                "title": "c-o-n-time-complexity-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        // Time complexity - O(N)\\n\\t\\t\\n        int size = arr.size(), count=0, tcount=0, iptr=0, jptr=2;\\n        string str = \"\", t = \"\", h1 = \"\", h2 = \"\";\\n        vector<int>res(2,-1);\\n        for(int i=0;i<size;i++){\\n            str += (arr[i] ? \\'1\\' : \\'0\\');\\n            count += arr[i];\\n        }\\n        if(count == 0){\\n            res[0] = 0, res[1] = size-1;\\n            return res;\\n        }\\n        if(count%3) return res;\\n        count /= 3;\\n        reverse(str.begin(), str.end());\\n\\t\\t// reversed the string to easily process ending zeros of 3rd part in unreversed string\\n\\t\\t\\n        // find first part string for future comparision\\n        tcount = 0;\\n        for(int i=0;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n            jptr = i;\\n        }\\n        \\n        // find second string for comparision\\n        h1 = t, t = \"\";\\n        tcount = 0;\\n        for(int i=jptr+1;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n            iptr = i;\\n        }\\n        \\n        if(t.length() < h1.length()) return res;\\n        h2 = t.substr( (t.length()-h1.length()), h1.length() );\\n        \\n        if(h1 != h2) return res;\\n        jptr += t.length()-h1.length();\\n        \\n        // find last string for comparision\\n        t = \"\";\\n        tcount = 0;\\n        for(int i=iptr+1;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n        }\\n        \\n        if(t.length() < h1.length()) return res;\\n        h2 = t.substr( (t.length()-h1.length()), h1.length() );\\n        if(h1 != h2) return res;\\n        \\n        iptr += t.length()-h1.length();\\n        \\n        res[0] = size-1-(iptr+1);\\n        res[1] = size-1-jptr;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        // Time complexity - O(N)\\n\\t\\t\\n        int size = arr.size(), count=0, tcount=0, iptr=0, jptr=2;\\n        string str = \"\", t = \"\", h1 = \"\", h2 = \"\";\\n        vector<int>res(2,-1);\\n        for(int i=0;i<size;i++){\\n            str += (arr[i] ? \\'1\\' : \\'0\\');\\n            count += arr[i];\\n        }\\n        if(count == 0){\\n            res[0] = 0, res[1] = size-1;\\n            return res;\\n        }\\n        if(count%3) return res;\\n        count /= 3;\\n        reverse(str.begin(), str.end());\\n\\t\\t// reversed the string to easily process ending zeros of 3rd part in unreversed string\\n\\t\\t\\n        // find first part string for future comparision\\n        tcount = 0;\\n        for(int i=0;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n            jptr = i;\\n        }\\n        \\n        // find second string for comparision\\n        h1 = t, t = \"\";\\n        tcount = 0;\\n        for(int i=jptr+1;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n            iptr = i;\\n        }\\n        \\n        if(t.length() < h1.length()) return res;\\n        h2 = t.substr( (t.length()-h1.length()), h1.length() );\\n        \\n        if(h1 != h2) return res;\\n        jptr += t.length()-h1.length();\\n        \\n        // find last string for comparision\\n        t = \"\";\\n        tcount = 0;\\n        for(int i=iptr+1;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n        }\\n        \\n        if(t.length() < h1.length()) return res;\\n        h2 = t.substr( (t.length()-h1.length()), h1.length() );\\n        if(h1 != h2) return res;\\n        \\n        iptr += t.length()-h1.length();\\n        \\n        res[0] = size-1-(iptr+1);\\n        res[1] = size-1-jptr;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949754,
                "title": "python-faster-than-100-00",
                "content": "\\tdef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = arr.count(1)\\n        if ones == 0: return [0, 2]\\n        if ones % 3: return [-1, -1]\\n        ones_in_number = ones//3\\n        \\n        ones = 0\\n        start0 = i = arr.index(1)\\n        while(ones < ones_in_number):\\n            if arr[i]:\\n                ones+=1\\n            i+=1\\n            \\n        l = i-start0\\n        start1 = arr.index(1, start0+l)\\n        start2 = arr.index(1, start1+l)\\n\\n        l += len(arr)-(start2+l)\\n        \\n        if arr[start0:start0+l] == arr[start1:start1+l] == arr[start2:start2+l]:\\n            return [start0+l-1, start1+l]\\n        else:\\n            return [-1, -1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tdef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = arr.count(1)\\n        if ones == 0: return [0, 2]\\n        if ones % 3: return [-1, -1]\\n        ones_in_number = ones//3\\n        \\n        ones = 0\\n        start0 = i = arr.index(1)\\n        while(ones < ones_in_number):\\n            if arr[i]:\\n                ones+=1\\n            i+=1\\n            \\n        l = i-start0\\n        start1 = arr.index(1, start0+l)\\n        start2 = arr.index(1, start1+l)\\n\\n        l += len(arr)-(start2+l)\\n        \\n        if arr[start0:start0+l] == arr[start1:start1+l] == arr[start2:start2+l]:\\n            return [start0+l-1, start1+l]\\n        else:\\n            return [-1, -1]",
                "codeTag": "Python3"
            },
            {
                "id": 1938784,
                "title": "three-equal-parts-solution-java",
                "content": "class Solution {\\n  public int[] threeEqualParts(int[] A) {\\n    int ones = 0;\\n\\n    for (int a : A)\\n      if (a == 1)\\n        ++ones;\\n\\n    if (ones == 0)\\n      return new int[] {0, A.length - 1};\\n    if (ones % 3 != 0)\\n      return new int[] {-1, -1};\\n\\n    int k = ones / 3;\\n    int i = 0;\\n    int j = 0;\\n    int first = 0;\\n    int second = 0;\\n    int third = 0;\\n\\n    for (i = 0; i < A.length; ++i)\\n      if (A[i] == 1) {\\n        first = i;\\n        break;\\n      }\\n\\n    int gapOnes = k;\\n\\n    for (j = i + 1; j < A.length; ++j)\\n      if (A[j] == 1 && --gapOnes == 0) {\\n        second = j;\\n        break;\\n      }\\n\\n    gapOnes = k;\\n\\n    for (i = j + 1; i < A.length; ++i)\\n      if (A[i] == 1 && --gapOnes == 0) {\\n        third = i;\\n        break;\\n      }\\n\\n    while (third < A.length && A[first] == A[second] && A[second] == A[third]) {\\n      ++first;\\n      ++second;\\n      ++third;\\n    }\\n\\n    if (third == A.length)\\n      return new int[] {first - 1, second};\\n    return new int[] {-1, -1};\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\n  public int[] threeEqualParts(int[] A) {\\n    int ones = 0;\\n\\n    for (int a : A)\\n      if (a == 1)\\n        ++ones;\\n\\n    if (ones == 0)\\n      return new int[] {0, A.length - 1}",
                "codeTag": "Java"
            },
            {
                "id": 1737751,
                "title": "typescript-documented-to-be-easy-to-understand",
                "content": "```\\nfunction threeEqualParts(dd: number[]) {\\n  // Every part has to have the same number of digit 1, and so it must be divisible by 3.\\n  const countOnes = dd.reduce<number>((total, i) => total + (i === 1 ? 1 : 0), 0);\\n  if (countOnes === 0) return [0, 2];\\n  if (countOnes % 3 !== 0) return [-1, -1];\\n\\n  // Get inclusive indexes of the middle part, from 1 to 1. So in \"1010 101 0101\"\\n  // the indexes would be 4 to 6. Same number of 1s in each third.\\n  let [i, j] = (() => {\\n    let indexes = [];\\n    let ones = 0;\\n    for (let inx = 0; inx < dd.length && indexes.length < 2; inx++) {\\n      if (dd[inx] === 1) {\\n        ones++;\\n        if (ones === (countOnes * 2) / 3) indexes.push(inx);\\n        if (ones === countOnes / 3 + 1) indexes.push(inx);\\n      }\\n    }\\n    return [indexes[0], indexes[1]];\\n  })();\\n\\n  // Every number has to have the same number of zeros on the end as the last number.\\n  // Otherwise their values won\\'t be the same.\\n  const requiredZerosAtEnd = dd.length - dd.lastIndexOf(1, dd.length - 1) - 1;\\n\\n  // Try to adjust the middle number by incrementing j so it has proper number of 0s on\\n  // the end.\\n  const zerosRight = (inx: number) => {\\n    const nextOne = dd.indexOf(1, inx + 1);\\n    return nextOne === -1 ? dd.length - inx - 1 : nextOne - inx - 1;\\n  };\\n  if (zerosRight(j) >= requiredZerosAtEnd) {\\n    j += requiredZerosAtEnd;\\n  } else {\\n    return [-1, -1];\\n  }\\n\\n  // Try to adjust the first number by moving i so it has proper number of 0s on the end.\\n  const lastOneInFirstPart = dd.lastIndexOf(1, i - 1);\\n  if (zerosRight(lastOneInFirstPart) >= requiredZerosAtEnd) {\\n    i = lastOneInFirstPart + requiredZerosAtEnd + 1;\\n  } else {\\n    return [-1, -1];\\n  }\\n\\n  // Compare the three numbers, bit by bit, to see if they are the same.\\n  [i, j] = [i - 1, j + 1];\\n  let aStart = dd.indexOf(1, 0);\\n  let bStart = dd.indexOf(1, i + 1);\\n  let cStart = dd.indexOf(1, j);\\n  while (cStart !== dd.length) {\\n    if (dd[aStart] === dd[bStart] && dd[bStart] === dd[cStart]) {\\n      aStart++;\\n      bStart++;\\n      cStart++;\\n    } else return [-1, -1];\\n  }\\n  return [i, j];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction threeEqualParts(dd: number[]) {\\n  // Every part has to have the same number of digit 1, and so it must be divisible by 3.\\n  const countOnes = dd.reduce<number>((total, i) => total + (i === 1 ? 1 : 0), 0);\\n  if (countOnes === 0) return [0, 2];\\n  if (countOnes % 3 !== 0) return [-1, -1];\\n\\n  // Get inclusive indexes of the middle part, from 1 to 1. So in \"1010 101 0101\"\\n  // the indexes would be 4 to 6. Same number of 1s in each third.\\n  let [i, j] = (() => {\\n    let indexes = [];\\n    let ones = 0;\\n    for (let inx = 0; inx < dd.length && indexes.length < 2; inx++) {\\n      if (dd[inx] === 1) {\\n        ones++;\\n        if (ones === (countOnes * 2) / 3) indexes.push(inx);\\n        if (ones === countOnes / 3 + 1) indexes.push(inx);\\n      }\\n    }\\n    return [indexes[0], indexes[1]];\\n  })();\\n\\n  // Every number has to have the same number of zeros on the end as the last number.\\n  // Otherwise their values won\\'t be the same.\\n  const requiredZerosAtEnd = dd.length - dd.lastIndexOf(1, dd.length - 1) - 1;\\n\\n  // Try to adjust the middle number by incrementing j so it has proper number of 0s on\\n  // the end.\\n  const zerosRight = (inx: number) => {\\n    const nextOne = dd.indexOf(1, inx + 1);\\n    return nextOne === -1 ? dd.length - inx - 1 : nextOne - inx - 1;\\n  };\\n  if (zerosRight(j) >= requiredZerosAtEnd) {\\n    j += requiredZerosAtEnd;\\n  } else {\\n    return [-1, -1];\\n  }\\n\\n  // Try to adjust the first number by moving i so it has proper number of 0s on the end.\\n  const lastOneInFirstPart = dd.lastIndexOf(1, i - 1);\\n  if (zerosRight(lastOneInFirstPart) >= requiredZerosAtEnd) {\\n    i = lastOneInFirstPart + requiredZerosAtEnd + 1;\\n  } else {\\n    return [-1, -1];\\n  }\\n\\n  // Compare the three numbers, bit by bit, to see if they are the same.\\n  [i, j] = [i - 1, j + 1];\\n  let aStart = dd.indexOf(1, 0);\\n  let bStart = dd.indexOf(1, i + 1);\\n  let cStart = dd.indexOf(1, j);\\n  while (cStart !== dd.length) {\\n    if (dd[aStart] === dd[bStart] && dd[bStart] === dd[cStart]) {\\n      aStart++;\\n      bStart++;\\n      cStart++;\\n    } else return [-1, -1];\\n  }\\n  return [i, j];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575243,
                "title": "golang-c-solution",
                "content": "```go\\nfunc threeEqualParts(arr []int) []int {\\n\\t// remove all leading zeros if 1 exist\\n\\tremovedLeadingZero := 0\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tif arr[i] == 1 {\\n\\t\\t\\tremovedLeadingZero = i\\n\\t\\t\\tarr = arr[i:]\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\t// valid check\\n\\tif len(arr) < 3 {\\n\\t\\treturn []int{-1, -1}\\n\\t}\\n\\t// arr[0] equal to 0 means all value in arr is 0\\n\\tif arr[0] == 0 {\\n\\t\\treturn []int{0, 2}\\n\\t}\\n\\t// first non zero index from current to last index\\n\\tfirstNonZero := make([]int, len(arr))\\n\\tnonZeroIndex := math.MaxInt32\\n\\tfor i := len(arr) - 1; i >= 0; i-- {\\n\\t\\tif arr[i] == 1 {\\n\\t\\t\\tnonZeroIndex = i\\n\\t\\t}\\n\\t\\tfirstNonZero[i] = nonZeroIndex\\n\\t}\\nloop:\\n\\tfor end1 := 0; end1 < len(arr)-2; end1++ {\\n\\t\\tsize := end1 + 1\\n\\t\\tend2 := firstNonZero[end1+1] + end1\\n\\t\\tif end2 >= len(arr)-1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tend3 := firstNonZero[end2+1] + end1\\n\\t\\tif end3 != len(arr)-1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor i := 0; i < size; i++ {\\n\\t\\t\\tif arr[end1-i] != arr[end2-i] {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t\\tif arr[end1-i] != arr[end3-i] {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn []int{end1 + removedLeadingZero, end2 + 1 + removedLeadingZero}\\n\\t}\\n\\treturn []int{-1, -1}\\n}\\n```\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sizeOfOne = 0;\\n        for (auto &i : arr) {\\n            if (i == 1) {\\n                sizeOfOne++;\\n            }\\n        }\\n        if (sizeOfOne % 3 != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        if (sizeOfOne == 0) {\\n            return vector<int>{0, 2};\\n        }\\n        int currentSizeOfOne = 0;\\n        int end1 = 0;\\n        int end2 = 0;\\n        int end3 = 0;\\n        int prefixZero = -1;\\n        for (std::vector<int>::size_type i = 0; i < arr.size(); i++) {\\n            if (arr[i] == 1) {\\n                currentSizeOfOne++;\\n                if (prefixZero == -1) {\\n                    prefixZero = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne/3) {\\n                    end1 = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne/3*2) {\\n                    end2 = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne) {\\n                    end3 = i;\\n                }\\n            }\\n        }\\n        int suffixZero = static_cast<int>(arr.size() - 1) - end3;\\n        end1 += suffixZero;\\n        end2 += suffixZero;\\n        end3 += suffixZero;\\n        for (auto i = 0; i <= end1-prefixZero; i++) {\\n            if (arr[end1-i] != arr[end2-i] || arr[end1-i] != arr[end3-i]) {\\n                return vector<int>{-1, -1};\\n            }\\n        }\\n        return vector<int>{end1, end2+1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Go"
                ],
                "code": "```go\\nfunc threeEqualParts(arr []int) []int {\\n\\t// remove all leading zeros if 1 exist\\n\\tremovedLeadingZero := 0\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tif arr[i] == 1 {\\n\\t\\t\\tremovedLeadingZero = i\\n\\t\\t\\tarr = arr[i:]\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\t// valid check\\n\\tif len(arr) < 3 {\\n\\t\\treturn []int{-1, -1}\\n\\t}\\n\\t// arr[0] equal to 0 means all value in arr is 0\\n\\tif arr[0] == 0 {\\n\\t\\treturn []int{0, 2}\\n\\t}\\n\\t// first non zero index from current to last index\\n\\tfirstNonZero := make([]int, len(arr))\\n\\tnonZeroIndex := math.MaxInt32\\n\\tfor i := len(arr) - 1; i >= 0; i-- {\\n\\t\\tif arr[i] == 1 {\\n\\t\\t\\tnonZeroIndex = i\\n\\t\\t}\\n\\t\\tfirstNonZero[i] = nonZeroIndex\\n\\t}\\nloop:\\n\\tfor end1 := 0; end1 < len(arr)-2; end1++ {\\n\\t\\tsize := end1 + 1\\n\\t\\tend2 := firstNonZero[end1+1] + end1\\n\\t\\tif end2 >= len(arr)-1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tend3 := firstNonZero[end2+1] + end1\\n\\t\\tif end3 != len(arr)-1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor i := 0; i < size; i++ {\\n\\t\\t\\tif arr[end1-i] != arr[end2-i] {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t\\tif arr[end1-i] != arr[end3-i] {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn []int{end1 + removedLeadingZero, end2 + 1 + removedLeadingZero}\\n\\t}\\n\\treturn []int{-1, -1}\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sizeOfOne = 0;\\n        for (auto &i : arr) {\\n            if (i == 1) {\\n                sizeOfOne++;\\n            }\\n        }\\n        if (sizeOfOne % 3 != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        if (sizeOfOne == 0) {\\n            return vector<int>{0, 2};\\n        }\\n        int currentSizeOfOne = 0;\\n        int end1 = 0;\\n        int end2 = 0;\\n        int end3 = 0;\\n        int prefixZero = -1;\\n        for (std::vector<int>::size_type i = 0; i < arr.size(); i++) {\\n            if (arr[i] == 1) {\\n                currentSizeOfOne++;\\n                if (prefixZero == -1) {\\n                    prefixZero = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne/3) {\\n                    end1 = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne/3*2) {\\n                    end2 = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne) {\\n                    end3 = i;\\n                }\\n            }\\n        }\\n        int suffixZero = static_cast<int>(arr.size() - 1) - end3;\\n        end1 += suffixZero;\\n        end2 += suffixZero;\\n        end3 += suffixZero;\\n        for (auto i = 0; i <= end1-prefixZero; i++) {\\n            if (arr[end1-i] != arr[end2-i] || arr[end1-i] != arr[end3-i]) {\\n                return vector<int>{-1, -1};\\n            }\\n        }\\n        return vector<int>{end1, end2+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437060,
                "title": "c-easy",
                "content": "```\\n\\n```public:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n         int i,first,second,third,count=0,one=0;\\n        for(i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                count++;\\n            }\\n        }\\n        if(count==0)\\n        {\\n            return {0,2};\\n        }\\n        if(count%3!=0)\\n        {\\n            return {-1,-1};\\n        }\\n       int  n=count/3;\\n        for(i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                one++;\\n                if(one==1)\\n                {\\n                    first=i;\\n                }\\n                else if(one==n+1)\\n                {\\n                    second=i;\\n                }\\n                else if(one==(2*n)+1)\\n                {\\n                    third=i;\\n                }\\n            }\\n        }\\n        while(third<arr.size())\\n        {\\n            if(arr[first]==arr[second]&&arr[second]==arr[third])\\n            {\\n                first++;\\n                second++;\\n                third++;\\n            }\\n            else\\n            {\\n                return {-1,-1};\\n            }\\n        }\\n        return {first-1,second};\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348123,
                "title": "java-easy-o-n-1ms-with-comments",
                "content": "refactored  version :\\n```\\n    public int[] threeEqualParts(int[] arr) {\\n        int len=arr.length, onesCount=0;\\n        int[] fail = new int[]{-1,-1};  //error case return\\n      \\n        //every part of tree may have a variable number of zeros due to leading zeros, while\\n        //number of ones should be the same in all parts;\\n        //let\\'s count overall number of ones\\n        for(int a : arr)  \\n            onesCount+=a;\\n        \\n        //if overall number of ones can\\'t be divided equally between all three parts, then we return error\\n        if(onesCount%3!=0 )\\n            return fail;\\n        \\n        //in case of absence of ones, let\\'s return any possible combination\\n        if(onesCount==0)\\n            return new int[]{0,2};\\n\\n        int i,j,k,m,l;\\n        int partOnesCount =onesCount/3; //number of ones in a single part\\n        \\n        //let\\'s count trailing zeros in the latest part\\n        for(k=len-1;arr[k]!=1;k--);\\n        int trailingZeroesCount = len-1-k;\\n        \\n        //find beginning of the first part\\n        l = findBeg(0, partOnesCount, trailingZeroesCount, arr);\\n        if(l==-1)\\n            return fail;\\n\\n        //find beginning of the second part\\n        m = findBeg(l, partOnesCount, trailingZeroesCount, arr);\\n        if(m==-1)\\n            return fail;      \\n        \\n        for(i=--l,j=--m,k=len-1;i>=0 && j>l && k > m; i--,j--,k--)\\n            if(arr[i]!=arr[j] || arr[j]!=arr[k]) //check item by item in all tree parts, that exact sequence should be the same in all tree parts\\n                return fail;    \\n\\n        return new int[]{l,m+1};\\n    }\\n    \\n    private int findBeg(int i, int partOnesCount, int trailingZeroesCount, int[] arr){\\n        //shift i to the right by counting ones\\n        for(;partOnesCount!=0;i++)\\n            partOnesCount-=arr[i];\\n        \\n        //shift i to the right by counting trailing zeros\\n        for(;trailingZeroesCount>0;i++, trailingZeroesCount--)\\n            if(arr[i]!=0) //if we face non-zero value in trailing zeros area, the return error\\n                return -1;   \\n        \\n        return i; //return potential beginning of the binary representation\\n    }\\n```\\n\\noriginal version : \\n```\\n    public int[] threeEqualParts(int[] arr) {\\n        int len=arr.length, onesCount=0;\\n        int[] fail = new int[]{-1,-1};  //error case return\\n      \\n        //every part of tree may have a variable number of zeros due to leading zeros, while\\n        //number of ones should be the same in all parts;\\n        //let\\'s count overall number of ones\\n        for(int a : arr)  \\n            onesCount+=a;\\n        \\n        //if overall number of ones can\\'t be divided equally between all three parts, then we return error\\n        if(onesCount%3!=0 )\\n            return fail;\\n        \\n        //in case of absence of ones, let\\'s return any possible combination\\n        if(onesCount==0)\\n            return new int[]{0,2};\\n\\n        int i,j,k;\\n        int partOnesCount =onesCount/3; //number of ones in a single part\\n        \\n        //let\\'s count trailing zeros in the latest part\\n        for(k=len-1;arr[k]!=1;k--);\\n        int trailingZeroesCount = len-1-k;\\n        \\n        //shift i to the right by counting ones\\n        int leftOnesCount = partOnesCount;\\n        for(i=0;leftOnesCount!=0;i++)\\n            leftOnesCount-=arr[i];\\n        \\n        //shift i to the right by counting trailing zeros\\n        int leftTrailingZeros = trailingZeroesCount;\\n        for(;leftTrailingZeros>0;i++, leftTrailingZeros--)\\n            if(arr[i]!=0) //if we face non-zero value in trailing zeros area, the return error\\n                return fail;\\n        \\n        int l = i-1, m=i;\\n        //do the same with the middle part\\n        int middleOnesCount = onesCount/3;\\n        for(;middleOnesCount!=0;m++)\\n            middleOnesCount-=arr[m];\\n        \\n        int middleTrailingZeros = trailingZeroesCount;\\n        for(;middleTrailingZeros>0;m++, middleTrailingZeros--)\\n            if(arr[m]!=0)\\n                return fail;        \\n        \\n        m--; i = l; j = m; k = len-1;\\n        while(i>=0 && j>l && k > m){\\n            if(arr[i]!=arr[j] || arr[j]!=arr[k]) //check item by item, that exact sequence is the same in all tree parts\\n                return fail;    \\n            \\n            i--; j--; k--;\\n        }\\n        return new int[]{l,m+1};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] threeEqualParts(int[] arr) {\\n        int len=arr.length, onesCount=0;\\n        int[] fail = new int[]{-1,-1};  //error case return\\n      \\n        //every part of tree may have a variable number of zeros due to leading zeros, while\\n        //number of ones should be the same in all parts;\\n        //let\\'s count overall number of ones\\n        for(int a : arr)  \\n            onesCount+=a;\\n        \\n        //if overall number of ones can\\'t be divided equally between all three parts, then we return error\\n        if(onesCount%3!=0 )\\n            return fail;\\n        \\n        //in case of absence of ones, let\\'s return any possible combination\\n        if(onesCount==0)\\n            return new int[]{0,2};\\n\\n        int i,j,k,m,l;\\n        int partOnesCount =onesCount/3; //number of ones in a single part\\n        \\n        //let\\'s count trailing zeros in the latest part\\n        for(k=len-1;arr[k]!=1;k--);\\n        int trailingZeroesCount = len-1-k;\\n        \\n        //find beginning of the first part\\n        l = findBeg(0, partOnesCount, trailingZeroesCount, arr);\\n        if(l==-1)\\n            return fail;\\n\\n        //find beginning of the second part\\n        m = findBeg(l, partOnesCount, trailingZeroesCount, arr);\\n        if(m==-1)\\n            return fail;      \\n        \\n        for(i=--l,j=--m,k=len-1;i>=0 && j>l && k > m; i--,j--,k--)\\n            if(arr[i]!=arr[j] || arr[j]!=arr[k]) //check item by item in all tree parts, that exact sequence should be the same in all tree parts\\n                return fail;    \\n\\n        return new int[]{l,m+1};\\n    }\\n    \\n    private int findBeg(int i, int partOnesCount, int trailingZeroesCount, int[] arr){\\n        //shift i to the right by counting ones\\n        for(;partOnesCount!=0;i++)\\n            partOnesCount-=arr[i];\\n        \\n        //shift i to the right by counting trailing zeros\\n        for(;trailingZeroesCount>0;i++, trailingZeroesCount--)\\n            if(arr[i]!=0) //if we face non-zero value in trailing zeros area, the return error\\n                return -1;   \\n        \\n        return i; //return potential beginning of the binary representation\\n    }\\n```\n```\\n    public int[] threeEqualParts(int[] arr) {\\n        int len=arr.length, onesCount=0;\\n        int[] fail = new int[]{-1,-1};  //error case return\\n      \\n        //every part of tree may have a variable number of zeros due to leading zeros, while\\n        //number of ones should be the same in all parts;\\n        //let\\'s count overall number of ones\\n        for(int a : arr)  \\n            onesCount+=a;\\n        \\n        //if overall number of ones can\\'t be divided equally between all three parts, then we return error\\n        if(onesCount%3!=0 )\\n            return fail;\\n        \\n        //in case of absence of ones, let\\'s return any possible combination\\n        if(onesCount==0)\\n            return new int[]{0,2};\\n\\n        int i,j,k;\\n        int partOnesCount =onesCount/3; //number of ones in a single part\\n        \\n        //let\\'s count trailing zeros in the latest part\\n        for(k=len-1;arr[k]!=1;k--);\\n        int trailingZeroesCount = len-1-k;\\n        \\n        //shift i to the right by counting ones\\n        int leftOnesCount = partOnesCount;\\n        for(i=0;leftOnesCount!=0;i++)\\n            leftOnesCount-=arr[i];\\n        \\n        //shift i to the right by counting trailing zeros\\n        int leftTrailingZeros = trailingZeroesCount;\\n        for(;leftTrailingZeros>0;i++, leftTrailingZeros--)\\n            if(arr[i]!=0) //if we face non-zero value in trailing zeros area, the return error\\n                return fail;\\n        \\n        int l = i-1, m=i;\\n        //do the same with the middle part\\n        int middleOnesCount = onesCount/3;\\n        for(;middleOnesCount!=0;m++)\\n            middleOnesCount-=arr[m];\\n        \\n        int middleTrailingZeros = trailingZeroesCount;\\n        for(;middleTrailingZeros>0;m++, middleTrailingZeros--)\\n            if(arr[m]!=0)\\n                return fail;        \\n        \\n        m--; i = l; j = m; k = len-1;\\n        while(i>=0 && j>l && k > m){\\n            if(arr[i]!=arr[j] || arr[j]!=arr[k]) //check item by item, that exact sequence is the same in all tree parts\\n                return fail;    \\n            \\n            i--; j--; k--;\\n        }\\n        return new int[]{l,m+1};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344451,
                "title": "simple-o-n-logical-approach-explained-with-example",
                "content": "### Approach \\n*  The array has to contain number of 1\\'s that are multiple of 3\\n*  Each of the three parts has to contain equal number of ones\\n*  Now it\\'s all about locating the beginning of 1s, and comparing the parts\\n\\n### Example\\n```\\n    000010101010000101010100001010101      << example\\n    [0]*1[1,0]*[0]*1[1,0]*[0]*1[1,0]*      << pattern\\n        ^          ^          ^            << beginning of first 1 in each part\\n        <--n-->    <--n-->    <--n-->      << n = length of the last part \\n        left       middle     right        << left, middle, right parts whose value is to be compared\\n               ^          ^                << beginning of each part, having leading 0s\\n              i           j                << answer = end of first part, beginning of last part\\n```\\n\\n### Python3 Implementation\\n* `O(n)` time\\n\\t* one pass for counting 1\\'s\\n\\t* one pass for locating the first 1 of each part\\n\\t* one pass for comparing left, middle and right parts\\n* `O(1)` space \\n\\t* ignores space taken by string splicing\\n\\t* we can always do that in `O(1)` time with a little bit of extra lines of code\\n\\n```\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        ones = sum(arr)         # total count of 1\\'s\\n        \\n        # early termination conditions\\n        if ones % 3 != 0: return [-1, -1]\\n        if ones == 0:     return [0, len(arr)-1]\\n        \\n        cnt = 0                  # running count of 1\\'s\\n        target1 = 1              # first 1 of left part\\n        target2 = 1 + ones//3    # first 1 of middle part\\n        target3 = 1 + 2*ones//3  # first 1 of right part\\n        \\n        for idx, bit in enumerate(arr):\\n            if bit == 1:\\n                cnt += 1\\n                if cnt == target1: start1 = idx\\n                if cnt == target2: start2 = idx\\n                if cnt == target3: start3 = idx\\n\\n        n = len(arr) - start3\\n        if arr[start1 : start1+n] == arr[start2 : start2+n] == arr[start3 : start3+n]:\\n            return [start1 + n - 1, start2 + n]  \\n        \\n        return [-1, -1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    000010101010000101010100001010101      << example\\n    [0]*1[1,0]*[0]*1[1,0]*[0]*1[1,0]*      << pattern\\n        ^          ^          ^            << beginning of first 1 in each part\\n        <--n-->    <--n-->    <--n-->      << n = length of the last part \\n        left       middle     right        << left, middle, right parts whose value is to be compared\\n               ^          ^                << beginning of each part, having leading 0s\\n              i           j                << answer = end of first part, beginning of last part\\n```\n```\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        ones = sum(arr)         # total count of 1\\'s\\n        \\n        # early termination conditions\\n        if ones % 3 != 0: return [-1, -1]\\n        if ones == 0:     return [0, len(arr)-1]\\n        \\n        cnt = 0                  # running count of 1\\'s\\n        target1 = 1              # first 1 of left part\\n        target2 = 1 + ones//3    # first 1 of middle part\\n        target3 = 1 + 2*ones//3  # first 1 of right part\\n        \\n        for idx, bit in enumerate(arr):\\n            if bit == 1:\\n                cnt += 1\\n                if cnt == target1: start1 = idx\\n                if cnt == target2: start2 = idx\\n                if cnt == target3: start3 = idx\\n\\n        n = len(arr) - start3\\n        if arr[start1 : start1+n] == arr[start2 : start2+n] == arr[start3 : start3+n]:\\n            return [start1 + n - 1, start2 + n]  \\n        \\n        return [-1, -1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344385,
                "title": "three-equal-parts-java-solution",
                "content": "```\\n public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length ;\\n        List<Integer> ones=new ArrayList() ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(arr[i]>0)\\n            {\\n                ones.add(i) ;\\n            }\\n        }\\n        int cnt = ones.size() ;\\n        if(cnt == 0)\\n        {\\n            return new int[]{0 , n - 1} ;\\n        }\\n        if(cnt%3!=0)         \\n        {\\n            return new int[]{-1 , -1} ;\\n        }\\n        int f = ones.get(0);\\n        int s = ones.get(cnt/3);\\n        int t = ones.get((cnt/3)*2) ;\\n        while(t < n && arr[f] == arr[s] && arr[f] == arr[t])\\n        {\\n            f++ ;\\n            s++ ;\\n            t++ ;\\n        }\\n        if(t == n)\\n        {\\n            return new int[]{f - 1 , s} ;\\n        }\\n        return new int[]{-1 , -1} ;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length ;\\n        List<Integer> ones=new ArrayList() ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(arr[i]>0)\\n            {\\n                ones.add(i) ;\\n            }\\n        }\\n        int cnt = ones.size() ;\\n        if(cnt == 0)\\n        {\\n            return new int[]{0 , n - 1} ;\\n        }\\n        if(cnt%3!=0)         \\n        {\\n            return new int[]{-1 , -1} ;\\n        }\\n        int f = ones.get(0);\\n        int s = ones.get(cnt/3);\\n        int t = ones.get((cnt/3)*2) ;\\n        while(t < n && arr[f] == arr[s] && arr[f] == arr[t])\\n        {\\n            f++ ;\\n            s++ ;\\n            t++ ;\\n        }\\n        if(t == n)\\n        {\\n            return new int[]{f - 1 , s} ;\\n        }\\n        return new int[]{-1 , -1} ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1344263,
                "title": "c-clean-commented-for-easy-understanding",
                "content": "```\\n/*\\n\\tSuch approaches don\\'t come to our minds in one go. I had taken help for this solution. Tried to put\\n\\tcomments so that others can understand well.\\n\\tPersonally, Leetcode\\'s solution to this Qn and explanation are not written well. It seems like\\n\\ta mess and unreadable. I have tried to explain it with comments\\n*/\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n = arr.size();\\n        int sum = accumulate(begin(arr), end(arr), 0);\\n        \\n        if(sum == 0)\\n            return {0, n-1};\\n        else if(sum%3 != 0)\\n            return {-1, -1};\\n        \\n        int k = sum/3;\\n        //So every partition must have k 1\\'s\\n        //So let\\'s find three partitions having k 1\\'s and compare them bit by bit\\n        \\n        int start = -1, mid = -1, end = -1;\\n        int count = 0;\\n\\n        //[1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1,  1,  1,  1,  1,  1]\\n        for(int i = 0; i<n; i++) {\\n            if(arr[i] == 0) continue;\\n            \\n            count += arr[i];\\n            if(count > k) {\\n                count = 1;\\n            }\\n            \\n            if(count == 1) {\\n                if(start == -1) start = i;\\n                else if(mid == -1) mid = i;\\n                else if(end == -1) end = i;\\n                else break;\\n            }\\n        }\\n        \\n        /*\\n            we have found three sections and we have pointers to starting \\'1\\' of\\n            each section.\\n            we now compare them bit by bit\\n        */\\n        \\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]) {\\n            start++;  mid++;   end++;\\n        }\\n        \\n        //It means we couldn\\'t match all sections\\n        if(end != n)  return {-1, -1};\\n        \\n        return {start-1, mid};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tSuch approaches don\\'t come to our minds in one go. I had taken help for this solution. Tried to put\\n\\tcomments so that others can understand well.\\n\\tPersonally, Leetcode\\'s solution to this Qn and explanation are not written well. It seems like\\n\\ta mess and unreadable. I have tried to explain it with comments\\n*/\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n = arr.size();\\n        int sum = accumulate(begin(arr), end(arr), 0);\\n        \\n        if(sum == 0)\\n            return {0, n-1};\\n        else if(sum%3 != 0)\\n            return {-1, -1};\\n        \\n        int k = sum/3;\\n        //So every partition must have k 1\\'s\\n        //So let\\'s find three partitions having k 1\\'s and compare them bit by bit\\n        \\n        int start = -1, mid = -1, end = -1;\\n        int count = 0;\\n\\n        //[1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1,  1,  1,  1,  1,  1]\\n        for(int i = 0; i<n; i++) {\\n            if(arr[i] == 0) continue;\\n            \\n            count += arr[i];\\n            if(count > k) {\\n                count = 1;\\n            }\\n            \\n            if(count == 1) {\\n                if(start == -1) start = i;\\n                else if(mid == -1) mid = i;\\n                else if(end == -1) end = i;\\n                else break;\\n            }\\n        }\\n        \\n        /*\\n            we have found three sections and we have pointers to starting \\'1\\' of\\n            each section.\\n            we now compare them bit by bit\\n        */\\n        \\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]) {\\n            start++;  mid++;   end++;\\n        }\\n        \\n        //It means we couldn\\'t match all sections\\n        if(end != n)  return {-1, -1};\\n        \\n        return {start-1, mid};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344099,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> ans={-1,-1};\\n        int numOf1s = 0;\\n        for(int x:arr){\\n            numOf1s += x;\\n        }\\n        if(numOf1s == 0){\\n            return {0,2};\\n        }\\n        if(numOf1s % 3 != 0){\\n            return ans;\\n        }   \\n        int noOfOnesInEachPart = numOf1s / 3;\\n        int indexOfFirst1InPart0 = -1;\\n        int indexOfFirst1InPart1 = -1;\\n        int indexOfFirst1InPart2 = -1;\\n        numOf1s = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] == 1){\\n                numOf1s++;\\n                if(numOf1s == noOfOnesInEachPart + 1){\\n                    indexOfFirst1InPart1 = i;\\n                }else if(numOf1s == 2 * noOfOnesInEachPart + 1){\\n                    indexOfFirst1InPart2 = i;\\n                }else if(numOf1s == 1){\\n                    indexOfFirst1InPart0 = i;\\n                }\\n            }\\n        }\\n        while(indexOfFirst1InPart2 < arr.size()){\\n            if(arr[indexOfFirst1InPart0] == arr[indexOfFirst1InPart1] && arr[indexOfFirst1InPart1]==arr[indexOfFirst1InPart2]){\\n                indexOfFirst1InPart0++;\\n                indexOfFirst1InPart1++;\\n                indexOfFirst1InPart2++;\\n            }else{\\n                return ans;\\n            }\\n        }\\n        return {indexOfFirst1InPart0-1, indexOfFirst1InPart1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> ans={-1,-1};\\n        int numOf1s = 0;\\n        for(int x:arr){\\n            numOf1s += x;\\n        }\\n        if(numOf1s == 0){\\n            return {0,2};\\n        }\\n        if(numOf1s % 3 != 0){\\n            return ans;\\n        }   \\n        int noOfOnesInEachPart = numOf1s / 3;\\n        int indexOfFirst1InPart0 = -1;\\n        int indexOfFirst1InPart1 = -1;\\n        int indexOfFirst1InPart2 = -1;\\n        numOf1s = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] == 1){\\n                numOf1s++;\\n                if(numOf1s == noOfOnesInEachPart + 1){\\n                    indexOfFirst1InPart1 = i;\\n                }else if(numOf1s == 2 * noOfOnesInEachPart + 1){\\n                    indexOfFirst1InPart2 = i;\\n                }else if(numOf1s == 1){\\n                    indexOfFirst1InPart0 = i;\\n                }\\n            }\\n        }\\n        while(indexOfFirst1InPart2 < arr.size()){\\n            if(arr[indexOfFirst1InPart0] == arr[indexOfFirst1InPart1] && arr[indexOfFirst1InPart1]==arr[indexOfFirst1InPart2]){\\n                indexOfFirst1InPart0++;\\n                indexOfFirst1InPart1++;\\n                indexOfFirst1InPart2++;\\n            }else{\\n                return ans;\\n            }\\n        }\\n        return {indexOfFirst1InPart0-1, indexOfFirst1InPart1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344092,
                "title": "easy-c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        vector<int> res(2);\\n        res[0] = -1;\\n        res[1] = -1;\\n        \\n        int totalCountOne = 0;\\n        for(auto X: arr)\\n        {\\n            totalCountOne += X;\\n        }\\n        if(totalCountOne == 0)\\n        {\\n            res[0] = 0;\\n            res[1] = 2;\\n            return res;\\n        }   \\n        if((totalCountOne)%3 != 0)\\n        {\\n            return res;\\n        }\\n        \\n        int noOfOneInEachPart = totalCountOne/3;\\n        int idxOfFirstOneInPart0 = -1;\\n        int idxOfFirstOneInPart1 = -1;\\n        int idxOfFirstOneInPart2 = -1;\\n        int NoOfOnes = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                NoOfOnes++;\\n                if(NoOfOnes == 1)\\n                {\\n                    idxOfFirstOneInPart0 = i;\\n                }\\n                else if(NoOfOnes == noOfOneInEachPart + 1)\\n                {\\n                    idxOfFirstOneInPart1 = i;\\n                }\\n                else if(NoOfOnes == 2*noOfOneInEachPart + 1)\\n                {\\n                    idxOfFirstOneInPart2 = i;\\n                }\\n            }\\n        }\\n        while(idxOfFirstOneInPart2<n)\\n        {\\n            if(arr[idxOfFirstOneInPart2] == arr[idxOfFirstOneInPart1] && arr[idxOfFirstOneInPart2] == arr[idxOfFirstOneInPart0])\\n            {\\n                idxOfFirstOneInPart0++;\\n                idxOfFirstOneInPart2++;\\n                idxOfFirstOneInPart1++;\\n            }\\n            else\\n            {\\n                return res;\\n            }\\n            \\n        }\\n        res[0] = idxOfFirstOneInPart0-1;\\n        res[1] = idxOfFirstOneInPart1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        vector<int> res(2);\\n        res[0] = -1;\\n        res[1] = -1;\\n        \\n        int totalCountOne = 0;\\n        for(auto X: arr)\\n        {\\n            totalCountOne += X;\\n        }\\n        if(totalCountOne == 0)\\n        {\\n            res[0] = 0;\\n            res[1] = 2;\\n            return res;\\n        }   \\n        if((totalCountOne)%3 != 0)\\n        {\\n            return res;\\n        }\\n        \\n        int noOfOneInEachPart = totalCountOne/3;\\n        int idxOfFirstOneInPart0 = -1;\\n        int idxOfFirstOneInPart1 = -1;\\n        int idxOfFirstOneInPart2 = -1;\\n        int NoOfOnes = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                NoOfOnes++;\\n                if(NoOfOnes == 1)\\n                {\\n                    idxOfFirstOneInPart0 = i;\\n                }\\n                else if(NoOfOnes == noOfOneInEachPart + 1)\\n                {\\n                    idxOfFirstOneInPart1 = i;\\n                }\\n                else if(NoOfOnes == 2*noOfOneInEachPart + 1)\\n                {\\n                    idxOfFirstOneInPart2 = i;\\n                }\\n            }\\n        }\\n        while(idxOfFirstOneInPart2<n)\\n        {\\n            if(arr[idxOfFirstOneInPart2] == arr[idxOfFirstOneInPart1] && arr[idxOfFirstOneInPart2] == arr[idxOfFirstOneInPart0])\\n            {\\n                idxOfFirstOneInPart0++;\\n                idxOfFirstOneInPart2++;\\n                idxOfFirstOneInPart1++;\\n            }\\n            else\\n            {\\n                return res;\\n            }\\n            \\n        }\\n        res[0] = idxOfFirstOneInPart0-1;\\n        res[1] = idxOfFirstOneInPart1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344011,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int count = 0;\\n        for (auto i:arr)\\n        {\\n            if(i == 1)\\n                count++;\\n        }\\n        if(count == 0)\\n            return {0,2};\\n        if(count%3 != 0)\\n            return {-1,-1};\\n        int p1 = 0;\\n        int p2 = 0;\\n        int p3 = 0;\\n        count = count/3;\\n        int temp = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {  if(arr[i] == 1)\\n          { if(temp == 0)\\n              p1 = i;\\n            else if(temp == count)\\n                p2 = i;\\n             else if(temp == 2*count)\\n                p3 = i;\\n           temp++;\\n          }\\n        }\\n        int oldp2 = p2;\\n        int oldp3 = p3;\\n        while(p1<oldp2 and p2<oldp3 and p3<arr.size())\\n        {\\n            if(arr[p1] != arr[p2] or arr[p2] != arr[p3])\\n                return {-1,-1};\\n            p1++;\\n            p2++;\\n            p3++;\\n        }\\n        if(p3 == arr.size())\\n        {\\n            return {p1-1,p2};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int count = 0;\\n        for (auto i:arr)\\n        {\\n            if(i == 1)\\n                count++;\\n        }\\n        if(count == 0)\\n            return {0,2};\\n        if(count%3 != 0)\\n            return {-1,-1};\\n        int p1 = 0;\\n        int p2 = 0;\\n        int p3 = 0;\\n        count = count/3;\\n        int temp = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {  if(arr[i] == 1)\\n          { if(temp == 0)\\n              p1 = i;\\n            else if(temp == count)\\n                p2 = i;\\n             else if(temp == 2*count)\\n                p3 = i;\\n           temp++;\\n          }\\n        }\\n        int oldp2 = p2;\\n        int oldp3 = p3;\\n        while(p1<oldp2 and p2<oldp3 and p3<arr.size())\\n        {\\n            if(arr[p1] != arr[p2] or arr[p2] != arr[p3])\\n                return {-1,-1};\\n            p1++;\\n            p2++;\\n            p3++;\\n        }\\n        if(p3 == arr.size())\\n        {\\n            return {p1-1,p2};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343923,
                "title": "linear-times-o-n-solution-in-python-clean",
                "content": "```\\n# Github: Shantanugupta1118\\n# DAY 60 of DAY 100\\n# 927. Three Equal Parts  -  Leetcode/July\\n# https://leetcode.com/problems/three-equal-parts/\\n\\n\\nclass Solution:\\n    def threeEqualParts(self, arr):\\n        ans = [-1,-1]\\n        numsOf1s = 0\\n        for i in arr:\\n            numsOf1s += i\\n        if numsOf1s == 0:\\n            return [0,2]\\n        if numsOf1s%3 != 0:\\n            return ans\\n        \\n        eachPart = numsOf1s//3\\n        index0, index1, index2 = -1, -1, -1\\n        numsOf1s = 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                numsOf1s += 1\\n                if numsOf1s == eachPart+1:\\n                    index1 = i\\n                elif numsOf1s == 2*eachPart+1:\\n                    index2 = i\\n                elif numsOf1s == 1:\\n                    index0 = i\\n        while index2 < len(arr):\\n            if arr[index2] == arr[index0] and arr[index2] == arr[index1]:\\n                index0 += 1\\n                index1 += 1\\n                index2 += 1\\n            else:\\n                return ans \\n        return [index0-1, index1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Github: Shantanugupta1118\\n# DAY 60 of DAY 100\\n# 927. Three Equal Parts  -  Leetcode/July\\n# https://leetcode.com/problems/three-equal-parts/\\n\\n\\nclass Solution:\\n    def threeEqualParts(self, arr):\\n        ans = [-1,-1]\\n        numsOf1s = 0\\n        for i in arr:\\n            numsOf1s += i\\n        if numsOf1s == 0:\\n            return [0,2]\\n        if numsOf1s%3 != 0:\\n            return ans\\n        \\n        eachPart = numsOf1s//3\\n        index0, index1, index2 = -1, -1, -1\\n        numsOf1s = 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                numsOf1s += 1\\n                if numsOf1s == eachPart+1:\\n                    index1 = i\\n                elif numsOf1s == 2*eachPart+1:\\n                    index2 = i\\n                elif numsOf1s == 1:\\n                    index0 = i\\n        while index2 < len(arr):\\n            if arr[index2] == arr[index0] and arr[index2] == arr[index1]:\\n                index0 += 1\\n                index1 += 1\\n                index2 += 1\\n            else:\\n                return ans \\n        return [index0-1, index1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343905,
                "title": "pretty-short-java-solution-15-lines-explained",
                "content": "The idea is to count the number of ones `numOnes`: \\n\\nIf `numOnes` isn\\'t divisible by 3, then you can\\'t divide them into 3 parts so return [-1, -1]. \\n\\nSecondly, if there are only zeroes in the array, you can divide the array arbitrarily.\\n\\nFinally, if `numOnes` is divisible by 3, we run three pointers `first, second and third` and check whether the division is possible.\\n\\n`first` points to the First One of the array, `second` points to the `numOnes/3`th One of the array, and `third` points to the `2*numOnes/3`th One of the array.\\nAdvance the three pointer, if there is a mismatch at any step, return [-1, -1].\\nIf the `third` pointer finally manages to reach the end, we have a valid division, because everything matched!\\n\\nWhat I said in code:\\n```java\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int numOnes = 0;\\n        List<Integer> pos = new ArrayList<>();\\n        for(int i = 0; i < arr.length; i++){\\n            numOnes += arr[i];\\n            if(arr[i] == 1) pos.add(i);\\n        }\\n        if(numOnes % 3 != 0) return new int[]{-1, -1};\\n        if(numOnes == 0) return new int[]{0, arr.length-1};\\n        int first = pos.get(0), second = pos.get(numOnes/3), third = pos.get(numOnes/3 *2);\\n        while(first < second && second < third && third < arr.length){\\n            if(arr[first] != arr[second] || arr[second] != arr[third]) return new int[]{-1, -1};\\n            first++; second++; third++;\\n        }\\n        return third == arr.length ? new int[]{first-1, second} : new int[]{-1, -1};\\n    }\\n}\\n```\\nOkay, not 15 lines, it\\'s 18. You can probably sue me for that ;)\\nBut I hope you understand how the solution works.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int numOnes = 0;\\n        List<Integer> pos = new ArrayList<>();\\n        for(int i = 0; i < arr.length; i++){\\n            numOnes += arr[i];\\n            if(arr[i] == 1) pos.add(i);\\n        }\\n        if(numOnes % 3 != 0) return new int[]{-1, -1};\\n        if(numOnes == 0) return new int[]{0, arr.length-1};\\n        int first = pos.get(0), second = pos.get(numOnes/3), third = pos.get(numOnes/3 *2);\\n        while(first < second && second < third && third < arr.length){\\n            if(arr[first] != arr[second] || arr[second] != arr[third]) return new int[]{-1, -1};\\n            first++; second++; third++;\\n        }\\n        return third == arr.length ? new int[]{first-1, second} : new int[]{-1, -1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343855,
                "title": "o-n-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> ans{-1,-1};\\n        int count=0,ones=0,p1=0,p2=0,p3=0;\\n        for(int i=0; i<arr.size();i++){\\n            count+=arr[i];\\n        }\\n        if(count%3) return ans;\\n        if(count==0){\\n            ans[0] = 0;\\n            ans[1] = arr.size()-1;\\n            return ans;\\n        }\\n        count/=3;\\n        for(int i=0; i<arr.size(); i++){\\n            if(arr[i]==1){\\n                if(ones==0) p1 = i;\\n                else if(ones==count) p2 = i;\\n                else if(ones==2*count) p3 = i;\\n                ones++;\\n            }\\n        }\\n        int op2=p2,op3=p3;\\n        while(p1<op2 && p2<op3 && p3<arr.size()){\\n            if(arr[p1]!= arr[p2] || arr[p2]!=arr[p3]) return ans;\\n            p1++; p2++; p3++;\\n        }\\n        if(p3!=arr.size()) return ans;\\n        \\n        ans[0] = p1-1;\\n        ans[1] = p2;\\n        return ans;\\n    }\\n};\\n```\\nInspired from :- https://leetcode.com/problems/three-equal-parts/discuss/1343568/C%2B%2B-O(n)-time-and-O(1)-space",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> ans{-1,-1};\\n        int count=0,ones=0,p1=0,p2=0,p3=0;\\n        for(int i=0; i<arr.size();i++){\\n            count+=arr[i];\\n        }\\n        if(count%3) return ans;\\n        if(count==0){\\n            ans[0] = 0;\\n            ans[1] = arr.size()-1;\\n            return ans;\\n        }\\n        count/=3;\\n        for(int i=0; i<arr.size(); i++){\\n            if(arr[i]==1){\\n                if(ones==0) p1 = i;\\n                else if(ones==count) p2 = i;\\n                else if(ones==2*count) p3 = i;\\n                ones++;\\n            }\\n        }\\n        int op2=p2,op3=p3;\\n        while(p1<op2 && p2<op3 && p3<arr.size()){\\n            if(arr[p1]!= arr[p2] || arr[p2]!=arr[p3]) return ans;\\n            p1++; p2++; p3++;\\n        }\\n        if(p3!=arr.size()) return ans;\\n        \\n        ans[0] = p1-1;\\n        ans[1] = p2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343847,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn three_equal_parts(arr: Vec<i32>) -> Vec<i32> {\\n        let v = arr\\n            .iter()\\n            .enumerate()\\n            .filter_map(|(i, &a)| if a == 1 { Some(i) } else { None })\\n            .collect::<Vec<_>>();\\n        if arr.len() < 3 || v.len() % 3 != 0 {\\n            return [-1, -1].to_vec();\\n        }\\n        if v.is_empty() {\\n            return [0, 2].to_vec();\\n        }\\n        let chunks = v.chunks(v.len() / 3).collect::<Vec<_>>();\\n        let i = chunks[0][v.len() / 3 - 1] + arr.len() - v[v.len() - 1] - 1;\\n        let j = chunks[1][v.len() / 3 - 1] + arr.len() - v[v.len() - 1];\\n        if arr.len() - chunks[2][0] > j - i - 1 || arr.len() - chunks[2][0] > i + 1 {\\n            return [-1, -1].to_vec();\\n        }\\n        for k in 0..(i + 1).min(j - i - 1).min(arr.len() - j) {\\n            if arr[i - k] != arr[j - 1 - k] || arr[i - k] != arr[arr.len() - 1 - k] {\\n                return [-1, -1].to_vec();\\n            }\\n        }\\n        [i as i32, j as i32].to_vec()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn three_equal_parts(arr: Vec<i32>) -> Vec<i32> {\\n        let v = arr\\n            .iter()\\n            .enumerate()\\n            .filter_map(|(i, &a)| if a == 1 { Some(i) } else { None })\\n            .collect::<Vec<_>>();\\n        if arr.len() < 3 || v.len() % 3 != 0 {\\n            return [-1, -1].to_vec();\\n        }\\n        if v.is_empty() {\\n            return [0, 2].to_vec();\\n        }\\n        let chunks = v.chunks(v.len() / 3).collect::<Vec<_>>();\\n        let i = chunks[0][v.len() / 3 - 1] + arr.len() - v[v.len() - 1] - 1;\\n        let j = chunks[1][v.len() / 3 - 1] + arr.len() - v[v.len() - 1];\\n        if arr.len() - chunks[2][0] > j - i - 1 || arr.len() - chunks[2][0] > i + 1 {\\n            return [-1, -1].to_vec();\\n        }\\n        for k in 0..(i + 1).min(j - i - 1).min(arr.len() - j) {\\n            if arr[i - k] != arr[j - 1 - k] || arr[i - k] != arr[arr.len() - 1 - k] {\\n                return [-1, -1].to_vec();\\n            }\\n        }\\n        [i as i32, j as i32].to_vec()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343435,
                "title": "three-equal-parts-python-logic-building",
                "content": "Key obseration is that three parts must have same number and pattern of 1s except the leading 0s part. \\nMy idea is to:\\n\\n1.  Count no. of ones, simply taking sum. (if sum%3!=0 return [-1,-1])\\n2.  Search from right side to left, until we found sum/3 of 1s. This index defines the pattern of 1s.\\n3.  From left, ignore leading 0s, and then match the pattern found in step 2, to get the first EndIndex.\\n4.  Similary, do another matching to found second EndIndex.\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n=len(arr)\\n        x=sum(arr)  #gives no. of 1s\\n        if x==0:\\n            return [0,2]\\n        elif x%3!=0:\\n            return [-1,-1]\\n        \\n        # finding index of starting 1 of third string\\n        idx3=0\\n        count=0\\n        for i in range(n-1,-1,-1):\\n            if arr[i]==1:\\n                count+=1\\n                if count==x//3:\\n                    idx3=i\\n                    break\\n        \\n        idx1=endIdx(arr,0,idx3)\\n        if idx1<0:\\n            return [-1,-1]\\n        \\n        idx2=endIdx(arr,idx1+1,idx3)\\n        if idx2<0:\\n            return [-1,-1]\\n        \\n        return [idx1,idx2+1]\\n    \\n#  here, idx3 is index of pattern to compare to.\\n#  return endIdx of start pattern that matches idx3 side.\\ndef endIdx(arr, start, idx3):\\n    while arr[start]==0:\\n        start+=1\\n    while idx3<len(arr):\\n        if arr[start]!=arr[idx3]:\\n            return -1\\n        start+=1\\n        idx3+=1\\n    return start-1\\n```\\n*If case of any doubt or suggestion, do comment.*\\n\\n***Happy Coding* :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n=len(arr)\\n        x=sum(arr)  #gives no. of 1s\\n        if x==0:\\n            return [0,2]\\n        elif x%3!=0:\\n            return [-1,-1]\\n        \\n        # finding index of starting 1 of third string\\n        idx3=0\\n        count=0\\n        for i in range(n-1,-1,-1):\\n            if arr[i]==1:\\n                count+=1\\n                if count==x//3:\\n                    idx3=i\\n                    break\\n        \\n        idx1=endIdx(arr,0,idx3)\\n        if idx1<0:\\n            return [-1,-1]\\n        \\n        idx2=endIdx(arr,idx1+1,idx3)\\n        if idx2<0:\\n            return [-1,-1]\\n        \\n        return [idx1,idx2+1]\\n    \\n#  here, idx3 is index of pattern to compare to.\\n#  return endIdx of start pattern that matches idx3 side.\\ndef endIdx(arr, start, idx3):\\n    while arr[start]==0:\\n        start+=1\\n    while idx3<len(arr):\\n        if arr[start]!=arr[idx3]:\\n            return -1\\n        start+=1\\n        idx3+=1\\n    return start-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343434,
                "title": "python-binarysearch-o-nlogn-slow-but-viable-solution",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        ps = []\\n        cur = 0\\n        for x in arr:\\n            cur <<= 1\\n            cur += x\\n            ps.append(cur)\\n        # print(ps[-1])\\n        for i in range(n-1):\\n            a = ps[i]\\n            l,r = i+1,n-1\\n            cnt = 0\\n            while l<r:\\n                cnt += 1\\n                mid = (l+r)//2\\n                b = ps[mid]-(ps[i] << (mid-i))\\n                if b<a:\\n                    l = mid + 1\\n                elif b>a:\\n                    r = mid\\n                else:\\n                    c = ps[n-1]-(ps[mid] << (n-1-mid))\\n                    if c==b:\\n                        return [i,mid+1]\\n                    else:\\n                        l = r\\n        return [-1,-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        ps = []\\n        cur = 0\\n        for x in arr:\\n            cur <<= 1\\n            cur += x\\n            ps.append(cur)\\n        # print(ps[-1])\\n        for i in range(n-1):\\n            a = ps[i]\\n            l,r = i+1,n-1\\n            cnt = 0\\n            while l<r:\\n                cnt += 1\\n                mid = (l+r)//2\\n                b = ps[mid]-(ps[i] << (mid-i))\\n                if b<a:\\n                    l = mid + 1\\n                elif b>a:\\n                    r = mid\\n                else:\\n                    c = ps[n-1]-(ps[mid] << (n-1-mid))\\n                    if c==b:\\n                        return [i,mid+1]\\n                    else:\\n                        l = r\\n        return [-1,-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343373,
                "title": "javascript-84ms",
                "content": "Approximately 1.33N operations => O(N).\\n\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar threeEqualParts = function (arr) {\\n  const gaps = []\\n  let head0s = 0\\n  let prev\\n  for (let p = 0; p < arr.length; p++) {\\n    if (arr[p] === 1) {\\n      if (prev !== undefined) {\\n        gaps.push(p - prev)\\n      }\\n      prev = p\\n    } else if (prev === undefined) {\\n      head0s++\\n    }\\n  }\\n  if (head0s === arr.length) {\\n    return [0, 2]\\n  }\\n  if (gaps.length % 3 !== 2) {\\n    return [-1, -1]\\n  }\\n  const groupLen = (gaps.length - 2) / 3\\n  let groupSum = 0\\n  for (let q = 0; q < groupLen; q++) {\\n    if (\\n      gaps[q] !== gaps[q + groupLen + 1] ||\\n      gaps[q] !== gaps[q + 2 * groupLen + 2]\\n    ) {\\n      return [-1, -1]\\n    }\\n    groupSum += gaps[q]\\n  }\\n  const tail0s = arr.length -\\n    head0s -\\n    groupSum * 3 -\\n    gaps[groupLen] -\\n    gaps[2 * groupLen + 1] -\\n    1\\n  if (gaps[groupLen] - 1 < tail0s || gaps[2 * groupLen + 1] - 1 < tail0s) {\\n    return [-1, -1]\\n  }\\n  const i = head0s + groupSum + tail0s\\n  const j = i + gaps[groupLen] + groupSum + 1\\n  return [i, j]\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar threeEqualParts = function (arr) {\\n  const gaps = []\\n  let head0s = 0\\n  let prev\\n  for (let p = 0; p < arr.length; p++) {\\n    if (arr[p] === 1) {\\n      if (prev !== undefined) {\\n        gaps.push(p - prev)\\n      }\\n      prev = p\\n    } else if (prev === undefined) {\\n      head0s++\\n    }\\n  }\\n  if (head0s === arr.length) {\\n    return [0, 2]\\n  }\\n  if (gaps.length % 3 !== 2) {\\n    return [-1, -1]\\n  }\\n  const groupLen = (gaps.length - 2) / 3\\n  let groupSum = 0\\n  for (let q = 0; q < groupLen; q++) {\\n    if (\\n      gaps[q] !== gaps[q + groupLen + 1] ||\\n      gaps[q] !== gaps[q + 2 * groupLen + 2]\\n    ) {\\n      return [-1, -1]\\n    }\\n    groupSum += gaps[q]\\n  }\\n  const tail0s = arr.length -\\n    head0s -\\n    groupSum * 3 -\\n    gaps[groupLen] -\\n    gaps[2 * groupLen + 1] -\\n    1\\n  if (gaps[groupLen] - 1 < tail0s || gaps[2 * groupLen + 1] - 1 < tail0s) {\\n    return [-1, -1]\\n  }\\n  const i = head0s + groupSum + tail0s\\n  const j = i + gaps[groupLen] + groupSum + 1\\n  return [i, j]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343246,
                "title": "swift-solution",
                "content": "1. Count ones in `arr`\\n2. If there is no ones in `arr`, then all parts are zeros\\n3. Ones count must be multiple of three, else it is not possible to split `arr` into three parts\\n4. Find first significant bit for each part in `arr`\\n5. The last part ends at the end of `arr`, it has a reference length. Check that the length of the first two parts is not less than the reference one.\\n6. Check the equality of the three parts\\n\\nTime complexity O(n), space complexity O(1)\\n\\nUpdate: simplified reduce, as [@Legonaftik](https://leetcode.com/Legonaftik/) suggested\\n```\\nclass Solution {\\n    func threeEqualParts(_ arr: [Int]) -> [Int] {\\n        let n = arr.count, ones = arr.reduce(0, +), partOnes = ones / 3\\n        guard ones > 0 else { return [0, 2] } // all parts are zeros\\n        guard ones % 3 == 0 else { return [-1, -1] } // it is not possible to split into three parts\\n\\n        var starts = [Int](repeating: -1, count: 3), runningOnes = 0\\n        for i in 0..<n where arr[i] == 1 {\\n            let part = runningOnes / partOnes // 0...2\\n            if starts[part] == -1 {\\n                starts[part] = i\\n            }\\n            runningOnes += 1\\n        }\\n\\n        let len = n - starts[2]\\n\\n        guard starts[1] - starts[0] >= len && starts[2] - starts[1] >= len else { return [-1, -1] }\\n\\n        // check if three parts are equal\\n        for l in 0..<len where arr[starts[0] + l] != arr[starts[1] + l] || arr[starts[0] + l] != arr[starts[2] + l] {\\n            return [-1, -1]\\n        }\\n        \\n        return [starts[0] + len - 1, starts[1] + len]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func threeEqualParts(_ arr: [Int]) -> [Int] {\\n        let n = arr.count, ones = arr.reduce(0, +), partOnes = ones / 3\\n        guard ones > 0 else { return [0, 2] } // all parts are zeros\\n        guard ones % 3 == 0 else { return [-1, -1] } // it is not possible to split into three parts\\n\\n        var starts = [Int](repeating: -1, count: 3), runningOnes = 0\\n        for i in 0..<n where arr[i] == 1 {\\n            let part = runningOnes / partOnes // 0...2\\n            if starts[part] == -1 {\\n                starts[part] = i\\n            }\\n            runningOnes += 1\\n        }\\n\\n        let len = n - starts[2]\\n\\n        guard starts[1] - starts[0] >= len && starts[2] - starts[1] >= len else { return [-1, -1] }\\n\\n        // check if three parts are equal\\n        for l in 0..<len where arr[starts[0] + l] != arr[starts[1] + l] || arr[starts[0] + l] != arr[starts[2] + l] {\\n            return [-1, -1]\\n        }\\n        \\n        return [starts[0] + len - 1, starts[1] + len]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343237,
                "title": "three-equal-parts-python-solution-o-n",
                "content": "```python\\n\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = []\\n        for i,num in enumerate(arr):\\n            if num == 1:\\n                ones.append(i)\\n        \\n        if len(ones) == 0:\\n            return [0,len(arr)-1]\\n        \\n        if len(ones) < 3 or len(ones)%3 > 0:\\n            return [-1, -1]\\n        \\n        endZeros = len(arr)-ones[-1]-1 \\n        l1 = ones[0]\\n        l2 = ones[len(ones)//3 -1]\\n        m1 = ones[len(ones)//3]\\n        m2 = ones[2*len(ones)//3-1]\\n        r1 = ones[2*len(ones)//3]\\n        r2 = ones[-1]\\n        \\n        if arr[l1:l2+1+endZeros] == arr[m1:m2+1+endZeros] and arr[m1:m2+1+endZeros] == arr[r1:]:\\n            \\n            return [l2+endZeros,m2+1+endZeros]\\n            \\n            \\n        return [-1,-1]\\n```",
                "solutionTags": [],
                "code": "```python\\n\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = []\\n        for i,num in enumerate(arr):\\n            if num == 1:\\n                ones.append(i)\\n        \\n        if len(ones) == 0:\\n            return [0,len(arr)-1]\\n        \\n        if len(ones) < 3 or len(ones)%3 > 0:\\n            return [-1, -1]\\n        \\n        endZeros = len(arr)-ones[-1]-1 \\n        l1 = ones[0]\\n        l2 = ones[len(ones)//3 -1]\\n        m1 = ones[len(ones)//3]\\n        m2 = ones[2*len(ones)//3-1]\\n        r1 = ones[2*len(ones)//3]\\n        r2 = ones[-1]\\n        \\n        if arr[l1:l2+1+endZeros] == arr[m1:m2+1+endZeros] and arr[m1:m2+1+endZeros] == arr[r1:]:\\n            \\n            return [l2+endZeros,m2+1+endZeros]\\n            \\n            \\n        return [-1,-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019239,
                "title": "python3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        \"\"\"\\n        1: (# of 1) mod 3 == 0\\n        2: calculate n3 values (start with 0, end to tail)\\n        3. check if there exists n1, n2 == n3\\n        \"\"\"\\n        if sum(A) % 3 != 0:\\n            return [-1, -1]\\n        \\n        if sum(A) == 0:\\n            return [0, len(A) - 1]\\n        \\n        tot = sum(A)\\n        cnt = sum(A) // 3 * 2\\n        n3 = 0\\n        for i, n in enumerate(A):\\n            if cnt > 0:\\n                cnt -= n\\n            else:\\n                n3 = 2 * n3 + n\\n        \\n        n1 = 0\\n        n2 = 0\\n        i1 = None\\n        i2 = None\\n        for i, n in enumerate(A):\\n            if n1 > n3 or n2 > n3:\\n                return [-1, -1]\\n            elif n1 == n3:\\n                n2 = 2 * n2 + n\\n            else:\\n                n1 = 2 * n1 + n\\n                \\n            if n1 == n3 and i1 is None:\\n                i1 = i\\n            \\n            if n2 == n3:\\n                return [i1, i + 1]\\n            \\n        return [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        \"\"\"\\n        1: (# of 1) mod 3 == 0\\n        2: calculate n3 values (start with 0, end to tail)\\n        3. check if there exists n1, n2 == n3\\n        \"\"\"\\n        if sum(A) % 3 != 0:\\n            return [-1, -1]\\n        \\n        if sum(A) == 0:\\n            return [0, len(A) - 1]\\n        \\n        tot = sum(A)\\n        cnt = sum(A) // 3 * 2\\n        n3 = 0\\n        for i, n in enumerate(A):\\n            if cnt > 0:\\n                cnt -= n\\n            else:\\n                n3 = 2 * n3 + n\\n        \\n        n1 = 0\\n        n2 = 0\\n        i1 = None\\n        i2 = None\\n        for i, n in enumerate(A):\\n            if n1 > n3 or n2 > n3:\\n                return [-1, -1]\\n            elif n1 == n3:\\n                n2 = 2 * n2 + n\\n            else:\\n                n1 = 2 * n1 + n\\n                \\n            if n1 == n3 and i1 is None:\\n                i1 = i\\n            \\n            if n2 == n3:\\n                return [i1, i + 1]\\n            \\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815003,
                "title": "c-short-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int> &A) {\\n        vector<int> vi;\\n        for (int i = 0; i < A.size(); ++i) if (A[i] == 1) vi.push_back(i);\\n        if (vi.size() == 0) return vector{0, 2};\\n        if (vi.size() % 3 != 0) return vector{-1, -1};\\n        int len = A.size() - vi[vi.size() / 3 * 2];\\n        int a = vi[0], b = vi[vi.size() / 3], c = vi[vi.size() / 3 * 2];\\n        for (int i = 0; i < len; ++i)\\n            if (A[a + i] != A[b + i] || A[a + i] != A[c + i]) return vector{-1, -1};\\n        return vector{a + len - 1, b + len};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int> &A) {\\n        vector<int> vi;\\n        for (int i = 0; i < A.size(); ++i) if (A[i] == 1) vi.push_back(i);\\n        if (vi.size() == 0) return vector{0, 2};\\n        if (vi.size() % 3 != 0) return vector{-1, -1};\\n        int len = A.size() - vi[vi.size() / 3 * 2];\\n        int a = vi[0], b = vi[vi.size() / 3], c = vi[vi.size() / 3 * 2];\\n        for (int i = 0; i < len; ++i)\\n            if (A[a + i] != A[b + i] || A[a + i] != A[c + i]) return vector{-1, -1};\\n        return vector{a + len - 1, b + len};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720969,
                "title": "c-greedy",
                "content": "The only thing horrifying in this problem is its tag hard and its proof which we don\\'t have to do by the way.: )\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& a) {\\n        int one=0;\\n        int n=a.size();\\n        for(auto it:a)if(it)one++;\\n        if(one==0)\\n            return vector<int>{0,n-1};\\n        if(one%3)\\n            return vector<int>{-1,-1};\\n        int k=one/3;\\n        vector<int> pos;\\n        int t=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i])\\n                t++;\\n            if(t==1 and a[i]==1)\\n                pos.push_back(i);\\n            if(t==k)t=0;\\n        }\\n        int st=pos[0],mid=pos[1],en=pos[2];\\n        cout<<\"st= \"<<st<<\" mid= \"<<mid<<\" en= \"<<en<<endl;\\n        while(en<n and a[st]==a[mid] and a[mid]==a[en])\\n            en++,st++,mid++;\\n        if(en==n)\\n            return vector<int>{st-1,mid};\\n        return vector<int>{-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& a) {\\n        int one=0;\\n        int n=a.size();\\n        for(auto it:a)if(it)one++;\\n        if(one==0)\\n            return vector<int>{0,n-1};\\n        if(one%3)\\n            return vector<int>{-1,-1};\\n        int k=one/3;\\n        vector<int> pos;\\n        int t=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i])\\n                t++;\\n            if(t==1 and a[i]==1)\\n                pos.push_back(i);\\n            if(t==k)t=0;\\n        }\\n        int st=pos[0],mid=pos[1],en=pos[2];\\n        cout<<\"st= \"<<st<<\" mid= \"<<mid<<\" en= \"<<en<<endl;\\n        while(en<n and a[st]==a[mid] and a[mid]==a[en])\\n            en++,st++,mid++;\\n        if(en==n)\\n            return vector<int>{st-1,mid};\\n        return vector<int>{-1,-1};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 702617,
                "title": "python-3-solution-explained",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        \"\"\"\\n        Given an array of ones and zeros, this program determines whether\\n        the array can be partitioned three ways where each partition contains\\n        the same pattern of ones and zeros beginning with a one.  If there\\n        are no ones, the presence of at least three zeros makes a partition\\n        possible.\\n\\n        :param A: array of 1\\'s and 0\\'s\\n        :type A: list[int]\\n        :return: pair of integers\\n                 [last location partion 1, first location after partition 2]\\n                 or [-1, -1] if partition is not possible\\n        :rtype: list[int]\\n        \"\"\"\\n        \"\"\"\\n        Initialize:\\n        - length of A\\n        - get number of ones in A\\n        \"\"\"\\n        len_A = len(A)\\n        ones = A.count(1)\\n\\n        \"\"\"\\n        If A is all zeros, a valid partition is possible if the length\\n        of A is 3 or greater.\\n        \"\"\"\\n        if ones == 0:\\n            if len_A >= 3:\\n                return [0, len_A - 1]\\n            else:\\n                return[-1, -1]\\n\\n        \"\"\"\\n        The number of ones must be divisible by 3 in order for it to be\\n        possible to partition A.\\n        \"\"\"\\n        if ones % 3:\\n            return [-1, -1]\\n\\n        \"\"\"\\n        If we have gotton this far, the number of ones in A is divisible\\n        by 3. It is now possible to scan A to find the start of each pattern.\\n        It is also possible to determine the length of the pattern from the\\n        third pattern.\\n        \"\"\"\\n        ones_in_pattern = ones // 3\\n        pattern_starts = []\\n        ones_count = 0\\n        for k, a in enumerate(A):\\n            if a:\\n                ones_count += 1\\n                if ones_in_pattern == 1 \\\\\\n                    or ones_count % ones_in_pattern == 1:\\n                    pattern_starts.append(k)\\n        s1, s2, s3 = pattern_starts\\n        len_pattern = len(A[s3:])\\n\\n        \"\"\"\\n        Compare the patterns and return the result.\\n        \"\"\"\\n        if A[s1:s1 + len_pattern] == A[s2:s2 + len_pattern] == A[s3:]:\\n            return [s1 + len_pattern - 1, s2 + len_pattern]\\n        return [-1, -1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        \"\"\"\\n        Given an array of ones and zeros, this program determines whether\\n        the array can be partitioned three ways where each partition contains\\n        the same pattern of ones and zeros beginning with a one.  If there\\n        are no ones, the presence of at least three zeros makes a partition\\n        possible.\\n\\n        :param A: array of 1\\'s and 0\\'s\\n        :type A: list[int]\\n        :return: pair of integers\\n                 [last location partion 1, first location after partition 2]\\n                 or [-1, -1] if partition is not possible\\n        :rtype: list[int]\\n        \"\"\"\\n        \"\"\"\\n        Initialize:\\n        - length of A\\n        - get number of ones in A\\n        \"\"\"\\n        len_A = len(A)\\n        ones = A.count(1)\\n\\n        \"\"\"\\n        If A is all zeros, a valid partition is possible if the length\\n        of A is 3 or greater.\\n        \"\"\"\\n        if ones == 0:\\n            if len_A >= 3:\\n                return [0, len_A - 1]\\n            else:\\n                return[-1, -1]\\n\\n        \"\"\"\\n        The number of ones must be divisible by 3 in order for it to be\\n        possible to partition A.\\n        \"\"\"\\n        if ones % 3:\\n            return [-1, -1]\\n\\n        \"\"\"\\n        If we have gotton this far, the number of ones in A is divisible\\n        by 3. It is now possible to scan A to find the start of each pattern.\\n        It is also possible to determine the length of the pattern from the\\n        third pattern.\\n        \"\"\"\\n        ones_in_pattern = ones // 3\\n        pattern_starts = []\\n        ones_count = 0\\n        for k, a in enumerate(A):\\n            if a:\\n                ones_count += 1\\n                if ones_in_pattern == 1 \\\\\\n                    or ones_count % ones_in_pattern == 1:\\n                    pattern_starts.append(k)\\n        s1, s2, s3 = pattern_starts\\n        len_pattern = len(A[s3:])\\n\\n        \"\"\"\\n        Compare the patterns and return the result.\\n        \"\"\"\\n        if A[s1:s1 + len_pattern] == A[s2:s2 + len_pattern] == A[s3:]:\\n            return [s1 + len_pattern - 1, s2 + len_pattern]\\n        return [-1, -1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598904,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    int t;\\n    public int[] threeEqualParts(int[] A) {\\n        int res[]=new int[]{-1,-1};\\n        int part1=0;int part2=0;int part3=0;int cnt=1;\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int ones=0;\\n        for(int n:A)if(n==1)ones++;\\n        if(ones==0)return new int[]{0,A.length-1};\\n        if(ones%3!=0)return res;\\n        t=ones/3;ones=0;\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==1){\\n                ones++;\\n                map.put(cnt,i);\\n                cnt++;\\n            }\\n        }\\n        for(int i=map.get(t)+1;i<=map.get(2*t);i++){\\n            if(A[i]==0)part1++;\\n            else break;\\n        }\\n        for(int i=map.get(2*t)+1;i<A.length;i++){\\n            if(A[i]==0)part2++;\\n            else break;\\n        }\\n        for(int i=map.get(ones)+1;i<A.length;i++){\\n            if(A[i]==0)part3++;\\n        }\\n        if(part1<part3||part2<part3)return res;\\n        List<Integer>l1=getlist(A,map.get(1),map.get(t));\\n        List<Integer>l2=getlist(A,map.get(t+1),map.get(2*t));\\n        List<Integer>l3=getlist(A,map.get(2*t+1),map.get(ones));\\n        if(!compare(l1,l2)||!compare(l2,l3))return res;\\n        res[0]=map.get(t)+part3;\\n        res[1]=map.get(2*t)+part3+1;\\n        return res;\\n    }\\n    \\n    public List<Integer> getlist(int A[],int i1,int i2){\\n        List<Integer>list=new ArrayList<>();\\n        for(int i=i1;i<=i2;i++)list.add(A[i]);\\n        return list;\\n    }\\n    public boolean compare(List<Integer>list1,List<Integer>list2){\\n        if(list1.size()!=list2.size())return false;\\n        for(int i=0;i<list1.size();i++){\\n            if(list1.get(i)!=list2.get(i))return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int t;\\n    public int[] threeEqualParts(int[] A) {\\n        int res[]=new int[]{-1,-1};\\n        int part1=0;int part2=0;int part3=0;int cnt=1;\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int ones=0;\\n        for(int n:A)if(n==1)ones++;\\n        if(ones==0)return new int[]{0,A.length-1};\\n        if(ones%3!=0)return res;\\n        t=ones/3;ones=0;\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==1){\\n                ones++;\\n                map.put(cnt,i);\\n                cnt++;\\n            }\\n        }\\n        for(int i=map.get(t)+1;i<=map.get(2*t);i++){\\n            if(A[i]==0)part1++;\\n            else break;\\n        }\\n        for(int i=map.get(2*t)+1;i<A.length;i++){\\n            if(A[i]==0)part2++;\\n            else break;\\n        }\\n        for(int i=map.get(ones)+1;i<A.length;i++){\\n            if(A[i]==0)part3++;\\n        }\\n        if(part1<part3||part2<part3)return res;\\n        List<Integer>l1=getlist(A,map.get(1),map.get(t));\\n        List<Integer>l2=getlist(A,map.get(t+1),map.get(2*t));\\n        List<Integer>l3=getlist(A,map.get(2*t+1),map.get(ones));\\n        if(!compare(l1,l2)||!compare(l2,l3))return res;\\n        res[0]=map.get(t)+part3;\\n        res[1]=map.get(2*t)+part3+1;\\n        return res;\\n    }\\n    \\n    public List<Integer> getlist(int A[],int i1,int i2){\\n        List<Integer>list=new ArrayList<>();\\n        for(int i=i1;i<=i2;i++)list.add(A[i]);\\n        return list;\\n    }\\n    public boolean compare(List<Integer>list1,List<Integer>list2){\\n        if(list1.size()!=list2.size())return false;\\n        for(int i=0;i<list1.size();i++){\\n            if(list1.get(i)!=list2.get(i))return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570039,
                "title": "simple-solution-o-n-time-complexity-o-1-space",
                "content": "\\tclass Solution(object):\\n\\tdef threeEqualParts(self, A):\\n        if len(A) < 3:\\n            return [-1,-1]\\n        nums = 0\\n        for i in range(len(A)):\\n            if A[i] == 1:\\n                nums += 1\\n        \\n        if nums % 3 != 0:\\n            return [-1,-1]\\n        \\n        if nums == 0:\\n            return [0,len(A) - 1]\\n        arr = []\\n        val = 0\\n        \\n\\n        for i in range(len(A)):\\n            if A[i] == 1:\\n                val += 1\\n                if val == 1 or val == nums/3 or val == nums/3 + 1 or val == 2*nums/3 or val == 2*nums/3 + 1 or val == nums:\\n                    arr.append(i)\\n        if nums == 3:\\n            z = len(A) - arr[2] - 1\\n            x = arr[1] - arr[0] - 1\\n            y = arr[2] - arr[1] - 1\\n            if x < z or y < z:\\n                return [-1,-1]\\n            \\n            return [arr[0] + z, arr[1] + z + 1]\\n            \\n        if A[arr[0]:arr[1]] != A[arr[2]:arr[3]] or A[arr[0]:arr[1]] != A[arr[4]:arr[5]]:\\n            return [-1,-1]\\n        \\n        z = len(A) - arr[5] - 1\\n        x = arr[2] - arr[1] - 1\\n        y = arr[4] - arr[3] - 1\\n        \\n        if x < z or y < z:\\n            return [-1,-1]\\n\\n        return [arr[1] + (len(A) - arr[5]) - 1, arr[3] + (len(A) - arr[5])]",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\tdef threeEqualParts(self, A):\\n        if len(A) < 3:\\n            return [-1,-1]\\n        nums = 0\\n        for i in range(len(A)):\\n            if A[i] == 1:\\n                nums += 1\\n        \\n        if nums % 3 != 0:\\n            return [-1,-1]\\n        \\n        if nums == 0:\\n            return [0,len(A) - 1]\\n        arr = []\\n        val = 0\\n        \\n\\n        for i in range(len(A)):\\n            if A[i] == 1:\\n                val += 1\\n                if val == 1 or val == nums/3 or val == nums/3 + 1 or val == 2*nums/3 or val == 2*nums/3 + 1 or val == nums:\\n                    arr.append(i)\\n        if nums == 3:\\n            z = len(A) - arr[2] - 1\\n            x = arr[1] - arr[0] - 1\\n            y = arr[2] - arr[1] - 1\\n            if x < z or y < z:\\n                return [-1,-1]\\n            \\n            return [arr[0] + z, arr[1] + z + 1]\\n            \\n        if A[arr[0]:arr[1]] != A[arr[2]:arr[3]] or A[arr[0]:arr[1]] != A[arr[4]:arr[5]]:\\n            return [-1,-1]\\n        \\n        z = len(A) - arr[5] - 1\\n        x = arr[2] - arr[1] - 1\\n        y = arr[4] - arr[3] - 1\\n        \\n        if x < z or y < z:\\n            return [-1,-1]\\n\\n        return [arr[1] + (len(A) - arr[5]) - 1, arr[3] + (len(A) - arr[5])]",
                "codeTag": "Java"
            },
            {
                "id": 481365,
                "title": "python-intuitive-solution-less-than-100-memory-usage",
                "content": "```\\nclass Solution(object):\\n    def threeEqualParts(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(A)\\n        if N < 3:\\n            return [-1, -1]\\n\\n        count_of_one = A.count(1)\\n        if count_of_one == 0:\\n            return [0, N-1]\\n        if count_of_one % 3 != 0:\\n            return [-1, -1]\\n\\n        pattern = \\'\\'\\n        count = 0\\n        reversed_str = \\'\\'.join(map(str, A[::-1]))\\n\\n        for i, digit in enumerate(A[::-1]):\\n            if digit == 1:\\n                count += 1\\n            if count == count_of_one/3:\\n                break\\n        pattern = reversed_str[:i+1]\\n\\n        length = len(reversed_str)\\n        len_pattern = len(pattern)\\n\\n        \\'\\'\\'matching\\'\\'\\'\\n        index = reversed_str.find(pattern, len_pattern)\\n        if index == -1:\\n            return [-1, -1]\\n        j = length - index\\n\\n        index = reversed_str.find(pattern, len_pattern + index)\\n        if index == -1:\\n            return [-1, -1]\\n        i = length - index - 1\\n\\n        return [i, j]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def threeEqualParts(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(A)\\n        if N < 3:\\n            return [-1, -1]\\n\\n        count_of_one = A.count(1)\\n        if count_of_one == 0:\\n            return [0, N-1]\\n        if count_of_one % 3 != 0:\\n            return [-1, -1]\\n\\n        pattern = \\'\\'\\n        count = 0\\n        reversed_str = \\'\\'.join(map(str, A[::-1]))\\n\\n        for i, digit in enumerate(A[::-1]):\\n            if digit == 1:\\n                count += 1\\n            if count == count_of_one/3:\\n                break\\n        pattern = reversed_str[:i+1]\\n\\n        length = len(reversed_str)\\n        len_pattern = len(pattern)\\n\\n        \\'\\'\\'matching\\'\\'\\'\\n        index = reversed_str.find(pattern, len_pattern)\\n        if index == -1:\\n            return [-1, -1]\\n        j = length - index\\n\\n        index = reversed_str.find(pattern, len_pattern + index)\\n        if index == -1:\\n            return [-1, -1]\\n        i = length - index - 1\\n\\n        return [i, j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391687,
                "title": "c-o-n-time-simple-sol-with-explaination",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        // check number of 1s\\n        int oneCount = 0, n = A.size();\\n        for (int &i: A)\\n            oneCount += (i == 1);\\n        if (oneCount % 3 != 0)\\n            return vector<int> {-1, -1};\\n        if (oneCount == 0)\\n            return vector<int> {0, 2};\\n        \\n        // find last part\\n        int count = oneCount / 3, third = n;\\n        while (count > 0) {\\n            third--;\\n            if (A[third] == 1)\\n                count--;\\n        }\\n        \\n        // find first part\\n        int first = 0;\\n        while (first < n && A[first] == 0)\\n            first++;\\n        \\n        // check equalness of 1 and 3\\n        bool equal = true;\\n        for (int offset = 0; third + offset < n; offset++)\\n            if (first + offset >= third || A[first + offset] != A[third + offset])\\n                return vector<int> {-1, -1};\\n        \\n        // check equalness of 2 and 3\\n        int second = first + n - third;\\n        while (A[second] == 0)\\n            second++;\\n        for (int offset = 0; third + offset < n; offset++)\\n            if (second + offset >= third || A[second + offset] != A[third + offset])\\n                return vector<int> {-1, -1};\\n\\n        // okay. return last position of first part and first position of third part.\\n        return vector<int> {first + n - third - 1, second + n - third};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        // check number of 1s\\n        int oneCount = 0, n = A.size();\\n        for (int &i: A)\\n            oneCount += (i == 1);\\n        if (oneCount % 3 != 0)\\n            return vector<int> {-1, -1};\\n        if (oneCount == 0)\\n            return vector<int> {0, 2};\\n        \\n        // find last part\\n        int count = oneCount / 3, third = n;\\n        while (count > 0) {\\n            third--;\\n            if (A[third] == 1)\\n                count--;\\n        }\\n        \\n        // find first part\\n        int first = 0;\\n        while (first < n && A[first] == 0)\\n            first++;\\n        \\n        // check equalness of 1 and 3\\n        bool equal = true;\\n        for (int offset = 0; third + offset < n; offset++)\\n            if (first + offset >= third || A[first + offset] != A[third + offset])\\n                return vector<int> {-1, -1};\\n        \\n        // check equalness of 2 and 3\\n        int second = first + n - third;\\n        while (A[second] == 0)\\n            second++;\\n        for (int offset = 0; third + offset < n; offset++)\\n            if (second + offset >= third || A[second + offset] != A[third + offset])\\n                return vector<int> {-1, -1};\\n\\n        // okay. return last position of first part and first position of third part.\\n        return vector<int> {first + n - third - 1, second + n - third};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300534,
                "title": "clean-java-solution-with-o-1-space-and-o-n-complexity",
                "content": "```\\npublic class Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        if (A == null || A.length < 3) return new int[]{-1, -1};\\n        int oneCnt = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) oneCnt++;\\n        }\\n        if (oneCnt % 3 != 0) return new int[]{-1, -1};\\n        int oneAvg = oneCnt / 3;\\n        if (oneAvg == 0) return new int[]{0, A.length - 1};\\n\\n        // find the start index for the 3rd part\\n        int postOnes = 0, start3 = A.length - 1;\\n        while (postOnes < oneAvg) {\\n            if (A[start3--] == 1) postOnes++;\\n        }\\n        start3++;\\n\\n        // find the end index for the 1st part\\n        int l = A.length - start3, i = 0;\\n        while (A[i] == 0) i++;\\n        for (int k = 0; k < l; k++) {\\n            if (A[i + k] != A[start3 + k]) return new int[]{-1, -1};\\n        }\\n        int left = i + l - 1, j = left + 1;\\n\\n        // find the end index for the 2nd part\\n        while (A[j] == 0) j++;\\n        for (int k = 0; k < l; k++) {\\n            if (A[k + j] != A[start3 + k]) return new int[]{-1, -1};\\n        }\\n        int right = j + l;\\n\\n        return new int[]{left, right};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        if (A == null || A.length < 3) return new int[]{-1, -1};\\n        int oneCnt = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) oneCnt++;\\n        }\\n        if (oneCnt % 3 != 0) return new int[]{-1, -1};\\n        int oneAvg = oneCnt / 3;\\n        if (oneAvg == 0) return new int[]{0, A.length - 1};\\n\\n        // find the start index for the 3rd part\\n        int postOnes = 0, start3 = A.length - 1;\\n        while (postOnes < oneAvg) {\\n            if (A[start3--] == 1) postOnes++;\\n        }\\n        start3++;\\n\\n        // find the end index for the 1st part\\n        int l = A.length - start3, i = 0;\\n        while (A[i] == 0) i++;\\n        for (int k = 0; k < l; k++) {\\n            if (A[i + k] != A[start3 + k]) return new int[]{-1, -1};\\n        }\\n        int left = i + l - 1, j = left + 1;\\n\\n        // find the end index for the 2nd part\\n        while (A[j] == 0) j++;\\n        for (int k = 0; k < l; k++) {\\n            if (A[k + j] != A[start3 + k]) return new int[]{-1, -1};\\n        }\\n        int right = j + l;\\n\\n        return new int[]{left, right};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290095,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        n = len(A)\\n        ones = []\\n        for i in range(n):\\n            if A[i]: ones.append(i)\\n        none = len(ones)\\n        if none == 0: return [0, n-1]\\n        if none % 3: return [-1, -1]\\n        g = none // 3\\n        i, j = ones[g-1], ones[2*g -1]\\n        pre_zero = n-1 - ones[-1]\\n        if ones[g] - ones[g-1]-1 < pre_zero or ones[2*g]-ones[2*g-1]-1 < pre_zero: \\n            return [-1, -1]\\n        \\n        i += pre_zero\\n        j += pre_zero\\n        k = n-1\\n        ans = [i, j+1]\\n        for _ in range(g):\\n            if not (A[k]==A[j]==A[i]): return [-1, -1]\\n            k -=1\\n            j -= 1\\n            i -= 1\\n        return ans\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        n = len(A)\\n        ones = []\\n        for i in range(n):\\n            if A[i]: ones.append(i)\\n        none = len(ones)\\n        if none == 0: return [0, n-1]\\n        if none % 3: return [-1, -1]\\n        g = none // 3\\n        i, j = ones[g-1], ones[2*g -1]\\n        pre_zero = n-1 - ones[-1]\\n        if ones[g] - ones[g-1]-1 < pre_zero or ones[2*g]-ones[2*g-1]-1 < pre_zero: \\n            return [-1, -1]\\n        \\n        i += pre_zero\\n        j += pre_zero\\n        k = n-1\\n        ans = [i, j+1]\\n        for _ in range(g):\\n            if not (A[k]==A[j]==A[i]): return [-1, -1]\\n            k -=1\\n            j -= 1\\n            i -= 1\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 222775,
                "title": "o-n-solution-in-rust-4ms",
                "content": "The algorithm proceeds as follows:\\n- find the number of `1`s that each part must have. This number must be `total_number_of_ones/3` sinceo otherwise parts would definitely not have same values. Because of this if the total number of `1`s is not a multiple of `3`, we can return `{-1, -1}` immediately. Another simple optimization that can be made at this stage is checking if the total number of `1`s is `0`, since in such case any split would result in equal parts. I use `{0,2}` just because it works for all input sizes, including `3`.\\n- find the number of trailing zeros. Since in order to have same values all numbers have to have the exact same number of trailing zeros, we can use the last part to get it, since we know that the end of the thrird part is `A.length-1`.\\n- find the end of the first part. To do this we increase the index until we find encounter `part_ones` number of `1`s and then will skip `trailing_zeros` after making sure that there are enough trailing zeros available.\\n- find the end of the second part. The procedure is exactly the same as the one used for the first part, but the scan starts with `i+1`.\\n- check if all parts are equal and if not return `{-1, -1}`. I\\'m relying on iterator `zip` method to stop as soon as one of the ranges is exhausted in order to avoid having to deal with different part lengths.\\n- return the end of the first and the start of the third part (one past the end of the second part).\\n\\n```\\nimpl Solution {\\n    pub fn three_equal_parts(a: Vec<i32>) -> Vec<i32> {\\n        let ones = a.iter().filter(|&n| *n == 1).count();\\n        if ones == 0 {\\n            return vec![0, 2]; // any split works here\\n        }\\n        if ones % 3 != 0 {\\n            return vec![-1, -1];\\n        }\\n        let part_ones = ones / 3;\\n        let trailing_zeros = (0..a.len()).rev().take_while(|&idx| a[idx] == 0).count();\\n        \\n        let find_part_end = |start| -> Option<usize> {\\n            let mut ones = 0;\\n            let mut i = start;\\n            while ones < part_ones {\\n                if a[i] == 1 {\\n                    ones += 1;\\n                }\\n                i += 1;\\n            }\\n            if !(i..(i+trailing_zeros)).all(|idx| a[idx] == 0) {\\n                // first part does not have enough trailing zeros\\n                return None;\\n            }\\n            Some(i + trailing_zeros - 1)\\n        };\\n        \\n        let i = match find_part_end(0) { // first part end\\n            Some(i) => i,\\n            None => return vec![-1, -1],\\n        };\\n        \\n        let j = match find_part_end(i+1) { // second part end\\n            Some(j) => j + 1, // j starts after the end of second part\\n            None => return vec![-1, -1],\\n        };\\n        \\n        if !(0..i+1).rev().zip((i+1..j).rev()).all(|t| a[t.0] == a[t.1]) {\\n            // first and second parts are different\\n            return vec![-1, -1];\\n        }\\n        \\n        if !(i+1..j).rev().zip((j..a.len()).rev()).all(|t| a[t.0] == a[t.1]) {\\n            // second and first parts are different\\n            return vec![-1, -1];\\n        }\\n        \\n        vec![i as i32, j as i32]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn three_equal_parts(a: Vec<i32>) -> Vec<i32> {\\n        let ones = a.iter().filter(|&n| *n == 1).count();\\n        if ones == 0 {\\n            return vec![0, 2]; // any split works here\\n        }\\n        if ones % 3 != 0 {\\n            return vec![-1, -1];\\n        }\\n        let part_ones = ones / 3;\\n        let trailing_zeros = (0..a.len()).rev().take_while(|&idx| a[idx] == 0).count();\\n        \\n        let find_part_end = |start| -> Option<usize> {\\n            let mut ones = 0;\\n            let mut i = start;\\n            while ones < part_ones {\\n                if a[i] == 1 {\\n                    ones += 1;\\n                }\\n                i += 1;\\n            }\\n            if !(i..(i+trailing_zeros)).all(|idx| a[idx] == 0) {\\n                // first part does not have enough trailing zeros\\n                return None;\\n            }\\n            Some(i + trailing_zeros - 1)\\n        };\\n        \\n        let i = match find_part_end(0) { // first part end\\n            Some(i) => i,\\n            None => return vec![-1, -1],\\n        };\\n        \\n        let j = match find_part_end(i+1) { // second part end\\n            Some(j) => j + 1, // j starts after the end of second part\\n            None => return vec![-1, -1],\\n        };\\n        \\n        if !(0..i+1).rev().zip((i+1..j).rev()).all(|t| a[t.0] == a[t.1]) {\\n            // first and second parts are different\\n            return vec![-1, -1];\\n        }\\n        \\n        if !(i+1..j).rev().zip((j..a.len()).rev()).all(|t| a[t.0] == a[t.1]) {\\n            // second and first parts are different\\n            return vec![-1, -1];\\n        }\\n        \\n        vec![i as i32, j as i32]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 219711,
                "title": "my-concise-solution-with-explanation-beat-100",
                "content": "*Please upvote if you like it.*\\n\\n**Observations/algorithm**:\\n1. Each part must have equal number of 1\\'s.\\n2. Let nums be the actual binary value of the parts, then num1 == num2 == num3, and each num starts with a 1. The only exception is when all nums are 0.\\n3. Each part can have various number of leading 0\\'s.\\n    Thus, part1/num1 and part2/num2 are more flexible: they can play with the leading 0\\'s of the next part.\\n\\n4. num3 can be certain (if it exists), we find num3 by the following method:\\n\\t```\\n            i             j       k\\n    0000[num1]000000[num2]0000000[num3]\\n\\t```\\n\\n    Let find k first, where k is the first \\'1\\' we can find in part3 from left to right.\\n    Then A[k:] is num3, let\\'s call it pattern.\\n    How to find k then? The 1\\'s in num3 is one third of the total 1\\'s.\\n5. There must not be any 1\\'s between any two nums.\\n    So we scan from left to k-1, once we see a 1, it must belong to num1 and num1 must equal to pattern.\\n    Assume num1 matched, we continue scanning, once we see another 1, it must belong to num2 and num2 must equal to pattern.\\n    If num2 == pattern, then we are done; there won\\'t be any 1\\'s between num2 and num3 because the totle 1\\'s are all visited in this round.\\n\\nCode:\\n```\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        N = len(A)\\n        ones = sum(A)\\n        if ones == 0: return [0, N-1]\\n        if ones % 3 > 0: return [-1, -1]\\n        one_third = ones//3\\n        k = N-1\\n        while True:\\n            if A[k] == 1:\\n                ones -= 1\\n                if ones == 2 * one_third: break\\n            k -= 1\\n        pattern = A[k:]\\n        M = len(pattern)\\n        \\n        i = j = None\\n        x = 0\\n        while x < k:\\n            if A[x] == 1:\\n                if A[x:x+M] != pattern: return [-1, -1]\\n                x += M\\n                if i is None: i = x - 1\\n                else: j = x\\n            else:\\n                x += 1\\n        return [i, j]\\n```\\n\\nComplexity Analysis:\\n* Running Time: O(N), two passes\\n* Space: O(N) for storing and comparing pattern",
                "solutionTags": [],
                "code": "```\\n            i             j       k\\n    0000[num1]000000[num2]0000000[num3]\\n\\t```\n```\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        N = len(A)\\n        ones = sum(A)\\n        if ones == 0: return [0, N-1]\\n        if ones % 3 > 0: return [-1, -1]\\n        one_third = ones//3\\n        k = N-1\\n        while True:\\n            if A[k] == 1:\\n                ones -= 1\\n                if ones == 2 * one_third: break\\n            k -= 1\\n        pattern = A[k:]\\n        M = len(pattern)\\n        \\n        i = j = None\\n        x = 0\\n        while x < k:\\n            if A[x] == 1:\\n                if A[x:x+M] != pattern: return [-1, -1]\\n                x += M\\n                if i is None: i = x - 1\\n                else: j = x\\n            else:\\n                x += 1\\n        return [i, j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216541,
                "title": "c-o-n-time-o-1-space-with-comments",
                "content": "If the number at each segment is same, the binary of those segment will also be same. \\nThe key thing is to split all the ones into 3 equal parts. Then, the last segment is final, it will be the value against which first 2 segments need to be compared.\\n```\\nvector<int> threeEqualParts(vector<int>& A) {\\n        int cnt = 0, i, a, b, c, val = 0;\\n        for (auto x : A)\\n            cnt += x;\\n        if (cnt == 0)\\n            return {0, 2};\\n        if (cnt % 3) // number of 1\\'s are not splittable\\n            return {-1,-1};\\n        for (i = A.size() - 1; i >= 0; i--) {\\n            if (A[i]) {\\n                val++;\\n                if (val == cnt/3)\\n                    c = i; // start of 3rd segment\\n                else if (val == 2 * (cnt/3))\\n                    b = i; // start of 2nd segment\\n                else if (val == cnt) {\\n                    a = i; // start of 1st segment\\n                    break;\\n                }\\n            }\\n        }\\n        for (i = 0; i < (int)A.size() - c; i++) {\\n            if (a+i >= b || b+i >= c) // overlapping regions\\n                return {-1, -1};\\n            if (A[c+i] != A[a+i] || A[c+i] != A[b+i]) // mismatch\\n                return {-1, -1};\\n        }\\n        return {a+i-1, b+i};\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<int> threeEqualParts(vector<int>& A) {\\n        int cnt = 0, i, a, b, c, val = 0;\\n        for (auto x : A)\\n            cnt += x;\\n        if (cnt == 0)\\n            return {0, 2};\\n        if (cnt % 3) // number of 1\\'s are not splittable\\n            return {-1,-1};\\n        for (i = A.size() - 1; i >= 0; i--) {\\n            if (A[i]) {\\n                val++;\\n                if (val == cnt/3)\\n                    c = i; // start of 3rd segment\\n                else if (val == 2 * (cnt/3))\\n                    b = i; // start of 2nd segment\\n                else if (val == cnt) {\\n                    a = i; // start of 1st segment\\n                    break;\\n                }\\n            }\\n        }\\n        for (i = 0; i < (int)A.size() - c; i++) {\\n            if (a+i >= b || b+i >= c) // overlapping regions\\n                return {-1, -1};\\n            if (A[c+i] != A[a+i] || A[c+i] != A[b+i]) // mismatch\\n                return {-1, -1};\\n        }\\n        return {a+i-1, b+i};\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 184480,
                "title": "c-22-lines-o-n-time-soluton",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int v[30005];\\n        int cnt = 0,n = A.size();\\n        for(int i=0;i<n;i++)if(A[i])v[cnt++] = i;\\n        if (cnt%3!=0) return {-1,-1};\\n        if (cnt == 0) return {0, n-1};\\n        int a = v[0];\\n        int b = v[cnt/3];\\n        int c = v[cnt/3*2];\\n        int ed = b,ed2 = c;\\n        int num = 0;\\n        while(a<ed && b<ed2 && c<n){\\n            if(A[a]!= A[b] || A[a]!=A[c] || A[b]!=A[c])return {-1,-1};\\n            num += A[a];\\n            if(num==cnt/3 && c==n-1)return {a,b+1};\\n            a++;b++;c++;\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int v[30005];\\n        int cnt = 0,n = A.size();\\n        for(int i=0;i<n;i++)if(A[i])v[cnt++] = i;\\n        if (cnt%3!=0) return {-1,-1};\\n        if (cnt == 0) return {0, n-1};\\n        int a = v[0];\\n        int b = v[cnt/3];\\n        int c = v[cnt/3*2];\\n        int ed = b,ed2 = c;\\n        int num = 0;\\n        while(a<ed && b<ed2 && c<n){\\n            if(A[a]!= A[b] || A[a]!=A[c] || A[b]!=A[c])return {-1,-1};\\n            num += A[a];\\n            if(num==cnt/3 && c==n-1)return {a,b+1};\\n            a++;b++;c++;\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184322,
                "title": "short-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int count = std::count(A.begin(), A.end(), 1);\\n        if(count % 3)\\n            return {-1, -1};\\n        count /= 3;\\n        int i = 0,j = 1,k = 2;\\n        for(int l = 0, cnt = 0; l < A.size(); cnt += A[l], ++l){\\n            if(cnt == 0 && A[l] == 1)\\n                i = l;\\n            if(cnt == count && A[l] == 1)\\n                j = l;\\n            if(cnt == 2 * count && A[l] == 1)\\n                k = l;\\n        }\\n        for(; k < A.size(); ++i, ++j, ++k)\\n            if(A[i] != A[j] || A[i] != A[k])\\n                return {-1, -1};\\n        return {i - 1, j};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int count = std::count(A.begin(), A.end(), 1);\\n        if(count % 3)\\n            return {-1, -1};\\n        count /= 3;\\n        int i = 0,j = 1,k = 2;\\n        for(int l = 0, cnt = 0; l < A.size(); cnt += A[l], ++l){\\n            if(cnt == 0 && A[l] == 1)\\n                i = l;\\n            if(cnt == count && A[l] == 1)\\n                j = l;\\n            if(cnt == 2 * count && A[l] == 1)\\n                k = l;\\n        }\\n        for(; k < A.size(); ++i, ++j, ++k)\\n            if(A[i] != A[j] || A[i] != A[k])\\n                return {-1, -1};\\n        return {i - 1, j};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184176,
                "title": "c-solution-in-o-n-using-cumulative-sum-and-binary-search",
                "content": "````\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {        \n        int ones = 0;\n        vector<int> B = A;\n        for (int i = 0; i < A.size(); i++)\n            ones += A[i];\n        \n        if (ones == 0) {\n            return {0, 2};\n        }\n        else {\n            if (ones % 3 != 0) {\n                return {-1, -1};\n            }\n            else {\n                ones /= 3;\n                \n                // Count the number of trailing zeros in part 3\n                int z3 = 0;\n                for (int i = A.size() - 1; A[i] == 0; i--)\n                    z3++;\n                \n                // Cumulate\n                for (int i = 1; i < A.size(); i++)\n                    A[i] += A[i-1];\n                \n                int p1 = lower_bound(A.begin(), A.end(), ones) - A.begin();\n                if (A[p1 + z3] != ones)\n                    return {-1, -1};\n                \n                int p2 = lower_bound(A.begin(), A.end(), 2 * ones) - A.begin();\n                if (A[p2 + z3] != 2 * ones)\n                    return {-1, -1};\n                \n                // Check the content of the 3 arrays\n                int L = A.size() - 1;\n                bool ok = true;\n                for (int i = 0; ones && ok; i++) {\n                    ok &= B[L - i] == B[p2 + z3 - i];\n                    ok &= B[L - i] == B[p1 + z3 - i];\n                    ones -= B[L - i];\n                }\n                \n                if (ok)\n                    return {p1 + z3, p2 + z3 + 1};\n                else\n                    return {-1, -1};\n            }\n        }\n    }\n};\n````\n",
                "solutionTags": [],
                "code": "````\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {        \n        int ones = 0;\n        vector<int> B = A;\n        for (int i = 0; i < A.size(); i++)\n            ones += A[i];\n        \n        if (ones == 0) {\n            return {0, 2};\n        }\n        else {\n            if (ones % 3 != 0) {\n                return {-1, -1};\n            }\n            else {\n                ones /= 3;\n                \n                // Count the number of trailing zeros in part 3\n                int z3 = 0;\n                for (int i = A.size() - 1; A[i] == 0; i--)\n                    z3++;\n                \n                // Cumulate\n                for (int i = 1; i < A.size(); i++)\n                    A[i] += A[i-1];\n                \n                int p1 = lower_bound(A.begin(), A.end(), ones) - A.begin();\n                if (A[p1 + z3] != ones)\n                    return {-1, -1};\n                \n                int p2 = lower_bound(A.begin(), A.end(), 2 * ones) - A.begin();\n                if (A[p2 + z3] != 2 * ones)\n                    return {-1, -1};\n                \n                // Check the content of the 3 arrays\n                int L = A.size() - 1;\n                bool ok = true;\n                for (int i = 0; ones && ok; i++) {\n                    ok &= B[L - i] == B[p2 + z3 - i];\n                    ok &= B[L - i] == B[p1 + z3 - i];\n                    ones -= B[L - i];\n                }\n                \n                if (ok)\n                    return {p1 + z3, p2 + z3 + 1};\n                else\n                    return {-1, -1};\n            }\n        }\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 183936,
                "title": "java-solution-with-detailed-explanation",
                "content": "# Approach\nWe need to have 3 arrays with binary number represented by them should be all equal.  We know that leading '0'(zero) in binary doesn't add value to binary number, but trailiing zero's do.  So, if we could first count the trailing zeros in the incoming input first.  Then we can try to find 2 other arrays with same number of trailing zeros.  If it's not possible to find such 3 arrays, then we can't find solution.  Also, since we need to slice array into 3 parts, then we need to make sure the incoming arrays contains '1' which are divisible by 3.  \n\n# Algorithm\n1.  Get the **SUM** of the array.  If the **SUM** is not divisible by 3 then we can blindly return [-1,-1] as answer.  Otherwise go to step2\n2.  If sum is 0 then we can split array in many possible ways, we can use [0,A.length-1] as answer.  You can hardcode some other value as well, it should work. Otherwise, go to step3\n3.  Find the trailing zero's in the input.  Lets call it **trailingZeros**.  **targetSum** is equal to **SUM/3**\n4.  Now lets iterate through the input and find the 2 split where the running sum of the split array is equal to **targetSum**.  We know there are count of **trailingZeros** at the end.  So, after we find the **targetSum** store the index with **trailingZeros** count added.  Why we add **trailingZeros** count to the first and second split of the array? Reason: If the last array contains those many trailing zeros then other 2 also must contain those, failing to do so means we cannot split the array into 3 parts.\n5.  Once we find the 2 splits.  We can iterate through the split and check whether **splitSum** matches **targetSum**?.  Return the [-1,-1] when there is no match.\n6.  Last part of the algo:  We found 3 arrays with equals sum, but it's possible that individual binary number formed by split array may not match.  So, lets check the individual bits do they match.  Why we need to match? Reason: Matching them gives a clear indication that binary number formed by 3 are actually equal.\n\nRuntime Complexity is O(N) - N is length of input array.\nSpace Complexity is O(1) - Constant.\nMy solution took 11 ms.  \n# Code\n\n```\npublic int[] threeEqualPartsWorking(int[] A) {\n\t\tint sum = 0, N = A.length ;\n\t\tfor(int v : A) sum +=v;\n\t\tif(sum  % 3 != 0)\n\t\t\treturn new int[]{-1, -1};\n\t\tif(sum  == 0){\n\t\t\treturn new int[]{0, N - 1};\n\t\t}\n\t\tint[] ret = new int[]{-1, -1}; // First split and second split index\n\t\tint trailingZeros = 0;\n\t\tfor(int i= N-1;i >= 0;i--){\n\t\t\tif(A[i] == 1){\n\t\t\t\ttrailingZeros = N-1-i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint runningSum= 0, targetSum = sum /3 ;\n\t\tfor(int i = 0;i < N ;i++){\n\t\t\trunningSum += A[i];\n\t\t\tif(runningSum == targetSum && ret[0] == -1){\n\t\t\t\t\tret[0] = i+trailingZeros;\n\t\t\t}\n\t\t\tif(runningSum == 2*targetSum && ret[1] == -1){\n\t\t\t\t\tret[1] = i+1+trailingZeros;\n\t\t\t}\n\t\t}\n\n\t\tif(ret[1] >= N)// if first split has gone beyond the input array length, then we can't split.\n\t\t\treturn new int[]{-1, -1};\n\n\t\tint splitSum = 0 ;\n\t\tfor(int i = 0;i <= ret[0];i++) splitSum += A[i];\n\t\tif(splitSum != targetSum)return new int[]{-1,-1};\n\n\t\tsplitSum = 0;\n\t\tfor(int i = ret[0]+1;i < ret[1];i++) splitSum += A[i];\n\t\tif(splitSum != targetSum)return new int[]{-1,-1};\n\n\t\tfor(int i = N-1, j = ret[1]-1, k = ret[0]; i >= ret[1] && j >= ret[0]+1 && k >= 0; i--,j--,k--){\n\t\t\tint uniqBits = A[i]+A[j]+A[k];\n\t\t\tif(!(uniqBits == 3 || uniqBits == 0))return new int[]{-1, -1};\n\t\t}\n\n\t\treturn ret;\n}\n```",
                "solutionTags": [],
                "code": "```\npublic int[] threeEqualPartsWorking(int[] A) {\n\t\tint sum = 0, N = A.length ;\n\t\tfor(int v : A) sum +=v;\n\t\tif(sum  % 3 != 0)\n\t\t\treturn new int[]{-1, -1};\n\t\tif(sum  == 0){\n\t\t\treturn new int[]{0, N - 1};\n\t\t}\n\t\tint[] ret = new int[]{-1, -1}; // First split and second split index\n\t\tint trailingZeros = 0;\n\t\tfor(int i= N-1;i >= 0;i--){\n\t\t\tif(A[i] == 1){\n\t\t\t\ttrailingZeros = N-1-i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint runningSum= 0, targetSum = sum /3 ;\n\t\tfor(int i = 0;i < N ;i++){\n\t\t\trunningSum += A[i];\n\t\t\tif(runningSum == targetSum && ret[0] == -1){\n\t\t\t\t\tret[0] = i+trailingZeros;\n\t\t\t}\n\t\t\tif(runningSum == 2*targetSum && ret[1] == -1){\n\t\t\t\t\tret[1] = i+1+trailingZeros;\n\t\t\t}\n\t\t}\n\n\t\tif(ret[1] >= N)// if first split has gone beyond the input array length, then we can't split.\n\t\t\treturn new int[]{-1, -1};\n\n\t\tint splitSum = 0 ;\n\t\tfor(int i = 0;i <= ret[0];i++) splitSum += A[i];\n\t\tif(splitSum != targetSum)return new int[]{-1,-1};\n\n\t\tsplitSum = 0;\n\t\tfor(int i = ret[0]+1;i < ret[1];i++) splitSum += A[i];\n\t\tif(splitSum != targetSum)return new int[]{-1,-1};\n\n\t\tfor(int i = N-1, j = ret[1]-1, k = ret[0]; i >= ret[1] && j >= ret[0]+1 && k >= 0; i--,j--,k--){\n\t\t\tint uniqBits = A[i]+A[j]+A[k];\n\t\t\tif(!(uniqBits == 3 || uniqBits == 0))return new int[]{-1, -1};\n\t\t}\n\n\t\treturn ret;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183912,
                "title": "c-it-is-hard-level-algorithm-and-i-could-not-make-it-in-the-contest",
                "content": "Oct. 20, 2018\\n927. Three Equal Parts\\n\\nIt is the third algorithm in weekly contest 107. I did come out the idea but my code had a few bugs in the contest. It took me more than 30 minutes in the contest and 20 minutes after the contest to make the code work. I also simplify the logic to make it readable. \\n\\nThe idea is to determine how many one in integer array. So first count how many one\\'s in total using one iteration. And then it is true that number of 1 should be divisible by 3. And then the number without considing leading zero can be determined by the map of 1 with its index. \\n\\n1. Count how many 1 in the integer array, save each 1 and its index to a hashmap\\n2. Determine the number in each part using binary string. \\n3. Compare three numbers in three parts to make sure they are the same\\n4. Considering leading zero, determine the two indexes to return. \\n\\nI made mistakes when I caculated a few numbers, one is ``` int index2 = map[number1];```, I could not determine second number\\'s start index; one is to compare third number with first number and second number. Using string compare is to shorten the time to write my own comparison. ``` var digitsString = string.Join(string.Empty, digits); // look up stackoverflow.com```, I had to learn how to convert integer array to a string using C#. \\n\\nHere is my C# code to pass online judge after the contest. \\n\\n```\\npublic class Solution {\\n    public int[] ThreeEqualParts(int[] digits)\\n        {\\n            var notFound = new int[] { -1, -1 };\\n\\n            if (digits == null)\\n                return notFound;\\n\\n            var countof1 = 0;\\n            var length = digits.Length;\\n            var map = new Dictionary<int, int>();\\n            for (int i = 0; i < length; i++)\\n            {\\n                if (digits[i] == 1)\\n                {\\n                    map.Add(countof1, i);\\n                    countof1++;\\n                }\\n            }\\n\\n            if (countof1 % 3 != 0)\\n                return notFound;\\n\\n            if (countof1 == 0)\\n                return new int[] { 0, 2 };\\n\\n            int number1 = countof1 / 3;\\n\\n            // narrow down the number without considering leading zero\\n            int thirdNumberStart = map[countof1 - number1];\\n\\n            // constraint\\n            int minimumLength = length - thirdNumberStart; // substring of number, there are some leading 0s maybe. \\n\\n            // compare the first number with third number            \\n            int index1 = map[0];\\n            int index2 = map[number1];\\n            int index3 = map[countof1 - number1]; // test using countof1 = 3, 2 ; 6;\\n\\n            if (length - index1 + 1 < 3 * minimumLength)\\n                return notFound;\\n\\n            var digitsString = string.Join(string.Empty, digits); // look up stackoverflow.com\\n\\n            var number = digitsString.Substring(thirdNumberStart);\\n            var firstNumber = digitsString.Substring(index1, minimumLength);\\n            var secondNumber = digitsString.Substring(index2, minimumLength);\\n\\n            var result = number.CompareTo(firstNumber) == 0 && number.CompareTo(secondNumber) == 0;\\n            if (!result)\\n            {\\n                return notFound;\\n            }\\n            //               last digit of first number   third number\\'s first digit\\n            return new int[] { index1 + minimumLength - 1, index2 + minimumLength };\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "``` int index2 = map[number1];```\n``` var digitsString = string.Join(string.Empty, digits); // look up stackoverflow.com```\n```\\npublic class Solution {\\n    public int[] ThreeEqualParts(int[] digits)\\n        {\\n            var notFound = new int[] { -1, -1 };\\n\\n            if (digits == null)\\n                return notFound;\\n\\n            var countof1 = 0;\\n            var length = digits.Length;\\n            var map = new Dictionary<int, int>();\\n            for (int i = 0; i < length; i++)\\n            {\\n                if (digits[i] == 1)\\n                {\\n                    map.Add(countof1, i);\\n                    countof1++;\\n                }\\n            }\\n\\n            if (countof1 % 3 != 0)\\n                return notFound;\\n\\n            if (countof1 == 0)\\n                return new int[] { 0, 2 };\\n\\n            int number1 = countof1 / 3;\\n\\n            // narrow down the number without considering leading zero\\n            int thirdNumberStart = map[countof1 - number1];\\n\\n            // constraint\\n            int minimumLength = length - thirdNumberStart; // substring of number, there are some leading 0s maybe. \\n\\n            // compare the first number with third number            \\n            int index1 = map[0];\\n            int index2 = map[number1];\\n            int index3 = map[countof1 - number1]; // test using countof1 = 3, 2 ; 6;\\n\\n            if (length - index1 + 1 < 3 * minimumLength)\\n                return notFound;\\n\\n            var digitsString = string.Join(string.Empty, digits); // look up stackoverflow.com\\n\\n            var number = digitsString.Substring(thirdNumberStart);\\n            var firstNumber = digitsString.Substring(index1, minimumLength);\\n            var secondNumber = digitsString.Substring(index2, minimumLength);\\n\\n            var result = number.CompareTo(firstNumber) == 0 && number.CompareTo(secondNumber) == 0;\\n            if (!result)\\n            {\\n                return notFound;\\n            }\\n            //               last digit of first number   third number\\'s first digit\\n            return new int[] { index1 + minimumLength - 1, index2 + minimumLength };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183878,
                "title": "c-o-n-time-o-1-space-40ms",
                "content": "First count the total number of 1s. If it is not a multiple of 3, then it is not possible.\nOtherwise divide it by 3, we can get the number of 1s should be in each partition. The only uncertain thing now is the number tailing zeros for each partition. However, this can be easily determined by the last partition.\nNow, we konw the number of 1s for each partition and the number of tailing zeros for each partition, we can directly calculate the partition positions. \n\nC++ code here [wrote in the contest, maybe can be optimize further]:\n\n```\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        \n        int c = 0; // count the 1\n        for (auto& x : A) {\n            if (x == 1) {\n                ++c;\n            }\n        }\n        \n        if (c % 3 != 0) {\n            return {-1, -1};\n        }\n        if (c == 0) {\n            return {0,2};\n        }\n        \n        int n = c / 3;\n        int nZero = 0;\n        for (int i = A.size()-1; i >= 0; --i) {\n            if (A[i] == 0) {\n                ++nZero;\n            }\n            else {\n                break;\n            }\n        }\n        \n        // a and b are the partitioning position\n        int a, b;\n        \n        \n        // calculate a\n        a = 0;\n        c = 0; // count the 1\n        while(c < n) {\n            if (A[a] == 0) {\n                ++a;\n            }\n            else {\n                ++a;\n                ++c;\n            }\n        }\n        c = 0; // count the 0\n        while(c < nZero) {\n            if (A[a] == 0) {\n                ++c;\n                ++a;\n            }\n            else {\n                return {-1, -1};\n            }\n        }\n        --a;\n        \n        // calculate b\n        b = a + 1;       \n        c = 0; // count 1\n        while(c < n) {\n            if (A[b] == 0) {\n                ++b;\n            }\n            else {\n                ++b;\n                ++c;\n            }\n        }\n        c = 0; // count 0\n        while(c < nZero) {\n            if (A[b] == 0) {\n                ++c;\n                ++b;\n            }\n            else {\n                return {-1, -1};\n            }\n        }\n        \n        // verify a, b\n        if (verify(A, 0, a, a+1, b-1) && verify(A, 0, a, b, A.size()-1)) {\n            return {a, b};\n        }\n        else {\n            return {-1, -1};\n        }\n    }\nprivate:\n    bool verify(vector<int>& A, int lo1, int hi1, int lo2, int hi2) {\n        int p1 = lo1;\n        int p2 = lo2;\n        while(A[p1] == 0 && p1 <= hi1) ++p1;\n        while(A[p2] == 0 && p2 <= hi2) ++p2;\n        \n        if (hi1 - p1 != hi2 - p2) {\n            return false;\n        }\n        \n        while(p1 < hi1) {\n            if (A[p1] != A[p2]) {\n                return false;\n            }\n            else {\n                ++p1;\n                ++p2;\n            }\n        }\n        \n        return true;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        \n        int c = 0; // count the 1\n        for (auto& x : A) {\n            if (x == 1) {\n                ++c;\n            }\n        }\n        \n        if (c % 3 != 0) {\n            return {-1, -1};\n        }\n        if (c == 0) {\n            return {0,2};\n        }\n        \n        int n = c / 3;\n        int nZero = 0;\n        for (int i = A.size()-1; i >= 0; --i) {\n            if (A[i] == 0) {\n                ++nZero;\n            }\n            else {\n                break;\n            }\n        }\n        \n        // a and b are the partitioning position\n        int a, b;\n        \n        \n        // calculate a\n        a = 0;\n        c = 0; // count the 1\n        while(c < n) {\n            if (A[a] == 0) {\n                ++a;\n            }\n            else {\n                ++a;\n                ++c;\n            }\n        }\n        c = 0; // count the 0\n        while(c < nZero) {\n            if (A[a] == 0) {\n                ++c;\n                ++a;\n            }\n            else {\n                return {-1, -1};\n            }\n        }\n        --a;\n        \n        // calculate b\n        b = a + 1;       \n        c = 0; // count 1\n        while(c < n) {\n            if (A[b] == 0) {\n                ++b;\n            }\n            else {\n                ++b;\n                ++c;\n            }\n        }\n        c = 0; // count 0\n        while(c < nZero) {\n            if (A[b] == 0) {\n                ++c;\n                ++b;\n            }\n            else {\n                return {-1, -1};\n            }\n        }\n        \n        // verify a, b\n        if (verify(A, 0, a, a+1, b-1) && verify(A, 0, a, b, A.size()-1)) {\n            return {a, b};\n        }\n        else {\n            return {-1, -1};\n        }\n    }\nprivate:\n    bool verify(vector<int>& A, int lo1, int hi1, int lo2, int hi2) {\n        int p1 = lo1;\n        int p2 = lo2;\n        while(A[p1] == 0 && p1 <= hi1) ++p1;\n        while(A[p2] == 0 && p2 <= hi2) ++p2;\n        \n        if (hi1 - p1 != hi2 - p2) {\n            return false;\n        }\n        \n        while(p1 < hi1) {\n            if (A[p1] != A[p2]) {\n                return false;\n            }\n            else {\n                ++p1;\n                ++p2;\n            }\n        }\n        \n        return true;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873616,
                "title": "z-function-bashing",
                "content": "We first skip the leading zeroes. Then, in order for the last part to equal the first part, its starting index `i` must satisfy `i + z[i] == n`. Then, the middle part must start at the first one past the end of the first part. We can precompute the first one past any index in `O(n)`, so the middle part starts at `j = first_one[z[i]]`. We then need the middle part to satisfy `z[j] >= z[i]` and `first_one[j + z[i]] == i`.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        auto it = std::find(arr.begin(), arr.end(), 1);\\n        if (it == arr.end()) return {0, 2};\\n        int n = arr.end() - it;\\n        int off = it - arr.begin();\\n        std::vector<int> ns(n + 1);\\n        ns.back() = n;\\n        for (int i = n; i--; ns[i] = it[i] == 1 ? i : ns[i + 1]);\\n        std::vector<int> z(n);\\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n            if (i < r) {\\n                z[i] = std::min(z[i - l], r - i);\\n            }\\n            while (i + z[i] < n && it[i + z[i]] == it[z[i]]) ++z[i];\\n            if (i + z[i] > r) {\\n                l = i;\\n                r = i + z[i];\\n            }\\n            if (i + z[i] == n && ns[z[i]] < i && z[ns[z[i]]] >= z[i] && ns[ns[z[i]] + z[i]] == i) {\\n                return {off + z[i] - 1, off + ns[z[i]] + z[i]};\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        auto it = std::find(arr.begin(), arr.end(), 1);\\n        if (it == arr.end()) return {0, 2};\\n        int n = arr.end() - it;\\n        int off = it - arr.begin();\\n        std::vector<int> ns(n + 1);\\n        ns.back() = n;\\n        for (int i = n; i--; ns[i] = it[i] == 1 ? i : ns[i + 1]);\\n        std::vector<int> z(n);\\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n            if (i < r) {\\n                z[i] = std::min(z[i - l], r - i);\\n            }\\n            while (i + z[i] < n && it[i + z[i]] == it[z[i]]) ++z[i];\\n            if (i + z[i] > r) {\\n                l = i;\\n                r = i + z[i];\\n            }\\n            if (i + z[i] == n && ns[z[i]] < i && z[ns[z[i]]] >= z[i] && ns[ns[z[i]] + z[i]] == i) {\\n                return {off + z[i] - 1, off + ns[z[i]] + z[i]};\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733985,
                "title": "c-o-n-solution-check-if-first-two-parts-match-last-part",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Not possible if count of ones isn\\'t divisible by 3 and each part will have (count of ones / 3) ones\\n- Last part of array determines what the other 2 parts must equal since any leading zeros won\\'t affect what the last part will be (ex [1,1,0,0,1] -> last part can be 1, 01, 001 and will always be the same value)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Knowing the number that each part is suppose to be makes it an easy check of positions of ones and non leading zeros match the last part\\n- If they don\\'t match return {-1, -1}\\n- Otherwise you know where each part ends\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int countOnes = 0;\\n        for(int& i : arr){\\n            if(i == 1) countOnes++;\\n        }\\n        if(countOnes % 3 != 0) return {-1, -1};\\n        if(countOnes == 0) return{0, (int)arr.size() - 1};\\n        countOnes /= 3;\\n\\n        //find last part\\n        int lastPartStart = arr.size() - 1, currOnes = 0;\\n        while(lastPartStart >= 0 && currOnes < countOnes){\\n            if(arr[lastPartStart] == 1){\\n                currOnes++;\\n            }\\n            lastPartStart--;\\n        }\\n        \\n        //check if first part matches last part\\n        int firstPartEnd = 0;\\n        while(arr[firstPartEnd] == 0) firstPartEnd++;\\n        for(int r = lastPartStart + 1; r < arr.size(); firstPartEnd++, r++){\\n            if(arr[firstPartEnd] != arr[r]) return {-1, -1};\\n        }\\n        firstPartEnd--;\\n\\n        //check if second part matches last part\\n        int lastIndexStart = firstPartEnd + 1;\\n        while(arr[lastIndexStart] == 0) lastIndexStart++;\\n        for(int r = lastPartStart + 1; r < arr.size(); lastIndexStart++, r++){\\n            if(arr[lastIndexStart] != arr[r]) return {-1, -1};\\n        }\\n\\n        return {firstPartEnd, lastIndexStart};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int countOnes = 0;\\n        for(int& i : arr){\\n            if(i == 1) countOnes++;\\n        }\\n        if(countOnes % 3 != 0) return {-1, -1};\\n        if(countOnes == 0) return{0, (int)arr.size() - 1};\\n        countOnes /= 3;\\n\\n        //find last part\\n        int lastPartStart = arr.size() - 1, currOnes = 0;\\n        while(lastPartStart >= 0 && currOnes < countOnes){\\n            if(arr[lastPartStart] == 1){\\n                currOnes++;\\n            }\\n            lastPartStart--;\\n        }\\n        \\n        //check if first part matches last part\\n        int firstPartEnd = 0;\\n        while(arr[firstPartEnd] == 0) firstPartEnd++;\\n        for(int r = lastPartStart + 1; r < arr.size(); firstPartEnd++, r++){\\n            if(arr[firstPartEnd] != arr[r]) return {-1, -1};\\n        }\\n        firstPartEnd--;\\n\\n        //check if second part matches last part\\n        int lastIndexStart = firstPartEnd + 1;\\n        while(arr[lastIndexStart] == 0) lastIndexStart++;\\n        for(int r = lastPartStart + 1; r < arr.size(); lastIndexStart++, r++){\\n            if(arr[lastIndexStart] != arr[r]) return {-1, -1};\\n        }\\n\\n        return {firstPartEnd, lastIndexStart};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625985,
                "title": "c-equal-binary-parts",
                "content": "# Intuition\\nThe problem asks us to divide an array into three parts such that each part represents the same binary value. We need to find the indices where we can split the array into three parts and check if each part has the same binary value.\\n# Approach\\n1. Count the number of ones in the given array. Let\\'s denote this count as `oneCount`.\\n2. If the `oneCount` is not divisible by 3, it is not possible to divide the array into three equal parts with the same binary value. In this case, return `[-1, -1]`.\\n3. If the `oneCount` is 0, it means the array consists of all zeros. In this case, we can divide the array at indices 0 and `n-1`, where `n` is the length of the array. Return `[0, n-1]`.\\n4. Calculate the target binary value for each part, which is equal to `oneCount / 3`.\\n5. Find the indices `firstOneIdx`, `secondOneIdx`, and `thirdOneIdx` where the first, second, and third target binary values end, respectively.\\n6. Check if the suffix starting from thirdOneIdx has the same binary value as the prefix starting from `firstOneIdx`. If it does, return `[firstOneIdx-1, secondOneIdx]` as the indices where the array can be divided into three equal parts. Otherwise, `return [-1, -1]`.\\n# Complexity\\n- Time complexity:\\nThe algorithm traverses the array once to count the number of ones, which takes O(n) time, where n is the length of the array. Therefore, the time complexity of the algorithm is `O(n)`.\\n- Space complexity:\\nThe algorithm uses a constant amount of extra space, so the space complexity is `O(1)`.\\n# Code\\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        int oneCount = 0;\\n        int n = arr.size();\\n\\n        // Count the number of ones\\n        for (int num : arr) {\\n            if (num == 1) {\\n                oneCount++;\\n            }\\n        }\\n\\n        // If oneCount is not divisible by 3, return {-1, -1}\\n        if (oneCount % 3 != 0) {\\n            return {-1, -1};\\n        }\\n\\n        // If oneCount is 0, return {0, n-1}\\n        if (oneCount == 0) {\\n            return {0, n - 1};\\n        }\\n\\n        // Calculate the target binary value\\n        int target = oneCount / 3;\\n\\n        int firstOneIdx = -1;\\n        int secondOneIdx = -1;\\n        int thirdOneIdx = -1;\\n\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) {\\n                count++;\\n\\n                if (count == 1)\\n                    firstOneIdx = i;\\n                else if (count == target + 1)\\n                    secondOneIdx = i;\\n                else if (count == 2 * target + 1)\\n                    thirdOneIdx = i;\\n            }\\n        }\\n\\n        // Find the matching suffix\\n        while (thirdOneIdx < n && arr[firstOneIdx] == arr[secondOneIdx] && arr[secondOneIdx] == arr[thirdOneIdx]) {\\n            firstOneIdx++;\\n            secondOneIdx++;\\n            thirdOneIdx++;\\n        }\\n\\n        // If the matching suffix is found, return the indices\\n        if (thirdOneIdx == n) {\\n            return {firstOneIdx - 1, secondOneIdx};\\n        } else {\\n            return {-1, -1};\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        int oneCount = 0;\\n        int n = arr.size();\\n\\n        // Count the number of ones\\n        for (int num : arr) {\\n            if (num == 1) {\\n                oneCount++;\\n            }\\n        }\\n\\n        // If oneCount is not divisible by 3, return {-1, -1}\\n        if (oneCount % 3 != 0) {\\n            return {-1, -1};\\n        }\\n\\n        // If oneCount is 0, return {0, n-1}\\n        if (oneCount == 0) {\\n            return {0, n - 1};\\n        }\\n\\n        // Calculate the target binary value\\n        int target = oneCount / 3;\\n\\n        int firstOneIdx = -1;\\n        int secondOneIdx = -1;\\n        int thirdOneIdx = -1;\\n\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) {\\n                count++;\\n\\n                if (count == 1)\\n                    firstOneIdx = i;\\n                else if (count == target + 1)\\n                    secondOneIdx = i;\\n                else if (count == 2 * target + 1)\\n                    thirdOneIdx = i;\\n            }\\n        }\\n\\n        // Find the matching suffix\\n        while (thirdOneIdx < n && arr[firstOneIdx] == arr[secondOneIdx] && arr[secondOneIdx] == arr[thirdOneIdx]) {\\n            firstOneIdx++;\\n            secondOneIdx++;\\n            thirdOneIdx++;\\n        }\\n\\n        // If the matching suffix is found, return the indices\\n        if (thirdOneIdx == n) {\\n            return {firstOneIdx - 1, secondOneIdx};\\n        } else {\\n            return {-1, -1};\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3454023,
                "title": "solution-based-on-substrings-rather-than-subarrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter my first couple of attempts to solve this problem, I realized that because of the limits of the inputs, it was possible to end up with three numbers of 10,000 digits each, which requires the use of expensive unlimited-precision integers.  So, I changed my basic approach to convert the array into a string of \"0\"s and \"1\"s and to determine whether the three substrings are string-equivalent rather than comparing the numeric values of the subarrays.  One thing that complicates this is the presence of the leading zeros, because it\\'s necessary to treat the substrings \"11\" and \"011\" as numerically equivalent even though they\\'re not string equivalent, but we\\'ll handle this.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlthough searching for three equivalent substrings should require a doubly-nested loop (think of it as looping over possible values of \"i\" and \"j\"), we can get away with a single loop over \"i\" because we\\'re looking for substrings that are string-equivalent, hence the same length, so knowing \"i\", we have determined \"j\" -- basically 2 * i.  However, as noted above, we have to consider leading zeros in any or all of the three substrings.  We can eliminate the leading zeros for the left-most substring by searching for the first \"1\" in the string.  For each value of \"i\" and discounting the leading 0\\'s, we can compute \"j\" if we also take into account the leading 0\\'s in the middle and right substrings.  So, the basic logic is:\\n```\\nfor each i from 0 up to n:\\n    calculate left substring and \"i\", skipping leading zeros\\n    calculate mid substring and \"j\", skipping leading zeros\\n    calculate right substring, skipping leading zeros\\n    if left, mid and right substrings are ==, return [ i, j ]\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe iteration over ```i``` is $$O(n)$$ and within that loop,\\nthe calculation does not depend on $$n$$, so the basic complexity\\nis $$O(n)$$.  However, there\\'s another factor -- the comparison of\\nleft, mid and right substrings.  That is another factor of $$O(n)$$, so the overall complexity is $$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only storage that depends on $$n$$ is for the String converted from the input array; its space complexity is $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    # What we\\'re going to do in this version is convert the array of 0\\'s and 1\\'s \\n    # into a string consisting of \"0\"s and \"1\"s.\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len( arr )\\n        arr_str = \\'\\'.join( map( str, arr ) )  # Convert array of 0\\'s and 1\\'s to string of \"0\"s and \"1\"s\\n        left_leading_one_index = arr_str.find( \"1\" )\\n        if left_leading_one_index < 0:  # No 1\\'s anywhere\\n            return [ 0, 2 ]  # Take left=first 0, mid=second 0, and right=the rest of the zero\\'s \\n        for i in range( left_leading_one_index, n - 1 ):\\n            left_string = arr_str[ left_leading_one_index : i + 1 ]\\n            mid_leading_one_index = arr_str.find( \"1\", i + 1 )\\n            mid_stop_index = mid_leading_one_index + len( left_string )\\n            if mid_stop_index + len( left_string ) > n:\\n                return [ -1, -1 ]   # No room for mid and right within \"arr\"\\n            right_leading_one_index = arr_str.find( \"1\", mid_stop_index )\\n            if right_leading_one_index < 0:   # No 1\\'s in right\\n                return [ -1, -1 ]\\n            mid_string = arr_str[ mid_leading_one_index : mid_stop_index ]\\n            right_string = arr_str[ right_leading_one_index : n ]\\n            if left_string == mid_string and left_string == right_string:\\n                return [ i, mid_stop_index ]\\n        return [ -1, -1 ]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfor each i from 0 up to n:\\n    calculate left substring and \"i\", skipping leading zeros\\n    calculate mid substring and \"j\", skipping leading zeros\\n    calculate right substring, skipping leading zeros\\n    if left, mid and right substrings are ==, return [ i, j ]\\n```\n```i```\n```\\nclass Solution:\\n    # What we\\'re going to do in this version is convert the array of 0\\'s and 1\\'s \\n    # into a string consisting of \"0\"s and \"1\"s.\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len( arr )\\n        arr_str = \\'\\'.join( map( str, arr ) )  # Convert array of 0\\'s and 1\\'s to string of \"0\"s and \"1\"s\\n        left_leading_one_index = arr_str.find( \"1\" )\\n        if left_leading_one_index < 0:  # No 1\\'s anywhere\\n            return [ 0, 2 ]  # Take left=first 0, mid=second 0, and right=the rest of the zero\\'s \\n        for i in range( left_leading_one_index, n - 1 ):\\n            left_string = arr_str[ left_leading_one_index : i + 1 ]\\n            mid_leading_one_index = arr_str.find( \"1\", i + 1 )\\n            mid_stop_index = mid_leading_one_index + len( left_string )\\n            if mid_stop_index + len( left_string ) > n:\\n                return [ -1, -1 ]   # No room for mid and right within \"arr\"\\n            right_leading_one_index = arr_str.find( \"1\", mid_stop_index )\\n            if right_leading_one_index < 0:   # No 1\\'s in right\\n                return [ -1, -1 ]\\n            mid_string = arr_str[ mid_leading_one_index : mid_stop_index ]\\n            right_string = arr_str[ right_leading_one_index : n ]\\n            if left_string == mid_string and left_string == right_string:\\n                return [ i, mid_stop_index ]\\n        return [ -1, -1 ]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398016,
                "title": "ruby-1-liner",
                "content": "```\\ndef three_equal_parts(a) =\\n\\n  a.sum>0 ? a.join[/^((0*(1.*))0*\\\\3)0*\\\\3$/] ? [$2.size-1,$1.size] : [-1,-1] : [0,2]\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef three_equal_parts(a) =\\n\\n  a.sum>0 ? a.join[/^((0*(1.*))0*\\\\3)0*\\\\3$/] ? [$2.size-1,$1.size] : [-1,-1] : [0,2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3319305,
                "title": "c-o-n-time-and-o-1-space",
                "content": "# Please Upvote If Usefull, Means a Lot.\\n**Intution**\\n*  We Have to Divide Array into 3 parts Such That They represent Same Binary Number.\\n\\n\\n*  It is Only Possible if Numbers of 1\\'s in Array is Multiple of 3.\\n*  if it is Mltiple of 3 , then lets say 3 parts as **{1st , 2nd and 3rd} parts**\\n\\t*  We will First Find 3rd parts  From Last as Shown in Code and it is Mandatory  all 3 parts represnt same binnary Number....  . lets say 3rd parts Represent Binnary number as Z,then.\\n\\t*  then we wil find First part from Starting , such that we will exclude Leading Zero in that and Compare it with 3rd Parts Binary number.\\n\\t*  and at last we will find  2nd Parts.\\n\\n**And our anser will be end point of first (f) and starting point of 3rd parts(s). { f,s} As Described in Question**\\n\\n**Note : IF All Element in Array are Zero i.e, no. of Ones is Zero then answer will be { 0, size of array-1}**\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& a) {\\n        \\n        int n=a.size(), on=0;\\n        \\n        for( int x:a) if(x==1) on++;\\n        \\n        if(on==0) return {0,n-1};\\n        if(on%3!=0) return {-1,-1};\\n        \\n        on=on/3;\\n        string st=\"\",st1=\"\",th=\"\";\\n        int i=n-1,co=0,f=-1,s=-1;\\n        \\n        // 3rd part.\\n        while(i>=0 ){ \\n            if(a[i]==1) co++;\\n            st=to_string(a[i])+st;\\n            \\n            if(co==on){\\n                th=st;\\n                co=0;\\n                st=\"\";\\n                break;\\n            }\\n            i--;\\n        }\\n        int p=i,j=0;\\n        \\n        // Removing zeroes frome Start.\\n        while( j<n && a[j]==0) j++;\\n        \\n        // 1st part\\n        while( j<n && f==-1){\\n            if(a[j]==1) co++;\\n            st+=to_string(a[j]);\\n            \\n            if(co==on && st==th){\\n                co=0;\\n                f=j;\\n                st=\"\";\\n            }\\n            j++;\\n        }\\n        \\n        // Removing  leading Zero in 2nd part.\\n        while( j<n && a[j]==0) j++;\\n        \\n        // 2nd part.\\n        while( j<n &&s==-1 ){ \\n            if(a[j]==1) co++;\\n            st+=to_string(a[j]);\\n            \\n            if(co==on && st==th ){\\n                co=0;\\n                s=j;\\n                st=\"\";\\n            }\\n            j++;\\n        }\\n        if(s==-1) return {-1,-1};\\n        return {f,j};       \\n    }\\n};\\n```\\n\\n**If You Have any Doubt , Fell Free to Asksed.**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& a) {\\n        \\n        int n=a.size(), on=0;\\n        \\n        for( int x:a) if(x==1) on++;\\n        \\n        if(on==0) return {0,n-1};\\n        if(on%3!=0) return {-1,-1};\\n        \\n        on=on/3;\\n        string st=\"\",st1=\"\",th=\"\";\\n        int i=n-1,co=0,f=-1,s=-1;\\n        \\n        // 3rd part.\\n        while(i>=0 ){ \\n            if(a[i]==1) co++;\\n            st=to_string(a[i])+st;\\n            \\n            if(co==on){\\n                th=st;\\n                co=0;\\n                st=\"\";\\n                break;\\n            }\\n            i--;\\n        }\\n        int p=i,j=0;\\n        \\n        // Removing zeroes frome Start.\\n        while( j<n && a[j]==0) j++;\\n        \\n        // 1st part\\n        while( j<n && f==-1){\\n            if(a[j]==1) co++;\\n            st+=to_string(a[j]);\\n            \\n            if(co==on && st==th){\\n                co=0;\\n                f=j;\\n                st=\"\";\\n            }\\n            j++;\\n        }\\n        \\n        // Removing  leading Zero in 2nd part.\\n        while( j<n && a[j]==0) j++;\\n        \\n        // 2nd part.\\n        while( j<n &&s==-1 ){ \\n            if(a[j]==1) co++;\\n            st+=to_string(a[j]);\\n            \\n            if(co==on && st==th ){\\n                co=0;\\n                s=j;\\n                st=\"\";\\n            }\\n            j++;\\n        }\\n        if(s==-1) return {-1,-1};\\n        return {f,j};       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221561,
                "title": "java-two-pointers-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int[] ans=new int[] {-1,-1};\\n        int ones=0;\\n        for(int x:arr) ones+=x;\\n        if(ones==0) return new int[] {0,2};\\n        if(ones%3!=0) return ans;\\n        int onesInEachPart=ones/3;\\n        int firstOneIndexPart1=-1;\\n        int firstOneIndexPart2=-1;\\n        int firstOneIndexPart3=-1;\\n        ones=0;\\n        for(int i=0; i<arr.length;i++) {\\n            if(arr[i]==1) {\\n            ones++;\\n            if(ones==1) firstOneIndexPart1=i;\\n            else if(ones==onesInEachPart+1) firstOneIndexPart2=i;\\n            else if(ones==2*(onesInEachPart)+1) firstOneIndexPart3=i;\\n        }\\n        }\\n        while(firstOneIndexPart3<arr.length) {\\n            if(arr[firstOneIndexPart3]==arr[firstOneIndexPart1] && arr[firstOneIndexPart3]==arr[firstOneIndexPart2]) {\\n                firstOneIndexPart1++;\\n                firstOneIndexPart2++;\\n                firstOneIndexPart3++;\\n            }\\n            else {\\n                return ans;\\n            }\\n        }\\n    return new int[] {firstOneIndexPart1-1,firstOneIndexPart2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int[] ans=new int[] {-1,-1};\\n        int ones=0;\\n        for(int x:arr) ones+=x;\\n        if(ones==0) return new int[] {0,2};\\n        if(ones%3!=0) return ans;\\n        int onesInEachPart=ones/3;\\n        int firstOneIndexPart1=-1;\\n        int firstOneIndexPart2=-1;\\n        int firstOneIndexPart3=-1;\\n        ones=0;\\n        for(int i=0; i<arr.length;i++) {\\n            if(arr[i]==1) {\\n            ones++;\\n            if(ones==1) firstOneIndexPart1=i;\\n            else if(ones==onesInEachPart+1) firstOneIndexPart2=i;\\n            else if(ones==2*(onesInEachPart)+1) firstOneIndexPart3=i;\\n        }\\n        }\\n        while(firstOneIndexPart3<arr.length) {\\n            if(arr[firstOneIndexPart3]==arr[firstOneIndexPart1] && arr[firstOneIndexPart3]==arr[firstOneIndexPart2]) {\\n                firstOneIndexPart1++;\\n                firstOneIndexPart2++;\\n                firstOneIndexPart3++;\\n            }\\n            else {\\n                return ans;\\n            }\\n        }\\n    return new int[] {firstOneIndexPart1-1,firstOneIndexPart2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136224,
                "title": "python-96-straightforward-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = sum(arr)\\n        if n % 3: return [-1, -1]\\n        if n == 0: return [0, 2]\\n        k, indices = n // 3, []\\n        for i, num in enumerate(arr):\\n            if num: indices.append(i)\\n        i1, i2, i3, i, j = *[indices[-(j * k)] for j in (3, 2, 1)], 0 ,0\\n        part1, part2, part3 = arr[i1: i2], arr[i2: i3], arr[i3:]\\n        l1, l2, l3 = i2 - i1, i3 - i2, len(part3)\\n        if l3 > l2 or part2[:l3] != part3 or l3 > l1 or part1[:l3] != part3: return [-1, -1]\\n        i, j = i1 + l3 - 1, i2 + l3\\n        return [i, j]\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = sum(arr)\\n        if n % 3: return [-1, -1]\\n        if n == 0: return [0, 2]\\n        k, indices = n // 3, []\\n        for i, num in enumerate(arr):\\n            if num: indices.append(i)\\n        i1, i2, i3, i, j = *[indices[-(j * k)] for j in (3, 2, 1)], 0 ,0\\n        part1, part2, part3 = arr[i1: i2], arr[i2: i3], arr[i3:]\\n        l1, l2, l3 = i2 - i1, i3 - i2, len(part3)\\n        if l3 > l2 or part2[:l3] != part3 or l3 > l1 or part1[:l3] != part3: return [-1, -1]\\n        i, j = i1 + l3 - 1, i2 + l3\\n        return [i, j]\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066210,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr):\\n        n = len(arr)\\n\\n        res = [i for i in range(n) if arr[i] == 1]\\n\\n        p = len(res)\\n\\n        if p == 0:\\n            return [0,n-1]\\n\\n        id1, id2, id3 = res[0], res[p//3], res[2*p//3]\\n\\n        sub = n-id3\\n\\n        if p%3 == 0 and arr[id1:id1+sub] == arr[id2:id2+sub] == arr[id3:]:\\n            return [id1-1+sub,id2+sub]\\n\\n        return [-1,-1]\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr):\\n        n = len(arr)\\n\\n        res = [i for i in range(n) if arr[i] == 1]\\n\\n        p = len(res)\\n\\n        if p == 0:\\n            return [0,n-1]\\n\\n        id1, id2, id3 = res[0], res[p//3], res[2*p//3]\\n\\n        sub = n-id3\\n\\n        if p%3 == 0 and arr[id1:id1+sub] == arr[id2:id2+sub] == arr[id3:]:\\n            return [id1-1+sub,id2+sub]\\n\\n        return [-1,-1]\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065533,
                "title": "extremely-simple-explanation-solution-included",
                "content": "So the idea is pretty simple, and yes, like most of them, you have to count the number of ones first.\\n1. Count the number of ones (let\\'s call it `ones`). If it\\'s zero, return (0,size-1). If it isn\\'t a multiple of 3, return [-1,-1], and if it is a factor of 3, let\\'s proceed. *\\n\\n* Think about the array this way: \\n```\\n0 1 0 1 ... 0 1 | 1 1 0 ... 0 1 | 0 0 0 0 1 1 1 ... 1\\n     left       |    middle     |         right\\n```\\n2. Get the right side first. Is the only side you can calculate by just passing a pointer and reaching `ones//3` ones. So the value that has to be obtained for the three sides is forced. Here you get the `j` index.\\n3. Having the right side, now you can iterate a left index to see if you can reach the same value.  If we surpass the value of the right side, we can just return `[-1,-1]`. If you reach the value, you get the index `i`.\\n4. Now you can iterate over the middle to see if you can reach the same value as in the left and right sides. If you don\\'t reach it, return `[-1,-1]`.\\n5. If you got the value, the solution is done, because you got `ones` ones, so it\\'s complete.\\n\\n\\n* You need a multiple of three to be able to split the array into three equal bags since each of the subarrays will have `ones//3` ones. \\n\\n# Code\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Step 1: count ones and store info\\n        ones = arr.count(1)\\n        if ones % 3 != 0: return [ -1, -1 ]\\n        oneSize = ones // 3\\n\\n        # We start getting the right value\\n        size = len(arr)\\n        if not ones: return [0,size-1] # Particular case\\n        right = size\\n        rightValue = 0\\n        power = 1\\n        while oneSize > 0:\\n            right -= 1\\n            if arr[right] == 1:\\n                rightValue += power\\n                oneSize -= 1\\n            power <<= 1\\n        \\n        # We start getting the left value\\n        left = -1\\n        leftValue = 0\\n        while leftValue>>1 != rightValue:\\n            left += 1\\n            if arr[left] == 1:\\n                leftValue += 1\\n            leftValue <<= 1\\n            # If we can\\'t reach the value we want, we leave the process\\n            if leftValue>>1 > rightValue: return [-1,-1] \\n        leftValue >>= 1\\n\\n        # We start getting the third value\\n        third = 0\\n        answer = [left] # We got the last index we used for the left value\\n        left += 1 # We recycle the index from left\\n        while left < right:\\n            if arr[left] == 1:\\n                third += 1\\n            third <<= 1\\n            left += 1\\n            if third>>1 == rightValue: break\\n        third >>= 1\\n        # We got the three numbers. Now is matter of verifying.\\n        if third != rightValue: return [-1,-1]\\n        answer.append(left)\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n0 1 0 1 ... 0 1 | 1 1 0 ... 0 1 | 0 0 0 0 1 1 1 ... 1\\n     left       |    middle     |         right\\n```\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Step 1: count ones and store info\\n        ones = arr.count(1)\\n        if ones % 3 != 0: return [ -1, -1 ]\\n        oneSize = ones // 3\\n\\n        # We start getting the right value\\n        size = len(arr)\\n        if not ones: return [0,size-1] # Particular case\\n        right = size\\n        rightValue = 0\\n        power = 1\\n        while oneSize > 0:\\n            right -= 1\\n            if arr[right] == 1:\\n                rightValue += power\\n                oneSize -= 1\\n            power <<= 1\\n        \\n        # We start getting the left value\\n        left = -1\\n        leftValue = 0\\n        while leftValue>>1 != rightValue:\\n            left += 1\\n            if arr[left] == 1:\\n                leftValue += 1\\n            leftValue <<= 1\\n            # If we can\\'t reach the value we want, we leave the process\\n            if leftValue>>1 > rightValue: return [-1,-1] \\n        leftValue >>= 1\\n\\n        # We start getting the third value\\n        third = 0\\n        answer = [left] # We got the last index we used for the left value\\n        left += 1 # We recycle the index from left\\n        while left < right:\\n            if arr[left] == 1:\\n                third += 1\\n            third <<= 1\\n            left += 1\\n            if third>>1 == rightValue: break\\n        third >>= 1\\n        # We got the three numbers. Now is matter of verifying.\\n        if third != rightValue: return [-1,-1]\\n        answer.append(left)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014991,
                "title": "easy-java-solution",
                "content": "# Intuition\\n1) All the partitions must contain equal number of one to be equal.\\n\\n\\n# Complexity\\n- Time complexity: 0(n)\\n\\n\\n- Space complexity: 0(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;\\n        int countOfone = 0;\\n\\n        //Counting total number og ones\\n        for(int i:arr){\\n            if(i == 1){\\n                countOfone++;\\n            }\\n        }\\n\\n        //If number of Ones !== 3k\\n        //No need to check as equal p partitions not possible\\n        if(countOfone % 3 != 0)\\n            return new int[]{-1,-1};\\n\\n        //If the array only have zero\\n        if(countOfone == 0)\\n            return new int[]{0,n-1};\\n\\n        int k = countOfone/3;\\n        // Create a partition   \\n        int i1=-1, i2=-1, i3=-1, j1=-1, j2=-1, j3=-1;\\n        int currCount = 0;\\n//if countOfone is 1, k+1, 2k+1 --> assign i1, i2, i3 respectively\\n//if countOfone is k,2k,3k --> assign j1, j2, j3 respectively.\\n\\n        for(int i=0; i<n; i++){\\n            if(arr[i] == 1){\\n                currCount+=1;\\n                if(currCount ==1) i1 = i;\\n                if(currCount == (k+1)) i2=i;\\n                if(currCount == (2*k+1)) i3 = i;\\n\\n                if(currCount ==k) j1 = i;\\n                if(currCount ==2*k) j2 = i;\\n                if(currCount ==3*k) j3 = i;\\n            }\\n        }\\n\\n\\n        //Compare three partitions\\n        int[] part1 = Arrays.copyOfRange(arr, i1, j1+1);//+1 because last index is exclusive\\n        int[] part2 = Arrays.copyOfRange(arr, i2, j2+1);\\n        int[] part3 = Arrays.copyOfRange(arr, i3, j3+1);\\n\\n        if(!Arrays.equals(part1, part2) || !Arrays.equals(part1, part3))\\n            return new int[]{-1,-1};\\n\\n        // Take care of the trailing zeroes\\n        int first =0, second=0, third=0;\\n        first = i2-j1-1;//counting no of trailing zeroes.\\n        second = i3-j2-1;\\n        third = n-j3-1;\\n\\n        if(third > Math.min(first,second))\\n            return new int[]{-1,-1};\\n\\n        return new int[]{j1+third, j2+third+1};    \\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;\\n        int countOfone = 0;\\n\\n        //Counting total number og ones\\n        for(int i:arr){\\n            if(i == 1){\\n                countOfone++;\\n            }\\n        }\\n\\n        //If number of Ones !== 3k\\n        //No need to check as equal p partitions not possible\\n        if(countOfone % 3 != 0)\\n            return new int[]{-1,-1};\\n\\n        //If the array only have zero\\n        if(countOfone == 0)\\n            return new int[]{0,n-1};\\n\\n        int k = countOfone/3;\\n        // Create a partition   \\n        int i1=-1, i2=-1, i3=-1, j1=-1, j2=-1, j3=-1;\\n        int currCount = 0;\\n//if countOfone is 1, k+1, 2k+1 --> assign i1, i2, i3 respectively\\n//if countOfone is k,2k,3k --> assign j1, j2, j3 respectively.\\n\\n        for(int i=0; i<n; i++){\\n            if(arr[i] == 1){\\n                currCount+=1;\\n                if(currCount ==1) i1 = i;\\n                if(currCount == (k+1)) i2=i;\\n                if(currCount == (2*k+1)) i3 = i;\\n\\n                if(currCount ==k) j1 = i;\\n                if(currCount ==2*k) j2 = i;\\n                if(currCount ==3*k) j3 = i;\\n            }\\n        }\\n\\n\\n        //Compare three partitions\\n        int[] part1 = Arrays.copyOfRange(arr, i1, j1+1);//+1 because last index is exclusive\\n        int[] part2 = Arrays.copyOfRange(arr, i2, j2+1);\\n        int[] part3 = Arrays.copyOfRange(arr, i3, j3+1);\\n\\n        if(!Arrays.equals(part1, part2) || !Arrays.equals(part1, part3))\\n            return new int[]{-1,-1};\\n\\n        // Take care of the trailing zeroes\\n        int first =0, second=0, third=0;\\n        first = i2-j1-1;//counting no of trailing zeroes.\\n        second = i3-j2-1;\\n        third = n-j3-1;\\n\\n        if(third > Math.min(first,second))\\n            return new int[]{-1,-1};\\n\\n        return new int[]{j1+third, j2+third+1};    \\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923195,
                "title": "java-sde-sheet",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ones=0;\\n        int ans[]=new int[]{-1,-1};\\n        for(int i:arr) if(i==1) ones++;\\n        if(ones%3 != 0) return ans;\\n        if(ones == 0) return new int[]{0,2};\\n        int cut=ones/3;\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        int countones=0;\\n        for(int l=0;l<arr.length;l++){\\n            if(arr[l] == 1 )  {\\n                countones++;\\n            if(countones == ((2*cut) + 1)) k=l;\\n            else if(countones == cut + 1) j=l;\\n            else if(countones == 1)i=l;\\n            }\\n        }\\n        System.out.println(i+\" \"+j+\" \"+k);\\n        \\n        while(k<arr.length){\\n            if(arr[i]==arr[j] && arr[j]==arr[k] && arr[k]==arr[i]){\\n                i++;\\n                j++;\\n                k++;\\n            }else return ans;\\n        }\\n        return new int[]{i-1,j};\\n     \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ones=0;\\n        int ans[]=new int[]{-1,-1};\\n        for(int i:arr) if(i==1) ones++;\\n        if(ones%3 != 0) return ans;\\n        if(ones == 0) return new int[]{0,2};\\n        int cut=ones/3;\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        int countones=0;\\n        for(int l=0;l<arr.length;l++){\\n            if(arr[l] == 1 )  {\\n                countones++;\\n            if(countones == ((2*cut) + 1)) k=l;\\n            else if(countones == cut + 1) j=l;\\n            else if(countones == 1)i=l;\\n            }\\n        }\\n        System.out.println(i+\" \"+j+\" \"+k);\\n        \\n        while(k<arr.length){\\n            if(arr[i]==arr[j] && arr[j]==arr[k] && arr[k]==arr[i]){\\n                i++;\\n                j++;\\n                k++;\\n            }else return ans;\\n        }\\n        return new int[]{i-1,j};\\n     \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905899,
                "title": "python-o-n-o-1-pure-logic-deduction",
                "content": "# Intuition\\r\\nIf their are three equal parts, they must contain same amount of ones, and ends with same amount of zeros\\r\\nThe heading zeros is irrelevant\\r\\n\\r\\n# Approach\\r\\n- count ones, divide it by 3 to get ones count of each part\\r\\n- count tailing zeros, these zeros must contains in each part\\r\\n- hance we can get one and the only cut of I and J just in one parse\\r\\n- the last only thing we need to do, just check whether our cuts is legal\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$$O(n)$$\\r\\n- Space complexity:\\r\\n$$O(1)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def threeEqualParts(self, arr):\\r\\n        ones, remain = divmod(arr.count(1), 3)\\r\\n\\r\\n        if remain != 0: return [-1, -1]  # can not be divided equally\\r\\n        if ones == 0: return [0, 2]  # all zero\\r\\n\\r\\n        L, tail_zero_cnts = len(arr), arr[::-1].index(1)\\r\\n\\r\\n        I, J, cnt = 0, L - 1, 0\\r\\n        for i in filter(arr.__getitem__, range(L)):  # for all ones\\r\\n            cnt += 1\\r\\n            if cnt == ones:\\r\\n                I = i + tail_zero_cnts\\r\\n            if cnt == 2 * ones:\\r\\n                J = i + tail_zero_cnts\\r\\n                break\\r\\n\\r\\n        if int(\\'\\'.join(map(str, arr[:I + 1]))) == int(\\'\\'.join(map(str, arr[I + 1:J + 1]))) == int(\\'\\'.join(map(str, arr[J + 1:]))):\\r\\n            return [I, J + 1]\\r\\n\\r\\n        return [-1, -1]\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def threeEqualParts(self, arr):\\r\\n        ones, remain = divmod(arr.count(1), 3)\\r\\n\\r\\n        if remain != 0: return [-1, -1]  # can not be divided equally\\r\\n        if ones == 0: return [0, 2]  # all zero\\r\\n\\r\\n        L, tail_zero_cnts = len(arr), arr[::-1].index(1)\\r\\n\\r\\n        I, J, cnt = 0, L - 1, 0\\r\\n        for i in filter(arr.__getitem__, range(L)):  # for all ones\\r\\n            cnt += 1\\r\\n            if cnt == ones:\\r\\n                I = i + tail_zero_cnts\\r\\n            if cnt == 2 * ones:\\r\\n                J = i + tail_zero_cnts\\r\\n                break\\r\\n\\r\\n        if int(\\'\\'.join(map(str, arr[:I + 1]))) == int(\\'\\'.join(map(str, arr[I + 1:J + 1]))) == int(\\'\\'.join(map(str, arr[J + 1:]))):\\r\\n            return [I, J + 1]\\r\\n\\r\\n        return [-1, -1]\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858194,
                "title": "c-o-n-time-space",
                "content": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int len;\\n        vector<int> ones;\\n        for( int i=0; i<arr.size(); i++){\\n            if(arr[i]==1)   ones.push_back(i);\\n        }\\n\\n        len=ones.size();\\n        if(len%3!=0)    return {-1, -1};\\n        if(len==0)  return {0,(int)arr.size()-1};\\n        \\n        for( int i=1; i<ones.size()/3; i++){\\n            if(ones[i]-ones[i-1]!=ones[i+len/3]-ones[i+len/3-1]\\n                ||ones[i]-ones[i-1]!=ones[i+len/3*2]-ones[i+len/3*2-1]){\\n                return {-1, -1};\\n            }\\n        }\\n\\n        if(ones[len/3]-ones[len/3-1]-1<arr.size()-1-ones.back()\\n            ||ones[len/3*2]-ones[len/3*2-1]-1<arr.size()-1-ones.back())\\n            return {-1, -1};\\n\\n        return {ones[len/3-1]+(int)arr.size()-1-ones.back(), \\n            ones[len/3*2-1]+(int)arr.size()-1-ones.back()+1};\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int len;\\n        vector<int> ones;\\n        for( int i=0; i<arr.size(); i++){\\n            if(arr[i]==1)   ones.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2783702,
                "title": "easy-java-o-n-time-greedy-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. let say total # of ones = oneSum, then the # of ones in each of three numbers = oneSum / 3\\n2. greedy apporach is try to have least possbile # of zeros at the end of number.\\n3. the number of zeros at the end = length of zero suffix.\\n4. to find our number, try to first fill the ones, then fill the zeros. We got our number.\\n5. then to check if 2nd and 3rd number is present or not, match them from first occurence of one in both.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int oneSum = 0;\\n        for(int x : arr) oneSum +=x;\\n        if(oneSum % 3 !=0)return new int[]{-1,-1};\\n        if(oneSum == 0)return new int[]{0,2};\\n        int oneCount = oneSum / 3;\\n        int i = 0;\\n        int firstOne = -1;\\n        int n= arr.length;\\n        int lastZeroCount = 0;\\n        i = n-1;\\n        while(arr[i] ==0){\\n            lastZeroCount++;\\n            i--;\\n        }\\n        i=0;\\n        while(oneCount > 0){\\n            if(arr[i] == 1 && firstOne == -1)firstOne = i;\\n            oneCount-=arr[i++];\\n        }\\n        while(lastZeroCount > 0){\\n            if(arr[i++] == 1)return new int[]{-1,-1};\\n            lastZeroCount--;\\n        }\\n        int k = i--;\\n        int t = firstOne;\\n        while(arr[k] == 0)k++;\\n        while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        int j = k;\\n        while(arr[k] == 0)k++;\\n        firstOne = t;\\n         while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        return new int[]{i,j};\\n\\n    }\\n}\\n// 1 0 1 1 0 0 1 0 1 1 1 0 1 1\\n//[0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int oneSum = 0;\\n        for(int x : arr) oneSum +=x;\\n        if(oneSum % 3 !=0)return new int[]{-1,-1};\\n        if(oneSum == 0)return new int[]{0,2};\\n        int oneCount = oneSum / 3;\\n        int i = 0;\\n        int firstOne = -1;\\n        int n= arr.length;\\n        int lastZeroCount = 0;\\n        i = n-1;\\n        while(arr[i] ==0){\\n            lastZeroCount++;\\n            i--;\\n        }\\n        i=0;\\n        while(oneCount > 0){\\n            if(arr[i] == 1 && firstOne == -1)firstOne = i;\\n            oneCount-=arr[i++];\\n        }\\n        while(lastZeroCount > 0){\\n            if(arr[i++] == 1)return new int[]{-1,-1};\\n            lastZeroCount--;\\n        }\\n        int k = i--;\\n        int t = firstOne;\\n        while(arr[k] == 0)k++;\\n        while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        int j = k;\\n        while(arr[k] == 0)k++;\\n        firstOne = t;\\n         while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        return new int[]{i,j};\\n\\n    }\\n}\\n// 1 0 1 1 0 0 1 0 1 1 1 0 1 1\\n//[0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777154,
                "title": "java-o-n-time-o-1-space-beats-100-with-2-ms",
                "content": "Here is the solution. Just coded what was in mind hence is more verbose. though this code can be reduced in length\\n\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int total = 0;\\n        int[] ones = new int[arr.length];\\n        for(int i=arr.length-1; i>=0; i--) {\\n            total += arr[i];\\n            ones[i] = total;\\n        }\\n        \\n        //Total no of 1\\'s should be divisible by 3 to be split into 3 parts. \\n        if(total%3 != 0)\\n            return new int[] {-1, -1};\\n\\n        //Trivial case. \\n        if(total == 0)\\n            return new int[] {0, arr.length-1};\\n        \\n        //Count no of offset zeros from right\\n        int zeros = 0;\\n        for(int i=arr.length-1; i>=0; i--) {\\n            if(arr[i]==1)   break;\\n            zeros++;\\n        }\\n        \\n        //Find Left & right indexes where count of ones from right is mod 3\\n        int count = 0;\\n        int L = -1, R = -1;\\n        for(int i=arr.length-1; i>=0; i--) {\\n            count += arr[i];\\n            if(arr[i]==0)   continue;\\n            if(count==total/3) {\\n                R = i;\\n            } else if(count==2*total/3){\\n                L = i;\\n                break;\\n            }\\n        }\\n        \\n        // Check if is there any 1 at offet zeros between nos.\\n        for(int i=1; i<=zeros; i++) {\\n            if(arr[L-i]==1 || arr[R-i]==1) {\\n                // Zeros are not same.\\n                return new int[]{-1, -1};\\n            }\\n        }\\n        \\n        // Move L & R to their starting points from right. Add extra zeros to left side of part.\\n        while(arr[--R] != 1);\\n        while(arr[--L] != 1);\\n        L += zeros;\\n        R += zeros;\\n        \\n        // check if all 3 parts are exactly same. \\n        // Note: We just need to check till most significant 1 in each part. Since there can be different set of zeros\\n        count = 0;\\n        for(int i=0; i<arr.length; i++) {\\n            count += arr[R-i];\\n            if(arr[arr.length-1-i]!=arr[R-i] || arr[R-i]!=arr[L-i]) {\\n                return new int[]{-1, -1}; \\n            }\\n            if(count == total/3)    break;\\n        }\\n        return new int[]{L, R+1};\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e5968f55-342c-4cc8-ab74-5a98b3860c1c_1667554848.2208898.jpeg)\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int total = 0;\\n        int[] ones = new int[arr.length];\\n        for(int i=arr.length-1; i>=0; i--) {\\n            total += arr[i];\\n            ones[i] = total;\\n        }\\n        \\n        //Total no of 1\\'s should be divisible by 3 to be split into 3 parts. \\n        if(total%3 != 0)\\n            return new int[] {-1, -1};\\n\\n        //Trivial case. \\n        if(total == 0)\\n            return new int[] {0, arr.length-1};\\n        \\n        //Count no of offset zeros from right\\n        int zeros = 0;\\n        for(int i=arr.length-1; i>=0; i--) {\\n            if(arr[i]==1)   break;\\n            zeros++;\\n        }\\n        \\n        //Find Left & right indexes where count of ones from right is mod 3\\n        int count = 0;\\n        int L = -1, R = -1;\\n        for(int i=arr.length-1; i>=0; i--) {\\n            count += arr[i];\\n            if(arr[i]==0)   continue;\\n            if(count==total/3) {\\n                R = i;\\n            } else if(count==2*total/3){\\n                L = i;\\n                break;\\n            }\\n        }\\n        \\n        // Check if is there any 1 at offet zeros between nos.\\n        for(int i=1; i<=zeros; i++) {\\n            if(arr[L-i]==1 || arr[R-i]==1) {\\n                // Zeros are not same.\\n                return new int[]{-1, -1};\\n            }\\n        }\\n        \\n        // Move L & R to their starting points from right. Add extra zeros to left side of part.\\n        while(arr[--R] != 1);\\n        while(arr[--L] != 1);\\n        L += zeros;\\n        R += zeros;\\n        \\n        // check if all 3 parts are exactly same. \\n        // Note: We just need to check till most significant 1 in each part. Since there can be different set of zeros\\n        count = 0;\\n        for(int i=0; i<arr.length; i++) {\\n            count += arr[R-i];\\n            if(arr[arr.length-1-i]!=arr[R-i] || arr[R-i]!=arr[L-i]) {\\n                return new int[]{-1, -1}; \\n            }\\n            if(count == total/3)    break;\\n        }\\n        return new int[]{L, R+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704987,
                "title": "simple-o-n-and-failed-brute-force-c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int oneCount;\\n        int n = arr.size();\\n        vector<int> result(2,-1);\\n        for (auto &i : arr) \\n            oneCount += (i == 1);\\n        \\n        // if total number of 1\\'s are multiple of 3 then it is possible\\n        // to distribute all of them in 3 diffrent sets\\n        if (oneCount%3 != 0) return result;\\n        \\n        if (oneCount == 0) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n            return result;\\n        }\\n        \\n        // figure out first 1\\'s of 1st, 2nd and 3rd set\\n        int i1,i2,i3;\\n        int ones = 0;\\n        int numOnes = oneCount/3;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i]) {\\n                ones++;\\n                if (ones == 1) i1 = i; // start 1 of first set\\n                if (ones == numOnes+1) i2 = i; // start 1 of second set\\n                if (ones == 2*numOnes+1) i3 = i; // start 1 of third set\\n            }\\n        }\\n        \\n        \\n        // Now check for pattern from first 1 of last set, it should match to all of the patter\\n        // for 1st and 2nd set from first 1\\'s, not we always ingore leading 0\\'s of 1st, 2nd and 3rd set\\n        while(i3 < n) {\\n            if ((arr[i3] != arr[i1]) || (arr[i3] != arr[i2])) {\\n                return result;\\n            }\\n            i1++; i2++; i3++;\\n        }\\n        \\n        result[0] = i1-1;\\n        result[1] = i2;\\n        return result;\\n    }\\n\\t\\n    vector<int> threeEqualPartsDetail(vector<int>& arr) {\\n        int oneCount;\\n        int n = arr.size();\\n        vector<int> result(2,-1);\\n        for (auto &i : arr) \\n            oneCount += (i == 1);\\n        if (oneCount%3 != 0) return result;\\n        \\n        if (oneCount == 0) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n            return result;\\n        }\\n        \\n        // figure out first and last 1\\'s of 1st, 2nd and 3rd set\\n        int i1,j1,i2,j2,i3,j3;\\n        int ones = 0;\\n        int numOnes = oneCount/3;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i]) {\\n                ones++;\\n                if (ones == 1) i1 = i; // start 1 of first set\\n                if (ones == numOnes) j1 = i; // end 1 of first set\\n                if (ones == numOnes+1) i2 = i; // start 1 of second set\\n                if (ones == 2*numOnes) j2 = i; // end 1 of second set\\n                if (ones == 2*numOnes+1) i3 = i; // start 1 of third set\\n                if (ones == 3*numOnes) j3 = i; // end 1 of third set\\n            }\\n        }\\n        \\n        // Now check order off 1\\'s and 0\\'s is the same between first and last 1\\'s of each  number\\n        bool notSame = false;\\n        int i = i1; int j = i2; int k = i3;\\n        ones = 0;\\n        // check if sequence of 1\\'s and 0\\'s of each set between first and last 1\\'s is the same\\n        while(ones != numOnes) {\\n            if ((arr[i] != arr[j]) || (arr[i] != arr[k])) {\\n                notSame = true;\\n                break;\\n            }\\n            if (arr[i]) {\\n                ones++;\\n            }\\n            i++; j++; k++;\\n        }\\n        \\n        if (notSame) {\\n            return result;\\n        }\\n        \\n       \\n        // Now check for all trailing zeros of last set, first and second set and similar trailing 0\\'s\\n        // as we can always ignore the trailing 0\\'s of first, secon and third set\\n        i = j1+1; j = j2 + 1; k = j3+1;\\n        while(k < n) {\\n            if ((arr[k] != arr[i]) || (arr[k] != arr[j])) {\\n                notSame = true;\\n                break;\\n            }\\n            k++; i++; j++;\\n        }\\n        if (notSame)\\n            return result;\\n        \\n        result[0] = i-1;\\n        result[1] = j;\\n        return result;\\n    }\\n};\\n\\n\\nclass SolutionTLE {\\npublic:\\n    int helper(vector<int>& arr, string& val, int pos, int patno) {\\n        int n = 0;\\n        int i = pos;\\n        string curValue;\\n        bool oneSeen = false;\\n        int numBits = 0;\\n        for (;i < arr.size(); i++) {\\n            if (!oneSeen && arr[i] == 0) continue;\\n            numBits++;\\n            if (!oneSeen && arr[i] == 1) {\\n                oneSeen = true;\\n                curValue = \"1\";\\n            } else {\\n                curValue += (arr[i] + \\'0\\');\\n            }\\n            if ((curValue == val) || (curValue > val))\\n                break;\\n        }\\n        if ((patno == 2) && (curValue == val)) {\\n            if (numBits > (arr.size()-i))\\n                return -1;\\n            return helper(arr,val,i+1,patno+1);\\n        } else if ((patno == 3) && (curValue == val ) && (i == (arr.size()-1))) {\\n            return pos;\\n        }\\n        return -1;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int patno = 1;\\n        int ret = -1;\\n        vector<int> result(2,-1);\\n        int n = arr.size();\\n        string val;\\n        bool oneSeen = false;\\n        //cout << \" length : \" << n << endl;\\n        int numBits = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (!oneSeen && arr[i] == 0) continue;\\n            numBits++;\\n            if (!oneSeen && arr[i] == 1) {\\n                oneSeen = true;\\n                val = \"1\";\\n            } else {\\n                val += (arr[i] + \\'0\\');\\n            }\\n            \\n            //cout <<  i << \" \" << val << endl;\\n            if (3*numBits > n)\\n                break;\\n            int ret = helper(arr,val,i+1,patno+1);\\n            if (ret != -1) {\\n                result[0] = i;\\n                result[1] = ret;\\n                return result;\\n            }\\n        }\\n        if (!oneSeen) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nclass SolutionINF {\\npublic:\\n    int helper(vector<int>& arr, long long val, int pos, int patno) {\\n        int n = 0;\\n        int i = pos;\\n        long long  curValue = 0;\\n        for (;i < arr.size(); i++) {\\n            curValue = (curValue << 1) | arr[i];\\n            if ((curValue == val) || (curValue > val))\\n                break;\\n        }\\n        //cout << patno << \" \" << curValue << \" curidx : \" << i << endl;\\n        if ((patno == 2) && (curValue == val)) {\\n            long long numBits = curValue ? log2(curValue)+1 : 0;\\n            if (numBits > (arr.size()-i))\\n                return -1;\\n            return helper(arr,val,i+1,patno+1);\\n        } else if ((patno == 3) && (curValue == val ) && (i == (arr.size()-1))) {\\n            return pos;\\n        }\\n        return -1;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int patno = 1;\\n        long long val = 0;\\n        int ret = -1;\\n        vector<int> result(2,-1);\\n        int n = arr.size();\\n        cout << \" length : \" << n << endl;\\n        for (int i = 0; i < arr.size(); i++) {\\n            val = val << 1;\\n            val |= arr[i];\\n            cout <<  i << \" \" << val << endl;\\n            long long numBits = val ? log2(val)+1 : 0;\\n            if (3*numBits > n)\\n                break;\\n            int ret = helper(arr,val,i+1,patno+1);\\n            if (ret != -1) {\\n                result[0] = i;\\n                result[1] = ret;\\n                return result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int oneCount;\\n        int n = arr.size();\\n        vector<int> result(2,-1);\\n        for (auto &i : arr) \\n            oneCount += (i == 1);\\n        \\n        // if total number of 1\\'s are multiple of 3 then it is possible\\n        // to distribute all of them in 3 diffrent sets\\n        if (oneCount%3 != 0) return result;\\n        \\n        if (oneCount == 0) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n            return result;\\n        }\\n        \\n        // figure out first 1\\'s of 1st, 2nd and 3rd set\\n        int i1,i2,i3;\\n        int ones = 0;\\n        int numOnes = oneCount/3;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i]) {\\n                ones++;\\n                if (ones == 1) i1 = i; // start 1 of first set\\n                if (ones == numOnes+1) i2 = i; // start 1 of second set\\n                if (ones == 2*numOnes+1) i3 = i; // start 1 of third set\\n            }\\n        }\\n        \\n        \\n        // Now check for pattern from first 1 of last set, it should match to all of the patter\\n        // for 1st and 2nd set from first 1\\'s, not we always ingore leading 0\\'s of 1st, 2nd and 3rd set\\n        while(i3 < n) {\\n            if ((arr[i3] != arr[i1]) || (arr[i3] != arr[i2])) {\\n                return result;\\n            }\\n            i1++; i2++; i3++;\\n        }\\n        \\n        result[0] = i1-1;\\n        result[1] = i2;\\n        return result;\\n    }\\n\\t\\n    vector<int> threeEqualPartsDetail(vector<int>& arr) {\\n        int oneCount;\\n        int n = arr.size();\\n        vector<int> result(2,-1);\\n        for (auto &i : arr) \\n            oneCount += (i == 1);\\n        if (oneCount%3 != 0) return result;\\n        \\n        if (oneCount == 0) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n            return result;\\n        }\\n        \\n        // figure out first and last 1\\'s of 1st, 2nd and 3rd set\\n        int i1,j1,i2,j2,i3,j3;\\n        int ones = 0;\\n        int numOnes = oneCount/3;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i]) {\\n                ones++;\\n                if (ones == 1) i1 = i; // start 1 of first set\\n                if (ones == numOnes) j1 = i; // end 1 of first set\\n                if (ones == numOnes+1) i2 = i; // start 1 of second set\\n                if (ones == 2*numOnes) j2 = i; // end 1 of second set\\n                if (ones == 2*numOnes+1) i3 = i; // start 1 of third set\\n                if (ones == 3*numOnes) j3 = i; // end 1 of third set\\n            }\\n        }\\n        \\n        // Now check order off 1\\'s and 0\\'s is the same between first and last 1\\'s of each  number\\n        bool notSame = false;\\n        int i = i1; int j = i2; int k = i3;\\n        ones = 0;\\n        // check if sequence of 1\\'s and 0\\'s of each set between first and last 1\\'s is the same\\n        while(ones != numOnes) {\\n            if ((arr[i] != arr[j]) || (arr[i] != arr[k])) {\\n                notSame = true;\\n                break;\\n            }\\n            if (arr[i]) {\\n                ones++;\\n            }\\n            i++; j++; k++;\\n        }\\n        \\n        if (notSame) {\\n            return result;\\n        }\\n        \\n       \\n        // Now check for all trailing zeros of last set, first and second set and similar trailing 0\\'s\\n        // as we can always ignore the trailing 0\\'s of first, secon and third set\\n        i = j1+1; j = j2 + 1; k = j3+1;\\n        while(k < n) {\\n            if ((arr[k] != arr[i]) || (arr[k] != arr[j])) {\\n                notSame = true;\\n                break;\\n            }\\n            k++; i++; j++;\\n        }\\n        if (notSame)\\n            return result;\\n        \\n        result[0] = i-1;\\n        result[1] = j;\\n        return result;\\n    }\\n};\\n\\n\\nclass SolutionTLE {\\npublic:\\n    int helper(vector<int>& arr, string& val, int pos, int patno) {\\n        int n = 0;\\n        int i = pos;\\n        string curValue;\\n        bool oneSeen = false;\\n        int numBits = 0;\\n        for (;i < arr.size(); i++) {\\n            if (!oneSeen && arr[i] == 0) continue;\\n            numBits++;\\n            if (!oneSeen && arr[i] == 1) {\\n                oneSeen = true;\\n                curValue = \"1\";\\n            } else {\\n                curValue += (arr[i] + \\'0\\');\\n            }\\n            if ((curValue == val) || (curValue > val))\\n                break;\\n        }\\n        if ((patno == 2) && (curValue == val)) {\\n            if (numBits > (arr.size()-i))\\n                return -1;\\n            return helper(arr,val,i+1,patno+1);\\n        } else if ((patno == 3) && (curValue == val ) && (i == (arr.size()-1))) {\\n            return pos;\\n        }\\n        return -1;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int patno = 1;\\n        int ret = -1;\\n        vector<int> result(2,-1);\\n        int n = arr.size();\\n        string val;\\n        bool oneSeen = false;\\n        //cout << \" length : \" << n << endl;\\n        int numBits = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (!oneSeen && arr[i] == 0) continue;\\n            numBits++;\\n            if (!oneSeen && arr[i] == 1) {\\n                oneSeen = true;\\n                val = \"1\";\\n            } else {\\n                val += (arr[i] + \\'0\\');\\n            }\\n            \\n            //cout <<  i << \" \" << val << endl;\\n            if (3*numBits > n)\\n                break;\\n            int ret = helper(arr,val,i+1,patno+1);\\n            if (ret != -1) {\\n                result[0] = i;\\n                result[1] = ret;\\n                return result;\\n            }\\n        }\\n        if (!oneSeen) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nclass SolutionINF {\\npublic:\\n    int helper(vector<int>& arr, long long val, int pos, int patno) {\\n        int n = 0;\\n        int i = pos;\\n        long long  curValue = 0;\\n        for (;i < arr.size(); i++) {\\n            curValue = (curValue << 1) | arr[i];\\n            if ((curValue == val) || (curValue > val))\\n                break;\\n        }\\n        //cout << patno << \" \" << curValue << \" curidx : \" << i << endl;\\n        if ((patno == 2) && (curValue == val)) {\\n            long long numBits = curValue ? log2(curValue)+1 : 0;\\n            if (numBits > (arr.size()-i))\\n                return -1;\\n            return helper(arr,val,i+1,patno+1);\\n        } else if ((patno == 3) && (curValue == val ) && (i == (arr.size()-1))) {\\n            return pos;\\n        }\\n        return -1;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int patno = 1;\\n        long long val = 0;\\n        int ret = -1;\\n        vector<int> result(2,-1);\\n        int n = arr.size();\\n        cout << \" length : \" << n << endl;\\n        for (int i = 0; i < arr.size(); i++) {\\n            val = val << 1;\\n            val |= arr[i];\\n            cout <<  i << \" \" << val << endl;\\n            long long numBits = val ? log2(val)+1 : 0;\\n            if (3*numBits > n)\\n                break;\\n            int ret = helper(arr,val,i+1,patno+1);\\n            if (ret != -1) {\\n                result[0] = i;\\n                result[1] = ret;\\n                return result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2667413,
                "title": "c-slow-but-simple-solution",
                "content": "\\n```\\n// 927. Three Equal Parts\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        const int n = arr.size();\\n        int count_one = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) count_one++;\\n        }\\n        if (count_one == 0) return {0, n - 1};\\n        if (count_one % 3 != 0) return {-1, -1};\\n        \\n        int idx_third = 0, count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (arr[i] == 0) continue;\\n            count++;\\n            if (count == count_one / 3) {\\n                idx_third = i;\\n                break;\\n            }\\n        }\\n        int idx1 = helper(arr, 0, idx_third);\\n        if (idx1 < 0) return {-1, -1};\\n        int idx2 = helper(arr, idx1 + 1, idx_third);\\n        if (idx2 < 0) return {-1, -1};\\n        return {idx1, idx2 + 1};\\n    }\\n    int helper(std::vector<int>& arr, int left, int right) {\\n        const int n = arr.size();\\n        while (arr[left] == 0) {\\n            left++;\\n        }\\n        while (right < n) {\\n            if (arr[left] != arr[right]) return -1;\\n            left++; \\n            right++;\\n        }\\n        return left - 1;\\n    }\\n};\\n```\\n```\\n121 / 121 test cases passed. Status: Accepted\\nRuntime: 114 ms, faster than 16.03% of C++ online submissions for Three Equal Parts.\\nMemory Usage: 39 MB, less than 38.93% of C++ online submissions for Three Equal Parts.\\n```\\n\\n\\n```\\n// 927. Three Equal Parts\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        const int n = arr.size();\\n        int count_one = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) count_one++;\\n        }\\n        if (count_one == 0) return {0, n - 1};\\n        if (count_one % 3 != 0) return {-1, -1};\\n\\n        int k = count_one / 3, start = 0, mid = 0, end = 0, count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) continue;\\n            if (count == 0) start = i;\\n            count++;\\n            if (count == k + 1) mid = i;\\n            if (count == 2 * k + 1) {\\n                end = i; \\n                break;\\n            }\\n        }\\n        while (end < n && arr[start] == arr[mid] && arr[mid] == arr[end]) {\\n            start++; \\n            mid++; \\n            end++;\\n        }\\n        if (end == n) return {start - 1, mid};\\n        return {-1, -1};\\n    }\\n};\\n```\\n```\\n121 / 121 test cases passed. Status: Accepted\\nRuntime: 116 ms, faster than 16.03% of C++ online submissions for Three Equal Parts.\\nMemory Usage: 38.8 MB, less than 96.18% of C++ online submissions for Three Equal Parts.\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// 927. Three Equal Parts\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        const int n = arr.size();\\n        int count_one = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) count_one++;\\n        }\\n        if (count_one == 0) return {0, n - 1};\\n        if (count_one % 3 != 0) return {-1, -1};\\n        \\n        int idx_third = 0, count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (arr[i] == 0) continue;\\n            count++;\\n            if (count == count_one / 3) {\\n                idx_third = i;\\n                break;\\n            }\\n        }\\n        int idx1 = helper(arr, 0, idx_third);\\n        if (idx1 < 0) return {-1, -1};\\n        int idx2 = helper(arr, idx1 + 1, idx_third);\\n        if (idx2 < 0) return {-1, -1};\\n        return {idx1, idx2 + 1};\\n    }\\n    int helper(std::vector<int>& arr, int left, int right) {\\n        const int n = arr.size();\\n        while (arr[left] == 0) {\\n            left++;\\n        }\\n        while (right < n) {\\n            if (arr[left] != arr[right]) return -1;\\n            left++; \\n            right++;\\n        }\\n        return left - 1;\\n    }\\n};\\n```\n```\\n121 / 121 test cases passed. Status: Accepted\\nRuntime: 114 ms, faster than 16.03% of C++ online submissions for Three Equal Parts.\\nMemory Usage: 39 MB, less than 38.93% of C++ online submissions for Three Equal Parts.\\n```\n```\\n// 927. Three Equal Parts\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        const int n = arr.size();\\n        int count_one = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) count_one++;\\n        }\\n        if (count_one == 0) return {0, n - 1};\\n        if (count_one % 3 != 0) return {-1, -1};\\n\\n        int k = count_one / 3, start = 0, mid = 0, end = 0, count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) continue;\\n            if (count == 0) start = i;\\n            count++;\\n            if (count == k + 1) mid = i;\\n            if (count == 2 * k + 1) {\\n                end = i; \\n                break;\\n            }\\n        }\\n        while (end < n && arr[start] == arr[mid] && arr[mid] == arr[end]) {\\n            start++; \\n            mid++; \\n            end++;\\n        }\\n        if (end == n) return {start - 1, mid};\\n        return {-1, -1};\\n    }\\n};\\n```\n```\\n121 / 121 test cases passed. Status: Accepted\\nRuntime: 116 ms, faster than 16.03% of C++ online submissions for Three Equal Parts.\\nMemory Usage: 38.8 MB, less than 96.18% of C++ online submissions for Three Equal Parts.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666855,
                "title": "java-solution-with-explanations",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        // first we need to ensure each part has the same number of 1s.\\n        int count = 0;\\n        for (int i : arr) {\\n            count += i;\\n        }\\n        \\n        // if no 1s, return any division.\\n        if (count == 0) {\\n            return new int[]{0, 2};\\n        }\\n        \\n        // if the 1s can not be divide into three parts, no result.\\n        if (count % 3 != 0) {\\n            return new int[]{-1, -1};\\n        }\\n\\n        // then we count the trailing zeros, since last part should always has a fixed number of trailing zeros.\\n        int t = count / 3;\\n        int z = 0;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (arr[i] == 0) {\\n                z++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        // find the first part, count the 1s to fit our target number and append the trailing zeros.\\n        int p = 0;\\n        int r = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                r = i + z;\\n                break;\\n            }\\n        }\\n\\n        // find the second part with the same method.\\n        // r + 1 ~ arr.length - 1\\n        p = 0;\\n        int r2 = 0;\\n        for (int i = r + 1; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                r2 = i + z;\\n                break;\\n            }\\n        }\\n        \\n        // find the third part.\\n        // r2 + 1 ~ arr.length - 1\\n        p = 0;\\n        for (int i = r2 + 1; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                // in this case, we found three parts with the same number of 1s and trailing zeros.\\n                // but this does not mean that they are equal, we must check the equality.\\n                if (eq(arr, r, r2)) {\\n                    return new int[]{r, r2 + 1};\\n                }\\n                break;\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n\\n    boolean eq(int[] arr, int r, int r2) {\\n        int i = r;\\n        int j = r2;\\n        int k = arr.length - 1;\\n        while (i >= 0 || j >= 0 || k >= 0) {\\n            int a = i < 0 ? 0 : arr[i];\\n            int b = j < 0 || j <= r ? 0 : arr[j];\\n            int c = k < 0 || k <= r2 ? 0 : arr[k];\\n            if (a != b || a != c) {\\n                return false;\\n            }\\n            i--;\\n            k--;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        // first we need to ensure each part has the same number of 1s.\\n        int count = 0;\\n        for (int i : arr) {\\n            count += i;\\n        }\\n        \\n        // if no 1s, return any division.\\n        if (count == 0) {\\n            return new int[]{0, 2};\\n        }\\n        \\n        // if the 1s can not be divide into three parts, no result.\\n        if (count % 3 != 0) {\\n            return new int[]{-1, -1};\\n        }\\n\\n        // then we count the trailing zeros, since last part should always has a fixed number of trailing zeros.\\n        int t = count / 3;\\n        int z = 0;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (arr[i] == 0) {\\n                z++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        // find the first part, count the 1s to fit our target number and append the trailing zeros.\\n        int p = 0;\\n        int r = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                r = i + z;\\n                break;\\n            }\\n        }\\n\\n        // find the second part with the same method.\\n        // r + 1 ~ arr.length - 1\\n        p = 0;\\n        int r2 = 0;\\n        for (int i = r + 1; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                r2 = i + z;\\n                break;\\n            }\\n        }\\n        \\n        // find the third part.\\n        // r2 + 1 ~ arr.length - 1\\n        p = 0;\\n        for (int i = r2 + 1; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                // in this case, we found three parts with the same number of 1s and trailing zeros.\\n                // but this does not mean that they are equal, we must check the equality.\\n                if (eq(arr, r, r2)) {\\n                    return new int[]{r, r2 + 1};\\n                }\\n                break;\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n\\n    boolean eq(int[] arr, int r, int r2) {\\n        int i = r;\\n        int j = r2;\\n        int k = arr.length - 1;\\n        while (i >= 0 || j >= 0 || k >= 0) {\\n            int a = i < 0 ? 0 : arr[i];\\n            int b = j < 0 || j <= r ? 0 : arr[j];\\n            int c = k < 0 || k <= r2 ? 0 : arr[k];\\n            if (a != b || a != c) {\\n                return false;\\n            }\\n            i--;\\n            k--;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659736,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        \\n        vector<int> ones;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                ones.push_back(i);\\n            }\\n        }\\n        \\n        int sz = ones.size();\\n        \\n        if(sz == 0)\\n        {\\n            return {0,n-1};\\n        }\\n        \\n        if(sz%3 != 0)\\n        {\\n            return {-1,-1};\\n        }\\n        \\n        int a = ones[0], b = ones[sz/3], c = ones[(sz/3)*2];\\n        \\n        while(c < n && arr[a] == arr[b] && arr[b] == arr[c])\\n        {\\n            a++;\\n            b++;\\n            c++;\\n        }\\n        \\n        if(c == n)\\n        {\\n            return {a-1,b};\\n        }\\n        \\n        return {-1,-1};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        \\n        vector<int> ones;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                ones.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2603678,
                "title": "c-easy-to-unsderstand-step-by-step",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n                c++;\\n        }\\n        if(c%3!=0)return v;\\n        if(c==0)return {0,2}; //can make split from anywhere. this is in case we have 3 size of given array\\n        \\n        int idx=-1;\\n        int cnt=0;\\n        // start counting c/3 1s from back,so that we can make 3 equal parts\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]==1)\\n                cnt++;\\n            if(cnt==c/3)\\n            {  idx=i;\\n             break;}\\n            \\n        }\\n        int front=0;  // ignoring leading 0s\\n        while(arr[front]==0)\\n            front++;\\n        \\n        int strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n        if(strt!=n)return v;\\n        int frststrt=front-1;\\n        while(arr[front]==0)front++;\\n        strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n         if(strt!=n)return v;\\n        return {frststrt,front};\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2584689,
                "title": "c-easy-implementation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n                c++;\\n        }\\n        if(c%3!=0)return v;\\n        if(c==0)return {0,2}; //can make split from anywhere. this is in case we have 3 size of given array\\n        \\n        int idx=-1;\\n        int cnt=0;\\n        // start counting c/3 1s from back,so that we can make 3 equal parts\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]==1)\\n                cnt++;\\n            if(cnt==c/3)\\n            {  idx=i;\\n             break;}\\n            \\n        }\\n        int front=0;  // ignoring leading 0s\\n        while(arr[front]==0)\\n            front++;\\n        \\n        int strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n        if(strt!=n)return v;\\n        int frststrt=front-1;\\n        while(arr[front]==0)front++;\\n        strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n         if(strt!=n)return v;\\n        return {frststrt,front};\\n        \\n    }\\n};\\n\\nPLEASE UPVOTE GUYS!!!!",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2353001,
                "title": "python-solution-leading-and-trailing-zeros",
                "content": "There are a few keys to get three equal parts:\\n1. Number of ones must be the same for all parts, although in binary numbers, the order of 0 and 1s also matter.\\n2. Leading zeros are allowed but to be ignored.\\n3. Trailing zeros are very important. The only way to find out how many there are is to check out the zeros between the last 1 and the end of the array.\\n```\\nclass Solution:\\n    # We can neglect the leading zeros.\\n    # But one important point is that the number of 1s must be the same for all 3 partitions\\n    # So what we can do is once we make sure the number of 1s is divisible by 3, We find where the 3 partitions should start.\\n    # Skip the leading zeros\\n    # Then we match numbers element by element until end\\n    # It is possible that there are extra 0s at the end of the numbers. To accomodate that, we record number of 0s between the end of arr and the last 1\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = sum(arr)\\n        if ones == 0:\\n            return [0, 2]\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        \\n        result, count, last_one = [], 0, 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                count += 1\\n                last_one = i\\n                if count == ones // 3:\\n                    result.append(i)\\n                elif count == 2 * ones // 3:\\n                    result.append(i+1)\\n        for i in range(2):\\n            result[i] += len(arr) - 1 - last_one\\n            \\n        p1, p2, p3 = 0, result[0] + 1, result[1]\\n        # Remove leading 0s\\n        while p1 < result[0] + 1 and arr[p1] == 0:\\n            p1 += 1\\n        while p2 < result[1] and arr[p2] == 0:\\n            p2 += 1\\n        while p3 < len(arr) and arr[p3] == 0:\\n            p3 += 1\\n        if p1 >= result[0] + 1 or p2 >= result[1] or p3 >= len(arr):\\n            return [-1, -1]\\n        \\n        # matching\\n        while p1 < result[0] + 1 and p2 < result[1] and p3 < len(arr):\\n            if arr[p1] == arr[p2] and arr[p2] == arr[p3]:\\n                p1 += 1\\n                p2 += 1\\n                p3 += 1\\n            else:\\n                return [-1, -1]\\n        \\n        if p1 == result[0] + 1 and p2 == result[1] and p3 == len(arr):\\n            return result\\n        else:\\n            return [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # We can neglect the leading zeros.\\n    # But one important point is that the number of 1s must be the same for all 3 partitions\\n    # So what we can do is once we make sure the number of 1s is divisible by 3, We find where the 3 partitions should start.\\n    # Skip the leading zeros\\n    # Then we match numbers element by element until end\\n    # It is possible that there are extra 0s at the end of the numbers. To accomodate that, we record number of 0s between the end of arr and the last 1\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = sum(arr)\\n        if ones == 0:\\n            return [0, 2]\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        \\n        result, count, last_one = [], 0, 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                count += 1\\n                last_one = i\\n                if count == ones // 3:\\n                    result.append(i)\\n                elif count == 2 * ones // 3:\\n                    result.append(i+1)\\n        for i in range(2):\\n            result[i] += len(arr) - 1 - last_one\\n            \\n        p1, p2, p3 = 0, result[0] + 1, result[1]\\n        # Remove leading 0s\\n        while p1 < result[0] + 1 and arr[p1] == 0:\\n            p1 += 1\\n        while p2 < result[1] and arr[p2] == 0:\\n            p2 += 1\\n        while p3 < len(arr) and arr[p3] == 0:\\n            p3 += 1\\n        if p1 >= result[0] + 1 or p2 >= result[1] or p3 >= len(arr):\\n            return [-1, -1]\\n        \\n        # matching\\n        while p1 < result[0] + 1 and p2 < result[1] and p3 < len(arr):\\n            if arr[p1] == arr[p2] and arr[p2] == arr[p3]:\\n                p1 += 1\\n                p2 += 1\\n                p3 += 1\\n            else:\\n                return [-1, -1]\\n        \\n        if p1 == result[0] + 1 and p2 == result[1] and p3 == len(arr):\\n            return result\\n        else:\\n            return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266937,
                "title": "three-equal-parts-c-soln",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    \\n    int fun(int i,vector<int>&v,int ones, int last_zeros){\\n        int n=v.size();\\n        \\n        while(ones!=0 || last_zeros!=0){\\n            if(ones!=0){\\n                if(v[i])\\n                    ones--;\\n            }\\n            else{\\n                if(!v[i])\\n                    last_zeros--;\\n                else break;\\n            }\\n            i++;\\n        }\\n        int to_ret;\\n        if(last_zeros){\\n            to_ret=-1;\\n        }\\n        else{\\n            to_ret=i-1;\\n        }\\n        return to_ret;\\n    }\\n    \\n    void fun2(string &s,int start,int till,vector<int>&v){\\n        int i;\\n        \\n        for(i=start;i<=till;i++){\\n            if(v[i])break;\\n        }\\n        for(i;i<=till;i++){\\n            s+=(char)(v[i]+\\'0\\');\\n        }\\n    }\\n    \\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size();\\n        int cnt=0;\\n        \\n        for(auto x:arr)\\n            if(x)\\n                cnt++;\\n        \\n        vector<int>ans(2);\\n        \\n        if(cnt%3){\\n            ans[0]=-1;\\n            ans[1]=-1;\\n        }\\n        else if(cnt==0){\\n            ans[0]=0;\\n            ans[1]=2;\\n        }\\n        else{\\n            int last_zeros=0;\\n            for(int i=n-1;i>=0;i--){\\n                if(arr[i])\\n                    break;\\n                else \\n                    last_zeros++;\\n            }\\n            \\n            vector<string>vs(3);\\n            \\n            int prev=0,till;\\n            \\n            for(int i=0;i<3;i++){\\n                till=fun(prev,arr,cnt/3,last_zeros);\\n                if(till==-1){\\n                    ans[0]=-1;\\n                    ans[1]=-1;\\n                    break;\\n                }\\n                else{\\n                    fun2(vs[i],prev,till,arr);\\n                    if(i!=2){\\n                        ans[i]=till;\\n                    }\\n                    prev=till+1;\\n                }\\n            }\\n            if(vs[0]==vs[1] && vs[1]==vs[2] && !vs[0].empty()){\\n                ans[1]++;\\n            }\\n            else{\\n                ans[0]=-1;\\n                ans[1]=-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int fun(int i,vector<int>&v,int ones, int last_zeros){\\n        int n=v.size();\\n        \\n        while(ones!=0 || last_zeros!=0){\\n            if(ones!=0){\\n                if(v[i])\\n                    ones--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2167526,
                "title": "java-of-1-mod-3-0-partition-concise-solution",
                "content": "**Steps**\\n\\n- Store all the 1\\'s indexes into a list.\\n\\n- If ones list size is not a multiple of 3, it can\\'t be done.\\n\\n- Leading zeros do not increase the number. \\n\\n- The first partition starts at ones.get(0), second: ones.get(ones.size()/3), thrid: ones.get(ones.size()*2/3)\\n- The third partition is the target number we are aimming for because no matter how we cut it, it won\\'t affect the third number.\\n- Therefore, we will compare the gap between 1s in partition 1 and 2 against that of 3.\\n- We find the cut point with the tail of each partition + partition 3 tail offset to the end of array (last array index - last one index)\\n- We have to check that this cut point does not breach into another partition.\\n\\n```Java\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        List<Integer> ones = new ArrayList<>();\\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i]==1){\\n                ones.add(i);\\n            }\\n        }\\n        if (ones.size()==0){ // edge case\\n            return new int[]{0,2};\\n        }\\n        int[] ans = new int[2];\\n        int each = ones.size()/3;\\n        for (int i = 0; i < 2 && ones.size()%3==0; i++){ // for the first 2 partitions\\n            for (int j = 0; j < each-1; j++){ // compare gaps\\n                if (ones.get(j+1+i*each)-ones.get(j+i*each)!=ones.get(j+2*each+1)-ones.get(j+2*each))\\n                    return new int[]{-1, -1};\\n            }\\n            ans[i]=ones.get((i+1)*each-1)+i+(arr.length - 1 - ones.get(ones.size()-1)); // cut point\\n        }\\n        return ones.size()%3>0||ans[0]>=ones.get(each)||ans[1]>ones.get(2*each)?\\n            new int[]{-1, -1} : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        List<Integer> ones = new ArrayList<>();\\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i]==1){\\n                ones.add(i);\\n            }\\n        }\\n        if (ones.size()==0){ // edge case\\n            return new int[]{0,2};\\n        }\\n        int[] ans = new int[2];\\n        int each = ones.size()/3;\\n        for (int i = 0; i < 2 && ones.size()%3==0; i++){ // for the first 2 partitions\\n            for (int j = 0; j < each-1; j++){ // compare gaps\\n                if (ones.get(j+1+i*each)-ones.get(j+i*each)!=ones.get(j+2*each+1)-ones.get(j+2*each))\\n                    return new int[]{-1, -1};\\n            }\\n            ans[i]=ones.get((i+1)*each-1)+i+(arr.length - 1 - ones.get(ones.size()-1)); // cut point\\n        }\\n        return ones.size()%3>0||ans[0]>=ones.get(each)||ans[1]>ones.get(2*each)?\\n            new int[]{-1, -1} : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155025,
                "title": "detailed-explanation-equal-ones-in-all-three-parts",
                "content": "Firstly, we just need to count the number of ones. If divisible by 3 then the split of array with equal binary values is possible or else not. \\nIf the array doesnt contains any ones, then also its valid, with all three parts being just one zero (one of the edge cases) \\n\\nThen we need to split the array in such a way that first, second and third part contains equal ones, we can store the ones indices in a map and get them\\n\\nFor example, consider this example\\na = [1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0]\\n\\nx1 = 2 (index where the first part of one ends) and x2 = 4 (index upto which the first part can extend without taking the ones from second part)\\ny1 = 7 (index where the second part of ones ends)  and   y2 = 10 (index upto which the second part can extend without taking the ones from third part)\\n\\nhere, we are interested in two sliding window that can increase the first part and second part appropriately at the same time. Each time we also check for leading zeros and ignore them if present.\\n\\nDry run will produce results as follows\\n\\n\\t[1,0,1]        [0,0,1,0,1]        [0,0,0,1,0,1,0,0]\\n\\t[1,0,1,0]      [0,1,0,1,0]        [0,0,1,0,1,0,0]\\n\\t[1,0,1,0,0]    [0,1,0,1,0,0]      [0,1,0,1,0,0]\\n\\nsince we found a match, we return it\\n\\n\\nCode : \\n```\\nclass Solution {\\n    \\n    int[] a;\\n    public int[] threeEqualParts(int[] arr) {\\n        \\n        a = arr;\\n        \\n        int count = 0;\\n        Map<Integer, Integer> maps = new HashMap<>();\\n        \\n        //counting the ones and storing the ones indices in a map\\n        for(int i = 0; i < a.length; i++){\\n            if(a[i] == 1) \\n                maps.put(++count, i);\\n        }\\n        \\n        //if the count is zero, all parts are just ones, so return it\\n        if(count == 0) return new int[]{0, a.length - 1};\\n        \\n        //if the count is not divisibe by three, no way of splitting it\\n        if(count%3 != 0) return new int[]{-1, -1};\\n        \\n        //lets get the sliding window indices from the map appropriately\\n        int x1 = maps.get(count/3), x2 = maps.get((count/3) + 1) - 1, y1 = maps.get(2*(count/3)), y2 = maps.get((2*(count/3)) + 1) - 1;\\n        \\n        //incrementing the window of first and second part at the same time and checking \\n        //for match\\n        while(x1 <= x2 && y1 <= y2) {\\n            if(check(0, x1, x1+1, y1, y1+1, a.length - 1)) \\n                return new int[]{x1, y1 + 1};\\n            x1++; y1++;\\n        }\\n            \\n        \\n        //no match found finally\\n        return new int[]{-1, -1};\\n    }\\n    \\n    \\n    private boolean check(int a1, int a2, int b1, int b2, int c1, int c2) {\\n         \\n        //removing leading zeros if present from all the three parts, just \\n        //incrementing the indices in those three parts\\n        a1 = removeLeadingZeros(a1, a2);\\n        b1 = removeLeadingZeros(b1, b2);\\n        c1 = removeLeadingZeros(c1, c2);\\n        \\n       //if the parts length are different, no way of being same \\n       if(((a2 - a1) != (b2 - b1)) || ((a2 - a1) != (c2 - c1))) return false;\\n        \\n       //checking all the parts for same 0\\'s or 1\\'s\\n       while(a1 <= a2 && b1 <= b2 && c1 <= c2) {\\n            if((a[a1] != a[b1]) || (a[a1] != a[c1])) return false;\\n            a1++; b1++; c1++;\\n        }\\n        \\n       return true;\\n    }\\n    \\n    //removing the leading zeros \\n    private int removeLeadingZeros(int idx, int idx2) {\\n         while(idx <= idx2) if(a[idx++] == 1) break;\\n         return idx - 1;\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] a;\\n    public int[] threeEqualParts(int[] arr) {\\n        \\n        a = arr;\\n        \\n        int count = 0;\\n        Map<Integer, Integer> maps = new HashMap<>();\\n        \\n        //counting the ones and storing the ones indices in a map\\n        for(int i = 0; i < a.length; i++){\\n            if(a[i] == 1) \\n                maps.put(++count, i);\\n        }\\n        \\n        //if the count is zero, all parts are just ones, so return it\\n        if(count == 0) return new int[]{0, a.length - 1};\\n        \\n        //if the count is not divisibe by three, no way of splitting it\\n        if(count%3 != 0) return new int[]{-1, -1};\\n        \\n        //lets get the sliding window indices from the map appropriately\\n        int x1 = maps.get(count/3), x2 = maps.get((count/3) + 1) - 1, y1 = maps.get(2*(count/3)), y2 = maps.get((2*(count/3)) + 1) - 1;\\n        \\n        //incrementing the window of first and second part at the same time and checking \\n        //for match\\n        while(x1 <= x2 && y1 <= y2) {\\n            if(check(0, x1, x1+1, y1, y1+1, a.length - 1)) \\n                return new int[]{x1, y1 + 1};\\n            x1++; y1++;\\n        }\\n            \\n        \\n        //no match found finally\\n        return new int[]{-1, -1};\\n    }\\n    \\n    \\n    private boolean check(int a1, int a2, int b1, int b2, int c1, int c2) {\\n         \\n        //removing leading zeros if present from all the three parts, just \\n        //incrementing the indices in those three parts\\n        a1 = removeLeadingZeros(a1, a2);\\n        b1 = removeLeadingZeros(b1, b2);\\n        c1 = removeLeadingZeros(c1, c2);\\n        \\n       //if the parts length are different, no way of being same \\n       if(((a2 - a1) != (b2 - b1)) || ((a2 - a1) != (c2 - c1))) return false;\\n        \\n       //checking all the parts for same 0\\'s or 1\\'s\\n       while(a1 <= a2 && b1 <= b2 && c1 <= c2) {\\n            if((a[a1] != a[b1]) || (a[a1] != a[c1])) return false;\\n            a1++; b1++; c1++;\\n        }\\n        \\n       return true;\\n    }\\n    \\n    //removing the leading zeros \\n    private int removeLeadingZeros(int idx, int idx2) {\\n         while(idx <= idx2) if(a[idx++] == 1) break;\\n         return idx - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069601,
                "title": "c-o-n-time-o-n-space-hashing-solution",
                "content": "``` \\n#define ll long long\\nclass Solution {\\n    int n;\\n    vector<ll> pow1, pow2, hash1, hash2;\\n    const int MOD = 1e9 + 7;\\n    ll modpow(ll n, ll p) {\\n        if (p == 0) return 1;\\n        ll x = modpow(n, p / 2);\\n        x = (x * x) % MOD;\\n        if (p % 2)  x = (x * n) % MOD;\\n        return x;\\n    }\\n    void set(vector<int>& arr) {\\n        pow1[n - 1] = 1, pow2[n - 1] = 1, hash1[n - 1] = arr[n - 1], hash2[n - 1] = arr[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            pow1[i] = (pow1[i + 1] * 2) % MOD;\\n            pow2[i] = (pow2[i + 1] * 3) % MOD;\\n            hash1[i] = arr[i] * pow1[i] + hash1[i + 1];\\n            hash2[i] = arr[i] * pow2[i] + hash2[i + 1];\\n            hash1[i] %= MOD;\\n            hash2[i] %= MOD;\\n        }       \\n    }\\n    ll hashv1(int i, int j) { // \\n        ll temp = hash1[i];\\n        if (j + 1 < n)\\n            temp = (temp - hash1[j + 1] + MOD) % MOD;\\n        ll temp2 = modpow(2, n - 1 - j);\\n        temp = (temp * modpow(temp2, MOD - 2)) % MOD;\\n        return temp;\\n    }\\n    ll hashv2(int i, int j) {\\n        ll temp = hash2[i];\\n        if (j + 1 < n)\\n            temp = (temp - hash2[j + 1] + MOD) % MOD;\\n        ll temp2 = modpow(3, n - 1 - j);\\n        temp = (temp * modpow(temp2, MOD - 2)) % MOD;\\n        return temp;        \\n    }\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        reverse(arr.begin(), arr.end());\\n        int rem = 0;\\n        while (arr.size() && arr.back() == 0)\\n            arr.pop_back(), rem++;\\n        if (arr.size() == 0) \\n            return {0, rem - 1};\\n        reverse(arr.begin(), arr.end());\\n        n = arr.size();\\n        pow1.resize(n); pow2.resize(n); hash1.resize(n); hash2.resize(n);\\n        pow1[0] = 1, pow2[0] = 1;\\n        set(arr);\\n        unordered_map<int, vector<int>> pref;\\n        for (int i = 0; i < n; i++) \\n            pref[hashv1(0, i)].push_back(i);\\n        vector<int> ans = {-1, -1};\\n        for (int x = n - 1; x >= 0; x--) {\\n            for (auto i: pref[hash1[x]]) {\\n                if (i + 1 >= x) \\n                    break;\\n                ll lefth1 = hash1[x];\\n                ll righth1 = hash1[x];\\n                ll midh1 = hashv1(i + 1, x - 1);\\n                ll lefth2 = hashv2(0, i);\\n                ll righth2 = hash2[x];\\n                ll midh2 = hashv2(i + 1, x - 1);\\n                if (lefth1 == midh1 && lefth2 == righth2 && lefth2 == midh2) {\\n                    ans = {i + rem, x + rem};\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nInitially, the preceding zeroes in ```arr``` are removed. Let the number of removed zeroes be ```rem```. (The case when the entire array is removed is handled separately.)\\n\\nLet ```n``` be the size of the remaining array.\\n```\\nhash1[n - 1] = arr[n - 1] * (2 ^ 0)\\nhash1[n - 2] = arr[n - 2] * (2 ^ 1) + hash1[n - 1]\\nhash1[n - 3] = arr[n - 3] * (2 ^ 2) + hash1[n - 2]\\n```\\n\\nSimilarly,\\n```\\nhash2[n - 1] = arr[n - 1] * (3 ^ 0)\\nhash2[n - 2] = arr[n - 2] * (3 ^ 1) + hash2[n - 1]\\nhash2[n - 3] = arr[n - 3] * (3 ^ 2) + hash2[n - 2]\\n```\\n\\n``` hashv1(int i, int j) ``` returns the hash of the subarrary ```[i..j]``` with base ```2```.\\n``` hashv2(int i, int j) ``` returns the hash of the subarrary ```[i..j]``` with base ```3```.\\n\\nif  ```hashv1(0, i) = x, pref[x]``` contains ```i```, i.e, ```pref[x]``` contains all the prefixes which has hash value ```x```.\\n\\nIf the answer exists, the array can be broken down into three parts, i.e ```[0, i] [i + 1, x - 1] [x, n - 1]```.\\n\\nWe iterate over the suffices, i.e ```[x, n - 1]```, let us say, the ```hash1[x] = righth1```, now for every ```x```, we iterate over the prefixes which has hash with base ```2``` as ```h```. Now using ```hashv1(int i, int j)```, we find the hash value of the subarray ```[i + 1, x - 1]```, let us say, this value is ```midh1```.\\n\\nIf ```lefth1 == midh1 == righth1```. The pair ```{i + rem, x + rem}```(because we have removed few zeroes in the beginning, we have to add rem to compensate) is possibly a solution. But we may get false positives, due to hash collisions. Hence, we use another hash with ```base 3``` and repeat the above process to validate the pair.\\n",
                "solutionTags": [],
                "code": "``` \\n#define ll long long\\nclass Solution {\\n    int n;\\n    vector<ll> pow1, pow2, hash1, hash2;\\n    const int MOD = 1e9 + 7;\\n    ll modpow(ll n, ll p) {\\n        if (p == 0) return 1;\\n        ll x = modpow(n, p / 2);\\n        x = (x * x) % MOD;\\n        if (p % 2)  x = (x * n) % MOD;\\n        return x;\\n    }\\n    void set(vector<int>& arr) {\\n        pow1[n - 1] = 1, pow2[n - 1] = 1, hash1[n - 1] = arr[n - 1], hash2[n - 1] = arr[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            pow1[i] = (pow1[i + 1] * 2) % MOD;\\n            pow2[i] = (pow2[i + 1] * 3) % MOD;\\n            hash1[i] = arr[i] * pow1[i] + hash1[i + 1];\\n            hash2[i] = arr[i] * pow2[i] + hash2[i + 1];\\n            hash1[i] %= MOD;\\n            hash2[i] %= MOD;\\n        }       \\n    }\\n    ll hashv1(int i, int j) { // \\n        ll temp = hash1[i];\\n        if (j + 1 < n)\\n            temp = (temp - hash1[j + 1] + MOD) % MOD;\\n        ll temp2 = modpow(2, n - 1 - j);\\n        temp = (temp * modpow(temp2, MOD - 2)) % MOD;\\n        return temp;\\n    }\\n    ll hashv2(int i, int j) {\\n        ll temp = hash2[i];\\n        if (j + 1 < n)\\n            temp = (temp - hash2[j + 1] + MOD) % MOD;\\n        ll temp2 = modpow(3, n - 1 - j);\\n        temp = (temp * modpow(temp2, MOD - 2)) % MOD;\\n        return temp;        \\n    }\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        reverse(arr.begin(), arr.end());\\n        int rem = 0;\\n        while (arr.size() && arr.back() == 0)\\n            arr.pop_back(), rem++;\\n        if (arr.size() == 0) \\n            return {0, rem - 1};\\n        reverse(arr.begin(), arr.end());\\n        n = arr.size();\\n        pow1.resize(n); pow2.resize(n); hash1.resize(n); hash2.resize(n);\\n        pow1[0] = 1, pow2[0] = 1;\\n        set(arr);\\n        unordered_map<int, vector<int>> pref;\\n        for (int i = 0; i < n; i++) \\n            pref[hashv1(0, i)].push_back(i);\\n        vector<int> ans = {-1, -1};\\n        for (int x = n - 1; x >= 0; x--) {\\n            for (auto i: pref[hash1[x]]) {\\n                if (i + 1 >= x) \\n                    break;\\n                ll lefth1 = hash1[x];\\n                ll righth1 = hash1[x];\\n                ll midh1 = hashv1(i + 1, x - 1);\\n                ll lefth2 = hashv2(0, i);\\n                ll righth2 = hash2[x];\\n                ll midh2 = hashv2(i + 1, x - 1);\\n                if (lefth1 == midh1 && lefth2 == righth2 && lefth2 == midh2) {\\n                    ans = {i + rem, x + rem};\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```arr```\n```rem```\n```n```\n```\\nhash1[n - 1] = arr[n - 1] * (2 ^ 0)\\nhash1[n - 2] = arr[n - 2] * (2 ^ 1) + hash1[n - 1]\\nhash1[n - 3] = arr[n - 3] * (2 ^ 2) + hash1[n - 2]\\n```\n```\\nhash2[n - 1] = arr[n - 1] * (3 ^ 0)\\nhash2[n - 2] = arr[n - 2] * (3 ^ 1) + hash2[n - 1]\\nhash2[n - 3] = arr[n - 3] * (3 ^ 2) + hash2[n - 2]\\n```\n``` hashv1(int i, int j) ```\n```[i..j]```\n```2```\n``` hashv2(int i, int j) ```\n```[i..j]```\n```3```\n```hashv1(0, i) = x, pref[x]```\n```i```\n```pref[x]```\n```x```\n```[0, i] [i + 1, x - 1] [x, n - 1]```\n```[x, n - 1]```\n```hash1[x] = righth1```\n```x```\n```2```\n```h```\n```hashv1(int i, int j)```\n```[i + 1, x - 1]```\n```midh1```\n```lefth1 == midh1 == righth1```\n```{i + rem, x + rem}```\n```base 3```",
                "codeTag": "Java"
            },
            {
                "id": 2018713,
                "title": "java-constant-space",
                "content": "```\\n\\t\\tint n = arr.length;\\n        \\n        int oneCount = 0;\\n        for(int i : arr)\\n            if(i == 1)\\n                oneCount++;\\n        \\n// Base exit condition if the one\\'s in array are even then partion is not possible\\n        if(oneCount % 3 != 0)\\n            return new int[]{-1, -1};\\n        if(oneCount == 0)\\n            return new int[]{0, n - 1};\\n\\n// Initializing the values of i123, j123 with help of \"k\"\\n        int k = oneCount / 3;\\n        int i1 = -1, i2 = -1, i3 = -1, j1 = -1, j2 = -1, j3 = -1;\\n        int currCount = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(arr[i] == 1){\\n                currCount += 1;\\n                if(currCount == 1) i1 = i;\\n                if(currCount == (k+1)) i2 = i;\\n                if(currCount == (2*k+1)) i3 = i;\\n                \\n                if(currCount == k) j1 = i;\\n                if(currCount == (2*k)) j2 = i;\\n                if(currCount == (3*k)) j3 = i;\\n            }\\n        }\\n        \\n        int start = i1, mid = i2,end = i3;\\n        while(k-- > 0 && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n\\n        if(k >= 0) return new int[]{-1,-1};\\n        \\n// Take care of trailing zeros\\n        \\n        int first = i2-j1-1;\\n        int second = i3-j2-1;\\n        int third = n-j3-1;\\n        \\n        if(third > Math.min(first, second))\\n            return new int[] {-1, -1};\\n        \\n        return new int[] {j1 + third, j2 + third + 1};\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint n = arr.length;\\n        \\n        int oneCount = 0;\\n        for(int i : arr)\\n            if(i == 1)\\n                oneCount++;\\n        \\n// Base exit condition if the one\\'s in array are even then partion is not possible\\n        if(oneCount % 3 != 0)\\n            return new int[]{-1, -1};\\n        if(oneCount == 0)\\n            return new int[]{0, n - 1};\\n\\n// Initializing the values of i123, j123 with help of \"k\"\\n        int k = oneCount / 3;\\n        int i1 = -1, i2 = -1, i3 = -1, j1 = -1, j2 = -1, j3 = -1;\\n        int currCount = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(arr[i] == 1){\\n                currCount += 1;\\n                if(currCount == 1) i1 = i;\\n                if(currCount == (k+1)) i2 = i;\\n                if(currCount == (2*k+1)) i3 = i;\\n                \\n                if(currCount == k) j1 = i;\\n                if(currCount == (2*k)) j2 = i;\\n                if(currCount == (3*k)) j3 = i;\\n            }\\n        }\\n        \\n        int start = i1, mid = i2,end = i3;\\n        while(k-- > 0 && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n\\n        if(k >= 0) return new int[]{-1,-1};\\n        \\n// Take care of trailing zeros\\n        \\n        int first = i2-j1-1;\\n        int second = i3-j2-1;\\n        int third = n-j3-1;\\n        \\n        if(third > Math.min(first, second))\\n            return new int[] {-1, -1};\\n        \\n        return new int[] {j1 + third, j2 + third + 1};\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977666,
                "title": "python-o-nlogn-prefix-and-binary-search",
                "content": "```\\nfrom bisect import bisect\\nfrom collections import Counter\\n\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        if 1 not in arr: return [0,2]\\n        if Counter(arr)[1] < 3: return [-1, -1]\\n        n = len(arr)\\n        prefix = [0] * (n + 1)\\n        pow2 = [1] * (n + 1)\\n        for i in range(1, n + 1): pow2[i] = pow2[i - 1] * 2\\n        for i in range(n): prefix[i + 1] = prefix[i] * 2 + arr[i]\\n        cur = 0\\n        for j in range(n - 1, 1, -1):\\n            cur += arr[j] * pow2[n - 1 - j]\\n            if cur == 0: continue\\n            i = bisect(prefix, cur) - 1\\n            if i >= j: break\\n            if i > 0 and prefix[i] == cur and prefix[j] - prefix[i] * pow2[j - i] == cur: return [i - 1, j] \\n        return [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect\\nfrom collections import Counter\\n\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        if 1 not in arr: return [0,2]\\n        if Counter(arr)[1] < 3: return [-1, -1]\\n        n = len(arr)\\n        prefix = [0] * (n + 1)\\n        pow2 = [1] * (n + 1)\\n        for i in range(1, n + 1): pow2[i] = pow2[i - 1] * 2\\n        for i in range(n): prefix[i + 1] = prefix[i] * 2 + arr[i]\\n        cur = 0\\n        for j in range(n - 1, 1, -1):\\n            cur += arr[j] * pow2[n - 1 - j]\\n            if cur == 0: continue\\n            i = bisect(prefix, cur) - 1\\n            if i >= j: break\\n            if i > 0 and prefix[i] == cur and prefix[j] - prefix[i] * pow2[j - i] == cur: return [i - 1, j] \\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936489,
                "title": "c-easy-to-understand-simple-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sum=accumulate(arr.begin(),arr.end(),0);\\n        int n=arr.size();\\n        if(sum==0)\\n        return {0,n-1};\\n        if(sum%3!=0)\\n        return {-1,-1};\\n        int x=sum/3;\\n     \\n        int ones=0;\\n        vector<int> right,left,mid;\\n        int b=n-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            right.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n                \\n            }\\n            if(ones==x)\\n            {\\n                b=i;\\n                break;    \\n            }\\n        }\\n        \\n        reverse(right.begin(),right.end());\\n        bool ok=true;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ok&&arr[i]==0)\\n            {\\n                continue;\\n            }\\n            ok=false;\\n            left.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n            }\\n            if(left.size()==right.size())\\n            {\\n                a=i;\\n                break;    \\n            }\\n        }\\n        \\n        if(left!=right)\\n        return {-1,-1};\\n        \\n        ok=true;\\n        for(int i=a+1;i<b;i++)\\n        {\\n            if(ok&&arr[i]==0)\\n            {\\n                continue;\\n            }\\n            ok=false;\\n            mid.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n            }\\n            if(mid.size()==right.size())\\n            {\\n                b=i;\\n                break;    \\n            }\\n        }\\n        if(mid!=right)\\n        return {-1,-1};\\n        \\n        return {a,b+1};\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sum=accumulate(arr.begin(),arr.end(),0);\\n        int n=arr.size();\\n        if(sum==0)\\n        return {0,n-1};\\n        if(sum%3!=0)\\n        return {-1,-1};\\n        int x=sum/3;\\n     \\n        int ones=0;\\n        vector<int> right,left,mid;\\n        int b=n-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            right.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n                \\n            }\\n            if(ones==x)\\n            {\\n                b=i;\\n                break;    \\n            }\\n        }\\n        \\n        reverse(right.begin(),right.end());\\n        bool ok=true;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ok&&arr[i]==0)\\n            {\\n                continue;\\n            }\\n            ok=false;\\n            left.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n            }\\n            if(left.size()==right.size())\\n            {\\n                a=i;\\n                break;    \\n            }\\n        }\\n        \\n        if(left!=right)\\n        return {-1,-1};\\n        \\n        ok=true;\\n        for(int i=a+1;i<b;i++)\\n        {\\n            if(ok&&arr[i]==0)\\n            {\\n                continue;\\n            }\\n            ok=false;\\n            mid.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n            }\\n            if(mid.size()==right.size())\\n            {\\n                b=i;\\n                break;    \\n            }\\n        }\\n        if(mid!=right)\\n        return {-1,-1};\\n        \\n        return {a,b+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882345,
                "title": "python-sol-linear-time-explained-approach-explained-well",
                "content": "# EXPLANATION\\n```\\nWe need to divide the array into 3 subarrays such that the binary value of each of subarray is same\\n\\nNow : 001100 represents 12 and 1100 represents 12 too !\\nThe point is since leading zeroes are allowed , two binary numbers can have different number of zeroes yet they can be equal\\nBut for two binary numbers to be equal they must have equal number of 1\\'s\\n\\nSo , in all three parts of array the number of 1\\'s must be equal\\n\\nFind total number of 1\\'s in array \\nIf count_one % 3!=0 : we can never split the 1\\'s equally hence ans is [-1,-1]\\nelse : we know that in every part we will have exactly count_one/3 no of 1\\'s\\n\\nNow let\\'s traverse the array and count no of 1\\'s\\nOur target T== count_one/3\\nwe will count as\\n1 , ... , T , T+1 , .... , 2T , ..... , 2T+1 , ..... , 3T .....\\nThe point is \\n    1.  First subarray will start from count = 1 and may end at count = T\\n    2.  Second subarray may start from count = T+1 and may end at 2T\\n    3.  Third subarray may start from count = 2T+1 and will may end at 3T\\n    \\n\\t\\n\\tHere I haven\\'t thought about the ending zeroes \\n\\tlike if our binary num is [1 , 0 , 1 , 0 , 1 , 0 , 0]\\n\\tand my target t = 3\\n\\tI will say that my part1 is start from index 0 and ends at index 4 i.e. [ 1 , 0 , 1 , 0 , 1 ] \\n\\tThe remaining [0,0] we don\\'t know if these are leading zeroes for part 2 or trailing zeroes    for part 1\\n\\t\\nFirst we find the parts starting and ending \\nstarting = [ 1 , t+1 , 2*t+1]\\nending =  [t , 2* t , 3*t]\\nhere t = no of zeroes in one part\\n\\nLet\\'s say we get our indexes as [i1,j1] , [i2,j2] , [i3,j3]\\nNow the item without the confusion of trailing zeroes or leading zeroes should be equal i,e,\\narr[i1:j1+1] == arr[i2:j2+1] == arr[i3:j3+1]\\n\\nSo we will have this confusion of either trailing zeroes or leading zeroes between\\n(part1 and part2) and (part2 and part3) say x and y\\n\\nSince zeroes after part 3 can only be trailing zero say z so,\\nx and y should never be less than z else we can\\'t divide equally\\n\\nFinally our ans will be \\n[ j1 + z , j2 + z + 1]\\n\\n\\n```\\n\\n# CODE\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        count_one = arr.count(1)\\n        if count_one == 0: return [0,n-1]\\n        if count_one % 3!= 0: return [-1,-1]\\n        target_ones = count_one // 3\\n        breaks = []\\n        one_count = 0\\n        for i , bit in enumerate(arr):\\n            if bit ==1 :\\n                one_count +=1\\n                if one_count in [1,target_ones+1,2*target_ones+1]:breaks.append(i)   \\n                if one_count in [target_ones,2*target_ones,3*target_ones]:breaks.append(i)\\n        i1,j1,i2,j2,i3,j3 = breaks\\n        \\n        if not arr[i1:j1+1] == arr[i2:j2+1] == arr[i3:j3+1]:return [-1,-1]\\n        \\n        trailing_zeroes_left  = i2 - j1 - 1\\n        trailing_zeroes_mid   = i3 - j2 - 1\\n        trailing_zeroes_right = n -  j3 - 1\\n        if trailing_zeroes_right > min(trailing_zeroes_left,trailing_zeroes_mid):return [-1,-1]\\n        j1 += trailing_zeroes_right\\n        j2 += trailing_zeroes_right\\n        return [j1,j2+1]\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nWe need to divide the array into 3 subarrays such that the binary value of each of subarray is same\\n\\nNow : 001100 represents 12 and 1100 represents 12 too !\\nThe point is since leading zeroes are allowed , two binary numbers can have different number of zeroes yet they can be equal\\nBut for two binary numbers to be equal they must have equal number of 1\\'s\\n\\nSo , in all three parts of array the number of 1\\'s must be equal\\n\\nFind total number of 1\\'s in array \\nIf count_one % 3!=0 : we can never split the 1\\'s equally hence ans is [-1,-1]\\nelse : we know that in every part we will have exactly count_one/3 no of 1\\'s\\n\\nNow let\\'s traverse the array and count no of 1\\'s\\nOur target T== count_one/3\\nwe will count as\\n1 , ... , T , T+1 , .... , 2T , ..... , 2T+1 , ..... , 3T .....\\nThe point is \\n    1.  First subarray will start from count = 1 and may end at count = T\\n    2.  Second subarray may start from count = T+1 and may end at 2T\\n    3.  Third subarray may start from count = 2T+1 and will may end at 3T\\n    \\n\\t\\n\\tHere I haven\\'t thought about the ending zeroes \\n\\tlike if our binary num is [1 , 0 , 1 , 0 , 1 , 0 , 0]\\n\\tand my target t = 3\\n\\tI will say that my part1 is start from index 0 and ends at index 4 i.e. [ 1 , 0 , 1 , 0 , 1 ] \\n\\tThe remaining [0,0] we don\\'t know if these are leading zeroes for part 2 or trailing zeroes    for part 1\\n\\t\\nFirst we find the parts starting and ending \\nstarting = [ 1 , t+1 , 2*t+1]\\nending =  [t , 2* t , 3*t]\\nhere t = no of zeroes in one part\\n\\nLet\\'s say we get our indexes as [i1,j1] , [i2,j2] , [i3,j3]\\nNow the item without the confusion of trailing zeroes or leading zeroes should be equal i,e,\\narr[i1:j1+1] == arr[i2:j2+1] == arr[i3:j3+1]\\n\\nSo we will have this confusion of either trailing zeroes or leading zeroes between\\n(part1 and part2) and (part2 and part3) say x and y\\n\\nSince zeroes after part 3 can only be trailing zero say z so,\\nx and y should never be less than z else we can\\'t divide equally\\n\\nFinally our ans will be \\n[ j1 + z , j2 + z + 1]\\n\\n\\n```\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        count_one = arr.count(1)\\n        if count_one == 0: return [0,n-1]\\n        if count_one % 3!= 0: return [-1,-1]\\n        target_ones = count_one // 3\\n        breaks = []\\n        one_count = 0\\n        for i , bit in enumerate(arr):\\n            if bit ==1 :\\n                one_count +=1\\n                if one_count in [1,target_ones+1,2*target_ones+1]:breaks.append(i)   \\n                if one_count in [target_ones,2*target_ones,3*target_ones]:breaks.append(i)\\n        i1,j1,i2,j2,i3,j3 = breaks\\n        \\n        if not arr[i1:j1+1] == arr[i2:j2+1] == arr[i3:j3+1]:return [-1,-1]\\n        \\n        trailing_zeroes_left  = i2 - j1 - 1\\n        trailing_zeroes_mid   = i3 - j2 - 1\\n        trailing_zeroes_right = n -  j3 - 1\\n        if trailing_zeroes_right > min(trailing_zeroes_left,trailing_zeroes_mid):return [-1,-1]\\n        j1 += trailing_zeroes_right\\n        j2 += trailing_zeroes_right\\n        return [j1,j2+1]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861788,
                "title": "c-o-n-2solution-without-while-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        \\n        int size = arr.size();\\n        int total_ones = 0;\\n        int start_first = 0, start_second, start_third;\\n        int count_ones = 0;\\n        int index_finder;\\n        std::vector<int> ones_indexs;\\n        ones_indexs.reserve(size);\\n        \\n        for(; start_first < size; ++start_first)\\n        {\\n            if(arr[start_first] == 1)\\n            {\\n               break; // get start first part for comparison(leading 0s are not relevant)\\n            }\\n        }\\n        \\n        for(int i = start_first; i < size; ++i)\\n        {\\n            if(arr[i] == 1) //count all 1s and store their indicies \\n            {\\n               total_ones++; \\n               ones_indexs.emplace_back(i);\\n            }\\n        }\\n        \\n        //checks if three non-empty parts are possible\\n        if(total_ones%3 != 0){return {-1,-1};}\\n        \\n        if(total_ones == 0){ return {0, size-1};}//only zeros in arr     \\n        \\n        int one_part_ones = total_ones/3;\\n        \\n        //Alternativly we can find the start of third and second ==> we dont need to store the indicies \"ones_indexs\"\\n        //find third length\\n        /*\\n        for(index_finder = size-1; index_finder > 0; --index_finder)\\n        {\\n            if(arr[index_finder] == 1)\\n            {\\n               count_ones++;\\n                if(count_ones == one_part_ones)\\n                {\\n                    //found \\n                    start_third = index_finder;\\n                    break;\\n                }\\n            }\\n        }\\n        --index_finder;//go to the next step\\n        count_ones = 0;\\n     \\n        for(; index_finder > 0; --index_finder)\\n        {\\n            if(arr[index_finder] == 1)\\n            {\\n                count_ones++;\\n                if(count_ones == one_part_ones)\\n                {\\n                    //found \\n                    start_second = index_finder;\\n                    break;\\n                }\\n            }\\n        }\\n        */\\n        \\n        \\n        // get start second part for comparison(leading 0s are not relevant)\\n        start_second = ones_indexs.at(one_part_ones);\\n        // get start third part for comparison(leading 0s are not relevant) \\n        start_third = ones_indexs.at(one_part_ones + one_part_ones);\\n        \\n        //length of comparison is determined of the third part length(without leading 0s)\\n        int length = (size-start_third);\\n        \\n        //we can calculate the first and second delimiter\\n        //but we dont know if the 1s having the same position\\n        int first_delimiter = start_first+length-1, second_delimiter =  start_second + length;\\n        \\n        \\n        for(; start_third < size; ++start_first, ++start_second, ++start_third )\\n        {\\n            if(arr[start_first] == arr[start_second] && arr[start_first] == arr[start_third])\\n                {\\n                    continue;\\n                }\\n            return {-1,-1};//1s are not the same places \\n        }\\n\\n        \\n        return {first_delimiter,second_delimiter};\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        \\n        int size = arr.size();\\n        int total_ones = 0;\\n        int start_first = 0, start_second, start_third;\\n        int count_ones = 0;\\n        int index_finder;\\n        std::vector<int> ones_indexs;\\n        ones_indexs.reserve(size);\\n        \\n        for(; start_first < size; ++start_first)\\n        {\\n            if(arr[start_first] == 1)\\n            {\\n               break; // get start first part for comparison(leading 0s are not relevant)\\n            }\\n        }\\n        \\n        for(int i = start_first; i < size; ++i)\\n        {\\n            if(arr[i] == 1) //count all 1s and store their indicies \\n            {\\n               total_ones++; \\n               ones_indexs.emplace_back(i);\\n            }\\n        }\\n        \\n        //checks if three non-empty parts are possible\\n        if(total_ones%3 != 0){return {-1,-1};}\\n        \\n        if(total_ones == 0){ return {0, size-1};}//only zeros in arr     \\n        \\n        int one_part_ones = total_ones/3;\\n        \\n        //Alternativly we can find the start of third and second ==> we dont need to store the indicies \"ones_indexs\"\\n        //find third length\\n        /*\\n        for(index_finder = size-1; index_finder > 0; --index_finder)\\n        {\\n            if(arr[index_finder] == 1)\\n            {\\n               count_ones++;\\n                if(count_ones == one_part_ones)\\n                {\\n                    //found \\n                    start_third = index_finder;\\n                    break;\\n                }\\n            }\\n        }\\n        --index_finder;//go to the next step\\n        count_ones = 0;\\n     \\n        for(; index_finder > 0; --index_finder)\\n        {\\n            if(arr[index_finder] == 1)\\n            {\\n                count_ones++;\\n                if(count_ones == one_part_ones)\\n                {\\n                    //found \\n                    start_second = index_finder;\\n                    break;\\n                }\\n            }\\n        }\\n        */\\n        \\n        \\n        // get start second part for comparison(leading 0s are not relevant)\\n        start_second = ones_indexs.at(one_part_ones);\\n        // get start third part for comparison(leading 0s are not relevant) \\n        start_third = ones_indexs.at(one_part_ones + one_part_ones);\\n        \\n        //length of comparison is determined of the third part length(without leading 0s)\\n        int length = (size-start_third);\\n        \\n        //we can calculate the first and second delimiter\\n        //but we dont know if the 1s having the same position\\n        int first_delimiter = start_first+length-1, second_delimiter =  start_second + length;\\n        \\n        \\n        for(; start_third < size; ++start_first, ++start_second, ++start_third )\\n        {\\n            if(arr[start_first] == arr[start_second] && arr[start_first] == arr[start_third])\\n                {\\n                    continue;\\n                }\\n            return {-1,-1};//1s are not the same places \\n        }\\n\\n        \\n        return {first_delimiter,second_delimiter};\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745866,
                "title": "python3-time-complexity-o-n",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        aSum = sum(arr)\\n        if aSum % 3 != 0:\\n            return [-1, -1]\\n        \\n        n = len(arr)\\n        if aSum == 0:\\n            return [0, n - 1]\\n        \\n        k = aSum//3\\n        idx = []\\n        cnt = 0 \\n        \\n        for (i, bit) in enumerate(arr):\\n            cnt += 1 if bit == 1 else 0 \\n            if cnt == 1 and bit == 1: \\n                idx.append(i)\\n            if cnt % k == 0:\\n                cnt = 0\\n        \\n\\t\\tj = 0 \\n        while idx[2] + j < n and arr[idx[0] + j] == arr[idx[1] + j] == arr[idx[2] + j]:\\n            j += 1 \\n            \\n        if idx[2] + j < n: \\n            return [-1, -1]\\n        else: \\n            return (idx[0] + j - 1, idx[1] + j)        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        aSum = sum(arr)\\n        if aSum % 3 != 0:\\n            return [-1, -1]\\n        \\n        n = len(arr)\\n        if aSum == 0:\\n            return [0, n - 1]\\n        \\n        k = aSum//3\\n        idx = []\\n        cnt = 0 \\n        \\n        for (i, bit) in enumerate(arr):\\n            cnt += 1 if bit == 1 else 0 \\n            if cnt == 1 and bit == 1: \\n                idx.append(i)\\n            if cnt % k == 0:\\n                cnt = 0\\n        \\n\\t\\tj = 0 \\n        while idx[2] + j < n and arr[idx[0] + j] == arr[idx[1] + j] == arr[idx[2] + j]:\\n            j += 1 \\n            \\n        if idx[2] + j < n: \\n            return [-1, -1]\\n        else: \\n            return (idx[0] + j - 1, idx[1] + j)        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716915,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        total1Count = 0\\n        for i in range(len(arr)): \\n            if arr[i] == 1: total1Count += 1\\n        \\n        if (total1Count % 3 != 0): return [-1, -1]\\n\\n        max1OfPart = total1Count // 3\\n        mIdx = [0, 1, 2, 0] # last one is dummy for reducing if statements, not used\\n        addIdx = 0\\n        partCount = 0\\n        \\n        # find 3 appropriate indices (first 3 elements of mIdx) \\n        for i in range(len(arr)):\\n            if (arr[i] == 1):\\n                mIdx[addIdx] = i\\n                partCount += 1\\n                \\n                if (partCount == max1OfPart):\\n                    addIdx += 1\\n                    mIdx[addIdx] = mIdx[addIdx - 1] + 1\\n                    partCount = 0\\n                    \\n            elif (arr[i] == 0 and addIdx == 3): # push indices with trailing zeros\\n                mIdx[0] += 1\\n                mIdx[1] += 1\\n                mIdx[2] += 1\\n                \\n                if (arr[mIdx[0]] == 1 or arr[mIdx[1]] == 1): return [-1, -1] # check if any part steps on the others, return [-1, -1] when it happens\\n        \\n        r = [mIdx[0], mIdx[1] + 1]\\n        \\n        # Verify parts having same value\\n        while mIdx[0] >= 0 and mIdx[1] > r[0] and mIdx[2] >= r[1]:            \\n            if (arr[mIdx[0]] != arr[mIdx[2]] or arr[mIdx[1]] != arr[mIdx[2]]): return [-1, -1]\\n            mIdx = [mIdx[i] - 1 for i in range(3)]\\n        \\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        total1Count = 0\\n        for i in range(len(arr)): \\n            if arr[i] == 1: total1Count += 1\\n        \\n        if (total1Count % 3 != 0): return [-1, -1]\\n\\n        max1OfPart = total1Count // 3\\n        mIdx = [0, 1, 2, 0] # last one is dummy for reducing if statements, not used\\n        addIdx = 0\\n        partCount = 0\\n        \\n        # find 3 appropriate indices (first 3 elements of mIdx) \\n        for i in range(len(arr)):\\n            if (arr[i] == 1):\\n                mIdx[addIdx] = i\\n                partCount += 1\\n                \\n                if (partCount == max1OfPart):\\n                    addIdx += 1\\n                    mIdx[addIdx] = mIdx[addIdx - 1] + 1\\n                    partCount = 0\\n                    \\n            elif (arr[i] == 0 and addIdx == 3): # push indices with trailing zeros\\n                mIdx[0] += 1\\n                mIdx[1] += 1\\n                mIdx[2] += 1\\n                \\n                if (arr[mIdx[0]] == 1 or arr[mIdx[1]] == 1): return [-1, -1] # check if any part steps on the others, return [-1, -1] when it happens\\n        \\n        r = [mIdx[0], mIdx[1] + 1]\\n        \\n        # Verify parts having same value\\n        while mIdx[0] >= 0 and mIdx[1] > r[0] and mIdx[2] >= r[1]:            \\n            if (arr[mIdx[0]] != arr[mIdx[2]] or arr[mIdx[1]] != arr[mIdx[2]]): return [-1, -1]\\n            mIdx = [mIdx[i] - 1 for i in range(3)]\\n        \\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1666617,
                "title": "3-equal-parts-beats-98-c-o-n",
                "content": "\\nTime complexity=O(n);\\nSpace complexity=O(1);\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n                c++;\\n        }\\n        if(c%3!=0)return v;\\n        if(c==0)return {0,2}; //can make split from anywhere. this is in case we have 3 size of given array\\n        \\n        int idx=-1;\\n        int cnt=0;\\n        // start counting c/3 1s from back,so that we can make 3 equal parts\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]==1)\\n                cnt++;\\n            if(cnt==c/3)\\n            {  idx=i;\\n             break;}\\n            \\n        }\\n        int front=0;  // ignoring leading 0s\\n        while(arr[front]==0)\\n            front++;\\n        \\n        int strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n        if(strt!=n)return v;\\n        int frststrt=front-1;\\n        while(arr[front]==0)front++;\\n        strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n         if(strt!=n)return v;\\n        return {frststrt,front};\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n                c++;\\n        }\\n        if(c%3!=0)return v;\\n        if(c==0)return {0,2}; //can make split from anywhere. this is in case we have 3 size of given array\\n        \\n        int idx=-1;\\n        int cnt=0;\\n        // start counting c/3 1s from back,so that we can make 3 equal parts\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]==1)\\n                cnt++;\\n            if(cnt==c/3)\\n            {  idx=i;\\n             break;}\\n            \\n        }\\n        int front=0;  // ignoring leading 0s\\n        while(arr[front]==0)\\n            front++;\\n        \\n        int strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n        if(strt!=n)return v;\\n        int frststrt=front-1;\\n        while(arr[front]==0)front++;\\n        strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n         if(strt!=n)return v;\\n        return {frststrt,front};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652547,
                "title": "o-n-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size();\\n        int one=0,zero=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0)zero++;\\n            else one++;\\n        }\\n        if(one%3!=0)return {-1,-1};\\n        if(zero==arr.size())return{0,2};\\n        int curr=0;\\n        string start=\"\",end=\"\",mid=\"\";\\n        int first;\\n        int i=n-1;\\n        while(curr!=(one/3)){\\n            if(arr[i]==1){\\n                curr++;\\n            }\\n            end+=to_string(arr[i]);\\n            i--;\\n        }\\n        reverse(end.begin(),end.end());\\n        i=0;\\n        while(start.size()<end.size()){\\n            if(arr[i]==1){\\n                while(start.size()<end.size()){\\n                    start+=to_string(arr[i]);\\n                    i++;\\n                }\\n            }\\n            if(start.size()<end.size())i++;\\n        }\\n        first=i-1;\\n        if(start!=end)return {-1,-1};\\n        while(mid.size()<start.size()){\\n            if(arr[i]==1){\\n                while(mid.size()<end.size()){\\n                    mid+=to_string(arr[i]);\\n                    i++;\\n                }\\n            }\\n            if(mid.size()<end.size())i++;\\n        }\\n        if(start==mid)return {first,i};\\n        else return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size();\\n        int one=0,zero=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0)zero++;\\n            else one++;\\n        }\\n        if(one%3!=0)return {-1,-1};\\n        if(zero==arr.size())return{0,2};\\n        int curr=0;\\n        string start=\"\",end=\"\",mid=\"\";\\n        int first;\\n        int i=n-1;\\n        while(curr!=(one/3)){\\n            if(arr[i]==1){\\n                curr++;\\n            }\\n            end+=to_string(arr[i]);\\n            i--;\\n        }\\n        reverse(end.begin(),end.end());\\n        i=0;\\n        while(start.size()<end.size()){\\n            if(arr[i]==1){\\n                while(start.size()<end.size()){\\n                    start+=to_string(arr[i]);\\n                    i++;\\n                }\\n            }\\n            if(start.size()<end.size())i++;\\n        }\\n        first=i-1;\\n        if(start!=end)return {-1,-1};\\n        while(mid.size()<start.size()){\\n            if(arr[i]==1){\\n                while(mid.size()<end.size()){\\n                    mid+=to_string(arr[i]);\\n                    i++;\\n                }\\n            }\\n            if(mid.size()<end.size())i++;\\n        }\\n        if(start==mid)return {first,i};\\n        else return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571756,
                "title": "o-n-c-with-explanation",
                "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nFirstly, if two parts\\' binary value is equal, the number of 1 of them must be equal. We can iterate the array to get the total count of 1. If it can be divided by 3, then we can\\'t get 3 equal parts. Otherwise, we can get each part\\'s number of 1, which is total_count / 3.\\n\\nHowever, only knowing the number of 1 of each part can\\'t determine the position of each part, for that the leading zero of each part won\\'t contribute to the value of the part. So we don\\'t know the start position of each part when it has leading zeros. However, except for the leading zeros, other zeros in the part will contribute to the value, so these zeros must be the same for each target part. We can iterate the array from right to left, and get the trailing zeros of the last part, which are also the trailing zeros of other two parts. \\n\\nWith the information above, we can iterate the array from left to right, and when we meet total_count / 3 number of 1, we  get enough 1 of the current target part, then we continue to get enough the trailing zeros. If we succeed, let\\'s say the position of enough trailing zeros is called `p`, then [0, p] is the first part we find. We repeat the process above to get the second part, let\\'s say it\\'s `q`.  Finally, we compare if [0, p], [p + 1, q], [q + 1, size - 1] can represent the same value.\\n\\nWe iterate the array several rounds, total time complexity is O(n).\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findpos(vector<int>&arr, int last_0, int cnt_1, int start, int& pos) {\\n        int cnt_tmp = 0;\\n        int i = start;\\n        for (; i < arr.size(); i++) {\\n            if (arr[i] == 1)\\n                cnt_tmp++;\\n            \\n            if (cnt_tmp == cnt_1 / 3) {\\n                break;\\n            }\\n        }\\n        \\n \\n        cnt_tmp = 0;\\n        if (last_0 != 0)\\n            i++;\\n        for (; i < arr.size(); i++) {\\n            if (arr[i] == 0) {\\n                cnt_tmp++;\\n            } else {\\n                break;\\n            }\\n            if (cnt_tmp == last_0) {\\n                break;\\n            }\\n        }\\n        if (cnt_tmp != last_0) {\\n            return -1;\\n        }\\n   \\n        pos = i;\\n        return 0;\\n    }\\n    int cmparr(vector<int>&arr, int start1, int end1, int start2, int end2) {\\n        int i = start1;\\n        int j = start2;\\n        while (arr[i] == 0)\\n            i++;\\n        \\n        while (arr[j] == 0)\\n            j++;\\n        \\n        if (end1 - i != end2 - j) {\\n            return -1;\\n        }\\n        for (int k = i; k <= end1; k++) {\\n            if (arr[k] != arr[j + k - i]) {\\n                return -1;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int cnt_1 = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (arr[i] == 1) {\\n                cnt_1++;\\n            }\\n        }\\n        \\n        if (cnt_1 == 0) {\\n            return vector<int>{0, 2};\\n        }\\n        if (cnt_1 % 3) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        int last_0 = 0;\\n        for (int i = arr.size() - 1; i >= 0; i--) {\\n            if (arr[i] == 1)\\n                break;\\n            \\n            last_0++;\\n        }\\n        \\n\\n        int start = 0;\\n        int ret = findpos(arr, last_0, cnt_1, 0, start);\\n        if (ret != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        int end  = 0;\\n        ret = findpos(arr, last_0, cnt_1, start + 1, end);\\n        if (ret != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        if (cmparr(arr, 0, start, start + 1, end) != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        if (cmparr(arr, start + 1, end, end + 1, arr.size() - 1) != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        return vector<int>{start, end + 1};\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findpos(vector<int>&arr, int last_0, int cnt_1, int start, int& pos) {\\n        int cnt_tmp = 0;\\n        int i = start;\\n        for (; i < arr.size(); i++) {\\n            if (arr[i] == 1)\\n                cnt_tmp++;\\n            \\n            if (cnt_tmp == cnt_1 / 3) {\\n                break;\\n            }\\n        }\\n        \\n \\n        cnt_tmp = 0;\\n        if (last_0 != 0)\\n            i++;\\n        for (; i < arr.size(); i++) {\\n            if (arr[i] == 0) {\\n                cnt_tmp++;\\n            } else {\\n                break;\\n            }\\n            if (cnt_tmp == last_0) {\\n                break;\\n            }\\n        }\\n        if (cnt_tmp != last_0) {\\n            return -1;\\n        }\\n   \\n        pos = i;\\n        return 0;\\n    }\\n    int cmparr(vector<int>&arr, int start1, int end1, int start2, int end2) {\\n        int i = start1;\\n        int j = start2;\\n        while (arr[i] == 0)\\n            i++;\\n        \\n        while (arr[j] == 0)\\n            j++;\\n        \\n        if (end1 - i != end2 - j) {\\n            return -1;\\n        }\\n        for (int k = i; k <= end1; k++) {\\n            if (arr[k] != arr[j + k - i]) {\\n                return -1;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int cnt_1 = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (arr[i] == 1) {\\n                cnt_1++;\\n            }\\n        }\\n        \\n        if (cnt_1 == 0) {\\n            return vector<int>{0, 2};\\n        }\\n        if (cnt_1 % 3) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        int last_0 = 0;\\n        for (int i = arr.size() - 1; i >= 0; i--) {\\n            if (arr[i] == 1)\\n                break;\\n            \\n            last_0++;\\n        }\\n        \\n\\n        int start = 0;\\n        int ret = findpos(arr, last_0, cnt_1, 0, start);\\n        if (ret != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        int end  = 0;\\n        ret = findpos(arr, last_0, cnt_1, start + 1, end);\\n        if (ret != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        if (cmparr(arr, 0, start, start + 1, end) != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        if (cmparr(arr, start + 1, end, end + 1, arr.size() - 1) != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        return vector<int>{start, end + 1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569169,
                "title": "c-o-n-notes",
                "content": "```\\n// The ones should be devided to equel 3 parts\\n// if (ones%3) => {-1,-1}\\n// if (ones==0) => {0,2} (most trivial one)\\n// Find the first one (the highst 1) for each part\\n// The last part should go up to the end of the array\\n// compare the three part if the same, find i, j by the end of part 1 and 2\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int ones = accumulate(arr.begin(), arr.end(), 0);\\n\\n        if (!ones)  return {0,2};\\n        if (ones%3) return {-1,-1};\\n        int x = ones/3;\\n        int j = arr.size();\\n        ones = 0;\\n        while (ones<x) \\n        {\\n            j--;\\n            ones +=arr[j];\\n        }\\n        int k = j;\\n        ones = 0;\\n        while (ones<x) \\n        {\\n            k--;\\n            ones +=arr[k];\\n        }\\n        int i = 0;\\n        while (!arr[i]) i++;\\n        // cout << i << k << j << endl;\\n        while (j<arr.size() && arr[i]==arr[j] && arr[i] == arr[k]) \\n        {\\n            i++; j++; k++;\\n        }\\n        if (j != arr.size()) return {-1,-1};          \\n        return {i-1,k};        \\n    }\\n};\\n// [1,1,1,1,1,1,0,1,1,1]\\n// [0,0,0]\\n// [1,1,1]\\n```",
                "solutionTags": [],
                "code": "```\\n// The ones should be devided to equel 3 parts\\n// if (ones%3) => {-1,-1}\\n// if (ones==0) => {0,2} (most trivial one)\\n// Find the first one (the highst 1) for each part\\n// The last part should go up to the end of the array\\n// compare the three part if the same, find i, j by the end of part 1 and 2\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int ones = accumulate(arr.begin(), arr.end(), 0);\\n\\n        if (!ones)  return {0,2};\\n        if (ones%3) return {-1,-1};\\n        int x = ones/3;\\n        int j = arr.size();\\n        ones = 0;\\n        while (ones<x) \\n        {\\n            j--;\\n            ones +=arr[j];\\n        }\\n        int k = j;\\n        ones = 0;\\n        while (ones<x) \\n        {\\n            k--;\\n            ones +=arr[k];\\n        }\\n        int i = 0;\\n        while (!arr[i]) i++;\\n        // cout << i << k << j << endl;\\n        while (j<arr.size() && arr[i]==arr[j] && arr[i] == arr[k]) \\n        {\\n            i++; j++; k++;\\n        }\\n        if (j != arr.size()) return {-1,-1};          \\n        return {i-1,k};        \\n    }\\n};\\n// [1,1,1,1,1,1,0,1,1,1]\\n// [0,0,0]\\n// [1,1,1]\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1434603,
                "title": "java-string-based-solution",
                "content": "There are essentially 3 things to do \\n* Check if the total ones in the array is a multiple of 3\\n* Find out the last index of the first `1` in the last part  ,and check for that suffix in the first and 2nd part of the string\\n* What ever is left over in the mid part of the string after all the matching should contain `0` because that\\'s the part that has to be given to the last part of the string \\n\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        try {\\n            StringBuilder last = new StringBuilder();\\n            int count = 0;\\n            StringBuilder total = new StringBuilder();\\n            for (int num : arr) {\\n                count += (num == 1 ? 1 : 0);\\n                total.append(num);\\n            }\\n            if (count % 3 != 0) {\\n                return new int[]{-1, -1};\\n            }\\n            int curr = 0;\\n            for (int i = arr.length - 1; i >= 0; i--) {\\n                if (arr[i] == 1) {\\n                    curr++;\\n                }\\n                last.insert(0, arr[i]);\\n                if (curr == count / 3) {\\n                    break;\\n                }\\n            }\\n            int lastBegin = total.lastIndexOf(last.toString());\\n            int firstBegin = total.indexOf(last.toString());\\n            if (firstBegin == -1 || firstBegin == lastBegin) {\\n                return new int[]{-1, -1};\\n            }\\n            String mid = total.substring(firstBegin + last.length(), lastBegin);\\n            int midIdx = mid.indexOf(last.toString());\\n            if (midIdx == -1) {\\n                return new int[]{-1, -1};\\n            }\\n            String leftOver = mid.substring(midIdx + last.length());\\n            if (leftOver.contains(\"1\")) {\\n                return new int[]{-1, -1};\\n            }\\n            return new int[]{firstBegin + last.length() - 1, total.length() - last.length() - leftOver.length()};\\n        } catch (StringIndexOutOfBoundsException e) {\\n            return new int[]{-1, -1};\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        try {\\n            StringBuilder last = new StringBuilder();\\n            int count = 0;\\n            StringBuilder total = new StringBuilder();\\n            for (int num : arr) {\\n                count += (num == 1 ? 1 : 0);\\n                total.append(num);\\n            }\\n            if (count % 3 != 0) {\\n                return new int[]{-1, -1};\\n            }\\n            int curr = 0;\\n            for (int i = arr.length - 1; i >= 0; i--) {\\n                if (arr[i] == 1) {\\n                    curr++;\\n                }\\n                last.insert(0, arr[i]);\\n                if (curr == count / 3) {\\n                    break;\\n                }\\n            }\\n            int lastBegin = total.lastIndexOf(last.toString());\\n            int firstBegin = total.indexOf(last.toString());\\n            if (firstBegin == -1 || firstBegin == lastBegin) {\\n                return new int[]{-1, -1};\\n            }\\n            String mid = total.substring(firstBegin + last.length(), lastBegin);\\n            int midIdx = mid.indexOf(last.toString());\\n            if (midIdx == -1) {\\n                return new int[]{-1, -1};\\n            }\\n            String leftOver = mid.substring(midIdx + last.length());\\n            if (leftOver.contains(\"1\")) {\\n                return new int[]{-1, -1};\\n            }\\n            return new int[]{firstBegin + last.length() - 1, total.length() - last.length() - leftOver.length()};\\n        } catch (StringIndexOutOfBoundsException e) {\\n            return new int[]{-1, -1};\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357931,
                "title": "java-clean-concise-optimal-code-three-pointer-approach-o-n-time-solution",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        \\n        int ones = 0;\\n        \\n        for (int num : arr) {\\n            ones += num;\\n        }\\n        \\n        if (ones == 0) {\\n            return new int[] {0, 2};\\n        }\\n        else if (ones % 3 != 0) {\\n            return new int[] {-1, -1};\\n        }\\n        \\n        ones /= 3;\\n        int index1 = -1, index2 = -1, index3 = -1, totalOnes = 0;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                continue;\\n            }\\n            \\n            totalOnes += arr[i];\\n            if (totalOnes == 1) {\\n                index1 = i;\\n            }\\n            else if (totalOnes == ones + 1) {\\n                index2 = i;\\n            }\\n            else if (totalOnes == 2 * ones + 1) {\\n                index3 = i;\\n            }\\n        }\\n        \\n        while (index3 < arr.length) {\\n            if (arr[index1] == arr[index3] && arr[index2] == arr[index3]) {\\n                ++index1;\\n                ++index2;\\n                ++index3;\\n            }\\n            else {\\n                return new int[] {-1, -1};\\n            }\\n        }\\n        \\n        return new int[] {index1 - 1, index2};\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        \\n        int ones = 0;\\n        \\n        for (int num : arr) {\\n            ones += num;\\n        }\\n        \\n        if (ones == 0) {\\n            return new int[] {0, 2};\\n        }\\n        else if (ones % 3 != 0) {\\n            return new int[] {-1, -1};\\n        }\\n        \\n        ones /= 3;\\n        int index1 = -1, index2 = -1, index3 = -1, totalOnes = 0;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                continue;\\n            }\\n            \\n            totalOnes += arr[i];\\n            if (totalOnes == 1) {\\n                index1 = i;\\n            }\\n            else if (totalOnes == ones + 1) {\\n                index2 = i;\\n            }\\n            else if (totalOnes == 2 * ones + 1) {\\n                index3 = i;\\n            }\\n        }\\n        \\n        while (index3 < arr.length) {\\n            if (arr[index1] == arr[index3] && arr[index2] == arr[index3]) {\\n                ++index1;\\n                ++index2;\\n                ++index3;\\n            }\\n            else {\\n                return new int[] {-1, -1};\\n            }\\n        }\\n        \\n        return new int[] {index1 - 1, index2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354250,
                "title": "rust-o-n-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn three_equal_parts(arr: Vec<i32>) -> Vec<i32> {\\n        let mut idxs = vec![];\\n        for i in 0..arr.len() {\\n            if arr[i] == 1 {\\n                idxs.push(i);\\n            }\\n        }\\n        \\n        let n = idxs.len();\\n        if n == 0 {\\n            return vec![0,arr.len() as i32-1];\\n        }\\n        // number of 1s should be divisible by 3\\n        if n % 3 != 0 {\\n            return vec![-1, -1];\\n        }\\n        // find starting indices for each part\\n        let (s0, s1, s2) = (0, n/3, 2*n/3);\\n        // equal gaps between 1\\'s\\n        let (mut i, mut j, mut k) = (s0+1, s1+1, s2+1);\\n        while i < s1 {\\n            let g0 = idxs[i] - idxs[i-1];\\n            let g1 = idxs[j] - idxs[j-1];\\n            let g2 = idxs[k] - idxs[k-1];\\n            if g0 != g1 || g1 != g2 {\\n                return vec![-1, -1];\\n            }\\n            i += 1;\\n            j += 1;\\n            k += 1;\\n        }\\n        // equal trailing 0\\'s\\n        let N = arr.len() - 1;\\n        let trailing_0 = N - idxs[n-1];\\n        if idxs[s1] - idxs[s1-1] <= trailing_0 || idxs[s2] - idxs[s2-1] <= trailing_0 {\\n            return vec![-1, -1];\\n        }\\n        // println!(\"{} {} {}\", idxs[s1], idxs[s2], trailing_0);\\n        vec![\\n            (idxs[s1-1]+trailing_0) as i32,\\n            (idxs[s2-1]+trailing_0+1) as i32,\\n        ]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn three_equal_parts(arr: Vec<i32>) -> Vec<i32> {\\n        let mut idxs = vec![];\\n        for i in 0..arr.len() {\\n            if arr[i] == 1 {\\n                idxs.push(i);\\n            }\\n        }\\n        \\n        let n = idxs.len();\\n        if n == 0 {\\n            return vec![0,arr.len() as i32-1];\\n        }\\n        // number of 1s should be divisible by 3\\n        if n % 3 != 0 {\\n            return vec![-1, -1];\\n        }\\n        // find starting indices for each part\\n        let (s0, s1, s2) = (0, n/3, 2*n/3);\\n        // equal gaps between 1\\'s\\n        let (mut i, mut j, mut k) = (s0+1, s1+1, s2+1);\\n        while i < s1 {\\n            let g0 = idxs[i] - idxs[i-1];\\n            let g1 = idxs[j] - idxs[j-1];\\n            let g2 = idxs[k] - idxs[k-1];\\n            if g0 != g1 || g1 != g2 {\\n                return vec![-1, -1];\\n            }\\n            i += 1;\\n            j += 1;\\n            k += 1;\\n        }\\n        // equal trailing 0\\'s\\n        let N = arr.len() - 1;\\n        let trailing_0 = N - idxs[n-1];\\n        if idxs[s1] - idxs[s1-1] <= trailing_0 || idxs[s2] - idxs[s2-1] <= trailing_0 {\\n            return vec![-1, -1];\\n        }\\n        // println!(\"{} {} {}\", idxs[s1], idxs[s2], trailing_0);\\n        vec![\\n            (idxs[s1-1]+trailing_0) as i32,\\n            (idxs[s2-1]+trailing_0+1) as i32,\\n        ]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352815,
                "title": "c-o-n-simple-3-pointer-ish-solution",
                "content": "The idea is to split the array into 3 segments - [0, i_], [i_+1, j_] and [j_, n-1] each having the same number of \\'1\\'s. Then, we try to compare the entries in these 3 segments (RHS TO LHS) and ensure they are producing the same binary values. i.e 0011, 011, 11 all have the same values right.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        int i_, j_, numo=0;\\n        \\n        // Find the number of \\'1\\'s in the vector. It has to be divisible by 3 to have a \\n        // valid answer.\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==1){\\n                numo++;\\n            }\\n        }\\n        \\n        if(numo%3 == 0){\\n            \\n            // Case if all the elements of arr are 0 - then just return {0, 2}\\n            if(numo==0){\\n                return {0,2};\\n            }\\n            \\n            // Find the first index i_, and second index j_ each containing a segement\\n            // with re (= numo/3) number of \\'1\\'s.\\n            int re = numo/3, cnt = 0, f = 0;\\n            for(int i=0;i<arr.size();i++){\\n                if(arr[i] == 1){\\n                    cnt++;\\n                    if(cnt == re){\\n                        if(!f)\\n                        {\\n                            i_ = i;\\n                            f = 1;\\n                            cnt = 0;\\n                        }else{\\n                            j_ = i;\\n                            f = 2;\\n                        }\\n                    }\\n                }\\n            }\\n            // So, first segment - [0, i_], second segment - [i_+1, j_], third segment - [j_+1, n-1]\\n            // Of course, each of these 3 segments has exactly re (= numo/3) number of \\'1\\'s.\\n            // Now, we try to manage/equate the number of trailing zeros in these three segments.\\n            // If an overlap takes place while modifying i_, j_ and r - then return {-1, -1} as it \\n            // isn\\'t possible to get 3 segements with same binary values.\\n            int r = n-1;\\n            while(arr[r]==0){\\n                r--;\\n                i_++;\\n                j_++;\\n                if(j_ == r){\\n                    return {-1, -1}; // problem here due to overlap\\n                }\\n            }\\n            int i = i_, j = j_;\\n            r = n-1;\\n            // Now make sure each of the 3 segments have the same value by comparing their\\n            // set bits from the RHS TO LHS...i.e 0010, 010, 10 all have the same values right.\\n            while(i>-1 && j>i_ && r>j_){\\n                if(arr[i]==arr[j] && arr[j]==arr[r]){\\n                    i--;\\n                    j--;\\n                    r--;\\n                }else{\\n                    return {-1, -1}; // If some inequality, return this\\n                }\\n            }\\n            \\n            return {i_, j_+1}; // return the ans\\n            \\n        }else{\\n            // As number of \\'1\\'s in the arr itself is not divisible by 3 - we can\\'t do nothing.\\n            vector<int> ans = {-1, -1};\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        int i_, j_, numo=0;\\n        \\n        // Find the number of \\'1\\'s in the vector. It has to be divisible by 3 to have a \\n        // valid answer.\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==1){\\n                numo++;\\n            }\\n        }\\n        \\n        if(numo%3 == 0){\\n            \\n            // Case if all the elements of arr are 0 - then just return {0, 2}\\n            if(numo==0){\\n                return {0,2};\\n            }\\n            \\n            // Find the first index i_, and second index j_ each containing a segement\\n            // with re (= numo/3) number of \\'1\\'s.\\n            int re = numo/3, cnt = 0, f = 0;\\n            for(int i=0;i<arr.size();i++){\\n                if(arr[i] == 1){\\n                    cnt++;\\n                    if(cnt == re){\\n                        if(!f)\\n                        {\\n                            i_ = i;\\n                            f = 1;\\n                            cnt = 0;\\n                        }else{\\n                            j_ = i;\\n                            f = 2;\\n                        }\\n                    }\\n                }\\n            }\\n            // So, first segment - [0, i_], second segment - [i_+1, j_], third segment - [j_+1, n-1]\\n            // Of course, each of these 3 segments has exactly re (= numo/3) number of \\'1\\'s.\\n            // Now, we try to manage/equate the number of trailing zeros in these three segments.\\n            // If an overlap takes place while modifying i_, j_ and r - then return {-1, -1} as it \\n            // isn\\'t possible to get 3 segements with same binary values.\\n            int r = n-1;\\n            while(arr[r]==0){\\n                r--;\\n                i_++;\\n                j_++;\\n                if(j_ == r){\\n                    return {-1, -1}; // problem here due to overlap\\n                }\\n            }\\n            int i = i_, j = j_;\\n            r = n-1;\\n            // Now make sure each of the 3 segments have the same value by comparing their\\n            // set bits from the RHS TO LHS...i.e 0010, 010, 10 all have the same values right.\\n            while(i>-1 && j>i_ && r>j_){\\n                if(arr[i]==arr[j] && arr[j]==arr[r]){\\n                    i--;\\n                    j--;\\n                    r--;\\n                }else{\\n                    return {-1, -1}; // If some inequality, return this\\n                }\\n            }\\n            \\n            return {i_, j_+1}; // return the ans\\n            \\n        }else{\\n            // As number of \\'1\\'s in the arr itself is not divisible by 3 - we can\\'t do nothing.\\n            vector<int> ans = {-1, -1};\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347377,
                "title": "simple-ruby-solution-with-comments-three-equal-parts",
                "content": "Runtime: 140 ms, faster than 100.00% of Ruby online submissions for Three Equal Parts.\\nMemory Usage: 213.5 MB, less than 100.00% of Ruby online submissions for Three Equal Parts.\\n```\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef three_equal_parts(arr)\\n    num_of_one = arr.sum\\n    return [0, arr.size - 1] if num_of_one.zero?\\n    return [-1, -1] if num_of_one % 3 != 0\\n    first, second = num_of_one / 3, num_of_one * 2 / 3\\n    imp, idx, count_one = [], 0, 0\\n\\t# split by count of ones\\n    while idx < arr.size and count_one < num_of_one\\n        if arr[idx] == 1\\n            case count_one += 1\\n            when first\\n                imp[0] = idx\\n            when second\\n                imp[1] = idx\\n            when num_of_one\\n                imp[2] = idx\\n            end\\n        end\\n        idx += 1\\n    end\\n\\t# the rest zeros\\n    if imp[2] < arr.size - 1\\n        offset = arr.size - 1 - imp[2]\\n        imp[0] += offset\\n        imp[1] += offset\\n        imp[2] = arr.size - 1\\n    end\\n\\t# reduce to strings, convert 0 to space, then remove the heading space with lstrip\\n    splited = [arr[0..imp[0]], arr[(imp[0] + 1)..imp[1]], arr[(imp[1] + 1)..imp[2]]].map do |a|\\n        a.reduce(\\'\\') { |res, n| res << (n.zero? ? \\' \\' : \\'1\\') }.lstrip\\n    end\\n\\t# compare the generated strings\\n    0.upto(splited.size - 2).each { |i| return [-1, -1] if splited[i] != splited[i + 1] }\\n    [imp[0], imp[1] + 1]\\nend\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef three_equal_parts(arr)\\n    num_of_one = arr.sum\\n    return [0, arr.size - 1] if num_of_one.zero?\\n    return [-1, -1] if num_of_one % 3 != 0\\n    first, second = num_of_one / 3, num_of_one * 2 / 3\\n    imp, idx, count_one = [], 0, 0\\n\\t# split by count of ones\\n    while idx < arr.size and count_one < num_of_one\\n        if arr[idx] == 1\\n            case count_one += 1\\n            when first\\n                imp[0] = idx\\n            when second\\n                imp[1] = idx\\n            when num_of_one\\n                imp[2] = idx\\n            end\\n        end\\n        idx += 1\\n    end\\n\\t# the rest zeros\\n    if imp[2] < arr.size - 1\\n        offset = arr.size - 1 - imp[2]\\n        imp[0] += offset\\n        imp[1] += offset\\n        imp[2] = arr.size - 1\\n    end\\n\\t# reduce to strings, convert 0 to space, then remove the heading space with lstrip\\n    splited = [arr[0..imp[0]], arr[(imp[0] + 1)..imp[1]], arr[(imp[1] + 1)..imp[2]]].map do |a|\\n        a.reduce(\\'\\') { |res, n| res << (n.zero? ? \\' \\' : \\'1\\') }.lstrip\\n    end\\n\\t# compare the generated strings\\n    0.upto(splited.size - 2).each { |i| return [-1, -1] if splited[i] != splited[i + 1] }\\n    [imp[0], imp[1] + 1]\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1346486,
                "title": "python-o-n-iterative-well-commented-and-recursive",
                "content": "We should see if the next k nodes are available. We then reverse the next k nodes keeping the previous pointer intact to assigs its next pointer to the reversed group starting.\\n\\nIteartive:\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        \\n        # grouping size should be atleast 2\\n        if k < 2:\\n            return head\\n         \\n        # utility method to reverse a part from start before the before pointer\\n        def reverse(start, before):\\n            prev = None\\n            node = start\\n            while node != before:\\n                # doing the reverse\\n                nxt = node.next\\n                node.next = prev\\n                prev = node\\n                node = nxt\\n            \\n            # after reverse, initial starting point will point to before pointer\\n            start.next = before\\n            return prev\\n        \\n        # starting point\\n        start = head\\n\\n        # pointer prvious to the current group\\n        prev = None\\n        \\n        while True:\\n            # reach one more than the next k nodes\\n            node = start\\n            count = k\\n            while node and count:\\n                node = node.next\\n                count -= 1\\n            \\n            # if less than k nodes are left, stop reversing\\n            if count:\\n                break\\n            \\n            # get the start point of new group\\n            newStart = reverse(start, node)\\n            \\n            if not prev:\\n                # if previous pointer is not set, this is first group\\n                head = newStart\\n            else:\\n                # else, set this group\\'s start as the next of previous\\n                prev.next = newStart\\n            \\n            # set previous to start\\n            prev = start\\n            # set the start to the current node\\n            start = node\\n        \\n        return head\\n```\\n\\nRecursive:\\n```\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if k < 2:\\n            return head\\n         \\n        def reverse(start):\\n            \\n            node = start\\n            left = 0\\n            while node and left < k:\\n                node = node.next\\n                left += 1\\n                \\n            if left < k:\\n                return start\\n            \\n            node = start\\n            nxt = None\\n            prev = None\\n            count = 0\\n            \\n            prev = None\\n            while node and count < k:\\n                nxt = node.next\\n                node.next = prev\\n                prev = node\\n                node = nxt\\n                count += 1\\n            \\n            start.next = reverse(nxt)\\n            \\n            return prev\\n        \\n        return reverse(head)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        \\n        # grouping size should be atleast 2\\n        if k < 2:\\n            return head\\n         \\n        # utility method to reverse a part from start before the before pointer\\n        def reverse(start, before):\\n            prev = None\\n            node = start\\n            while node != before:\\n                # doing the reverse\\n                nxt = node.next\\n                node.next = prev\\n                prev = node\\n                node = nxt\\n            \\n            # after reverse, initial starting point will point to before pointer\\n            start.next = before\\n            return prev\\n        \\n        # starting point\\n        start = head\\n\\n        # pointer prvious to the current group\\n        prev = None\\n        \\n        while True:\\n            # reach one more than the next k nodes\\n            node = start\\n            count = k\\n            while node and count:\\n                node = node.next\\n                count -= 1\\n            \\n            # if less than k nodes are left, stop reversing\\n            if count:\\n                break\\n            \\n            # get the start point of new group\\n            newStart = reverse(start, node)\\n            \\n            if not prev:\\n                # if previous pointer is not set, this is first group\\n                head = newStart\\n            else:\\n                # else, set this group\\'s start as the next of previous\\n                prev.next = newStart\\n            \\n            # set previous to start\\n            prev = start\\n            # set the start to the current node\\n            start = node\\n        \\n        return head\\n```\n```\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if k < 2:\\n            return head\\n         \\n        def reverse(start):\\n            \\n            node = start\\n            left = 0\\n            while node and left < k:\\n                node = node.next\\n                left += 1\\n                \\n            if left < k:\\n                return start\\n            \\n            node = start\\n            nxt = None\\n            prev = None\\n            count = 0\\n            \\n            prev = None\\n            while node and count < k:\\n                nxt = node.next\\n                node.next = prev\\n                prev = node\\n                node = nxt\\n                count += 1\\n            \\n            start.next = reverse(nxt)\\n            \\n            return prev\\n        \\n        return reverse(head)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345943,
                "title": "three-equal-parts-o-n-simple-approach-solution-java",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ans[] = new int[2];\\n        int count1 = 0;\\n        int n = arr.length;\\n        for(int i : arr){\\n            if(i == 1){\\n                count1++;\\n            }\\n        }\\n        if(count1 == 0){\\n            ans[0] = 0;\\n            ans[1] = n-1;\\n            return ans;\\n        }\\n        if(count1 % 3 != 0){\\n            ans[0] = -1;\\n            ans[1] = -1;\\n            return ans;\\n        }\\n        \\n        int part = count1 / 3;\\n        int i = 0; int j = 0; int k = 0;\\n        boolean flag1 = false, flag2 = false;\\n        int check1 = 0;\\n        for(int p = 0; p < n ; p++){\\n            if(arr[p] == 1){\\n                check1++;\\n            }\\n            if(check1 == 1 && !flag1){\\n                i = p;\\n                flag1 = true;\\n            }else if(check1 == part + 1 && !flag2){\\n                j = p;\\n                flag2 = true;\\n            }else if(check1 == 2 * part + 1){\\n                k = p;\\n                break;\\n            }\\n        }\\n        System.out.println(\"i: \" + i + \" j: \" + j + \" k: \" + k);\\n        int m = j, nn = k;\\n        while(k < n){\\n            if(arr[j] != arr[j] || arr[j] != arr[k] || i >= m || j >= nn){\\n                ans[0] = -1;\\n                ans[1] = -1;\\n                return ans; \\n            }\\n            i++;j++;k++;\\n        }\\n        //System.out.println(\"i: \" + i + \" j: \" + j + \" k: \" + k);\\n        ans[0] = i-1;\\n        ans[1] = j;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ans[] = new int[2];\\n        int count1 = 0;\\n        int n = arr.length;\\n        for(int i : arr){\\n            if(i == 1){\\n                count1++;\\n            }\\n        }\\n        if(count1 == 0){\\n            ans[0] = 0;\\n            ans[1] = n-1;\\n            return ans;\\n        }\\n        if(count1 % 3 != 0){\\n            ans[0] = -1;\\n            ans[1] = -1;\\n            return ans;\\n        }\\n        \\n        int part = count1 / 3;\\n        int i = 0; int j = 0; int k = 0;\\n        boolean flag1 = false, flag2 = false;\\n        int check1 = 0;\\n        for(int p = 0; p < n ; p++){\\n            if(arr[p] == 1){\\n                check1++;\\n            }\\n            if(check1 == 1 && !flag1){\\n                i = p;\\n                flag1 = true;\\n            }else if(check1 == part + 1 && !flag2){\\n                j = p;\\n                flag2 = true;\\n            }else if(check1 == 2 * part + 1){\\n                k = p;\\n                break;\\n            }\\n        }\\n        System.out.println(\"i: \" + i + \" j: \" + j + \" k: \" + k);\\n        int m = j, nn = k;\\n        while(k < n){\\n            if(arr[j] != arr[j] || arr[j] != arr[k] || i >= m || j >= nn){\\n                ans[0] = -1;\\n                ans[1] = -1;\\n                return ans; \\n            }\\n            i++;j++;k++;\\n        }\\n        //System.out.println(\"i: \" + i + \" j: \" + j + \" k: \" + k);\\n        ans[0] = i-1;\\n        ans[1] = j;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345867,
                "title": "java-binarysearch-presum-approach-concept-100-faster-and-96-8-less-space",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for Three Equal Parts.\\nMemory Usage: 43.5 MB, less than 96.08% of Java online submissions for Three Equal Parts.\\n\\n\\nHere i used a presum array i.e the countArray  to keep track of the number of one occured.And checked if the number of ones in the end is a multiple of 3 if yes the i will proceed  if not then i will return {-1,-1} as output and to handle the corner case when the array consist of no ones.\\n\\nNow we know in the 3 parts the number of 1\\'s should be equal so keeping that in mind and we know that 0 before a number does not change the value so we proceed backward.\\n\\nSuppose there are 21 ones in the array so i will search the 15th one position and substract one since i used a presum array of size one greater than the original array.\\nSo now i know the size of the array not containing precedding ones.i.e  arr.length-lastIndex i.e the 15th position in this case.\\n\\nSimilarly i will search the first occurence of the 1 in this array and substract -1.Now i will compare this\\nfirstOccurenceIndex(firstIndex) array with the lastIndex if its not equal i will return {-1,-1} output.\\nelse i will continue.\\n\\nNow the first and the last are equal and not i will search the starting position of the secondArray \\nand in this case also i will not consider preceeding 1.and i will find the position in countArray which is 7 and substract -1 to get the starting position of the secondArray.\\n\\nThen compare with the last array and if its equal and i will update the output and return it.\\n\\n\\nI think i may not be able to make it clear that well .If any one want to explain it easily then please so that it may be helpful to others.\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n     int [] countArray;\\n    public int findBinarySearchIndex(int x){\\n        int low=0;\\n        int high=countArray.length-1;\\n        int mid;\\n        while(low<high){\\n            mid=low+(high-low)/2;\\n            if(countArray[mid]>=x){\\n                high=mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n    public int[] threeEqualParts(int[] arr) {\\n        countArray=new int[arr.length+1];\\n        int [] output=new int[]{-1,-1};\\n        for(int i=0;i<arr.length;i++){\\n            countArray[i+1]=arr[i]+countArray[i];\\n        }\\n        if(countArray[countArray.length-1]%3!=0)\\n            return output;\\n        if(countArray[countArray.length-1]==0){\\n            output[0]=0;\\n            output[1]=arr.length-1;\\n            return output;\\n        }\\n       int lastIndex=findBinarySearchIndex((countArray[countArray.length-1]-(countArray[countArray.length-1]/3))+1)-1;\\n        int firstIndex=findBinarySearchIndex(1)-1; \\n        for(int i=0;i<arr.length-lastIndex;i++){\\n            if(arr[i+firstIndex]!=arr[i+lastIndex]){\\n                return output;\\n            }\\n    \\n        }\\n        int secondIndex=findBinarySearchIndex((countArray[countArray.length-1]/3)+1)-1;\\n        for(int i=0;i<arr.length-lastIndex;i++){\\n            if(arr[i+secondIndex]!=arr[i+lastIndex]){\\n                return output;\\n            }\\n        }\\n        output[0]=firstIndex+(arr.length-lastIndex)-1;\\n        output[1]=secondIndex+arr.length-lastIndex;\\n         return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     int [] countArray;\\n    public int findBinarySearchIndex(int x){\\n        int low=0;\\n        int high=countArray.length-1;\\n        int mid;\\n        while(low<high){\\n            mid=low+(high-low)/2;\\n            if(countArray[mid]>=x){\\n                high=mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n    public int[] threeEqualParts(int[] arr) {\\n        countArray=new int[arr.length+1];\\n        int [] output=new int[]{-1,-1};\\n        for(int i=0;i<arr.length;i++){\\n            countArray[i+1]=arr[i]+countArray[i];\\n        }\\n        if(countArray[countArray.length-1]%3!=0)\\n            return output;\\n        if(countArray[countArray.length-1]==0){\\n            output[0]=0;\\n            output[1]=arr.length-1;\\n            return output;\\n        }\\n       int lastIndex=findBinarySearchIndex((countArray[countArray.length-1]-(countArray[countArray.length-1]/3))+1)-1;\\n        int firstIndex=findBinarySearchIndex(1)-1; \\n        for(int i=0;i<arr.length-lastIndex;i++){\\n            if(arr[i+firstIndex]!=arr[i+lastIndex]){\\n                return output;\\n            }\\n    \\n        }\\n        int secondIndex=findBinarySearchIndex((countArray[countArray.length-1]/3)+1)-1;\\n        for(int i=0;i<arr.length-lastIndex;i++){\\n            if(arr[i+secondIndex]!=arr[i+lastIndex]){\\n                return output;\\n            }\\n        }\\n        output[0]=firstIndex+(arr.length-lastIndex)-1;\\n        output[1]=secondIndex+arr.length-lastIndex;\\n         return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345509,
                "title": "python-o-n-solution",
                "content": "Python:\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        # count number of ones\\n        sum_ = sum(arr)\\n        \\n        # number of ones should be divisible by 3 to be in 3 equal parts\\n        if sum_ % 3:\\n            return [-1, -1]\\n        \\n        # number of ones needed in each part\\n        ones = sum_ // 3\\n        \\n        # if all are zeros, any parition is okay\\n        if ones == 0:\\n            return [0, len(arr) - 1]\\n        \\n        \\n        indices = []\\n        \\n        \\n        #counting number of ones till a point in array\\n        curOnes = 0\\n        for i in range(len(arr)):\\n            if not arr[i]:\\n                continue\\n            curOnes += 1\\n            # if we reach a valid patition\\'s left point\\n            if curOnes in {1, ones + 1, 2 * ones + 1}:\\n                indices.append(i)\\n            # if we reach a valid parition\\'s right point\\n            if curOnes in {ones, 2 * ones, 3 * ones}:\\n                indices.append(i)\\n            \\n        # all points for all parititions\\n        # first - f1, f2\\n        # second - s1, s2\\n        # third - t1, t2\\n        f1, f2, s1, s2, t1, t2 = indices\\n        \\n        # if parititions are not equal, not valid\\n        if arr[f1: f2 + 1] != arr[s1: s2 + 1] or arr[f1: f2 + 1] != arr[t1: t2 + 1]:\\n            return [-1, -1]\\n        \\n        # zeros after each parition\\n        zerosAfterFirst = s1 - f2 - 1\\n        zerosAfterSecond = t1 - s2 - 1\\n        zerosAfterThird = len(arr) - t2 - 1\\n        \\n        # first and second paritions cannot have fewer following zeros than third\\n        if zerosAfterFirst < zerosAfterThird or zerosAfterSecond < zerosAfterThird:\\n            return [-1, -1]\\n        \\n        # add needed zeros to first and second partitions right points\\n        f2 += zerosAfterThird\\n        s2 += zerosAfterThird\\n        \\n        # return valid limits\\n        return [f2, s2 + 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        # count number of ones\\n        sum_ = sum(arr)\\n        \\n        # number of ones should be divisible by 3 to be in 3 equal parts\\n        if sum_ % 3:\\n            return [-1, -1]\\n        \\n        # number of ones needed in each part\\n        ones = sum_ // 3\\n        \\n        # if all are zeros, any parition is okay\\n        if ones == 0:\\n            return [0, len(arr) - 1]\\n        \\n        \\n        indices = []\\n        \\n        \\n        #counting number of ones till a point in array\\n        curOnes = 0\\n        for i in range(len(arr)):\\n            if not arr[i]:\\n                continue\\n            curOnes += 1\\n            # if we reach a valid patition\\'s left point\\n            if curOnes in {1, ones + 1, 2 * ones + 1}:\\n                indices.append(i)\\n            # if we reach a valid parition\\'s right point\\n            if curOnes in {ones, 2 * ones, 3 * ones}:\\n                indices.append(i)\\n            \\n        # all points for all parititions\\n        # first - f1, f2\\n        # second - s1, s2\\n        # third - t1, t2\\n        f1, f2, s1, s2, t1, t2 = indices\\n        \\n        # if parititions are not equal, not valid\\n        if arr[f1: f2 + 1] != arr[s1: s2 + 1] or arr[f1: f2 + 1] != arr[t1: t2 + 1]:\\n            return [-1, -1]\\n        \\n        # zeros after each parition\\n        zerosAfterFirst = s1 - f2 - 1\\n        zerosAfterSecond = t1 - s2 - 1\\n        zerosAfterThird = len(arr) - t2 - 1\\n        \\n        # first and second paritions cannot have fewer following zeros than third\\n        if zerosAfterFirst < zerosAfterThird or zerosAfterSecond < zerosAfterThird:\\n            return [-1, -1]\\n        \\n        # add needed zeros to first and second partitions right points\\n        f2 += zerosAfterThird\\n        s2 += zerosAfterThird\\n        \\n        # return valid limits\\n        return [f2, s2 + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345460,
                "title": "c-easy-solution-with-bitset",
                "content": "```\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> output;\\n\\n        int left = 0;\\n        int right = arr.size() - 1;\\n\\n        bitset<30001> parts1(arr[0]);\\n        bitset<30001> parts2;\\n        bitset<30001> parts3(arr[arr.size()-1]);\\n\\n        int bitIndex = right-2;\\n        for (int i = left + 1; i < right; ++i) {\\n            parts2.set(bitIndex, arr[i]);\\n            --bitIndex;\\n        }\\n        int part2Cnt = arr.size() - 3;\\n\\n        while (left < right-2) {\\n\\n            if(parts1 == parts3){\\n                if (parts1 == parts2) {\\n                    output.push_back(left);\\n                    output.push_back(right);\\n                    return output;\\n                }\\n                else {\\n                    --right;\\n                    parts3.set(arr.size() - right - 1, arr[right]);\\n                    parts2 = parts2 >> 1;\\n                }\\n            } else if (parts1.count() <= parts3.count()) {\\n                ++left;\\n                parts1 = parts1 << 1;\\n                parts1.set(0, arr[left]);\\n                parts2 = parts2.set(part2Cnt, false);\\n            } else {\\n                --right;\\n                parts3.set(arr.size() - right - 1, arr[right]);\\n                parts2 = parts2 >> 1;\\n            }\\n\\n            --part2Cnt;\\n        }\\n\\n        if (parts1 == parts2 && parts1 == parts3) {\\n            output.push_back(left);\\n            output.push_back(right);\\n            return output;\\n        }\\n\\n        output.push_back(-1);\\n        output.push_back(-1);\\n        return output;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> output;\\n\\n        int left = 0;\\n        int right = arr.size() - 1;\\n\\n        bitset<30001> parts1(arr[0]);\\n        bitset<30001> parts2;\\n        bitset<30001> parts3(arr[arr.size()-1]);\\n\\n        int bitIndex = right-2;\\n        for (int i = left + 1; i < right; ++i) {\\n            parts2.set(bitIndex, arr[i]);\\n            --bitIndex;\\n        }\\n        int part2Cnt = arr.size() - 3;\\n\\n        while (left < right-2) {\\n\\n            if(parts1 == parts3){\\n                if (parts1 == parts2) {\\n                    output.push_back(left);\\n                    output.push_back(right);\\n                    return output;\\n                }\\n                else {\\n                    --right;\\n                    parts3.set(arr.size() - right - 1, arr[right]);\\n                    parts2 = parts2 >> 1;\\n                }\\n            } else if (parts1.count() <= parts3.count()) {\\n                ++left;\\n                parts1 = parts1 << 1;\\n                parts1.set(0, arr[left]);\\n                parts2 = parts2.set(part2Cnt, false);\\n            } else {\\n                --right;\\n                parts3.set(arr.size() - right - 1, arr[right]);\\n                parts2 = parts2 >> 1;\\n            }\\n\\n            --part2Cnt;\\n        }\\n\\n        if (parts1 == parts2 && parts1 == parts3) {\\n            output.push_back(left);\\n            output.push_back(right);\\n            return output;\\n        }\\n\\n        output.push_back(-1);\\n        output.push_back(-1);\\n        return output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345396,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        auto ones = 0;\\n        for(auto bit: arr)\\n            ones+=(bit)?1:0;\\n        if (ones==0) return {0, (int)arr.size()-1};\\n        if (ones%3!=0) return {-1, -1};\\n        int count = 0;\\n        int pos[3][2] = {};\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if (arr[i]==0) continue;\\n            count++;\\n            if (count == 1) pos[0][0] = i;\\n            if (count==ones/3) pos[0][1] = i;\\n            if (count == ones/3+1) pos[1][0] = i;\\n            if (count==ones-ones/3) pos[1][1] = i;\\n            if (count == ones-ones/3+1) pos[2][0] = i;\\n            if (count==ones) pos[2][1] = i;\\n        }\\n        if ((pos[0][1] - pos[0][0]) !=(pos[1][1] - pos[1][0]))\\n            return {-1, -1};\\n        if ((pos[0][1] - pos[0][0]) !=(pos[2][1] - pos[2][0]))\\n            return {-1, -1};\\n        int n = pos[0][1] - pos[0][0]; \\n        for(int i=0;i<=n;i++)\\n        {\\n            if (arr[pos[0][0]+i]!=arr[pos[1][0]+i])  return {-1, -1};\\n            if (arr[pos[0][0]+i]!=arr[pos[2][0]+i])  return {-1, -1};\\n            \\n        }\\n        int postZeros = arr.size()-pos[2][1]-1;\\n        \\n        int end = pos[1][1]+postZeros+1;\\n        if (end>pos[2][0]) return  {-1, -1};\\n        int start =  pos[0][1]+postZeros;\\n        if (start>=pos[1][0]) return  {-1, -1};\\n        \\n        return {start, end};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        auto ones = 0;\\n        for(auto bit: arr)\\n            ones+=(bit)?1:0;\\n        if (ones==0) return {0, (int)arr.size()-1};\\n        if (ones%3!=0) return {-1, -1};\\n        int count = 0;\\n        int pos[3][2] = {};\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if (arr[i]==0) continue;\\n            count++;\\n            if (count == 1) pos[0][0] = i;\\n            if (count==ones/3) pos[0][1] = i;\\n            if (count == ones/3+1) pos[1][0] = i;\\n            if (count==ones-ones/3) pos[1][1] = i;\\n            if (count == ones-ones/3+1) pos[2][0] = i;\\n            if (count==ones) pos[2][1] = i;\\n        }\\n        if ((pos[0][1] - pos[0][0]) !=(pos[1][1] - pos[1][0]))\\n            return {-1, -1};\\n        if ((pos[0][1] - pos[0][0]) !=(pos[2][1] - pos[2][0]))\\n            return {-1, -1};\\n        int n = pos[0][1] - pos[0][0]; \\n        for(int i=0;i<=n;i++)\\n        {\\n            if (arr[pos[0][0]+i]!=arr[pos[1][0]+i])  return {-1, -1};\\n            if (arr[pos[0][0]+i]!=arr[pos[2][0]+i])  return {-1, -1};\\n            \\n        }\\n        int postZeros = arr.size()-pos[2][1]-1;\\n        \\n        int end = pos[1][1]+postZeros+1;\\n        if (end>pos[2][0]) return  {-1, -1};\\n        int start =  pos[0][1]+postZeros;\\n        if (start>=pos[1][0]) return  {-1, -1};\\n        \\n        return {start, end};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345330,
                "title": "c-o-n-without-counting-number-of-ones-explained-with-comments",
                "content": "Idea: For every possible i, we compute j dynamically.\\ndivided the 3 parts as A, B and C.\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(vector<int>& arr, int i, int j, int fNZA, int fNZB, int fNZC) {\\n        int a = fNZA, b = fNZB, c =fNZC;\\n        int x = i, y =j-1, z = arr.size()-1;\\n        while(a <= x) { //here \\'=\\' is needed if the size of the Component\\'s of A, B, C is 1.\\n            if(arr[a] != arr[b] || arr[b]!= arr[c] || arr[x]!= arr[y] || arr[y]!= arr[z])\\n                return false;\\n            a++;b++;c++;--x;--y;--z;\\n        }\\n        return true;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int i=0, j=i+1, n = arr.size();;\\n        int firstNonZeroIndexOfA=0, firstNonZeroIndexOfB=0, firstNonZeroIndexOfC=0;\\n\\t\\t\\n\\t\\t//While reading the code first time ignore this piece.\\n        /*vector<int> countOnes(n, 0);\\n        countOnes[0] = arr[0];\\n        for(int k=1; k<n; ++k) {\\n            if(arr[k]) countOnes[k] = 1+countOnes[k-1];\\n            else countOnes[k] = countOnes[k-1];\\n        }*/\\n\\t\\t\\n        for(;i <= n-3; ++i) {\\n\\t\\t\\t//Compute 1st index in A where element value is one, if all elements in A is zero, firstNonZeroIndexOfA = i;\\n            while(firstNonZeroIndexOfA<i && arr[firstNonZeroIndexOfA] == 0) firstNonZeroIndexOfA++;\\n\\t\\t\\t\\n\\t\\t\\t//Compute 1st index in B where element value is one, if all elements in B is zero, firstNonZeroIndexOfB = n-2;\\n            if(firstNonZeroIndexOfB < i+1)  firstNonZeroIndexOfB = i+1;\\n            while(firstNonZeroIndexOfB<n-2 && arr[firstNonZeroIndexOfB] == 0) firstNonZeroIndexOfB++;\\n            \\n\\t\\t\\t//Now we have to compute \\'j\\' such that, j-firstNonZeroIndexOfB == i-firstNonZeroIndexOfA+1\\n            j = i+firstNonZeroIndexOfB - firstNonZeroIndexOfA +1;\\n            if(j>=n) continue; // if no such \\'j\\' exists\\n\\n\\t\\t\\t//similarly we have to compute firstNonZeroIndexC in component C.\\n            if(firstNonZeroIndexOfC < j)  firstNonZeroIndexOfC = j;\\n            while(firstNonZeroIndexOfC<n-1 && arr[firstNonZeroIndexOfC] == 0) firstNonZeroIndexOfC++;\\n            \\n\\t\\t\\t//size of A = size of B already, now Size of C should be equal to size of B.\\n            if(n-firstNonZeroIndexOfC != j-firstNonZeroIndexOfB) continue;\\n          \\n            //if(countOnes[i] == countOnes[j-1]-countOnes[i] && countOnes[i] == countOnes[n-1] - countOnes[j-1])\\n            if(isMatch(arr, i, j, firstNonZeroIndexOfA, firstNonZeroIndexOfB, firstNonZeroIndexOfC))\\n                return {i, j};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n```\\n\\nTime Complexity: \\n\\t\\tThe Amortized time complexity for the three while loops inside the for loops is O(n), as they are not getting initialized everytime, In worst case firstNonZeroIndexOfA grows from 0 to n-3, firstNonZeroIndexOfB grows from 1 to n-2, firstNonZeroIndexOfC grows from 2 to n-1.\\n\\nMore Optimization:\\n\\t\\tBy counting no.of 1\\'s and adding more restriction before calling \\'isMatch\\' function, check my commented code.\\n\\nThis soultion(without counting ones) beated 98.15% c++ solutions with 28ms.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(vector<int>& arr, int i, int j, int fNZA, int fNZB, int fNZC) {\\n        int a = fNZA, b = fNZB, c =fNZC;\\n        int x = i, y =j-1, z = arr.size()-1;\\n        while(a <= x) { //here \\'=\\' is needed if the size of the Component\\'s of A, B, C is 1.\\n            if(arr[a] != arr[b] || arr[b]!= arr[c] || arr[x]!= arr[y] || arr[y]!= arr[z])\\n                return false;\\n            a++;b++;c++;--x;--y;--z;\\n        }\\n        return true;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int i=0, j=i+1, n = arr.size();;\\n        int firstNonZeroIndexOfA=0, firstNonZeroIndexOfB=0, firstNonZeroIndexOfC=0;\\n\\t\\t\\n\\t\\t//While reading the code first time ignore this piece.\\n        /*vector<int> countOnes(n, 0);\\n        countOnes[0] = arr[0];\\n        for(int k=1; k<n; ++k) {\\n            if(arr[k]) countOnes[k] = 1+countOnes[k-1];\\n            else countOnes[k] = countOnes[k-1];\\n        }*/\\n\\t\\t\\n        for(;i <= n-3; ++i) {\\n\\t\\t\\t//Compute 1st index in A where element value is one, if all elements in A is zero, firstNonZeroIndexOfA = i;\\n            while(firstNonZeroIndexOfA<i && arr[firstNonZeroIndexOfA] == 0) firstNonZeroIndexOfA++;\\n\\t\\t\\t\\n\\t\\t\\t//Compute 1st index in B where element value is one, if all elements in B is zero, firstNonZeroIndexOfB = n-2;\\n            if(firstNonZeroIndexOfB < i+1)  firstNonZeroIndexOfB = i+1;\\n            while(firstNonZeroIndexOfB<n-2 && arr[firstNonZeroIndexOfB] == 0) firstNonZeroIndexOfB++;\\n            \\n\\t\\t\\t//Now we have to compute \\'j\\' such that, j-firstNonZeroIndexOfB == i-firstNonZeroIndexOfA+1\\n            j = i+firstNonZeroIndexOfB - firstNonZeroIndexOfA +1;\\n            if(j>=n) continue; // if no such \\'j\\' exists\\n\\n\\t\\t\\t//similarly we have to compute firstNonZeroIndexC in component C.\\n            if(firstNonZeroIndexOfC < j)  firstNonZeroIndexOfC = j;\\n            while(firstNonZeroIndexOfC<n-1 && arr[firstNonZeroIndexOfC] == 0) firstNonZeroIndexOfC++;\\n            \\n\\t\\t\\t//size of A = size of B already, now Size of C should be equal to size of B.\\n            if(n-firstNonZeroIndexOfC != j-firstNonZeroIndexOfB) continue;\\n          \\n            //if(countOnes[i] == countOnes[j-1]-countOnes[i] && countOnes[i] == countOnes[n-1] - countOnes[j-1])\\n            if(isMatch(arr, i, j, firstNonZeroIndexOfA, firstNonZeroIndexOfB, firstNonZeroIndexOfC))\\n                return {i, j};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345310,
                "title": "java-simple-code-with-explanation",
                "content": "**OBSERVATIONS:**\\n\\nBy seeing the question itself and traversing through the example test cases, you\\'ll have couple of observations like:\\n1. If the number of 1\\'s in the array is not multiple of 3, then there is no way it can be equally partioned. Hence, we need to return *{-1, -1}*\\n2. Leading `0\\'s` won\\'t contribute towards the binary number hence can be ignored, and we need to look for very first `1\\'s` for building the algorithm.\\n\\n**CODE:**\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;\\n        List<Integer> ones = new ArrayList<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) {\\n                ones.add(i);\\n            }\\n        }\\n        \\n        int countOfOne = ones.size();\\n        \\n        // when all the element of an array is ZERO\\n        if (countOfOne == 0) {\\n            return new int[] {0, n - 1};\\n        }\\n        \\n        // when number of 1\\'s is not in multiple of 3\\n        if (countOfOne % 3 != 0) {\\n            return new int [] {-1, -1};\\n        }\\n        \\n        int ptr1 = ones.get(0); // index of first 1 in first part\\n        int ptr2 = ones.get(countOfOne / 3); // index of first 1 in second part\\n        int ptr3 = ones.get(2 * (countOfOne / 3)); // index of first 1 in third part\\n        \\n                \\n        while (ptr3 < n) {\\n            if (arr[ptr3] == arr[ptr2] && arr[ptr3] == arr[ptr1]) {\\n                ptr1++;\\n                ptr2++;\\n                ptr3++;\\n            } else {\\n                return new int [] {-1, -1};\\n            }\\n        }\\n        \\n        return new int [] {ptr1 - 1, ptr2};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;\\n        List<Integer> ones = new ArrayList<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) {\\n                ones.add(i);\\n            }\\n        }\\n        \\n        int countOfOne = ones.size();\\n        \\n        // when all the element of an array is ZERO\\n        if (countOfOne == 0) {\\n            return new int[] {0, n - 1};\\n        }\\n        \\n        // when number of 1\\'s is not in multiple of 3\\n        if (countOfOne % 3 != 0) {\\n            return new int [] {-1, -1};\\n        }\\n        \\n        int ptr1 = ones.get(0); // index of first 1 in first part\\n        int ptr2 = ones.get(countOfOne / 3); // index of first 1 in second part\\n        int ptr3 = ones.get(2 * (countOfOne / 3)); // index of first 1 in third part\\n        \\n                \\n        while (ptr3 < n) {\\n            if (arr[ptr3] == arr[ptr2] && arr[ptr3] == arr[ptr1]) {\\n                ptr1++;\\n                ptr2++;\\n                ptr3++;\\n            } else {\\n                return new int [] {-1, -1};\\n            }\\n        }\\n        \\n        return new int [] {ptr1 - 1, ptr2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345287,
                "title": "c-long-but-easy-implementation-explained",
                "content": "The problem looks complicated, but actually very simple.\\n1. count number of 1s.\\n2. If they are 0, return 0, size-1.\\n3. If number of 1s are not divisible by 3, return -1, -1.\\n4. Convert array numbers to string for easy manipulation.\\n5. Start from end, extract string by counting number of 1s that are needed. Reverse it. This is our universal string that we will search two more times.\\n6. Now, start from beginning, generate substring from 0 to i+1 position and search universal string.\\n7. If index is -1, return -1, -1.\\n8. Otherwise, generate another sunstring from index+universal string size to i+1.\\n9. search for universal string in this new substring.\\n10. If index is -1, return -1, -1.\\n11. else find the difference where the universal string ends in this substring. We need to subtract this difference from i+1 position to get our j.\\n12. our i would be initial index+universal string size -1.\\n13. Print some statements in below code to understand more.\\n```\\nvector<int> threeEqualParts(vector<int>& arr) {\\n        int i,j, size, diff, count1s=0,need1s=0;\\n        string str, s, s1, s2;\\n        vector<int> vec;\\n        size = arr.size();\\n       \\n        for(i=0; i<size; i++)\\n        {\\n            if(arr[i]==1)\\n                count1s++;\\n            str.push_back(arr[i]+\\'0\\');\\n        }\\n        if(count1s == 0)\\n            return {0, size-1};\\n        if(count1s%3!=0)\\n            return {-1,-1};\\n        else\\n            need1s = count1s/3;\\n        \\n        count1s=0;\\n        i= size-1;\\n        while(count1s!=need1s)\\n        {\\n            if(arr[i]==1)\\n                count1s++;\\n            s.push_back(arr[i]+\\'0\\');\\n            i--;\\n        }\\n        reverse(s.begin(), s.end());\\n      \\n        s1 = str.substr(0, i+1);\\n        auto index0 = s1.find(s);\\n        if(index0 == -1)\\n            return {-1, -1};\\n        s2 = s1.substr(index0+s.size(), i+1);\\n        auto index1 = s2.find(s);\\n         if(index1 == -1)\\n            return {-1, -1};\\n        diff = s2.size()-(index1+s.size());\\n\\n        vec.push_back(index0+s.size()-1);\\n        vec.push_back(i+1-diff);\\n        return vec;\\n    }\\n```\\nPlease UPVOTE if my approach helped you understand.",
                "solutionTags": [
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nvector<int> threeEqualParts(vector<int>& arr) {\\n        int i,j, size, diff, count1s=0,need1s=0;\\n        string str, s, s1, s2;\\n        vector<int> vec;\\n        size = arr.size();\\n       \\n        for(i=0; i<size; i++)\\n        {\\n            if(arr[i]==1)\\n                count1s++;\\n            str.push_back(arr[i]+\\'0\\');\\n        }\\n        if(count1s == 0)\\n            return {0, size-1};\\n        if(count1s%3!=0)\\n            return {-1,-1};\\n        else\\n            need1s = count1s/3;\\n        \\n        count1s=0;\\n        i= size-1;\\n        while(count1s!=need1s)\\n        {\\n            if(arr[i]==1)\\n                count1s++;\\n            s.push_back(arr[i]+\\'0\\');\\n            i--;\\n        }\\n        reverse(s.begin(), s.end());\\n      \\n        s1 = str.substr(0, i+1);\\n        auto index0 = s1.find(s);\\n        if(index0 == -1)\\n            return {-1, -1};\\n        s2 = s1.substr(index0+s.size(), i+1);\\n        auto index1 = s2.find(s);\\n         if(index1 == -1)\\n            return {-1, -1};\\n        diff = s2.size()-(index1+s.size());\\n\\n        vec.push_back(index0+s.size()-1);\\n        vec.push_back(i+1-diff);\\n        return vec;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345229,
                "title": "cpp-t-o-n",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sum1 = 0;\\n        for(int i : arr) sum1 += i;\\n        if(!sum1) return {0,2};\\n        else if(sum1 % 3 !=  0) return {-1,-1};\\n        \\n        int i0,i1,i2;\\n        i0 = i1 = i2 = -1;\\n        int partsum = sum1 / 3;\\n        int t1 = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] == 1){\\n                t1++;\\n                if(t1 == 1){\\n                    i0 = i; // find the first one\\n                }\\n                else if(t1 == partsum + 1){\\n                    i1 = i; // find the second one\\n                }\\n                else if(t1 == partsum * 2 + 1){\\n                    i2 = i; // find the third one\\n                }\\n            }\\n        }\\n        while(i2 < arr.size()) { // compare all one\\n            if(arr[i0] == arr[i2] && arr[i0] == arr[i1]){\\n                i0++;\\n                i1++;\\n                i2++;\\n            }\\n            else return {-1,-1};\\n        }\\n        return {i0-1,i1};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sum1 = 0;\\n        for(int i : arr) sum1 += i;\\n        if(!sum1) return {0,2}",
                "codeTag": "Java"
            },
            {
                "id": 1345212,
                "title": "java-solution-with-comments",
                "content": "```\\n\\nimport java.util.*;\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;                                                         // Get the length of the array\\n        List<Integer> indexesOfOnes = new Vector<Integer>();                        // Take a list to store the indexes of ones in the array\\n        for(int i = 0; i < n; i++){                                                 // Traverse the array and check for ones\\n            if(arr[i] == 1){                                                        // If the ith index is 1, then add \\'i\\' to the vector\\n                indexesOfOnes.add(i);\\n            }\\n        }\\n        int numOfOnes = indexesOfOnes.size();                                       // Get the size of the list, i.e., the total no. of 1\\'s\\n        \\n        if(numOfOnes%3 != 0)                                                        // If the total no. of 1\\'s is not divisible by 3\\n            return new int[]{-1, -1};                                               // Then, no 3 equal partition is possible\\n        \\n        if(numOfOnes == 0)                                                          // If no 1 is present in the array\\n            return new int[]{0, n-1};                                               // Then, 3 equal partition of 0\\'s is possible\\n        \\n        int indexDist = numOfOnes/3;                                                // Else, get the avg. index distance between the ones\\n        \\n        int first  = indexesOfOnes.get(0);                                          // Now, from the list, get the index of the 1st 1 for the 1st partition\\n        int second = indexesOfOnes.get(indexDist);                                  // Get the index of the 1 at index \\'indexDist\\' for the 2nd partition\\n        int third  = indexesOfOnes.get(indexDist*2);                                // And get index of the 1 at index \\'2*indexDist\\' for the 3rd partition\\n        \\n        while(third < n && arr[first] == arr[second] && arr[first] == arr[third]){  // Run a loop while the elements are equal in each part and \\'third\\' is less than \\'n\\'\\n            first++;                                                                // Keep increasing the value of \\'first\\'\\n            second++;                                                               // Keep increasing the value of \\'second\\'\\n            third++;                                                                // And, keep increasing the value of \\'third\\'\\n        }\\n        \\n        if(third == n)                                                              // Check if \\'third\\' has reached the end or not\\n            return new int[]{first-1, second};                                      // If Yes, then all the partitions were equal; so return \\'first-1\\' & \\'second\\' as the indexes\\n        \\n        return new int[]{-1, -1};                                                   // Else, the 3 partitions were not equal; so return {-1, -1}\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nimport java.util.*;\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;                                                         // Get the length of the array\\n        List<Integer> indexesOfOnes = new Vector<Integer>();                        // Take a list to store the indexes of ones in the array\\n        for(int i = 0; i < n; i++){                                                 // Traverse the array and check for ones\\n            if(arr[i] == 1){                                                        // If the ith index is 1, then add \\'i\\' to the vector\\n                indexesOfOnes.add(i);\\n            }\\n        }\\n        int numOfOnes = indexesOfOnes.size();                                       // Get the size of the list, i.e., the total no. of 1\\'s\\n        \\n        if(numOfOnes%3 != 0)                                                        // If the total no. of 1\\'s is not divisible by 3\\n            return new int[]{-1, -1};                                               // Then, no 3 equal partition is possible\\n        \\n        if(numOfOnes == 0)                                                          // If no 1 is present in the array\\n            return new int[]{0, n-1};                                               // Then, 3 equal partition of 0\\'s is possible\\n        \\n        int indexDist = numOfOnes/3;                                                // Else, get the avg. index distance between the ones\\n        \\n        int first  = indexesOfOnes.get(0);                                          // Now, from the list, get the index of the 1st 1 for the 1st partition\\n        int second = indexesOfOnes.get(indexDist);                                  // Get the index of the 1 at index \\'indexDist\\' for the 2nd partition\\n        int third  = indexesOfOnes.get(indexDist*2);                                // And get index of the 1 at index \\'2*indexDist\\' for the 3rd partition\\n        \\n        while(third < n && arr[first] == arr[second] && arr[first] == arr[third]){  // Run a loop while the elements are equal in each part and \\'third\\' is less than \\'n\\'\\n            first++;                                                                // Keep increasing the value of \\'first\\'\\n            second++;                                                               // Keep increasing the value of \\'second\\'\\n            third++;                                                                // And, keep increasing the value of \\'third\\'\\n        }\\n        \\n        if(third == n)                                                              // Check if \\'third\\' has reached the end or not\\n            return new int[]{first-1, second};                                      // If Yes, then all the partitions were equal; so return \\'first-1\\' & \\'second\\' as the indexes\\n        \\n        return new int[]{-1, -1};                                                   // Else, the 3 partitions were not equal; so return {-1, -1}\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345173,
                "title": "three-equal-parts-java-explanatory-comments",
                "content": "```\\n\\nimport java.util.*;\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;                                                         // Get the length of the array\\n        List<Integer> indexesOfOnes = new Vector<Integer>();                        // Take a list to store the indexes of ones in the array\\n        for(int i = 0; i < n; i++){                                                 // Traverse the array and check for ones\\n            if(arr[i] == 1){                                                        // If the ith index is 1, then add \\'i\\' to the vector\\n                indexesOfOnes.add(i);\\n            }\\n        }\\n        int numOfOnes = indexesOfOnes.size();                                       // Get the size of the list, i.e., the total no. of 1\\'s\\n        \\n        if(numOfOnes%3 != 0)                                                        // If the total no. of 1\\'s is not divisible by 3\\n            return new int[]{-1, -1};                                               // Then, no 3 equal partition is possible\\n        \\n        if(numOfOnes == 0)                                                          // If no 1 is present in the array\\n            return new int[]{0, n-1};                                               // Then, 3 equal partition of 0\\'s is possible\\n        \\n        int indexDist = numOfOnes/3;                                                // Else, get the avg. index distance between the ones\\n        \\n        int first  = indexesOfOnes.get(0);                                          // Now, from the list, get the index of the 1st 1 for the 1st partition\\n        int second = indexesOfOnes.get(indexDist);                                  // Get the index of the 1 at index \\'indexDist\\' for the 2nd partition\\n        int third  = indexesOfOnes.get(indexDist*2);                                // And get index of the 1 at index \\'2*indexDist\\' for the 3rd partition\\n        \\n        while(third < n && arr[first] == arr[second] && arr[first] == arr[third]){  // Run a loop while the elements are equal in each part and \\'third\\' is less than \\'n\\'\\n            first++;                                                                // Keep increasing the value of \\'first\\'\\n            second++;                                                               // Keep increasing the value of \\'second\\'\\n            third++;                                                                // And, keep increasing the value of \\'third\\'\\n        }\\n        \\n        if(third == n)                                                              // Check if \\'third\\' has reached the end or not\\n            return new int[]{first-1, second};                                      // If Yes, then all the partitions were equal; so return \\'first-1\\' & \\'second\\' as the indexes\\n        \\n        return new int[]{-1, -1};                                                   // Else, the 3 partitions were not equal; so return {-1, -1}\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nimport java.util.*;\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;                                                         // Get the length of the array\\n        List<Integer> indexesOfOnes = new Vector<Integer>();                        // Take a list to store the indexes of ones in the array\\n        for(int i = 0; i < n; i++){                                                 // Traverse the array and check for ones\\n            if(arr[i] == 1){                                                        // If the ith index is 1, then add \\'i\\' to the vector\\n                indexesOfOnes.add(i);\\n            }\\n        }\\n        int numOfOnes = indexesOfOnes.size();                                       // Get the size of the list, i.e., the total no. of 1\\'s\\n        \\n        if(numOfOnes%3 != 0)                                                        // If the total no. of 1\\'s is not divisible by 3\\n            return new int[]{-1, -1};                                               // Then, no 3 equal partition is possible\\n        \\n        if(numOfOnes == 0)                                                          // If no 1 is present in the array\\n            return new int[]{0, n-1};                                               // Then, 3 equal partition of 0\\'s is possible\\n        \\n        int indexDist = numOfOnes/3;                                                // Else, get the avg. index distance between the ones\\n        \\n        int first  = indexesOfOnes.get(0);                                          // Now, from the list, get the index of the 1st 1 for the 1st partition\\n        int second = indexesOfOnes.get(indexDist);                                  // Get the index of the 1 at index \\'indexDist\\' for the 2nd partition\\n        int third  = indexesOfOnes.get(indexDist*2);                                // And get index of the 1 at index \\'2*indexDist\\' for the 3rd partition\\n        \\n        while(third < n && arr[first] == arr[second] && arr[first] == arr[third]){  // Run a loop while the elements are equal in each part and \\'third\\' is less than \\'n\\'\\n            first++;                                                                // Keep increasing the value of \\'first\\'\\n            second++;                                                               // Keep increasing the value of \\'second\\'\\n            third++;                                                                // And, keep increasing the value of \\'third\\'\\n        }\\n        \\n        if(third == n)                                                              // Check if \\'third\\' has reached the end or not\\n            return new int[]{first-1, second};                                      // If Yes, then all the partitions were equal; so return \\'first-1\\' & \\'second\\' as the indexes\\n        \\n        return new int[]{-1, -1};                                                   // Else, the 3 partitions were not equal; so return {-1, -1}\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345119,
                "title": "simple-solution-no-storage-very-intuitive-o-n-time-with-o-1-space",
                "content": "The solution is very simple. We need to divide the array into three segments right? So, what comes to mind first?\\n\\nAaah, it makes sense that the number of ones must be a multiple of 3. Second, the last segment determines the binary equivalent we are looking for. So, find the first one in the last segment. For example, if this is the array [1,0,0,1,1,0,0,1,**1**,0,0,1]. The bold part will be the first one in the last segment. Finding it is simple. Traverse the aray from back and when you reach the expected number of ones, you break.\\n\\nNow, all you need to do is traverse the array from beginning and check if there are segments that are exactly similar to the last segment. That\\'s it. You are done!!!!\\n\\t\\n\\tdef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Perform segment check to see if the segments are same.\\n        def start_segment_check(i, last_one):\\n            while(last_one < n):\\n                if arr[i] != arr[last_one]:\\n                    return -1\\n                last_one += 1\\n                i += 1\\n            return 0\\n        \\n        # Preliminary checks.\\n        ones = 0\\n        n = len(arr)\\n        for num in arr:\\n            ones += num\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        if ones == 0:\\n            return [0, n - 1]\\n        \\n        # Find the first one in the last segment\\n        zeroes = n - ones\\n        first_one = -1\\n        expected_number_of_ones_in_segment = ones // 3\\n        curr_num_of_ones = 0\\n        \\n        for i in range(n - 1, -1, -1):\\n            if arr[i] == 1:\\n                curr_num_of_ones += 1\\n                if curr_num_of_ones > expected_number_of_ones_in_segment:\\n                    break\\n                #Setup for ones\\n                first_one = i\\n        \\n        # Perform checks\\n        i = 0\\n        retunr_i = -1\\n        return_j = -1\\n        while(i < first_one):\\n            if arr[i] == 1:\\n                j = start_segment_check(i, first_one)\\n                if j == -1:\\n                    return [-1, -1]\\n                i += n - first_one\\n                if retunr_i == -1:\\n                    retunr_i = i - 1\\n                else:\\n                    return_j = i\\n            else:\\n                i += 1\\n                \\n        \\n        return [retunr_i, return_j]\\n",
                "solutionTags": [],
                "code": "The solution is very simple. We need to divide the array into three segments right? So, what comes to mind first?\\n\\nAaah, it makes sense that the number of ones must be a multiple of 3. Second, the last segment determines the binary equivalent we are looking for. So, find the first one in the last segment. For example, if this is the array [1,0,0,1,1,0,0,1,**1**,0,0,1]. The bold part will be the first one in the last segment. Finding it is simple. Traverse the aray from back and when you reach the expected number of ones, you break.\\n\\nNow, all you need to do is traverse the array from beginning and check if there are segments that are exactly similar to the last segment. That\\'s it. You are done!!!!\\n\\t\\n\\tdef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Perform segment check to see if the segments are same.\\n        def start_segment_check(i, last_one):\\n            while(last_one < n):\\n                if arr[i] != arr[last_one]:\\n                    return -1\\n                last_one += 1\\n                i += 1\\n            return 0\\n        \\n        # Preliminary checks.\\n        ones = 0\\n        n = len(arr)\\n        for num in arr:\\n            ones += num\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        if ones == 0:\\n            return [0, n - 1]\\n        \\n        # Find the first one in the last segment\\n        zeroes = n - ones\\n        first_one = -1\\n        expected_number_of_ones_in_segment = ones // 3\\n        curr_num_of_ones = 0\\n        \\n        for i in range(n - 1, -1, -1):\\n            if arr[i] == 1:\\n                curr_num_of_ones += 1\\n                if curr_num_of_ones > expected_number_of_ones_in_segment:\\n                    break\\n                #Setup for ones\\n                first_one = i\\n        \\n        # Perform checks\\n        i = 0\\n        retunr_i = -1\\n        return_j = -1\\n        while(i < first_one):\\n            if arr[i] == 1:\\n                j = start_segment_check(i, first_one)\\n                if j == -1:\\n                    return [-1, -1]\\n                i += n - first_one\\n                if retunr_i == -1:\\n                    retunr_i = i - 1\\n                else:\\n                    return_j = i\\n            else:\\n                i += 1\\n                \\n        \\n        return [retunr_i, return_j]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1345054,
                "title": "simple-c-code-by-converting-array-to-string-explained",
                "content": "If count of all one is not divisible by 3 answer doesn\\'t exist. Just return {-1,-1} in this case.\\nOtherwise convert binary array to binary string. Iterate over string from last till you find one/3 ones. Let this index be \\'i\\'. So our pattern is string starting from \\'i\\' till end.\\nNow just search for this pattern in string using s.find(), and if you find two such patterns before index \\'i\\' than your answer may exist. \\nNote that, a pattern may have leading zeros as it doesn\\'t contribute towards any value in binary to decimal conversion. But between these patterns there can\\'t be any 1. So check for this and return your answer.\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        string s = \"\";\\n        int n=arr.size();\\n        int one=0;\\n        for(int i=0;i<n;i++){\\n            s += to_string(arr[i]);\\n            if(arr[i]==1)\\n                one++;\\n        }\\n        if(one==0){\\n            return {0,2};\\n        }\\n        if(one%3!=0)\\n            return {-1,-1};\\n        \\n        one = one/3;\\n        int i=n-1;\\n        int count=0;\\n        while(i>=0 and count<one){\\n            if(s[i]==\\'1\\')\\n                count++;\\n            i--;\\n        }\\n        i++;\\n        string pat = s.substr(i);\\n        int m = pat.length();\\n        int j = s.find(pat);\\n        int k = s.find(pat,j+m);\\n        if(j==-1 or k==-1)\\n            return {-1,-1};\\n        for(int l=0;l<j;l++){\\n           if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        for(int l=j+m;l<k;l++){\\n            if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        for(int l=k+m;l<i;l++){\\n            if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        \\n        return {j+m-1,k+m};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        string s = \"\";\\n        int n=arr.size();\\n        int one=0;\\n        for(int i=0;i<n;i++){\\n            s += to_string(arr[i]);\\n            if(arr[i]==1)\\n                one++;\\n        }\\n        if(one==0){\\n            return {0,2};\\n        }\\n        if(one%3!=0)\\n            return {-1,-1};\\n        \\n        one = one/3;\\n        int i=n-1;\\n        int count=0;\\n        while(i>=0 and count<one){\\n            if(s[i]==\\'1\\')\\n                count++;\\n            i--;\\n        }\\n        i++;\\n        string pat = s.substr(i);\\n        int m = pat.length();\\n        int j = s.find(pat);\\n        int k = s.find(pat,j+m);\\n        if(j==-1 or k==-1)\\n            return {-1,-1};\\n        for(int l=0;l<j;l++){\\n           if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        for(int l=j+m;l<k;l++){\\n            if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        for(int l=k+m;l<i;l++){\\n            if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        \\n        return {j+m-1,k+m};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344936,
                "title": "python3-prefix-sum-o-n",
                "content": "\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        MOD = 1_000_000_007\\n        total = 0 \\n        p2 = [1]\\n        for x in arr: \\n            total = (2*total + x) % MOD \\n            p2.append((p2[-1] << 1) % MOD)\\n        \\n        seen = {}\\n        prefix = 0\\n        for j, x in enumerate(arr): \\n            prefix = (2*prefix + x) % MOD\\n            diff = (total - prefix * p2[len(arr)-1-j]) % MOD \\n            if diff in seen:\\n                i = seen[diff]\\n                if diff == (prefix - diff * p2[j - i]) % MOD: return [i, j+1]\\n            seen[prefix] = j\\n        return [-1, -1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        MOD = 1_000_000_007\\n        total = 0 \\n        p2 = [1]\\n        for x in arr: \\n            total = (2*total + x) % MOD \\n            p2.append((p2[-1] << 1) % MOD)\\n        \\n        seen = {}\\n        prefix = 0\\n        for j, x in enumerate(arr): \\n            prefix = (2*prefix + x) % MOD\\n            diff = (total - prefix * p2[len(arr)-1-j]) % MOD \\n            if diff in seen:\\n                i = seen[diff]\\n                if diff == (prefix - diff * p2[j - i]) % MOD: return [i, j+1]\\n            seen[prefix] = j\\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344866,
                "title": "python-o-n-time-o-1-space-two-pointers",
                "content": "Use `i` to represent the ending index of the first part and `j` the starting index of the third part, where `i` and `j` are initialized as `0` and `len-1`. In each step, we either move `i` to the right or `j` to the left according to the relation among `left`, `mid` and `right` values. (Note that we can move `i` to the right without decreasing the `mid`, also we can move `j` to the left without increasing the `right`).\\n\\n```\\ndef threeEqualParts(arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        i, j = 0, n-1\\n        left = arr[0]\\n        right = arr[-1]\\n        mid = 0\\n        for k in range(j-1, i, -1):\\n            mid += (arr[k] << (j-1-k))\\n        while i < j - 1:\\n            if left == mid == right:\\n                return [i, j]\\n            if max(left, right) > mid or left == mid:\\n                return [-1, -1]\\n            if left >= right:\\n                j -= 1\\n                mid >>= 1\\n                right += (arr[j] << (n-1-j))\\n            else:\\n                i += 1\\n                left <<= 1\\n                left += arr[i]\\n                mid -= (arr[i] << (j-i-1))\\n        return [-1, -1]\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef threeEqualParts(arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        i, j = 0, n-1\\n        left = arr[0]\\n        right = arr[-1]\\n        mid = 0\\n        for k in range(j-1, i, -1):\\n            mid += (arr[k] << (j-1-k))\\n        while i < j - 1:\\n            if left == mid == right:\\n                return [i, j]\\n            if max(left, right) > mid or left == mid:\\n                return [-1, -1]\\n            if left >= right:\\n                j -= 1\\n                mid >>= 1\\n                right += (arr[j] << (n-1-j))\\n            else:\\n                i += 1\\n                left <<= 1\\n                left += arr[i]\\n                mid -= (arr[i] << (j-i-1))\\n        return [-1, -1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344836,
                "title": "c-o-n-time-no-extra-memory",
                "content": "```\\npublic class Solution {\\n    public int[] ThreeEqualParts(int[] arr) {\\n        int ones = arr.Sum(x => x == 1 ? 1 : 0);\\n        \\n        if(ones%3 != 0)\\n            return new int[] { -1, -1};\\n        if(ones == 0)\\n            return new int[] { 0, 2 };\\n        \\n        int p1 = -1, p2 = -1, p3 = -1, counter = 0, target = ones/3;\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                if(counter == 0)\\n                {\\n                    if(p1 == -1)\\n                        p1 = i;\\n                    else if(p2 == -1)\\n                        p2 = i;\\n                    else if(p3 == -1)\\n                    {\\n                        p3 = i;\\n                        break;\\n                    }\\n                }\\n                counter++;\\n                if(counter == target)\\n                    counter = 0;\\n            }\\n        }\\n        \\n        while(p3 < arr.Length)\\n        {\\n            if(arr[p1] != arr[p2] || arr[p2] != arr[p3])\\n                return new int[] { -1, -1 };\\n            p1++;p2++;p3++;\\n        } \\n        \\n        return new int[] { p1-1, p2 };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] ThreeEqualParts(int[] arr) {\\n        int ones = arr.Sum(x => x == 1 ? 1 : 0);\\n        \\n        if(ones%3 != 0)\\n            return new int[] { -1, -1};\\n        if(ones == 0)\\n            return new int[] { 0, 2 };\\n        \\n        int p1 = -1, p2 = -1, p3 = -1, counter = 0, target = ones/3;\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                if(counter == 0)\\n                {\\n                    if(p1 == -1)\\n                        p1 = i;\\n                    else if(p2 == -1)\\n                        p2 = i;\\n                    else if(p3 == -1)\\n                    {\\n                        p3 = i;\\n                        break;\\n                    }\\n                }\\n                counter++;\\n                if(counter == target)\\n                    counter = 0;\\n            }\\n        }\\n        \\n        while(p3 < arr.Length)\\n        {\\n            if(arr[p1] != arr[p2] || arr[p2] != arr[p3])\\n                return new int[] { -1, -1 };\\n            p1++;p2++;p3++;\\n        } \\n        \\n        return new int[] { p1-1, p2 };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344809,
                "title": "python3-compare-lengths-of-three-chunks-sol-for-reference",
                "content": "The idea is to compare the starting and ending chunks in length and decide if the middle chunk fits in comparision ( as in the three arrays are equal. )\\n\\nT & S = O(n)\\n\\nRuntime: 382 ms, faster than 56.99% of Python3 online submissions for Three Equal Parts.\\nMemory Usage: 16 MB, less than 8.60% of Python3 online submissions for Three Equal Parts.\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        indices = deque([])\\n        N = len(arr)\\n        ans = [-1,-1]\\n        \\n        ## collect all indices of 1\\n        for idx, val in enumerate(arr):\\n            if val: \\n                indices.append(idx)\\n                \\n        if not indices:\\n            return [0, N-1]\\n        \\n        if len(indices) %3 != 0: \\n            return [-1, -1]\\n    \\n        start = 0\\n        end = len(indices)-1\\n        \\n        s = indices[start]\\n        \\n        # if ending in zero, the right most part of 3 parts, should always be from end of middle chunk-until end of array\\n        endsInZero = (arr[-1] == 0)\\n        \\n        # s....index[start]...index[end]....#\\n        # chunk1 - starts with the first 1\\n        # chunk2 - start with chunk1 end + 1 or 1st one after chunk1 \\n        # chunk3 - start with chunk2+1 until end \\n        \\n        ## if the array ends in zero, then the calcuation should be from chunk1+len(last_chunk), chunk2+len(last_chunk) and its edge cases.  \\n        \\n        while start < end:\\n            if endsInZero:\\n                edge_len = N-1-indices[end]\\n                medge_index = min(indices[end], indices[start+1]+edge_len+1)\\n                ## Edge case, if between middle index edge and end if there are 1s\\n                medge_index = max(medge_index, indices[end-1])\\n                \\n                ## check if the lengths are equal, chunk1 and chunk3 have edge_len, hence only compare with middle.\\n                if medge_index - indices[start+1] == edge_len+1:\\n                    if arr[s:s+edge_len+1] == arr[indices[end]:]  == arr[indices[start+1]: medge_index]:\\n                        return (s+edge_len,medge_index)\\n            else:\\n                ## check if the lengths are equal\\n                if indices[start]-s ==  N-indices[end]-1 == indices[end-1]-indices[start+1]:\\n                    if arr[s:indices[start]+1] == arr[indices[end]:] == arr[indices[start+1]:indices[end-1]+1]:\\n                        return (indices[start],indices[end-1]+1)\\n                \\n            start += 1\\n            end -= 1\\n                    \\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The idea is to compare the starting and ending chunks in length and decide if the middle chunk fits in comparision ( as in the three arrays are equal. )\\n\\nT & S = O(n)\\n\\nRuntime: 382 ms, faster than 56.99% of Python3 online submissions for Three Equal Parts.\\nMemory Usage: 16 MB, less than 8.60% of Python3 online submissions for Three Equal Parts.\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        indices = deque([])\\n        N = len(arr)\\n        ans = [-1,-1]\\n        \\n        ## collect all indices of 1\\n        for idx, val in enumerate(arr):\\n            if val: \\n                indices.append(idx)\\n                \\n        if not indices:\\n            return [0, N-1]\\n        \\n        if len(indices) %3 != 0: \\n            return [-1, -1]\\n    \\n        start = 0\\n        end = len(indices)-1\\n        \\n        s = indices[start]\\n        \\n        # if ending in zero, the right most part of 3 parts, should always be from end of middle chunk-until end of array\\n        endsInZero = (arr[-1] == 0)\\n        \\n        # s....index[start]...index[end]....#\\n        # chunk1 - starts with the first 1\\n        # chunk2 - start with chunk1 end + 1 or 1st one after chunk1 \\n        # chunk3 - start with chunk2+1 until end \\n        \\n        ## if the array ends in zero, then the calcuation should be from chunk1+len(last_chunk), chunk2+len(last_chunk) and its edge cases.  \\n        \\n        while start < end:\\n            if endsInZero:\\n                edge_len = N-1-indices[end]\\n                medge_index = min(indices[end], indices[start+1]+edge_len+1)\\n                ## Edge case, if between middle index edge and end if there are 1s\\n                medge_index = max(medge_index, indices[end-1])\\n                \\n                ## check if the lengths are equal, chunk1 and chunk3 have edge_len, hence only compare with middle.\\n                if medge_index - indices[start+1] == edge_len+1:\\n                    if arr[s:s+edge_len+1] == arr[indices[end]:]  == arr[indices[start+1]: medge_index]:\\n                        return (s+edge_len,medge_index)\\n            else:\\n                ## check if the lengths are equal\\n                if indices[start]-s ==  N-indices[end]-1 == indices[end-1]-indices[start+1]:\\n                    if arr[s:indices[start]+1] == arr[indices[end]:] == arr[indices[start+1]:indices[end-1]+1]:\\n                        return (indices[start],indices[end-1]+1)\\n                \\n            start += 1\\n            end -= 1\\n                    \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1344774,
                "title": "java-o-n-solution-1ms-beats-100",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length, n_ones = 0; // total number of 1\\n        int[] ones = new int[n]; // record the index of 1\\n        int[] res = new int[] {-1 , -1}; \\n        \\n        for(int i = 0; i < n; i++){\\n            if(arr[i] == 1) {\\n                ones[n_ones++] = i; // get index of 1 and total number of 1\\n            }\\n        }\\n        \\n        if(n_ones % 3 != 0) return res; \\n        if(n_ones == 0) return new int[] {0, n - 1}; // the case where there is no 1\\n        \\n\\t\\t// check for each segment, if there are same number of 0 between two 1s\\n        for(int i = 1; i < n_ones / 3; i++){\\n            int spacing1 = ones[n_ones / 3 - i] - ones[n_ones / 3 - i - 1];\\n            int spacing2 = ones[n_ones / 3 * 2 - i] - ones[n_ones / 3 * 2 - i - 1];\\n            int spacing3 = ones[n_ones - i] - ones[n_ones - i - 1];\\n            if(spacing1 == spacing2 && spacing1 == spacing3) continue;\\n            else return res;\\n        }\\n        \\n\\t\\t\\n       int useful_zeros = n - 1 - ones[n_ones - 1]; // count the number of useful 0s before the least 1  for the last segment\\n       // check for the middle segment\\n\\t   if(ones[n_ones / 3 * 2] - ones[n_ones / 3 * 2 - 1] - 1 < useful_zeros){\\n            return res;\\n        }\\n       \\n\\t   // check for the first segment\\n        if(ones[n_ones / 3] - ones[n_ones / 3 - 1] - 1 >= useful_zeros){\\n            res[0] = ones[n_ones / 3 - 1] + useful_zeros;\\n            res[1] = ones[n_ones / 3 * 2 - 1] + useful_zeros + 1;\\n            return res;\\n        } else return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length, n_ones = 0; // total number of 1\\n        int[] ones = new int[n]; // record the index of 1\\n        int[] res = new int[] {-1 , -1}; \\n        \\n        for(int i = 0; i < n; i++){\\n            if(arr[i] == 1) {\\n                ones[n_ones++] = i; // get index of 1 and total number of 1\\n            }\\n        }\\n        \\n        if(n_ones % 3 != 0) return res; \\n        if(n_ones == 0) return new int[] {0, n - 1}; // the case where there is no 1\\n        \\n\\t\\t// check for each segment, if there are same number of 0 between two 1s\\n        for(int i = 1; i < n_ones / 3; i++){\\n            int spacing1 = ones[n_ones / 3 - i] - ones[n_ones / 3 - i - 1];\\n            int spacing2 = ones[n_ones / 3 * 2 - i] - ones[n_ones / 3 * 2 - i - 1];\\n            int spacing3 = ones[n_ones - i] - ones[n_ones - i - 1];\\n            if(spacing1 == spacing2 && spacing1 == spacing3) continue;\\n            else return res;\\n        }\\n        \\n\\t\\t\\n       int useful_zeros = n - 1 - ones[n_ones - 1]; // count the number of useful 0s before the least 1  for the last segment\\n       // check for the middle segment\\n\\t   if(ones[n_ones / 3 * 2] - ones[n_ones / 3 * 2 - 1] - 1 < useful_zeros){\\n            return res;\\n        }\\n       \\n\\t   // check for the first segment\\n        if(ones[n_ones / 3] - ones[n_ones / 3 - 1] - 1 >= useful_zeros){\\n            res[0] = ones[n_ones / 3 - 1] + useful_zeros;\\n            res[1] = ones[n_ones / 3 * 2 - 1] + useful_zeros + 1;\\n            return res;\\n        } else return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344765,
                "title": "python3-runtime-100-explained",
                "content": "To have three parts represent the same binary value, the array can be\\ndevided into following 6 parts.\\n```\\n0.........01x...x10...00.........01x...x10...00.........01x...x10...0\\n|- part1 -||- part2  -||- part3 -||- part4 - ||- part5 -||- part6  -|\\n```\\n\\nThe part1, part3, and part5 are all 0\\'s.\\nPart1 can be added to part2 without changing the represented binary value.\\nPart3 and part5 are similar.\\nPart2, part4 and part6 must be exactly same. They should start with 1, with\\nzero or some 0\\'s at the end.\\n\\nThe algorithm is to find part6 first, then skip all heading 0\\'s (i.e. part1),\\nuse length of part6 to find part2. And then skip 0\\'s (part3), use length of part6\\nto find part4.\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Find number of 1\\'s in the list\\n        n = arr.count(1)\\n        if n == 0: # No 1 found\\n            return [0, 2]\\n        # If number of 1\\'s cannot be mod by 3, the solution does not exist\\n        if n%3:\\n            return [-1, -1]\\n        m = n/3 # Number of 1\\'s each part should have\\n        \\n        # Find the starting point of part6 (must be 1)\\n        j = len(arr)\\n        while m > 0:\\n            j-=1\\n            if arr[j]:\\n                m-=1\\n                \\n        # Part6\\n        lastArr = arr[j:]\\n        length = len(lastArr)\\n        \\n        # Skip all heading 0\\'s\\n        i = 0\\n        while arr[i]==0:\\n            i += 1\\n            \\n        # Is part2 same as part6?\\n        if arr[i: i+length] != lastArr:\\n            return [-1, -1]\\n            \\n        # Got the first element of returning value\\n        i += length-1\\n        \\n        # Skip next consecutive 0\\'s (part3)\\n        k = i+1\\n        while arr[k] == 0:\\n            k += 1\\n            \\n        # Is part4 same as part6 ?\\n        if arr[k: k+length] != lastArr:\\n            return [-1, -1]\\n            \\n        return [i, k+length]\\n```",
                "solutionTags": [],
                "code": "```\\n0.........01x...x10...00.........01x...x10...00.........01x...x10...0\\n|- part1 -||- part2  -||- part3 -||- part4 - ||- part5 -||- part6  -|\\n```\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Find number of 1\\'s in the list\\n        n = arr.count(1)\\n        if n == 0: # No 1 found\\n            return [0, 2]\\n        # If number of 1\\'s cannot be mod by 3, the solution does not exist\\n        if n%3:\\n            return [-1, -1]\\n        m = n/3 # Number of 1\\'s each part should have\\n        \\n        # Find the starting point of part6 (must be 1)\\n        j = len(arr)\\n        while m > 0:\\n            j-=1\\n            if arr[j]:\\n                m-=1\\n                \\n        # Part6\\n        lastArr = arr[j:]\\n        length = len(lastArr)\\n        \\n        # Skip all heading 0\\'s\\n        i = 0\\n        while arr[i]==0:\\n            i += 1\\n            \\n        # Is part2 same as part6?\\n        if arr[i: i+length] != lastArr:\\n            return [-1, -1]\\n            \\n        # Got the first element of returning value\\n        i += length-1\\n        \\n        # Skip next consecutive 0\\'s (part3)\\n        k = i+1\\n        while arr[k] == 0:\\n            k += 1\\n            \\n        # Is part4 same as part6 ?\\n        if arr[k: k+length] != lastArr:\\n            return [-1, -1]\\n            \\n        return [i, k+length]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567353,
                "content": [
                    {
                        "username": "THolc",
                        "content": "The test case for [0,0,0,0,0] only allows the answer [0,4], but from my understanding of the problem as long as any 2 valid and unique indices are listed it should be correct since it will always be a binary 0 (i.e. 000, 00, and 0 are all equivalent here).\\n\\nCan someone confirm or refute this? Am I missing some key detail or is this test case actually incorrect based on the problem description?"
                    },
                    {
                        "username": "njbillov",
                        "content": "For the [0,0,0,0,0] test case in the solution checker, I calculated [0,1] and it said it was incorrect and the correct answer was [0,4].  As per spec, any [i,j] that results in three equal parts should be true, so I believe something is wrong with the solution checker.\n\nNevermind, i + 1 < j."
                    }
                ]
            },
            {
                "id": 1569325,
                "content": [
                    {
                        "username": "THolc",
                        "content": "The test case for [0,0,0,0,0] only allows the answer [0,4], but from my understanding of the problem as long as any 2 valid and unique indices are listed it should be correct since it will always be a binary 0 (i.e. 000, 00, and 0 are all equivalent here).\\n\\nCan someone confirm or refute this? Am I missing some key detail or is this test case actually incorrect based on the problem description?"
                    },
                    {
                        "username": "njbillov",
                        "content": "For the [0,0,0,0,0] test case in the solution checker, I calculated [0,1] and it said it was incorrect and the correct answer was [0,4].  As per spec, any [i,j] that results in three equal parts should be true, so I believe something is wrong with the solution checker.\n\nNevermind, i + 1 < j."
                    }
                ]
            }
        ]
    }
]