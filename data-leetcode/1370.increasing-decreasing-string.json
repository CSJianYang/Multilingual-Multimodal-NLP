[
    {
        "title": "Shortest Bridge",
        "question_content": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.\n&nbsp;\nExample 1:\n\nInput: grid = [[0,1],[1,0]]\nOutput: 1\n\nExample 2:\n\nInput: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2\n\nExample 3:\n\nInput: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tn == grid.length == grid[i].length\n\t2 <= n <= 100\n\tgrid[i][j] is either 0 or 1.\n\tThere are exactly two islands in grid.",
        "solutions": [
            {
                "id": 189293,
                "title": "c-bfs-island-expansion-uf-bonus",
                "content": "We first paint one of the islands using DFS with color 2, so we can easily identify island #1 and island #2. Thanks [@davidluoyes](https://leetcode.com/davidluoyes/) for pointing out that we only need to paint one island.\\n\\nThen we start expanding island #2 by paining connected empty area. Each round, we increase the color (3, 4, and so on) so we can keep track of the newly painted area. This ends when we \"bump\" into the first island. \\n![image](https://assets.leetcode.com/users/votrubac/image_1541488072.png)\\nThe fact that we are increasing the color is also useful for the backtracking, if we need to return the coordinates of the bridge.\\n**C++**\\n```cpp\\nint paint(vector<vector<int>>& A, int i, int j) {\\n    if (min(i, j) < 0 || max(i, j) == A.size() || A[i][j] != 1)\\n        return 0;\\n    A[i][j] = 2;\\n    return 1 + paint(A, i + 1, j) + paint(A, i - 1, j) + paint(A, i, j + 1) + paint(A, i, j - 1);\\n}\\nbool expand(vector<vector<int>>& A, int i, int j, int cl) {\\n    if (min(i, j) < 0 || max(i, j) == A.size())\\n        return false;\\n    A[i][j] = A[i][j] == 0 ? cl + 1 : A[i][j];\\n    return A[i][j] == 1;\\n}  \\nint shortestBridge(vector<vector<int>>& A) {\\n    for (int i = 0, found = 0; !found && i < A.size(); ++i)\\n        for (int j = 0; !found && j < A[0].size(); ++j)\\n            found = paint(A, i, j);\\n    for (int cl = 2; ; ++cl)\\n        for (int i = 0; i < A.size(); ++i)\\n            for (int j = 0; j < A.size(); ++j) \\n                if (A[i][j] == cl && ((expand(A, i - 1, j, cl) || expand(A, i, j - 1, cl) || \\n                    expand(A, i + 1, j, cl) || expand(A, i, j + 1, cl))))\\n                        return cl - 2;\\n}\\n```\\n**C++**\\nSame idea, but using a queue instead of scaning the grid.\\n```cpp\\nint dir[5] = {0, 1, 0, -1, 0};\\nvoid paint(vector<vector<int>>& A, int i, int j, vector<pair<int, int>> &q) {\\n    if (min(i, j) >= 0 && max(i, j) < A.size() && A[i][j] == 1) {\\n        A[i][j] = 2;\\n        q.push_back({i, j});\\n        for (int d = 0; d < 4; ++d)\\n            paint(A, i + dir[d], j + dir[d + 1], q);\\n    }\\n}\\nint shortestBridge(vector<vector<int>>& A) {\\n    vector<pair<int, int>> q;\\n    for (int i = 0; q.size() == 0 && i < A.size(); ++i)\\n        for (int j = 0; q.size() == 0 && j < A[0].size(); ++j)\\n            paint(A, i, j, q);\\n    while (!q.empty()) {\\n        vector<pair<int, int>> q1;\\n        for (auto [i, j] : q) {\\n            for (int d = 0; d < 4; ++d) {\\n                int x = i + dir[d], y = j + dir[d + 1];\\n                if (min(x, y) >= 0 && max(x, y) < A.size()) {\\n                    if (A[x][y] == 1)\\n                        return A[i][j] - 2;\\n                    if (A[x][y] == 0) {\\n                        A[x][y] = A[i][j] + 1;\\n                        q1.push_back({x, y});\\n                    }\\n                }\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return 0;\\n}\\n```\\nAs a bonus, below is the union-find based solution. We convert the map into the graph, and join connected \"land\" cells into sub-graphs (island #1 and island #2). Then, we expand both of these islands by adding directly connected \"water\" cells to the sub-graphs. Finally, we stop when we detect that two sub-graphs are about to merge into one.\\n\\nInterestingly, the runtime of these two very different solutions are similar (24 - 35 ms), and the UF solution is much more complex. Probably, the UF solution can be further optimized by only processing direct connections...\\n**C++**\\n```cpp\\nint uf_find(int i, vector<int>& nodes) {\\n  if (nodes[i] <= 0) return i;\\n  else return nodes[i] = uf_find(nodes[i], nodes);\\n}\\nint uf_union(int i, int j, vector<int>& nodes) {\\n  auto pi = uf_find(i, nodes), pj = uf_find(j, nodes);\\n  if (pi == pj) return 0;\\n  if (nodes[pi] > nodes[pj]) swap(pi, pj);\\n  nodes[pi] += min(-1, nodes[pj]);\\n  nodes[pj] = pi;\\n  return -nodes[pi];\\n}\\nint shortestBridge(vector<vector<int>> &A) {\\n  int sz = A.size();\\n  vector<int> nodes(sz * sz + 1);\\n  list<pair<int, int>> edges;\\n  for (auto i = 0; i < sz; ++i)\\n    for (auto j = 0; j < sz; ++j) {\\n      auto idx = i * sz + j + 1;\\n      if (A[i][j]) nodes[idx] = -1;\\n      if (j > 0) {\\n        if (A[i][j] && A[i][j - 1]) uf_union(idx - 1, idx, nodes);\\n        else edges.push_back({ idx - 1, idx });\\n      }\\n      if (i > 0) {\\n        if (A[i][j] && A[i - 1][j]) uf_union(idx - sz, idx, nodes);\\n        else edges.push_back({ idx - sz, idx });\\n      }\\n    }\\n\\n  for (auto step = 1; ; ++step) {\\n    vector<pair<int, int>> merge_list;\\n    for (auto it = edges.begin(); it != edges.end(); ) {\\n      if (nodes[it->first] == 0 && nodes[it->second] == 0) ++it;\\n      else {\\n        if (nodes[it->first] != 0 && nodes[it->second] != 0) {\\n          if (uf_find(it->first, nodes) != uf_find(it->second, nodes)) return (step - 1) * 2;\\n        }\\n        merge_list.push_back({ it->first, it->second });\\n        edges.erase(it++);\\n      }\\n    }\\n    for (auto p : merge_list) {\\n      if (nodes[p.first] != 0 && nodes[p.second] != 0) {\\n        if (uf_find(p.first, nodes) != uf_find(p.second, nodes)) return step * 2 - 1;\\n      }\\n      uf_union(p.first, p.second, nodes);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint paint(vector<vector<int>>& A, int i, int j) {\\n    if (min(i, j) < 0 || max(i, j) == A.size() || A[i][j] != 1)\\n        return 0;\\n    A[i][j] = 2;\\n    return 1 + paint(A, i + 1, j) + paint(A, i - 1, j) + paint(A, i, j + 1) + paint(A, i, j - 1);\\n}\\nbool expand(vector<vector<int>>& A, int i, int j, int cl) {\\n    if (min(i, j) < 0 || max(i, j) == A.size())\\n        return false;\\n    A[i][j] = A[i][j] == 0 ? cl + 1 : A[i][j];\\n    return A[i][j] == 1;\\n}  \\nint shortestBridge(vector<vector<int>>& A) {\\n    for (int i = 0, found = 0; !found && i < A.size(); ++i)\\n        for (int j = 0; !found && j < A[0].size(); ++j)\\n            found = paint(A, i, j);\\n    for (int cl = 2; ; ++cl)\\n        for (int i = 0; i < A.size(); ++i)\\n            for (int j = 0; j < A.size(); ++j) \\n                if (A[i][j] == cl && ((expand(A, i - 1, j, cl) || expand(A, i, j - 1, cl) || \\n                    expand(A, i + 1, j, cl) || expand(A, i, j + 1, cl))))\\n                        return cl - 2;\\n}\\n```\n```cpp\\nint dir[5] = {0, 1, 0, -1, 0};\\nvoid paint(vector<vector<int>>& A, int i, int j, vector<pair<int, int>> &q) {\\n    if (min(i, j) >= 0 && max(i, j) < A.size() && A[i][j] == 1) {\\n        A[i][j] = 2;\\n        q.push_back({i, j});\\n        for (int d = 0; d < 4; ++d)\\n            paint(A, i + dir[d], j + dir[d + 1], q);\\n    }\\n}\\nint shortestBridge(vector<vector<int>>& A) {\\n    vector<pair<int, int>> q;\\n    for (int i = 0; q.size() == 0 && i < A.size(); ++i)\\n        for (int j = 0; q.size() == 0 && j < A[0].size(); ++j)\\n            paint(A, i, j, q);\\n    while (!q.empty()) {\\n        vector<pair<int, int>> q1;\\n        for (auto [i, j] : q) {\\n            for (int d = 0; d < 4; ++d) {\\n                int x = i + dir[d], y = j + dir[d + 1];\\n                if (min(x, y) >= 0 && max(x, y) < A.size()) {\\n                    if (A[x][y] == 1)\\n                        return A[i][j] - 2;\\n                    if (A[x][y] == 0) {\\n                        A[x][y] = A[i][j] + 1;\\n                        q1.push_back({x, y});\\n                    }\\n                }\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return 0;\\n}\\n```\n```cpp\\nint uf_find(int i, vector<int>& nodes) {\\n  if (nodes[i] <= 0) return i;\\n  else return nodes[i] = uf_find(nodes[i], nodes);\\n}\\nint uf_union(int i, int j, vector<int>& nodes) {\\n  auto pi = uf_find(i, nodes), pj = uf_find(j, nodes);\\n  if (pi == pj) return 0;\\n  if (nodes[pi] > nodes[pj]) swap(pi, pj);\\n  nodes[pi] += min(-1, nodes[pj]);\\n  nodes[pj] = pi;\\n  return -nodes[pi];\\n}\\nint shortestBridge(vector<vector<int>> &A) {\\n  int sz = A.size();\\n  vector<int> nodes(sz * sz + 1);\\n  list<pair<int, int>> edges;\\n  for (auto i = 0; i < sz; ++i)\\n    for (auto j = 0; j < sz; ++j) {\\n      auto idx = i * sz + j + 1;\\n      if (A[i][j]) nodes[idx] = -1;\\n      if (j > 0) {\\n        if (A[i][j] && A[i][j - 1]) uf_union(idx - 1, idx, nodes);\\n        else edges.push_back({ idx - 1, idx });\\n      }\\n      if (i > 0) {\\n        if (A[i][j] && A[i - 1][j]) uf_union(idx - sz, idx, nodes);\\n        else edges.push_back({ idx - sz, idx });\\n      }\\n    }\\n\\n  for (auto step = 1; ; ++step) {\\n    vector<pair<int, int>> merge_list;\\n    for (auto it = edges.begin(); it != edges.end(); ) {\\n      if (nodes[it->first] == 0 && nodes[it->second] == 0) ++it;\\n      else {\\n        if (nodes[it->first] != 0 && nodes[it->second] != 0) {\\n          if (uf_find(it->first, nodes) != uf_find(it->second, nodes)) return (step - 1) * 2;\\n        }\\n        merge_list.push_back({ it->first, it->second });\\n        edges.erase(it++);\\n      }\\n    }\\n    for (auto p : merge_list) {\\n      if (nodes[p.first] != 0 && nodes[p.second] != 0) {\\n        if (uf_find(p.first, nodes) != uf_find(p.second, nodes)) return step * 2 - 1;\\n      }\\n      uf_union(p.first, p.second, nodes);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189321,
                "title": "java-dfs-find-the-island-bfs-expand-the-island",
                "content": "```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean found = false;\\n        // 1. dfs to find an island, mark it in `visited`\\n        for (int i = 0; i < m; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (A[i][j] == 1) {\\n                    dfs(A, visited, q, i, j, dirs);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        // 2. bfs to expand this island\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cur = q.poll();\\n                for (int[] dir : dirs) {\\n                    int i = cur[0] + dir[0];\\n                    int j = cur[1] + dir[1];\\n                    if (i >= 0 && j >= 0 && i < m && j < n && !visited[i][j]) {\\n                        if (A[i][j] == 1) {\\n                            return step;\\n                        }\\n                        q.offer(new int[]{i, j});\\n                        visited[i][j] = true;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    private void dfs(int[][] A, boolean[][] visited, Queue<int[]> q, int i, int j, int[][] dirs) {\\n        if (i < 0 || j < 0 || i >= A.length || j >= A[0].length || visited[i][j] || A[i][j] == 0) {\\n            return;\\n        }\\n        visited[i][j] = true;\\n        q.offer(new int[]{i, j});\\n        for (int[] dir : dirs) {\\n            dfs(A, visited, q, i + dir[0], j + dir[1], dirs);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean found = false;\\n        // 1. dfs to find an island, mark it in `visited`\\n        for (int i = 0; i < m; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (A[i][j] == 1) {\\n                    dfs(A, visited, q, i, j, dirs);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        // 2. bfs to expand this island\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cur = q.poll();\\n                for (int[] dir : dirs) {\\n                    int i = cur[0] + dir[0];\\n                    int j = cur[1] + dir[1];\\n                    if (i >= 0 && j >= 0 && i < m && j < n && !visited[i][j]) {\\n                        if (A[i][j] == 1) {\\n                            return step;\\n                        }\\n                        q.offer(new int[]{i, j});\\n                        visited[i][j] = true;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    private void dfs(int[][] A, boolean[][] visited, Queue<int[]> q, int i, int j, int[][] dirs) {\\n        if (i < 0 || j < 0 || i >= A.length || j >= A[0].length || visited[i][j] || A[i][j] == 0) {\\n            return;\\n        }\\n        visited[i][j] = true;\\n        q.offer(new int[]{i, j});\\n        for (int[] dir : dirs) {\\n            dfs(A, visited, q, i + dir[0], j + dir[1], dirs);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189440,
                "title": "python-concise-dfs-bfs-in-1-solution",
                "content": "* Idea is straightforward.\\n* We get root of first island from \"first\" function\\n* We dfs root and add indexes to bfs\\n* We bfs and expand the first island in other words\\n* Finally return step number when facing other island\\n* Note: This can also be done with referenced array if you don\\'t want to modify A.\\n```\\nclass Solution:\\n    def shortestBridge(self, A):\\n        def dfs(i, j):\\n            A[i][j] = -1\\n            bfs.append((i, j))\\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                if 0 <= x < n and 0 <= y < n and A[x][y] == 1:\\n                    dfs(x, y)\\n        def first():\\n            for i in range(n):\\n                for j in range(n):\\n                    if A[i][j]:\\n                        return i, j\\n        n, step, bfs = len(A), 0, []\\n        dfs(*first())\\n        while bfs:\\n            new = []\\n            for i, j in bfs:\\n                for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                    if 0 <= x < n and 0 <= y < n:\\n                        if A[x][y] == 1:\\n                            return step\\n                        elif not A[x][y]:\\n                            A[x][y] = -1\\n                            new.append((x, y))\\n            step += 1\\n            bfs = new\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, A):\\n        def dfs(i, j):\\n            A[i][j] = -1\\n            bfs.append((i, j))\\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                if 0 <= x < n and 0 <= y < n and A[x][y] == 1:\\n                    dfs(x, y)\\n        def first():\\n            for i in range(n):\\n                for j in range(n):\\n                    if A[i][j]:\\n                        return i, j\\n        n, step, bfs = len(A), 0, []\\n        dfs(*first())\\n        while bfs:\\n            new = []\\n            for i, j in bfs:\\n                for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                    if 0 <= x < n and 0 <= y < n:\\n                        if A[x][y] == 1:\\n                            return step\\n                        elif not A[x][y]:\\n                            A[x][y] = -1\\n                            new.append((x, y))\\n            step += 1\\n            bfs = new\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189315,
                "title": "java-dfs-bfs-traverse-the-2d-array-once",
                "content": "Use DFS to mark the first island to 2, and continue traverse the 2D array to add every \\'1\\'(the second island) into Queue, then BFS to find the shortest path needed.\\n\\n```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean found = false;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int level = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(A[i][j] == 1 && !found) {\\n                    dfs(A, i, j, m, n);\\n                    found = true;\\n                }\\n                if(found && A[i][j] == 1) {\\n                    queue.add(new int[] {i, j});\\n                }\\n            }\\n        }\\n        int[][] d = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int s = 0; s < size; s++) {\\n                int[] pos = queue.poll();\\n                for(int i = 0; i < 4; i++) {\\n                    int x = pos[0] + d[i][0];\\n                    int y = pos[1] + d[i][1];\\n                    if(x < 0 || x >= m || y < 0 || y >= n) continue;\\n                    if(A[x][y] == 2) return level;\\n                    else if(A[x][y] == 1) continue;\\n                    else if(A[x][y] == 0) {\\n                        A[x][y] = 1;\\n                        queue.add(new int[]{x, y});\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    public void dfs(int[][] A, int i, int j, int m, int n) {\\n        A[i][j] = 2;\\n        if(i - 1 >= 0 && A[i-1][j] == 1) dfs(A, i - 1, j, m, n);\\n        if(i + 1 < m && A[i+1][j] == 1) dfs(A, i + 1, j, m, n);\\n        if(j - 1 >= 0 && A[i][j - 1] == 1) dfs(A, i, j - 1, m, n);\\n        if(j + 1 < n && A[i][j + 1] == 1) dfs(A, i, j + 1, m, n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean found = false;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int level = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(A[i][j] == 1 && !found) {\\n                    dfs(A, i, j, m, n);\\n                    found = true;\\n                }\\n                if(found && A[i][j] == 1) {\\n                    queue.add(new int[] {i, j});\\n                }\\n            }\\n        }\\n        int[][] d = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int s = 0; s < size; s++) {\\n                int[] pos = queue.poll();\\n                for(int i = 0; i < 4; i++) {\\n                    int x = pos[0] + d[i][0];\\n                    int y = pos[1] + d[i][1];\\n                    if(x < 0 || x >= m || y < 0 || y >= n) continue;\\n                    if(A[x][y] == 2) return level;\\n                    else if(A[x][y] == 1) continue;\\n                    else if(A[x][y] == 0) {\\n                        A[x][y] = 1;\\n                        queue.add(new int[]{x, y});\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    public void dfs(int[][] A, int i, int j, int m, int n) {\\n        A[i][j] = 2;\\n        if(i - 1 >= 0 && A[i-1][j] == 1) dfs(A, i - 1, j, m, n);\\n        if(i + 1 < m && A[i+1][j] == 1) dfs(A, i + 1, j, m, n);\\n        if(j - 1 >= 0 && A[i][j - 1] == 1) dfs(A, i, j - 1, m, n);\\n        if(j + 1 < n && A[i][j + 1] == 1) dfs(A, i, j + 1, m, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560363,
                "title": "c-dfs-and-bfs-explanation-and-commented",
                "content": "**My approach is:**\\n**1st step** :  I will visit the island which comes first in graph i.e. finding first \\'1\\' in the graph.\\n**2nd step** : I will add the first 1\\'s cordinates to queue and mark it visited (by changing 1 to 2 instead of another visited 2D array, so it saves us space).\\n**3rd step** : I will travel through all its neighbours and make the neighbour visited if it comes under same island. And while marking them visited, I will add them to queue also.\\n**4th step** : Now I will run BFS on the first island and find the nearest bridge to connect nearest \\'1\\'.\\n\\nThats it!! The problem is solved!!!\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    queue<pair<int, int>> q; // queue\\n    \\n    void dfs(vector<vector<int>>& grid, int i, int j) { // for marking the 1st island visited\\n        \\n        if (i<0 or i>=grid.size() or j<0 or j>=grid[0].size() or grid[i][j] == 2 or grid[i][j] == 0)\\n            return;\\n        \\n        grid[i][j] = 2; // marking them visited\\n        q.push({i,j}); // adding them to queue\\n        \\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n    }\\n    \\n    int bfs(vector<vector<int>>& grid){ // finding the nearest bridge between visited island and unvisited island\\n        \\n        int d = 0; // dist\\n        int mindist = INT_MAX; // to store minimum distance\\n        \\n        vector<vector<int>> dir = {{1,0}, {0,1}, {-1,0}, {0,-1}};\\n        \\n        while (!q.empty()){\\n            int n = q.size();\\n            \\n            while(n-- > 0){\\n                auto a = q.front();\\n                q.pop();\\n\\n                for (int h=0; h<4; h++) {\\n                    int x = dir[h][0] + a.first;\\n                    int y = dir[h][1] + a.second;\\n                    \\n                    if (x>=0 and x<grid.size() and y>=0 and y<grid[0].size() and grid[x][y] == 1) { // if the neighbor is 1, then check if its minimum distance\\n                        mindist = min(mindist, d);\\n                    }\\n\\n                    else if (x>=0 and x<grid.size() and y>=0 and y<grid[0].size() and grid[x][y] == 0) { // if the neighbor is 0, then mark it visited and add it to queue\\n                        q.push({x, y});\\n                        grid[x][y] = 2;\\n                    }\\n                }\\n            }\\n            d++; // increasing each level by distance + 1\\n        }\\n        \\n        return mindist; // returning min dist found till end\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        bool flag = false;\\n        \\n        for (int i=0; i<grid.size(); i++){\\n            for (int j=0; j<grid[0].size(); j++){\\n                if (grid[i][j] == 1 and !flag){ // found 1st \\'1\\' in the matrix\\n                    dfs(grid, i, j); // dfs for marking the whole island visited\\n                    q.push({i,j});\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag)\\n                break;\\n        }\\n        \\n        return bfs(grid); // bfs for getting min dist and returning it\\n    }\\n};\\n```\\n\\nPlease upvote if you liked it \\u263A\\uFE0F!!",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    queue<pair<int, int>> q; // queue\\n    \\n    void dfs(vector<vector<int>>& grid, int i, int j) { // for marking the 1st island visited\\n        \\n        if (i<0 or i>=grid.size() or j<0 or j>=grid[0].size() or grid[i][j] == 2 or grid[i][j] == 0)\\n            return;\\n        \\n        grid[i][j] = 2; // marking them visited\\n        q.push({i,j}); // adding them to queue\\n        \\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n    }\\n    \\n    int bfs(vector<vector<int>>& grid){ // finding the nearest bridge between visited island and unvisited island\\n        \\n        int d = 0; // dist\\n        int mindist = INT_MAX; // to store minimum distance\\n        \\n        vector<vector<int>> dir = {{1,0}, {0,1}, {-1,0}, {0,-1}};\\n        \\n        while (!q.empty()){\\n            int n = q.size();\\n            \\n            while(n-- > 0){\\n                auto a = q.front();\\n                q.pop();\\n\\n                for (int h=0; h<4; h++) {\\n                    int x = dir[h][0] + a.first;\\n                    int y = dir[h][1] + a.second;\\n                    \\n                    if (x>=0 and x<grid.size() and y>=0 and y<grid[0].size() and grid[x][y] == 1) { // if the neighbor is 1, then check if its minimum distance\\n                        mindist = min(mindist, d);\\n                    }\\n\\n                    else if (x>=0 and x<grid.size() and y>=0 and y<grid[0].size() and grid[x][y] == 0) { // if the neighbor is 0, then mark it visited and add it to queue\\n                        q.push({x, y});\\n                        grid[x][y] = 2;\\n                    }\\n                }\\n            }\\n            d++; // increasing each level by distance + 1\\n        }\\n        \\n        return mindist; // returning min dist found till end\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        bool flag = false;\\n        \\n        for (int i=0; i<grid.size(); i++){\\n            for (int j=0; j<grid[0].size(); j++){\\n                if (grid[i][j] == 1 and !flag){ // found 1st \\'1\\' in the matrix\\n                    dfs(grid, i, j); // dfs for marking the whole island visited\\n                    q.push({i,j});\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag)\\n                break;\\n        }\\n        \\n        return bfs(grid); // bfs for getting min dist and returning it\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448914,
                "title": "java-easy-approach-with-explanation-bfs-dfs-preorder-graph",
                "content": "```\\nclass Solution \\n{\\n    public int shortestBridge(int[][] grid) \\n    {\\n        Queue<int[]> q= new LinkedList<>();\\n        boolean flag= false;\\n        for(int i= 0; i< grid.length; i++)\\n        {\\n            for(int j= 0; j< grid[0].length; j++)\\n            {\\n                if(grid[i][j] == 1)//finding one island cell, to traverse the whole component and add it to the Queue \\n                {\\n                    dfs(grid, i, j, q);//Connected island cells \\n                    flag= true;\\n                    break;\\n                }\\n            }\\n            if(flag == true)break;\\n        }\\n        \\n        return findNearestIslandBFS(grid, q);\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, Queue<int[]> q)\\n    {//Preorder DFS is used to add the sub-land of island into the queue\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == -1 || grid[i][j] == 0)\\n            return;//base case 1)index out of  bound 2)not visiting the visited node  3)not visiting the water cell \\n        \\n        grid[i][j]= -1;//marking the node as visited, so that we don\\'t traverse the node again \\n        q.offer(new int[]{i, j});//adding the sub-land of the island into the Queue \\n        \\n        //CSS Border Order\\n        dfs(grid, i-1, j, q);//Top\\n        dfs(grid, i, j+1, q);//Right\\n        dfs(grid, i+1, j, q);//Bottom \\n        dfs(grid, i, j-1, q);//Left\\n        \\n        return;\\n    }\\n    \\n    private int findNearestIslandBFS(int[][] grid, Queue<int[]> q)\\n    {//BFS finds the shortest path length between the two points, so we use here to find the minimum distance between two point of island //Top to Bottom Approach //Multiple Variate BFS \\n        int[][] trav= {{-1,0},{0,1},{1,0},{0,-1}};//Traversing in 4 Direction \\n        \\n        int level= 0;//current level//source starting island level \\n        \\n        while(!q.isEmpty())\\n        {\\n            int size= q.size();//Level popping constraint \\n            while(size-- > 0)//Radially traversing breadth wise \\n            {\\n                int []temp= q.poll();//polling the current node \\n                for(int []dirc: trav)\\n                {\\n                    //new co-ordinate \\n                    int i_= temp[0]+ dirc[0];\\n                    int j_= temp[1]+ dirc[1];\\n                    if(i_ >= grid.length || i_ < 0 || j_ >= grid[0].length || j_ < 0 || grid[i_][j_] == -1)\\n                        continue;//base case 1)index out of bound 2)not visiting the visited node again \\n                    \\n                    if(grid[i_][j_] == 1)//when we find a island cell, we return the current level(n-1)\\n                        return level;//previous level of the destination level//0 1 2 ... (n-1) n, [1 -> n-1] swap required//returning the n-1 level //n -> level of the destination level, 0 -> source starting island level\\n                    \\n                    else\\n                    {//water cell case, we are adding it to the next level of the queue, to expand the search and to find the min path length between two island\\n                        grid[i_][j_]= -1;//marking it as visited, so that we dont traverse it again \\n                        q.offer(new int[]{i_, j_});//adding the the water cell into the Queue \\n                    }\\n                }\\n            }\\n            level+= 1;//increasing the level \\n        }\\n        return -1;//base case\\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int shortestBridge(int[][] grid) \\n    {\\n        Queue<int[]> q= new LinkedList<>();\\n        boolean flag= false;\\n        for(int i= 0; i< grid.length; i++)\\n        {\\n            for(int j= 0; j< grid[0].length; j++)\\n            {\\n                if(grid[i][j] == 1)//finding one island cell, to traverse the whole component and add it to the Queue \\n                {\\n                    dfs(grid, i, j, q);//Connected island cells \\n                    flag= true;\\n                    break;\\n                }\\n            }\\n            if(flag == true)break;\\n        }\\n        \\n        return findNearestIslandBFS(grid, q);\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, Queue<int[]> q)\\n    {//Preorder DFS is used to add the sub-land of island into the queue\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == -1 || grid[i][j] == 0)\\n            return;//base case 1)index out of  bound 2)not visiting the visited node  3)not visiting the water cell \\n        \\n        grid[i][j]= -1;//marking the node as visited, so that we don\\'t traverse the node again \\n        q.offer(new int[]{i, j});//adding the sub-land of the island into the Queue \\n        \\n        //CSS Border Order\\n        dfs(grid, i-1, j, q);//Top\\n        dfs(grid, i, j+1, q);//Right\\n        dfs(grid, i+1, j, q);//Bottom \\n        dfs(grid, i, j-1, q);//Left\\n        \\n        return;\\n    }\\n    \\n    private int findNearestIslandBFS(int[][] grid, Queue<int[]> q)\\n    {//BFS finds the shortest path length between the two points, so we use here to find the minimum distance between two point of island //Top to Bottom Approach //Multiple Variate BFS \\n        int[][] trav= {{-1,0},{0,1},{1,0},{0,-1}};//Traversing in 4 Direction \\n        \\n        int level= 0;//current level//source starting island level \\n        \\n        while(!q.isEmpty())\\n        {\\n            int size= q.size();//Level popping constraint \\n            while(size-- > 0)//Radially traversing breadth wise \\n            {\\n                int []temp= q.poll();//polling the current node \\n                for(int []dirc: trav)\\n                {\\n                    //new co-ordinate \\n                    int i_= temp[0]+ dirc[0];\\n                    int j_= temp[1]+ dirc[1];\\n                    if(i_ >= grid.length || i_ < 0 || j_ >= grid[0].length || j_ < 0 || grid[i_][j_] == -1)\\n                        continue;//base case 1)index out of bound 2)not visiting the visited node again \\n                    \\n                    if(grid[i_][j_] == 1)//when we find a island cell, we return the current level(n-1)\\n                        return level;//previous level of the destination level//0 1 2 ... (n-1) n, [1 -> n-1] swap required//returning the n-1 level //n -> level of the destination level, 0 -> source starting island level\\n                    \\n                    else\\n                    {//water cell case, we are adding it to the next level of the queue, to expand the search and to find the min path length between two island\\n                        grid[i_][j_]= -1;//marking it as visited, so that we dont traverse it again \\n                        q.offer(new int[]{i_, j_});//adding the the water cell into the Queue \\n                    }\\n                }\\n            }\\n            level+= 1;//increasing the level \\n        }\\n        return -1;//base case\\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 639392,
                "title": "c-dfs-bfs-solution-find-one-island-and-then-grow-towards-another",
                "content": "```\\nclass Solution {\\n    vector<vector<int> > mat;\\n    vector<vector<int> > vis;\\n    int m,n;\\n    int x[4]={-1,0,1,0};\\n    int y[4]={0,1,0,-1};\\n    queue<pair<int,int> > que;\\npublic:\\n    void dfs(int i,int j){\\n        vis[i][j]=1;\\n        que.push({i,j});\\n        for(int dir=0;dir<4;dir++){\\n            int xd=i+x[dir];\\n            int yd=j+y[dir];\\n            if(xd>=0 && yd>=0 && xd<=m-1 && yd<=n-1){\\n                if(!vis[xd][yd] && mat[xd][yd]==1){\\n                    dfs(xd,yd);\\n                }\\n            }\\n        }\\n    }\\n    int shortestBridge(vector<vector<int>>& A) {\\n        m=A.size();\\n        if(m==0) return 0;\\n        n=A[0].size();\\n        cout<<m<<\" \"<<n;\\n        mat=A;\\n        vis.resize(m,vector<int>(n,0));\\n        int flag=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    dfs(i,j);\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                break;\\n            }\\n        }\\n        int l=0;\\n        while(!que.empty()){\\n            int len=que.size();\\n            l++;\\n            while(len--){\\n                pair<int,int> poi=que.front();\\n                que.pop();\\n                vis[poi.first][poi.second]=1;\\n                for(int dir=0;dir<4;dir++){\\n                    int xd=poi.first+x[dir];\\n                    int yd=poi.second+y[dir];\\n                    if(xd>=0 && yd>=0 && xd<=m-1 && yd<=n-1){\\n                       if(!vis[xd][yd] && mat[xd][yd]==1){\\n                           return l-1;\\n                       }\\n                       else if(!vis[xd][yd] && mat[xd][yd]==0){\\n                           vis[xd][yd]=1;\\n                           que.push({xd,yd});\\n                       }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};      \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int> > mat;\\n    vector<vector<int> > vis;\\n    int m,n;\\n    int x[4]={-1,0,1,0};\\n    int y[4]={0,1,0,-1};\\n    queue<pair<int,int> > que;\\npublic:\\n    void dfs(int i,int j){\\n        vis[i][j]=1;\\n        que.push({i,j});\\n        for(int dir=0;dir<4;dir++){\\n            int xd=i+x[dir];\\n            int yd=j+y[dir];\\n            if(xd>=0 && yd>=0 && xd<=m-1 && yd<=n-1){\\n                if(!vis[xd][yd] && mat[xd][yd]==1){\\n                    dfs(xd,yd);\\n                }\\n            }\\n        }\\n    }\\n    int shortestBridge(vector<vector<int>>& A) {\\n        m=A.size();\\n        if(m==0) return 0;\\n        n=A[0].size();\\n        cout<<m<<\" \"<<n;\\n        mat=A;\\n        vis.resize(m,vector<int>(n,0));\\n        int flag=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    dfs(i,j);\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                break;\\n            }\\n        }\\n        int l=0;\\n        while(!que.empty()){\\n            int len=que.size();\\n            l++;\\n            while(len--){\\n                pair<int,int> poi=que.front();\\n                que.pop();\\n                vis[poi.first][poi.second]=1;\\n                for(int dir=0;dir<4;dir++){\\n                    int xd=poi.first+x[dir];\\n                    int yd=poi.second+y[dir];\\n                    if(xd>=0 && yd>=0 && xd<=m-1 && yd<=n-1){\\n                       if(!vis[xd][yd] && mat[xd][yd]==1){\\n                           return l-1;\\n                       }\\n                       else if(!vis[xd][yd] && mat[xd][yd]==0){\\n                           vis[xd][yd]=1;\\n                           que.push({xd,yd});\\n                       }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};      \\n```",
                "codeTag": "C++"
            },
            {
                "id": 374415,
                "title": "python-easy-to-understand-with-key-comments",
                "content": "```\\nclass Solution:\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        \\n        found = False\\n        stack = []\\n        n, m = len(A), len(A[0])\\n        # -----------\\n        # find the first island\\n        # -----------\\n        for i in range(n):\\n            for j in range(m):\\n                if A[i][j]:\\n                    # -----------\\n                    # using depth first search to find all connected (\\'1\\') locations, since we already know there are only two islands. so we only need to find the first one \\n                    # -----------\\n                    self.dfs(A, i, j, n, m, stack)\\n                    found = True\\n                    break\\n            if found:\\n                break\\n        steps = 0\\n        # -----------\\n        # breadth first search, once we find next \\'1\\', that is our final answer \\n        # -----------\\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        while stack:\\n            size = len(stack)\\n            level = []\\n            while(size):\\n                temp = stack.pop()\\n                size-=1\\n                x, y = temp[0], temp[1]\\n                for dx, dy in dirs:\\n                    tx = x+dx\\n                    ty = y+dy\\n                    if tx<0 or ty<0 or tx>=n or ty>=m or A[tx][ty]==2:\\n                        continue\\n                    if A[tx][ty]==1:\\n                        return steps\\n                    A[tx][ty]=2\\n                    level.append((tx, ty))\\n            steps+=1\\n            stack = level\\n        return -1 \\n                \\n    def dfs(self, A, row, col, n, m, stack):\\n        # -----------\\n        # we only need to find connected \\'1\\'s. that\\'s why we need A[row][col]==1\\n        # -----------\\n        if row<0 or col<0 or row>=n or col>=m or A[row][col]!=1:\\n            return \\n        A[row][col]=2\\n        # -----------\\n        # use stack for breath first search\\n        # -----------\\n        stack.append((row, col))\\n        self.dfs(A, row+1, col, n, m, stack)\\n        self.dfs(A, row-1, col, n, m, stack)\\n        self.dfs(A, row, col+1, n, m, stack)\\n        self.dfs(A, row, col-1, n, m, stack)\\n    \\n    \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        \\n        found = False\\n        stack = []\\n        n, m = len(A), len(A[0])\\n        # -----------\\n        # find the first island\\n        # -----------\\n        for i in range(n):\\n            for j in range(m):\\n                if A[i][j]:\\n                    # -----------\\n                    # using depth first search to find all connected (\\'1\\') locations, since we already know there are only two islands. so we only need to find the first one \\n                    # -----------\\n                    self.dfs(A, i, j, n, m, stack)\\n                    found = True\\n                    break\\n            if found:\\n                break\\n        steps = 0\\n        # -----------\\n        # breadth first search, once we find next \\'1\\', that is our final answer \\n        # -----------\\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        while stack:\\n            size = len(stack)\\n            level = []\\n            while(size):\\n                temp = stack.pop()\\n                size-=1\\n                x, y = temp[0], temp[1]\\n                for dx, dy in dirs:\\n                    tx = x+dx\\n                    ty = y+dy\\n                    if tx<0 or ty<0 or tx>=n or ty>=m or A[tx][ty]==2:\\n                        continue\\n                    if A[tx][ty]==1:\\n                        return steps\\n                    A[tx][ty]=2\\n                    level.append((tx, ty))\\n            steps+=1\\n            stack = level\\n        return -1 \\n                \\n    def dfs(self, A, row, col, n, m, stack):\\n        # -----------\\n        # we only need to find connected \\'1\\'s. that\\'s why we need A[row][col]==1\\n        # -----------\\n        if row<0 or col<0 or row>=n or col>=m or A[row][col]!=1:\\n            return \\n        A[row][col]=2\\n        # -----------\\n        # use stack for breath first search\\n        # -----------\\n        stack.append((row, col))\\n        self.dfs(A, row+1, col, n, m, stack)\\n        self.dfs(A, row-1, col, n, m, stack)\\n        self.dfs(A, row, col+1, n, m, stack)\\n        self.dfs(A, row, col-1, n, m, stack)\\n    \\n    \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547010,
                "title": "c-beginner-friendly-easy-to-understand-100",
                "content": "### \\uD83D\\uDD25 Donn Forget to Upvote if you liked the Approach. \\uD83D\\uDD25\\n\\n\\n# Intuition\\n**Intution of the problem is very basic. Just find all the the indices of first Island and Second Island then perform minimum distance between them and return the ans.**\\n\\n# Approach\\nCreated two Global Vectors ***First*** and ***Second*** that stores the indices of first and second Island respectively.\\n\\nThen calculated the distance of indices of second Island from first Island and stored the minimum value among them and returned the ***ans***.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> first,second;\\n    \\n    void mark(int i,int j, int no, vector<vector<int>>& grid)\\n    {\\n        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]!=1) return;\\n        grid[i][j]=no;\\n\\n        if(no==2) first.push_back({i,j});\\n        else second.push_back({i,j});\\n\\n        mark(i+1,j,no,grid);\\n        mark(i-1,j,no,grid);\\n        mark(i,j+1,no,grid);\\n        mark(i,j-1,no,grid);\\n    }\\n    \\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int count=2;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1){\\n                mark(i,j,count,grid);\\n                count++;}\\n            }\\n        }\\n        int ans=1000000;\\n        for(int i=0;i<first.size();i++)\\n            for(int j=0;j<second.size();j++)\\n                ans=min(abs(first[i].first-second[j].first)+abs(first[i].second-second[j].second)-1,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> first,second;\\n    \\n    void mark(int i,int j, int no, vector<vector<int>>& grid)\\n    {\\n        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]!=1) return;\\n        grid[i][j]=no;\\n\\n        if(no==2) first.push_back({i,j});\\n        else second.push_back({i,j});\\n\\n        mark(i+1,j,no,grid);\\n        mark(i-1,j,no,grid);\\n        mark(i,j+1,no,grid);\\n        mark(i,j-1,no,grid);\\n    }\\n    \\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int count=2;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1){\\n                mark(i,j,count,grid);\\n                count++;}\\n            }\\n        }\\n        int ans=1000000;\\n        for(int i=0;i<first.size();i++)\\n            for(int j=0;j<second.size();j++)\\n                ans=min(abs(first[i].first-second[j].first)+abs(first[i].second-second[j].second)-1,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739372,
                "title": "c-simple-solution-using-dfs-and-distance-between-2-points",
                "content": "Perform DFS for both islands and store their coordinates in seperate sets. now we know distance between 2 points is  |x1-x2| + |y1-y2| \\nso iterate over those 2 sets and find minimum distance between points of island 1 and  2. subtract 1 as we included the island coordinate too in distance and return the answer.\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &g,set<pair<int,int>> &is,int i,int j)\\n    {\\n         \\n        if(i<0||j<0||i>=g.size()||j>=g[0].size()||g[i][j]!=1||is.count({i,j}))\\n            return;\\n        \\n        is.insert({i,j});\\n        g[i][j]=2;\\n        dfs(g,is,i+1,j);\\n        dfs(g,is,i-1,j);\\n        dfs(g,is,i,j+1);\\n        dfs(g,is,i,j-1);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        set<pair<int,int>> is1,is2;\\n        \\n        int n=grid.size();\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int f=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {  \\n                if(grid[i][j]==1&&!vis[i][j])\\n                {\\n                    if(f==0)\\n                    {   \\n                        dfs(grid,is1,i,j);\\n                        f++;\\n                    }\\n                    else\\n                        dfs(grid,is2,i,j);\\n                 }\\n             }\\n        }\\n        int ans=INT_MAX;\\n     \\n        for(auto i :is1)\\n        for(auto j :is2) \\n            ans=min(ans,(abs(i.first - j.first) + abs(i.second - j.second)-1));\\n        return ans;\\n    }\\n};\\n```\\n**NOTE:**\\nSince it is mentioned that there are **exactly two islands** so we can skip the 2nd dfs call and simply mark is1 in 1st call by some value other than 1 then check for remaining 1s which would belong to is2 and continue to find the shortest distance between their points .",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &g,set<pair<int,int>> &is,int i,int j)\\n    {\\n         \\n        if(i<0||j<0||i>=g.size()||j>=g[0].size()||g[i][j]!=1||is.count({i,j}))\\n            return;\\n        \\n        is.insert({i,j});\\n        g[i][j]=2;\\n        dfs(g,is,i+1,j);\\n        dfs(g,is,i-1,j);\\n        dfs(g,is,i,j+1);\\n        dfs(g,is,i,j-1);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        set<pair<int,int>> is1,is2;\\n        \\n        int n=grid.size();\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int f=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {  \\n                if(grid[i][j]==1&&!vis[i][j])\\n                {\\n                    if(f==0)\\n                    {   \\n                        dfs(grid,is1,i,j);\\n                        f++;\\n                    }\\n                    else\\n                        dfs(grid,is2,i,j);\\n                 }\\n             }\\n        }\\n        int ans=INT_MAX;\\n     \\n        for(auto i :is1)\\n        for(auto j :is2) \\n            ans=min(ans,(abs(i.first - j.first) + abs(i.second - j.second)-1));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342966,
                "title": "c-bfs-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    queue<pair<pair<int,int>,int>> q;\\n    \\n    void dfs(vector<vector<int>>& grid, int x, int y, int row, int col, vector<vector<bool>> &vis){\\n        if(x<0 || x>=row || y<0 || y>=col || vis[x][y] || grid[x][y]==0) return;\\n        vis[x][y] = true;\\n        grid[x][y] = 0;\\n        q.push({{x,y},0});\\n        \\n        int dx[] = {0,1,0,-1};\\n        int dy[] = {1,0,-1,0};\\n        \\n        for(int i=0;i<4;++i){\\n            int x1 = x+dx[i], y1 = y+dy[i];\\n            if(x1<0 || x1>=row || y1<0 || y1>=col || vis[x1][y1] || grid[x1][y1]==0) continue;\\n            dfs(grid,x1,y1,row,col,vis);\\n        }\\n        return;\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        bool flag = false;\\n        \\n        vector<vector<bool>> vis(row,vector<bool>(col,false));\\n        \\n        for(int i=0;i<row;++i){\\n            for(int j=0;j<col;++j){\\n                if(!vis[i][j] && grid[i][j]==1){\\n                    dfs(grid,i,j,row,col,vis);\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag) break;\\n        }\\n        \\n        int dx[] = {0,1,0,-1};\\n        int dy[] = {1,0,-1,0};\\n\\n        while(!q.empty()){ \\n            int x = q.front().first.first;\\n            int y = q.front().first.second;\\n            int dis = q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;++i){\\n                int x1 = x+dx[i];\\n                int y1 = y+dy[i];\\n\\n                if(x1<0 || x1>=row || y1<0 || y1>=col || vis[x1][y1]) continue;\\n\\n                if(grid[x1][y1]==1) return dis;\\n                else {\\n                    vis[x1][y1] = true;\\n                    q.push({{x1,y1},dis+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    queue<pair<pair<int,int>,int>> q;\\n    \\n    void dfs(vector<vector<int>>& grid, int x, int y, int row, int col, vector<vector<bool>> &vis){\\n        if(x<0 || x>=row || y<0 || y>=col || vis[x][y] || grid[x][y]==0) return;\\n        vis[x][y] = true;\\n        grid[x][y] = 0;\\n        q.push({{x,y},0});\\n        \\n        int dx[] = {0,1,0,-1};\\n        int dy[] = {1,0,-1,0};\\n        \\n        for(int i=0;i<4;++i){\\n            int x1 = x+dx[i], y1 = y+dy[i];\\n            if(x1<0 || x1>=row || y1<0 || y1>=col || vis[x1][y1] || grid[x1][y1]==0) continue;\\n            dfs(grid,x1,y1,row,col,vis);\\n        }\\n        return;\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        bool flag = false;\\n        \\n        vector<vector<bool>> vis(row,vector<bool>(col,false));\\n        \\n        for(int i=0;i<row;++i){\\n            for(int j=0;j<col;++j){\\n                if(!vis[i][j] && grid[i][j]==1){\\n                    dfs(grid,i,j,row,col,vis);\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag) break;\\n        }\\n        \\n        int dx[] = {0,1,0,-1};\\n        int dy[] = {1,0,-1,0};\\n\\n        while(!q.empty()){ \\n            int x = q.front().first.first;\\n            int y = q.front().first.second;\\n            int dis = q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;++i){\\n                int x1 = x+dx[i];\\n                int y1 = y+dy[i];\\n\\n                if(x1<0 || x1>=row || y1<0 || y1>=col || vis[x1][y1]) continue;\\n\\n                if(grid[x1][y1]==1) return dis;\\n                else {\\n                    vis[x1][y1] = true;\\n                    q.push({{x1,y1},dis+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546474,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n\\n# or\\n\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\n- Perform a depth-first search (DFS) to find the first island in the grid. Mark the visited cells as you traverse through the island.\\n- Start a breadth-first search (BFS) from the visited cells of the first island. Keep expanding to neighboring cells until you find the second island or exhaust all possible cells.\\n- During the BFS, maintain the level (distance) from the first island. Return the level when you encounter the second island.\\n- If no second island is found, return -1 to indicate that no bridge exists between the two islands.\\n# Intuition:\\n\\n- We start by finding the first island using a DFS approach. We traverse the grid until we find the first cell with a value of 1, indicating the start of the island.\\n- Once we find the first island, we mark all the visited cells in a set to keep track of them.\\n- Next, we use a BFS approach starting from the visited cells of the first island. We explore the neighboring cells and check if they are part of the second island or not.\\n- We continue BFS until we find the second island or exhaust all possible cells.\\n- By using BFS, we can ensure that we find the shortest bridge between the two islands, as we traverse the grid layer by layer.\\n- The distance (level) of each layer in the BFS represents the shortest path from the first island to the second island.\\n- If we find the second island during BFS, we return the level as the shortest distance. Otherwise, if no second island is found, we return -1 to indicate that no bridge exists between the two islands.\\n\\n```Python []\\nclass Solution:\\n    def shortestBridge(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        start_i, start_j = next((i, j) for i in range(m) for j in range(n) if grid[i][j])\\n        \\n        \\n        stack = [(start_i, start_j)]\\n        visited = set(stack)\\n        while stack:\\n            i, j = stack.pop()\\n            visited.add((i, j))  \\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):\\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] and (ii, jj) not in visited:\\n                    stack.append((ii, jj))\\n                    visited.add((ii, jj))\\n        \\n        \\n        ans = 0\\n        queue = list(visited)\\n        while queue:\\n            new_queue = []\\n            for i, j in queue:\\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):\\n                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in visited:\\n                        if grid[ii][jj] == 1:\\n                            return ans\\n                        new_queue.append((ii, jj))\\n                        visited.add((ii, jj))\\n            queue = new_queue\\n            ans += 1\\n\\n```\\n```Java []\\n\\nclass Solution {\\n    private int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    public int shortestBridge(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        int startI = -1;\\n        int startJ = -1;\\n        boolean found = false;\\n\\n        // Step 1: Find the first island using DFS\\n        for (int i = 0; i < m; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    startI = i;\\n                    startJ = j;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(grid, startI, startJ, visited);\\n\\n        // Step 2: Perform BFS from the first island to find the shortest bridge\\n        Queue<Integer> queue = new ArrayDeque<>(visited);\\n        int level = 0;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = queue.poll();\\n                int currI = curr / n;\\n                int currJ = curr % n;\\n\\n                for (int[] dir : directions) {\\n                    int ni = currI + dir[0];\\n                    int nj = currJ + dir[1];\\n                    int neighbor = ni * n + nj;\\n\\n                    if (ni >= 0 && ni < m && nj >= 0 && nj < n && !visited.contains(neighbor)) {\\n                        if (grid[ni][nj] == 1) {\\n                            return level;\\n                        }\\n                        queue.offer(neighbor);\\n                        visited.add(neighbor);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return -1; // No bridge found\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j, Set<Integer> visited) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int curr = i * n + j;\\n\\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != 1 || visited.contains(curr)) {\\n            return;\\n        }\\n\\n        visited.add(curr);\\n\\n        for (int[] dir : directions) {\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            dfs(grid, ni, nj, visited);\\n        }\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int shortestBridge(vector<vector<int>>& A) {\\n        int m = A.size();\\n        int n = A[0].size();\\n\\n        // Step 1: Find the first island using DFS and mark its cells as visited\\n        bool found = false;\\n        unordered_set<int> visited;\\n        for (int i = 0; i < m; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (A[i][j] == 1) {\\n                    dfs(A, i, j, visited);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // Step 2: Perform BFS to find the shortest bridge to the second island\\n        queue<int> q;\\n        for (int cell : visited) {\\n            q.push(cell);\\n        }\\n\\n        vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int level = 0;\\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.front();\\n                q.pop();\\n\\n                int currI = curr / n;\\n                int currJ = curr % n;\\n\\n                for (auto dir : directions) {\\n                    int ni = currI + dir[0];\\n                    int nj = currJ + dir[1];\\n                    int neighbor = ni * n + nj;\\n\\n                    if (ni >= 0 && ni < m && nj >= 0 && nj < n && visited.find(neighbor) == visited.end()) {\\n                        if (A[ni][nj] == 1) {\\n                            return level;\\n                        }\\n                        q.push(neighbor);\\n                        visited.insert(neighbor);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return -1; // No bridge found\\n    }\\n\\nprivate:\\n    void dfs(vector<vector<int>>& A, int i, int j, unordered_set<int>& visited) {\\n        int m = A.size();\\n        int n = A[0].size();\\n\\n        if (i < 0 || i >= m || j < 0 || j >= n || A[i][j] != 1 || visited.find(i * n + j) != visited.end()) {\\n            return;\\n        }\\n\\n        visited.insert(i * n + j);\\n        vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n        for (auto dir : directions) {\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            dfs(A, ni, nj, visited);\\n        }\\n    }\\n};\\n```\\n\\n\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```Python []\\nclass Solution:\\n    def shortestBridge(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        start_i, start_j = next((i, j) for i in range(m) for j in range(n) if grid[i][j])\\n        \\n        \\n        stack = [(start_i, start_j)]\\n        visited = set(stack)\\n        while stack:\\n            i, j = stack.pop()\\n            visited.add((i, j))  \\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):\\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] and (ii, jj) not in visited:\\n                    stack.append((ii, jj))\\n                    visited.add((ii, jj))\\n        \\n        \\n        ans = 0\\n        queue = list(visited)\\n        while queue:\\n            new_queue = []\\n            for i, j in queue:\\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):\\n                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in visited:\\n                        if grid[ii][jj] == 1:\\n                            return ans\\n                        new_queue.append((ii, jj))\\n                        visited.add((ii, jj))\\n            queue = new_queue\\n            ans += 1\\n\\n```\n```Java []\\n\\nclass Solution {\\n    private int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    public int shortestBridge(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        int startI = -1;\\n        int startJ = -1;\\n        boolean found = false;\\n\\n        // Step 1: Find the first island using DFS\\n        for (int i = 0; i < m; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    startI = i;\\n                    startJ = j;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(grid, startI, startJ, visited);\\n\\n        // Step 2: Perform BFS from the first island to find the shortest bridge\\n        Queue<Integer> queue = new ArrayDeque<>(visited);\\n        int level = 0;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = queue.poll();\\n                int currI = curr / n;\\n                int currJ = curr % n;\\n\\n                for (int[] dir : directions) {\\n                    int ni = currI + dir[0];\\n                    int nj = currJ + dir[1];\\n                    int neighbor = ni * n + nj;\\n\\n                    if (ni >= 0 && ni < m && nj >= 0 && nj < n && !visited.contains(neighbor)) {\\n                        if (grid[ni][nj] == 1) {\\n                            return level;\\n                        }\\n                        queue.offer(neighbor);\\n                        visited.add(neighbor);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return -1; // No bridge found\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j, Set<Integer> visited) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int curr = i * n + j;\\n\\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != 1 || visited.contains(curr)) {\\n            return;\\n        }\\n\\n        visited.add(curr);\\n\\n        for (int[] dir : directions) {\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            dfs(grid, ni, nj, visited);\\n        }\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int shortestBridge(vector<vector<int>>& A) {\\n        int m = A.size();\\n        int n = A[0].size();\\n\\n        // Step 1: Find the first island using DFS and mark its cells as visited\\n        bool found = false;\\n        unordered_set<int> visited;\\n        for (int i = 0; i < m; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (A[i][j] == 1) {\\n                    dfs(A, i, j, visited);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // Step 2: Perform BFS to find the shortest bridge to the second island\\n        queue<int> q;\\n        for (int cell : visited) {\\n            q.push(cell);\\n        }\\n\\n        vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int level = 0;\\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.front();\\n                q.pop();\\n\\n                int currI = curr / n;\\n                int currJ = curr % n;\\n\\n                for (auto dir : directions) {\\n                    int ni = currI + dir[0];\\n                    int nj = currJ + dir[1];\\n                    int neighbor = ni * n + nj;\\n\\n                    if (ni >= 0 && ni < m && nj >= 0 && nj < n && visited.find(neighbor) == visited.end()) {\\n                        if (A[ni][nj] == 1) {\\n                            return level;\\n                        }\\n                        q.push(neighbor);\\n                        visited.insert(neighbor);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return -1; // No bridge found\\n    }\\n\\nprivate:\\n    void dfs(vector<vector<int>>& A, int i, int j, unordered_set<int>& visited) {\\n        int m = A.size();\\n        int n = A[0].size();\\n\\n        if (i < 0 || i >= m || j < 0 || j >= n || A[i][j] != 1 || visited.find(i * n + j) != visited.end()) {\\n            return;\\n        }\\n\\n        visited.insert(i * n + j);\\n        vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n        for (auto dir : directions) {\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            dfs(A, ni, nj, visited);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190421,
                "title": "java-extremely-easy-to-understand-with-comment-bfs-to-find-answer-and-dfs-to-paint-the-matrix",
                "content": "```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        paint(A); //paint one island with int 2\\n        Queue<int[]> q = new LinkedList<>(); //queue contains coordinates to do bfs\\n        boolean[][] visited = new boolean[A.length][A[0].length];\\n        \\n        for(int i = 0; i < A.length; i ++){//initialize queue with all coordinates with number 2\\n            for(int j = 0; j < A[0].length; j ++){\\n                if(A[i][j] == 2){\\n                    q.add(new int[]{i,j});\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        int level = 0;\\n        while(!q.isEmpty()){//level order bfs\\n            int size = q.size();\\n            for(int i = 0; i < size; i ++){\\n                int[] cur = q.poll();\\n                int x = cur[0];\\n                int y = cur[1];\\n                if(A[x][y] == 1){//found, then return\\n                    return level - 1;\\n                }\\n                if(x - 1 >= 0 && !visited[x - 1][y]){\\n                    q.add(new int[]{x - 1, y});\\n                    visited[x - 1][y] = true;\\n                }\\n                if(x + 1 < A.length && !visited[x + 1][y]){\\n                    q.add(new int[]{x + 1, y});\\n                    visited[x + 1][y] = true;\\n                }\\n                if(y - 1 >= 0 && !visited[x][y - 1]){\\n                    q.add(new int[]{x, y - 1});\\n                    visited[x][y - 1] = true;\\n                }\\n                if(y + 1 < A[0].length && !visited[x][y + 1]){\\n                    q.add(new int[]{x, y + 1});\\n                    visited[x][y + 1] = true;\\n                }\\n            }\\n            level ++; //next level\\n        }\\n        return -1;\\n    }\\n    \\n    public void paint(int[][] A){//paint one island with int 2\\n        for(int i = 0; i < A.length; i ++){\\n            for(int j = 0; j < A[0].length; j ++){\\n                if(A[i][j] == 1){\\n                    dfs(i, j, A);\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void dfs(int x, int y, int[][] A){//helper function for paint function\\n        if(x < 0 || x > A.length - 1 || y < 0 || y > A[0].length - 1 || A[x][y] != 1){\\n            return;\\n        }\\n        A[x][y] = 2;\\n        dfs(x - 1, y, A);\\n        dfs(x + 1, y, A);\\n        dfs(x, y - 1, A);\\n        dfs(x, y + 1, A);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        paint(A); //paint one island with int 2\\n        Queue<int[]> q = new LinkedList<>(); //queue contains coordinates to do bfs\\n        boolean[][] visited = new boolean[A.length][A[0].length];\\n        \\n        for(int i = 0; i < A.length; i ++){//initialize queue with all coordinates with number 2\\n            for(int j = 0; j < A[0].length; j ++){\\n                if(A[i][j] == 2){\\n                    q.add(new int[]{i,j});\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        int level = 0;\\n        while(!q.isEmpty()){//level order bfs\\n            int size = q.size();\\n            for(int i = 0; i < size; i ++){\\n                int[] cur = q.poll();\\n                int x = cur[0];\\n                int y = cur[1];\\n                if(A[x][y] == 1){//found, then return\\n                    return level - 1;\\n                }\\n                if(x - 1 >= 0 && !visited[x - 1][y]){\\n                    q.add(new int[]{x - 1, y});\\n                    visited[x - 1][y] = true;\\n                }\\n                if(x + 1 < A.length && !visited[x + 1][y]){\\n                    q.add(new int[]{x + 1, y});\\n                    visited[x + 1][y] = true;\\n                }\\n                if(y - 1 >= 0 && !visited[x][y - 1]){\\n                    q.add(new int[]{x, y - 1});\\n                    visited[x][y - 1] = true;\\n                }\\n                if(y + 1 < A[0].length && !visited[x][y + 1]){\\n                    q.add(new int[]{x, y + 1});\\n                    visited[x][y + 1] = true;\\n                }\\n            }\\n            level ++; //next level\\n        }\\n        return -1;\\n    }\\n    \\n    public void paint(int[][] A){//paint one island with int 2\\n        for(int i = 0; i < A.length; i ++){\\n            for(int j = 0; j < A[0].length; j ++){\\n                if(A[i][j] == 1){\\n                    dfs(i, j, A);\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void dfs(int x, int y, int[][] A){//helper function for paint function\\n        if(x < 0 || x > A.length - 1 || y < 0 || y > A[0].length - 1 || A[x][y] != 1){\\n            return;\\n        }\\n        A[x][y] = 2;\\n        dfs(x - 1, y, A);\\n        dfs(x + 1, y, A);\\n        dfs(x, y - 1, A);\\n        dfs(x, y + 1, A);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958926,
                "title": "python3-dfs-bfs",
                "content": "**Algo**\\nLocate the one island via DFS and expand its boundary via BFS until the other island is found. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        i, j = next((i, j) for i in range(m) for j in range(n) if A[i][j])\\n        \\n        # dfs \\n        stack = [(i, j)]\\n        seen = set(stack)\\n        while stack: \\n            i, j = stack.pop()\\n            seen.add((i, j)) # mark as visited \\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and A[ii][jj] and (ii, jj) not in seen: \\n                    stack.append((ii, jj))\\n                    seen.add((ii, jj))\\n        \\n        # bfs \\n        ans = 0\\n        queue = list(seen)\\n        while queue:\\n            newq = []\\n            for i, j in queue: \\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen: \\n                        if A[ii][jj] == 1: return ans \\n                        newq.append((ii, jj))\\n                        seen.add((ii, jj))\\n            queue = newq\\n            ans += 1\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        i, j = next((i, j) for i in range(m) for j in range(n) if A[i][j])\\n        \\n        # dfs \\n        stack = [(i, j)]\\n        seen = set(stack)\\n        while stack: \\n            i, j = stack.pop()\\n            seen.add((i, j)) # mark as visited \\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and A[ii][jj] and (ii, jj) not in seen: \\n                    stack.append((ii, jj))\\n                    seen.add((ii, jj))\\n        \\n        # bfs \\n        ans = 0\\n        queue = list(seen)\\n        while queue:\\n            newq = []\\n            for i, j in queue: \\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen: \\n                        if A[ii][jj] == 1: return ans \\n                        newq.append((ii, jj))\\n                        seen.add((ii, jj))\\n            queue = newq\\n            ans += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189286,
                "title": "c-flood-fill-solution-with-explanation",
                "content": "1. Use a set of pairs to store island coordinates (A, B)\n2. Use [flood fill](https://en.wikipedia.org/wiki/Flood_fill) to find islands\n3. Simply calculate distance between all points in the islands and return the minimum\n\nCheck out my YouTube channel for more solutions: [https://youtube.com/c/codereport](https://youtube.com/c/codereport)\n\n```\n\n#define FORI(s,n) for(int i = s; i < n; i++)\n#define FORJ(s,n) for(int j = s; j < n; j++)\n\nusing vi  = vector<int>;\nusing vvi = vector<vi>;\nusing island = set<pair<int, int>>;\n\nclass Solution {\npublic:\n\n   int n;\n   vi dx = { 0, 0, 1, -1 };\n   vi dy = { 1, -1, 0, 0 };\n\n   bool is_valid(int x, int y) {\n      return (x >= 0 && x < n && y >= 0 && y < n);\n   }\n\n   void flood_fill(island& A, const vvi& g, int x, int y) {\n      A.insert({ x, y });\n      FORI(0, 4) {\n         int nx = x + dx[i];\n         int ny = y + dy[i];\n         if (is_valid(nx, ny) && g[nx][ny] && !A.count({ nx, ny }))\n            flood_fill(A, g, nx, ny);\n      }\n   }\n\n   template<class T>\n   int dist(T a, T b) {\n      return abs(a.first - b.first) + abs(a.second - b.second) - 1;\n   }\n\n   int shortestBridge(vvi& g) {\n      n = g.size();\n      island A, B;\n\n      // discover the islands using flood fill\n      FORI(0, n) {\n         FORJ(0, n) {\n            if (g[i][j] == 0) continue;\n            if (A.empty())\n               flood_fill(A, g, i, j);\n            else if (B.empty() && !A.count({ i, j }))\n               flood_fill(B, g, i, j);\n         }\n      }\n\n      // calculate the distance between points in the islands\n      int ans = 2 * n;\n      for (auto i : A) {\n         for (auto j : B) {\n            ans = min(ans, dist(i, j));\n         }\n      }\n\n      return ans;\n   }\n};",
                "solutionTags": [],
                "code": "class Solution {\npublic:\n\n   int n;\n   vi dx = { 0, 0, 1, -1 }",
                "codeTag": "Java"
            },
            {
                "id": 2033952,
                "title": "python-bfs-dfs-easy-and-efficient-solution-with-explanation",
                "content": "**As given in question , there are only two islands in given grid. so what we can do is just find the min distance of one island from other by changing the values of any one island from 1 to $ (we can use anything  except 0 and 1) using dfs function and appending those indices to queue. The motive of doing this is that we\\'ll use bfs to search for 1(other island) and will return it\\'s distance.**\\n\\n```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        def dfs(r, c) :\\n            if grid[r][c] == 1 :\\n                q.append((r, c, 0))\\n                grid[r][c] = \\'$\\'\\n                if r-1 >= 0 : dfs(r-1, c)\\n                if r+1 < len(grid) : dfs(r+1, c)\\n                if c-1 >= 0 : dfs(r, c-1)\\n                if c+1 < len(grid) : dfs(r, c+1)\\n        \\n        def bfs(q) :\\n            seen = set()\\n            while q :\\n                i, j, d = q.popleft()\\n                if grid[i][j] == 1 :\\n                    return d\\n                else :\\n                    for x, y in ((i-1, j), (i, j-1), (i+1, j), (i, j+1)) :\\n                        if 0 <= x < len(grid) and 0 <= y < len(grid[0]) : \\n                            if (x, y) not in seen :\\n                                seen.add((x, y))\\n                                q.append((x, y, d+1))\\n        \\n        q = deque()\\n        flag = False\\n        for i in range(len(grid)) :\\n            for j in range(len(grid[0])) :\\n                if grid[i][j] == 1 :\\n                    dfs(i, j)\\n                    flag = True\\n                    break\\n            if flag :\\n                break\\n        \\n        return bfs(q) - 1\\n```\\n\\n**Feel free to ask any question ...\\nPls do upvote , if it helps even a bit :-)**",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        def dfs(r, c) :\\n            if grid[r][c] == 1 :\\n                q.append((r, c, 0))\\n                grid[r][c] = \\'$\\'\\n                if r-1 >= 0 : dfs(r-1, c)\\n                if r+1 < len(grid) : dfs(r+1, c)\\n                if c-1 >= 0 : dfs(r, c-1)\\n                if c+1 < len(grid) : dfs(r, c+1)\\n        \\n        def bfs(q) :\\n            seen = set()\\n            while q :\\n                i, j, d = q.popleft()\\n                if grid[i][j] == 1 :\\n                    return d\\n                else :\\n                    for x, y in ((i-1, j), (i, j-1), (i+1, j), (i, j+1)) :\\n                        if 0 <= x < len(grid) and 0 <= y < len(grid[0]) : \\n                            if (x, y) not in seen :\\n                                seen.add((x, y))\\n                                q.append((x, y, d+1))\\n        \\n        q = deque()\\n        flag = False\\n        for i in range(len(grid)) :\\n            for j in range(len(grid[0])) :\\n                if grid[i][j] == 1 :\\n                    dfs(i, j)\\n                    flag = True\\n                    break\\n            if flag :\\n                break\\n        \\n        return bfs(q) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189235,
                "title": "java-bidirectional-bfs",
                "content": "```A[x][y]=0```: it is an unexplored empty cell\\n```A[x][y]=1```: it is an island to be explored\\n```A[x][y]=2```: it is an island that has been explored\\n```A[x][y]=3```: this cell is already captured by island a\\n```A[x][y]=4```: this cell is already captured by island b\\n\\nFirst there are only 0 and 1 in board, we store island A in ```qa```, and island B in ```qb```. Then we do BFS from those 2 islands, step by step. When one island reaches a cell that has been captured by the other island, we return the cost stored in ```res```.\\n\\n```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        Queue<int[]> qa= new LinkedList<>();\\n        Queue<int[]> qb= new LinkedList<>();\\n        int m=A.length, n=A[0].length;\\n        for (int i=0; i<m; i++){\\n            for (int j=0; j<n; j++){\\n                if (A[i][j]==1) {\\n                    if (qa.isEmpty()) dfs(A, i, j, qa);\\n                    else dfs(A, i, j, qb);\\n                }\\n            }\\n        }\\n        int res=0;\\n        int[] d= new int[]{0,1,0,-1,0};\\n        while (!qa.isEmpty() && !qb.isEmpty()){\\n            for (int size=qa.size(); size>0; size--){\\n                int[] cur= qa.poll();\\n                for (int k=0; k<4; k++){\\n                    int x= cur[0]+d[k], y= cur[1]+d[k+1];\\n                    if (x<0 || x>=m || y<0 || y>=n || A[x][y]==3 || A[x][y]==2) continue; // Thanks Evolut1on for pointing this out, we can also skip A[x][y]==2\\n                    if (A[x][y]==4) return res;\\n                    A[x][y]=3;\\n                    qa.add(new int[]{x, y});\\n                }\\n            }\\n            for (int size=qb.size(); size>0; size--){\\n                int[] cur= qb.poll();\\n                for (int k=0; k<4; k++){\\n                    int x= cur[0]+d[k], y= cur[1]+d[k+1];\\n                    if (x<0 || x>=m || y<0 || y>=n || A[x][y]==4 || A[x][y]==2) continue; \\n                    if (A[x][y]==3) return res+1;\\n                    A[x][y]=4;\\n                    qb.add(new int[]{x, y});\\n                }\\n            }\\n            res+=2;\\n        }\\n        return 1;\\n    }\\n    public void dfs(int[][] A, int i, int j, Queue<int[]> q){\\n        int m=A.length, n=A[0].length;\\n        if (i<0 || i>=m || j<0 || j>=n || A[i][j]!=1) return;\\n        q.add(new int[]{i, j});\\n        A[i][j]=2;\\n        dfs(A, i+1, j, q);\\n        dfs(A, i-1, j, q);\\n        dfs(A, i, j+1, q);\\n        dfs(A, i, j-1, q);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```A[x][y]=0```\n```A[x][y]=1```\n```A[x][y]=2```\n```A[x][y]=3```\n```A[x][y]=4```\n```qa```\n```qb```\n```res```\n```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        Queue<int[]> qa= new LinkedList<>();\\n        Queue<int[]> qb= new LinkedList<>();\\n        int m=A.length, n=A[0].length;\\n        for (int i=0; i<m; i++){\\n            for (int j=0; j<n; j++){\\n                if (A[i][j]==1) {\\n                    if (qa.isEmpty()) dfs(A, i, j, qa);\\n                    else dfs(A, i, j, qb);\\n                }\\n            }\\n        }\\n        int res=0;\\n        int[] d= new int[]{0,1,0,-1,0};\\n        while (!qa.isEmpty() && !qb.isEmpty()){\\n            for (int size=qa.size(); size>0; size--){\\n                int[] cur= qa.poll();\\n                for (int k=0; k<4; k++){\\n                    int x= cur[0]+d[k], y= cur[1]+d[k+1];\\n                    if (x<0 || x>=m || y<0 || y>=n || A[x][y]==3 || A[x][y]==2) continue; // Thanks Evolut1on for pointing this out, we can also skip A[x][y]==2\\n                    if (A[x][y]==4) return res;\\n                    A[x][y]=3;\\n                    qa.add(new int[]{x, y});\\n                }\\n            }\\n            for (int size=qb.size(); size>0; size--){\\n                int[] cur= qb.poll();\\n                for (int k=0; k<4; k++){\\n                    int x= cur[0]+d[k], y= cur[1]+d[k+1];\\n                    if (x<0 || x>=m || y<0 || y>=n || A[x][y]==4 || A[x][y]==2) continue; \\n                    if (A[x][y]==3) return res+1;\\n                    A[x][y]=4;\\n                    qb.add(new int[]{x, y});\\n                }\\n            }\\n            res+=2;\\n        }\\n        return 1;\\n    }\\n    public void dfs(int[][] A, int i, int j, Queue<int[]> q){\\n        int m=A.length, n=A[0].length;\\n        if (i<0 || i>=m || j<0 || j>=n || A[i][j]!=1) return;\\n        q.add(new int[]{i, j});\\n        A[i][j]=2;\\n        dfs(A, i+1, j, q);\\n        dfs(A, i-1, j, q);\\n        dfs(A, i, j+1, q);\\n        dfs(A, i, j-1, q);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535290,
                "title": "graph-expansion",
                "content": "Thanks @votrubac for the original post https://leetcode.com/problems/shortest-bridge/discuss/189293/C%2B%2B-BFS-Island-Expansion-%2B-UF-Bonus.\\n\\nIn order to find the shortest path between two islands, we have to uniquely **identify each island** first -- by marking the first island to `2`s, then `1`s indicate the second island.\\n\\nIt\\'s hard to tell which two cells form the shortest path between two islands.\\n\\nWe **expand one island** by marking its adjacent cells round by round, until it reachs the second island. The number of rounds marked is the shortest path.\\n\\n\\n```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        rows, cols = len(grid), len(grid[0])\\n        pos_incs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n                \\n        def mark_2(i, j):\\n            \"\"\"Mark the island (of grid[i][j]) as 2s.\"\"\"\\n            grid[i][j] = 2\\n            \\n            for i_inc, j_inc in pos_incs:\\n                ni, nj = i + i_inc, j + j_inc\\n                if ni >= 0 and nj >= 0 and ni < rows and nj < cols and grid[ni][nj] == 1:\\n                    mark_2(ni, nj)\\n\\n        # Mark the first island to 2s\\n        marked = False\\n        for i in range(rows):\\n            if not marked:\\n                for j in range(cols):\\n                    if not marked and grid[i][j] == 1:\\n                        mark_2(i, j)\\n                        marked = True\\n        \\n        def expand(i, j, mark) -> bool:\\n            \"\"\"Expand the island (of grid[i][j]) with the given mark.\"\"\"\\n            for i_inc, j_inc in pos_incs:\\n                ni, nj = i + i_inc, j + j_inc\\n                if ni >= 0 and nj >= 0 and ni < rows and nj < cols:\\n                    if grid[ni][nj] == 1:\\n                        return True\\n                    elif grid[ni][nj] == 0:\\n                        grid[ni][nj] = mark\\n\\n            return False\\n        \\n        # Expland the first island as follows:\\n        #\\n        #  2    # mark = 2; island\\n        #\\n        #  3\\n        # 323   # mark = 3; after expanding once\\n        #  3\\n        #\\n        #  4\\n        # 434\\n        #43234  # mark = 4; after expanding twice\\n        # 434\\n        #  4  \\n        mark = 2\\n        while True:\\n            for i in range(rows):\\n                for j in range(cols):\\n                    if grid[i][j] == mark and expand(i, j, mark + 1):\\n                        return mark - 2\\n            mark += 1\\n                    \\n        raise Exception(\\'Impossible\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        rows, cols = len(grid), len(grid[0])\\n        pos_incs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n                \\n        def mark_2(i, j):\\n            \"\"\"Mark the island (of grid[i][j]) as 2s.\"\"\"\\n            grid[i][j] = 2\\n            \\n            for i_inc, j_inc in pos_incs:\\n                ni, nj = i + i_inc, j + j_inc\\n                if ni >= 0 and nj >= 0 and ni < rows and nj < cols and grid[ni][nj] == 1:\\n                    mark_2(ni, nj)\\n\\n        # Mark the first island to 2s\\n        marked = False\\n        for i in range(rows):\\n            if not marked:\\n                for j in range(cols):\\n                    if not marked and grid[i][j] == 1:\\n                        mark_2(i, j)\\n                        marked = True\\n        \\n        def expand(i, j, mark) -> bool:\\n            \"\"\"Expand the island (of grid[i][j]) with the given mark.\"\"\"\\n            for i_inc, j_inc in pos_incs:\\n                ni, nj = i + i_inc, j + j_inc\\n                if ni >= 0 and nj >= 0 and ni < rows and nj < cols:\\n                    if grid[ni][nj] == 1:\\n                        return True\\n                    elif grid[ni][nj] == 0:\\n                        grid[ni][nj] = mark\\n\\n            return False\\n        \\n        # Expland the first island as follows:\\n        #\\n        #  2    # mark = 2; island\\n        #\\n        #  3\\n        # 323   # mark = 3; after expanding once\\n        #  3\\n        #\\n        #  4\\n        # 434\\n        #43234  # mark = 4; after expanding twice\\n        # 434\\n        #  4  \\n        mark = 2\\n        while True:\\n            for i in range(rows):\\n                for j in range(cols):\\n                    if grid[i][j] == mark and expand(i, j, mark + 1):\\n                        return mark - 2\\n            mark += 1\\n                    \\n        raise Exception(\\'Impossible\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547333,
                "title": "c-bfs-dfs",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    queue<pair<int, int>> q;\\n    void change(vector<vector<int>> &grid, int x, int y)\\n    {\\n        q.push({x, y});\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        grid[x][y] = 2;\\n        for (int k = 0; k < 4; k++)\\n        {\\n            int nx = x + dx[k];\\n            int ny = y + dy[k];\\n            if (nx >= 0 && ny >= 0 && nx < n && ny < m && grid[nx][ny] == 1)\\n            {\\n                change(grid, nx, ny);\\n            }\\n        }\\n    }\\n    int shortestBridge(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        bool f = false;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j])\\n                {\\n                    change(grid, i, j);\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            if (f)\\n                break;\\n        }\\n        int ans = 0;\\n        while (q.size())\\n        {\\n            int total = q.size();\\n            ans++;\\n            while (total--)\\n            {\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                for (int i = 0; i < 4; i++)\\n                {\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[i];\\n                    if (nx >= 0 && ny >= 0 && nx < n && ny < m)\\n                    {\\n                        if (grid[nx][ny] == 1)\\n                            return ans - 1;\\n                        else if (grid[nx][ny] == 0)\\n                        {\\n                            grid[nx][ny] = 2;\\n                            q.push({nx, ny});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/6686c30f-5233-4c9d-80cb-b12ddf619d98_1684647664.092938.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    queue<pair<int, int>> q;\\n    void change(vector<vector<int>> &grid, int x, int y)\\n    {\\n        q.push({x, y});\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        grid[x][y] = 2;\\n        for (int k = 0; k < 4; k++)\\n        {\\n            int nx = x + dx[k];\\n            int ny = y + dy[k];\\n            if (nx >= 0 && ny >= 0 && nx < n && ny < m && grid[nx][ny] == 1)\\n            {\\n                change(grid, nx, ny);\\n            }\\n        }\\n    }\\n    int shortestBridge(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        bool f = false;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j])\\n                {\\n                    change(grid, i, j);\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            if (f)\\n                break;\\n        }\\n        int ans = 0;\\n        while (q.size())\\n        {\\n            int total = q.size();\\n            ans++;\\n            while (total--)\\n            {\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                for (int i = 0; i < 4; i++)\\n                {\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[i];\\n                    if (nx >= 0 && ny >= 0 && nx < n && ny < m)\\n                    {\\n                        if (grid[nx][ny] == 1)\\n                            return ans - 1;\\n                        else if (grid[nx][ny] == 0)\\n                        {\\n                            grid[nx][ny] = 2;\\n                            q.push({nx, ny});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189415,
                "title": "c-using-dfs-to-find-island-perimeters-then-manhattan-distances",
                "content": "We store a set of perimeter nodes of both the islands in two sets. Then return the minimum manhattan distance between the two perimeters.\n\n```\nclass Solution {\n    set<pair<int,int>> perimiter_1;\n    set<pair<int,int>> perimiter_2;\n    vector<vector<int>> matrix;\n    vector<vector<bool>> visited;\n    int m,n;\npublic:\n    int shortestBridge(vector<vector<int>>& A) {\n        m = A.size();\n        n = A[0].size();\n        matrix = A;\n        \n        visited.resize(m,vector<bool>(n,0));\n        \n        int i,j;\n        bool first_found = false; // to track if the perimeter is of island 1 or 2.\n        for(i = 0; i<m;i++){\n            for(j = 0; j<n ; j++){\n                if(A[i][j] && !visited[i][j]){\n                    find_perimeter(i,j,first_found);\n                    first_found = true;\n                }\n            }\n        }\n        \n        int result = INT_MAX;\n        \n        //compute manhatan distance between all possible perimeter combinations and return minimum distance.\n        for(auto& p1 : perimiter_1){\n            for(auto& p2 : perimiter_2){\n                result = min(result, abs(p1.first - p2.first) + abs(p1.second - p2.second) -1 );\n            }\n        }\n        return result;\n    }\n    \n    int numofneighbour(int i, int j) \n    { \n        int count = 0; \n        if (i > 0 && matrix[i - 1][j]) \n            count++; \n        if (j > 0 && matrix[i][j - 1]) \n            count++;  \n        if (i < m-1 && matrix[i + 1][j]) \n            count++; \n        if (j < n-1 && matrix[i][j + 1]) \n            count++; \n\n        return count; \n    } \n    \n    void find_perimeter(int i, int j, bool& first_found){\n        if(i<0 || j<0 || i>=m||j>=n||matrix[i][j] == 0||visited[i][j])\n            return;\n        visited[i][j] = 1;\n        \n        find_perimeter(i+1,j,first_found);\n        find_perimeter(i-1,j,first_found);\n        find_perimeter(i,j+1,first_found);\n        find_perimeter(i,j-1,first_found);\n        \n        // if number of neighbours is less than 4 then it's a perimeter node. Insert it in the appropriate set.\n        if(numofneighbour(i,j) < 4){\n            if(!first_found)\n                perimiter_1.insert(make_pair(i,j));\n            else\n                perimiter_2.insert(make_pair(i,j));\n        }\n        \n        return;\n        \n    }\n};\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\nclass Solution {\n    set<pair<int,int>> perimiter_1;\n    set<pair<int,int>> perimiter_2;\n    vector<vector<int>> matrix;\n    vector<vector<bool>> visited;\n    int m,n;\npublic:\n    int shortestBridge(vector<vector<int>>& A) {\n        m = A.size();\n        n = A[0].size();\n        matrix = A;\n        \n        visited.resize(m,vector<bool>(n,0));\n        \n        int i,j;\n        bool first_found = false; // to track if the perimeter is of island 1 or 2.\n        for(i = 0; i<m;i++){\n            for(j = 0; j<n ; j++){\n                if(A[i][j] && !visited[i][j]){\n                    find_perimeter(i,j,first_found);\n                    first_found = true;\n                }\n            }\n        }\n        \n        int result = INT_MAX;\n        \n        //compute manhatan distance between all possible perimeter combinations and return minimum distance.\n        for(auto& p1 : perimiter_1){\n            for(auto& p2 : perimiter_2){\n                result = min(result, abs(p1.first - p2.first) + abs(p1.second - p2.second) -1 );\n            }\n        }\n        return result;\n    }\n    \n    int numofneighbour(int i, int j) \n    { \n        int count = 0; \n        if (i > 0 && matrix[i - 1][j]) \n            count++; \n        if (j > 0 && matrix[i][j - 1]) \n            count++;  \n        if (i < m-1 && matrix[i + 1][j]) \n            count++; \n        if (j < n-1 && matrix[i][j + 1]) \n            count++; \n\n        return count; \n    } \n    \n    void find_perimeter(int i, int j, bool& first_found){\n        if(i<0 || j<0 || i>=m||j>=n||matrix[i][j] == 0||visited[i][j])\n            return;\n        visited[i][j] = 1;\n        \n        find_perimeter(i+1,j,first_found);\n        find_perimeter(i-1,j,first_found);\n        find_perimeter(i,j+1,first_found);\n        find_perimeter(i,j-1,first_found);\n        \n        // if number of neighbours is less than 4 then it's a perimeter node. Insert it in the appropriate set.\n        if(numofneighbour(i,j) < 4){\n            if(!first_found)\n                perimiter_1.insert(make_pair(i,j));\n            else\n                perimiter_2.insert(make_pair(i,j));\n        }\n        \n        return;\n        \n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811188,
                "title": "shortest-bridge-idea-and-then-approach-in-code",
                "content": "Hey everyone hope you\\'re having a great day. So about this question , its simply an idea to fill and chage one island to a diffrent type and as there are only 2 of them so we could easily distinguish between the islands.\\nThe idea is we change one island to some dif. colour and then start a bfs from every of its node and see if we could reach the other island and as bfs gives us the shortest path , as soon as we touch the other island we will know that we are on it and could easily return the dist.\\n```\\nbool isValid(int i, int j, vector<vector<int>> &grid){   \\n        if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] == 0 || grid[i][j] == -1)\\n            return false;\\n        else\\n            return true;\\n    }\\n    void dfs(int i, int j, vector<vector<int>> &grid , queue<pair<int ,int>>& q){\\n        \\n        if(isValid(i, j, grid) == false)\\n            return;\\n\\n        q.push({i,j});\\n        \\n        grid[i][j] = -1;\\n\\n        dfs(i + 1, j, grid , q);\\n        dfs(i - 1, j, grid , q);\\n        dfs(i, j + 1, grid , q);\\n        dfs(i, j - 1, grid , q);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<pair<int ,int>> dis = {{1 ,0} , {-1 , 0} , {0 , 1} , {0 , -1}};\\n        \\n        queue<pair<int , int>> q;\\n        \\n        bool brk = false;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(grid[i][j] == 1){\\n                    dfs(i , j , grid , q);\\n                    brk = true;\\n                    break;\\n                }\\n            }\\n            if(brk){\\n                break;\\n            }\\n        }\\n        int dist = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                auto front = q.front();\\n                q.pop();\\n            \\n                int x = front.first;\\n                int y = front.second;\\n            \\n                for(int i = 0 ; i < 4 ; i++){\\n                    int adj_x = x + dis[i].first;\\n                    int adj_y = y + dis[i].second;\\n                \\n                    if(adj_x < 0 || adj_y < 0 || adj_x >= n || adj_y >= n || grid[adj_x][adj_y] == -1){\\n                        continue;\\n                    }\\n                    if(grid[adj_x][adj_y] == 1){\\n                        return dist;\\n                    }\\n                    grid[adj_x][adj_y] = -1;\\n                    q.push({adj_x , adj_y});\\n                }   \\n            }\\n        dist++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nbool isValid(int i, int j, vector<vector<int>> &grid){   \\n        if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] == 0 || grid[i][j] == -1)\\n            return false;\\n        else\\n            return true;\\n    }\\n    void dfs(int i, int j, vector<vector<int>> &grid , queue<pair<int ,int>>& q){\\n        \\n        if(isValid(i, j, grid) == false)\\n            return;\\n\\n        q.push({i,j});\\n        \\n        grid[i][j] = -1;\\n\\n        dfs(i + 1, j, grid , q);\\n        dfs(i - 1, j, grid , q);\\n        dfs(i, j + 1, grid , q);\\n        dfs(i, j - 1, grid , q);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<pair<int ,int>> dis = {{1 ,0} , {-1 , 0} , {0 , 1} , {0 , -1}};\\n        \\n        queue<pair<int , int>> q;\\n        \\n        bool brk = false;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(grid[i][j] == 1){\\n                    dfs(i , j , grid , q);\\n                    brk = true;\\n                    break;\\n                }\\n            }\\n            if(brk){\\n                break;\\n            }\\n        }\\n        int dist = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                auto front = q.front();\\n                q.pop();\\n            \\n                int x = front.first;\\n                int y = front.second;\\n            \\n                for(int i = 0 ; i < 4 ; i++){\\n                    int adj_x = x + dis[i].first;\\n                    int adj_y = y + dis[i].second;\\n                \\n                    if(adj_x < 0 || adj_y < 0 || adj_x >= n || adj_y >= n || grid[adj_x][adj_y] == -1){\\n                        continue;\\n                    }\\n                    if(grid[adj_x][adj_y] == 1){\\n                        return dist;\\n                    }\\n                    grid[adj_x][adj_y] = -1;\\n                    q.push({adj_x , adj_y});\\n                }   \\n            }\\n        dist++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 677890,
                "title": "python-dfs-w-explanation",
                "content": "IDEA:\\n1. Paint the first encountered island with the color \\'2\\' \\n2. Start expanding this island by painting connected \\'empty\\' cells\\n3. For every successive round, increase value of \\'color\\' by 1 (This helps us keep track of the number of steps required)\\n4. End when we bump into an island i.e. when we encounter a cell with value \\'1\\' (original island which wasn\\'t colored \\'2\\')\\n5. The answer is the difference of the current color value and \\'2\\' (the starting color) \\n\\n```\\nclass Solution:\\n    \\n    # Assigining \\'2\\' to one of the islands\\n    def paint(self, A, i, j):\\n        if i >= len(A) or i < 0 or j < 0 or j >= len(A[0]) or A[i][j] == 0 or A[i][j] == 2:\\n            return\\n        A[i][j] = 2\\n        for nb in [(0,1),(0,-1),(1,0),(-1,0)]:\\n            self.paint(A, i + nb[0], j + nb[1])\\n\\n    # expanding from the perimeter of the island & incrementing color with every next outward move\\n    def expand(self, A, i, j, color):\\n        if i >= len(A) or i < 0 or j < 0 or j >= len(A[0]):\\n            return False\\n        if A[i][j] == 0:\\n            A[i][j] = color + 1\\n        return A[i][j] == 1\\n\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        if not A:\\n            return 0\\n        m, n, flag = len(A), len(A[0]), False\\n        \\n        # Finding and coloring the first encountered island\\n        for i in range(m):\\n            if flag:\\n                break\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    self.paint(A, i, j)\\n                    flag = True\\n                    break\\n        \\n        # Growing outward and tracking number of steps taken to bump into other island\\n        for color in range(2, 2+m+n+1):\\n            for i in range(m):\\n                for j in range(n):\\n                    if A[i][j] == color and ( self.expand(A, i-1, j, color) or self.expand(A, i, j+1, color) or\\n                                              self.expand(A, i+1, j, color) or self.expand(A, i, j-1, color)):\\n                        return color-2\\n\\n```\\n\\nRefrence: https://leetcode.com/problems/shortest-bridge/discuss/189293/C%2B%2B-BFS-Island-Expansion-%2B-UF-Bonus (Amazing answer with elaborate pictorial explanation)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Assigining \\'2\\' to one of the islands\\n    def paint(self, A, i, j):\\n        if i >= len(A) or i < 0 or j < 0 or j >= len(A[0]) or A[i][j] == 0 or A[i][j] == 2:\\n            return\\n        A[i][j] = 2\\n        for nb in [(0,1),(0,-1),(1,0),(-1,0)]:\\n            self.paint(A, i + nb[0], j + nb[1])\\n\\n    # expanding from the perimeter of the island & incrementing color with every next outward move\\n    def expand(self, A, i, j, color):\\n        if i >= len(A) or i < 0 or j < 0 or j >= len(A[0]):\\n            return False\\n        if A[i][j] == 0:\\n            A[i][j] = color + 1\\n        return A[i][j] == 1\\n\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        if not A:\\n            return 0\\n        m, n, flag = len(A), len(A[0]), False\\n        \\n        # Finding and coloring the first encountered island\\n        for i in range(m):\\n            if flag:\\n                break\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    self.paint(A, i, j)\\n                    flag = True\\n                    break\\n        \\n        # Growing outward and tracking number of steps taken to bump into other island\\n        for color in range(2, 2+m+n+1):\\n            for i in range(m):\\n                for j in range(n):\\n                    if A[i][j] == color and ( self.expand(A, i-1, j, color) or self.expand(A, i, j+1, color) or\\n                                              self.expand(A, i+1, j, color) or self.expand(A, i, j-1, color)):\\n                        return color-2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231812,
                "title": "c-just-using-dfs-find-the-island",
                "content": "We have exactly two islands. Using DFS update the cell of any one island as 2. Now we have two type of Islands( Island with cell value->1 & Island with cell value->2). Then take two pair vector to store the coordinates of island of type 1 and type 2.  Then iterate over the pair vector of Island of type 1 and type 2. Update the **res=min(res, |x1-x2|+|y1-y2|-1)** in each iterations.\\n\\n|x1-x2|+|y1-y2|-1 to just count the number of cells between two island.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i, int j, vector<vector<int>>& vis, vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==0 || vis[i][j]==1)\\n            return ;\\n        \\n        grid[i][j]=2;\\n        vis[i][j]=1;\\n        \\n        dfs(i-1, j, vis, grid);\\n        dfs(i, j-1, vis, grid);\\n        dfs(i, j+1, vis, grid);\\n        dfs(i+1, j, vis, grid);\\n    }\\n    \\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int x, y;\\n        vector<vector<int>>vis(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]==1)\\n                {\\n                    x=i, y=j;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        dfs(x, y, vis, grid);\\n        \\n        \\n        int minflip=INT_MAX;\\n        \\n        vector<pair<int, int>>v1, v2;\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                \\n                if(grid[i][j]==1){\\n                    v1.push_back({i, j}); \\n                }\\n                else if(grid[i][j]==2){\\n                    v2.push_back({i, j}); \\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<v1.size(); i++){\\n            \\n            for(int j=0; j<v2.size(); j++){\\n                \\n                minflip=min(minflip, abs(v1[i].first-v2[j].first)+abs(v1[i].second-v2[j].second)-1);\\n            }\\n        }\\n        \\n        return minflip;\\n    }\\n};\\n\\n\\n\\n\\nPlease Upvote!!",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(int i, int j, vector<vector<int>>& vis, vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==0 || vis[i][j]==1)\\n            return ;\\n        \\n        grid[i][j]=2;\\n        vis[i][j]=1;\\n        \\n        dfs(i-1, j, vis, grid);\\n        dfs(i, j-1, vis, grid);\\n        dfs(i, j+1, vis, grid);\\n        dfs(i+1, j, vis, grid);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 787170,
                "title": "java-dfs-bfs-6ms-time-more-than-97-concise-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic void dfs(int a[][], int i, int j) {\\n\\t\\t\\tif (i < 0 || i >= a.length || j < 0 ||  j >= a[0].length || a[i][j] == 0 || a[i][j] == 2) return;\\n\\t\\t\\ta[i][j] = 2;\\n\\t\\t\\tdfs(a,i-1,j);dfs(a,i+1,j);dfs(a,i,j-1);dfs(a,i,j+1);\\n\\t\\t}\\n\\t\\tpublic int shortestBridge(int[][] a) {\\n\\t\\t\\tboolean found = false;\\n\\t\\t\\tQueue<int[]> q = new LinkedList<>();\\n\\t\\t\\tfor (int i = 0; i < a.length; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < a[0].length; j++) {\\n\\t\\t\\t\\t\\t if (a[i][j] == 1 && !found) {\\n\\t\\t\\t\\t\\t\\t found = true;\\n\\t\\t\\t\\t\\t\\t dfs(a,i,j);\\n\\t\\t\\t\\t\\t }\\n\\t\\t\\t\\t\\tif (found && a[i][j] == 1) q.add(new int[]{i,j});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\twhile (!q.isEmpty()) {\\n\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\tfor (int c = 0; c < size; c++) {\\n\\t\\t\\t\\t\\tint b[] = q.remove();\\n\\t\\t\\t\\t\\tint i = b[0];\\n\\t\\t\\t\\t\\tint j = b[1];\\n\\t\\t\\t\\t\\tif ((i > 0 && a[i-1][j] == 2) || (i < a.length-1 && a[i+1][j] == 2) || (j > 0 && a[i][j-1] == 2) || \\n\\t\\t\\t\\t\\t\\t(j < a[0].length-1 && a[i][j+1] == 2)) return ans;\\n\\t\\t\\t\\t\\tif (i > 0 && a[i-1][j] == 0) {\\n\\t\\t\\t\\t\\t\\ta[i-1][j] = 1;\\n\\t\\t\\t\\t\\t\\tq.add(new int[]{i-1,j});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (i < a.length-1 && a[i+1][j] == 0) {\\n\\t\\t\\t\\t\\t\\ta[i+1][j] = 1;\\n\\t\\t\\t\\t\\t\\tq.add(new int[]{i+1,j});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (j > 0 && a[i][j-1] == 0) {\\n\\t\\t\\t\\t\\t\\ta[i][j-1] = 1;\\n\\t\\t\\t\\t\\t\\tq.add(new int[]{i,j-1});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (j < a[0].length-1 && a[i][j+1] == 0) {\\n\\t\\t\\t\\t\\t\\ta[i][j+1] = 1;\\n\\t\\t\\t\\t\\t\\tq.add(new int[]{i,j+1});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic void dfs(int a[][], int i, int j) {\\n\\t\\t\\tif (i < 0 || i >= a.length || j < 0 ||  j >= a[0].length || a[i][j] == 0 || a[i][j] == 2) return;\\n\\t\\t\\ta[i][j] = 2;\\n\\t\\t\\tdfs(a,i-1,j);dfs(a,i+1,j);dfs(a,i,j-1);dfs(a,i,j+1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1449673,
                "title": "c-easy-explained-dfs-bfs-approach",
                "content": "The basic idea is that we first perform DFS from one of the island (any cell of first island ), and when we perform DFS we mark them as visited and also we pus these cells in the queue. And as soon as we successfully perform DFS from 1st island we break and start performing BFS. The advantage we get is that all the cells of 1st island is marked as visited but the cells of 2nd island is still unvisited, **so we can distinguish between them using visited matrix.** Now when we perfrom BFS we try to reach the cells of 2nd island which is identifined as grid value as 1 and unvisted. This way BFS give shortest path as it is a shortest path algo.\\n\\nCode has been commented below:\\n```\\nclass Solution {\\n    vector<vector<int>>vis; //vis vector to keep track of visited cells\\n    queue<pair<int,int>>q;  //queue to perform bfs from one connected group of cells\\n    vector<vector<int>> dir = {{0,1},{0,-1},{1,0},{-1,0}};  //dirction vector to move to adjacent cells\\npublic:\\n//dfs function\\n    void dfs(int x,int y, vector<vector<int>>&grid){\\n        int n=grid.size(), m=grid[0].size();\\n        vis[x][y]=1; //mark the current cell (i,j) as visited\\n        q.push({x,y});  //and push it in the queue as we will perform the bfs from this cell later on\\n        \\n//now we traverse all the possible 4 adjacent cell from (i,j) and recur from there so that all cells\\n//connected to (i,j) s marked as visited \\n        for(int d=0;d<4;d++){\\n            int xx = x+dir[d][0];  \\n            int yy= y+dir[d][1];\\n    //check if the new co-ordinates are valid if yes recur from there \\n            if(xx>=0 && yy>=0 && xx<n && yy<m && !vis[xx][yy] && grid[xx][yy]==1)\\n            dfs(xx,yy,grid);\\n        }\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n= grid.size();  //get the number of rows \\n        if(n==0)return 0;  \\n        int m=grid[0].size(); //get the number of column\\n        \\n        vis.assign(n,vector<int>(m,0));  //initialize all the cells of vis as false i.e 0\\n        \\n//Now we try to perform dfs from one of island and mark all its connected cells as visited so the only \\n//cells left with value 1 in grid remains unvisited, this way we can distinguish between two islands\\n        for(int i=0;i<n;i++){\\n            int flag=0;   //falg to keep track if we have successfully performed dfs & marked all connected cells as visited\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    dfs(i,j,grid);\\n                    flag=1;  //we have successfully perfomed dfs & marked all connected cells as visited of one island\\n                    break;  //break so that the other island cells remain unvisited so get distinguisged\\n                }\\n            }\\n            if(flag==1)  \\n                break;\\n        }\\n        \\n    //bfs\\n        int ans=0;   //ans to store the final result\\n        while(!q.empty()){\\n            int sz= q.size();   //get the size of one island that were visited andpushed in queue while performing dfs\\n            ans++;  //increment the ans variable as it denote  the length while traversing\\n            for(int i=0;i<sz;i++){\\n                auto node = q.front();   //get the first cell in queue\\n                q.pop();  //remove it from queue\\n                int x =node.first, y= node.second;\\n//now we check all possible path from popped cell and check if we reach the 2nd island or not if yes\\n//return ans-1 else continue our search\\n                for(int d=0;d<4;d++){\\n                    int xx = x+dir[d][0]; //new coordinate adjacent onesto (x,y)\\n                  \\n                   int yy= y+dir[d][1];\\n                    if(xx<0 || yy<0 || xx>=n || y>=m)continue; //if out of bound continue\\n                    \\n                    if(xx>=0 && y>=0 && xx<n && yy<m ){ //if valid position\\n        //if vis[xx][yy]==0 anf grid[xx][yy]=1 that represent cell of other 2nd island so return ans-1\\n                        if(!vis[xx][yy] && grid[xx][yy]==1)return ans-1;\\n        //else we need to continue our search by pushing the adjacent cells as 0 and mark it visited\\n                        else if(!vis[xx][yy] && grid[xx][yy]==0){\\n                            q.push({xx,yy});\\n                            vis[xx][yy]=1;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return 0; //if not reachable\\n    }\\n};\\n```\\n**Do upvote if explanation was useful and you liked the code:)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>>vis; //vis vector to keep track of visited cells\\n    queue<pair<int,int>>q;  //queue to perform bfs from one connected group of cells\\n    vector<vector<int>> dir = {{0,1},{0,-1},{1,0},{-1,0}};  //dirction vector to move to adjacent cells\\npublic:\\n//dfs function\\n    void dfs(int x,int y, vector<vector<int>>&grid){\\n        int n=grid.size(), m=grid[0].size();\\n        vis[x][y]=1; //mark the current cell (i,j) as visited\\n        q.push({x,y});  //and push it in the queue as we will perform the bfs from this cell later on\\n        \\n//now we traverse all the possible 4 adjacent cell from (i,j) and recur from there so that all cells\\n//connected to (i,j) s marked as visited \\n        for(int d=0;d<4;d++){\\n            int xx = x+dir[d][0];  \\n            int yy= y+dir[d][1];\\n    //check if the new co-ordinates are valid if yes recur from there \\n            if(xx>=0 && yy>=0 && xx<n && yy<m && !vis[xx][yy] && grid[xx][yy]==1)\\n            dfs(xx,yy,grid);\\n        }\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n= grid.size();  //get the number of rows \\n        if(n==0)return 0;  \\n        int m=grid[0].size(); //get the number of column\\n        \\n        vis.assign(n,vector<int>(m,0));  //initialize all the cells of vis as false i.e 0\\n        \\n//Now we try to perform dfs from one of island and mark all its connected cells as visited so the only \\n//cells left with value 1 in grid remains unvisited, this way we can distinguish between two islands\\n        for(int i=0;i<n;i++){\\n            int flag=0;   //falg to keep track if we have successfully performed dfs & marked all connected cells as visited\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    dfs(i,j,grid);\\n                    flag=1;  //we have successfully perfomed dfs & marked all connected cells as visited of one island\\n                    break;  //break so that the other island cells remain unvisited so get distinguisged\\n                }\\n            }\\n            if(flag==1)  \\n                break;\\n        }\\n        \\n    //bfs\\n        int ans=0;   //ans to store the final result\\n        while(!q.empty()){\\n            int sz= q.size();   //get the size of one island that were visited andpushed in queue while performing dfs\\n            ans++;  //increment the ans variable as it denote  the length while traversing\\n            for(int i=0;i<sz;i++){\\n                auto node = q.front();   //get the first cell in queue\\n                q.pop();  //remove it from queue\\n                int x =node.first, y= node.second;\\n//now we check all possible path from popped cell and check if we reach the 2nd island or not if yes\\n//return ans-1 else continue our search\\n                for(int d=0;d<4;d++){\\n                    int xx = x+dir[d][0]; //new coordinate adjacent onesto (x,y)\\n                  \\n                   int yy= y+dir[d][1];\\n                    if(xx<0 || yy<0 || xx>=n || y>=m)continue; //if out of bound continue\\n                    \\n                    if(xx>=0 && y>=0 && xx<n && yy<m ){ //if valid position\\n        //if vis[xx][yy]==0 anf grid[xx][yy]=1 that represent cell of other 2nd island so return ans-1\\n                        if(!vis[xx][yy] && grid[xx][yy]==1)return ans-1;\\n        //else we need to continue our search by pushing the adjacent cells as 0 and mark it visited\\n                        else if(!vis[xx][yy] && grid[xx][yy]==0){\\n                            q.push({xx,yy});\\n                            vis[xx][yy]=1;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return 0; //if not reachable\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843901,
                "title": "easy-to-read-straightforward-python-bfs-approach-with-comments",
                "content": "```\\nclass Solution:\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        rows = len(A)\\n        cols = len(A[0])\\n        directions = ((1, 0), (-1, 0), (0, 1), (0, -1))\\n        # Function to check if a given location is an edge.\\n        def edge_check(ro, co):\\n            r = []\\n            for y, x in directions:\\n                nr = ro + y\\n                nc = co + x\\n                if nr < rows and nr >= 0 and nc < cols and nc >= 0 and A[nr][nc] == 0:\\n                    return True\\n            return False\\n        # Keep a flag for when we finish surveying the 1st island.\\n        edges_1 = []\\n        found_1 = False\\n        edges_2 = []\\n        # Work through our grid until we find an island.\\n        for row in range(rows):\\n            for col in range(cols):\\n                # If we find one we\\'ll start our bfs, marking visited locations with # so we don\\'t revisit.\\n                if A[row][col] == 1:\\n                    A[row][col] = \\'#\\'\\n                    q = collections.deque([])\\n                    q.append((row, col))\\n                    while q:\\n                        r, c = q.popleft()\\n                        # If we haven\\'t found 1 yet (we must be working through 1 now).\\n                        # Append the edge (row, col).\\n                        if not found_1 and edge_check(r, c):\\n                            edges_1.append((r, c))\\n                        # Otherwise we must be on island 2.\\n                        else:\\n                            if edge_check(r, c):\\n                                edges_2.append((r, c))\\n                        # Continue working through the adjacent cells.\\n                        for y, x in directions:\\n                            nr = r + y\\n                            nc = c + x\\n                            if nr < rows and nr >= 0 and nc < cols and nc >= 0 and A[nr][nc] == 1:\\n                                q.append((nr, nc))\\n                                A[nr][nc] = \\'#\\'\\n\\n                    found_1 = True\\n        # Sort the coordinates\\n        c1 = sorted(edges_1, key=lambda x: (x[0], x[1]))\\n        c2 = sorted(edges_2, key=lambda x: (x[0], x[1]))\\n\\n        minn = float(\\'inf\\')\\n        # Find/return the min distance between points.\\n        for x1, x2 in c1:\\n            for y1, y2 in c2:\\n                minn = min(minn, abs(x1-y1)+abs(x2-y2)-1)\\n\\n        return minn\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        rows = len(A)\\n        cols = len(A[0])\\n        directions = ((1, 0), (-1, 0), (0, 1), (0, -1))\\n        # Function to check if a given location is an edge.\\n        def edge_check(ro, co):\\n            r = []\\n            for y, x in directions:\\n                nr = ro + y\\n                nc = co + x\\n                if nr < rows and nr >= 0 and nc < cols and nc >= 0 and A[nr][nc] == 0:\\n                    return True\\n            return False\\n        # Keep a flag for when we finish surveying the 1st island.\\n        edges_1 = []\\n        found_1 = False\\n        edges_2 = []\\n        # Work through our grid until we find an island.\\n        for row in range(rows):\\n            for col in range(cols):\\n                # If we find one we\\'ll start our bfs, marking visited locations with # so we don\\'t revisit.\\n                if A[row][col] == 1:\\n                    A[row][col] = \\'#\\'\\n                    q = collections.deque([])\\n                    q.append((row, col))\\n                    while q:\\n                        r, c = q.popleft()\\n                        # If we haven\\'t found 1 yet (we must be working through 1 now).\\n                        # Append the edge (row, col).\\n                        if not found_1 and edge_check(r, c):\\n                            edges_1.append((r, c))\\n                        # Otherwise we must be on island 2.\\n                        else:\\n                            if edge_check(r, c):\\n                                edges_2.append((r, c))\\n                        # Continue working through the adjacent cells.\\n                        for y, x in directions:\\n                            nr = r + y\\n                            nc = c + x\\n                            if nr < rows and nr >= 0 and nc < cols and nc >= 0 and A[nr][nc] == 1:\\n                                q.append((nr, nc))\\n                                A[nr][nc] = \\'#\\'\\n\\n                    found_1 = True\\n        # Sort the coordinates\\n        c1 = sorted(edges_1, key=lambda x: (x[0], x[1]))\\n        c2 = sorted(edges_2, key=lambda x: (x[0], x[1]))\\n\\n        minn = float(\\'inf\\')\\n        # Find/return the min distance between points.\\n        for x1, x2 in c1:\\n            for y1, y2 in c2:\\n                minn = min(minn, abs(x1-y1)+abs(x2-y2)-1)\\n\\n        return minn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775356,
                "title": "java-bfs-dfs-96-clean-solution-use-array-as-visited",
                "content": "```\\nclass Solution {\\n    int row, col;\\n    public int shortestBridge(int[][] a) {\\n        row = a.length;\\n        col = a[0].length;\\n        Queue<int[]> q = new LinkedList();\\n        for (int i = 0; i < row && q.isEmpty(); i++) {\\n            for (int j = 0; j < col && q.isEmpty(); j++) {\\n                if (a[i][j]==1) dfs(i, j, q, a);\\n            }\\n        }\\n        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        while (q.isEmpty()==false) {\\n            int[] cur = q.poll();\\n            for (int[] dir : dirs) {\\n                int i = cur[0] + dir[0], j = cur[1] + dir[1];\\n                if (i < 0 || i == row || j < 0 || j == col || a[i][j]==-1) continue;\\n                if (a[i][j]==1) return cur[2];\\n                a[i][j] = -1;\\n                q.add(new int[]{i, j, cur[2]+1});//increase distance\\n            }\\n        }\\n        return -1;\\n    }\\n    public void dfs(int i, int j, Queue<int[]> q, int[][] a) {\\n        if (i < 0 || i == row || j < 0 || j == col || a[i][j]!=1) return;\\n        //a value is 1\\n        a[i][j] = -1;\\n        q.add(new int[]{i, j, 0});//0 distance travelled\\n        dfs(i+1, j, q, a);\\n        dfs(i-1, j, q, a);\\n        dfs(i, j+1, q, a);\\n        dfs(i, j-1, q, a);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    int row, col;\\n    public int shortestBridge(int[][] a) {\\n        row = a.length;\\n        col = a[0].length;\\n        Queue<int[]> q = new LinkedList();\\n        for (int i = 0; i < row && q.isEmpty(); i++) {\\n            for (int j = 0; j < col && q.isEmpty(); j++) {\\n                if (a[i][j]==1) dfs(i, j, q, a);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 765184,
                "title": "javascript-easy-solution",
                "content": "Credit: https://www.youtube.com/watch?v=B64JXbZsTOE\\n\\n```\\n/**\\n * @param {number[][]} A\\n * @return {number}\\n */\\nvar shortestBridge = function (A) {\\n    let aIsland = [];\\n    let bIsland = [];\\n\\n    for (let i = 0; i < A.length; i++) {\\n        for (let j = 0; j < A[0].length; j++) {\\n\\n            if (A[i][j] == 1) {\\n\\n\\n                if (!aIsland.length) {\\n                    dfs(A, i, j, aIsland)\\n                } else if (!bIsland.length) {\\n                    dfs(A, i, j, bIsland)\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    let diff = aIsland.length > bIsland.length ? calculateDistance(bIsland, aIsland) : calculateDistance(aIsland, bIsland);\\n    return diff\\n\\n\\n    function dfs(A, i, j, result) {\\n\\n        if (i < 0 || j < 0 || i >= A.length || j >= A.length || A[i][j] != 1) return;\\n\\n        //mark as visited\\n        A[i][j] = 0;\\n        result.push([i, j])\\n\\n        dfs(A, i - 1, j, result);\\n        dfs(A, i + 1, j, result);\\n        dfs(A, i, j - 1, result);\\n        dfs(A, i, j + 1, result);\\n    }\\n\\n\\n\\n    function calculateDistance(aDistances, bDistance) {\\n        let min = Infinity;\\n\\n        for (let i = 0; i < aDistances.length; i++) {\\n            for (let j = 0; j < bDistance.length; j++) {\\n\\n                //find distance and  -1 beacuse beacuse it includes on of the points\\n                let calculateDiff = Math.abs(aDistances[i][0] - bDistance[j][0]) + Math.abs(aDistances[i][1] - bDistance[j][1]) - 1\\n                min = Math.min(calculateDiff, min)\\n            }\\n        }\\n\\n        return min\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} A\\n * @return {number}\\n */\\nvar shortestBridge = function (A) {\\n    let aIsland = [];\\n    let bIsland = [];\\n\\n    for (let i = 0; i < A.length; i++) {\\n        for (let j = 0; j < A[0].length; j++) {\\n\\n            if (A[i][j] == 1) {\\n\\n\\n                if (!aIsland.length) {\\n                    dfs(A, i, j, aIsland)\\n                } else if (!bIsland.length) {\\n                    dfs(A, i, j, bIsland)\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    let diff = aIsland.length > bIsland.length ? calculateDistance(bIsland, aIsland) : calculateDistance(aIsland, bIsland);\\n    return diff\\n\\n\\n    function dfs(A, i, j, result) {\\n\\n        if (i < 0 || j < 0 || i >= A.length || j >= A.length || A[i][j] != 1) return;\\n\\n        //mark as visited\\n        A[i][j] = 0;\\n        result.push([i, j])\\n\\n        dfs(A, i - 1, j, result);\\n        dfs(A, i + 1, j, result);\\n        dfs(A, i, j - 1, result);\\n        dfs(A, i, j + 1, result);\\n    }\\n\\n\\n\\n    function calculateDistance(aDistances, bDistance) {\\n        let min = Infinity;\\n\\n        for (let i = 0; i < aDistances.length; i++) {\\n            for (let j = 0; j < bDistance.length; j++) {\\n\\n                //find distance and  -1 beacuse beacuse it includes on of the points\\n                let calculateDiff = Math.abs(aDistances[i][0] - bDistance[j][0]) + Math.abs(aDistances[i][1] - bDistance[j][1]) - 1\\n                min = Math.min(calculateDiff, min)\\n            }\\n        }\\n\\n        return min\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190283,
                "title": "c-solution-no-island-expansion",
                "content": "This is a solution that I don't think I've seen so far.\n\nThe idea is simple: once you know all the elements in both islands iterate through all pairs (el1, el2) where el1 is in Island1 and el2 is in Island2 and calculate the distance between them. Return the minimum of all these distances.\n\nClearly, for some pairs (el1,el2) there is no bridge between el1 and el2. But that does not matter because the minimum will not be attained on such a pair.\n\nThe only other trick is that, since in C++ we can't use unordered_set<pair<int,int>>,  I use unordered_set<int> to store the elements of an island. As an example, if element of coordinates [10,5]  is on the island, I insert the integer 10*totalRows + 5. This is a bijection that is well known. So this is really a standard maneuver.\n\n```\nclass Solution {\nprivate:\n    unordered_set<int> firstIsland;\n    unordered_set<int> secondIsland;\n\n    vector<bool> visited;\n    \n    vector<vector<int>>* AA;\n    int rowCount;\n    int colCount;\n    \n    void findSecondIsland()\n    {\n        auto A = *AA;\n        for (int i = 0 ; i < rowCount; ++i)\n        {\n            for (int j = 0; j < colCount; ++j)\n            {\n                if (A[i][j] == 0) continue;\n                if (firstIsland.count(i*rowCount + j) > 0) continue;\n                secondIsland.insert(i*rowCount+j);\n            }\n        }\n    }\n    \n    vector<pair<int,int>> getNeigh(int row, int col)\n    {\n        auto A = *AA;\n        vector<pair<int,int>> res;\n        \n        vector<int> dx = {0,0, 1, -1};\n        vector<int> dy = {1, -1, 0, 0};\n        for (int i = 0; i < dx.size(); ++i)\n        {\n            int nRow = row + dx[i];\n            int nCol = col + dy[i];\n            if (nRow < 0 || nCol < 0 || (nRow >=rowCount) || (nCol>=colCount)) continue;\n            if (A[nRow][nCol] != A[row][col]) continue;\n            res.push_back({nRow,nCol});\n        }\n        return res;\n    }\n    \n    void findFirstIsland(int row, int col)\n    {\n        firstIsland.insert(rowCount*row + col);\n        visited[rowCount*row + col] = true;\n        \n        for(auto neigh : getNeigh(row, col))\n        {\n            int nRow = neigh.first;\n            int nCol = neigh.second;\n            if (!visited[nRow*rowCount + nCol]) findFirstIsland(nRow, nCol);\n        }\n    }\n    \n    int distance(int el1, int el2)\n    {\n        int el1Row = el1/rowCount;\n        int el1Col = el1%rowCount;\n        \n        int el2Row = el2/rowCount;\n        int el2Col = el2%rowCount;\n        \n        return (abs(el1Row-el2Row) + abs(el1Col - el2Col) - 1);\n    }\n    pair<int,int> findElOnIsland()\n    {\n        auto A = *AA;\n        for (int i = 0; i < A.size(); ++i)\n        {\n            for (int j = 0 ; j < A[i].size(); ++j)\n                if (A[i][j] == 1) return {i,j};\n        }\n    }\n\npublic:\n    int shortestBridge(vector<vector<int>>& A) {\n        AA = &A;\n        rowCount = A.size();\n        colCount = A[0].size();\n        \n        pair<int,int> elOnIsland = findElOnIsland();\n        \n        visited = vector<bool>(rowCount*colCount, false);\n        findFirstIsland(elOnIsland.first, elOnIsland.second);\n        findSecondIsland();\n        \n        int res = INT_MAX;\n        for (auto el1 : firstIsland)\n            for(auto el2 : secondIsland)\n                res = min(res, distance(el1, el2));\n        \n        return res;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\nprivate:\n    unordered_set<int> firstIsland;\n    unordered_set<int> secondIsland;\n\n    vector<bool> visited;\n    \n    vector<vector<int>>* AA;\n    int rowCount;\n    int colCount;\n    \n    void findSecondIsland()\n    {\n        auto A = *AA;\n        for (int i = 0 ; i < rowCount; ++i)\n        {\n            for (int j = 0; j < colCount; ++j)\n            {\n                if (A[i][j] == 0) continue;\n                if (firstIsland.count(i*rowCount + j) > 0) continue;\n                secondIsland.insert(i*rowCount+j);\n            }\n        }\n    }\n    \n    vector<pair<int,int>> getNeigh(int row, int col)\n    {\n        auto A = *AA;\n        vector<pair<int,int>> res;\n        \n        vector<int> dx = {0,0, 1, -1};\n        vector<int> dy = {1, -1, 0, 0};\n        for (int i = 0; i < dx.size(); ++i)\n        {\n            int nRow = row + dx[i];\n            int nCol = col + dy[i];\n            if (nRow < 0 || nCol < 0 || (nRow >=rowCount) || (nCol>=colCount)) continue;\n            if (A[nRow][nCol] != A[row][col]) continue;\n            res.push_back({nRow,nCol});\n        }\n        return res;\n    }\n    \n    void findFirstIsland(int row, int col)\n    {\n        firstIsland.insert(rowCount*row + col);\n        visited[rowCount*row + col] = true;\n        \n        for(auto neigh : getNeigh(row, col))\n        {\n            int nRow = neigh.first;\n            int nCol = neigh.second;\n            if (!visited[nRow*rowCount + nCol]) findFirstIsland(nRow, nCol);\n        }\n    }\n    \n    int distance(int el1, int el2)\n    {\n        int el1Row = el1/rowCount;\n        int el1Col = el1%rowCount;\n        \n        int el2Row = el2/rowCount;\n        int el2Col = el2%rowCount;\n        \n        return (abs(el1Row-el2Row) + abs(el1Col - el2Col) - 1);\n    }\n    pair<int,int> findElOnIsland()\n    {\n        auto A = *AA;\n        for (int i = 0; i < A.size(); ++i)\n        {\n            for (int j = 0 ; j < A[i].size(); ++j)\n                if (A[i][j] == 1) return {i,j};\n        }\n    }\n\npublic:\n    int shortestBridge(vector<vector<int>>& A) {\n        AA = &A;\n        rowCount = A.size();\n        colCount = A[0].size();\n        \n        pair<int,int> elOnIsland = findElOnIsland();\n        \n        visited = vector<bool>(rowCount*colCount, false);\n        findFirstIsland(elOnIsland.first, elOnIsland.second);\n        findSecondIsland();\n        \n        int res = INT_MAX;\n        for (auto el1 : firstIsland)\n            for(auto el2 : secondIsland)\n                res = min(res, distance(el1, el2));\n        \n        return res;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547185,
                "title": "bfs-dfs-c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\n//<!-- IF THIS CODE IS HELPFULL FOR YOU THAN YOU CAN UPVOTE THIS SOLUTION THAT\\'S HELP FULL FOR ME.\\n// IF ANY SUGGETION YOU CAN COMMENT HERE. -->\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,int &m,int &n,vector<vector<int>> &g,queue<vector<int>> &q){\\n        if(i<0||j<0||i>=m||j>=n||g[i][j]==0||g[i][j]==-1)return;\\n        q.push({i,j});\\n        g[i][j] = -1;\\n        dfs(i+1,j,m,n,g,q);\\n        dfs(i,j+1,m,n,g,q);\\n        dfs(i-1,j,m,n,g,q);\\n        dfs(i,j-1,m,n,g,q);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j])break;\\n            }\\n            if(j<n)break;\\n        }\\n        queue<vector<int>> q;\\n        dfs(i,j,m,n,grid,q);//get first one and strore all one those conneted to it in to queue q.\\n        int k,x=0;\\n        vector<int> tmp;\\n        while(!q.empty()){//bfs\\n            k = q.size();\\n            while(k--){\\n                tmp = q.front();\\n                q.pop();\\n                if(tmp[0]-1 >= 0 && grid[tmp[0]-1][tmp[1]] != -1){\\n                    if(grid[tmp[0]-1][tmp[1]] == 1)return x;\\n                    grid[tmp[0]-1][tmp[1]] = -1;\\n                    q.push({tmp[0]-1,tmp[1]});\\n                }if(tmp[0]+1 < m && grid[tmp[0]+1][tmp[1]] != -1){\\n                    if(grid[tmp[0]+1][tmp[1]] == 1)return x;\\n                    grid[tmp[0]+1][tmp[1]] = -1;\\n                    q.push({tmp[0]+1,tmp[1]});\\n                }if(tmp[1]-1 >= 0 && grid[tmp[0]][tmp[1]-1] != -1){\\n                    if(grid[tmp[0]][tmp[1]-1] == 1)return x;\\n                    grid[tmp[0]][tmp[1]-1] = -1;\\n                    q.push({tmp[0],tmp[1]-1});\\n                }if(tmp[1]+1 < n && grid[tmp[0]][tmp[1]+1] != -1){\\n                    if(grid[tmp[0]][tmp[1]+1] == 1)return x;\\n                    grid[tmp[0]][tmp[1]+1] = -1;\\n                    q.push({tmp[0],tmp[1]+1});\\n                }\\n            }\\n            x++;\\n        }\\n        return x-2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//<!-- IF THIS CODE IS HELPFULL FOR YOU THAN YOU CAN UPVOTE THIS SOLUTION THAT\\'S HELP FULL FOR ME.\\n// IF ANY SUGGETION YOU CAN COMMENT HERE. -->\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,int &m,int &n,vector<vector<int>> &g,queue<vector<int>> &q){\\n        if(i<0||j<0||i>=m||j>=n||g[i][j]==0||g[i][j]==-1)return;\\n        q.push({i,j});\\n        g[i][j] = -1;\\n        dfs(i+1,j,m,n,g,q);\\n        dfs(i,j+1,m,n,g,q);\\n        dfs(i-1,j,m,n,g,q);\\n        dfs(i,j-1,m,n,g,q);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j])break;\\n            }\\n            if(j<n)break;\\n        }\\n        queue<vector<int>> q;\\n        dfs(i,j,m,n,grid,q);//get first one and strore all one those conneted to it in to queue q.\\n        int k,x=0;\\n        vector<int> tmp;\\n        while(!q.empty()){//bfs\\n            k = q.size();\\n            while(k--){\\n                tmp = q.front();\\n                q.pop();\\n                if(tmp[0]-1 >= 0 && grid[tmp[0]-1][tmp[1]] != -1){\\n                    if(grid[tmp[0]-1][tmp[1]] == 1)return x;\\n                    grid[tmp[0]-1][tmp[1]] = -1;\\n                    q.push({tmp[0]-1,tmp[1]});\\n                }if(tmp[0]+1 < m && grid[tmp[0]+1][tmp[1]] != -1){\\n                    if(grid[tmp[0]+1][tmp[1]] == 1)return x;\\n                    grid[tmp[0]+1][tmp[1]] = -1;\\n                    q.push({tmp[0]+1,tmp[1]});\\n                }if(tmp[1]-1 >= 0 && grid[tmp[0]][tmp[1]-1] != -1){\\n                    if(grid[tmp[0]][tmp[1]-1] == 1)return x;\\n                    grid[tmp[0]][tmp[1]-1] = -1;\\n                    q.push({tmp[0],tmp[1]-1});\\n                }if(tmp[1]+1 < n && grid[tmp[0]][tmp[1]+1] != -1){\\n                    if(grid[tmp[0]][tmp[1]+1] == 1)return x;\\n                    grid[tmp[0]][tmp[1]+1] = -1;\\n                    q.push({tmp[0],tmp[1]+1});\\n                }\\n            }\\n            x++;\\n        }\\n        return x-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642991,
                "title": "java-bfs-and-dfs-combine-solution-comments-for-better-understanding",
                "content": "```\\nclass Solution {\\n    public class Pair{\\n        int x;\\n        int y;\\n        Pair(int x,int y){\\n            this.x=x;\\n            this.y=y;\\n        }\\n    }\\n    \\n    int [][] dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n    public int shortestBridge(int[][] grid) {\\n         ArrayDeque<Pair> q=new ArrayDeque<>();\\n    boolean flag=false;//as we are going to stop by the time we find first whole island\\n    boolean [][] visited=new boolean[grid.length][grid[0].length];\\n    // Now search for first island and when we find first island using DFS then we will find the level using BFS\\n    for(int i=0;i<grid.length  && flag==false;i++){\\n        for(int j =0;j<grid[i].length && flag==false;j++){\\n            if(grid[i][j]==1){//by the time we find first 1 we will apply DFS and it will fill all 1 adjacent to it i.e its neighbour\\n                DFS(grid,i,j,visited,q);\\n                flag=true;\\n            }\\n        }\\n    }\\n    \\n    // after apply DFS queue will be filled with all the islands with 1 and now we will apply bfs\\n    \\n    int level=-1;//it is which we are going to return as  after finding the island we are going to make a bridge so that 2 island can connect\\n    \\n    while(q.size()!=0){\\n        int size=q.size();\\n        level++;\\n        \\n        // now this(following one) loop we do BFS\\n        while(size-->0){\\n            Pair rem=q.removeFirst();\\n            \\n            // Now after removing check for 0 then mark them as visited and by the time when we will find a unvisited 1 then that means we have reached the land and will return the value of level\\n             for(int i =0;i<dirs.length;i++){\\n          int newrow=rem.x+dirs[i][0];\\n            int newcol=rem.y+dirs[i][1];\\n            \\n              if(newrow>=0 && newcol>=0 && newrow<grid.length && newcol<grid[0].length && visited[newrow][newcol]==false ){\\n                  if(grid[newrow][newcol]==1){\\n                      return level;\\n                  }\\n                  \\n                  q.add(new Pair(newrow,newcol));\\n                  visited[newrow][newcol]=true;//not to come back again it this\\n            }\\n        }\\n    }\\n    }\\n    return -1;//if 1 is not found then i.e bridge cannot be made as there is no land\\n    }\\n    \\n    \\n    \\n    public void DFS(int [][] grid,int row,int col,boolean [][] visited,ArrayDeque<Pair> q){\\n             visited[row][col]=true;\\n      q.add(new Pair(row,col));//add row and coloum to the queue of the island\\n      \\n      for(int i =0;i<dirs.length;i++){\\n          int newrow=row+dirs[i][0];\\n            int newcol=col+dirs[i][1];\\n            \\n            // DFS will be only call if newrow and coloum are 1 and they are not visited.\\n            if(newrow>=0 && newcol>=0 && newrow<grid.length && newcol<grid[0].length && visited[newrow][newcol]==false && grid[newrow][newcol]==1){\\n                DFS(grid,newrow,newcol,visited,q);\\n            }\\n      }\\n  \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair{\\n        int x;\\n        int y;\\n        Pair(int x,int y){\\n            this.x=x;\\n            this.y=y;\\n        }\\n    }\\n    \\n    int [][] dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n    public int shortestBridge(int[][] grid) {\\n         ArrayDeque<Pair> q=new ArrayDeque<>();\\n    boolean flag=false;//as we are going to stop by the time we find first whole island\\n    boolean [][] visited=new boolean[grid.length][grid[0].length];\\n    // Now search for first island and when we find first island using DFS then we will find the level using BFS\\n    for(int i=0;i<grid.length  && flag==false;i++){\\n        for(int j =0;j<grid[i].length && flag==false;j++){\\n            if(grid[i][j]==1){//by the time we find first 1 we will apply DFS and it will fill all 1 adjacent to it i.e its neighbour\\n                DFS(grid,i,j,visited,q);\\n                flag=true;\\n            }\\n        }\\n    }\\n    \\n    // after apply DFS queue will be filled with all the islands with 1 and now we will apply bfs\\n    \\n    int level=-1;//it is which we are going to return as  after finding the island we are going to make a bridge so that 2 island can connect\\n    \\n    while(q.size()!=0){\\n        int size=q.size();\\n        level++;\\n        \\n        // now this(following one) loop we do BFS\\n        while(size-->0){\\n            Pair rem=q.removeFirst();\\n            \\n            // Now after removing check for 0 then mark them as visited and by the time when we will find a unvisited 1 then that means we have reached the land and will return the value of level\\n             for(int i =0;i<dirs.length;i++){\\n          int newrow=rem.x+dirs[i][0];\\n            int newcol=rem.y+dirs[i][1];\\n            \\n              if(newrow>=0 && newcol>=0 && newrow<grid.length && newcol<grid[0].length && visited[newrow][newcol]==false ){\\n                  if(grid[newrow][newcol]==1){\\n                      return level;\\n                  }\\n                  \\n                  q.add(new Pair(newrow,newcol));\\n                  visited[newrow][newcol]=true;//not to come back again it this\\n            }\\n        }\\n    }\\n    }\\n    return -1;//if 1 is not found then i.e bridge cannot be made as there is no land\\n    }\\n    \\n    \\n    \\n    public void DFS(int [][] grid,int row,int col,boolean [][] visited,ArrayDeque<Pair> q){\\n             visited[row][col]=true;\\n      q.add(new Pair(row,col));//add row and coloum to the queue of the island\\n      \\n      for(int i =0;i<dirs.length;i++){\\n          int newrow=row+dirs[i][0];\\n            int newcol=col+dirs[i][1];\\n            \\n            // DFS will be only call if newrow and coloum are 1 and they are not visited.\\n            if(newrow>=0 && newcol>=0 && newrow<grid.length && newcol<grid[0].length && visited[newrow][newcol]==false && grid[newrow][newcol]==1){\\n                DFS(grid,newrow,newcol,visited,q);\\n            }\\n      }\\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631239,
                "title": "c-simple-solution-bfs-manhatten-distance",
                "content": "```\\n// find all the coordinates of both islands\\n// then find the minimum manhatten distance\\n\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& A, int i, int j, vector <pair<int, int>> &r)\\n    {\\n        if(i < 0 || j < 0 || i >= A.size() || j >= A[i].size() || A[i][j]==0)\\n            return;\\n        A[i][j] = 0;\\n        r.push_back(make_pair(i,j));\\n        dfs(A, i+1, j, r);\\n        dfs(A, i-1, j, r);\\n        dfs(A, i, j-1, r);\\n        dfs(A, i, j+1, r);\\n        return;\\n    }\\n    int shortestBridge(vector<vector<int>>& A) {\\n        int count = 0;\\n        vector <pair<int, int>> x;\\n        vector <pair<int, int>> y;\\n        for(int i=0; i<A.size(); i++)\\n        {\\n            for(int j=0; j<A[i].size(); j++)\\n            {\\n                if(A[i][j] == 1)\\n                {\\n                    count++;\\n                    if(count == 1)\\n                    {\\n                        dfs(A, i, j, x);   \\n                    }\\n                    if(count == 2)\\n                    {\\n                        dfs(A, i, j, y);   \\n                    }   \\n                }\\n            }\\n        }\\n        int min_dist = INT_MAX;\\n        for(int i=0; i<x.size(); i++)\\n        {\\n            for(int j=0; j<y.size(); j++)\\n            {\\n                int dist = abs(x[i].first - y[j].first) + abs(x[i].second - y[j].second) - 1;\\n                if(dist < min_dist)\\n                    min_dist = dist;\\n            }\\n        }\\n        return min_dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n// find all the coordinates of both islands\\n// then find the minimum manhatten distance\\n\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& A, int i, int j, vector <pair<int, int>> &r)\\n    {\\n        if(i < 0 || j < 0 || i >= A.size() || j >= A[i].size() || A[i][j]==0)\\n            return;\\n        A[i][j] = 0;\\n        r.push_back(make_pair(i,j));\\n        dfs(A, i+1, j, r);\\n        dfs(A, i-1, j, r);\\n        dfs(A, i, j-1, r);\\n        dfs(A, i, j+1, r);\\n        return;\\n    }\\n    int shortestBridge(vector<vector<int>>& A) {\\n        int count = 0;\\n        vector <pair<int, int>> x;\\n        vector <pair<int, int>> y;\\n        for(int i=0; i<A.size(); i++)\\n        {\\n            for(int j=0; j<A[i].size(); j++)\\n            {\\n                if(A[i][j] == 1)\\n                {\\n                    count++;\\n                    if(count == 1)\\n                    {\\n                        dfs(A, i, j, x);   \\n                    }\\n                    if(count == 2)\\n                    {\\n                        dfs(A, i, j, y);   \\n                    }   \\n                }\\n            }\\n        }\\n        int min_dist = INT_MAX;\\n        for(int i=0; i<x.size(); i++)\\n        {\\n            for(int j=0; j<y.size(); j++)\\n            {\\n                int dist = abs(x[i].first - y[j].first) + abs(x[i].second - y[j].second) - 1;\\n                if(dist < min_dist)\\n                    min_dist = dist;\\n            }\\n        }\\n        return min_dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676714,
                "title": "simple-and-short-c-solution",
                "content": "```\\npublic class Solution {\\n    int row;\\n    int col;\\n    public int ShortestBridge(int[][] A) {\\n        row= A.Length;\\n        if(row == 0) return 0;\\n        col = A[0].Length;\\n        \\n        var island1 = new List<int[]>();\\n        var island2 = new List<int[]>();\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j = 0; j< col; j++){\\n               if( A[i][j] == 1 && island1.Count==0){\\n                   Dfs(A, island1, i, j);\\n               }\\n                else{\\n                    Dfs(A,island2, i, j);\\n                }\\n            }\\n        }\\n        int min=100;\\n        foreach (var i1 in island1){\\n            foreach( var i2 in island2){\\n              min = Math.Min(min, Math.Abs(i1[0]-i2[0]) + Math.Abs(i1[1]-i2[1]) -1);  \\n            }\\n        }\\n     return min;   \\n    }\\n    \\n    public void Dfs(int[][] A, List<int[]> island, int i, int j){\\n        if(i<0||i>=row||j<0||j>=col||A[i][j]==0) return;\\n        A[i][j] = 0;\\n        island.Add(new int[] {i, j});\\n        Dfs(A, island, i+1, j);\\n        Dfs(A, island, i, j-1);\\n        Dfs(A, island, i-1, j);\\n        Dfs(A, island, i, j+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int row;\\n    int col;\\n    public int ShortestBridge(int[][] A) {\\n        row= A.Length;\\n        if(row == 0) return 0;\\n        col = A[0].Length;\\n        \\n        var island1 = new List<int[]>();\\n        var island2 = new List<int[]>();\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j = 0; j< col; j++){\\n               if( A[i][j] == 1 && island1.Count==0){\\n                   Dfs(A, island1, i, j);\\n               }\\n                else{\\n                    Dfs(A,island2, i, j);\\n                }\\n            }\\n        }\\n        int min=100;\\n        foreach (var i1 in island1){\\n            foreach( var i2 in island2){\\n              min = Math.Min(min, Math.Abs(i1[0]-i2[0]) + Math.Abs(i1[1]-i2[1]) -1);  \\n            }\\n        }\\n     return min;   \\n    }\\n    \\n    public void Dfs(int[][] A, List<int[]> island, int i, int j){\\n        if(i<0||i>=row||j<0||j>=col||A[i][j]==0) return;\\n        A[i][j] = 0;\\n        island.Add(new int[] {i, j});\\n        Dfs(A, island, i+1, j);\\n        Dfs(A, island, i, j-1);\\n        Dfs(A, island, i-1, j);\\n        Dfs(A, island, i, j+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550062,
                "title": "java-dfs-bfs-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private int n;\\n  private int[][] moves = new int[][] {{-1,0}, {1,0}, {0,-1}, {0,1}};\\n  private Queue<int[]> queue = new ArrayDeque<>();\\n\\n  private void discoverIsland(int[][] grid, int x, int y) {\\n    grid[x][y] = 2;\\n    queue.add(new int[] {x, y});\\n\\n    for (var move : moves) {\\n      var x2 = x + move[0];\\n      var y2 = y + move[1];\\n\\n      if (x2 >= 0 && x2 < n && y2 >= 0 && y2 < n)\\n        if (grid[x2][y2] == 1)\\n          discoverIsland(grid, x2, y2);\\n    }\\n  }\\n\\n  public int shortestBridge(int[][] grid) {\\n    n = grid.length;\\n    int x = 0, y = 0;\\n    var br = false;\\n\\n    for (x=0; x<n && !br; x++) {\\n      for (y=0; y<n && !br; y++) {\\n        if (grid[x][y] == 1) {\\n          discoverIsland(grid, x, y);\\n          br = true;\\n        }\\n      }\\n    }\\n    for (var cnt = 0; ; cnt++) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var pos = queue.poll();\\n\\n        for (var move : moves) {\\n          var x2 = pos[0] + move[0];\\n          var y2 = pos[1] + move[1];\\n\\n          if (x2 >= 0 && x2 < n && y2 >= 0 && y2 < n) {\\n            if (grid[x2][y2] == 1)\\n              return cnt;\\n            else if (grid[x2][y2] == 0) {\\n              queue.add(new int[] {x2, y2});\\n              grid[x2][y2] = -1;\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  private int n;\\n  private int[][] moves = new int[][] {{-1,0}, {1,0}, {0,-1}, {0,1}};\\n  private Queue<int[]> queue = new ArrayDeque<>();\\n\\n  private void discoverIsland(int[][] grid, int x, int y) {\\n    grid[x][y] = 2;\\n    queue.add(new int[] {x, y});\\n\\n    for (var move : moves) {\\n      var x2 = x + move[0];\\n      var y2 = y + move[1];\\n\\n      if (x2 >= 0 && x2 < n && y2 >= 0 && y2 < n)\\n        if (grid[x2][y2] == 1)\\n          discoverIsland(grid, x2, y2);\\n    }\\n  }\\n\\n  public int shortestBridge(int[][] grid) {\\n    n = grid.length;\\n    int x = 0, y = 0;\\n    var br = false;\\n\\n    for (x=0; x<n && !br; x++) {\\n      for (y=0; y<n && !br; y++) {\\n        if (grid[x][y] == 1) {\\n          discoverIsland(grid, x, y);\\n          br = true;\\n        }\\n      }\\n    }\\n    for (var cnt = 0; ; cnt++) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var pos = queue.poll();\\n\\n        for (var move : moves) {\\n          var x2 = pos[0] + move[0];\\n          var y2 = pos[1] + move[1];\\n\\n          if (x2 >= 0 && x2 < n && y2 >= 0 && y2 < n) {\\n            if (grid[x2][y2] == 1)\\n              return cnt;\\n            else if (grid[x2][y2] == 0) {\\n              queue.add(new int[] {x2, y2});\\n              grid[x2][y2] = -1;\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549670,
                "title": "a-masterpiece-for-bfs-and-dfs-together-clear-intuition-cpp",
                "content": "# Intuition\\nStoring all coordinate of first island (using DFS) and then calculating steps from each cordinate to closest 1 (using BFS).\\n\\n# Approach\\n\\nInitialise a 2D matrix \\'dis\\', each cell with value INT_MAX.\\n\\nPart1:- Getting coordinates of all 1\\'s of first island.\\n1. Do a DFS(only once) and mark the distance matrix of all the 1\\'s of one of the two island as 0. Here 0 implies you travelled 0 distance.\\n2. Along with above , mark visited cell of grid matrix as 0( so that u don\\'t stuck in a loop).\\n3. push this cell\\'s coordinate and steps =0 in a queue (this queue will be used further for calculating minimum steps to reach 1 from island using BFS).\\n\\npart 2:- Calculating minimum steps. \\n\\n1. once you get the all positions of 1\\'s with steps=0 in a queue from first island.\\n2. Pop one by one and calculate its steps to reach nearest \\'1\\' using BFS.\\n3. Return minimum from all possible answers.\\n\\n# Complexity\\n- Time complexity:\\n    + O(N*N) for DFS\\n    + O (N*N) for BFS\\n\\n- Space complexity:\\n   + O(N*N)  for distance matrix\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<int>> &dis,queue<pair<int,pair<int,int>>> &q)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid.size() )\\n            return;\\n        if(grid[i][j]==0)\\n            return;\\n\\n        dis[i][j]=0;\\n        grid[i][j]=0; \\n        q.push({0,{i,j}}); // {steps till now,{x,y}}\\n\\n\\n         dfs(i+1,j,grid,dis,q);\\n         dfs(i,j+1,grid,dis,q); \\n         dfs(i-1,j,grid,dis,q); \\n         dfs(i,j-1,grid,dis,q); \\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        vector<vector<int>> dis(n,vector<int>(n,1e9));\\n        queue<pair<int,pair<int,int>>> q;\\n        bool flag=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {   \\n                    flag=1;\\n                    dfs(i,j,grid,dis,q);\\n                    break;\\n                }\\n            }\\n            if(flag==1) // we need to do dfs only once\\n                break;\\n        }\\n\\n        int ans=1e9;\\n        while(!q.empty())\\n        {\\n             auto it=q.front();\\n           q.pop();\\n           int step=it.first;\\n           int r=it.second.first;\\n           int c=it.second.second;\\n           \\n           int dx[4]={-1,1,0,0};\\n            int dy[4]={0,0,-1,1};\\n           \\n           for(int i=0;i<4;i++)\\n           {\\n               int newr=r+dx[i];\\n               int newc=c+dy[i];\\n               \\n               if(newr>=0 && newc>=0 && newr<n && newc<n && dis[newr][newc]>step+1)\\n               {\\n                   if(grid[newr][newc]==1)  // if we reached \\'1\\' of another island\\n                   {\\n                       ans=min(ans,step);\\n                       \\n                   }\\n                   dis[newr][newc]=step+1;\\n                   q.push({step+1,{newr,newc}});\\n               }\\n           }\\n           \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n        Happy Coding :-)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<int>> &dis,queue<pair<int,pair<int,int>>> &q)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid.size() )\\n            return;\\n        if(grid[i][j]==0)\\n            return;\\n\\n        dis[i][j]=0;\\n        grid[i][j]=0; \\n        q.push({0,{i,j}}); // {steps till now,{x,y}}\\n\\n\\n         dfs(i+1,j,grid,dis,q);\\n         dfs(i,j+1,grid,dis,q); \\n         dfs(i-1,j,grid,dis,q); \\n         dfs(i,j-1,grid,dis,q); \\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        vector<vector<int>> dis(n,vector<int>(n,1e9));\\n        queue<pair<int,pair<int,int>>> q;\\n        bool flag=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {   \\n                    flag=1;\\n                    dfs(i,j,grid,dis,q);\\n                    break;\\n                }\\n            }\\n            if(flag==1) // we need to do dfs only once\\n                break;\\n        }\\n\\n        int ans=1e9;\\n        while(!q.empty())\\n        {\\n             auto it=q.front();\\n           q.pop();\\n           int step=it.first;\\n           int r=it.second.first;\\n           int c=it.second.second;\\n           \\n           int dx[4]={-1,1,0,0};\\n            int dy[4]={0,0,-1,1};\\n           \\n           for(int i=0;i<4;i++)\\n           {\\n               int newr=r+dx[i];\\n               int newc=c+dy[i];\\n               \\n               if(newr>=0 && newc>=0 && newr<n && newc<n && dis[newr][newc]>step+1)\\n               {\\n                   if(grid[newr][newc]==1)  // if we reached \\'1\\' of another island\\n                   {\\n                       ans=min(ans,step);\\n                       \\n                   }\\n                   dis[newr][newc]=step+1;\\n                   q.push({step+1,{newr,newc}});\\n               }\\n           }\\n           \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548666,
                "title": "c-easy-to-understand-both-dfs-and-bfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int r,int c,vector<vector<int>>&grid,vector<vector<int>>&visited,int rsize,int cosize,vector<int>&ri,vector<int>&ci){\\n    visited[r][c] = 1;\\n\\n        for(int i=0;i<4;i++){\\n           int row = r + ri[i];\\n           int  col = c + ci[i];\\n            if(row >=0 && row<rsize && col>=0 && col<cosize && visited[row][col] == -1 && grid[row][col] == 1){\\n             \\n              dfs(row,col,grid,visited,rsize,cosize,ri,ci);\\n            }\\n     \\n}\\n}\\nint bfs2(int r,int c,vector<vector<int>>&grid,vector<vector<int>>&visited,int rsize,int cosize,vector<int>&ri,vector<int>&ci,int identify){\\n    \\n    queue<pair<int,pair<int,int>>>qu;\\n    qu.push({r,{c,0}});\\n    while(!qu.empty()){\\n        int rows = qu.front().first,cols = qu.front().second.first,fliptime = qu.front().second.second;\\n        qu.pop();\\n        for(int i=0;i<4;i++){\\n           int row = rows + ri[i];\\n           int  col = cols + ci[i];\\n            if(row >=0 && row<rsize && col>=0 && col<cosize && visited[row][col] != identify && grid[row][col] == 0){\\n                visited[row][col] = identify;\\n                qu.push({row,{col,fliptime+1}});\\n            }else if(row >=0 && row<rsize && col>=0 && col<cosize && visited[row][col] == -1 && grid[row][col] == 1) return fliptime;\\n        }\\n    }\\n    return INT_MAX;\\n}\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size();\\n        vector<vector<int>>visited(m,vector<int>(n,-1));\\n        vector<int>ri{+1,-1,0,0};\\n        vector<int>ci{0,0,-1,+1};\\n        for(int i=0;i<m;i++){\\n            int f = 0;\\n            for(int z=0;z<n;z++){\\n                if(grid[i][z]) {\\n                    visited[i][z] = 1;\\n                dfs(i,z,grid,visited,m,n,ri,ci);\\n                f=1;\\n                break;\\n                }\\n            }\\n            if(f==1) break;\\n        }\\n        int mins = INT_MAX;\\n        int start = 3;\\n        for(int i=0;i<m;i++){\\n            for(int z=0;z<n;z++){\\n                if(visited[z][i] == 1){\\n                    visited[z][i] = 2;\\n                   int ans =  bfs2(z,i,grid,visited,m,n,ri,ci,start++);\\n                   mins = min(ans,mins);\\n                }\\n                \\n            }\\n            if(mins == 1) break;\\n        }\\n        return mins;\\n    }\\n};\\n```\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/8e6de99c-9fb3-4d22-8172-a966fc29a4f5_1684672452.5498846.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int r,int c,vector<vector<int>>&grid,vector<vector<int>>&visited,int rsize,int cosize,vector<int>&ri,vector<int>&ci){\\n    visited[r][c] = 1;\\n\\n        for(int i=0;i<4;i++){\\n           int row = r + ri[i];\\n           int  col = c + ci[i];\\n            if(row >=0 && row<rsize && col>=0 && col<cosize && visited[row][col] == -1 && grid[row][col] == 1){\\n             \\n              dfs(row,col,grid,visited,rsize,cosize,ri,ci);\\n            }\\n     \\n}\\n}\\nint bfs2(int r,int c,vector<vector<int>>&grid,vector<vector<int>>&visited,int rsize,int cosize,vector<int>&ri,vector<int>&ci,int identify){\\n    \\n    queue<pair<int,pair<int,int>>>qu;\\n    qu.push({r,{c,0}});\\n    while(!qu.empty()){\\n        int rows = qu.front().first,cols = qu.front().second.first,fliptime = qu.front().second.second;\\n        qu.pop();\\n        for(int i=0;i<4;i++){\\n           int row = rows + ri[i];\\n           int  col = cols + ci[i];\\n            if(row >=0 && row<rsize && col>=0 && col<cosize && visited[row][col] != identify && grid[row][col] == 0){\\n                visited[row][col] = identify;\\n                qu.push({row,{col,fliptime+1}});\\n            }else if(row >=0 && row<rsize && col>=0 && col<cosize && visited[row][col] == -1 && grid[row][col] == 1) return fliptime;\\n        }\\n    }\\n    return INT_MAX;\\n}\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size();\\n        vector<vector<int>>visited(m,vector<int>(n,-1));\\n        vector<int>ri{+1,-1,0,0};\\n        vector<int>ci{0,0,-1,+1};\\n        for(int i=0;i<m;i++){\\n            int f = 0;\\n            for(int z=0;z<n;z++){\\n                if(grid[i][z]) {\\n                    visited[i][z] = 1;\\n                dfs(i,z,grid,visited,m,n,ri,ci);\\n                f=1;\\n                break;\\n                }\\n            }\\n            if(f==1) break;\\n        }\\n        int mins = INT_MAX;\\n        int start = 3;\\n        for(int i=0;i<m;i++){\\n            for(int z=0;z<n;z++){\\n                if(visited[z][i] == 1){\\n                    visited[z][i] = 2;\\n                   int ans =  bfs2(z,i,grid,visited,m,n,ri,ci,start++);\\n                   mins = min(ans,mins);\\n                }\\n                \\n            }\\n            if(mins == 1) break;\\n        }\\n        return mins;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547387,
                "title": "beats-95-explained-js-using-bfs-and-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS to Find Islands: The first step is to perform a depth-first search (DFS) to identify the two islands in the grid. The exploreIslandDFS function is used for this purpose. It starts from a cell containing 1 and explores all the adjacent cells connected to it in a depth-first manner. It marks the visited cells as 2 to indicate that they are part of an island. The DFS continues until all cells of the first island are explored. The DFS is triggered for the first island found in the grid.\\n\\nBFS to Build Bridge: After identifying the two islands, the next step is to use a breadth-first search (BFS) to find the shortest bridge between them. The buildBridgeBFS function is responsible for this. It starts with the cells of the first island (2 in the grid) and performs a BFS by exploring the neighboring cells. During the BFS, it checks for the presence of the second island (1 in the grid). If the second island is found, it returns the distance (number of steps) taken to reach it. If not, it continues the BFS until all reachable cells are explored.\\n\\nOverall Execution: The shortestBridge function first invokes the DFS (exploreIslandDFS) to find the two islands. Once the islands are identified, it calls the BFS (buildBridgeBFS) to calculate the shortest bridge between them. The result is the distance obtained from the BFS, which represents the minimum number of flips required to connect the two islands.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(rows * cols) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(rows * cols) \\n\\n# Code\\n```\\nconst DIRECTIONS = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\nconst shortestBridge = (grid) => {\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n\\n  let queue = [];\\n\\n  const exploreIslandDFS = (row, col) => {\\n    if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] !== 1) {\\n      return false;\\n    }\\n\\n    queue.push([row, col]);\\n    grid[row][col] = 2;\\n\\n    exploreIslandDFS(row - 1, col);\\n    exploreIslandDFS(row + 1, col);\\n    exploreIslandDFS(row, col - 1);\\n    exploreIslandDFS(row, col + 1);\\n\\n    return true;\\n  };\\n\\n  const buildBridgeBFS = () => {\\n    let distance = -1;\\n    let currentQueue = [];\\n\\n    while (queue.length) {\\n      currentQueue = queue;\\n      queue = [];\\n\\n      for (let [row, col] of currentQueue) {\\n        for (let [dx, dy] of DIRECTIONS) {\\n          const nextRow = row + dx;\\n          const nextCol = col + dy;\\n\\n          if (\\n            nextRow >= 0 &&\\n            nextRow < rows &&\\n            nextCol >= 0 &&\\n            nextCol < cols &&\\n            grid[nextRow][nextCol] !== 2\\n          ) {\\n            if (grid[nextRow][nextCol] === 1) {\\n              return distance + 1;\\n            }\\n\\n            queue.push([nextRow, nextCol]);\\n            grid[nextRow][nextCol] = 2;\\n          }\\n        }\\n      }\\n\\n      distance++;\\n    }\\n\\n    return -1;\\n  };\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (exploreIslandDFS(i, j)) {\\n        return buildBridgeBFS();\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst DIRECTIONS = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\nconst shortestBridge = (grid) => {\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n\\n  let queue = [];\\n\\n  const exploreIslandDFS = (row, col) => {\\n    if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] !== 1) {\\n      return false;\\n    }\\n\\n    queue.push([row, col]);\\n    grid[row][col] = 2;\\n\\n    exploreIslandDFS(row - 1, col);\\n    exploreIslandDFS(row + 1, col);\\n    exploreIslandDFS(row, col - 1);\\n    exploreIslandDFS(row, col + 1);\\n\\n    return true;\\n  };\\n\\n  const buildBridgeBFS = () => {\\n    let distance = -1;\\n    let currentQueue = [];\\n\\n    while (queue.length) {\\n      currentQueue = queue;\\n      queue = [];\\n\\n      for (let [row, col] of currentQueue) {\\n        for (let [dx, dy] of DIRECTIONS) {\\n          const nextRow = row + dx;\\n          const nextCol = col + dy;\\n\\n          if (\\n            nextRow >= 0 &&\\n            nextRow < rows &&\\n            nextCol >= 0 &&\\n            nextCol < cols &&\\n            grid[nextRow][nextCol] !== 2\\n          ) {\\n            if (grid[nextRow][nextCol] === 1) {\\n              return distance + 1;\\n            }\\n\\n            queue.push([nextRow, nextCol]);\\n            grid[nextRow][nextCol] = 2;\\n          }\\n        }\\n      }\\n\\n      distance++;\\n    }\\n\\n    return -1;\\n  };\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (exploreIslandDFS(i, j)) {\\n        return buildBridgeBFS();\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546536,
                "title": "easy-and-fast-c-solution-with-explanation",
                "content": "# Intuition\\nThe problem can be solved using a combination of Depth-First Search (DFS) and Breadth-First Search (BFS) algorithms.\\n\\nThe general idea is to find the first island using DFS and mark all its cells as visited. Then, starting from the cells of the first island, perform a BFS to expand the island and find the second island. The minimum number of flips required to connect the two islands is the number of steps taken in the BFS.\\n\\n# Approach\\n1. Initialize a boolean array **visited** of size **n x n** to keep track of visited cells.\\n2. Initialize a queue to store the cells during BFS.\\n3. Define the four directions to explore neighboring cells: up, down, left, and right.\\n4. Find the first island:\\n    - Iterate over each cell in the grid.\\n    - If a cell with a value of 1 is found and it has not been visited, perform a DFS to mark all connected cells as visited. Enqueue each visited cell into the queue.\\n    - Break the loop once the first island is found.\\n5. Perform a BFS to expand the first island and find the second island:\\n    - Initialize a variable **steps** to keep track of the number of steps taken.\\n    - While the queue is not empty:\\n        - Get the current size of the queue.\\n        - Iterate size times:\\n            - Dequeue a cell from the queue.\\n            - Check if the dequeued cell is adjacent to the second island (i.e., has a value of 1). If so, return the number of steps taken.\\n            - Explore the neighboring cells in the four directions:\\n                - If a neighboring cell is within the grid boundaries, has not been visited, and contains a value of 0, mark it as visited and enqueue it into the queue.\\n            - Increment **steps** by 1 after processing each level of the BFS.\\n6. If the BFS completes without finding the second island, return -1 to indicate that it is not possible to connect the two islands.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, where **n** is the size of the grid. We perform a DFS to find the first island, which takes $$O(n^2$$) time. Then, we perform a BFS to expand the first island, which also takes $$O(n^2)$$ time in the worst case.\\n\\n- Space complexity: $$O(n^2)$$, where **n** is the size of the grid. We use a boolean array **visited** of size **n x n** to keep track of visited cells, and a queue to store the cells during BFS. Both require $$O(n^2)$$ space.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ShortestBridge(int[][] grid) {\\n        int n = grid.Length;\\n        bool[][] visited = new bool[n][];\\n        for (int i = 0; i < n; i++) {\\n            visited[i] = new bool[n];\\n        }\\n\\n        int[][] dirs = new int[][] {\\n            new int[] {0, 1},\\n            new int[] {0, -1},\\n            new int[] {1, 0},\\n            new int[] {-1, 0}\\n        };\\n\\n        Queue<int[]> queue = new Queue<int[]>();\\n        bool found = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (found) break;\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    DFS(grid, visited, queue, dirs, i, j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int steps = 0;\\n        while (queue.Count > 0) {\\n            int size = queue.Count;\\n            for (int i = 0; i < size; i++) {\\n                int[] curr = queue.Dequeue();\\n                int row = curr[0];\\n                int col = curr[1];\\n\\n                for (int k = 0; k < 4; k++) {\\n                    int newRow = row + dirs[k][0];\\n                    int newCol = col + dirs[k][1];\\n\\n                    if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && !visited[newRow][newCol]) {\\n                        if (grid[newRow][newCol] == 1) {\\n                            return steps;\\n                        }\\n                        visited[newRow][newCol] = true;\\n                        queue.Enqueue(new int[] {newRow, newCol});\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private void DFS(int[][] grid, bool[][] visited, Queue<int[]> queue, int[][] dirs, int row, int col) {\\n        int n = grid.Length;\\n        if (row < 0 || row >= n || col < 0 || col >= n || visited[row][col] || grid[row][col] != 1) {\\n            return;\\n        }\\n\\n        visited[row][col] = true;\\n        queue.Enqueue(new int[] {row, col});\\n\\n        foreach (int[] dir in dirs) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            DFS(grid, visited, queue, dirs, newRow, newCol);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int ShortestBridge(int[][] grid) {\\n        int n = grid.Length;\\n        bool[][] visited = new bool[n][];\\n        for (int i = 0; i < n; i++) {\\n            visited[i] = new bool[n];\\n        }\\n\\n        int[][] dirs = new int[][] {\\n            new int[] {0, 1},\\n            new int[] {0, -1},\\n            new int[] {1, 0},\\n            new int[] {-1, 0}\\n        };\\n\\n        Queue<int[]> queue = new Queue<int[]>();\\n        bool found = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (found) break;\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    DFS(grid, visited, queue, dirs, i, j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int steps = 0;\\n        while (queue.Count > 0) {\\n            int size = queue.Count;\\n            for (int i = 0; i < size; i++) {\\n                int[] curr = queue.Dequeue();\\n                int row = curr[0];\\n                int col = curr[1];\\n\\n                for (int k = 0; k < 4; k++) {\\n                    int newRow = row + dirs[k][0];\\n                    int newCol = col + dirs[k][1];\\n\\n                    if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && !visited[newRow][newCol]) {\\n                        if (grid[newRow][newCol] == 1) {\\n                            return steps;\\n                        }\\n                        visited[newRow][newCol] = true;\\n                        queue.Enqueue(new int[] {newRow, newCol});\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private void DFS(int[][] grid, bool[][] visited, Queue<int[]> queue, int[][] dirs, int row, int col) {\\n        int n = grid.Length;\\n        if (row < 0 || row >= n || col < 0 || col >= n || visited[row][col] || grid[row][col] != 1) {\\n            return;\\n        }\\n\\n        visited[row][col] = true;\\n        queue.Enqueue(new int[] {row, col});\\n\\n        foreach (int[] dir in dirs) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            DFS(grid, visited, queue, dirs, newRow, newCol);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944490,
                "title": "easy-to-understand-c-code-which-beats-91-runtime-and-60-memory",
                "content": "# Intuition\\nAs there are only two islands present.First of all i thought of converting one island of 1\\'s into islands of 2\\'s and then calculate the minimum no of the zeros to join both of them.\\n\\n# Approach\\nSo First i used Dfs and changed any one of the two islands of 1\\'s into islands of 2\\'s and then i used Bfs to calculate closest 2 from the islands of 1\\'s.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,vector<vector<int>> &visited,int i ,int j){\\n        if(i<0 || j<0 || i>=grid.size()||j>=grid[0].size() || visited[i][j] ||grid[i][j]==0){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        grid[i][j]=2;\\n        dfs(grid,visited,i+1,j);\\n        dfs(grid,visited,i,j+1);\\n        dfs(grid,visited,i,j-1);\\n        dfs(grid,visited,i-1,j);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        bool ch=false;\\n        vector<vector<int>> visited(n,vector<int>(n,false));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    dfs(grid,visited,i,j);\\n                    ch=true;\\n                    break;\\n                }\\n            }\\n            if(ch){\\n                break;\\n            }\\n        }\\n        queue<pair<pair<int,int>,int>> q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                // cout<<grid[i][j]<<\" \";\\n                if(grid[i][j]==1){\\n                    q.push({{i,j},{0}});\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n        int level=0;\\n        int v[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n        while(!q.empty()){\\n            level++;\\n            pair<int,int> p=q.front().first;\\n            int x=p.first;\\n            int y=p.second;\\n            int len=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int newx=x+v[i][0];\\n                int newy=y+v[i][1];\\n                if(newx>=0 && newy>=0 && newx<n && newy<n && grid[newx][newy]!=1){\\n                    if(grid[newx][newy]==2){\\n                        return len;\\n                    }\\n                    q.push({{newx,newy},len+1});\\n                    grid[newx][newy]=1;\\n                }\\n            }\\n        }\\n    return 1;\\n    }\\n};\\n```\\n\\nif you liked the solution than please upvote...",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,vector<vector<int>> &visited,int i ,int j){\\n        if(i<0 || j<0 || i>=grid.size()||j>=grid[0].size() || visited[i][j] ||grid[i][j]==0){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        grid[i][j]=2;\\n        dfs(grid,visited,i+1,j);\\n        dfs(grid,visited,i,j+1);\\n        dfs(grid,visited,i,j-1);\\n        dfs(grid,visited,i-1,j);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        bool ch=false;\\n        vector<vector<int>> visited(n,vector<int>(n,false));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    dfs(grid,visited,i,j);\\n                    ch=true;\\n                    break;\\n                }\\n            }\\n            if(ch){\\n                break;\\n            }\\n        }\\n        queue<pair<pair<int,int>,int>> q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                // cout<<grid[i][j]<<\" \";\\n                if(grid[i][j]==1){\\n                    q.push({{i,j},{0}});\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n        int level=0;\\n        int v[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n        while(!q.empty()){\\n            level++;\\n            pair<int,int> p=q.front().first;\\n            int x=p.first;\\n            int y=p.second;\\n            int len=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int newx=x+v[i][0];\\n                int newy=y+v[i][1];\\n                if(newx>=0 && newy>=0 && newx<n && newy<n && grid[newx][newy]!=1){\\n                    if(grid[newx][newy]==2){\\n                        return len;\\n                    }\\n                    q.push({{newx,newy},len+1});\\n                    grid[newx][newy]=1;\\n                }\\n            }\\n        }\\n    return 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2684432,
                "title": "c-bfs-dfs-easy-to-understand-solution-beat-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n    void dfs(vector<vector<int>>& grid, int x, int y, queue<pair<int, int>>& qu) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        qu.push({x, y});\\n        grid[x][y] = 2;\\n        for(int i = 0; i < 4; i++) {\\n            int nx = x + dirs[i][0];\\n            int ny = y + dirs[i][1];\\n            if(nx >= 0 && ny >= 0 && nx < row && ny < col && grid[nx][ny] == 1) {\\n                dfs(grid, nx, ny, qu);\\n            }\\n        }\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        queue<pair<int, int>> qu;\\n        bool found = false;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == 1) {\\n                    dfs(grid, i, j, qu);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(found) {\\n                break;\\n            }\\n        }\\n        \\n        int level = 0;\\n        \\n        while(!qu.empty()) {\\n            int size = qu.size();\\n            for(int i = 0; i < size; i++) {\\n                pair<int, int> point = qu.front();\\n                qu.pop();\\n                int x = point.first;\\n                int y = point.second;\\n                \\n                for(int i = 0; i < 4; i++) {\\n                    int nx = x + dirs[i][0];\\n                    int ny = y + dirs[i][1];\\n                    if(nx >= 0 && ny >= 0 && nx < row && ny < col) {\\n                        if(grid[nx][ny] == 1) {\\n                            return level;\\n                        }\\n                        if(grid[nx][ny] == 0) {\\n                            grid[nx][ny] = 2;\\n                            qu.push({nx, ny});\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n    void dfs(vector<vector<int>>& grid, int x, int y, queue<pair<int, int>>& qu) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        qu.push({x, y});\\n        grid[x][y] = 2;\\n        for(int i = 0; i < 4; i++) {\\n            int nx = x + dirs[i][0];\\n            int ny = y + dirs[i][1];\\n            if(nx >= 0 && ny >= 0 && nx < row && ny < col && grid[nx][ny] == 1) {\\n                dfs(grid, nx, ny, qu);\\n            }\\n        }\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        queue<pair<int, int>> qu;\\n        bool found = false;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == 1) {\\n                    dfs(grid, i, j, qu);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(found) {\\n                break;\\n            }\\n        }\\n        \\n        int level = 0;\\n        \\n        while(!qu.empty()) {\\n            int size = qu.size();\\n            for(int i = 0; i < size; i++) {\\n                pair<int, int> point = qu.front();\\n                qu.pop();\\n                int x = point.first;\\n                int y = point.second;\\n                \\n                for(int i = 0; i < 4; i++) {\\n                    int nx = x + dirs[i][0];\\n                    int ny = y + dirs[i][1];\\n                    if(nx >= 0 && ny >= 0 && nx < row && ny < col) {\\n                        if(grid[nx][ny] == 1) {\\n                            return level;\\n                        }\\n                        if(grid[nx][ny] == 0) {\\n                            grid[nx][ny] = 2;\\n                            qu.push({nx, ny});\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428006,
                "title": "java-dfs-and-bfs-explained",
                "content": "**Idea:**\\n* Run DFS to find one island\\n* From that island run BFS to find the shortest distance to the other island. This distance will be the length of the shortest bridge\\n* This will work because BFS allows to have multipe starting points at level 0. In this case this level 0 will be comprised of all the cells of island-1. So when you spread out using BFS level by level, the first 1 detected beyond level 0 will be island-2\\n>**T/S:** O(n\\xB2)/O(n\\xB2), where n = size(grid)\\n```\\nprivate static final int[][] DIRS = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\npublic int shortestBridge(int[][] grid) {\\n\\tvar n = grid.length;\\n\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tfor (var j = 0; j < n; j++)\\n\\t\\t\\tif (grid[i][j] == 1) \\n\\t\\t\\t\\treturn findBridge(grid, n, findIsland(grid, i, j, n, new HashSet<>()));\\n\\treturn 0;\\n}\\n\\nprivate Set<List<Integer>> findIsland(int[][] grid, int r, int c, int n, Set<List<Integer>> island) {\\n\\tif (!isOutOfBounds(n, r, c) && grid[r][c] != 0 && island.add(List.of(r, c)))\\n\\t\\tfor (var dir : DIRS)\\n\\t\\t\\tfindIsland(grid, r + dir[0], c + dir[1], n, island);\\t\\t\\t\\n\\treturn island;\\n}\\n\\nprivate boolean isOutOfBounds(int n, int r, int c) {\\n\\treturn r == -1 || r == n || c == -1 || c == n;\\n}\\n\\nprivate int findBridge(int[][] grid, int n, Set<List<Integer>> island) {\\n\\tvar bridge = 0;\\n\\n\\tfor (var q = new ArrayDeque<>(island); !q.isEmpty(); bridge++)\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\tvar cell = q.poll();\\n\\t\\t\\t\\n\\t\\t\\tfor (var dir : DIRS) {\\n\\t\\t\\t\\tvar r = cell.get(0) + dir[0];\\n\\t\\t\\t\\tvar c = cell.get(1) + dir[1];\\n\\t\\t\\t\\tvar next = List.of(r, c);\\n\\n\\t\\t\\t\\tif (isOutOfBounds(n, r, c) || !island.add(next))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (grid[r][c] == 1) // island-2 found\\n\\t\\t\\t\\t\\treturn bridge;\\n\\t\\t\\t\\tq.add(next);\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn bridge;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate static final int[][] DIRS = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\npublic int shortestBridge(int[][] grid) {\\n\\tvar n = grid.length;\\n\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tfor (var j = 0; j < n; j++)\\n\\t\\t\\tif (grid[i][j] == 1) \\n\\t\\t\\t\\treturn findBridge(grid, n, findIsland(grid, i, j, n, new HashSet<>()));\\n\\treturn 0;\\n}\\n\\nprivate Set<List<Integer>> findIsland(int[][] grid, int r, int c, int n, Set<List<Integer>> island) {\\n\\tif (!isOutOfBounds(n, r, c) && grid[r][c] != 0 && island.add(List.of(r, c)))\\n\\t\\tfor (var dir : DIRS)\\n\\t\\t\\tfindIsland(grid, r + dir[0], c + dir[1], n, island);\\t\\t\\t\\n\\treturn island;\\n}\\n\\nprivate boolean isOutOfBounds(int n, int r, int c) {\\n\\treturn r == -1 || r == n || c == -1 || c == n;\\n}\\n\\nprivate int findBridge(int[][] grid, int n, Set<List<Integer>> island) {\\n\\tvar bridge = 0;\\n\\n\\tfor (var q = new ArrayDeque<>(island); !q.isEmpty(); bridge++)\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\tvar cell = q.poll();\\n\\t\\t\\t\\n\\t\\t\\tfor (var dir : DIRS) {\\n\\t\\t\\t\\tvar r = cell.get(0) + dir[0];\\n\\t\\t\\t\\tvar c = cell.get(1) + dir[1];\\n\\t\\t\\t\\tvar next = List.of(r, c);\\n\\n\\t\\t\\t\\tif (isOutOfBounds(n, r, c) || !island.add(next))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (grid[r][c] == 1) // island-2 found\\n\\t\\t\\t\\t\\treturn bridge;\\n\\t\\t\\t\\tq.add(next);\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn bridge;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1251709,
                "title": "bfs-python-with-explanation-amazing-solution",
                "content": "What I did is just tranlsting this [amazing c++ solution](https://leetcode.com/problems/shortest-bridge/discuss/189293/C%2B%2B-BFS-Island-Expansion-%2B-UF-Bonus) to python. I am very amazed with his smartness!\\n![image](https://assets.leetcode.com/users/images/cd86299e-8ee5-46ee-91fa-f58f15373536_1622843025.7932434.png)\\n````\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        def paint(grid,i,j):\\n            if not 0<=i<len(grid) or not 0<=j<len(grid[0]):\\n                return \\n            if grid[i][j]==1:\\n                grid[i][j] = 2\\n                paint(grid,i-1,j)\\n                paint(grid,i+1,j)\\n                paint(grid,i,j-1)\\n                paint(grid,i,j+1)\\n                \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    paint(grid,i,j)\\n                    break \\n            else:\\n                continue \\n            break \\n        \\n        # print(grid)\\n        def expand(grid,i,j,n):\\n            if not 0<=i<len(grid) or not 0<=j<len(grid[0]):\\n                return   \\n            if grid[i][j]==0:\\n                grid[i][j] = n+1\\n            return grid[i][j]==1\\n        \\n        n = 2\\n        while True:\\n            for i in range(len(grid)):\\n                for j in range(len(grid[0])):\\n                    if grid[i][j]==n and (expand(grid,i-1,j,n) or expand(grid,i+1,j,n) or expand(grid,i,j+1,n) or\\\\\\n                                          expand(grid,i,j-1,n)):\\n                        return n-2\\n            n += 1\\n````\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "````\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        def paint(grid,i,j):\\n            if not 0<=i<len(grid) or not 0<=j<len(grid[0]):\\n                return \\n            if grid[i][j]==1:\\n                grid[i][j] = 2\\n                paint(grid,i-1,j)\\n                paint(grid,i+1,j)\\n                paint(grid,i,j-1)\\n                paint(grid,i,j+1)\\n                \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    paint(grid,i,j)\\n                    break \\n            else:\\n                continue \\n            break \\n        \\n        # print(grid)\\n        def expand(grid,i,j,n):\\n            if not 0<=i<len(grid) or not 0<=j<len(grid[0]):\\n                return   \\n            if grid[i][j]==0:\\n                grid[i][j] = n+1\\n            return grid[i][j]==1\\n        \\n        n = 2\\n        while True:\\n            for i in range(len(grid)):\\n                for j in range(len(grid[0])):\\n                    if grid[i][j]==n and (expand(grid,i-1,j,n) or expand(grid,i+1,j,n) or expand(grid,i,j+1,n) or\\\\\\n                                          expand(grid,i,j-1,n)):\\n                        return n-2\\n            n += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547808,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &g,set<pair<int,int>> &is,int i,int j)\\n    {\\n        if(i<0||j<0||i>=g.size()||j>=g[0].size()||g[i][j]!=1||is.count({i,j}))\\n            return;\\n        is.insert({i,j});\\n        g[i][j]=2;\\n        dfs(g,is,i+1,j);\\n        dfs(g,is,i-1,j);\\n        dfs(g,is,i,j+1);\\n        dfs(g,is,i,j-1);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid)\\n     {\\n        set<pair<int,int>> is1,is2;\\n        int n=grid.size();\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int f=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {  \\n                if(grid[i][j]==1&&!vis[i][j])\\n                {\\n                    if(f==0)\\n                    {   \\n                        dfs(grid,is1,i,j);\\n                        f++;\\n                    }\\n                    else\\n                        dfs(grid,is2,i,j);\\n                 }\\n             }\\n        }\\n        int ans=INT_MAX;\\n        for(auto i :is1)\\n        for(auto j :is2) \\n            ans=min(ans,(abs(i.first - j.first) + abs(i.second - j.second)-1));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &g,set<pair<int,int>> &is,int i,int j)\\n    {\\n        if(i<0||j<0||i>=g.size()||j>=g[0].size()||g[i][j]!=1||is.count({i,j}))\\n            return;\\n        is.insert({i,j});\\n        g[i][j]=2;\\n        dfs(g,is,i+1,j);\\n        dfs(g,is,i-1,j);\\n        dfs(g,is,i,j+1);\\n        dfs(g,is,i,j-1);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid)\\n     {\\n        set<pair<int,int>> is1,is2;\\n        int n=grid.size();\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int f=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {  \\n                if(grid[i][j]==1&&!vis[i][j])\\n                {\\n                    if(f==0)\\n                    {   \\n                        dfs(grid,is1,i,j);\\n                        f++;\\n                    }\\n                    else\\n                        dfs(grid,is2,i,j);\\n                 }\\n             }\\n        }\\n        int ans=INT_MAX;\\n        for(auto i :is1)\\n        for(auto j :is2) \\n            ans=min(ans,(abs(i.first - j.first) + abs(i.second - j.second)-1));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546661,
                "title": "clean-and-easy-code-dfs-bfs-c-youtube-video",
                "content": "MY YOUTUBE VIDEO ON THIS Qn : https://www.youtube.com/watch?v=GSE0-dReL6Y\\n```\\n/*\\n    Similar Problems : \\n    \\n    Leetcode 286. Walls and Gates\\n    Leetcode 417. Pacific Atlantic Water Flow (Very Good Problem)\\n    Leetcode 994. Rotting Oranges\\n    Leetcode 1162. As Far from Land as Possible\\n    Leetcode 1765. Map of Highest Peak\\n\\n    \\n*/\\n\\n//Using combination of DFS -> BFS\\n//NOTE : You can also use combination of BFS -> BFS\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> directions = {\\n                {-1,0},\\n        {0,-1},         {0,1},\\n                {1, 0}\\n    };\\n    \\n    bool isSafe(int i, int j) {\\n        return (i < m && i >= 0 && j < n && j >= 0);\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, int i, int j, set<pair<int, int>>& visitedCell) {\\n        if(!isSafe(i, j) || grid[i][j] == 0 || visitedCell.find({i, j}) != visitedCell.end()) {\\n            return;\\n        }\\n        \\n        visitedCell.insert({i, j});\\n        \\n        for(auto &dir : directions) {\\n            int i_ = i + dir[0];\\n            int j_ = j + dir[1];\\n            \\n            dfs(grid, i_, j_, visitedCell);\\n        }\\n    }\\n    \\n    int bfs(vector<vector<int>>& grid, set<pair<int, int>>& visitedCell) {\\n        queue<pair<int, int>> que;\\n        \\n        for(auto &it : visitedCell) {\\n            \\n            que.push({it});\\n            \\n        }\\n        \\n        int level = 0;\\n        \\n        while(!que.empty()) {\\n            int L = que.size();\\n            \\n            while(L--) {\\n                pair<int, int> P = que.front();\\n                que.pop();\\n                \\n                for(auto &dir : directions) {\\n                    int i_ = P.first + dir[0];\\n                    int j_ = P.second + dir[1];\\n\\n                    if(isSafe(i_, j_) && visitedCell.find({i_, j_}) == visitedCell.end()) {\\n                        if(grid[i_][j_] == 1) //found another island\\n                            return level;\\n                        \\n                        visitedCell.insert({i_, j_});\\n                        que.push({i_, j_});\\n                    }\\n                }\\n                \\n            }\\n            level++;\\n        }\\n        \\n        return level;\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        set<pair<int, int>> visitedCell;\\n        \\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                \\n                if(grid[i][j] == 1) {\\n                    dfs(grid, i, j, visitedCell); //It will mark one island visited\\n                    return bfs(grid, visitedCell);\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Similar Problems : \\n    \\n    Leetcode 286. Walls and Gates\\n    Leetcode 417. Pacific Atlantic Water Flow (Very Good Problem)\\n    Leetcode 994. Rotting Oranges\\n    Leetcode 1162. As Far from Land as Possible\\n    Leetcode 1765. Map of Highest Peak\\n\\n    \\n*/\\n\\n//Using combination of DFS -> BFS\\n//NOTE : You can also use combination of BFS -> BFS\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> directions = {\\n                {-1,0},\\n        {0,-1},         {0,1},\\n                {1, 0}\\n    };\\n    \\n    bool isSafe(int i, int j) {\\n        return (i < m && i >= 0 && j < n && j >= 0);\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, int i, int j, set<pair<int, int>>& visitedCell) {\\n        if(!isSafe(i, j) || grid[i][j] == 0 || visitedCell.find({i, j}) != visitedCell.end()) {\\n            return;\\n        }\\n        \\n        visitedCell.insert({i, j});\\n        \\n        for(auto &dir : directions) {\\n            int i_ = i + dir[0];\\n            int j_ = j + dir[1];\\n            \\n            dfs(grid, i_, j_, visitedCell);\\n        }\\n    }\\n    \\n    int bfs(vector<vector<int>>& grid, set<pair<int, int>>& visitedCell) {\\n        queue<pair<int, int>> que;\\n        \\n        for(auto &it : visitedCell) {\\n            \\n            que.push({it});\\n            \\n        }\\n        \\n        int level = 0;\\n        \\n        while(!que.empty()) {\\n            int L = que.size();\\n            \\n            while(L--) {\\n                pair<int, int> P = que.front();\\n                que.pop();\\n                \\n                for(auto &dir : directions) {\\n                    int i_ = P.first + dir[0];\\n                    int j_ = P.second + dir[1];\\n\\n                    if(isSafe(i_, j_) && visitedCell.find({i_, j_}) == visitedCell.end()) {\\n                        if(grid[i_][j_] == 1) //found another island\\n                            return level;\\n                        \\n                        visitedCell.insert({i_, j_});\\n                        que.push({i_, j_});\\n                    }\\n                }\\n                \\n            }\\n            level++;\\n        }\\n        \\n        return level;\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        set<pair<int, int>> visitedCell;\\n        \\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                \\n                if(grid[i][j] == 1) {\\n                    dfs(grid, i, j, visitedCell); //It will mark one island visited\\n                    return bfs(grid, visitedCell);\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004814,
                "title": "c-dfs-easy-best-code-quality-step-by-step",
                "content": "**Step1:** As the question has mentioned that there are only two islands. We will use the counter to traverse both the islands one by one.\\n**Step 2:** We will find all the co-ordinates of the island and push them into 2 vectors (1 for each island)\\n**Step 3:** We will then find the minimum distance between them.(i.e. Manhattan distance).\\n**Step 4:** The minimum distance will be the number of flips needed.\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(int nRow,int nCol,int n){\\n        return nRow>= 0 && nRow<n && nCol>=0 && nCol<n;\\n    }\\n    void dfs(int row,int col, vector<vector<int>>& grid,vector<pair<int,int>>& island,\\n            vector<int>& delRow,vector<int>& delCol){\\n        int n=grid.size();\\n        grid[row][col]=0;\\n        island.push_back({row,col});\\n        for(int i=0;i<4;i++){\\n            int nRow=row+delRow[i];\\n            int nCol=col+delCol[i];\\n            if(isValid(nRow,nCol,n) && grid[nRow][nCol]==1){\\n                dfs(nRow,nCol,grid,island,delRow,delCol);\\n            }\\n        }\\n    }\\n    \\n    int getMinFlips(vector<pair<int,int>> &island1,vector<pair<int,int>> &island2){\\n        int minDist=INT_MAX;\\n        for(int i=0;i<island1.size();i++){\\n            for(int j=0;j<island2.size();j++){\\n                int x1=island1[i].first;\\n                int x2=island2[j].first;\\n                int y1=island1[i].second;\\n                int y2=island2[j].second;\\n                \\n                int dist=abs(x1-x2)+abs(y1-y2)-1;\\n                minDist=min(minDist,dist);\\n            }\\n        }\\n        return minDist;\\n    }\\npublic:   \\n    int shortestBridge(vector<vector<int>>& grid) {\\n\\n        int n=grid.size();\\n        vector<pair<int,int>> island1;\\n        vector<pair<int,int>> island2;\\n\\n        int islandCnt=0;\\n        for(int row=0;row<n;row++){\\n            for(int col=0;col<n;col++){\\n                vector<int> delRow{-1,0,1,0};\\n                vector<int> delCol{0,1,0,-1};\\n                if(grid[row][col]==1){\\n                    islandCnt++;\\n                    if(islandCnt==1){\\n                        dfs(row,col,grid,island1,delRow,delCol);\\n                    }\\n                    else if(islandCnt==2){\\n                        dfs(row,col,grid,island2,delRow,delCol);\\n                    }\\n                }\\n            }\\n        }\\n        int minDist=getMinFlips(island1,island2);\\n\\n        return minDist;\\n    }\\n};\\n```\\n\\nDo Upvote if you liked it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(int nRow,int nCol,int n){\\n        return nRow>= 0 && nRow<n && nCol>=0 && nCol<n;\\n    }\\n    void dfs(int row,int col, vector<vector<int>>& grid,vector<pair<int,int>>& island,\\n            vector<int>& delRow,vector<int>& delCol){\\n        int n=grid.size();\\n        grid[row][col]=0;\\n        island.push_back({row,col});\\n        for(int i=0;i<4;i++){\\n            int nRow=row+delRow[i];\\n            int nCol=col+delCol[i];\\n            if(isValid(nRow,nCol,n) && grid[nRow][nCol]==1){\\n                dfs(nRow,nCol,grid,island,delRow,delCol);\\n            }\\n        }\\n    }\\n    \\n    int getMinFlips(vector<pair<int,int>> &island1,vector<pair<int,int>> &island2){\\n        int minDist=INT_MAX;\\n        for(int i=0;i<island1.size();i++){\\n            for(int j=0;j<island2.size();j++){\\n                int x1=island1[i].first;\\n                int x2=island2[j].first;\\n                int y1=island1[i].second;\\n                int y2=island2[j].second;\\n                \\n                int dist=abs(x1-x2)+abs(y1-y2)-1;\\n                minDist=min(minDist,dist);\\n            }\\n        }\\n        return minDist;\\n    }\\npublic:   \\n    int shortestBridge(vector<vector<int>>& grid) {\\n\\n        int n=grid.size();\\n        vector<pair<int,int>> island1;\\n        vector<pair<int,int>> island2;\\n\\n        int islandCnt=0;\\n        for(int row=0;row<n;row++){\\n            for(int col=0;col<n;col++){\\n                vector<int> delRow{-1,0,1,0};\\n                vector<int> delCol{0,1,0,-1};\\n                if(grid[row][col]==1){\\n                    islandCnt++;\\n                    if(islandCnt==1){\\n                        dfs(row,col,grid,island1,delRow,delCol);\\n                    }\\n                    else if(islandCnt==2){\\n                        dfs(row,col,grid,island2,delRow,delCol);\\n                    }\\n                }\\n            }\\n        }\\n        int minDist=getMinFlips(island1,island2);\\n\\n        return minDist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971249,
                "title": "approach-explained-dfs-bfs-beats-99",
                "content": "## Intuition\\n- Use DFS for traversing the first island (BFS can also be used).\\n- Use BFS to find the shortest path to the second island.\\n## Approach\\n- Traverse the first island using DFS.\\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\\n- Utilize a multi-source BFS to determine the shortest path to the second island.\\n** That\\'s it **.\\n\\n# Code\\n```\\nclass Solution {\\n    boolean[][] visited;\\n    int n;\\n    public int shortestBridge(int[][] grid) {\\n        n=grid.length;\\n        visited=new boolean[n][n];\\n\\n        boolean flag=false;\\n        Queue<int[]> queue = new ArrayDeque<>(); //for adding water boundaries\\n// of 1st island and finding smallest distance to 2nd island\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    dfs(i,j,grid,queue);  //traverse the 1st island found\\n                    flag=true;\\n                    break;\\n                }  \\n            }\\n            if(flag)\\n               break;\\n        }\\n        \\n        return bfs(grid,queue);  //return smallest number of flipped 0\\'s\\n    }\\n    \\n    private int bfs(int[][] grid,Queue<int[]> queue)\\n    {\\n        int level=0;\\n        while(!queue.isEmpty())\\n        {\\n            int len = queue.size();\\n            \\n            while(len-->0)\\n            {\\n                int[] curr = queue.remove();\\n                int i=curr[0], j=curr[1];\\n                if(grid[i][j]==1)\\n                   return level;\\n\\n                if(i+1<n && !visited[i+1][j]){\\n                   queue.add(new int[]{i+1,j});\\n                   visited[i+1][j]=true;\\n                }\\n\\n                if(i-1>=0 && !visited[i-1][j]){\\n                   queue.add(new int[]{i-1,j});\\n                   visited[i-1][j]=true;\\n                }\\n                \\n                if(j+1<n && !visited[i][j+1]){\\n                   queue.add(new int[]{i,j+1});\\n                   visited[i][j+1]=true;\\n                }\\n                \\n                if(j-1>=0 && !visited[i][j-1]){\\n                   queue.add(new int[]{i,j-1});\\n                   visited[i][j-1]=true;\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n\\n\\n    private void dfs(int i,int j,int[][] grid,Queue<int[]> queue)\\n    {\\n        if(i==-1||i==n||j==-1||j==n||visited[i][j])\\n            return;\\n        visited[i][j]=true;\\n        if(grid[i][j]==0)\\n        {\\n            queue.add(new int[]{i,j});\\n            return;\\n        }\\n        dfs(i+1,j,grid,queue);\\n        dfs(i,j+1,grid,queue);\\n        dfs(i-1,j,grid,queue);\\n        dfs(i,j-1,grid,queue);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][] visited;\\n    int n;\\n    public int shortestBridge(int[][] grid) {\\n        n=grid.length;\\n        visited=new boolean[n][n];\\n\\n        boolean flag=false;\\n        Queue<int[]> queue = new ArrayDeque<>(); //for adding water boundaries\\n// of 1st island and finding smallest distance to 2nd island\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    dfs(i,j,grid,queue);  //traverse the 1st island found\\n                    flag=true;\\n                    break;\\n                }  \\n            }\\n            if(flag)\\n               break;\\n        }\\n        \\n        return bfs(grid,queue);  //return smallest number of flipped 0\\'s\\n    }\\n    \\n    private int bfs(int[][] grid,Queue<int[]> queue)\\n    {\\n        int level=0;\\n        while(!queue.isEmpty())\\n        {\\n            int len = queue.size();\\n            \\n            while(len-->0)\\n            {\\n                int[] curr = queue.remove();\\n                int i=curr[0], j=curr[1];\\n                if(grid[i][j]==1)\\n                   return level;\\n\\n                if(i+1<n && !visited[i+1][j]){\\n                   queue.add(new int[]{i+1,j});\\n                   visited[i+1][j]=true;\\n                }\\n\\n                if(i-1>=0 && !visited[i-1][j]){\\n                   queue.add(new int[]{i-1,j});\\n                   visited[i-1][j]=true;\\n                }\\n                \\n                if(j+1<n && !visited[i][j+1]){\\n                   queue.add(new int[]{i,j+1});\\n                   visited[i][j+1]=true;\\n                }\\n                \\n                if(j-1>=0 && !visited[i][j-1]){\\n                   queue.add(new int[]{i,j-1});\\n                   visited[i][j-1]=true;\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n\\n\\n    private void dfs(int i,int j,int[][] grid,Queue<int[]> queue)\\n    {\\n        if(i==-1||i==n||j==-1||j==n||visited[i][j])\\n            return;\\n        visited[i][j]=true;\\n        if(grid[i][j]==0)\\n        {\\n            queue.add(new int[]{i,j});\\n            return;\\n        }\\n        dfs(i+1,j,grid,queue);\\n        dfs(i,j+1,grid,queue);\\n        dfs(i-1,j,grid,queue);\\n        dfs(i,j-1,grid,queue);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680556,
                "title": "simple-c-solution-using-dfs-distance-of-points-clean-code",
                "content": "# **Upvote if You Like !**\\n\\n```\\nclass Solution {\\n    \\n    void find(vector<vector<int>>& grid, int i, int j, set<pair<int,int>> &isl) {\\n        if(min(i,j) < 0 || max(i,j)>= grid.size() || !grid[i][j] || isl.count({i,j})) \\n            return;\\n        isl.insert({i,j});\\n        grid[i][j] = 0;\\n        find(grid, i+1, j, isl);\\n        find(grid, i-1, j, isl);\\n        find(grid, i, j+1, isl);\\n        find(grid, i, j-1, isl);\\n    }\\n    \\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        set<pair<int,int>> isl1, isl2;\\n        bool isl = true;\\n        for(int i = 0; i<grid.size(); i++)\\n            for(int j = 0; j<grid.size(); j++)\\n                if(grid[i][j]) {\\n                    if(isl) find(grid, i,j, isl1), isl = 0;\\n                    else find(grid, i,j, isl2);\\n                }\\n        \\n        int ans = INT_MAX;\\n        for(auto [x1, y1] : isl1)\\n            for(auto [x2, y2] : isl2)\\n                ans = min(ans, abs(x1-x2)+abs(y1-y2)-1);\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void find(vector<vector<int>>& grid, int i, int j, set<pair<int,int>> &isl) {\\n        if(min(i,j) < 0 || max(i,j)>= grid.size() || !grid[i][j] || isl.count({i,j})) \\n            return;\\n        isl.insert({i,j});\\n        grid[i][j] = 0;\\n        find(grid, i+1, j, isl);\\n        find(grid, i-1, j, isl);\\n        find(grid, i, j+1, isl);\\n        find(grid, i, j-1, isl);\\n    }\\n    \\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        set<pair<int,int>> isl1, isl2;\\n        bool isl = true;\\n        for(int i = 0; i<grid.size(); i++)\\n            for(int j = 0; j<grid.size(); j++)\\n                if(grid[i][j]) {\\n                    if(isl) find(grid, i,j, isl1), isl = 0;\\n                    else find(grid, i,j, isl2);\\n                }\\n        \\n        int ans = INT_MAX;\\n        for(auto [x1, y1] : isl1)\\n            for(auto [x2, y2] : isl2)\\n                ans = min(ans, abs(x1-x2)+abs(y1-y2)-1);\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429432,
                "title": "java-approach-explained-bfs-dfs-dfs-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    /*\\n    Approch: \\n    Mark island as 1 and 2 using bfs/dfs\\n    start from 1 and do bfs to get shorted path to island 2\\n    return the distance\\n    */\\n    private int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        \\n        // Marking 1 island with 2\\n        boolean isMarked = false;\\n        for(int i = 0; i< n; i++){\\n            for(int j = 0; j< n; j++){\\n                if(grid[i][j] == 1){\\n                    markIsland(i, j, grid);\\n                    isMarked = true;\\n                    break;\\n                }\\n            }\\n            if(isMarked) break;\\n        }\\n     \\n        // Adding first island in queue\\n        Queue<int[]> q = new LinkedList<>();\\n        for(int i = 0; i< n; i++)\\n            for(int j = 0; j< n; j++)\\n                if(grid[i][j] == 1){\\n                    visited[i][j] = true;\\n                    q.add(new int[]{i, j});\\n                }\\n        \\n        // Using multi source BFS to find nearest cell of second island (2) from first island cells (1) \\n        int dist = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size--!=0){\\n                int[] cur = q.poll();\\n                for(int[] d: dirs){\\n                    int x = cur[0] + d[0], y = cur[1] + d[1];\\n                    if(x < 0 || y < 0 || x == grid.length || y == grid[0].length || grid[x][y] == 1 || visited[x][y]) continue;\\n                    if(grid[x][y] == 2) return dist;\\n                    visited[x][y] = true;\\n                    q.add(new int[]{x, y});\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n    // DFS to mark one island cells as 2\\n    private void markIsland(int i, int j, int[][] grid){\\n        grid[i][j] = 2;\\n        for(int[] d: dirs){\\n            int x = i+d[0], y = j+d[1];\\n            if(x < 0 || y < 0 || x == grid.length || y == grid.length || grid[x][y] != 1)\\n                continue;\\n            markIsland(x, y, grid);\\n        }\\n    } \\n}\\n```\\n\\n**Please upvote if you like the solution!!!**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    Approch: \\n    Mark island as 1 and 2 using bfs/dfs\\n    start from 1 and do bfs to get shorted path to island 2\\n    return the distance\\n    */\\n    private int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        \\n        // Marking 1 island with 2\\n        boolean isMarked = false;\\n        for(int i = 0; i< n; i++){\\n            for(int j = 0; j< n; j++){\\n                if(grid[i][j] == 1){\\n                    markIsland(i, j, grid);\\n                    isMarked = true;\\n                    break;\\n                }\\n            }\\n            if(isMarked) break;\\n        }\\n     \\n        // Adding first island in queue\\n        Queue<int[]> q = new LinkedList<>();\\n        for(int i = 0; i< n; i++)\\n            for(int j = 0; j< n; j++)\\n                if(grid[i][j] == 1){\\n                    visited[i][j] = true;\\n                    q.add(new int[]{i, j});\\n                }\\n        \\n        // Using multi source BFS to find nearest cell of second island (2) from first island cells (1) \\n        int dist = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size--!=0){\\n                int[] cur = q.poll();\\n                for(int[] d: dirs){\\n                    int x = cur[0] + d[0], y = cur[1] + d[1];\\n                    if(x < 0 || y < 0 || x == grid.length || y == grid[0].length || grid[x][y] == 1 || visited[x][y]) continue;\\n                    if(grid[x][y] == 2) return dist;\\n                    visited[x][y] = true;\\n                    q.add(new int[]{x, y});\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n    // DFS to mark one island cells as 2\\n    private void markIsland(int i, int j, int[][] grid){\\n        grid[i][j] = 2;\\n        for(int[] d: dirs){\\n            int x = i+d[0], y = j+d[1];\\n            if(x < 0 || y < 0 || x == grid.length || y == grid.length || grid[x][y] != 1)\\n                continue;\\n            markIsland(x, y, grid);\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331267,
                "title": "c-dfs-bfs-98-faster-easy-to-follow",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        long res=INT_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                if(grid[i][j])\\n                {\\n                    fun(grid,i,j); // dfs\\n                    return bfs(grid,vis);\\n                }\\n        return 0;\\n    }\\n    void fun(vector<vector<int>>& v,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v.size() || v[i][j]!=1)\\n            return;\\n        \\n        v[i][j]=2;\\n        \\n        fun(v,i+1,j);\\n        fun(v,i,j+1);\\n        fun(v,i-1,j);\\n        fun(v,i,j-1);\\n    }\\n    int bfs(vector<vector<int>>& v,vector<vector<int>>& vis)\\n    {\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<v.size();i++)\\n            for(int j=0;j<v.size();j++)\\n                if(v[i][j]==1)\\n                {\\n                    q.push({i,j});\\n                    vis[i][j]=1;\\n                }\\n        \\n        int res=0;\\n        while(!q.empty())\\n        {\\n           int t=q.size();\\n           for(int i=0;i<t;i++)\\n           {               \\n               auto x=q.front();\\n               q.pop();        \\n               \\n               if(v[x.first][x.second]==2)\\n                   return res-1;\\n            \\n               if(valid(v,vis,x.first+1,x.second))\\n                   q.push({x.first+1,x.second});\\n               \\n               if(valid(v,vis,x.first-1,x.second))\\n                   q.push({x.first-1,x.second});\\n               \\n               if(valid(v,vis,x.first,x.second-1))\\n                   q.push({x.first,x.second-1});\\n               \\n               if(valid(v,vis,x.first,x.second+1))\\n                   q.push({x.first,x.second+1});\\n           }\\n           res++;\\n        }\\n        return res;\\n    }\\n    int valid(vector<vector<int>>& v,vector<vector<int>>& vis,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v.size() || v[i][j]==1 || vis[i][j])\\n            return 0;\\n       return vis[i][j]=1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        long res=INT_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                if(grid[i][j])\\n                {\\n                    fun(grid,i,j); // dfs\\n                    return bfs(grid,vis);\\n                }\\n        return 0;\\n    }\\n    void fun(vector<vector<int>>& v,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v.size() || v[i][j]!=1)\\n            return;\\n        \\n        v[i][j]=2;\\n        \\n        fun(v,i+1,j);\\n        fun(v,i,j+1);\\n        fun(v,i-1,j);\\n        fun(v,i,j-1);\\n    }\\n    int bfs(vector<vector<int>>& v,vector<vector<int>>& vis)\\n    {\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<v.size();i++)\\n            for(int j=0;j<v.size();j++)\\n                if(v[i][j]==1)\\n                {\\n                    q.push({i,j});\\n                    vis[i][j]=1;\\n                }\\n        \\n        int res=0;\\n        while(!q.empty())\\n        {\\n           int t=q.size();\\n           for(int i=0;i<t;i++)\\n           {               \\n               auto x=q.front();\\n               q.pop();        \\n               \\n               if(v[x.first][x.second]==2)\\n                   return res-1;\\n            \\n               if(valid(v,vis,x.first+1,x.second))\\n                   q.push({x.first+1,x.second});\\n               \\n               if(valid(v,vis,x.first-1,x.second))\\n                   q.push({x.first-1,x.second});\\n               \\n               if(valid(v,vis,x.first,x.second-1))\\n                   q.push({x.first,x.second-1});\\n               \\n               if(valid(v,vis,x.first,x.second+1))\\n                   q.push({x.first,x.second+1});\\n           }\\n           res++;\\n        }\\n        return res;\\n    }\\n    int valid(vector<vector<int>>& v,vector<vector<int>>& vis,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v.size() || v[i][j]==1 || vis[i][j])\\n            return 0;\\n       return vis[i][j]=1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110568,
                "title": "runtime-51-ms-faster-than-87-23-of-c-online-submissions-for-shortest-bridge",
                "content": "![](https://assets.leetcode.com/users/votrubac/image_1541488072.png)\\n\\n```\\nclass Solution\\n{\\n\\tvector<vector<int>> visited;\\n\\tqueue<pair<int, int>> q1;\\n\\n\\tvoid bfs(vector<vector<int>> &grid, int i, int j)\\n\\t{\\n\\t\\tqueue<pair<int, int>> q;\\n\\t\\tvisited[i][j] = 1;\\n\\t\\tq.push({i, j});\\n\\t\\tq1.push({i, j});\\n\\t\\tint xn[] = {1, -1, 0, 0};\\n\\t\\tint yn[] = {0, 0, -1, 1};\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tint x = (q.front()).first;\\n\\t\\t\\tint y = (q.front()).second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor (int ii = 0; ii < 4; ii++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ti = x + xn[ii];\\n\\t\\t\\t\\tj = y + yn[ii];\\n\\t\\t\\t\\tif (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0 || visited[i][j] == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tvisited[i][j] = 1;\\n\\t\\t\\t\\tq.push({i, j});\\n\\t\\t\\t\\tq1.push({i, j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint bfs2(vector<vector<int>> &grid)\\n\\t{\\n\\t\\tint xn[] = {1, -1, 0, 0};\\n\\t\\tint yn[] = {0, 0, -1, 1};\\n\\t\\twhile (!q1.empty())\\n\\t\\t{\\n\\t\\t\\tint x = (q1.front()).first;\\n\\t\\t\\tint y = (q1.front()).second;\\n\\t\\t\\tq1.pop();\\n\\t\\t\\tfor (int ii = 0; ii < 4; ii++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint i = x + xn[ii];\\n\\t\\t\\t\\tint j = y + yn[ii];\\n\\t\\t\\t\\tif (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || visited[i][j] == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (grid[i][j] == 1 and visited[i][j] == 0)\\n\\t\\t\\t\\t\\treturn grid[x][y];\\n\\t\\t\\t\\tgrid[i][j] = grid[x][y] + 1;\\n\\t\\t\\t\\tvisited[i][j] = 1;\\n\\t\\t\\t\\tq1.push({i, j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\npublic:\\n\\tint shortestBridge(vector<vector<int>> &grid)\\n\\t{\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\n\\t\\tbool bat = 0;\\n\\t\\tvisited.resize(n + 1, vector<int>(m + 1, 0));\\n\\t\\tint i, j;\\n\\t\\t//to take all 1\\'s of one component;\\n\\t\\tfor (i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tfor (j = 0; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbfs(grid, i, j);  \\n\\t\\t\\t\\t\\tbat = 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (bat)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\t//bfs2 is to increment value\\n\\t\\treturn bfs2(grid) - 1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tvector<vector<int>> visited;\\n\\tqueue<pair<int, int>> q1;\\n\\n\\tvoid bfs(vector<vector<int>> &grid, int i, int j)\\n\\t{\\n\\t\\tqueue<pair<int, int>> q;\\n\\t\\tvisited[i][j] = 1;\\n\\t\\tq.push({i, j});\\n\\t\\tq1.push({i, j});\\n\\t\\tint xn[] = {1, -1, 0, 0};\\n\\t\\tint yn[] = {0, 0, -1, 1};\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tint x = (q.front()).first;\\n\\t\\t\\tint y = (q.front()).second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor (int ii = 0; ii < 4; ii++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ti = x + xn[ii];\\n\\t\\t\\t\\tj = y + yn[ii];\\n\\t\\t\\t\\tif (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0 || visited[i][j] == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tvisited[i][j] = 1;\\n\\t\\t\\t\\tq.push({i, j});\\n\\t\\t\\t\\tq1.push({i, j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint bfs2(vector<vector<int>> &grid)\\n\\t{\\n\\t\\tint xn[] = {1, -1, 0, 0};\\n\\t\\tint yn[] = {0, 0, -1, 1};\\n\\t\\twhile (!q1.empty())\\n\\t\\t{\\n\\t\\t\\tint x = (q1.front()).first;\\n\\t\\t\\tint y = (q1.front()).second;\\n\\t\\t\\tq1.pop();\\n\\t\\t\\tfor (int ii = 0; ii < 4; ii++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint i = x + xn[ii];\\n\\t\\t\\t\\tint j = y + yn[ii];\\n\\t\\t\\t\\tif (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || visited[i][j] == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (grid[i][j] == 1 and visited[i][j] == 0)\\n\\t\\t\\t\\t\\treturn grid[x][y];\\n\\t\\t\\t\\tgrid[i][j] = grid[x][y] + 1;\\n\\t\\t\\t\\tvisited[i][j] = 1;\\n\\t\\t\\t\\tq1.push({i, j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\npublic:\\n\\tint shortestBridge(vector<vector<int>> &grid)\\n\\t{\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\n\\t\\tbool bat = 0;\\n\\t\\tvisited.resize(n + 1, vector<int>(m + 1, 0));\\n\\t\\tint i, j;\\n\\t\\t//to take all 1\\'s of one component;\\n\\t\\tfor (i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tfor (j = 0; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbfs(grid, i, j);  \\n\\t\\t\\t\\t\\tbat = 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (bat)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\t//bfs2 is to increment value\\n\\t\\treturn bfs2(grid) - 1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920292,
                "title": "dfs-bfs-solution-explain-propelry-easy-to-understand",
                "content": "**# \\t<-----IF YOU LIKE THE EXPLAINATION UPVOTE ME**\\n\\t\\n\\t\\n\\tExplaination : \\n* \\tfist using dfs mark all the value of first iland as 2\\n* \\tthen we know that there are only two ilands in the question so all the remaining 1\\'s are of 2nd iland so add all them in queue\\n* \\tpass this queue in BFS and bsf will find the minimum path to iland one i.e the value we mark as 2 if use this as condition of return \\n* \\tnote in return of the final ans I have substract -1 bcz in BFS I have added distace for 2 also.\\n\\nFill free to give any suggestions.\\n\\n\\n\\t\\n\\t\\tclass Solution:\\n\\t\\tdef shortestBridge(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tq, n, count = deque(), len(grid), 0\\n\\t\\t\\t\\n\\t\\t\\t#used dfs to mark all one\\'s of first iland as 2\\n\\t\\t\\tdef dfs(i,j):\\n\\t\\t\\t\\tif 0<=i<n and 0<=j<n and grid[i][j] == 1:\\n\\t\\t\\t\\t\\tgrid[i][j] = 2\\n\\t\\t\\t\\t\\tdfs(i,j-1) or dfs(i,j+1) or dfs(i+1,j) or dfs(i-1,j)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#used bfs to find the min distance between iland\\n\\t\\t\\tdef bfs(q):\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\twhile q:\\n\\t\\t\\t\\t\\ti, j, dist = q.popleft()\\n\\t\\t\\t\\t\\tif grid[i][j] == 2:\\n\\t\\t\\t\\t\\t\\treturn dist\\n\\n\\t\\t\\t\\t\\tfor x, y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n\\t\\t\\t\\t\\t\\tif 0<=x<n and 0<=y<n and (x,y) not in visited :\\n\\t\\t\\t\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\t\\t\\t\\tq.append((x,y,dist+1))\\n\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\t\\tif count == 0:         #due to this conditon dfs run for only first iland\\n\\t\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\t\\t\\tdfs(i,j)\\n\\t\\t\\t\\t\\t\\telse :\\n\\t\\t\\t\\t\\t\\t\\tq.append((i,j,0))          #appending all one\\'s of second iland in queue to use bfs \\n\\t\\t\\treturn bfs(q) - 1",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "**# \\t<-----IF YOU LIKE THE EXPLAINATION UPVOTE ME**\\n\\t\\n\\t\\n\\tExplaination : \\n* \\tfist using dfs mark all the value of first iland as 2\\n* \\tthen we know that there are only two ilands in the question so all the remaining 1\\'s are of 2nd iland so add all them in queue\\n* \\tpass this queue in BFS and bsf will find the minimum path to iland one i.e the value we mark as 2 if use this as condition of return \\n* \\tnote in return of the final ans I have substract -1 bcz in BFS I have added distace for 2 also.\\n\\nFill free to give any suggestions.\\n\\n\\n\\t\\n\\t\\tclass Solution:\\n\\t\\tdef shortestBridge(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tq, n, count = deque(), len(grid), 0\\n\\t\\t\\t\\n\\t\\t\\t#used dfs to mark all one\\'s of first iland as 2\\n\\t\\t\\tdef dfs(i,j):\\n\\t\\t\\t\\tif 0<=i<n and 0<=j<n and grid[i][j] == 1:\\n\\t\\t\\t\\t\\tgrid[i][j] = 2\\n\\t\\t\\t\\t\\tdfs(i,j-1) or dfs(i,j+1) or dfs(i+1,j) or dfs(i-1,j)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#used bfs to find the min distance between iland\\n\\t\\t\\tdef bfs(q):\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\twhile q:\\n\\t\\t\\t\\t\\ti, j, dist = q.popleft()\\n\\t\\t\\t\\t\\tif grid[i][j] == 2:\\n\\t\\t\\t\\t\\t\\treturn dist\\n\\n\\t\\t\\t\\t\\tfor x, y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n\\t\\t\\t\\t\\t\\tif 0<=x<n and 0<=y<n and (x,y) not in visited :\\n\\t\\t\\t\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\t\\t\\t\\tq.append((x,y,dist+1))\\n\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\t\\tif count == 0:         #due to this conditon dfs run for only first iland\\n\\t\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\t\\t\\tdfs(i,j)\\n\\t\\t\\t\\t\\t\\telse :\\n\\t\\t\\t\\t\\t\\t\\tq.append((i,j,0))          #appending all one\\'s of second iland in queue to use bfs \\n\\t\\t\\treturn bfs(q) - 1",
                "codeTag": "Java"
            },
            {
                "id": 1885160,
                "title": "python-sol-bfs-dfs-well-written-explained",
                "content": "**Runtime: 441 ms, faster than 80.65% of Python3 online submissions for Shortest Bridge.\\nMemory Usage: 17.3 MB, less than 38.11% of Python3 online submissions for Shortest Bridge.**\\n\\n# EXPLANATION\\n```\\nFirst we seperate two islands\\nFor this traverse the grid :\\n         whenever we found a 1 ( a part of a island ) we use DFS and change the value of \\n\\t\\t every cell of this island to 2 and store the location to an arrray/list\\n\\t\\t \\nNow since there can be many paths but we need the smallest path we use BFS\\nSo we start with our island we made the value 2 for .\\nNow whenever we visit an adjacent from queue item \\n         If it\\'s 1 you know that you reached the second island\\n\\t\\t If it\\'s 2 don\\'t add to queue as all the 2 are already added to queue\\n\\t\\t If it\\'s 0 we make it 2 ( so that we don\\'t get there again ) and add to queue with dis + 1\\n\\t\\t \\n```\\n\\n# CODE\\n```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        island = []\\n        \\n        def dfs(row,col):\\n            grid[row][col] = 2\\n            island.append((row,col,0))\\n            moves = ((row+1,col),(row-1,col),(row,col+1),(row,col-1))\\n            for x,y in moves:\\n                if 0<=x<n and 0<=y<n and grid[x][y] == 1:\\n                    dfs(x,y)\\n        \\n        flag = True\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    dfs(i,j)\\n                    flag = False\\n                    break\\n            if not flag:break\\n                \\n        queue = island\\n        while queue:\\n            r,c,dis = queue.pop(0)\\n            if grid[r][c] == 1:return dis\\n            moves = ((r+1,c),(r-1,c),(r,c-1),(r,c+1))\\n            for x,y in moves:\\n                if 0<=x<n and 0<=y<n and grid[x][y]!=2:\\n                    if grid[x][y] == 1:return dis\\n                    grid[x][y] = 2\\n                    queue.append((x,y,dis+1))\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nFirst we seperate two islands\\nFor this traverse the grid :\\n         whenever we found a 1 ( a part of a island ) we use DFS and change the value of \\n\\t\\t every cell of this island to 2 and store the location to an arrray/list\\n\\t\\t \\nNow since there can be many paths but we need the smallest path we use BFS\\nSo we start with our island we made the value 2 for .\\nNow whenever we visit an adjacent from queue item \\n         If it\\'s 1 you know that you reached the second island\\n\\t\\t If it\\'s 2 don\\'t add to queue as all the 2 are already added to queue\\n\\t\\t If it\\'s 0 we make it 2 ( so that we don\\'t get there again ) and add to queue with dis + 1\\n\\t\\t \\n```\n```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        island = []\\n        \\n        def dfs(row,col):\\n            grid[row][col] = 2\\n            island.append((row,col,0))\\n            moves = ((row+1,col),(row-1,col),(row,col+1),(row,col-1))\\n            for x,y in moves:\\n                if 0<=x<n and 0<=y<n and grid[x][y] == 1:\\n                    dfs(x,y)\\n        \\n        flag = True\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    dfs(i,j)\\n                    flag = False\\n                    break\\n            if not flag:break\\n                \\n        queue = island\\n        while queue:\\n            r,c,dis = queue.pop(0)\\n            if grid[r][c] == 1:return dis\\n            moves = ((r+1,c),(r-1,c),(r,c-1),(r,c+1))\\n            for x,y in moves:\\n                if 0<=x<n and 0<=y<n and grid[x][y]!=2:\\n                    if grid[x][y] == 1:return dis\\n                    grid[x][y] = 2\\n                    queue.append((x,y,dis+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650681,
                "title": "c-bfs-from-one-island-to-another",
                "content": "Since the question mentions that there will always be exactly two islands, we will try to find all the points in one island and do the bfs from those points to another island. As soon as we get to another island, we reached the solution.\\n\\nUpdate: One more optimization that we can do, instead of pushing all the nodes into the queue for BFS, we can only push the nodes which are at border.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    queue<pair<int, int>> Q;\\n    void dfs(int x, int y, vector<vector<int>> &mat) {\\n        auto isValid = [&](int A, int B) {\\n            return (A >= 0 && A < n && B >= 0 && B < m && mat[A][B] == 1);\\n        };\\n        Q.push({x, y});\\n        mat[x][y] = -1;\\n        int dir[] = {-1, 0, 1, 0, -1};\\n        for (int i = 0; i < 4; ++i) {\\n            int X = x + dir[i];\\n            int Y = y + dir[i + 1];\\n            if (isValid(X, Y)) {\\n                dfs(X, Y, mat);\\n            }\\n        }\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        bool haveFound = false;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    dfs(i, j, grid);\\n                    haveFound = true;\\n                    break;\\n                }\\n            }\\n            if (haveFound)  break;\\n        }\\n        auto isValid = [&](int A, int B) {\\n            return (A >= 0 && A < n && B >= 0 && B < m);\\n        };\\n        int depth = -1;\\n        while(Q.size() > 0) {\\n            int N = Q.size();\\n            ++depth;\\n            while(N--) {\\n                const auto node = Q.front();\\n                Q.pop();\\n                int dir[] = {-1, 0, 1, 0, -1};\\n                for (int i = 0; i < 4; ++i) {\\n                    int X = node.first + dir[i];\\n                    int Y = node.second + dir[i + 1];\\n                    if (isValid(X, Y)) {\\n                        if (grid[X][Y] == 1) return depth;\\n                        if (grid[X][Y] == 0) {\\n                            Q.push({X, Y});\\n                            grid[X][Y] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```\\n\\n<ins>Optimized DFS:</ins>\\n\\n```cpp\\nvoid dfs(int x, int y, vector<vector<int>> &mat) {\\n    auto isValid = [&](int A, int B) {\\n        return (A >= 0 && A < n && B >= 0 && B < m && mat[A][B] == 1);\\n    };\\n    int childCount = 4;\\n    mat[x][y] = -1;\\n    int dir[] = {-1, 0, 1, 0, -1};\\n    for (int i = 0; i < 4; ++i) {\\n        int X = x + dir[i];\\n        int Y = y + dir[i + 1];\\n        if (isValid(X, Y)) {\\n            dfs(X, Y, mat);\\n            --childCount;\\n        }\\n    }\\n    //it means that the current node is not internal node\\n    if (childCount != 0) {\\n        Q.push({x, y});\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    queue<pair<int, int>> Q;\\n    void dfs(int x, int y, vector<vector<int>> &mat) {\\n        auto isValid = [&](int A, int B) {\\n            return (A >= 0 && A < n && B >= 0 && B < m && mat[A][B] == 1);\\n        };\\n        Q.push({x, y});\\n        mat[x][y] = -1;\\n        int dir[] = {-1, 0, 1, 0, -1};\\n        for (int i = 0; i < 4; ++i) {\\n            int X = x + dir[i];\\n            int Y = y + dir[i + 1];\\n            if (isValid(X, Y)) {\\n                dfs(X, Y, mat);\\n            }\\n        }\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        bool haveFound = false;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    dfs(i, j, grid);\\n                    haveFound = true;\\n                    break;\\n                }\\n            }\\n            if (haveFound)  break;\\n        }\\n        auto isValid = [&](int A, int B) {\\n            return (A >= 0 && A < n && B >= 0 && B < m);\\n        };\\n        int depth = -1;\\n        while(Q.size() > 0) {\\n            int N = Q.size();\\n            ++depth;\\n            while(N--) {\\n                const auto node = Q.front();\\n                Q.pop();\\n                int dir[] = {-1, 0, 1, 0, -1};\\n                for (int i = 0; i < 4; ++i) {\\n                    int X = node.first + dir[i];\\n                    int Y = node.second + dir[i + 1];\\n                    if (isValid(X, Y)) {\\n                        if (grid[X][Y] == 1) return depth;\\n                        if (grid[X][Y] == 0) {\\n                            Q.push({X, Y});\\n                            grid[X][Y] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```\n```cpp\\nvoid dfs(int x, int y, vector<vector<int>> &mat) {\\n    auto isValid = [&](int A, int B) {\\n        return (A >= 0 && A < n && B >= 0 && B < m && mat[A][B] == 1);\\n    };\\n    int childCount = 4;\\n    mat[x][y] = -1;\\n    int dir[] = {-1, 0, 1, 0, -1};\\n    for (int i = 0; i < 4; ++i) {\\n        int X = x + dir[i];\\n        int Y = y + dir[i + 1];\\n        if (isValid(X, Y)) {\\n            dfs(X, Y, mat);\\n            --childCount;\\n        }\\n    }\\n    //it means that the current node is not internal node\\n    if (childCount != 0) {\\n        Q.push({x, y});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248945,
                "title": "brute-force-solution-java",
                "content": "class pair{\\n        int first;\\n        int second;\\n        \\n        pair(int first,int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n}\\nclass Solution {\\n    \\n    public int shortestBridge(int[][] grid) {\\n        \\n        int count = 0;\\n        ArrayList<pair> a = new ArrayList<>();\\n        ArrayList<pair> b = new ArrayList<>();\\n        \\n        for(int i=0; i<grid.length; i++)\\n        {\\n            for(int j=0; j<grid[0].length; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    count++;\\n                    if(count == 1)\\n                    {\\n                        dfs(grid, i, j, a);   \\n                    }\\n                    if(count == 2)\\n                    {\\n                        dfs(grid, i, j, b);   \\n                    }   \\n                }\\n            }\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int i=0; i<a.size(); i++)\\n        {\\n            for(int j=0; j<b.size(); j++)\\n            {\\n                int dist = Math.abs(a.get(i).first - b.get(j).first) + Math.abs(a.get(i).second - b.get(j).second) - 1;\\n                if(dist < ans)\\n                    ans = dist;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public static void dfs(int[][] grid, int i, int j, ArrayList<pair> a)\\n    {\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j]==0)\\n            return;\\n        \\n        grid[i][j] = 0;\\n        pair p = new pair(i,j);\\n        a.add(p);\\n        \\n        dfs(grid, i+1, j, a);\\n        dfs(grid, i-1, j, a);\\n        dfs(grid, i, j-1, a);\\n        dfs(grid, i, j+1, a);\\n        \\n        return;\\n    }\\n}\\n\\n\\nWe have only two islands so put coordinates of both island in two different arralist and find minimum distance from those coordinates...",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public int shortestBridge(int[][] grid) {\\n        \\n        int count = 0;\\n        ArrayList<pair> a = new ArrayList<>();\\n        ArrayList<pair> b = new ArrayList<>();\\n        \\n        for(int i=0; i<grid.length; i++)\\n        {\\n            for(int j=0; j<grid[0].length; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    count++;\\n                    if(count == 1)\\n                    {\\n                        dfs(grid, i, j, a);   \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 824450,
                "title": "explained-c-bfs-dfs-based-solution-commented",
                "content": "-> mark all the 1\\'s that belong to first island using dfs\\n->store all the points for first island so to start from here we can move toward second island\\n->we perform bfs so to reach 2nd island because from all the available points to be flipped we have to only flip one point in one layer and bfs allow to cover one layer in one round.\\n->as we reach the 1 which has not been visited before we will return the count of how may times we have performed bfs that has been stored in res variable, as this is the count of in how many layers we have flipped the value.\\n```\\nclass Solution {\\npublic:\\n      /*Move in four direction*/\\n      vector<int>dx={1,-1,0,0};\\n       vector<int>dy={0,0,1,-1};\\n      \\n    vector<vector<bool>>vis;\\n    vector<vector<int>>v;\\n     int n,m,res;\\n    int shortestBridge(vector<vector<int>>& A) {\\n         n=A.size();\\n         m=A[0].size();\\n         v=A;\\n         res=0;\\n         vis.resize(n,vector<bool>(m,false));\\n        \\n        /* For marking 1st island as visited*/\\n         for(int i=0;i<n;i++)\\n         {\\n             int f=0;\\n             for(int j=0;j<m;j++)\\n               if(v[i][j]==1){dfs(i,j);f=1;break;}  \\n             \\n             if(f)break;//as there are only two island and 1 is already visited\\n         }\\n        \\n         /* To store all the points corresponding to 1st island*/\\n         queue<pair<int,int>>qp;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(vis[i][j])\\n                    qp.push({i,j});\\n        \\n         bfs(qp);\\n        \\n        return res;\\n    }\\n    \\n    /*To find the first island*/\\n    void dfs(int x,int y)\\n    {\\n        vis[x][y]=true;\\n        for(int i=0;i<4;i++)\\n        {\\nif(check(x+dx[i],y+dy[i]) && v[x+dx[i]][y+dy[i]]==1 && vis[x+dx[i]][y+dy[i]]==false)\\n                dfs(x+dx[i],y+dy[i]);\\n        }\\n    }\\n    \\n    /*To iterate through the matrix starting from 1st island until we reach 2nd island*/\\n    void bfs(queue<pair<int,int>>q)\\n    {\\n        queue<pair<int,int>>tmp;//storing the points to flipped so to reach 2nd island\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            int x=p.first,y=p.second;\\n            for(int i=0;i<4;i++)\\n            if(check(x+dx[i],y+dy[i]) && vis[x+dx[i]][y+dy[i]]==false) \\n            {\\n                if(v[x+dx[i]][y+dy[i]]==1)return; //we reached the second island\\n                \\n                vis[x+dx[i]][y+dy[i]]=true;\\n                tmp.push({x+dx[i],y+dy[i]});\\n            }\\n        }\\n        res++; // only one of all the tmp points should flipped in this layer\\n       \\n        bfs(tmp);\\n    }\\n    \\n    /*To check if point is valid*/\\n    bool check(int x,int y)\\n    {\\n        if(x>=0 &&x<n && y>=0 && y<m)return true;\\n        return false;\\n    }\\n        \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n      /*Move in four direction*/\\n      vector<int>dx={1,-1,0,0};\\n       vector<int>dy={0,0,1,-1};\\n      \\n    vector<vector<bool>>vis;\\n    vector<vector<int>>v;\\n     int n,m,res;\\n    int shortestBridge(vector<vector<int>>& A) {\\n         n=A.size();\\n         m=A[0].size();\\n         v=A;\\n         res=0;\\n         vis.resize(n,vector<bool>(m,false));\\n        \\n        /* For marking 1st island as visited*/\\n         for(int i=0;i<n;i++)\\n         {\\n             int f=0;\\n             for(int j=0;j<m;j++)\\n               if(v[i][j]==1){dfs(i,j);f=1;break;}  \\n             \\n             if(f)break;//as there are only two island and 1 is already visited\\n         }\\n        \\n         /* To store all the points corresponding to 1st island*/\\n         queue<pair<int,int>>qp;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(vis[i][j])\\n                    qp.push({i,j});\\n        \\n         bfs(qp);\\n        \\n        return res;\\n    }\\n    \\n    /*To find the first island*/\\n    void dfs(int x,int y)\\n    {\\n        vis[x][y]=true;\\n        for(int i=0;i<4;i++)\\n        {\\nif(check(x+dx[i],y+dy[i]) && v[x+dx[i]][y+dy[i]]==1 && vis[x+dx[i]][y+dy[i]]==false)\\n                dfs(x+dx[i],y+dy[i]);\\n        }\\n    }\\n    \\n    /*To iterate through the matrix starting from 1st island until we reach 2nd island*/\\n    void bfs(queue<pair<int,int>>q)\\n    {\\n        queue<pair<int,int>>tmp;//storing the points to flipped so to reach 2nd island\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            int x=p.first,y=p.second;\\n            for(int i=0;i<4;i++)\\n            if(check(x+dx[i],y+dy[i]) && vis[x+dx[i]][y+dy[i]]==false) \\n            {\\n                if(v[x+dx[i]][y+dy[i]]==1)return; //we reached the second island\\n                \\n                vis[x+dx[i]][y+dy[i]]=true;\\n                tmp.push({x+dx[i],y+dy[i]});\\n            }\\n        }\\n        res++; // only one of all the tmp points should flipped in this layer\\n       \\n        bfs(tmp);\\n    }\\n    \\n    /*To check if point is valid*/\\n    bool check(int x,int y)\\n    {\\n        if(x>=0 &&x<n && y>=0 && y<m)return true;\\n        return false;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603220,
                "title": "c-flood-fill-to-distinguish-between-island-1-and-2-coordinates-and-apply-distance-formula",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> A;\\n    vector<pair<int, int>> B;\\n    \\n    int dx[4] = {0, 1, -1, 0};\\n    int dy[4] = {1, 0, 0, -1};\\n    \\n    void flood_fill(vector<vector<int>>& grid, int i, int j, vector<vector<bool>>& visited, vector<pair<int, int>>& arr) {\\n        if ((i > grid.size()-1 || i < 0 || j > grid[0].size()-1 || j < 0) || !grid[i][j] || visited[i][j]) return;\\n        visited[i][j] = true;\\n        arr.push_back(make_pair(i, j));\\n        for (int k=0; k<4; k++) {\\n            flood_fill(grid, i+dx[k], j+dy[k], visited, arr);\\n        }\\n    }\\n    \\n    int getDist(pair<int, int>& p1, pair<int, int>& p2) {\\n        return abs(p1.first - p2.first) + abs(p1.second - p2.second) - 1;\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\\n        bool doneA = false;\\n        for (int i=0; i<grid.size(); i++) {\\n            for (int j=0; j<grid[0].size(); j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    vector<pair<int, int>>* arr = (doneA) ? &B : &A;\\n                    flood_fill(grid, i, j, visited, *arr);\\n                    doneA = ~doneA;\\n                }\\n            }\\n        }\\n        int minDistance = 2 * grid.size()-1;\\n        for (auto p1 : A) {\\n            for (auto p2 : B) {\\n                minDistance = min(minDistance, getDist(p1, p2));\\n            }\\n        }\\n        return minDistance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> A;\\n    vector<pair<int, int>> B;\\n    \\n    int dx[4] = {0, 1, -1, 0};\\n    int dy[4] = {1, 0, 0, -1};\\n    \\n    void flood_fill(vector<vector<int>>& grid, int i, int j, vector<vector<bool>>& visited, vector<pair<int, int>>& arr) {\\n        if ((i > grid.size()-1 || i < 0 || j > grid[0].size()-1 || j < 0) || !grid[i][j] || visited[i][j]) return;\\n        visited[i][j] = true;\\n        arr.push_back(make_pair(i, j));\\n        for (int k=0; k<4; k++) {\\n            flood_fill(grid, i+dx[k], j+dy[k], visited, arr);\\n        }\\n    }\\n    \\n    int getDist(pair<int, int>& p1, pair<int, int>& p2) {\\n        return abs(p1.first - p2.first) + abs(p1.second - p2.second) - 1;\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\\n        bool doneA = false;\\n        for (int i=0; i<grid.size(); i++) {\\n            for (int j=0; j<grid[0].size(); j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    vector<pair<int, int>>* arr = (doneA) ? &B : &A;\\n                    flood_fill(grid, i, j, visited, *arr);\\n                    doneA = ~doneA;\\n                }\\n            }\\n        }\\n        int minDistance = 2 * grid.size()-1;\\n        for (auto p1 : A) {\\n            for (auto p2 : B) {\\n                minDistance = min(minDistance, getDist(p1, p2));\\n            }\\n        }\\n        return minDistance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413724,
                "title": "java-bfs-dfs-space-efficient-solution",
                "content": "Use DFS to find the border of the first island then use BFS to find the minimum length of the bridge. Use the matrix itself to record visited cells to save space.  \\n\\n```\\nclass Solution {\\n\\n\\tprivate static final int[] DIRECTIONS = new int[]{0, -1, 0, 1, 0};\\n\\n\\t// time O(m*n), space O(m*n)\\n\\tpublic int shortestBridge(int[][] A) {\\n\\t\\tLinkedList<int[]> queue = new LinkedList<>();\\n\\t\\tint m = A.length, n = A[0].length, a = -1, b = -1;\\n\\t\\tboolean stop = false;\\n\\t\\tfor(int i = 0; i < m && !stop; i++){\\n\\t\\t\\tfor(int j = 0; j < n && !stop; j++){\\n\\t\\t\\t\\tif(A[i][j] == 1){\\n\\t\\t\\t\\t\\ta = i;\\n\\t\\t\\t\\t\\tb = j;\\n\\t\\t\\t\\t\\tstop = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// dfs find the surrounding water cells of the first island\\n\\t\\tdfs(a, b, A, m, n, queue);\\n\\n\\t\\t// bfs to find the shortest path to the second island\\n\\t\\tint steps = 1;\\n\\t\\twhile(!queue.isEmpty()){\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\twhile(size-- > 0){\\n\\t\\t\\t\\tint[] cur = queue.pollFirst();\\n\\t\\t\\t\\tfor(int k = 0; k < 4; k++){\\n\\t\\t\\t\\t\\tint x = cur[0] + DIRECTIONS[k], y = cur[1] + DIRECTIONS[k + 1];\\n\\t\\t\\t\\t\\tif(x < 0 || x >= m || y < 0 || y >= n || A[x][y] == -1){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(A[x][y] == 1){\\n\\t\\t\\t\\t\\t\\treturn steps;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tA[x][y] = -1;\\n\\t\\t\\t\\t\\t\\tqueue.offerLast(new int[]{x, y});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsteps++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tprivate void dfs(int i, int j, int[][] A, int m, int n, LinkedList<int[]> queue){\\n\\t\\tA[i][j] = -1;\\n\\t\\tfor(int k = 0; k < 4; k++){\\n\\t\\t\\tint x = i + DIRECTIONS[k], y = j + DIRECTIONS[k + 1];\\n\\t\\t\\tif(x < 0 || x >= m || y < 0 || y >= n || A[x][y] == -1){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif(A[x][y] == 1){\\n\\t\\t\\t\\tdfs(x, y, A, m, n, queue);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tA[x][y] = -1;\\n\\t\\t\\t\\tqueue.offerLast(new int[]{x, y});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n\\tprivate static final int[] DIRECTIONS = new int[]{0, -1, 0, 1, 0};\\n\\n\\t// time O(m*n), space O(m*n)\\n\\tpublic int shortestBridge(int[][] A) {\\n\\t\\tLinkedList<int[]> queue = new LinkedList<>();\\n\\t\\tint m = A.length, n = A[0].length, a = -1, b = -1;\\n\\t\\tboolean stop = false;\\n\\t\\tfor(int i = 0; i < m && !stop; i++){\\n\\t\\t\\tfor(int j = 0; j < n && !stop; j++){\\n\\t\\t\\t\\tif(A[i][j] == 1){\\n\\t\\t\\t\\t\\ta = i;\\n\\t\\t\\t\\t\\tb = j;\\n\\t\\t\\t\\t\\tstop = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// dfs find the surrounding water cells of the first island\\n\\t\\tdfs(a, b, A, m, n, queue);\\n\\n\\t\\t// bfs to find the shortest path to the second island\\n\\t\\tint steps = 1;\\n\\t\\twhile(!queue.isEmpty()){\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\twhile(size-- > 0){\\n\\t\\t\\t\\tint[] cur = queue.pollFirst();\\n\\t\\t\\t\\tfor(int k = 0; k < 4; k++){\\n\\t\\t\\t\\t\\tint x = cur[0] + DIRECTIONS[k], y = cur[1] + DIRECTIONS[k + 1];\\n\\t\\t\\t\\t\\tif(x < 0 || x >= m || y < 0 || y >= n || A[x][y] == -1){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(A[x][y] == 1){\\n\\t\\t\\t\\t\\t\\treturn steps;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tA[x][y] = -1;\\n\\t\\t\\t\\t\\t\\tqueue.offerLast(new int[]{x, y});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsteps++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tprivate void dfs(int i, int j, int[][] A, int m, int n, LinkedList<int[]> queue){\\n\\t\\tA[i][j] = -1;\\n\\t\\tfor(int k = 0; k < 4; k++){\\n\\t\\t\\tint x = i + DIRECTIONS[k], y = j + DIRECTIONS[k + 1];\\n\\t\\t\\tif(x < 0 || x >= m || y < 0 || y >= n || A[x][y] == -1){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif(A[x][y] == 1){\\n\\t\\t\\t\\tdfs(x, y, A, m, n, queue);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tA[x][y] = -1;\\n\\t\\t\\t\\tqueue.offerLast(new int[]{x, y});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189320,
                "title": "c-solution-using-dfs-flood-fill",
                "content": "1-find island no. 1 by using flood fill algo (storing coordinates of island in a set)\n2-find island no.2 using flood fill\n3-loop throught both sets to find shortest path \n```\n#include <unordered_set>\n#include <boost/functional/hash.hpp>\nclass Solution {\npublic:\n    void flood_fill(vector<vector<int>>& ar,int x,int y,int m,int n,int colour,set<pair<int,int>> &s,int k)\n    {   if(x<0||y<0||x>=n||y>=m||ar[x][y]!=colour)\n        {\n           return ;\n        }\n        ar[x][y]=k;\n        pair<int,int> p=make_pair(x,y);\n        if(s.count(p)==0)\n        {  //cout<<\" ds\";\n            s.insert(p);\n        }\n        flood_fill(ar,x,y+1,m,n,colour,s,k);\n        flood_fill(ar,x+1,y,m,n,colour,s,k);\n        flood_fill(ar,x-1,y,m,n,colour,s,k);\n        flood_fill(ar,x,y-1,m,n,colour,s,k);\n    }\n    int shortestBridge(vector<vector<int>>& A) \n    {\n        int n=A.size();\n        int m=A[0].size();\n       set<pair<int,int>> s1;\n        set<pair<int,int>> s2;\n        for(int i=0;i<n;i++)\n        {\n            int flag=0;\n            for(int j=0;j<m;j++)\n            {\n                if(A[i][j]==1)\n                {\n                    flood_fill(A,i,j,m,n,1,s1,2);\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==1)\n            {\n                break;\n            }\n        }\n        for(int i=0;i<n;i++)\n        {\n             int flag=0;\n            for(int j=0;j<m;j++)\n            {\n                if(A[i][j]==1)\n                {\n                    flood_fill(A,i,j,m,n,1,s2,2);\n                    break;\n                    flag=1;\n                }\n            }\n            if(flag==1)\n            {\n                break;\n            }\n        }\n     \n     //   cout<<s1.size()<<\" \"<<s2.size();\n        int ans=INT_MAX;\n        for(auto a:s1)\n        {\n            for(auto b:s2)\n            {\n                //cout<<a.first<<\" \"<<a.second<<\" \"<<b.first<<\" \"<<b.second<<endl;\n               int op=abs(a.first-b.first)+abs(a.second-b.second);\n                ans=min(ans,op);\n            }\n        }\n        return ans-1;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\n#include <unordered_set>\n#include <boost/functional/hash.hpp>\nclass Solution {\npublic:\n    void flood_fill(vector<vector<int>>& ar,int x,int y,int m,int n,int colour,set<pair<int,int>> &s,int k)\n    {   if(x<0||y<0||x>=n||y>=m||ar[x][y]!=colour)\n        {\n           return ;\n        }\n        ar[x][y]=k;\n        pair<int,int> p=make_pair(x,y);\n        if(s.count(p)==0)\n        {  //cout<<\" ds\";\n            s.insert(p);\n        }\n        flood_fill(ar,x,y+1,m,n,colour,s,k);\n        flood_fill(ar,x+1,y,m,n,colour,s,k);\n        flood_fill(ar,x-1,y,m,n,colour,s,k);\n        flood_fill(ar,x,y-1,m,n,colour,s,k);\n    }\n    int shortestBridge(vector<vector<int>>& A) \n    {\n        int n=A.size();\n        int m=A[0].size();\n       set<pair<int,int>> s1;\n        set<pair<int,int>> s2;\n        for(int i=0;i<n;i++)\n        {\n            int flag=0;\n            for(int j=0;j<m;j++)\n            {\n                if(A[i][j]==1)\n                {\n                    flood_fill(A,i,j,m,n,1,s1,2);\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==1)\n            {\n                break;\n            }\n        }\n        for(int i=0;i<n;i++)\n        {\n             int flag=0;\n            for(int j=0;j<m;j++)\n            {\n                if(A[i][j]==1)\n                {\n                    flood_fill(A,i,j,m,n,1,s2,2);\n                    break;\n                    flag=1;\n                }\n            }\n            if(flag==1)\n            {\n                break;\n            }\n        }\n     \n     //   cout<<s1.size()<<\" \"<<s2.size();\n        int ans=INT_MAX;\n        for(auto a:s1)\n        {\n            for(auto b:s2)\n            {\n                //cout<<a.first<<\" \"<<a.second<<\" \"<<b.first<<\" \"<<b.second<<endl;\n               int op=abs(a.first-b.first)+abs(a.second-b.second);\n                ans=min(ans,op);\n            }\n        }\n        return ans-1;\n    }\n};\n```",
                "codeTag": "C++"
            },
            {
                "id": 3617398,
                "title": "dfs-with-distance-formula-self-explanatory-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\\n#define trav(a, x) for (auto& a : x) \\n\\nclass Solution {\\npublic:\\n    \\n    bool isinside(int x, int y, int& n)\\n    {\\n        if (x >= 0 and x < n and y >= 0 and y < n)\\n            return true;\\n        return false;\\n    }\\n\\n\\n    void dfs1(int x, int y, int& n, vector<vector<int>>& arr, set<pair<int, int>>& st)\\n    {\\n        if (isinside(x, y, n) and arr[x][y] == 1)\\n        {\\n            arr[x][y] = 2;\\n            st.insert({ x,y });\\n            dfs1(x + 1, y, n, arr,st);\\n            dfs1(x - 1, y, n, arr,st);\\n            dfs1(x, y + 1, n, arr,st);\\n            dfs1(x, y - 1, n, arr,st);\\n        }\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        int x = -1, y = -1;\\n        \\n        // we start form a land and mark all connected land cell as 2\\n        // this will seperate one island (marked with 2) with other (marked with 1)\\n        // since there are only 2 island so marking only one island will differentiate the other one\\n        rep(i, 0, n)\\n        {\\n            rep(j, 0, n)\\n            {\\n                if (arr[i][j])\\n                {\\n                    x = i, y = j;\\n                    break;\\n                }\\n            }\\n        }\\n        // we create a set of pair which will store the coordinates of every\\n        // cell of island 2\\n\\n        set<pair<int, int>>st;\\n        dfs1(x, y, n, arr,st);\\n\\n        int ans = INT_MAX;\\n\\n        // now from every cell of island 1 we will calculate the distance of every \\n        // cell of island 2 and output the minimum distance among them\\n        rep(i, 0, n)\\n        {\\n            rep(j, 0, n)\\n            {\\n                if (arr[i][j] == 1)\\n                {\\n                    trav(k, st)\\t\\t// traversing all the coordinates of island 2\\n                    {\\n                        ans = min(ans, abs(k.first - i) + abs(k.second - j) - 1);\\n                        //pr(ans);\\n                    }\\n                }\\n            }\\n        }\\n        //debmat(arr, n, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\\n#define trav(a, x) for (auto& a : x) \\n\\nclass Solution {\\npublic:\\n    \\n    bool isinside(int x, int y, int& n)\\n    {\\n        if (x >= 0 and x < n and y >= 0 and y < n)\\n            return true;\\n        return false;\\n    }\\n\\n\\n    void dfs1(int x, int y, int& n, vector<vector<int>>& arr, set<pair<int, int>>& st)\\n    {\\n        if (isinside(x, y, n) and arr[x][y] == 1)\\n        {\\n            arr[x][y] = 2;\\n            st.insert({ x,y });\\n            dfs1(x + 1, y, n, arr,st);\\n            dfs1(x - 1, y, n, arr,st);\\n            dfs1(x, y + 1, n, arr,st);\\n            dfs1(x, y - 1, n, arr,st);\\n        }\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        int x = -1, y = -1;\\n        \\n        // we start form a land and mark all connected land cell as 2\\n        // this will seperate one island (marked with 2) with other (marked with 1)\\n        // since there are only 2 island so marking only one island will differentiate the other one\\n        rep(i, 0, n)\\n        {\\n            rep(j, 0, n)\\n            {\\n                if (arr[i][j])\\n                {\\n                    x = i, y = j;\\n                    break;\\n                }\\n            }\\n        }\\n        // we create a set of pair which will store the coordinates of every\\n        // cell of island 2\\n\\n        set<pair<int, int>>st;\\n        dfs1(x, y, n, arr,st);\\n\\n        int ans = INT_MAX;\\n\\n        // now from every cell of island 1 we will calculate the distance of every \\n        // cell of island 2 and output the minimum distance among them\\n        rep(i, 0, n)\\n        {\\n            rep(j, 0, n)\\n            {\\n                if (arr[i][j] == 1)\\n                {\\n                    trav(k, st)\\t\\t// traversing all the coordinates of island 2\\n                    {\\n                        ans = min(ans, abs(k.first - i) + abs(k.second - j) - 1);\\n                        //pr(ans);\\n                    }\\n                }\\n            }\\n        }\\n        //debmat(arr, n, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548457,
                "title": "optimal-solution-easy-to-understand",
                "content": "\\n\\n# Approach\\nThis optimized solution uses a combination of DFS and BFS to find the shortest path between the two islands. It avoids unnecessary operations and minimizes memory usage, resulting in an efficient solution for the given problem.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int dx[4] = {-1, 1, 0, 0};\\n    const int dy[4] = {0, 0, -1, 1};\\n\\n    bool isValid(int i, int j, int n) {\\n        return (i >= 0 && i < n && j >= 0 && j < n);\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n\\n        // Step 1: Find the first island using DFS and mark its cells as -1\\n        bool found = false;\\n        for (int i = 0; i < n; ++i) {\\n            if (found)\\n                break;\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j]) {\\n                    dfs(i, j, n, grid);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // Step 2: Perform a BFS search to find the second island\\n        queue<pair<int, int>> q;\\n        int steps = 0;\\n\\n        // Add the cells of the first island to the BFS queue\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == -1) {\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n\\n        // Perform BFS search\\n        while (!q.empty()) {\\n            int size = q.size();\\n\\n            while (size--) {\\n                auto node = q.front();\\n                q.pop();\\n\\n                for (int x = 0; x < 4; ++x) {\\n                    int ni = node.first + dx[x];\\n                    int nj = node.second + dy[x];\\n\\n                    if (isValid(ni, nj, n)) {\\n                        if (grid[ni][nj] == 1) {\\n                            return steps;\\n                        }\\n\\n                        if (grid[ni][nj] == 0) {\\n                            grid[ni][nj] = -1;\\n                            q.push({ni, nj});\\n                        }\\n                    }\\n                }\\n            }\\n\\n            steps++;\\n        }\\n\\n        return -1; // No path found\\n    }\\n\\n    void dfs(int i, int j, int n, vector<vector<int>>& grid) {\\n        if (i < 0 || i >= n || j < 0 || j >= n || grid[i][j] != 1)\\n            return;\\n\\n        grid[i][j] = -1;\\n\\n        dfs(i - 1, j, n, grid);\\n        dfs(i + 1, j, n, grid);\\n        dfs(i, j - 1, n, grid);\\n        dfs(i, j + 1, n, grid);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int dx[4] = {-1, 1, 0, 0};\\n    const int dy[4] = {0, 0, -1, 1};\\n\\n    bool isValid(int i, int j, int n) {\\n        return (i >= 0 && i < n && j >= 0 && j < n);\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n\\n        // Step 1: Find the first island using DFS and mark its cells as -1\\n        bool found = false;\\n        for (int i = 0; i < n; ++i) {\\n            if (found)\\n                break;\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j]) {\\n                    dfs(i, j, n, grid);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // Step 2: Perform a BFS search to find the second island\\n        queue<pair<int, int>> q;\\n        int steps = 0;\\n\\n        // Add the cells of the first island to the BFS queue\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == -1) {\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n\\n        // Perform BFS search\\n        while (!q.empty()) {\\n            int size = q.size();\\n\\n            while (size--) {\\n                auto node = q.front();\\n                q.pop();\\n\\n                for (int x = 0; x < 4; ++x) {\\n                    int ni = node.first + dx[x];\\n                    int nj = node.second + dy[x];\\n\\n                    if (isValid(ni, nj, n)) {\\n                        if (grid[ni][nj] == 1) {\\n                            return steps;\\n                        }\\n\\n                        if (grid[ni][nj] == 0) {\\n                            grid[ni][nj] = -1;\\n                            q.push({ni, nj});\\n                        }\\n                    }\\n                }\\n            }\\n\\n            steps++;\\n        }\\n\\n        return -1; // No path found\\n    }\\n\\n    void dfs(int i, int j, int n, vector<vector<int>>& grid) {\\n        if (i < 0 || i >= n || j < 0 || j >= n || grid[i][j] != 1)\\n            return;\\n\\n        grid[i][j] = -1;\\n\\n        dfs(i - 1, j, n, grid);\\n        dfs(i + 1, j, n, grid);\\n        dfs(i, j - 1, n, grid);\\n        dfs(i, j + 1, n, grid);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547816,
                "title": "simple-solution-in-java-divided-into-smaller-functions",
                "content": "# Intuition\\nI know the code looks too long to understand but let me give you a simple Intuition . \\nFirst of all we need to find a single \\'1\\' by running dfs algorithm on this \\'1\\' we\\'ve got we can find all the coordinates of all the \\'1\\'s present in that island and then we fill queue with all the coordinates along with a variable call moves with is zero initially . Refer the Pair class for more details.\\nNow this queue is very much useful for running BFS. \\nWe pop an element from queue one by one and if encounter any zero we add it\\'s coordinates and the popped moves+1 to the queue and continue the process and in this process if we encounter any 1 then we are going to return the popped moves directly.\\n\\n---\\n\\n\\n##### The code is divided into different functions and I\\'m really sorry for writing conditions for checking vertical and horizontal directions separately in DFS and BFS probably not a good practice but written according to the convenience.\\n# Time complexity :\\n$$O(n^2)$$\\n# Space complexity :\\n$$O(n^2)$$\\n\\n---\\n\\n\\n\\n```\\nclass Pair\\n{\\n    int i  = 0 , j = 0, moves = 0;\\n    Pair(int i , int j , int moves)\\n    {\\n        this.i = i;\\n        this.j = j;\\n        this.moves = moves;\\n    }\\n}\\nclass Solution {\\n    public boolean isSafe(int i , int j , int n,boolean[][] visited)\\n    {\\n        return(i>=0 && j>=0 && i<n && j<n && visited[i][j] == false);\\n    }\\n    public void DFS(int[][] grid,int i , int j,int n,boolean[][] visited)\\n    {\\n        if(isSafe(i,j,n,visited) && grid[i][j] == 1)\\n        {\\n            visited[i][j] = true;\\n            DFS(grid,i+1,j,n,visited);\\n            DFS(grid,i-1,j,n,visited);\\n            DFS(grid,i,j+1,n,visited);\\n            DFS(grid,i,j-1,n,visited);\\n        }\\n    }\\n    public int BFS(Queue<Pair> queue,int[][] grid,boolean[][] visited,int n)\\n    {\\n        while(queue.size()!=0)\\n        {\\n            Pair p = queue.poll();\\n            int r = p.i;\\n            int c = p.j;\\n            int m = p.moves;\\n            if(isSafe(r+1,c,n,visited))\\n            {\\n                if(grid[r+1][c] == 1)\\n                    return m;\\n                Pair p1 = new Pair(r+1,c,m+1);\\n                queue.add(p1);\\n                visited[r+1][c] = true;\\n            }\\n            if(isSafe(r-1,c,n,visited))\\n            {\\n                if(grid[r-1][c] == 1)\\n                    return m;\\n                Pair p1 = new Pair(r-1,c,m+1);\\n                queue.add(p1);\\n                visited[r-1][c] = true;\\n            }\\n            if(isSafe(r,c+1,n,visited))\\n            {\\n                if(grid[r][c+1] == 1)\\n                    return m;\\n                Pair p1 = new Pair(r,c+1,m+1);\\n                queue.add(p1);\\n                visited[r][c+1] = true;\\n            }\\n            if(isSafe(r,c-1,n,visited))\\n            {\\n                if(grid[r][c-1] == 1)\\n                    return m;\\n                Pair p1 = new Pair(r,c-1,m+1);\\n                queue.add(p1);\\n                visited[r][c-1] = true;\\n            }\\n        }\\n        return 0;\\n    }\\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        boolean flag = true;\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    DFS(grid,i,j,n,visited);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag == false)\\n                break;\\n        }\\n        Queue<Pair> queue = new LinkedList<>();\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(visited[i][j] == true)\\n                {\\n                    Pair p = new Pair(i,j,0);\\n                    queue.add(p);\\n                }\\n            } \\n        }\\n        return BFS(queue,grid,visited,n);\\n    }\\n}\\n\\n```\\n\\n---\\n\\n\\n##### ***Please don\\'t forget to upvote if you\\'ve liked my explanation !!***\\n\\n---\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Pair\\n{\\n    int i  = 0 , j = 0, moves = 0;\\n    Pair(int i , int j , int moves)\\n    {\\n        this.i = i;\\n        this.j = j;\\n        this.moves = moves;\\n    }\\n}\\nclass Solution {\\n    public boolean isSafe(int i , int j , int n,boolean[][] visited)\\n    {\\n        return(i>=0 && j>=0 && i<n && j<n && visited[i][j] == false);\\n    }\\n    public void DFS(int[][] grid,int i , int j,int n,boolean[][] visited)\\n    {\\n        if(isSafe(i,j,n,visited) && grid[i][j] == 1)\\n        {\\n            visited[i][j] = true;\\n            DFS(grid,i+1,j,n,visited);\\n            DFS(grid,i-1,j,n,visited);\\n            DFS(grid,i,j+1,n,visited);\\n            DFS(grid,i,j-1,n,visited);\\n        }\\n    }\\n    public int BFS(Queue<Pair> queue,int[][] grid,boolean[][] visited,int n)\\n    {\\n        while(queue.size()!=0)\\n        {\\n            Pair p = queue.poll();\\n            int r = p.i;\\n            int c = p.j;\\n            int m = p.moves;\\n            if(isSafe(r+1,c,n,visited))\\n            {\\n                if(grid[r+1][c] == 1)\\n                    return m;\\n                Pair p1 = new Pair(r+1,c,m+1);\\n                queue.add(p1);\\n                visited[r+1][c] = true;\\n            }\\n            if(isSafe(r-1,c,n,visited))\\n            {\\n                if(grid[r-1][c] == 1)\\n                    return m;\\n                Pair p1 = new Pair(r-1,c,m+1);\\n                queue.add(p1);\\n                visited[r-1][c] = true;\\n            }\\n            if(isSafe(r,c+1,n,visited))\\n            {\\n                if(grid[r][c+1] == 1)\\n                    return m;\\n                Pair p1 = new Pair(r,c+1,m+1);\\n                queue.add(p1);\\n                visited[r][c+1] = true;\\n            }\\n            if(isSafe(r,c-1,n,visited))\\n            {\\n                if(grid[r][c-1] == 1)\\n                    return m;\\n                Pair p1 = new Pair(r,c-1,m+1);\\n                queue.add(p1);\\n                visited[r][c-1] = true;\\n            }\\n        }\\n        return 0;\\n    }\\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        boolean flag = true;\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    DFS(grid,i,j,n,visited);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag == false)\\n                break;\\n        }\\n        Queue<Pair> queue = new LinkedList<>();\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(visited[i][j] == true)\\n                {\\n                    Pair p = new Pair(i,j,0);\\n                    queue.add(p);\\n                }\\n            } \\n        }\\n        return BFS(queue,grid,visited,n);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546667,
                "title": "c-dfs-bsf-solutions-with-video-explanation-distance-info-on-the-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find Island A, two types of solutions are commonly used: Depth-First Search (DFS) and Breadth-First Search (BFS).\\n\\nDepth-First Search (DFS):\\n\\nStart from a given cell on the grid and recursively explore its neighboring cells.\\n\\n\\nBreadth-First Search (BFS):\\n\\nStart from a given cell on the grid and explore all its neighboring cells at the same distance level before moving on to the next level.\\nUse a queue to store the cells to be visited.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[https://anwendeng.blogspot.com/2023/05/leetcode-934dfs-bfsc.html](https://anwendeng.blogspot.com/2023/05/leetcode-934dfs-bfsc.html)\\n\\nPlease turn on the English subtitles if necessary\\n\\n[https://youtu.be/9Lx7yr-tmfI](https://youtu.be/9Lx7yr-tmfI)\\n\\nSimilar easier medium problems:\\n[https://leetcode.com/problems/number-of-closed-islands/]()\\n[https://leetcode.com/problems/number-of-enclaves/]()\\n[https://leetcode.com/problems/max-area-of-island/]()\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ngrid =\\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\\n```\\n -1  2 -1 -2  0\\n -1  2 -1  1  1\\n -2 -1 -2  0  1\\n  0 -2  0  0  0\\n  0  0  0  0  0\\n```\\nOther bigger example\\n```\\nd=0\\n -1  0 -1  0  0  0  0  0  0  0\\n  0 -1  2 -1  0  0  0  0  0  0\\n -1  0 -1  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=1\\n -1 -2 -1 -2  0  0  0  0  0  0\\n -2 -1  2 -1 -2  0  0  0  0  0\\n -1 -2 -1 -2  0  0  0  0  0  0\\n -2  0 -2  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=2\\n -1 -2 -1 -2 -3  0  0  0  0  0\\n -2 -1  2 -1 -2 -3  0  0  0  0\\n -1 -2 -1 -2 -3  0  0  0  0  0\\n -2 -3 -2 -3  0  0  0  0  0  0\\n -3  0 -3  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=3\\n -1 -2 -1 -2 -3 -4  0  0  0  0\\n -2 -1  2 -1 -2 -3 -4  0  0  0\\n -1 -2 -1 -2 -3 -4  0  0  0  0\\n -2 -3 -2 -3 -4  0  0  0  0  0\\n -3 -4 -3 -4  0  0  0  0  0  0\\n -4  0 -4  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=4\\n -1 -2 -1 -2 -3 -4 -5  0  0  0\\n -2 -1  2 -1 -2 -3 -4 -5  0  0\\n -1 -2 -1 -2 -3 -4 -5  0  0  0\\n -2 -3 -2 -3 -4 -5  0  0  0  0\\n -3 -4 -3 -4 -5  0  0  0  0  0\\n -4 -5 -4 -5  0  0  0  0  0  0\\n -5  0 -5  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=5\\n -1 -2 -1 -2 -3 -4 -5 -6  0  0\\n -2 -1  2 -1 -2 -3 -4 -5 -6  0\\n -1 -2 -1 -2 -3 -4 -5 -6  0  0\\n -2 -3 -2 -3 -4 -5 -6  0  0  0\\n -3 -4 -3 -4 -5 -6  0  0  0  0\\n -4 -5 -4 -5 -6  0  0  0  0  0\\n -5 -6 -5 -6  0  0  0  0  0  0\\n -6  0 -6  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=6\\n -1 -2 -1 -2 -3 -4 -5 -6 -7  0\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7  0\\n -2 -3 -2 -3 -4 -5 -6 -7  0  0\\n -3 -4 -3 -4 -5 -6 -7  0  0  0\\n -4 -5 -4 -5 -6 -7  0  0  0  0\\n -5 -6 -5 -6 -7  0  0  0  0  0\\n -6 -7 -6 -7  0  0  0  0  0  0\\n -7  0 -7  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -3 -2 -3 -4 -5 -6 -7 -8  0\\n -3 -4 -3 -4 -5 -6 -7 -8  0  0\\n -4 -5 -4 -5 -6 -7 -8  0  0  0\\n -5 -6 -5 -6 -7 -8  0  0  0  0\\n -6 -7 -6 -7 -8  0  0  0  0  0\\n -7 -8 -7 -8  0  0  0  1  1  1\\n -8  0 -8  0  0  0  0  0  0  0\\nd=8\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -3 -2 -3 -4 -5 -6 -7 -8 -9\\n -3 -4 -3 -4 -5 -6 -7 -8 -9  0\\n -4 -5 -4 -5 -6 -7 -8 -9  0  0\\n -5 -6 -5 -6 -7 -8 -9  0  0  0\\n -6 -7 -6 -7 -8 -9  0  0  0  0\\n -7 -8 -7 -8 -9  0  0  1  1  1\\n -8 -9 -8 -9  0  0  0  0  0  0\\nd=9\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -3 -2 -3 -4 -5 -6 -7 -8 -9\\n -3 -4 -3 -4 -5 -6 -7 -8 -9-10\\n -4 -5 -4 -5 -6 -7 -8 -9-10  0\\n -5 -6 -5 -6 -7 -8 -9-10  0  0\\n -6 -7 -6 -7 -8 -9-10  0  0  0\\n -7 -8 -7 -8 -9-10  0  1  1  1\\n -8 -9 -8 -9-10  0  0  0  0  0\\nd=10\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -3 -2 -3 -4 -5 -6 -7 -8 -9\\n -3 -4 -3 -4 -5 -6 -7 -8 -9-10\\n -4 -5 -4 -5 -6 -7 -8 -9-10-11\\n -5 -6 -5 -6 -7 -8 -9-10-11  0\\n -6 -7 -6 -7 -8 -9-10-11  0  0\\n -7 -8 -7 -8 -9-10-11  1  1  1\\n -8 -9 -8 -9-10-11  0  0  0  0\\nReturning\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -3 -2 -3 -4 -5 -6 -7 -8 -9\\n -3 -4 -3 -4 -5 -6 -7 -8 -9-10\\n -4 -5 -4 -5 -6 -7 -8 -9-10-11\\n -5 -6 -5 -6 -7 -8 -9-10-11  0\\n -6 -7 -6 -7 -8 -9-10-11  0  0\\n -7 -8 -7 -8 -9-10-11  1  1  1\\n -8 -9 -8 -9-10-11-12  0  0  0\\nans=11\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    queue<pair<int, int>> Q;\\n\\n    pair<int, int> find_ini_grid(int n, vector<vector<int>>& grid){      \\n        for (int i=0; i<n; i++)\\n            for(int j=0; j<n; j++)\\n                if (grid[i][j]==1){\\n                  return {i, j};  \\n            }\\n        return {-1,-1};\\n    }\\n    void print(int n, vector<vector<int>>& grid){\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<n; j++)\\n                cout<<setw(3)<<grid[i][j];\\n            cout<<endl;\\n        }\\n    }\\n\\n    void find_A(int x, int y, vector<vector<int>>& grid, int n){\\n        if (x<0 || x>=n || y<0 || y>=n) return;\\n        if (grid[x][y]==1) {\\n            grid[x][y]=2;\\n            Q.push({x, y});\\n            find_A(x+1, y, grid, n);\\n            find_A(x, y+1, grid, n);\\n            find_A(x-1, y, grid, n);\\n            find_A(x, y-1, grid, n);\\n        }        \\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        pair<int, int> P=find_ini_grid(n, grid);\\n        find_A(P.first, P.second,  grid, n);\\n        int d;\\n        for (d=0; ; d++){\\n            queue<pair<int, int>> Q2;\\n            while(!Q.empty()){              \\n                pair<int, int> P=Q.front();\\n                Q.pop();\\n                int x=P.first, y=P.second;\\n                vector<pair<int,int>> adj({{x+1,y},{x, y+1},{x-1, y},{x, y-1}});\\n                for(auto& [x2, y2]: adj)\\n                {\\n                    if (x2<0 || x2>=n || y2<0 || y2>=n) continue;\\n                    if (grid[x2][y2]==1) {\\n                  //    print(n, grid);//print the graph w dist.info\\n                        return d;\\n                    }\\n                    else if (grid[x2][y2]==0) {\\n                        Q2.push({x2,y2});\\n                        grid[x2][y2]=-1-d;//distance d to island A\\n                    }\\n                }    \\n            }          \\n            Q=Q2;\\n        }\\n        return d;       \\n    }\\n};\\n```\\nBSF solution \\n```\\nvoid bfs_findA(int i, int j, vector<vector<int>>& grid, int n){\\n        if (i<0 || i>=n || j<0 || j>=n || grid[i][j]!=1) return;\\n        queue<pair<int,int>> q;\\n        grid[i][j]=2;\\n        q.push({i, j});\\n        Q.push({i, j});\\n        while(!q.empty()){\\n            auto [x, y]=q.front();\\n            q.pop();\\n            vector<pair<int,int>> adj({{x+1,y},{x, y+1},{x-1, y},{x, y-1}});\\n            for(auto& [a, b]: adj){\\n                if((a >= 0 && a < n && b >= 0 && b < n) && grid[a][b] == 1)\\n                {\\n                    grid[a][b] = 2;\\n                    q.push({a, b});\\n                    Q.push({a, b});\\n                }          \\n            }\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n -1  2 -1 -2  0\\n -1  2 -1  1  1\\n -2 -1 -2  0  1\\n  0 -2  0  0  0\\n  0  0  0  0  0\\n```\n```\\nd=0\\n -1  0 -1  0  0  0  0  0  0  0\\n  0 -1  2 -1  0  0  0  0  0  0\\n -1  0 -1  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=1\\n -1 -2 -1 -2  0  0  0  0  0  0\\n -2 -1  2 -1 -2  0  0  0  0  0\\n -1 -2 -1 -2  0  0  0  0  0  0\\n -2  0 -2  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=2\\n -1 -2 -1 -2 -3  0  0  0  0  0\\n -2 -1  2 -1 -2 -3  0  0  0  0\\n -1 -2 -1 -2 -3  0  0  0  0  0\\n -2 -3 -2 -3  0  0  0  0  0  0\\n -3  0 -3  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=3\\n -1 -2 -1 -2 -3 -4  0  0  0  0\\n -2 -1  2 -1 -2 -3 -4  0  0  0\\n -1 -2 -1 -2 -3 -4  0  0  0  0\\n -2 -3 -2 -3 -4  0  0  0  0  0\\n -3 -4 -3 -4  0  0  0  0  0  0\\n -4  0 -4  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=4\\n -1 -2 -1 -2 -3 -4 -5  0  0  0\\n -2 -1  2 -1 -2 -3 -4 -5  0  0\\n -1 -2 -1 -2 -3 -4 -5  0  0  0\\n -2 -3 -2 -3 -4 -5  0  0  0  0\\n -3 -4 -3 -4 -5  0  0  0  0  0\\n -4 -5 -4 -5  0  0  0  0  0  0\\n -5  0 -5  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=5\\n -1 -2 -1 -2 -3 -4 -5 -6  0  0\\n -2 -1  2 -1 -2 -3 -4 -5 -6  0\\n -1 -2 -1 -2 -3 -4 -5 -6  0  0\\n -2 -3 -2 -3 -4 -5 -6  0  0  0\\n -3 -4 -3 -4 -5 -6  0  0  0  0\\n -4 -5 -4 -5 -6  0  0  0  0  0\\n -5 -6 -5 -6  0  0  0  0  0  0\\n -6  0 -6  0  0  0  0  0  0  0\\n  0  0  0  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=6\\n -1 -2 -1 -2 -3 -4 -5 -6 -7  0\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7  0\\n -2 -3 -2 -3 -4 -5 -6 -7  0  0\\n -3 -4 -3 -4 -5 -6 -7  0  0  0\\n -4 -5 -4 -5 -6 -7  0  0  0  0\\n -5 -6 -5 -6 -7  0  0  0  0  0\\n -6 -7 -6 -7  0  0  0  0  0  0\\n -7  0 -7  0  0  0  0  1  1  1\\n  0  0  0  0  0  0  0  0  0  0\\nd=7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -3 -2 -3 -4 -5 -6 -7 -8  0\\n -3 -4 -3 -4 -5 -6 -7 -8  0  0\\n -4 -5 -4 -5 -6 -7 -8  0  0  0\\n -5 -6 -5 -6 -7 -8  0  0  0  0\\n -6 -7 -6 -7 -8  0  0  0  0  0\\n -7 -8 -7 -8  0  0  0  1  1  1\\n -8  0 -8  0  0  0  0  0  0  0\\nd=8\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -3 -2 -3 -4 -5 -6 -7 -8 -9\\n -3 -4 -3 -4 -5 -6 -7 -8 -9  0\\n -4 -5 -4 -5 -6 -7 -8 -9  0  0\\n -5 -6 -5 -6 -7 -8 -9  0  0  0\\n -6 -7 -6 -7 -8 -9  0  0  0  0\\n -7 -8 -7 -8 -9  0  0  1  1  1\\n -8 -9 -8 -9  0  0  0  0  0  0\\nd=9\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -3 -2 -3 -4 -5 -6 -7 -8 -9\\n -3 -4 -3 -4 -5 -6 -7 -8 -9-10\\n -4 -5 -4 -5 -6 -7 -8 -9-10  0\\n -5 -6 -5 -6 -7 -8 -9-10  0  0\\n -6 -7 -6 -7 -8 -9-10  0  0  0\\n -7 -8 -7 -8 -9-10  0  1  1  1\\n -8 -9 -8 -9-10  0  0  0  0  0\\nd=10\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -3 -2 -3 -4 -5 -6 -7 -8 -9\\n -3 -4 -3 -4 -5 -6 -7 -8 -9-10\\n -4 -5 -4 -5 -6 -7 -8 -9-10-11\\n -5 -6 -5 -6 -7 -8 -9-10-11  0\\n -6 -7 -6 -7 -8 -9-10-11  0  0\\n -7 -8 -7 -8 -9-10-11  1  1  1\\n -8 -9 -8 -9-10-11  0  0  0  0\\nReturning\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -1  2 -1 -2 -3 -4 -5 -6 -7\\n -1 -2 -1 -2 -3 -4 -5 -6 -7 -8\\n -2 -3 -2 -3 -4 -5 -6 -7 -8 -9\\n -3 -4 -3 -4 -5 -6 -7 -8 -9-10\\n -4 -5 -4 -5 -6 -7 -8 -9-10-11\\n -5 -6 -5 -6 -7 -8 -9-10-11  0\\n -6 -7 -6 -7 -8 -9-10-11  0  0\\n -7 -8 -7 -8 -9-10-11  1  1  1\\n -8 -9 -8 -9-10-11-12  0  0  0\\nans=11\\n```\n```\\nclass Solution {\\npublic:\\n    queue<pair<int, int>> Q;\\n\\n    pair<int, int> find_ini_grid(int n, vector<vector<int>>& grid){      \\n        for (int i=0; i<n; i++)\\n            for(int j=0; j<n; j++)\\n                if (grid[i][j]==1){\\n                  return {i, j};  \\n            }\\n        return {-1,-1};\\n    }\\n    void print(int n, vector<vector<int>>& grid){\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<n; j++)\\n                cout<<setw(3)<<grid[i][j];\\n            cout<<endl;\\n        }\\n    }\\n\\n    void find_A(int x, int y, vector<vector<int>>& grid, int n){\\n        if (x<0 || x>=n || y<0 || y>=n) return;\\n        if (grid[x][y]==1) {\\n            grid[x][y]=2;\\n            Q.push({x, y});\\n            find_A(x+1, y, grid, n);\\n            find_A(x, y+1, grid, n);\\n            find_A(x-1, y, grid, n);\\n            find_A(x, y-1, grid, n);\\n        }        \\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        pair<int, int> P=find_ini_grid(n, grid);\\n        find_A(P.first, P.second,  grid, n);\\n        int d;\\n        for (d=0; ; d++){\\n            queue<pair<int, int>> Q2;\\n            while(!Q.empty()){              \\n                pair<int, int> P=Q.front();\\n                Q.pop();\\n                int x=P.first, y=P.second;\\n                vector<pair<int,int>> adj({{x+1,y},{x, y+1},{x-1, y},{x, y-1}});\\n                for(auto& [x2, y2]: adj)\\n                {\\n                    if (x2<0 || x2>=n || y2<0 || y2>=n) continue;\\n                    if (grid[x2][y2]==1) {\\n                  //    print(n, grid);//print the graph w dist.info\\n                        return d;\\n                    }\\n                    else if (grid[x2][y2]==0) {\\n                        Q2.push({x2,y2});\\n                        grid[x2][y2]=-1-d;//distance d to island A\\n                    }\\n                }    \\n            }          \\n            Q=Q2;\\n        }\\n        return d;       \\n    }\\n};\\n```\n```\\nvoid bfs_findA(int i, int j, vector<vector<int>>& grid, int n){\\n        if (i<0 || i>=n || j<0 || j>=n || grid[i][j]!=1) return;\\n        queue<pair<int,int>> q;\\n        grid[i][j]=2;\\n        q.push({i, j});\\n        Q.push({i, j});\\n        while(!q.empty()){\\n            auto [x, y]=q.front();\\n            q.pop();\\n            vector<pair<int,int>> adj({{x+1,y},{x, y+1},{x-1, y},{x, y-1}});\\n            for(auto& [a, b]: adj){\\n                if((a >= 0 && a < n && b >= 0 && b < n) && grid[a][b] == 1)\\n                {\\n                    grid[a][b] = 2;\\n                    q.push({a, b});\\n                    Q.push({a, b});\\n                }          \\n            }\\n        }\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3546514,
                "title": "c-depth-first-search-breadth-first-seach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    queue<pair<int,int>> q;\\n    int d[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\\n    bool check(vector<vector<int>>& nums,int i,int j){\\n        if(i<0||i>=nums.size()||j<0||j>=nums[0].size()) return 0;\\n        return 1;\\n    }\\n    void dfs(vector<vector<int>>& nums,vector<vector<int>>& vis,int i,int j){\\n        if(!check(nums,i,j) || vis[i][j]) return;\\n        if(nums[i][j]==0){\\n            vis[i][j]=1; q.push({i,j});\\n            return;\\n        }\\n        vis[i][j]=1;\\n        dfs(nums,vis,i+1,j); dfs(nums,vis,i-1,j);\\n        dfs(nums,vis,i,j+1); dfs(nums,vis,i,j-1);\\n    }\\n    int shortestBridge(vector<vector<int>>& nums) {\\n        vector<vector<int>> vis(nums.size(),vector<int>(nums[0].size(),0));\\n        bool st = 1;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0; j<nums[0].size() && st;++j){\\n                if(nums[i][j]){\\n                    dfs(nums,vis,i,j); st=0;\\n                    break;\\n                }\\n            }\\n        }\\n        int l = 0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                auto[i,j] = q.front(); q.pop();\\n                if(nums[i][j]==1) return l;\\n                for(int k = 0; k<4;++k){\\n                    int x=i+d[k][0],y=j+d[k][1];\\n                    if(check(nums,x,y) && !vis[x][y]){\\n                        vis[x][y]=1; q.push({x,y});\\n                    }\\n                }\\n            }\\n            ++l;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    queue<pair<int,int>> q;\\n    int d[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\\n    bool check(vector<vector<int>>& nums,int i,int j){\\n        if(i<0||i>=nums.size()||j<0||j>=nums[0].size()) return 0;\\n        return 1;\\n    }\\n    void dfs(vector<vector<int>>& nums,vector<vector<int>>& vis,int i,int j){\\n        if(!check(nums,i,j) || vis[i][j]) return;\\n        if(nums[i][j]==0){\\n            vis[i][j]=1; q.push({i,j});\\n            return;\\n        }\\n        vis[i][j]=1;\\n        dfs(nums,vis,i+1,j); dfs(nums,vis,i-1,j);\\n        dfs(nums,vis,i,j+1); dfs(nums,vis,i,j-1);\\n    }\\n    int shortestBridge(vector<vector<int>>& nums) {\\n        vector<vector<int>> vis(nums.size(),vector<int>(nums[0].size(),0));\\n        bool st = 1;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0; j<nums[0].size() && st;++j){\\n                if(nums[i][j]){\\n                    dfs(nums,vis,i,j); st=0;\\n                    break;\\n                }\\n            }\\n        }\\n        int l = 0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                auto[i,j] = q.front(); q.pop();\\n                if(nums[i][j]==1) return l;\\n                for(int k = 0; k<4;++k){\\n                    int x=i+d[k][0],y=j+d[k][1];\\n                    if(check(nums,x,y) && !vis[x][y]){\\n                        vis[x][y]=1; q.push({x,y});\\n                    }\\n                }\\n            }\\n            ++l;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880706,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS 2D and BFS 2D\\n\\n# Code\\n```\\n#define pii pair<int, int>\\nint fx[] = {-1, 1, 0, 0};\\nint fy[] = {0, 0, -1, 1};\\nclass Solution {\\npublic:\\n    int n, m, vis[105][105], dis[105][105];\\n    vector<vector<int>> grids;\\n    queue<pii> q;\\n\\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void dfs(int x, int y) {\\n        if(valid(x, y) and grids[x][y]) {\\n            vis[x][y] = 1;\\n            dfs(x+1, y);\\n            dfs(x-1, y);\\n            dfs(x, y+1);\\n            dfs(x, y-1);\\n        }\\n    }\\n\\n    void bfs() {\\n        while(!q.empty()) {\\n            pii top = q.front();\\n            int x = top.first;\\n            int y = top.second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int tx = x + fx[k];\\n                int ty = y + fy[k];\\n                if(valid(tx, ty)) {\\n                    vis[tx][ty] = 1;\\n                    dis[tx][ty] = dis[x][y] + 1;\\n                    q.push({tx, ty});\\n                }\\n            }\\n        }\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        memset(vis, 0, sizeof(vis));\\n        memset(dis, 0, sizeof(dis));\\n        grids = grid;\\n        n = grid.size(), m = grid[0].size();\\n\\n        for(int i=0; i<n; i++) {\\n            int fl = 0;\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]) {\\n                    dfs(i, j);\\n                    fl = 1;\\n                    break;\\n                }\\n            }\\n            if(fl) break;\\n        }\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(vis[i][j]) q.push({i, j});\\n            }\\n        }\\n\\n        bfs();\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] and dis[i][j]) ans = min(ans, dis[i][j]-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pii pair<int, int>\\nint fx[] = {-1, 1, 0, 0};\\nint fy[] = {0, 0, -1, 1};\\nclass Solution {\\npublic:\\n    int n, m, vis[105][105], dis[105][105];\\n    vector<vector<int>> grids;\\n    queue<pii> q;\\n\\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void dfs(int x, int y) {\\n        if(valid(x, y) and grids[x][y]) {\\n            vis[x][y] = 1;\\n            dfs(x+1, y);\\n            dfs(x-1, y);\\n            dfs(x, y+1);\\n            dfs(x, y-1);\\n        }\\n    }\\n\\n    void bfs() {\\n        while(!q.empty()) {\\n            pii top = q.front();\\n            int x = top.first;\\n            int y = top.second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int tx = x + fx[k];\\n                int ty = y + fy[k];\\n                if(valid(tx, ty)) {\\n                    vis[tx][ty] = 1;\\n                    dis[tx][ty] = dis[x][y] + 1;\\n                    q.push({tx, ty});\\n                }\\n            }\\n        }\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        memset(vis, 0, sizeof(vis));\\n        memset(dis, 0, sizeof(dis));\\n        grids = grid;\\n        n = grid.size(), m = grid[0].size();\\n\\n        for(int i=0; i<n; i++) {\\n            int fl = 0;\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]) {\\n                    dfs(i, j);\\n                    fl = 1;\\n                    break;\\n                }\\n            }\\n            if(fl) break;\\n        }\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(vis[i][j]) q.push({i, j});\\n            }\\n        }\\n\\n        bfs();\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] and dis[i][j]) ans = min(ans, dis[i][j]-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769189,
                "title": "java-dfs-easy-solution",
                "content": "```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean found = false;\\n        // 1. dfs to find an island, mark it in `visited`\\n        for (int i = 0; i < m; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (A[i][j] == 1) {\\n                    dfs(A, visited, q, i, j, dirs);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        // 2. bfs to expand this island\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cur = q.poll();\\n                for (int[] dir : dirs) {\\n                    int i = cur[0] + dir[0];\\n                    int j = cur[1] + dir[1];\\n                    if (i >= 0 && j >= 0 && i < m && j < n && !visited[i][j]) {\\n                        if (A[i][j] == 1) {\\n                            return step;\\n                        }\\n                        q.offer(new int[]{i, j});\\n                        visited[i][j] = true;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    private void dfs(int[][] A, boolean[][] visited, Queue<int[]> q, int i, int j, int[][] dirs) {\\n        if (i < 0 || j < 0 || i >= A.length || j >= A[0].length || visited[i][j] || A[i][j] == 0) {\\n            return;\\n        }\\n        visited[i][j] = true;\\n        q.offer(new int[]{i, j});\\n        for (int[] dir : dirs) {\\n            dfs(A, visited, q, i + dir[0], j + dir[1], dirs);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean found = false;\\n        // 1. dfs to find an island, mark it in `visited`\\n        for (int i = 0; i < m; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (A[i][j] == 1) {\\n                    dfs(A, visited, q, i, j, dirs);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        // 2. bfs to expand this island\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cur = q.poll();\\n                for (int[] dir : dirs) {\\n                    int i = cur[0] + dir[0];\\n                    int j = cur[1] + dir[1];\\n                    if (i >= 0 && j >= 0 && i < m && j < n && !visited[i][j]) {\\n                        if (A[i][j] == 1) {\\n                            return step;\\n                        }\\n                        q.offer(new int[]{i, j});\\n                        visited[i][j] = true;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    private void dfs(int[][] A, boolean[][] visited, Queue<int[]> q, int i, int j, int[][] dirs) {\\n        if (i < 0 || j < 0 || i >= A.length || j >= A[0].length || visited[i][j] || A[i][j] == 0) {\\n            return;\\n        }\\n        visited[i][j] = true;\\n        q.offer(new int[]{i, j});\\n        for (int[] dir : dirs) {\\n            dfs(A, visited, q, i + dir[0], j + dir[1], dirs);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386980,
                "title": "shortest-bridge-easy-commented-solution",
                "content": "My approach is:\\n1st step : I will visit the island which comes first in graph i.e. finding first \\'1\\' in the graph.\\n2nd step : I will add the first 1\\'s cordinates to queue and mark it visited (by changing 1 to 2 instead of another visited 2D array, so it saves us space).\\n3rd step : I will travel through all its neighbours and make the neighbour visited if it comes under same island. And while marking them visited, I will add them to queue also.\\n4th step : Now I will run BFS on the first island and find the nearest bridge to connect nearest \\'1\\'.\\n\\nThats it!! The problem is solved!!!\\n```\\nclass Solution {\\npublic:\\n    \\n    queue<pair<int, int>> q; // queue\\n    \\n    void dfs(vector<vector<int>>& grid, int i, int j) { // for marking the 1st island visited\\n        \\n        if (i<0 or i>=grid.size() or j<0 or j>=grid[0].size() or grid[i][j] == 2 or grid[i][j] == 0)\\n            return;\\n        \\n        grid[i][j] = 2; // marking them visited\\n        q.push({i,j}); // adding them to queue\\n        \\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n    }\\n    \\n    int bfs(vector<vector<int>>& grid){ // finding the nearest bridge between visited island and unvisited island\\n        \\n        int d = 0; // dist\\n        int mindist = INT_MAX; // to store minimum distance\\n        \\n        vector<vector<int>> dir = {{1,0}, {0,1}, {-1,0}, {0,-1}};\\n        \\n        while (!q.empty()){\\n            int n = q.size();\\n            \\n            while(n > 0){\\n                auto a = q.front();\\n                q.pop();\\n\\n                for (int h=0; h<4; h++) {\\n                    int x = dir[h][0] + a.first;\\n                    int y = dir[h][1] + a.second;\\n                    \\n                    if (x>=0 and x<grid.size() and y>=0 and y<grid[0].size() and grid[x][y] == 1) { // if the neighbor is 1, then check if its minimum distance\\n                        mindist = min(mindist, d);\\n                    }\\n\\n                    else if (x>=0 and x<grid.size() and y>=0 and y<grid[0].size() and grid[x][y] == 0) { // if the neighbor is 0, then mark it visited and add it to queue\\n                        q.push({x, y});\\n                        grid[x][y] = 2;\\n                    }\\n                }\\n            }\\n\\t\\t\\tn--;\\n            d++; // increasing each level by distance + 1\\n        }\\n        \\n        return mindist; // returning min dist found till end\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        bool flag = false;\\n        \\n        for (int i=0; i<grid.size(); i++){\\n            for (int j=0; j<grid[0].size(); j++){\\n                if (grid[i][j] == 1 and !flag){ // found 1st \\'1\\' in the matrix\\n                    dfs(grid, i, j); // dfs for marking the whole island visited\\n                    q.push({i,j});\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag)\\n                break;\\n        }\\n        \\n        return bfs(grid); // bfs for getting min dist and returning it\\n    }\\n};\\n```\\nPlease upvote if you liked it \\u263A\\uFE0F!!",
                "solutionTags": [
                    "Oracle",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    queue<pair<int, int>> q; // queue\\n    \\n    void dfs(vector<vector<int>>& grid, int i, int j) { // for marking the 1st island visited\\n        \\n        if (i<0 or i>=grid.size() or j<0 or j>=grid[0].size() or grid[i][j] == 2 or grid[i][j] == 0)\\n            return;\\n        \\n        grid[i][j] = 2; // marking them visited\\n        q.push({i,j}); // adding them to queue\\n        \\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n    }\\n    \\n    int bfs(vector<vector<int>>& grid){ // finding the nearest bridge between visited island and unvisited island\\n        \\n        int d = 0; // dist\\n        int mindist = INT_MAX; // to store minimum distance\\n        \\n        vector<vector<int>> dir = {{1,0}, {0,1}, {-1,0}, {0,-1}};\\n        \\n        while (!q.empty()){\\n            int n = q.size();\\n            \\n            while(n > 0){\\n                auto a = q.front();\\n                q.pop();\\n\\n                for (int h=0; h<4; h++) {\\n                    int x = dir[h][0] + a.first;\\n                    int y = dir[h][1] + a.second;\\n                    \\n                    if (x>=0 and x<grid.size() and y>=0 and y<grid[0].size() and grid[x][y] == 1) { // if the neighbor is 1, then check if its minimum distance\\n                        mindist = min(mindist, d);\\n                    }\\n\\n                    else if (x>=0 and x<grid.size() and y>=0 and y<grid[0].size() and grid[x][y] == 0) { // if the neighbor is 0, then mark it visited and add it to queue\\n                        q.push({x, y});\\n                        grid[x][y] = 2;\\n                    }\\n                }\\n            }\\n\\t\\t\\tn--;\\n            d++; // increasing each level by distance + 1\\n        }\\n        \\n        return mindist; // returning min dist found till end\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        bool flag = false;\\n        \\n        for (int i=0; i<grid.size(); i++){\\n            for (int j=0; j<grid[0].size(); j++){\\n                if (grid[i][j] == 1 and !flag){ // found 1st \\'1\\' in the matrix\\n                    dfs(grid, i, j); // dfs for marking the whole island visited\\n                    q.push({i,j});\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag)\\n                break;\\n        }\\n        \\n        return bfs(grid); // bfs for getting min dist and returning it\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098996,
                "title": "c-solution-with-imaged-and-easiest-explanation-bfs-dfs",
                "content": "# BFS + DFS Solution\\n\\nSo, we have been given two islands seperated by water in between them (ofcourse) and we need to devise a way to make a bridge with the shortest length in between them. The first implementation you might think of reading the word \"shortest\" is that of a **Breadth First Search** which is ofcourse correct but, here is the trick!\\n\\tYou must recognize the two islands first before building a bridge. That\\'s where our **Depth First Search** or **Flood Fill** algorithm comes in handy.\\n\\n<img src=\"https://assets.leetcode.com/users/images/0da401ab-4fc9-43a0-bccc-35f00361155a_1654098785.0941424.jpeg\" alt=\"Pic1\" width=\"500\"/>\\n\\nSo, we run flood fill to mark the two islands distinctively using (-1) for the first and (-2) for the second in the grid 2D array.\\nWhile doing this for Island 1, we also push the cells for island one into our **queue** for the Breadth First Search we are about to do!\\n\\n<img src=\"https://assets.leetcode.com/users/images/57cc5905-08f0-42b9-bc88-c6c8b59b2986_1654099737.5103762.jpeg\" alt=\"Pic2\" width=\"500\"/>\\n\\nNotice how the BFS makes ripples of traversing levels. The first time the \"ripples\" make contact with Island 2 with its cells marked as (-2), the level of traversal for those \"ripples\" give you the minimum length of the bridge required to be constructed from the nearest point from Island 1.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid)\\n    {\\n        bool flag = false;\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<grid.size(); i++)   //Find and fill the first island with (-1) then second with (-2)\\n        {\\n            for(int j=0 ;j<grid.at(0).size(); j++)\\n            {\\n                if(grid[i][j]==1 && !flag)\\n                {\\n                    dfs(grid, -1, i, j, q);\\n                    flag = true;\\n                    continue;\\n                }\\n                else if(grid[i][j]==1 && flag)\\n                {\\n                    dfs(grid, -2, i, j, q);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // for(int i=0; i<grid.size(); i++)\\n        // {\\n        //     for(int j=0; j<grid.at(0).size(); j++)\\n        //     {\\n        //         cout<<grid[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        // cout<<endl;\\n        \\n        int x = bfs(grid, q);\\n        \\n        // for(int i=0; i<grid.size(); i++)\\n        // {\\n        //     for(int j=0; j<grid.at(0).size(); j++)\\n        //     {\\n        //         cout<<grid[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        return x;\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, int val, int i, int j, queue<pair<int,int>>& q)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid.at(0).size()) return;\\n        if(grid[i][j]==val || grid[i][j]==0) return;\\n        \\n        grid[i][j]=val;\\n        if(val==-1) q.push({i, j});\\n        \\n        dfs(grid, val, i+1, j, q);\\n        dfs(grid, val, i, j+1, q);\\n        dfs(grid, val, i-1, j, q);\\n        dfs(grid, val, i, j-1, q);\\n    }\\n    \\n    int bfs(vector<vector<int>>& grid, queue<pair<int,int>>& q)\\n    {\\n        while(!q.empty())\\n        {\\n            int i = q.front().first;\\n            int j = q.front().second;\\n            \\n            if(i>0 && grid[i-1][j]==-2)\\n            {\\n                if(grid[i][j]>1) return grid[i][j];\\n                else return 1;\\n            }\\n            if(i>0 && grid[i-1][j]==0)\\n            {\\n                q.push({i-1, j});\\n                if(grid[i][j]==-1) grid[i-1][j] = 1;\\n                else grid[i-1][j] = grid[i][j] + 1;\\n            }\\n            \\n            if(j>0 && grid[i][j-1]==-2)\\n            {\\n                if(grid[i][j]>1) return grid[i][j];\\n                else return 1;\\n            }\\n            if(j>0 && grid[i][j-1]==0)\\n            {\\n                q.push({i, j-1});\\n                if(grid[i][j]==-1) grid[i][j-1] = 1;\\n                else grid[i][j-1] = grid[i][j] + 1; \\n            }\\n            \\n            if(i<grid.size()-1 && grid[i+1][j]==-2)\\n            {\\n                if(grid[i][j]>1) return grid[i][j];\\n                else return 1;\\n            }\\n            if(i<grid.size()-1 && grid[i+1][j]==0)\\n            {\\n                q.push({i+1, j});\\n                if(grid[i][j]==-1) grid[i+1][j] = 1;\\n                else grid[i+1][j] = grid[i][j] + 1;\\n            }\\n            \\n            if(j<grid.at(0).size()-1 && grid[i][j+1]==-2)\\n            {\\n                if(grid[i][j]>1) return grid[i][j];\\n                else return 1;\\n            }\\n            if(j<grid.at(0).size()-1 && grid[i][j+1]==0)\\n            {\\n                q.push({i, j+1});\\n                if(grid[i][j]==-1) grid[i][j+1] = 1;\\n                else grid[i][j+1] = grid[i][j] + 1;\\n            }\\n            q.pop();\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\nFeel free and uncomment the sections to view how the code actually works.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid)\\n    {\\n        bool flag = false;\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<grid.size(); i++)   //Find and fill the first island with (-1) then second with (-2)\\n        {\\n            for(int j=0 ;j<grid.at(0).size(); j++)\\n            {\\n                if(grid[i][j]==1 && !flag)\\n                {\\n                    dfs(grid, -1, i, j, q);\\n                    flag = true;\\n                    continue;\\n                }\\n                else if(grid[i][j]==1 && flag)\\n                {\\n                    dfs(grid, -2, i, j, q);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // for(int i=0; i<grid.size(); i++)\\n        // {\\n        //     for(int j=0; j<grid.at(0).size(); j++)\\n        //     {\\n        //         cout<<grid[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        // cout<<endl;\\n        \\n        int x = bfs(grid, q);\\n        \\n        // for(int i=0; i<grid.size(); i++)\\n        // {\\n        //     for(int j=0; j<grid.at(0).size(); j++)\\n        //     {\\n        //         cout<<grid[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        return x;\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, int val, int i, int j, queue<pair<int,int>>& q)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid.at(0).size()) return;\\n        if(grid[i][j]==val || grid[i][j]==0) return;\\n        \\n        grid[i][j]=val;\\n        if(val==-1) q.push({i, j});\\n        \\n        dfs(grid, val, i+1, j, q);\\n        dfs(grid, val, i, j+1, q);\\n        dfs(grid, val, i-1, j, q);\\n        dfs(grid, val, i, j-1, q);\\n    }\\n    \\n    int bfs(vector<vector<int>>& grid, queue<pair<int,int>>& q)\\n    {\\n        while(!q.empty())\\n        {\\n            int i = q.front().first;\\n            int j = q.front().second;\\n            \\n            if(i>0 && grid[i-1][j]==-2)\\n            {\\n                if(grid[i][j]>1) return grid[i][j];\\n                else return 1;\\n            }\\n            if(i>0 && grid[i-1][j]==0)\\n            {\\n                q.push({i-1, j});\\n                if(grid[i][j]==-1) grid[i-1][j] = 1;\\n                else grid[i-1][j] = grid[i][j] + 1;\\n            }\\n            \\n            if(j>0 && grid[i][j-1]==-2)\\n            {\\n                if(grid[i][j]>1) return grid[i][j];\\n                else return 1;\\n            }\\n            if(j>0 && grid[i][j-1]==0)\\n            {\\n                q.push({i, j-1});\\n                if(grid[i][j]==-1) grid[i][j-1] = 1;\\n                else grid[i][j-1] = grid[i][j] + 1; \\n            }\\n            \\n            if(i<grid.size()-1 && grid[i+1][j]==-2)\\n            {\\n                if(grid[i][j]>1) return grid[i][j];\\n                else return 1;\\n            }\\n            if(i<grid.size()-1 && grid[i+1][j]==0)\\n            {\\n                q.push({i+1, j});\\n                if(grid[i][j]==-1) grid[i+1][j] = 1;\\n                else grid[i+1][j] = grid[i][j] + 1;\\n            }\\n            \\n            if(j<grid.at(0).size()-1 && grid[i][j+1]==-2)\\n            {\\n                if(grid[i][j]>1) return grid[i][j];\\n                else return 1;\\n            }\\n            if(j<grid.at(0).size()-1 && grid[i][j+1]==0)\\n            {\\n                q.push({i, j+1});\\n                if(grid[i][j]==-1) grid[i][j+1] = 1;\\n                else grid[i][j+1] = grid[i][j] + 1;\\n            }\\n            q.pop();\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2096650,
                "title": "dfs-bfs-level-order-traversal",
                "content": "DFS + BFS (level order traversal)\\nTime: O(size of grid)\\nSpace: O(size of grid)  but no need for a visited table\\n\\n> idea comes from visualization from this post: https://leetcode.com/problems/shortest-bridge/discuss/189293/C%2B%2B-BFS-Island-Expansion-%2B-UF-Bonus\\n---\\n\\n```python\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        q = deque()\\n        \\n        # DFS paint the first island to 2\\n        def paint(x: int, y: int) -> None:\\n            grid[x][y] = 2\\n            q.append((x, y))\\n            for dx, dy in directions:\\n                nx, ny = x+dx, y+dy\\n                if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 1:\\n                    paint(nx, ny)\\n                    \\n        def init() -> None:\\n            for i in range(N):\\n                for j in range(N):\\n                    if grid[i][j]:\\n                        paint(i, j)\\n                        return\\n                    \\n        init()\\n        \\n        # BFS level order traversal\\n        level = 0\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                x, y = q.popleft()\\n                for dx, dy in directions:\\n                    nx, ny = x+dx, y+dy\\n                    if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] != 2:\\n                        q.append((nx, ny))\\n                        if grid[nx][ny] == 1:\\n                             return level\\n                        grid[nx][ny] = 2\\n            level += 1\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        q = deque()\\n        \\n        # DFS paint the first island to 2\\n        def paint(x: int, y: int) -> None:\\n            grid[x][y] = 2\\n            q.append((x, y))\\n            for dx, dy in directions:\\n                nx, ny = x+dx, y+dy\\n                if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 1:\\n                    paint(nx, ny)\\n                    \\n        def init() -> None:\\n            for i in range(N):\\n                for j in range(N):\\n                    if grid[i][j]:\\n                        paint(i, j)\\n                        return\\n                    \\n        init()\\n        \\n        # BFS level order traversal\\n        level = 0\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                x, y = q.popleft()\\n                for dx, dy in directions:\\n                    nx, ny = x+dx, y+dy\\n                    if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] != 2:\\n                        q.append((nx, ny))\\n                        if grid[nx][ny] == 1:\\n                             return level\\n                        grid[nx][ny] = 2\\n            level += 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892463,
                "title": "java-find-islands-using-dfs-perform-bfs-to-find-the-mindistance-between-2-islands",
                "content": "\\n## Techniques Used\\n- Graph\\n- BFS\\n- DFS\\n\\n## Approach\\n- Apply ```dfs``` to find the two islands and use a ```mark``` variable to mark every island with different \"color\"\\n- I have marked my two islands with color \"-1\" and \"-2\"\\n- Add all cells containing -1 into a queue (to be used later in BFS)\\n- Perform a ```bfs```  on all the cell coordinates inside our queue, while maintaining the ```level``` of BFS along with the coordinates.\\n- As soon as a -2 (other island is reached), compare the current ```level``` of ```bfs``` with the ```minZeroes``` needed variable, and keep the minimum of the two.\\n- At the end of BFS, return the value of ```minZeroes``` variable.\\n\\n## Complexity\\n- Time Complexity: O(N^2) - both BFS or DFS, in the worst case, will be visiting all the cells.\\n- Space Complexity: O(N^2) for the visited array & the queue.\\n\\n\\n## Code:\\n\\n```java\\n\\nclass Solution {\\n    int[][] dir= new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\n    public int shortestBridge(int[][] grid) {\\n                \\n        int n = grid.length;\\n        \\n        int mark = -1;\\n        \\n        boolean[][] visited=  new boolean[n][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j =  0; j < n; j++){\\n                if(!visited[i][j] && grid[i][j] == 1){\\n                    dfs(grid, i, j, mark--, visited);\\n                }\\n                if(grid[i][j] == -1){\\n                    q.add(new int[]{i, j, 0});\\n                }\\n            }\\n        }\\n        \\n        visited = new boolean[n][n];\\n        int minZeroes = bfs(grid, q, visited);\\n        \\n        return minZeroes;\\n        \\n    }\\n    \\n\\tpublic int bfs(int[][] grid, Queue<int[]> queue, boolean[][] visited){\\n        \\n        int n = grid[0].length;\\n        \\n        int minZeroes = Integer.MAX_VALUE;\\n        \\n        while(!queue.isEmpty()){\\n            \\n            int[] cur = queue.poll();\\n            \\n            int level = cur[2];\\n            \\n            for(int[] d:dir){\\n                \\n                int x = cur[0]+d[0];\\n                int y = cur[1]+d[1];\\n                \\n                \\n                if(x<0 || x>=n || y<0 || y>= n || grid[x][y] == -1 || visited[x][y]){\\n                    continue;\\n                }\\n                \\n                \\n                if(grid[x][y] == -2) {\\n                    minZeroes = Math.min(minZeroes, level++);\\n                    continue;\\n                }\\n                \\n                visited[x][y] = true;\\n                \\n                queue.offer(new int[]{x, y, level + 1});\\n            } \\n        }\\n        \\n        return minZeroes;\\n    }\\n\\n    \\n      static void dfs(int[][] grid, int row, int col, int color,  boolean[][] visited){\\n        \\n        if(row < 0 || col < 0 || row >= grid.length || col >= grid[0].length || visited[row][col] || grid[row][col] != 1 ) return;\\n        \\n        \\n        visited[row][col] = true;\\n         grid[row][col] = color;\\n        \\n        dfs(grid, row - 1, col, color, visited);\\n        dfs(grid, row + 1, col, color, visited);\\n        dfs(grid, row, col  + 1, color, visited);\\n        dfs(grid, row, col - 1, color, visited);\\n\\n        return;\\n        \\n       \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```dfs```\n```mark```\n```bfs```\n```level```\n```level```\n```bfs```\n```minZeroes```\n```minZeroes```\n```java\\n\\nclass Solution {\\n    int[][] dir= new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\n    public int shortestBridge(int[][] grid) {\\n                \\n        int n = grid.length;\\n        \\n        int mark = -1;\\n        \\n        boolean[][] visited=  new boolean[n][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j =  0; j < n; j++){\\n                if(!visited[i][j] && grid[i][j] == 1){\\n                    dfs(grid, i, j, mark--, visited);\\n                }\\n                if(grid[i][j] == -1){\\n                    q.add(new int[]{i, j, 0});\\n                }\\n            }\\n        }\\n        \\n        visited = new boolean[n][n];\\n        int minZeroes = bfs(grid, q, visited);\\n        \\n        return minZeroes;\\n        \\n    }\\n    \\n\\tpublic int bfs(int[][] grid, Queue<int[]> queue, boolean[][] visited){\\n        \\n        int n = grid[0].length;\\n        \\n        int minZeroes = Integer.MAX_VALUE;\\n        \\n        while(!queue.isEmpty()){\\n            \\n            int[] cur = queue.poll();\\n            \\n            int level = cur[2];\\n            \\n            for(int[] d:dir){\\n                \\n                int x = cur[0]+d[0];\\n                int y = cur[1]+d[1];\\n                \\n                \\n                if(x<0 || x>=n || y<0 || y>= n || grid[x][y] == -1 || visited[x][y]){\\n                    continue;\\n                }\\n                \\n                \\n                if(grid[x][y] == -2) {\\n                    minZeroes = Math.min(minZeroes, level++);\\n                    continue;\\n                }\\n                \\n                visited[x][y] = true;\\n                \\n                queue.offer(new int[]{x, y, level + 1});\\n            } \\n        }\\n        \\n        return minZeroes;\\n    }\\n\\n    \\n      static void dfs(int[][] grid, int row, int col, int color,  boolean[][] visited){\\n        \\n        if(row < 0 || col < 0 || row >= grid.length || col >= grid[0].length || visited[row][col] || grid[row][col] != 1 ) return;\\n        \\n        \\n        visited[row][col] = true;\\n         grid[row][col] = color;\\n        \\n        dfs(grid, row - 1, col, color, visited);\\n        dfs(grid, row + 1, col, color, visited);\\n        dfs(grid, row, col  + 1, color, visited);\\n        dfs(grid, row, col - 1, color, visited);\\n\\n        return;\\n        \\n       \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859999,
                "title": "java-dfs-to-mark-islands-bfs-to-find-distance-between-islands",
                "content": "First do DFS to mark islands as ISLAND1 or ISLAND2.\\nThen do normal BFS to find distance.\\n```\\nclass Solution {\\n    public enum State {\\n        ISLAND1,\\n        ISLAND2,\\n        WATER\\n    }\\n    public class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    private Point[] points = {\\n        new Point(0, 1),\\n        new Point(1, 0),\\n        new Point(0, -1),\\n        new Point(-1, 0)\\n    };\\n    \\n    public int shortestBridge(int[][] grid) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        State currentState = State.ISLAND1;\\n        State[][] gridCopy = new State[rows][columns];\\n        for(int row = 0; row < rows; row += 1) {\\n            Arrays.fill(gridCopy[row], State.WATER);\\n        }\\n        boolean[][] visited = new boolean[rows][columns];\\n        for(int row = 0; row < rows; row += 1) {\\n            for(int column = 0; column < columns; column += 1) {\\n                if(grid[row][column] == 1 && !visited[row][column]) {\\n                    modifyGrid(grid, gridCopy, row, column, currentState, visited);\\n                    currentState = State.ISLAND2;\\n                }\\n            }\\n        }\\n        visited = new boolean[rows][columns];\\n        Queue<Point> queue = new LinkedList<>();\\n        for(int row = 0; row < rows; row += 1) {\\n            for(int column = 0; column < columns; column += 1) {\\n                if(gridCopy[row][column] == State.ISLAND1) {\\n                    queue.offer(new Point(row, column));\\n                    visited[row][column] = true;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size > 0) {\\n                Point currentPoint = queue.poll();\\n                for(Point point: points) {\\n                    int row = currentPoint.x + point.x;\\n                    int column = currentPoint.y + point.y;\\n                    if(!(row < 0 || column < 0 || row >= grid.length || column >= grid[0].length || visited[row][column])) {\\n                        if(gridCopy[row][column] == State.ISLAND2) {\\n                            return ans;\\n                        }\\n                        queue.offer(new Point(row, column));\\n                        visited[row][column] = true;\\n                    }\\n                }\\n                size -= 1;\\n            }\\n            ans += 1;\\n        }\\n        return -1;\\n    }\\n    \\n    private void modifyGrid(int[][] grid, State[][] gridCopy, int row, int column, State currentState, boolean[][] visited) {\\n        if(row < 0 || column < 0 || row >= grid.length || column >= grid[0].length || visited[row][column] || grid[row][column] == 0) {\\n            return;\\n        }\\n        visited[row][column] = true;\\n        gridCopy[row][column] = currentState;\\n        for(Point point: points) {\\n            modifyGrid(grid, gridCopy, row + point.x, column + point.y, currentState, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public enum State {\\n        ISLAND1,\\n        ISLAND2,\\n        WATER\\n    }\\n    public class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    private Point[] points = {\\n        new Point(0, 1),\\n        new Point(1, 0),\\n        new Point(0, -1),\\n        new Point(-1, 0)\\n    };\\n    \\n    public int shortestBridge(int[][] grid) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        State currentState = State.ISLAND1;\\n        State[][] gridCopy = new State[rows][columns];\\n        for(int row = 0; row < rows; row += 1) {\\n            Arrays.fill(gridCopy[row], State.WATER);\\n        }\\n        boolean[][] visited = new boolean[rows][columns];\\n        for(int row = 0; row < rows; row += 1) {\\n            for(int column = 0; column < columns; column += 1) {\\n                if(grid[row][column] == 1 && !visited[row][column]) {\\n                    modifyGrid(grid, gridCopy, row, column, currentState, visited);\\n                    currentState = State.ISLAND2;\\n                }\\n            }\\n        }\\n        visited = new boolean[rows][columns];\\n        Queue<Point> queue = new LinkedList<>();\\n        for(int row = 0; row < rows; row += 1) {\\n            for(int column = 0; column < columns; column += 1) {\\n                if(gridCopy[row][column] == State.ISLAND1) {\\n                    queue.offer(new Point(row, column));\\n                    visited[row][column] = true;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size > 0) {\\n                Point currentPoint = queue.poll();\\n                for(Point point: points) {\\n                    int row = currentPoint.x + point.x;\\n                    int column = currentPoint.y + point.y;\\n                    if(!(row < 0 || column < 0 || row >= grid.length || column >= grid[0].length || visited[row][column])) {\\n                        if(gridCopy[row][column] == State.ISLAND2) {\\n                            return ans;\\n                        }\\n                        queue.offer(new Point(row, column));\\n                        visited[row][column] = true;\\n                    }\\n                }\\n                size -= 1;\\n            }\\n            ans += 1;\\n        }\\n        return -1;\\n    }\\n    \\n    private void modifyGrid(int[][] grid, State[][] gridCopy, int row, int column, State currentState, boolean[][] visited) {\\n        if(row < 0 || column < 0 || row >= grid.length || column >= grid[0].length || visited[row][column] || grid[row][column] == 0) {\\n            return;\\n        }\\n        visited[row][column] = true;\\n        gridCopy[row][column] = currentState;\\n        for(Point point: points) {\\n            modifyGrid(grid, gridCopy, row + point.x, column + point.y, currentState, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850660,
                "title": "c-easy-dfs-bfs-with-explanation",
                "content": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Graph Problem (DFS + BFS).\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\\n\\n**EXPLANATION**\\n* Apply DFS on one island and make it\\'s cells visited\\n* Make all cells of 2ed island as root node (distance=0, push in queue)\\n* Apply BFS to find shortest distnce between both islands\\n\\n\\n\\nTIME COMPLEXITY : O(N^N) , N is size of matrix    **Beats 90.02%**\\nSPACE COMPLEXITY : O(N^N),                                **Beats 70.50%**\\n\\n\\n\\n\\n\\n```\\nvoid dfs(int i,int j,vector<vector<int>>& grid, vector<vector<int>>& vis){\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid.size() || !grid[i][j] || vis[i][j]) \\n            return;\\n        vis[i][j]=1;\\n        dfs(i-1,j,grid,vis);\\n        dfs(i+1,j,grid,vis);\\n        dfs(i,j-1,grid,vis);\\n        dfs(i,j+1,grid,vis);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){   //Mark One island visited using DFS Algo\\n            int f=1;\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]) {dfs(i,j,grid,vis);f=0; break;}\\n            }\\n            if(f==0)break;\\n        }\\n        \\n        queue<pair<int,int>> q;    // Apply BFS to know shortest Distance between Islands\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n               if(!vis[i][j] && grid[i][j]) grid[i][j]=2, q.push({i,j});\\n           \\n        int cnt=0;\\n        while(!q.empty()){\\n            int s=q.size();\\n            cnt++;                     //increase distance by one\\n            while(s--){\\n                int x=q.front().first, y=q.front().second;\\n                q.pop();\\n                if(vis[x][y]==1) return cnt-2;       // if 1st island  found\\n                                                                        // check for adjcent cells\\n                if(x-1>=0 && grid[x-1][y]!=2) grid[x-1][y]=2, q.push({x-1,y});\\n                if(x+1<n && grid[x+1][y]!=2) grid[x+1][y]=2, q.push({x+1,y});\\n                if(y-1>=0 && grid[x][y-1]!=2) grid[x][y-1]=2, q.push({x,y-1});\\n                if(y+1<n && grid[x][y+1]!=2) grid[x][y+1]=2, q.push({x,y+1});\\n                \\n            }\\n        }\\n        return cnt-2;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Graph Problem (DFS + BFS).\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\n```\\nvoid dfs(int i,int j,vector<vector<int>>& grid, vector<vector<int>>& vis){\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid.size() || !grid[i][j] || vis[i][j]) \\n            return;\\n        vis[i][j]=1;\\n        dfs(i-1,j,grid,vis);\\n        dfs(i+1,j,grid,vis);\\n        dfs(i,j-1,grid,vis);\\n        dfs(i,j+1,grid,vis);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){   //Mark One island visited using DFS Algo\\n            int f=1;\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]) {dfs(i,j,grid,vis);f=0; break;}\\n            }\\n            if(f==0)break;\\n        }\\n        \\n        queue<pair<int,int>> q;    // Apply BFS to know shortest Distance between Islands\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n               if(!vis[i][j] && grid[i][j]) grid[i][j]=2, q.push({i,j});\\n           \\n        int cnt=0;\\n        while(!q.empty()){\\n            int s=q.size();\\n            cnt++;                     //increase distance by one\\n            while(s--){\\n                int x=q.front().first, y=q.front().second;\\n                q.pop();\\n                if(vis[x][y]==1) return cnt-2;       // if 1st island  found\\n                                                                        // check for adjcent cells\\n                if(x-1>=0 && grid[x-1][y]!=2) grid[x-1][y]=2, q.push({x-1,y});\\n                if(x+1<n && grid[x+1][y]!=2) grid[x+1][y]=2, q.push({x+1,y});\\n                if(y-1>=0 && grid[x][y-1]!=2) grid[x][y-1]=2, q.push({x,y-1});\\n                if(y+1<n && grid[x][y+1]!=2) grid[x][y+1]=2, q.push({x,y+1});\\n                \\n            }\\n        }\\n        return cnt-2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1357946,
                "title": "java-bfs-with-explanation",
                "content": "```\\nclass Solution {\\n\\n    static int moves[][] = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n\\n    boolean isValid(int[][] grid, int R, int C, int r, int c, boolean[][] visited) {\\n        return r >= 0 && r < R && c >= 0 && c < C && grid[r][c] == 1 && !visited[r][c];\\n    }\\n\\n    boolean isValid(int R, int C, int r, int c, boolean[][] visited) {\\n        return r >= 0 && r < R && c >= 0 && c < C && !visited[r][c];\\n    }\\n\\n    public int shortestBridge(int[][] grid) {\\n\\n        Queue<Node> qFor1stIsland = new LinkedList<>();\\n\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        boolean visited[][] = new boolean[R][C];\\n\\n        int firstR = -1, firstC = -1;\\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                if (grid[i][j] == 1) {\\n                    // we have found 1st island, now save these indexes and\\n                    // using dfs or bfs traverse all connected nodes and save them into a queue\\n                    firstR = i;\\n                    firstC = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // bfs to traverse all connected nodes and save them into a queue qFor1stIsland\\n        Queue<Node> qForBFS = new LinkedList<>();\\n        qForBFS.add(new Node(firstR, firstC));\\n        visited[firstR][firstC] = true;\\n        while (!qForBFS.isEmpty()) {\\n            Node node = qForBFS.remove();\\n            qFor1stIsland.add(node);\\n            for (int[] move : moves) {\\n                int nextR = node.r + move[0];\\n                int nextC = node.c + move[1];\\n                if (isValid(grid, R, C, nextR, nextC, visited)) {\\n                    qForBFS.add(new Node(nextR, nextC));\\n                    visited[nextR][nextC] = true;\\n                }\\n            }\\n        }\\n\\n        // now qFor1stIsland have all nodes from 1st island\\n        // now idea is to find all unvisited nodes from nodes present in qFor1stIsland and add them in another queue\\n        // pick this new queue and then goto unvisited nodes and the moment we find 1, we can say we have found our 2nd island\\n        // no of times we switch queues is our solution\\n\\n        // here I am using same queue, but I am storing size of queue before I start processing so that I know when my current level is going complete\\n\\n        int noOfFlip = 0;\\n        while (!qFor1stIsland.isEmpty()) {\\n            int size = qFor1stIsland.size();\\n            while (size > 0) {\\n                Node node = qFor1stIsland.remove();\\n                for (int[] move : moves) {\\n                    int nextR = node.r + move[0];\\n                    int nextC = node.c + move[1];\\n                    if (isValid(R, C, nextR, nextC, visited)) { // this method does not check grid value\\n                        if (grid[nextR][nextC] == 1) {\\n                            return noOfFlip;\\n                        }\\n                        qFor1stIsland.add(new Node(nextR, nextC));\\n                        visited[nextR][nextC] = true;\\n                    }\\n                }\\n                size--;\\n            }\\n            noOfFlip++;\\n        }\\n\\n        return -1; // code wont reach here, if reached then it means no 2nd island\\n    }\\n\\n    static class Node {\\n        int r, c;\\n\\n        Node(int r, int c) {\\n            this.r = r;\\n            this.c = c;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    static int moves[][] = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n\\n    boolean isValid(int[][] grid, int R, int C, int r, int c, boolean[][] visited) {\\n        return r >= 0 && r < R && c >= 0 && c < C && grid[r][c] == 1 && !visited[r][c];\\n    }\\n\\n    boolean isValid(int R, int C, int r, int c, boolean[][] visited) {\\n        return r >= 0 && r < R && c >= 0 && c < C && !visited[r][c];\\n    }\\n\\n    public int shortestBridge(int[][] grid) {\\n\\n        Queue<Node> qFor1stIsland = new LinkedList<>();\\n\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        boolean visited[][] = new boolean[R][C];\\n\\n        int firstR = -1, firstC = -1;\\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                if (grid[i][j] == 1) {\\n                    // we have found 1st island, now save these indexes and\\n                    // using dfs or bfs traverse all connected nodes and save them into a queue\\n                    firstR = i;\\n                    firstC = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // bfs to traverse all connected nodes and save them into a queue qFor1stIsland\\n        Queue<Node> qForBFS = new LinkedList<>();\\n        qForBFS.add(new Node(firstR, firstC));\\n        visited[firstR][firstC] = true;\\n        while (!qForBFS.isEmpty()) {\\n            Node node = qForBFS.remove();\\n            qFor1stIsland.add(node);\\n            for (int[] move : moves) {\\n                int nextR = node.r + move[0];\\n                int nextC = node.c + move[1];\\n                if (isValid(grid, R, C, nextR, nextC, visited)) {\\n                    qForBFS.add(new Node(nextR, nextC));\\n                    visited[nextR][nextC] = true;\\n                }\\n            }\\n        }\\n\\n        // now qFor1stIsland have all nodes from 1st island\\n        // now idea is to find all unvisited nodes from nodes present in qFor1stIsland and add them in another queue\\n        // pick this new queue and then goto unvisited nodes and the moment we find 1, we can say we have found our 2nd island\\n        // no of times we switch queues is our solution\\n\\n        // here I am using same queue, but I am storing size of queue before I start processing so that I know when my current level is going complete\\n\\n        int noOfFlip = 0;\\n        while (!qFor1stIsland.isEmpty()) {\\n            int size = qFor1stIsland.size();\\n            while (size > 0) {\\n                Node node = qFor1stIsland.remove();\\n                for (int[] move : moves) {\\n                    int nextR = node.r + move[0];\\n                    int nextC = node.c + move[1];\\n                    if (isValid(R, C, nextR, nextC, visited)) { // this method does not check grid value\\n                        if (grid[nextR][nextC] == 1) {\\n                            return noOfFlip;\\n                        }\\n                        qFor1stIsland.add(new Node(nextR, nextC));\\n                        visited[nextR][nextC] = true;\\n                    }\\n                }\\n                size--;\\n            }\\n            noOfFlip++;\\n        }\\n\\n        return -1; // code wont reach here, if reached then it means no 2nd island\\n    }\\n\\n    static class Node {\\n        int r, c;\\n\\n        Node(int r, int c) {\\n            this.r = r;\\n            this.c = c;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326085,
                "title": "python-dfs-bfs",
                "content": "Python DFS + BFS. Use DFS to mark islands as 1 or 2. Then use BFS from each cell belonging to island 1 and count the distance to reach the first possible cell in island 2.\\n\\n\\n\\t\\tnr, nc = len(grid), len(grid[0])\\n        \\n        visited = []\\n        island_id = []\\n        for i in range(nr):\\n            island_id.append([0]*nc)\\n            visited.append([False]*nc)\\n        \\n        def dfs(i, j, is_id):\\n            island_id[i][j] = is_id\\n            visited[i][j] = True\\n            if i-1 >= 0 and grid[i-1][j] == 1 and visited[i-1][j] == False:\\n                dfs(i-1, j, is_id)\\n            if i+1 < nr and grid[i+1][j] == 1 and visited[i+1][j] == False:\\n                dfs(i+1, j, is_id)\\n            if j-1 >= 0 and grid[i][j-1] == 1 and visited[i][j-1] == False:\\n                dfs(i, j-1, is_id)\\n            if j+1 < nc and grid[i][j+1] == 1 and visited[i][j+1] == False:\\n                dfs(i, j+1, is_id)\\n        \\n        is_id = 0\\n        for i in range(nr):\\n            for j in range(nc):\\n                if grid[i][j] == 1 and visited[i][j] == False:\\n                    is_id += 1\\n                    dfs(i, j, is_id)\\n        \\n        \\n        q = deque()\\n        seen = set()\\n        \\n        for i in range(nr):\\n            for j in range(nc):\\n                if island_id[i][j] == 1:\\n                    q.append((i, j, 0))\\n                    seen.add((i, j))\\n        \\n        ans = float(\\'inf\\')\\n        \\n        while q:\\n            i, j, dist = q.popleft()\\n            if island_id[i][j] == 2:\\n                ans = min(ans, dist-1)\\n                continue\\n        \\n            if dist+1 >= ans:\\n                continue\\n        \\n            if (i-1, j) not in seen and i-1 >= 0:\\n                q.append((i-1, j, dist+1))\\n                seen.add((i-1, j))\\n            if (i+1, j) not in seen and i+1 < nr:\\n                q.append((i+1, j, dist+1))\\n                seen.add((i+1, j))\\n            if (i, j-1) not in seen and j-1 >= 0:\\n                q.append((i, j-1, dist+1))\\n                seen.add((i, j-1))\\n            if (i, j+1) not in seen and j+1 < nc:\\n                q.append((i, j+1, dist+1))\\n                seen.add((i, j+1))\\n         \\n        return ans",
                "solutionTags": [],
                "code": "Python DFS + BFS. Use DFS to mark islands as 1 or 2. Then use BFS from each cell belonging to island 1 and count the distance to reach the first possible cell in island 2.\\n\\n\\n\\t\\tnr, nc = len(grid), len(grid[0])\\n        \\n        visited = []\\n        island_id = []\\n        for i in range(nr):\\n            island_id.append([0]*nc)\\n            visited.append([False]*nc)\\n        \\n        def dfs(i, j, is_id):\\n            island_id[i][j] = is_id\\n            visited[i][j] = True\\n            if i-1 >= 0 and grid[i-1][j] == 1 and visited[i-1][j] == False:\\n                dfs(i-1, j, is_id)\\n            if i+1 < nr and grid[i+1][j] == 1 and visited[i+1][j] == False:\\n                dfs(i+1, j, is_id)\\n            if j-1 >= 0 and grid[i][j-1] == 1 and visited[i][j-1] == False:\\n                dfs(i, j-1, is_id)\\n            if j+1 < nc and grid[i][j+1] == 1 and visited[i][j+1] == False:\\n                dfs(i, j+1, is_id)\\n        \\n        is_id = 0\\n        for i in range(nr):\\n            for j in range(nc):\\n                if grid[i][j] == 1 and visited[i][j] == False:\\n                    is_id += 1\\n                    dfs(i, j, is_id)\\n        \\n        \\n        q = deque()\\n        seen = set()\\n        \\n        for i in range(nr):\\n            for j in range(nc):\\n                if island_id[i][j] == 1:\\n                    q.append((i, j, 0))\\n                    seen.add((i, j))\\n        \\n        ans = float(\\'inf\\')\\n        \\n        while q:\\n            i, j, dist = q.popleft()\\n            if island_id[i][j] == 2:\\n                ans = min(ans, dist-1)\\n                continue\\n        \\n            if dist+1 >= ans:\\n                continue\\n        \\n            if (i-1, j) not in seen and i-1 >= 0:\\n                q.append((i-1, j, dist+1))\\n                seen.add((i-1, j))\\n            if (i+1, j) not in seen and i+1 < nr:\\n                q.append((i+1, j, dist+1))\\n                seen.add((i+1, j))\\n            if (i, j-1) not in seen and j-1 >= 0:\\n                q.append((i, j-1, dist+1))\\n                seen.add((i, j-1))\\n            if (i, j+1) not in seen and j+1 < nc:\\n                q.append((i, j+1, dist+1))\\n                seen.add((i, j+1))\\n         \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1281883,
                "title": "detailed-explanation-flood-fill-algorithm-c",
                "content": "**Approach:**\\n1. We are given two islands (denoted by a connected component of ```1```).\\n2. So, we store the location of the island in a vector.\\n  More precisely, we store the coordinates of ```1```, from the 1st island, in a vector x.\\n  And, we store the coordinates of ```1```, from the 2nd island, in a vector y.\\n 3. After getting the coordinates, we simply find the minimum distance as asked in the question.\\n\\n***How to do Step 2 --***\\ni. We use Flood Fill algo, to do it.\\nii. Our ```cnt==0```, describes that we are in island no. 1...And ```cnt==1``` describes that we are in island no. 2.\\niii. For every ```grid[i][j]```, of the same color, we make its color as 0, and put its coordinates, into corresponding vectors.\\niv. See about Flood Fill algorithm, for more details.\\nv.  The code below, will make it more clear.\\n\\nPlease upvote if it\\'s helpful : )\\n\\n```\\nclass Solution {\\n    vector<int> row = {-1, 0, 1, 0}, col = {0, -1, 0, 1};\\n    int R, C;\\n    \\n    void flood_fill(vector<vector<int>>& grid, int i, int j, vector<pair<int, int>>& v)\\n    {\\n        if(i<0 || i>=R || j<0 || j>=C || grid[i][j]==0)\\n            return ;\\n        v.push_back({i, j});\\n        grid[i][j] = 0;\\n        \\n        for(int k=0;k<4;k++)\\n            flood_fill(grid, i+row[k], j+col[k], v);\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) \\n    {\\n        vector<pair<int, int>> x, y;\\n        R = grid.size();\\n        C = grid[0].size();\\n        int cnt = 0;\\n        \\n        for(int i=0;i<R;i++)\\n        {\\n            for(int j=0;j<C;j++)\\n            {\\n                if(grid[i][j]==1 && cnt==0)\\n                {\\n                    flood_fill(grid, i, j, x); // island no. 1\\n                    cnt++;\\n                }\\n                else if(grid[i][j]==1 && cnt==1)\\n                    flood_fill(grid, i, j, y); // island no. 2\\n             }\\n         }\\n        \\n        int ans = INT_MAX;\\n        for(auto i : x)\\n        {\\n            for(auto j : y)\\n            {\\n                ans = min(ans, abs(i.first - j.first) + abs(i.second - j.second)); // step 3\\n            }\\n        }\\n        \\n        return --ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```1```\n```1```\n```1```\n```cnt==0```\n```cnt==1```\n```grid[i][j]```\n```\\nclass Solution {\\n    vector<int> row = {-1, 0, 1, 0}, col = {0, -1, 0, 1};\\n    int R, C;\\n    \\n    void flood_fill(vector<vector<int>>& grid, int i, int j, vector<pair<int, int>>& v)\\n    {\\n        if(i<0 || i>=R || j<0 || j>=C || grid[i][j]==0)\\n            return ;\\n        v.push_back({i, j});\\n        grid[i][j] = 0;\\n        \\n        for(int k=0;k<4;k++)\\n            flood_fill(grid, i+row[k], j+col[k], v);\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) \\n    {\\n        vector<pair<int, int>> x, y;\\n        R = grid.size();\\n        C = grid[0].size();\\n        int cnt = 0;\\n        \\n        for(int i=0;i<R;i++)\\n        {\\n            for(int j=0;j<C;j++)\\n            {\\n                if(grid[i][j]==1 && cnt==0)\\n                {\\n                    flood_fill(grid, i, j, x); // island no. 1\\n                    cnt++;\\n                }\\n                else if(grid[i][j]==1 && cnt==1)\\n                    flood_fill(grid, i, j, y); // island no. 2\\n             }\\n         }\\n        \\n        int ans = INT_MAX;\\n        for(auto i : x)\\n        {\\n            for(auto j : y)\\n            {\\n                ans = min(ans, abs(i.first - j.first) + abs(i.second - j.second)); // step 3\\n            }\\n        }\\n        \\n        return --ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262018,
                "title": "freaking-easy-dfs-bfs-clean-simple",
                "content": "please start the github if you like this solution Thanks! \\nhttps://github.com/chiranjeevisaride/leetcode/blob/master/934.%20Shortest%20Bridge.java\\n\\n```\\nclass Solution {\\n    private int[][] directions = {{-1,0}, {1,0}, {0,1}, {0,-1}};\\n    int[][] grid;\\n    boolean[][] visited;\\n    int n;    \\n    Queue<int[]> queue = new LinkedList<>();\\n    \\n    public int shortestBridge(int[][] grid) {\\n        this.n = grid.length;\\n        this.visited = new boolean[n][n];\\n        this.grid = grid;\\n        \\n        for(int row = 0; row < n; row++) {\\n            for(int col = 0; col < n; col++) {\\n                if(grid[row][col] == 1) {\\n                    dfs(row, col);\\n                    System.out.println(queue.size());\\n                    return bfs();        \\n                }   \\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    private int bfs() {\\n        int minFlips = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int index = 0; index < size; index++) {\\n                int[] current = queue.poll();\\n                for(int[] direction : directions) {\\n                    int newRow = direction[0] + current[0];\\n                    int newCol = direction[1] + current[1];\\n                    if(inBound(newRow, newCol)) {\\n                        if(grid[newRow][newCol] == 1)\\n                            return minFlips;\\n                        visited[newRow][newCol] = true;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n            minFlips++;\\n        }\\n        return 0;\\n    }\\n    \\n    private void dfs(int row, int col) {\\n        if(!inBound(row, col)) return;\\n        if(grid[row][col] == 0) return;\\n        visited[row][col] = true;\\n        queue.offer(new int[]{row, col}); \\n        for(int[] direction : directions) {\\n            dfs(direction[0] + row, direction[1] + col);\\n        }\\n    } \\n    \\n    private boolean inBound(int row, int col) {\\n         return row >= 0 && row < n && col >= 0 && col < n && !visited[row][col];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] directions = {{-1,0}, {1,0}, {0,1}, {0,-1}};\\n    int[][] grid;\\n    boolean[][] visited;\\n    int n;    \\n    Queue<int[]> queue = new LinkedList<>();\\n    \\n    public int shortestBridge(int[][] grid) {\\n        this.n = grid.length;\\n        this.visited = new boolean[n][n];\\n        this.grid = grid;\\n        \\n        for(int row = 0; row < n; row++) {\\n            for(int col = 0; col < n; col++) {\\n                if(grid[row][col] == 1) {\\n                    dfs(row, col);\\n                    System.out.println(queue.size());\\n                    return bfs();        \\n                }   \\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    private int bfs() {\\n        int minFlips = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int index = 0; index < size; index++) {\\n                int[] current = queue.poll();\\n                for(int[] direction : directions) {\\n                    int newRow = direction[0] + current[0];\\n                    int newCol = direction[1] + current[1];\\n                    if(inBound(newRow, newCol)) {\\n                        if(grid[newRow][newCol] == 1)\\n                            return minFlips;\\n                        visited[newRow][newCol] = true;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n            minFlips++;\\n        }\\n        return 0;\\n    }\\n    \\n    private void dfs(int row, int col) {\\n        if(!inBound(row, col)) return;\\n        if(grid[row][col] == 0) return;\\n        visited[row][col] = true;\\n        queue.offer(new int[]{row, col}); \\n        for(int[] direction : directions) {\\n            dfs(direction[0] + row, direction[1] + col);\\n        }\\n    } \\n    \\n    private boolean inBound(int row, int col) {\\n         return row >= 0 && row < n && col >= 0 && col < n && !visited[row][col];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121450,
                "title": "c-bfs-dfs-super-long-code-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestBridge(vector<vector<int>>& A) {\\n        // DFS + BFS: first using DFS to mark all 1s in the 1st island to be -1s, and store their indices.\\n        // Then for each index, using BFS to mark adjacent 0 point as -1 and store their indices as the next level.\\n        // We keep doing this until we find any adjacent point to be 1, that means we have built the bridge.\\n        int res = 0, marked = 0;\\n        vector<pair<int, int>> indices;\\n        vector<pair<int, int>> dirs{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        \\n        for (int i = 0; i < A.size(); ++i)\\n        {\\n            for (int j = 0; j < A[0].size(); ++j)\\n            {\\n                if (A[i][j] == 1)\\n                {\\n                    dfs(A, i, j, indices); // dfs to mark all 1s in the islands to be -1s\\n                    marked = 1;\\n                    break;\\n                }\\n            }\\n            \\n            if (marked)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        while (true)\\n        {\\n            vector<pair<int, int>> next;\\n            for (const auto& ind : indices)\\n            {\\n                int x = ind.first, y = ind.second;\\n                for (const auto& dir : dirs) // up, down, left and right\\n                {\\n                    int x = ind.first + dir.first;\\n                    int y = ind.second + dir.second;\\n                    if (x >= 0 && x < A.size() && y >= 0 && y < A[0].size())\\n                    {\\n                        if (A[x][y] == 1) \\n                        {\\n                            return res; // reach the 2nd island\\n                        }\\n                        \\n                        if (A[x][y] == 0)\\n                        {\\n                            A[x][y] = -1;\\n                            next.push_back({x, y}); // update the indices on the next level\\n                        }\\n                    }\\n                }\\n            }\\n\\n            ++res; // one more flip\\n            indices = next; // update indices\\n        }\\n        \\n        return res;\\n    }\\n    \\nprivate:\\n    void dfs(vector<vector<int>>& A, int r, int c, vector<pair<int, int>>& indices)\\n    {\\n        if (r < 0 || r >= A.size() || c < 0 || c >= A[0].size() || A[r][c] != 1)\\n        {\\n            return;\\n        }\\n        \\n        A[r][c] = -1;\\n        indices.push_back({r, c});\\n        \\n        dfs(A, r - 1, c, indices);\\n        dfs(A, r + 1, c, indices);\\n        dfs(A, r, c - 1, indices);\\n        dfs(A, r, c + 1, indices);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestBridge(vector<vector<int>>& A) {\\n        // DFS + BFS: first using DFS to mark all 1s in the 1st island to be -1s, and store their indices.\\n        // Then for each index, using BFS to mark adjacent 0 point as -1 and store their indices as the next level.\\n        // We keep doing this until we find any adjacent point to be 1, that means we have built the bridge.\\n        int res = 0, marked = 0;\\n        vector<pair<int, int>> indices;\\n        vector<pair<int, int>> dirs{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        \\n        for (int i = 0; i < A.size(); ++i)\\n        {\\n            for (int j = 0; j < A[0].size(); ++j)\\n            {\\n                if (A[i][j] == 1)\\n                {\\n                    dfs(A, i, j, indices); // dfs to mark all 1s in the islands to be -1s\\n                    marked = 1;\\n                    break;\\n                }\\n            }\\n            \\n            if (marked)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        while (true)\\n        {\\n            vector<pair<int, int>> next;\\n            for (const auto& ind : indices)\\n            {\\n                int x = ind.first, y = ind.second;\\n                for (const auto& dir : dirs) // up, down, left and right\\n                {\\n                    int x = ind.first + dir.first;\\n                    int y = ind.second + dir.second;\\n                    if (x >= 0 && x < A.size() && y >= 0 && y < A[0].size())\\n                    {\\n                        if (A[x][y] == 1) \\n                        {\\n                            return res; // reach the 2nd island\\n                        }\\n                        \\n                        if (A[x][y] == 0)\\n                        {\\n                            A[x][y] = -1;\\n                            next.push_back({x, y}); // update the indices on the next level\\n                        }\\n                    }\\n                }\\n            }\\n\\n            ++res; // one more flip\\n            indices = next; // update indices\\n        }\\n        \\n        return res;\\n    }\\n    \\nprivate:\\n    void dfs(vector<vector<int>>& A, int r, int c, vector<pair<int, int>>& indices)\\n    {\\n        if (r < 0 || r >= A.size() || c < 0 || c >= A[0].size() || A[r][c] != 1)\\n        {\\n            return;\\n        }\\n        \\n        A[r][c] = -1;\\n        indices.push_back({r, c});\\n        \\n        dfs(A, r - 1, c, indices);\\n        dfs(A, r + 1, c, indices);\\n        dfs(A, r, c - 1, indices);\\n        dfs(A, r, c + 1, indices);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052103,
                "title": "java-dfs-bfs-o-m-n-6ms-beats-96",
                "content": "\\n    // O(m*n)\\n\\tpublic int shortestBridge(int[][] A) {\\n\\t\\tint m = A.length;\\n\\t\\tint n = A[0].length;\\n\\t\\tint[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\t\\tQueue<int[]> queue = new LinkedList<int[]>();\\n\\t\\tboolean flag = false;\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (A[i][j] == 1) {\\n\\t\\t\\t\\t\\tdfs(A, i, j, m, n, queue);\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\treturn bfs(A, queue, dirs, m, n);\\n\\t}\\n\\n\\t// O(m*n)\\n\\tpublic void dfs(int[][] A, int x, int y, int m, int n, Queue<int[]> queue) {\\n\\n\\t\\tif (x == -1 || y == -1 || x == m || y == n || A[x][y] != 1)\\n\\t\\t\\treturn;\\n\\n\\t\\tA[x][y] = 2;\\n\\t\\tint[] temp = { x, y, 0 };\\n\\t\\tqueue.offer(temp);\\n\\n\\t\\tdfs(A, x + 1, y, m, n, queue);\\n\\t\\tdfs(A, x - 1, y, m, n, queue);\\n\\t\\tdfs(A, x, y + 1, m, n, queue);\\n\\t\\tdfs(A, x, y - 1, m, n, queue);\\n\\t}\\n\\n\\t// O(m*n)\\n\\tpublic int bfs(int[][] A, Queue<int[]> queue, int[][] dirs, int m, int n) {\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\n\\t\\t\\tint[] temp = queue.poll();\\n\\t\\t\\tint x = temp[0];\\n\\t\\t\\tint y = temp[1];\\n\\t\\t\\tint moves = temp[2];\\n\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\tint row = x + dir[0];\\n\\t\\t\\t\\tint col = y + dir[1];\\n\\t\\t\\t\\tif (row == -1 || col == -1 || row == m || col == n || A[row][col] == 2)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (A[row][col] == 1)\\n\\t\\t\\t\\t\\treturn temp[2];\\n\\t\\t\\t\\tA[row][col] = 2;\\n\\t\\t\\t\\tqueue.offer(new int[] { row, col, moves + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // O(m*n)\\n\\tpublic int shortestBridge(int[][] A) {\\n\\t\\tint m = A.length;\\n\\t\\tint n = A[0].length;\\n\\t\\tint[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\t\\tQueue<int[]> queue = new LinkedList<int[]>();\\n\\t\\tboolean flag = false;\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (A[i][j] == 1) {\\n\\t\\t\\t\\t\\tdfs(A, i, j, m, n, queue);\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\treturn bfs(A, queue, dirs, m, n);\\n\\t}\\n\\n\\t// O(m*n)\\n\\tpublic void dfs(int[][] A, int x, int y, int m, int n, Queue<int[]> queue) {\\n\\n\\t\\tif (x == -1 || y == -1 || x == m || y == n || A[x][y] != 1)\\n\\t\\t\\treturn;\\n\\n\\t\\tA[x][y] = 2;\\n\\t\\tint[] temp = { x, y, 0 };\\n\\t\\tqueue.offer(temp);\\n\\n\\t\\tdfs(A, x + 1, y, m, n, queue);\\n\\t\\tdfs(A, x - 1, y, m, n, queue);\\n\\t\\tdfs(A, x, y + 1, m, n, queue);\\n\\t\\tdfs(A, x, y - 1, m, n, queue);\\n\\t}\\n\\n\\t// O(m*n)\\n\\tpublic int bfs(int[][] A, Queue<int[]> queue, int[][] dirs, int m, int n) {\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\n\\t\\t\\tint[] temp = queue.poll();\\n\\t\\t\\tint x = temp[0];\\n\\t\\t\\tint y = temp[1];\\n\\t\\t\\tint moves = temp[2];\\n\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\tint row = x + dir[0];\\n\\t\\t\\t\\tint col = y + dir[1];\\n\\t\\t\\t\\tif (row == -1 || col == -1 || row == m || col == n || A[row][col] == 2)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (A[row][col] == 1)\\n\\t\\t\\t\\t\\treturn temp[2];\\n\\t\\t\\t\\tA[row][col] = 2;\\n\\t\\t\\t\\tqueue.offer(new int[] { row, col, moves + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 851340,
                "title": "c-clean-easy-to-read-solution",
                "content": "**Note**: When the problem says shortest distance in a grid, tree or graph, see the problem in terms of BFS traversal, it will become easier to visualize the problem and come up with a solution.\\n\\n**Algo**:\\n- Visit island1 using dfs and mark it with value 2. Add all the indices of island1 into queue\\n- Perform bfs with the indices in queue until you find destination island\\n```\\nclass Solution {\\n    void visitFirstIsland(int i, int j, queue<pair<int, int>>& q, vector<vector<int>>& A) {\\n        if (i < 0 or i == A.size() or j < 0 or j == A[i].size())\\n            return;\\n        \\n        if (A[i][j] == 0 or A[i][j] == 2)\\n            return;\\n        \\n        // mark first island with value 2\\n        q.push({i, j});\\n        A[i][j] = 2;\\n        \\n        visitFirstIsland(i, j + 1, q, A);\\n        visitFirstIsland(i, j - 1, q, A);\\n        visitFirstIsland(i + 1, j, q, A);\\n        visitFirstIsland(i - 1, j, q, A);\\n    }\\n    \\npublic:\\n    int shortestBridge(vector<vector<int>>& A) {\\n        queue<pair<int, int>> q;\\n        for (int i = 0; i < A.size(); i++) {\\n            bool flag = false;\\n            for (int j = 0; j < A[i].size(); j++) {\\n                if (A[i][j] == 1) {\\n                    visitFirstIsland(i, j, q, A);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            \\n            // we have found and visited first island. Break out of the loop\\n            if (flag == true)\\n                break;\\n        }\\n        \\n        vector<pair<int, int>> dirs = {{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int distance = 0;\\n        \\n        while (!q.empty()) {\\n            int qSize = q.size();\\n            \\n            while (qSize--) {\\n                auto cur = q.front(); q.pop();\\n                \\n                for (auto& dir : dirs) {\\n                    int x = cur.first + dir.first;\\n                    int y = cur.second + dir.second;\\n                    \\n                    if (x < 0  or x == A.size() or y < 0 or y == A[x].size() or A[x][y] == 2)\\n                        continue;\\n                    \\n                    if (A[x][y] == 1)\\n                        return distance;\\n                    \\n                    q.push({x, y});\\n                    A[x][y] = 2;\\n                }\\n            }\\n            \\n            distance++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    void visitFirstIsland(int i, int j, queue<pair<int, int>>& q, vector<vector<int>>& A) {\\n        if (i < 0 or i == A.size() or j < 0 or j == A[i].size())\\n            return;\\n        \\n        if (A[i][j] == 0 or A[i][j] == 2)\\n            return;\\n        \\n        // mark first island with value 2\\n        q.push({i, j}",
                "codeTag": "Java"
            },
            {
                "id": 817666,
                "title": "python3-find-the-border-of-the-first-island-then-grow-shortest-bridge",
                "content": "```\\nclass Solution:\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        def neighbors(x, y):\\n            for nx, ny in ((x+1, y), (x-1, y), (x, y+1), (x, y-1)):\\n                if 0 <= nx < R and 0 <= ny < C:\\n                    yield nx, ny\\n        R, C = len(A), len(A[0])\\n        for x, y in itertools.product(range(R), range(C)):\\n            if A[x][y]:\\n                break\\n        seen = set()            \\n        border = deque()\\n        def dfs(x, y):\\n            if not A[x][y] or (x, y) in seen:\\n                return\\n            seen.add((x, y))\\n            onBorder = False\\n            for nx, ny in neighbors(x, y):\\n                dfs(nx, ny)\\n                onBorder |= not A[nx][ny]\\n            if onBorder:\\n                border.append(((x, y), 0))\\n        dfs(x, y)        \\n        while border:\\n            (x, y), d = border.popleft()\\n            for nx, ny in neighbors(x, y):\\n                if (nx, ny) not in seen:\\n                    if A[nx][ny]:\\n                        return d\\n                    border.append(((nx, ny), d+1))\\n                    seen.add((nx, ny))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        def neighbors(x, y):\\n            for nx, ny in ((x+1, y), (x-1, y), (x, y+1), (x, y-1)):\\n                if 0 <= nx < R and 0 <= ny < C:\\n                    yield nx, ny\\n        R, C = len(A), len(A[0])\\n        for x, y in itertools.product(range(R), range(C)):\\n            if A[x][y]:\\n                break\\n        seen = set()            \\n        border = deque()\\n        def dfs(x, y):\\n            if not A[x][y] or (x, y) in seen:\\n                return\\n            seen.add((x, y))\\n            onBorder = False\\n            for nx, ny in neighbors(x, y):\\n                dfs(nx, ny)\\n                onBorder |= not A[nx][ny]\\n            if onBorder:\\n                border.append(((x, y), 0))\\n        dfs(x, y)        \\n        while border:\\n            (x, y), d = border.popleft()\\n            for nx, ny in neighbors(x, y):\\n                if (nx, ny) not in seen:\\n                    if A[nx][ny]:\\n                        return d\\n                    border.append(((nx, ny), d+1))\\n                    seen.add((nx, ny))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676273,
                "title": "javascript-dfs-bfs-easy-to-read-no-extra-space",
                "content": "```javascript\\nconst shortestBridge = (A) => {\\n    // identify 1st island\\n    identifyIslands(A);\\n\\n    // enqueue all 1\\'s\\n    const queue = new Array();\\n    primeFirstIsland(A, queue);\\n    \\n\\t// no 1\\'s? means only 1 island\\n    if(queue.length === 0) return 0;\\n    \\n    // get min distance to second island\\n    return bfs(A, queue);\\n};\\n\\nconst primeFirstIsland = (matrix, queue) => {\\n    for(let row = 0; row < matrix.length; row++) {\\n        for(let col = 0; col < matrix[0].length; col++) {\\n            if(matrix[row][col] === 1) queue.unshift( { row, col, dist: 0 } );\\n        }\\n    }    \\n}\\n\\nconst identifyIslands = (matrix) => {\\n    for(let row = 0; row < matrix.length; row++) {\\n        for(let col = 0; col < matrix[0].length; col++) {\\n            if(matrix[row][col] === 1) {\\n                // mark all connected as 2\\n                dfs(matrix, row, col);\\n                return;\\n            }\\n        }\\n    }\\n}\\n\\nconst bfs = (matrix, queue) => {\\n    let min = Number.MAX_SAFE_INTEGER;\\n    \\n    while(queue.length) { \\n        const curr = queue.pop();\\n        const row = curr.row;\\n        const col = curr.col;\\n        const distance = curr.dist;\\n        \\n        if(matrix[row][col] === 2) {\\n            min = Math.min(min, distance - 1);\\n            continue;\\n        }\\n        \\n        for(const dir of directions) {\\n            const nextRow = row + dir[0];\\n            const nextCol = col + dir[1];\\n            if(\\n                nextRow >= 0\\n                && nextRow < matrix.length\\n                && nextCol >= 0\\n                && nextCol < matrix[0].length\\n                && (\\n                    matrix[nextRow][nextCol] === 0 \\n                    || matrix[nextRow][nextCol] === 2\\n                )\\n            ) {\\n                if(matrix[nextRow][nextCol] === 0) matrix[nextRow][nextCol] = 3;\\n                queue.unshift( { row: nextRow, col: nextCol, dist: distance + 1 } );\\n            }\\n        }\\n    }\\n    \\n    return min;\\n}\\n\\n// up down left right\\nconst directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\nconst dfs = (A, row, col) => {\\n    if(\\n        row < 0\\n        || row >= A.length\\n        || col < 0\\n        || col >= A[0].length\\n        || A[row][col] !== 1\\n    ) return;\\n    \\n    A[row][col] = 2;\\n    \\n    for(const dir of directions) {\\n        const nextRow = row + dir[0];\\n        const nextCol = col + dir[1];\\n        dfs(A, nextRow, nextCol);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nconst shortestBridge = (A) => {\\n    // identify 1st island\\n    identifyIslands(A);\\n\\n    // enqueue all 1\\'s\\n    const queue = new Array();\\n    primeFirstIsland(A, queue);\\n    \\n\\t// no 1\\'s? means only 1 island\\n    if(queue.length === 0) return 0;\\n    \\n    // get min distance to second island\\n    return bfs(A, queue);\\n};\\n\\nconst primeFirstIsland = (matrix, queue) => {\\n    for(let row = 0; row < matrix.length; row++) {\\n        for(let col = 0; col < matrix[0].length; col++) {\\n            if(matrix[row][col] === 1) queue.unshift( { row, col, dist: 0 } );\\n        }\\n    }    \\n}\\n\\nconst identifyIslands = (matrix) => {\\n    for(let row = 0; row < matrix.length; row++) {\\n        for(let col = 0; col < matrix[0].length; col++) {\\n            if(matrix[row][col] === 1) {\\n                // mark all connected as 2\\n                dfs(matrix, row, col);\\n                return;\\n            }\\n        }\\n    }\\n}\\n\\nconst bfs = (matrix, queue) => {\\n    let min = Number.MAX_SAFE_INTEGER;\\n    \\n    while(queue.length) { \\n        const curr = queue.pop();\\n        const row = curr.row;\\n        const col = curr.col;\\n        const distance = curr.dist;\\n        \\n        if(matrix[row][col] === 2) {\\n            min = Math.min(min, distance - 1);\\n            continue;\\n        }\\n        \\n        for(const dir of directions) {\\n            const nextRow = row + dir[0];\\n            const nextCol = col + dir[1];\\n            if(\\n                nextRow >= 0\\n                && nextRow < matrix.length\\n                && nextCol >= 0\\n                && nextCol < matrix[0].length\\n                && (\\n                    matrix[nextRow][nextCol] === 0 \\n                    || matrix[nextRow][nextCol] === 2\\n                )\\n            ) {\\n                if(matrix[nextRow][nextCol] === 0) matrix[nextRow][nextCol] = 3;\\n                queue.unshift( { row: nextRow, col: nextCol, dist: distance + 1 } );\\n            }\\n        }\\n    }\\n    \\n    return min;\\n}\\n\\n// up down left right\\nconst directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\nconst dfs = (A, row, col) => {\\n    if(\\n        row < 0\\n        || row >= A.length\\n        || col < 0\\n        || col >= A[0].length\\n        || A[row][col] !== 1\\n    ) return;\\n    \\n    A[row][col] = 2;\\n    \\n    for(const dir of directions) {\\n        const nextRow = row + dir[0];\\n        const nextCol = col + dir[1];\\n        dfs(A, nextRow, nextCol);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 634450,
                "title": "a-simple-dfs-approach-c",
                "content": "```\\nclass Solution {\\n    int r,c;\\n            int ans=INT_MAX;\\n    \\n    \\n    void dfs(vector<vector<int>>& A,int i,int j,vector<vector<bool>>& vis,vector<pair<int,int>>& S)\\n    {\\n        if(i<0||j<0||i>=r||j>=c) return;\\n        if(vis[i][j]||A[i][j]==0) return;\\n        \\n        vis[i][j]=true; \\n        S.push_back(make_pair(i,j));\\n        dfs(A,i-1,j,vis,S);\\n        dfs(A,i+1,j,vis,S);\\n        dfs(A,i,j-1,vis,S);\\n        dfs(A,i,j+1,vis,S);\\n        \\n        return;\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& A) {\\n        \\n        r=A.size(); c=A[0].size();\\n        vector<pair<int,int>> P,Q;\\n        vector<vector<bool>> vis(r,vector<bool>(c,false));\\n        int flag=0;\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(A[i][j]==1&&!vis[i][j])\\n                {\\n                    if(flag==0) {dfs(A,i,j,vis,P); flag++;}\\n                    else {dfs(A,i,j,vis,Q);}\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<P.size();i++)\\n        {\\n            for(int j=0;j<Q.size();j++)\\n            {\\n                int x1=P[i].first;\\n                int x2=Q[j].first;\\n                int y1=P[i].second;\\n                int y2=Q[j].second;\\n                \\n                int dis=abs(x1-x2)+abs(y1-y2);\\n                \\n                ans=min(ans,dis);\\n            }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int r,c;\\n            int ans=INT_MAX;\\n    \\n    \\n    void dfs(vector<vector<int>>& A,int i,int j,vector<vector<bool>>& vis,vector<pair<int,int>>& S)\\n    {\\n        if(i<0||j<0||i>=r||j>=c) return;\\n        if(vis[i][j]||A[i][j]==0) return;\\n        \\n        vis[i][j]=true; \\n        S.push_back(make_pair(i,j));\\n        dfs(A,i-1,j,vis,S);\\n        dfs(A,i+1,j,vis,S);\\n        dfs(A,i,j-1,vis,S);\\n        dfs(A,i,j+1,vis,S);\\n        \\n        return;\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& A) {\\n        \\n        r=A.size(); c=A[0].size();\\n        vector<pair<int,int>> P,Q;\\n        vector<vector<bool>> vis(r,vector<bool>(c,false));\\n        int flag=0;\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(A[i][j]==1&&!vis[i][j])\\n                {\\n                    if(flag==0) {dfs(A,i,j,vis,P); flag++;}\\n                    else {dfs(A,i,j,vis,Q);}\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<P.size();i++)\\n        {\\n            for(int j=0;j<Q.size();j++)\\n            {\\n                int x1=P[i].first;\\n                int x2=Q[j].first;\\n                int y1=P[i].second;\\n                int y2=Q[j].second;\\n                \\n                int dis=abs(x1-x2)+abs(y1-y2);\\n                \\n                ans=min(ans,dis);\\n            }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394556,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nWe know we need to use `bfs` for shortest distance but from where to where? Since there are two islands, we cover one island and note down their coodinates. We add all those coordinate at once to the queue of our `bfs`. This way, whoever sees the `1` first will give us the shortest path to `1` from another island.  \\n\\n```\\npublic int shortestBridge(int[][] a) {\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<String> seen = new HashSet<>();\\n        for(int i=0; i < a.length; i++)\\n            for(int j=0; j < a[0].length; j++)\\n                if(a[i][j] == 1){\\n                    dfs(a, i, j, q, seen);\\n                    return shortestPath(a, q, seen);\\n                }\\n        return -1;\\n    }\\n    private void dfs(int[][] a, int i, int j, Queue<int[]> q, Set<String> seen){\\n        if(i < 0 || j < 0 || i == a.length || j == a[0].length || a[i][j] == 0) return;\\n        String key = i+\" \"+j;\\n        if(seen.contains(key)) return;\\n        seen.add(key);\\n        q.add(new int[]{i, j});\\n        dfs(a, i+1, j, q, seen);\\n        dfs(a, i-1, j, q, seen);\\n        dfs(a, i, j+1, q, seen);\\n        dfs(a, i, j-1, q, seen);\\n    }\\n    private int shortestPath(int[][] a, Queue<int[]> q, Set<String> oldIsland){\\n        int moves = 0, m = a.length, n = a[0].length;\\n        Set<String> seen = new HashSet<>();\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int k=0; k < size; k++){\\n                int[] curr = q.remove();\\n                int i = curr[0], j = curr[1];\\n                String key = i+\" \"+j;\\n                if(seen.contains(key)) continue;\\n                if(a[i][j] == 1 && !oldIsland.contains(key)) return moves-1;\\n                seen.add(key);\\n                if(i-1 >= 0)\\n                    q.add(new int[]{i-1, j});\\n                if(i+1 < m)\\n                    q.add(new int[]{i+1, j});\\n                if(j-1 >= 0)\\n                    q.add(new int[]{i, j-1});\\n                if(j+1 < n)\\n                    q.add(new int[]{i, j+1});\\n            }\\n            ++moves;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int shortestBridge(int[][] a) {\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<String> seen = new HashSet<>();\\n        for(int i=0; i < a.length; i++)\\n            for(int j=0; j < a[0].length; j++)\\n                if(a[i][j] == 1){\\n                    dfs(a, i, j, q, seen);\\n                    return shortestPath(a, q, seen);\\n                }\\n        return -1;\\n    }\\n    private void dfs(int[][] a, int i, int j, Queue<int[]> q, Set<String> seen){\\n        if(i < 0 || j < 0 || i == a.length || j == a[0].length || a[i][j] == 0) return;\\n        String key = i+\" \"+j;\\n        if(seen.contains(key)) return;\\n        seen.add(key);\\n        q.add(new int[]{i, j});\\n        dfs(a, i+1, j, q, seen);\\n        dfs(a, i-1, j, q, seen);\\n        dfs(a, i, j+1, q, seen);\\n        dfs(a, i, j-1, q, seen);\\n    }\\n    private int shortestPath(int[][] a, Queue<int[]> q, Set<String> oldIsland){\\n        int moves = 0, m = a.length, n = a[0].length;\\n        Set<String> seen = new HashSet<>();\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int k=0; k < size; k++){\\n                int[] curr = q.remove();\\n                int i = curr[0], j = curr[1];\\n                String key = i+\" \"+j;\\n                if(seen.contains(key)) continue;\\n                if(a[i][j] == 1 && !oldIsland.contains(key)) return moves-1;\\n                seen.add(key);\\n                if(i-1 >= 0)\\n                    q.add(new int[]{i-1, j});\\n                if(i+1 < m)\\n                    q.add(new int[]{i+1, j});\\n                if(j-1 >= 0)\\n                    q.add(new int[]{i, j-1});\\n                if(j+1 < n)\\n                    q.add(new int[]{i, j+1});\\n            }\\n            ++moves;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916773,
                "title": "simple-and-clean-code-optimized-bfs-and-dfs-graph-highly-readable-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- 0(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- 0(N2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n//------------dfs -------------------//\\nvoid dfs( vector<vector<int>>&visit,  vector<vector<int>>&mark , vector<vector<int>>&grid , int markIdentity ,int i , int j, int n  ){\\n     visit[i][j] =1 ; \\n     mark[i][j] = markIdentity ; \\n int deltX[] = { 0, -1, 0 , 1};\\n int deltY[] = { -1 , 0, 1, 0};\\n\\n for( int k = 0; k<4; k++){\\n      int I = i+ deltX[k];\\n      int J = j+ deltY[k];\\nif( I>=0 and J>=0 and I<n and J<n and visit[I][J]==0 and grid[I][J] ==1 ){\\n     dfs( visit,  mark , grid , markIdentity , I, J , n);\\n}\\n\\n }\\n\\n\\n}\\n\\n//----------main function ------------//\\n    int shortestBridge(vector<vector<int>>& grid) {\\n//------lets do it by breaking it into smaller chunks------//\\n\\n// 1) make both island node  with island 1 and island 2 mark help to identify nodes using dfs \\n int n = grid.size();\\nvector<vector<int>>visit(n, vector<int>(n,0));\\nvector<vector<int>>mark(n, vector<int>(n,0));\\nqueue<pair<pair<int,int> , int> >bfs;  // for second point ignore \\nvector<vector<int>>visited(n, vector<int>(n,0)) ; // for second point ignore\\n\\nint markIdentity = 1; \\nfor(int i = 0; i<n; i++){\\n     for( int j =0; j<n; j++){\\n          if(grid[i][j] ==1 and visit[i][j]==0){\\n                dfs( visit, mark , grid ,  markIdentity , i, j , n);\\n                 markIdentity++;\\n                } \\n\\n                if( grid[i][j] == 1 and mark[i][j]==1) {\\n                     visited[i][j] =1; \\n                      bfs.push({ {i, j }, 0}); \\n                      }  // for second point ignore \\n     }\\n}\\n\\n\\n\\n// 2) second and last step do bfs to find min distance to connect this island \\n\\nint deltX[] = { 0, -1, 0 , 1};\\n int deltY[] = { -1 , 0, 1, 0};\\n\\nwhile( !bfs.empty()){\\n      pair<pair<int ,int>, int> val = bfs.front();\\n       bfs.pop(); \\n       int dis = val.second;\\n       int i = val.first.first , j = val.first.second ; \\n   for(int k = 0; k<4; k++){\\n         int I = i+ deltX[k];\\n         int J = j+ deltY[k];\\n\\n         if( I>=0 and J>=0 and I<n and J<n and visited[I][J]== 0 ){\\n             if(grid[I][J] ==1 and  mark[i][j] != mark[I][J]) return dis;\\n                 visited[I][J]=1;  \\n                 bfs.push({{I,J}, (dis+1)});        \\n         }\\n   }\\n\\n}\\n\\nreturn 0; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n//------------dfs -------------------//\\nvoid dfs( vector<vector<int>>&visit,  vector<vector<int>>&mark , vector<vector<int>>&grid , int markIdentity ,int i , int j, int n  ){\\n     visit[i][j] =1 ; \\n     mark[i][j] = markIdentity ; \\n int deltX[] = { 0, -1, 0 , 1};\\n int deltY[] = { -1 , 0, 1, 0};\\n\\n for( int k = 0; k<4; k++){\\n      int I = i+ deltX[k];\\n      int J = j+ deltY[k];\\nif( I>=0 and J>=0 and I<n and J<n and visit[I][J]==0 and grid[I][J] ==1 ){\\n     dfs( visit,  mark , grid , markIdentity , I, J , n);\\n}\\n\\n }\\n\\n\\n}\\n\\n//----------main function ------------//\\n    int shortestBridge(vector<vector<int>>& grid) {\\n//------lets do it by breaking it into smaller chunks------//\\n\\n// 1) make both island node  with island 1 and island 2 mark help to identify nodes using dfs \\n int n = grid.size();\\nvector<vector<int>>visit(n, vector<int>(n,0));\\nvector<vector<int>>mark(n, vector<int>(n,0));\\nqueue<pair<pair<int,int> , int> >bfs;  // for second point ignore \\nvector<vector<int>>visited(n, vector<int>(n,0)) ; // for second point ignore\\n\\nint markIdentity = 1; \\nfor(int i = 0; i<n; i++){\\n     for( int j =0; j<n; j++){\\n          if(grid[i][j] ==1 and visit[i][j]==0){\\n                dfs( visit, mark , grid ,  markIdentity , i, j , n);\\n                 markIdentity++;\\n                } \\n\\n                if( grid[i][j] == 1 and mark[i][j]==1) {\\n                     visited[i][j] =1; \\n                      bfs.push({ {i, j }, 0}); \\n                      }  // for second point ignore \\n     }\\n}\\n\\n\\n\\n// 2) second and last step do bfs to find min distance to connect this island \\n\\nint deltX[] = { 0, -1, 0 , 1};\\n int deltY[] = { -1 , 0, 1, 0};\\n\\nwhile( !bfs.empty()){\\n      pair<pair<int ,int>, int> val = bfs.front();\\n       bfs.pop(); \\n       int dis = val.second;\\n       int i = val.first.first , j = val.first.second ; \\n   for(int k = 0; k<4; k++){\\n         int I = i+ deltX[k];\\n         int J = j+ deltY[k];\\n\\n         if( I>=0 and J>=0 and I<n and J<n and visited[I][J]== 0 ){\\n             if(grid[I][J] ==1 and  mark[i][j] != mark[I][J]) return dis;\\n                 visited[I][J]=1;  \\n                 bfs.push({{I,J}, (dis+1)});        \\n         }\\n   }\\n\\n}\\n\\nreturn 0; \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548487,
                "title": "double-breadth-first-search-using-python-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple solution using two Breadth-First Searches via classic Python ```collections.deque```.\\nShort descriptions:\\n- find any cell of the first island\\n- collect all cells of the first island and mark it with another cell value\\n- traverse from the first island by layers to find number of steps, which we need to meet the second island\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, we should find any cell of the first island, which we can use for starting traverse.\\n\\nThen, we can start at the cell of the first island, which we found before, and traverse through other cells of the first island. During this traverse, we should mark each sell of the first island by 2, instead of 1, for differing from the second island, and collect all cells of the first island to the ```first_island_queue``` with zero distance at the start for further operations.\\n\\nAt the end, we should traverse from each cell of the first island until we reach the second island. This traverse can be operated by layer, or in other words - steps of BFS, when we process all cells from current layer:\\n- if we reached the second island, which we can identify by cell value as 1, we just return current number of steps.\\n- if we found water, or cell with 0 value, then we should mark it by -1, for marking as visited, and add it as new start cell in ```first_island_queue``` with (current number of steps + 1) steps.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom typing import List\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        \"\"\"time: O(n^2), space: O(n^2)\"\"\"\\n        n = len(grid)\\n\\n        first_x, first_y = -1, -1\\n        for x in range(n):\\n            for y in range(n):\\n                if grid[x][y] == 1:\\n                    first_x, first_y = x, y\\n                    break\\n\\n        queue = deque([(first_x, first_y)])\\n        first_island_queue = deque([(first_x, first_y, 0)])\\n        grid[first_x][first_y] = 2\\n        while(queue):\\n            x, y = queue.popleft()\\n            for d_x, d_y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                n_x, n_y = x + d_x, y + d_y\\n                if (0 <= n_x < n) and (0 <= n_y < n) and (grid[n_x][n_y] == 1):\\n                    queue.append((n_x, n_y))\\n                    first_island_queue.append((n_x, n_y, 0))\\n                    grid[n_x][n_y] = 2\\n\\n        while(first_island_queue):\\n            x, y, d = first_island_queue.popleft()\\n            for d_x, d_y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                n_x, n_y = x + d_x, y + d_y\\n                if (0 <= n_x < n) and (0 <= n_y < n):\\n                    if grid[n_x][n_y] == 1:\\n                        return d\\n                    elif grid[n_x][n_y] == 0:\\n                        grid[n_x][n_y] = -1\\n                        first_island_queue.append((n_x, n_y, d + 1))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```collections.deque```\n```first_island_queue```\n```first_island_queue```\n```\\nfrom typing import List\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        \"\"\"time: O(n^2), space: O(n^2)\"\"\"\\n        n = len(grid)\\n\\n        first_x, first_y = -1, -1\\n        for x in range(n):\\n            for y in range(n):\\n                if grid[x][y] == 1:\\n                    first_x, first_y = x, y\\n                    break\\n\\n        queue = deque([(first_x, first_y)])\\n        first_island_queue = deque([(first_x, first_y, 0)])\\n        grid[first_x][first_y] = 2\\n        while(queue):\\n            x, y = queue.popleft()\\n            for d_x, d_y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                n_x, n_y = x + d_x, y + d_y\\n                if (0 <= n_x < n) and (0 <= n_y < n) and (grid[n_x][n_y] == 1):\\n                    queue.append((n_x, n_y))\\n                    first_island_queue.append((n_x, n_y, 0))\\n                    grid[n_x][n_y] = 2\\n\\n        while(first_island_queue):\\n            x, y, d = first_island_queue.popleft()\\n            for d_x, d_y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                n_x, n_y = x + d_x, y + d_y\\n                if (0 <= n_x < n) and (0 <= n_y < n):\\n                    if grid[n_x][n_y] == 1:\\n                        return d\\n                    elif grid[n_x][n_y] == 0:\\n                        grid[n_x][n_y] = -1\\n                        first_island_queue.append((n_x, n_y, d + 1))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548424,
                "title": "c-dfs-bfs-98-time-31ms-50-space-21-3mb",
                "content": "Funny problem and we might be tempted to solve it in several ways, but the one I think might be the most convenient consists of few relatively easy steps:\\n* we will iterate through each cell until we find the first bit of land;\\n* once there, we will \"colour\" all the cells of the same first island in a different way to mark them as different from the second island and add them to a queue;\\n* after having finished mapping all the elements in the first island, we will run a search from there to try and reach the second island in the shortest amount of steps.\\n\\nWe will use a DFS to colour/mark all the elements of the first island and, as it is often the case in order to efficiently find the minimum number of steps, a BFS to move from the first to the second island.\\n\\nNow, to get started, let\\'s first of all declare a few instance variables:\\n* `qLen` will store the length of our queue;\\n* `maxX` and `maxY` will store the value of the maximum column and row index we can get, respectively;\\n* `grid` will contain our initial input;\\n* `q` is the queue of coordinate pairs we will use in our BFS logic.\\n\\nIn the main function, we will also declare `res` with an initial value of `-1` (since we will count the distance betweeen both islands, but without the destination itself, so we will have to count one less step for that) and then assign the proper values to `grid`, `maxX` and `maxY`.\\n\\nNext, we will try to loop with `cy` and `cx` through each cell in `grid` and, as soon as we find a land cell (ie: `grid[cy][cx] == 1`), we will:\\n* call `dfs` on the two current coordinates;\\n* run our BFS search from there.\\n\\nNow, focusing on the first step, our helper function `dfs` will take two coordinates `x` and `y` and:\\n* mark the current cell `grid[y][x]` as visited with a value of `-1` (but, really, it could be anything which is not in `[0, 1]`);\\n* check in every direction if we would not go out of boundaries and if it still a land cell (ie: with value `== 1`) and if so, we will call `dfs` recursively on that bit of land;\\n* add the current coordinates `x` and `y` to `q`;\\n* increase `qLen` by `1`.\\n\\nOur BFS logic will run when we have already finished marking/colouring all of the first island as visited and put all of its cells in `q`, so we will run `while` `q` is not empty (ie: `qLen != 0`) and:\\n* do a level traversal, checking the first `qLen` elements currently in `q` and:\\n    * extract the `x` and `y` coordinates of the current node (ie: `q.front()`);\\n    * pop the current node out of `q`;\\n    * if we have reached the other island (ie: `grid[y][x] == 1`), we will `return` `res`;\\n    * if not, we will use a similar logic to check every adjacent cell that is not part of the first island (ie: with value `!= -1`) and, if so:\\n        * push its coordinates into `q`;\\n        * mark it as visited (same colour of the first island to simplify the logic - it will do just fine) if it a sea square (ie: value `== 0`)\\n* increase `res` by `1` (we are now taking an extra step);\\n* restore `qLen` to be the current length of `q`. \\n\\nThe end of our core logic still has to have a `return` statement we will never reach, since we are guaranteed to have always two separate islands. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity:. $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\n    int qLen = 0, maxX, maxY;\\n    vector<vector<int>> grid;\\n    queue<pair<int, int>> q;\\n    void dfs(int x, int y) {\\n        // marking the current cell as visited\\n        grid[y][x] = -1;\\n        // moving east\\n        if (x < maxX && grid[y][x + 1] == 1) dfs(x + 1, y);\\n        // moving south\\n        if (y < maxY && grid[y + 1][x] == 1) dfs(x, y + 1);\\n        // moving west\\n        if (x && grid[y][x - 1] == 1) dfs(x - 1, y);\\n        // moving north\\n        if (y && grid[y - 1][x] == 1) dfs(x, y - 1);\\n        // storing the current cell as belonging to the first island\\n        q.push({x, y}), qLen++;\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>> &tmp) {\\n        // support variables\\n        int res = -1;\\n        // populating instance variables\\n        swap(tmp, grid);\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // parsing grid to find the first bit of land\\n        for (int cy = 0; cy <= maxY; cy++) {\\n            for (int cx = 0; cx <= maxX; cx++) {\\n                if (grid[cy][cx]) {\\n                    // marking the first island and adding its tiles to q\\n                    dfs(cx, cy);\\n                    // looking for the closest island with a BFS\\n                    while (qLen) {\\n                        // level traversal\\n                        while (qLen--) {\\n                            // extracting the current front of q\\n                            auto [x, y] = q.front();\\n                            q.pop();\\n                            // other island found!\\n                            if (grid[y][x] == 1) return res;\\n                            // moving east and marking is as added\\n                            if (x < maxX && grid[y][x + 1] != -1) {\\n                                q.push({x + 1, y});\\n                                if (!grid[y][x + 1]) grid[y][x + 1] = -1;\\n                            }\\n                            // moving south and marking is as added\\n                            if (y < maxY && grid[y + 1][x] != -1) {\\n                                q.push({x, y + 1});\\n                                if (!grid[y + 1][x]) grid[y + 1][x] = -1;\\n                            }\\n                            // moving west and marking is as added\\n                            if (x && grid[y][x - 1] != -1) {\\n                                q.push({x - 1, y});\\n                                if (!grid[y][x - 1]) grid[y][x - 1] = -1;\\n                            }\\n                            // moving north and marking is as added\\n                            if (y && grid[y - 1][x] != -1) {\\n                                q.push({x, y - 1});\\n                                if (!grid[y - 1][x]) grid[y - 1][x] = -1;\\n                            }\\n                        }\\n                        // preparing for the next pass\\n                        res++, qLen = q.size();\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\n    int qLen = 0, maxX, maxY;\\n    vector<vector<int>> grid;\\n    queue<pair<int, int>> q;\\n    void dfs(int x, int y) {\\n        // marking the current cell as visited\\n        grid[y][x] = -1;\\n        // moving east\\n        if (x < maxX && grid[y][x + 1] == 1) dfs(x + 1, y);\\n        // moving south\\n        if (y < maxY && grid[y + 1][x] == 1) dfs(x, y + 1);\\n        // moving west\\n        if (x && grid[y][x - 1] == 1) dfs(x - 1, y);\\n        // moving north\\n        if (y && grid[y - 1][x] == 1) dfs(x, y - 1);\\n        // storing the current cell as belonging to the first island\\n        q.push({x, y}), qLen++;\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>> &tmp) {\\n        // support variables\\n        int res = -1;\\n        // populating instance variables\\n        swap(tmp, grid);\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // parsing grid to find the first bit of land\\n        for (int cy = 0; cy <= maxY; cy++) {\\n            for (int cx = 0; cx <= maxX; cx++) {\\n                if (grid[cy][cx]) {\\n                    // marking the first island and adding its tiles to q\\n                    dfs(cx, cy);\\n                    // looking for the closest island with a BFS\\n                    while (qLen) {\\n                        // level traversal\\n                        while (qLen--) {\\n                            // extracting the current front of q\\n                            auto [x, y] = q.front();\\n                            q.pop();\\n                            // other island found!\\n                            if (grid[y][x] == 1) return res;\\n                            // moving east and marking is as added\\n                            if (x < maxX && grid[y][x + 1] != -1) {\\n                                q.push({x + 1, y});\\n                                if (!grid[y][x + 1]) grid[y][x + 1] = -1;\\n                            }\\n                            // moving south and marking is as added\\n                            if (y < maxY && grid[y + 1][x] != -1) {\\n                                q.push({x, y + 1});\\n                                if (!grid[y + 1][x]) grid[y + 1][x] = -1;\\n                            }\\n                            // moving west and marking is as added\\n                            if (x && grid[y][x - 1] != -1) {\\n                                q.push({x - 1, y});\\n                                if (!grid[y][x - 1]) grid[y][x - 1] = -1;\\n                            }\\n                            // moving north and marking is as added\\n                            if (y && grid[y - 1][x] != -1) {\\n                                q.push({x, y - 1});\\n                                if (!grid[y - 1][x]) grid[y - 1][x] = -1;\\n                            }\\n                        }\\n                        // preparing for the next pass\\n                        res++, qLen = q.size();\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547939,
                "title": "c-optimized-readable-solution",
                "content": "# Intuition\\n    DFS+BFS\\n# Approach\\n1.Find any cell with value 1, perform DFS and mark them as 2.\\n    simultaneously push the cell into the queue , with distance as 0.\\n2.Perform BFS in all four directions of elements in q, once you find cell 1 , return the \\'parent_cell_distance + 1\\' as answer.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*M);\\n- Space complexity:\\nO(N*M) // considering the queue size\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i , int j ,vector<vector<int>>& grid ,queue<vector<int>>&q ){\\n        if(i<0||i>=grid.size() || j<0 || j>= grid[0].size() || grid[i][j] == 2 || grid[i][j] == 0)return;\\n        grid[i][j] = 2;\\n        q.push({i,j,0});\\n        dfs(i , j-1 , grid ,q);\\n        dfs(i , j+1 , grid ,q);\\n        dfs(i+1 , j , grid ,q);\\n        dfs(i-1 , j , grid ,q);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n       \\n        queue<vector<int>>q;\\n        for(int i=0;i<grid.size();i++){\\n            int f=0;\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]){\\n                    f=1;\\n                    dfs(i,j,grid,q);\\n                    break;\\n                }\\n            }\\n            if(f)break;\\n        }\\n        \\n        cout<<q.size()<<endl;\\n        int dr[4] = {0,0,-1,1};\\n        int dc[4] = {-1,1,0,0};\\n        while(!q.empty()){\\n            auto v = q.front();\\n            q.pop();\\n            int i = v[0] , j = v[1] , dis = v[2];\\n            for(int k=0;k<4;k++){\\n                int r = i+dr[k];\\n                int c = j+dc[k];\\n                if(r<0 || c<0 || r>= grid.size() || c>=grid.size())continue;\\n                if(grid[r][c] == 2)continue;\\n                if(grid[r][c] == 1)return dis;\\n                grid[r][c] = 2; \\n                q.push({r,c,dis+1});\\n            }\\n        }\\n        return 0;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i , int j ,vector<vector<int>>& grid ,queue<vector<int>>&q ){\\n        if(i<0||i>=grid.size() || j<0 || j>= grid[0].size() || grid[i][j] == 2 || grid[i][j] == 0)return;\\n        grid[i][j] = 2;\\n        q.push({i,j,0});\\n        dfs(i , j-1 , grid ,q);\\n        dfs(i , j+1 , grid ,q);\\n        dfs(i+1 , j , grid ,q);\\n        dfs(i-1 , j , grid ,q);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n       \\n        queue<vector<int>>q;\\n        for(int i=0;i<grid.size();i++){\\n            int f=0;\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]){\\n                    f=1;\\n                    dfs(i,j,grid,q);\\n                    break;\\n                }\\n            }\\n            if(f)break;\\n        }\\n        \\n        cout<<q.size()<<endl;\\n        int dr[4] = {0,0,-1,1};\\n        int dc[4] = {-1,1,0,0};\\n        while(!q.empty()){\\n            auto v = q.front();\\n            q.pop();\\n            int i = v[0] , j = v[1] , dis = v[2];\\n            for(int k=0;k<4;k++){\\n                int r = i+dr[k];\\n                int c = j+dc[k];\\n                if(r<0 || c<0 || r>= grid.size() || c>=grid.size())continue;\\n                if(grid[r][c] == 2)continue;\\n                if(grid[r][c] == 1)return dis;\\n                grid[r][c] = 2; \\n                q.push({r,c,dis+1});\\n            }\\n        }\\n        return 0;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3547779,
                "title": "java-dfs-bfs-intuitive-solution",
                "content": "# Intuition\\nFirst thought was to think of the 2 islands as 2 nodes in a graph and then find the minimum distance between these 2 nodes.\\n\\n# Approach\\nStep 1: Apply **DFS** on both the islands and use another 2D array (or the same array) to color them seperately i.e. members of first island are marked with 1 and members of the second island are marked with 2.\\n\\nStep 2: Gather all the members of one of the islands in a queue and find the shortest route to any member of the other island using **BFS**. Here I\\'ve added members of island 2 to a queue and performed BFS to find the closest member to island 1.\\n\\nStep 3: Return the distance to the closest member of the other island. It\\'ll be the minimum number of 0s you need to flip in order to connect both the islands together.\\n\\n# Complexity\\n- Time complexity:\\nLet n be the number of cells in the matrix.\\nBoth the Depth first searches will take: O(n) time in total.\\nBFS will take: O(n) time.\\nHence Time Complexity: O(n) + O(n) = **O(n)**.\\n\\n- Space complexity:\\nWe\\'re using an auxiliary visited array which will be of size O(n).\\nWe\\'re also using a queue for BFS which will be of size O(n).\\nThe recursive stack in case of DFS can go as deep as O(n).\\nHence Space Complexity: **O(n)**.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int[] dx = {1, -1, 0, 0};\\n    int[] dy = {0, 0, 1, -1};\\n    \\n    public int shortestBridge(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        int[][] visited = new int[rows][columns];\\n        int islandCount = 0;\\n        Queue<Pair> queue = new LinkedList<>();\\n\\n\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < columns; j++) {\\n                if(grid[i][j] == 1 && visited[i][j] == 0) {\\n                    islandCount++;\\n                    DFS(i, j, grid, visited, islandCount);\\n                }\\n                if(visited[i][j] == 2) {\\n                    queue.add(new Pair(i, j));\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n\\n        outer: while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                Pair current = queue.poll();\\n                for(int j = 0; j < 4; j++) {\\n                    int row = current.row + dx[j];\\n                    int column = current.column + dy[j];\\n                    if(!isSafe(row, column, grid) || visited[row][column] == 2) {\\n                        continue;\\n                    }\\n                    if(visited[row][column] == 1) {\\n                        break outer;\\n                    }\\n                    queue.add(new Pair(row, column));\\n                    visited[row][column] = 2;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    public void DFS(int i, int j, int[][] grid, int[][] visited, int islandCount) {\\n\\n        if(!isSafe(i, j, grid) || visited[i][j] == islandCount || grid[i][j] == 0) {\\n            return;\\n        }\\n\\n        visited[i][j] = islandCount;\\n        for(int x = 0; x < 4; x++) {\\n            int row = i + dx[x];\\n            int column = j + dy[x];\\n            DFS(row, column, grid, visited, islandCount);\\n        }\\n    }\\n\\n    public boolean isSafe(int i, int j, int[][] grid) {\\n\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        if(i < 0 || i >= rows || j < 0 || j >= columns) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    class Pair {\\n\\n        int row;\\n        int column;\\n        Pair(int row, int column) {\\n            this.row = row;\\n            this.column = column;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] dx = {1, -1, 0, 0};\\n    int[] dy = {0, 0, 1, -1};\\n    \\n    public int shortestBridge(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        int[][] visited = new int[rows][columns];\\n        int islandCount = 0;\\n        Queue<Pair> queue = new LinkedList<>();\\n\\n\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < columns; j++) {\\n                if(grid[i][j] == 1 && visited[i][j] == 0) {\\n                    islandCount++;\\n                    DFS(i, j, grid, visited, islandCount);\\n                }\\n                if(visited[i][j] == 2) {\\n                    queue.add(new Pair(i, j));\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n\\n        outer: while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                Pair current = queue.poll();\\n                for(int j = 0; j < 4; j++) {\\n                    int row = current.row + dx[j];\\n                    int column = current.column + dy[j];\\n                    if(!isSafe(row, column, grid) || visited[row][column] == 2) {\\n                        continue;\\n                    }\\n                    if(visited[row][column] == 1) {\\n                        break outer;\\n                    }\\n                    queue.add(new Pair(row, column));\\n                    visited[row][column] = 2;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    public void DFS(int i, int j, int[][] grid, int[][] visited, int islandCount) {\\n\\n        if(!isSafe(i, j, grid) || visited[i][j] == islandCount || grid[i][j] == 0) {\\n            return;\\n        }\\n\\n        visited[i][j] = islandCount;\\n        for(int x = 0; x < 4; x++) {\\n            int row = i + dx[x];\\n            int column = j + dy[x];\\n            DFS(row, column, grid, visited, islandCount);\\n        }\\n    }\\n\\n    public boolean isSafe(int i, int j, int[][] grid) {\\n\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        if(i < 0 || i >= rows || j < 0 || j >= columns) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    class Pair {\\n\\n        int row;\\n        int column;\\n        Pair(int row, int column) {\\n            this.row = row;\\n            this.column = column;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547619,
                "title": "java-solution-for-shortest-bridge-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the above solution is to find the two islands in the binary grid and then use a combination of depth-first search (DFS) and breadth-first search (BFS) to find the shortest path between them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the first island: Iterate through the grid to find the first island (a group of 1s). Once found, mark the cells of this island as 2 using DFS.\\n\\n1. Expand the first island using BFS: Create a queue and add the cells of the first island to it. Perform BFS by processing the cells in the queue. Explore the neighboring cells in four directions (up, left, down, right) and check if any neighboring cell belongs to the second island (cell value 1). If found, return the distance (number of steps) taken to reach it.\\n\\n1. If the second island is not found, increment the distance and continue BFS until it is found or until there are no more cells to explore.\\n\\n1. If there is no path between the two islands, return -1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(N), where N represents the number of cells in the grid. We visit each cell only once during both the DFS and BFS steps.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(N) as well. We use additional space for the queue, visited array, and recursive stack for DFS, all of which can grow up to the size of the grid.\\n\\n# Code\\n```\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n         int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        // Step 1: Find the first island and mark its cells as 2\\n        boolean found = false;\\n        for (int i = 0; i < rows; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 1) {\\n                    dfs(grid, i, j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // Step 2: Expand the first island using BFS and find the shortest path to the second island\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        boolean[][] visited = new boolean[rows][cols];\\n        int[][] directions = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        int distance = 0;\\n        \\n        // Add the cells of the first island to the queue\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(new int[]{i, j});\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        // Perform BFS to find the shortest path to the second island\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                int[] curr = queue.poll();\\n                int currRow = curr[0];\\n                int currCol = curr[1];\\n                \\n                for (int[] dir : directions) {\\n                    int newRow = currRow + dir[0];\\n                    int newCol = currCol + dir[1];\\n                    \\n                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !visited[newRow][newCol]) {\\n                        if (grid[newRow][newCol] == 1) {\\n                            return distance;\\n                        }\\n                        \\n                        queue.offer(new int[]{newRow, newCol});\\n                        visited[newRow][newCol] = true;\\n                    }\\n                }\\n            }\\n            \\n            distance++;\\n        }\\n        \\n        return -1; // In case there is no path between the islands\\n    }\\n\\n    private void dfs(int[][] grid, int row, int col) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] != 1) {\\n            return;\\n        }\\n        \\n        grid[row][col] = 2;\\n        \\n        dfs(grid, row - 1, col);\\n        dfs(grid, row, col - 1);\\n        dfs(grid, row + 1, col);\\n        dfs(grid, row, col + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n         int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        // Step 1: Find the first island and mark its cells as 2\\n        boolean found = false;\\n        for (int i = 0; i < rows; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 1) {\\n                    dfs(grid, i, j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // Step 2: Expand the first island using BFS and find the shortest path to the second island\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        boolean[][] visited = new boolean[rows][cols];\\n        int[][] directions = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        int distance = 0;\\n        \\n        // Add the cells of the first island to the queue\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(new int[]{i, j});\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        // Perform BFS to find the shortest path to the second island\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                int[] curr = queue.poll();\\n                int currRow = curr[0];\\n                int currCol = curr[1];\\n                \\n                for (int[] dir : directions) {\\n                    int newRow = currRow + dir[0];\\n                    int newCol = currCol + dir[1];\\n                    \\n                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !visited[newRow][newCol]) {\\n                        if (grid[newRow][newCol] == 1) {\\n                            return distance;\\n                        }\\n                        \\n                        queue.offer(new int[]{newRow, newCol});\\n                        visited[newRow][newCol] = true;\\n                    }\\n                }\\n            }\\n            \\n            distance++;\\n        }\\n        \\n        return -1; // In case there is no path between the islands\\n    }\\n\\n    private void dfs(int[][] grid, int row, int col) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] != 1) {\\n            return;\\n        }\\n        \\n        grid[row][col] = 2;\\n        \\n        dfs(grid, row - 1, col);\\n        dfs(grid, row, col - 1);\\n        dfs(grid, row + 1, col);\\n        dfs(grid, row, col + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547572,
                "title": "c-dfs-approach",
                "content": "# Intuition\\nC++ DFS approach\\n\\n# Approach\\nStep-1:\\nFirst of all marks all the grid which belongs to the first island using dfs. And store the row and col of first island.\\nStep-2;\\nIn second step we started the construction of bridges and as the bridges are constructed the are going to be the part of the first island so we will push the coordinates of the newly constructed bridges in queue.\\nOnce any grid with 1 in it is found and it is not the part of first island, then we\\'ll stop construction because we have reached the second island.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int r,int c,queue<pair<int,int>>&q,vector<vector<int>>&grid,int n){\\n        if(r<0||r>=n || c<0||c>=n||grid[r][c]==-1){\\n            return;\\n        }\\n        if(grid[r][c]==0){\\n            return;\\n        }\\n        q.push({r,c});\\n        grid[r][c]=-1;\\n        dfs(r-1,c,q,grid,n);\\n        dfs(r+1,c,q,grid,n);\\n        dfs(r,c+1,q,grid,n);\\n        dfs(r,c-1,q,grid,n);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        int ans=0;\\n        int n=grid.size();\\n        bool ok=1;\\n        for(int i=0;i<n;i++){\\n            if(ok){\\n                for(int j=0;j<n;j++){\\n                    if(grid[i][j]==1){\\n                        dfs(i,j,q,grid,n);\\n                        ok=false;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        // this was step-1 in which we have marked the first island\\n        // at this point we got the co-ordinates of first island;\\n        vector<pair<int,int>>dir={{0,-1},{0,1},{1,0},{-1,0}};\\n        while(!q.empty()){\\n            int sz=q.size();\\n            \\n            for(int i=0;i<sz;i++){\\n                int curr_row=q.front().first;\\n                int curr_col=q.front().second;\\n                q.pop();\\n                for(auto ele:dir){\\n                    int dx=ele.second;\\n                    int dy=ele.first;\\n                    int new_row=curr_row+dy;\\n                    int new_col=curr_col+dx;\\n                    if(new_row>=0&&new_col>=0&&new_row<n&&new_col<n){\\n                        if(grid[new_row][new_col]==0){\\n                            q.push({new_row,new_col});\\n                            grid[new_row][new_col]=-1;\\n                        }\\n                        else{\\n                            if(grid[new_row][new_col]==1){\\n                                return ans;\\n                                // this was step-2 in which we have constructed the bridges and we stopped when we reached the second island.\\n                            \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n            // fir idhar new bridge construct krte jaao aur jaise hi construct kiya hai waise hi ans++ kr te jaao\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int r,int c,queue<pair<int,int>>&q,vector<vector<int>>&grid,int n){\\n        if(r<0||r>=n || c<0||c>=n||grid[r][c]==-1){\\n            return;\\n        }\\n        if(grid[r][c]==0){\\n            return;\\n        }\\n        q.push({r,c});\\n        grid[r][c]=-1;\\n        dfs(r-1,c,q,grid,n);\\n        dfs(r+1,c,q,grid,n);\\n        dfs(r,c+1,q,grid,n);\\n        dfs(r,c-1,q,grid,n);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        int ans=0;\\n        int n=grid.size();\\n        bool ok=1;\\n        for(int i=0;i<n;i++){\\n            if(ok){\\n                for(int j=0;j<n;j++){\\n                    if(grid[i][j]==1){\\n                        dfs(i,j,q,grid,n);\\n                        ok=false;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        // this was step-1 in which we have marked the first island\\n        // at this point we got the co-ordinates of first island;\\n        vector<pair<int,int>>dir={{0,-1},{0,1},{1,0},{-1,0}};\\n        while(!q.empty()){\\n            int sz=q.size();\\n            \\n            for(int i=0;i<sz;i++){\\n                int curr_row=q.front().first;\\n                int curr_col=q.front().second;\\n                q.pop();\\n                for(auto ele:dir){\\n                    int dx=ele.second;\\n                    int dy=ele.first;\\n                    int new_row=curr_row+dy;\\n                    int new_col=curr_col+dx;\\n                    if(new_row>=0&&new_col>=0&&new_row<n&&new_col<n){\\n                        if(grid[new_row][new_col]==0){\\n                            q.push({new_row,new_col});\\n                            grid[new_row][new_col]=-1;\\n                        }\\n                        else{\\n                            if(grid[new_row][new_col]==1){\\n                                return ans;\\n                                // this was step-2 in which we have constructed the bridges and we stopped when we reached the second island.\\n                            \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n            // fir idhar new bridge construct krte jaao aur jaise hi construct kiya hai waise hi ans++ kr te jaao\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546471,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n \\n        directions = [(0,1), (0,-1), (1,0), (-1,0)]  # right, left, up, down\\n        \\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        # find one point of a land\\n        def one_land(grid):\\n            for in_x, row in enumerate(grid):\\n                for in_y, val in enumerate(row):\\n                    if val:\\n                        return (in_x, in_y)\\n                    \\n        # start from one point and get all position of a land\\n        in_x, in_y = one_land(grid)\\n        queue = [(in_x, in_y)]\\n        first_land = [(in_x, in_y)]     # temp queue to find the first land\\n        \\n        from collections import defaultdict\\n        visited = defaultdict(lambda:False, {})\\n        visited[(in_x, in_y)] = True        \\n        \\n        # find positions of the first land\\n        while first_land:\\n            x, y = first_land.pop(0)\\n            for dir_x, dir_y in directions:\\n                nei_x = x + dir_x\\n                nei_y = y + dir_y\\n                if nei_x in range(n) and nei_y in range(m):       # point in range\\n                    if grid[nei_x][nei_y]:   # it is land\\n                        if not visited[(nei_x, nei_y)]:\\n                            first_land.append((nei_x, nei_y))\\n                            queue.append((nei_x, nei_y))\\n                            visited[(nei_x, nei_y)] = True\\n        \\n       \\n        \\n        # BFS\\n        cost = 0\\n        layer_size = 0\\n        while queue:\\n            layer_size = len(queue)\\n            for i in range(layer_size):\\n                x, y = queue.pop(0)\\n                for dir_x, dir_y in directions:\\n                    nei_x = x + dir_x\\n                    nei_y = y + dir_y\\n                    if nei_x in range(n) and nei_y in range(m):       # point in range\\n                        if not visited[(nei_x, nei_y)]:\\n                            if grid[nei_x][nei_y]:   # it is land (second land)\\n                                return cost\\n                            else:           # it is water\\n                                queue.append((nei_x, nei_y))\\n                                visited[(nei_x, nei_y)] = True\\n            cost += 1\\n        return None      \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n \\n        directions = [(0,1), (0,-1), (1,0), (-1,0)]  # right, left, up, down\\n        \\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        # find one point of a land\\n        def one_land(grid):\\n            for in_x, row in enumerate(grid):\\n                for in_y, val in enumerate(row):\\n                    if val:\\n                        return (in_x, in_y)\\n                    \\n        # start from one point and get all position of a land\\n        in_x, in_y = one_land(grid)\\n        queue = [(in_x, in_y)]\\n        first_land = [(in_x, in_y)]     # temp queue to find the first land\\n        \\n        from collections import defaultdict\\n        visited = defaultdict(lambda:False, {})\\n        visited[(in_x, in_y)] = True        \\n        \\n        # find positions of the first land\\n        while first_land:\\n            x, y = first_land.pop(0)\\n            for dir_x, dir_y in directions:\\n                nei_x = x + dir_x\\n                nei_y = y + dir_y\\n                if nei_x in range(n) and nei_y in range(m):       # point in range\\n                    if grid[nei_x][nei_y]:   # it is land\\n                        if not visited[(nei_x, nei_y)]:\\n                            first_land.append((nei_x, nei_y))\\n                            queue.append((nei_x, nei_y))\\n                            visited[(nei_x, nei_y)] = True\\n        \\n       \\n        \\n        # BFS\\n        cost = 0\\n        layer_size = 0\\n        while queue:\\n            layer_size = len(queue)\\n            for i in range(layer_size):\\n                x, y = queue.pop(0)\\n                for dir_x, dir_y in directions:\\n                    nei_x = x + dir_x\\n                    nei_y = y + dir_y\\n                    if nei_x in range(n) and nei_y in range(m):       # point in range\\n                        if not visited[(nei_x, nei_y)]:\\n                            if grid[nei_x][nei_y]:   # it is land (second land)\\n                                return cost\\n                            else:           # it is water\\n                                queue.append((nei_x, nei_y))\\n                                visited[(nei_x, nei_y)] = True\\n            cost += 1\\n        return None      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542469,
                "title": "simple-dart-solution-dfs-bfs",
                "content": "\\n\\n# Approach\\nBegin by iterating through the matrix to find both islands. When a 1 value is found use DFS to map out the entire island and place the values into a set. Then using that set continue iterating through the matrix until you find the first 1 that is not in the firt island. Then place these values into island two. From here use BFS on the first island until you find the first piece of land from island 2. At this point return the iterations of BFS required to reach the second island.\\n# Complexity\\n- Time complexity:\\nO(n) where n is the number of nodes in the matrix.\\n\\n# Code\\n```\\nclass Solution {\\n  Set<String> found = {};\\n  Set<String> second_island_set = {};\\n  Set<String> searched = {};\\n  int shortestBridge(List<List<int>> grid) {\\n\\n      List<List<int>> first_island = [];\\n      List<List<int>> second_island = [];\\n      for(int i = 0 ; i < grid.length ; ++i){\\n          for(int x = 0 ; x < grid[i].length ; ++x){\\n              if(grid[i][x] == 1 && !(found.contains(i.toString() + \" \" + x.toString()))){\\n                  if(first_island.length == 0){\\n                    explore(grid, [i, x], first_island);\\n                  }\\n                  else{\\n                    explore(grid, [i, x], second_island);\\n                    i = 10000000;\\n                    break;\\n                  }\\n              }\\n          }\\n      }\\n      List<List<int>> queue = [];\\n      //Iterate through the first list to initialize the BFS queue.\\n      for(int i = 0 ; i < first_island.length ; ++i){\\n          queue.add(first_island[i]);\\n      }\\n      //Create map of second island for faster searching\\n      for(int i = 0 ; i < second_island.length ; ++i){\\n          second_island_set.add(second_island[i][0].toString() + \" \" + second_island[i][1].toString());\\n      }\\n\\n      bool done = false;\\n      int iteration = 0;\\n\\n      while(queue.length != 0 && done == false){\\n          int init_queue = queue.length;\\n          for(int i = 0 ; i < init_queue ; ++i){\\n            List<int> current = queue[i];\\n            String curr_str = current[0].toString() + \" \" + current[1].toString();\\n            if(searched.contains(curr_str)){\\n                continue;\\n            }\\n            searched.add(curr_str);\\n            String current_str = current[0].toString() + \" \" + current[1].toString();\\n            if(second_island_set.contains(current[0].toString() + \" \" + current[1].toString())){\\n                done = true;\\n                break;\\n            }\\n            if(current[0] > 0){\\n                queue.add([current[0] - 1, current[1]]);\\n            }\\n            if(current[1] > 0){\\n                queue.add([current[0], current[1] - 1]);\\n            }\\n            if(current[0] < grid.length - 1){\\n                queue.add([current[0] + 1, current[1]]);\\n            }\\n            if(current[1] < grid[current[0]].length - 1){\\n                queue.add([current[0], current[1] + 1]);\\n            }\\n          }\\n          if(done != true){\\n            queue = queue.sublist(init_queue);\\n            iteration += 1;\\n          }\\n      }\\n      return iteration - 1;\\n\\n  }\\n\\n  //DFS to explore the entire island that is at the position[0][1]. This places the island positions in \\n  //the inputted island matrix and adds the values to the found set to help not search the same island\\n  //multiple times.\\n  void explore(List<List<int>> grid , List<int> position, List<List<int>> island){\\n      int currentx = position[0];\\n      int currenty = position[1];\\n      if(grid[currentx][currenty] != 1){\\n          return;\\n      }\\n      String position_str = currentx.toString() + \" \" + currenty.toString();\\n      if(found.contains(position_str)){\\n          return;\\n      }\\n      found.add(position_str);\\n      island.add([currentx , currenty]);\\n      if(currentx > 0){\\n          explore(grid, [currentx - 1, currenty], island);\\n      }\\n      if(currenty > 0){\\n          explore(grid, [currentx, currenty - 1], island);\\n      }\\n      if(currentx < grid.length - 1){\\n          explore(grid, [currentx + 1, currenty], island);\\n      }\\n      if(currenty < grid[currentx].length - 1){\\n          explore(grid, [currentx, currenty + 1], island);\\n      }\\n\\n  }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Dart",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  Set<String> found = {};\\n  Set<String> second_island_set = {};\\n  Set<String> searched = {};\\n  int shortestBridge(List<List<int>> grid) {\\n\\n      List<List<int>> first_island = [];\\n      List<List<int>> second_island = [];\\n      for(int i = 0 ; i < grid.length ; ++i){\\n          for(int x = 0 ; x < grid[i].length ; ++x){\\n              if(grid[i][x] == 1 && !(found.contains(i.toString() + \" \" + x.toString()))){\\n                  if(first_island.length == 0){\\n                    explore(grid, [i, x], first_island);\\n                  }\\n                  else{\\n                    explore(grid, [i, x], second_island);\\n                    i = 10000000;\\n                    break;\\n                  }\\n              }\\n          }\\n      }\\n      List<List<int>> queue = [];\\n      //Iterate through the first list to initialize the BFS queue.\\n      for(int i = 0 ; i < first_island.length ; ++i){\\n          queue.add(first_island[i]);\\n      }\\n      //Create map of second island for faster searching\\n      for(int i = 0 ; i < second_island.length ; ++i){\\n          second_island_set.add(second_island[i][0].toString() + \" \" + second_island[i][1].toString());\\n      }\\n\\n      bool done = false;\\n      int iteration = 0;\\n\\n      while(queue.length != 0 && done == false){\\n          int init_queue = queue.length;\\n          for(int i = 0 ; i < init_queue ; ++i){\\n            List<int> current = queue[i];\\n            String curr_str = current[0].toString() + \" \" + current[1].toString();\\n            if(searched.contains(curr_str)){\\n                continue;\\n            }\\n            searched.add(curr_str);\\n            String current_str = current[0].toString() + \" \" + current[1].toString();\\n            if(second_island_set.contains(current[0].toString() + \" \" + current[1].toString())){\\n                done = true;\\n                break;\\n            }\\n            if(current[0] > 0){\\n                queue.add([current[0] - 1, current[1]]);\\n            }\\n            if(current[1] > 0){\\n                queue.add([current[0], current[1] - 1]);\\n            }\\n            if(current[0] < grid.length - 1){\\n                queue.add([current[0] + 1, current[1]]);\\n            }\\n            if(current[1] < grid[current[0]].length - 1){\\n                queue.add([current[0], current[1] + 1]);\\n            }\\n          }\\n          if(done != true){\\n            queue = queue.sublist(init_queue);\\n            iteration += 1;\\n          }\\n      }\\n      return iteration - 1;\\n\\n  }\\n\\n  //DFS to explore the entire island that is at the position[0][1]. This places the island positions in \\n  //the inputted island matrix and adds the values to the found set to help not search the same island\\n  //multiple times.\\n  void explore(List<List<int>> grid , List<int> position, List<List<int>> island){\\n      int currentx = position[0];\\n      int currenty = position[1];\\n      if(grid[currentx][currenty] != 1){\\n          return;\\n      }\\n      String position_str = currentx.toString() + \" \" + currenty.toString();\\n      if(found.contains(position_str)){\\n          return;\\n      }\\n      found.add(position_str);\\n      island.add([currentx , currenty]);\\n      if(currentx > 0){\\n          explore(grid, [currentx - 1, currenty], island);\\n      }\\n      if(currenty > 0){\\n          explore(grid, [currentx, currenty - 1], island);\\n      }\\n      if(currentx < grid.length - 1){\\n          explore(grid, [currentx + 1, currenty], island);\\n      }\\n      if(currenty < grid[currentx].length - 1){\\n          explore(grid, [currentx, currenty + 1], island);\\n      }\\n\\n  }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503700,
                "title": "easiest-java-solution-bfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Tuple{\\n    int x,y,dist;\\n    public Tuple(int x,int y, int dist)\\n    {\\n        this.x=x;\\n        this.y=y;\\n        this.dist=dist;\\n    }\\n}\\nclass Solution {\\n    int n,m;\\n#This function marks any one component as visited by marking it to 2\\n    public void bfs(int[][] grid,int r,int c, PriorityQueue<Tuple> pq,PriorityQueue<Tuple> pq1)\\n    {\\n        int[] del_row={0,1,0,-1};\\n        int[] del_col={1,0,-1,0};\\n        pq.add(new Tuple(r,c,0));\\n        pq1.add(new Tuple(r,c,0));\\n        while(!pq.isEmpty())\\n        {\\n            int x=pq.peek().x;\\n            int y=pq.peek().y;\\n            int dist=pq.peek().dist;\\n            grid[x][y]=2;\\n            pq.remove();\\n            for(int i=0;i<4;i++)\\n            {\\n                int d_row=x+del_row[i];\\n                int d_col=y+del_col[i];\\n                if(d_row>=0 && d_row<n && d_col>=0 && d_col<m && grid[d_row][d_col]==1)\\n                {\\n                    grid[d_row][d_col]=2;\\n                    pq.add(new Tuple(d_row,d_col,0));\\n                    pq1.add(new Tuple(d_row,d_col,0));\\n                }\\n            }\\n\\n\\n        }\\n    }\\n    public int shortestBridge(int[][] grid) {\\n        n=grid.length;\\n        m=grid[0].length;\\n        PriorityQueue<Tuple> pq=new PriorityQueue<>((a,b)->a.dist-b.dist);\\n        PriorityQueue<Tuple> pq1=new PriorityQueue<>((a,b)->a.dist-b.dist);\\n\\n        int a,b,c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if (grid[i][j]==1){\\n                    a=i;\\n                    b=j;\\n                    c=1;\\n                    bfs(grid,a,b,pq,pq1);\\n                    break;\\n                }\\n            }\\n            if (c==1)\\n                break;\\n        }\\n\\n        int[] del_row={0,1,0,-1};\\n        int[] del_col={1,0,-1,0};\\n\\n        while(!pq1.isEmpty())\\n        {\\n            int x=pq1.peek().x;\\n            int y=pq1.peek().y;\\n            int dist=pq1.peek().dist;\\n            pq1.remove();\\n            for(int i=0;i<4;i++)\\n            {\\n                int d_row=x+del_row[i];\\n                int d_col=y+del_col[i];\\n                if(d_row>=0 && d_row<n && d_col>=0 && d_col<m && grid[d_row][d_col]==1)\\n                    return dist;\\n                if(d_row>=0 && d_row<n && d_col>=0 && d_col<m && grid[d_row][d_col]==0)\\n                {\\n                    grid[d_row][d_col]=2;\\n                    pq1.add(new Tuple(d_row,d_col,dist+1));\\n                }\\n                \\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Tuple{\\n    int x,y,dist;\\n    public Tuple(int x,int y, int dist)\\n    {\\n        this.x=x;\\n        this.y=y;\\n        this.dist=dist;\\n    }\\n}\\nclass Solution {\\n    int n,m;\\n#This function marks any one component as visited by marking it to 2\\n    public void bfs(int[][] grid,int r,int c, PriorityQueue<Tuple> pq,PriorityQueue<Tuple> pq1)\\n    {\\n        int[] del_row={0,1,0,-1};\\n        int[] del_col={1,0,-1,0};\\n        pq.add(new Tuple(r,c,0));\\n        pq1.add(new Tuple(r,c,0));\\n        while(!pq.isEmpty())\\n        {\\n            int x=pq.peek().x;\\n            int y=pq.peek().y;\\n            int dist=pq.peek().dist;\\n            grid[x][y]=2;\\n            pq.remove();\\n            for(int i=0;i<4;i++)\\n            {\\n                int d_row=x+del_row[i];\\n                int d_col=y+del_col[i];\\n                if(d_row>=0 && d_row<n && d_col>=0 && d_col<m && grid[d_row][d_col]==1)\\n                {\\n                    grid[d_row][d_col]=2;\\n                    pq.add(new Tuple(d_row,d_col,0));\\n                    pq1.add(new Tuple(d_row,d_col,0));\\n                }\\n            }\\n\\n\\n        }\\n    }\\n    public int shortestBridge(int[][] grid) {\\n        n=grid.length;\\n        m=grid[0].length;\\n        PriorityQueue<Tuple> pq=new PriorityQueue<>((a,b)->a.dist-b.dist);\\n        PriorityQueue<Tuple> pq1=new PriorityQueue<>((a,b)->a.dist-b.dist);\\n\\n        int a,b,c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if (grid[i][j]==1){\\n                    a=i;\\n                    b=j;\\n                    c=1;\\n                    bfs(grid,a,b,pq,pq1);\\n                    break;\\n                }\\n            }\\n            if (c==1)\\n                break;\\n        }\\n\\n        int[] del_row={0,1,0,-1};\\n        int[] del_col={1,0,-1,0};\\n\\n        while(!pq1.isEmpty())\\n        {\\n            int x=pq1.peek().x;\\n            int y=pq1.peek().y;\\n            int dist=pq1.peek().dist;\\n            pq1.remove();\\n            for(int i=0;i<4;i++)\\n            {\\n                int d_row=x+del_row[i];\\n                int d_col=y+del_col[i];\\n                if(d_row>=0 && d_row<n && d_col>=0 && d_col<m && grid[d_row][d_col]==1)\\n                    return dist;\\n                if(d_row>=0 && d_row<n && d_col>=0 && d_col<m && grid[d_row][d_col]==0)\\n                {\\n                    grid[d_row][d_col]=2;\\n                    pq1.add(new Tuple(d_row,d_col,dist+1));\\n                }\\n                \\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472751,
                "title": "python-bfs-solution-with-brief-explanation",
                "content": "# Approach\\nThis problem is simply a` multi-source BFS` problem where all nodes on `Island 1` are treated as if they are on the same level.\\n<!-- Describe your approach to solving the problem. -->\\n### The solution to this problem is :\\nget all the components of `Island 1` and treate `Island one` components as if there are on the same level and make BFS until we get `Island 2`. \\nSo the` number of moves` until we get `Island 2` is `SHORTEST BRIDGE`\\n\\n# Complexity\\n- Time complexity: O(V + E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n\\n        # step-1, get all components of island 1\\n        islandOne, q, visited = deque(), deque(), set()\\n        for r in range( len(grid)):\\n            for c in range( len(grid[0])):\\n                if grid[r][c] == 1:\\n                    islandOne.append([r, c])\\n                    q.append([r, c])\\n                    visited.add((r,c))\\n                    break\\n            if len(islandOne) == 1:\\n                break\\n        \\n        def isvalid(row, col):\\n            if 0 <= row < len(grid) and 0 <= col < len(grid):\\n                return True\\n            return False\\n\\n        # make a BFS on the first land cell and get all cell in Islandone\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                row, col = q.popleft()\\n                for r, c in [ [0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    newRow, newCol = row + r, col + c\\n                    if (newRow,newCol) not in visited and isvalid(newRow, newCol) and grid[newRow][newCol] == 1:\\n                        q.append([newRow, newCol])\\n                        islandOne.append([newRow, newCol])\\n                        visited.add((newRow, newCol))\\n        \\n        # step-2, make BFS on islandOne until we get Island-2\\n        numberOfMoves = 0\\n        while islandOne:\\n            size = len(islandOne)\\n            for _ in range( size ):\\n                row, col = islandOne.popleft()\\n                for r, c in [[0, 1],[0, -1],[1, 0], [-1, 0]]:\\n                    newRow, newCol = row + r, col + c\\n\\n                    if (newRow,newCol) not in visited and isvalid(newRow, newCol):\\n                        # there are exactly 2 islands, so terminate here since Island-2 is found\\n                        if grid[newRow][newCol] == 1:\\n                            return numberOfMoves\\n\\n                        islandOne.append([newRow, newCol])\\n                        visited.add((newRow, newCol))\\n            numberOfMoves += 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n\\n        # step-1, get all components of island 1\\n        islandOne, q, visited = deque(), deque(), set()\\n        for r in range( len(grid)):\\n            for c in range( len(grid[0])):\\n                if grid[r][c] == 1:\\n                    islandOne.append([r, c])\\n                    q.append([r, c])\\n                    visited.add((r,c))\\n                    break\\n            if len(islandOne) == 1:\\n                break\\n        \\n        def isvalid(row, col):\\n            if 0 <= row < len(grid) and 0 <= col < len(grid):\\n                return True\\n            return False\\n\\n        # make a BFS on the first land cell and get all cell in Islandone\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                row, col = q.popleft()\\n                for r, c in [ [0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    newRow, newCol = row + r, col + c\\n                    if (newRow,newCol) not in visited and isvalid(newRow, newCol) and grid[newRow][newCol] == 1:\\n                        q.append([newRow, newCol])\\n                        islandOne.append([newRow, newCol])\\n                        visited.add((newRow, newCol))\\n        \\n        # step-2, make BFS on islandOne until we get Island-2\\n        numberOfMoves = 0\\n        while islandOne:\\n            size = len(islandOne)\\n            for _ in range( size ):\\n                row, col = islandOne.popleft()\\n                for r, c in [[0, 1],[0, -1],[1, 0], [-1, 0]]:\\n                    newRow, newCol = row + r, col + c\\n\\n                    if (newRow,newCol) not in visited and isvalid(newRow, newCol):\\n                        # there are exactly 2 islands, so terminate here since Island-2 is found\\n                        if grid[newRow][newCol] == 1:\\n                            return numberOfMoves\\n\\n                        islandOne.append([newRow, newCol])\\n                        visited.add((newRow, newCol))\\n            numberOfMoves += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423960,
                "title": "java-solution-using-bfs-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int row;\\n    int col;\\n    Pair(int row,int col){\\n        this.row=row;\\n        this.col=col;\\n    }\\n\\n}\\n\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int visit[][]=new int[n][m];\\n        Queue<Pair>q=new LinkedList<>();\\n\\n        int delRow[]={1,-1,0,0};\\n        int delCol[]={0,0,1,-1};\\n\\n        boolean flag=false;\\n        \\n        for(int i=0;i<n && !flag;i++){\\n            for(int j=0;j<m && !flag;j++){\\n                if(visit[i][j]==0 && grid[i][j]==1){\\n                    dfs(i,j,grid,visit,q,delRow,delCol);\\n                    flag=true;\\n                }\\n            }\\n        }\\n    \\n\\n        int count=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                Pair pr=q.poll();\\n                int row=pr.row;\\n                int col=pr.col;\\n                visit[row][col]=1;\\n\\n                for(int i=0;i<4;i++){\\n                    int nrow=row+delRow[i];\\n                    int ncol=col+delCol[i];\\n\\n                    if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0){  \\n                        q.add(new Pair(nrow,ncol));\\n                        visit[nrow][ncol]=1;\\n                        if(grid[nrow][ncol]==1){\\n                            return count;\\n                        }\\n                    }    \\n                }\\n\\n            }\\n            count++;\\n            \\n        }\\n        return -1;\\n\\n\\n    }\\n\\n    public static void dfs(int row,int col,int [][]grid,int visit[][],Queue<Pair>q,int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        q.add(new Pair(row,col));\\n        visit[row][col]=1;\\n\\n        for(int i=0;i<4;i++){\\n            int nrow=row+delRow[i];\\n            int ncol=col+delCol[i];\\n\\n            if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]==1){  \\n                dfs(nrow,ncol,grid,visit,q,delRow,delCol);\\n            }\\n\\n            \\n        }\\n        \\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int row;\\n    int col;\\n    Pair(int row,int col){\\n        this.row=row;\\n        this.col=col;\\n    }\\n\\n}\\n\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int visit[][]=new int[n][m];\\n        Queue<Pair>q=new LinkedList<>();\\n\\n        int delRow[]={1,-1,0,0};\\n        int delCol[]={0,0,1,-1};\\n\\n        boolean flag=false;\\n        \\n        for(int i=0;i<n && !flag;i++){\\n            for(int j=0;j<m && !flag;j++){\\n                if(visit[i][j]==0 && grid[i][j]==1){\\n                    dfs(i,j,grid,visit,q,delRow,delCol);\\n                    flag=true;\\n                }\\n            }\\n        }\\n    \\n\\n        int count=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                Pair pr=q.poll();\\n                int row=pr.row;\\n                int col=pr.col;\\n                visit[row][col]=1;\\n\\n                for(int i=0;i<4;i++){\\n                    int nrow=row+delRow[i];\\n                    int ncol=col+delCol[i];\\n\\n                    if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0){  \\n                        q.add(new Pair(nrow,ncol));\\n                        visit[nrow][ncol]=1;\\n                        if(grid[nrow][ncol]==1){\\n                            return count;\\n                        }\\n                    }    \\n                }\\n\\n            }\\n            count++;\\n            \\n        }\\n        return -1;\\n\\n\\n    }\\n\\n    public static void dfs(int row,int col,int [][]grid,int visit[][],Queue<Pair>q,int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        q.add(new Pair(row,col));\\n        visit[row][col]=1;\\n\\n        for(int i=0;i<4;i++){\\n            int nrow=row+delRow[i];\\n            int ncol=col+delCol[i];\\n\\n            if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]==1){  \\n                dfs(nrow,ncol,grid,visit,q,delRow,delCol);\\n            }\\n\\n            \\n        }\\n        \\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221723,
                "title": "c-esay-understand-72-beats-bfs-ans-dfs-both",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nqueue<pair<pair<int,int >,int>> q;\\nprivate: \\nvoid dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& visited){\\n    if(!(row>=0 && row<grid.size() && col>=0 && col<grid[0].size() && !visited[row][col] && grid[row][col]))return ;\\n    grid[row][col]=0;\\n    visited[row][col]=1;\\n    q.push({{row,col},0});\\n      dfs(row+1,col,grid,visited);\\n      dfs(row,col+1,grid,visited);\\n      dfs(row-1,col,grid,visited);\\n      dfs(row,col-1,grid,visited);\\n\\n}\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>image=grid;\\n        vector<vector<int>> visited(m,vector<int>(n,0));\\n        int startrow=0;\\n        int startcol=0;\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n             if(grid[i][j]==1){\\n               startrow=i;\\n               startcol=j;   \\n               break;   \\n             }  \\n            }\\n        }\\n        dfs(startrow,startcol,grid,visited);\\n        int delrow[]={1,0,-1,0};\\n        int delcol[]={0,1,0,-1};\\n        while(!q.empty()){\\n            auto it= q.front();\\n            int row= it.first.first;\\n            int col= it.first.second;\\n            int steps=it.second;\\n            cout<<steps;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow= row+ delrow[i];\\n                int ncol= col+ delcol[i];\\n                if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && !visited[nrow][ncol]  ){\\n                        visited[nrow][ncol]=1;\\n                        q.push({{nrow,ncol},steps+1});\\n                        if(grid[nrow][ncol]==1){\\n                            return steps;\\n                        }\\n                }\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nqueue<pair<pair<int,int >,int>> q;\\nprivate: \\nvoid dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& visited){\\n    if(!(row>=0 && row<grid.size() && col>=0 && col<grid[0].size() && !visited[row][col] && grid[row][col]))return ;\\n    grid[row][col]=0;\\n    visited[row][col]=1;\\n    q.push({{row,col},0});\\n      dfs(row+1,col,grid,visited);\\n      dfs(row,col+1,grid,visited);\\n      dfs(row-1,col,grid,visited);\\n      dfs(row,col-1,grid,visited);\\n\\n}\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>image=grid;\\n        vector<vector<int>> visited(m,vector<int>(n,0));\\n        int startrow=0;\\n        int startcol=0;\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n             if(grid[i][j]==1){\\n               startrow=i;\\n               startcol=j;   \\n               break;   \\n             }  \\n            }\\n        }\\n        dfs(startrow,startcol,grid,visited);\\n        int delrow[]={1,0,-1,0};\\n        int delcol[]={0,1,0,-1};\\n        while(!q.empty()){\\n            auto it= q.front();\\n            int row= it.first.first;\\n            int col= it.first.second;\\n            int steps=it.second;\\n            cout<<steps;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow= row+ delrow[i];\\n                int ncol= col+ delcol[i];\\n                if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && !visited[nrow][ncol]  ){\\n                        visited[nrow][ncol]=1;\\n                        q.push({{nrow,ncol},steps+1});\\n                        if(grid[nrow][ncol]==1){\\n                            return steps;\\n                        }\\n                }\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3219461,
                "title": "c-solution-with-comments-dfs-bfs",
                "content": "```\\n//dfs to store all island in queue\\n//bfs from every land to calculate min dis\\n\\nclass Solution {\\npublic:\\n    int n,ans=0;\\n    queue<vector<int>> q;\\n    vector<int> di= {-1,0,1,0} , dj= {0,1,0,-1};\\n    vector<vector<bool>> vis;\\n    \\n    bool isValid(int i,int j){\\n        return (i>=0 && j>=0 && i<n && j<n);\\n    }\\n    \\n    void dfs(int i,int j,vector<vector<int>>& grid){\\n        for(int k=0;k<4;k++){\\n            int ii= i+di[k], jj= j+dj[k];\\n            if(isValid(ii,jj) && grid[ii][jj]==1){\\n                q.push({ii,jj});\\n                vis[ii][jj]= true;\\n                grid[ii][jj]=0;\\n                dfs(ii,jj,grid);\\n            }\\n        }\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        n= grid.size();\\n        vis.resize(n, vector<bool>(n, false));\\n        bool done= false;\\n        \\n        // for DFS call only one the when first \"1\" is found\\n        for(int i=0;i<n;i++){\\n            if(done) break;\\n            for(int j=0;j<n;j++){\\n                if(done) break;\\n                if(grid[i][j]==1) {\\n                    q.push({i,j});\\n                    vis[i][j]= true;\\n                    grid[i][j]=0;\\n                    dfs(i,j,grid);\\n                    done= true;\\n                }\\n            }\\n        }\\n        \\n        \\n        // BFS call from all island-1\\n        while(!q.empty()){\\n            int sz= q.size();\\n            \\n            while(sz--){\\n                int i= q.front()[0], j= q.front()[1];\\n                q.pop();\\n                \\n                for(int k=0; k<4; k++){\\n                    int ii= i+di[k], jj= j+dj[k];\\n                    if(isValid(ii,jj) && vis[ii][jj]==false){\\n                        if(grid[ii][jj]==1) return ans;\\n                        vis[ii][jj]= true;\\n                        q.push({ii,jj});\\n                    }\\n                }\\n            }\\n            \\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\n//dfs to store all island in queue\\n//bfs from every land to calculate min dis\\n\\nclass Solution {\\npublic:\\n    int n,ans=0;\\n    queue<vector<int>> q;\\n    vector<int> di= {-1,0,1,0} , dj= {0,1,0,-1};\\n    vector<vector<bool>> vis;\\n    \\n    bool isValid(int i,int j){\\n        return (i>=0 && j>=0 && i<n && j<n);\\n    }\\n    \\n    void dfs(int i,int j,vector<vector<int>>& grid){\\n        for(int k=0;k<4;k++){\\n            int ii= i+di[k], jj= j+dj[k];\\n            if(isValid(ii,jj) && grid[ii][jj]==1){\\n                q.push({ii,jj});\\n                vis[ii][jj]= true;\\n                grid[ii][jj]=0;\\n                dfs(ii,jj,grid);\\n            }\\n        }\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        n= grid.size();\\n        vis.resize(n, vector<bool>(n, false));\\n        bool done= false;\\n        \\n        // for DFS call only one the when first \"1\" is found\\n        for(int i=0;i<n;i++){\\n            if(done) break;\\n            for(int j=0;j<n;j++){\\n                if(done) break;\\n                if(grid[i][j]==1) {\\n                    q.push({i,j});\\n                    vis[i][j]= true;\\n                    grid[i][j]=0;\\n                    dfs(i,j,grid);\\n                    done= true;\\n                }\\n            }\\n        }\\n        \\n        \\n        // BFS call from all island-1\\n        while(!q.empty()){\\n            int sz= q.size();\\n            \\n            while(sz--){\\n                int i= q.front()[0], j= q.front()[1];\\n                q.pop();\\n                \\n                for(int k=0; k<4; k++){\\n                    int ii= i+di[k], jj= j+dj[k];\\n                    if(isValid(ii,jj) && vis[ii][jj]==false){\\n                        if(grid[ii][jj]==1) return ans;\\n                        vis[ii][jj]= true;\\n                        q.push({ii,jj});\\n                    }\\n                }\\n            }\\n            \\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054854,
                "title": "c-dfs-bfs-97-faster-approach-explained",
                "content": "# Approach\\n1. Find first island and traverse it using dfs.\\n2. While traversing, push all water nodes into the queue.\\n3. Do a multi sourc bfs, to find the shortest path between the first island and second, this will indicate the number of 0s needed to be flipped.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* \\nApproach :\\n1. Find first island and traverse it using dfs.\\n2. While traversing, push all water nodes into the queue.\\n3. Do a multi sourc bfs, to find the shortest path between the first island and second, this will indicate the number of 0s needed to be flipped.\\n*/\\nclass Solution {\\npublic:\\n    queue<pair<int,int>>q;\\n    int visited[101][101];\\n    void dfs(int i,int j,queue<pair<int,int>>&q,vector<vector<int>>& grid)\\n    {\\n        if(i<0 || j<0 || i>=grid.size()|| j>=grid.size() || visited[i][j])  return;\\n        visited[i][j]=true;\\n        if(grid[i][j]==0){q.push({i,j});\\n        return;}\\n        dfs(i+1,j,q,grid);\\n        dfs(i-1,j,q,grid);\\n        dfs(i,j+1,q,grid);\\n        dfs(i,j-1,q,grid);\\n\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        memset(visited,0,sizeof(visited));\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int flag=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)     \\n                {\\n                    flag =1;\\n                    dfs(i,j,q,grid);\\n                    break;\\n                }\\n            }\\n            if(flag)break;\\n        }\\n        int level=0;\\n        vector<int>rowDir = {-1,1,0,0};\\n        vector<int>colDir = {0,0,-1,1};\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {   \\n                int curRow = q.front().first;\\n                int curCol = q.front().second;\\n                if(grid[curRow][curCol]==1)return level;\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int nextRow= curRow+rowDir[i];\\n                    int nextCol= curCol+colDir[i];\\n                    if(nextRow>=0 && nextCol>=0 &&nextCol<n && nextRow<n && !visited[nextRow][nextCol])\\n                    {\\n                        visited[nextRow][nextCol]=1;\\n                        q.push({nextRow,nextCol});\\n                    }\\n                }\\n                \\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/* \\nApproach :\\n1. Find first island and traverse it using dfs.\\n2. While traversing, push all water nodes into the queue.\\n3. Do a multi sourc bfs, to find the shortest path between the first island and second, this will indicate the number of 0s needed to be flipped.\\n*/\\nclass Solution {\\npublic:\\n    queue<pair<int,int>>q;\\n    int visited[101][101];\\n    void dfs(int i,int j,queue<pair<int,int>>&q,vector<vector<int>>& grid)\\n    {\\n        if(i<0 || j<0 || i>=grid.size()|| j>=grid.size() || visited[i][j])  return;\\n        visited[i][j]=true;\\n        if(grid[i][j]==0){q.push({i,j});\\n        return;}\\n        dfs(i+1,j,q,grid);\\n        dfs(i-1,j,q,grid);\\n        dfs(i,j+1,q,grid);\\n        dfs(i,j-1,q,grid);\\n\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        memset(visited,0,sizeof(visited));\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int flag=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)     \\n                {\\n                    flag =1;\\n                    dfs(i,j,q,grid);\\n                    break;\\n                }\\n            }\\n            if(flag)break;\\n        }\\n        int level=0;\\n        vector<int>rowDir = {-1,1,0,0};\\n        vector<int>colDir = {0,0,-1,1};\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {   \\n                int curRow = q.front().first;\\n                int curCol = q.front().second;\\n                if(grid[curRow][curCol]==1)return level;\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int nextRow= curRow+rowDir[i];\\n                    int nextCol= curCol+colDir[i];\\n                    if(nextRow>=0 && nextCol>=0 &&nextCol<n && nextRow<n && !visited[nextRow][nextCol])\\n                    {\\n                        visited[nextRow][nextCol]=1;\\n                        q.push({nextRow,nextCol});\\n                    }\\n                }\\n                \\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028104,
                "title": "simple-java-solution-with-explanation-shortest-bridge-dfs",
                "content": "# Intuition\\nSimple approach of forming the graph first using DFS and then using that graph to reach the other graph using BFS.\\n\\n# Approach\\nFirst we are forming the graph with DFS and then using the queue we do BFS traversal and find then minimum number of steps to build a bridge so that both the graphs get connected.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$\\n\\n- Space complexity:\\n$$O(n * n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        Queue<int[]> q = new LinkedList<>();\\n        int[] dx = {-1,0,1,0};\\n        int[] dy = {0,-1,0,1};\\n        int n = grid.length;\\n        boolean[][] vis = new boolean[n][n];\\n        boolean breakEnable = false;\\n        for(int i = 0; i < n ; i++){\\n            if(breakEnable) break;\\n            for(int j = 0 ; j < n ; j++){\\n                if(grid[i][j] == 1){\\n                    formGraph(grid , q ,i , j ,  n ,vis , dx , dy);\\n                    breakEnable = true;\\n                    break;\\n                }\\n            }\\n        }\\n        int minimumSteps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                int[] curr = q.remove();\\n                for(int i = 0 ; i < 4 ; i++){\\n                    int newX = curr[0] + dx[i];\\n                    int newY = curr[1] + dy[i];\\n                    if(isValid(newX,newY,n)){\\n                        if(!vis[newX][newY] && grid[newX ][newY] == 1){\\n                            return minimumSteps;\\n                        }\\n                        else if(!vis[newX][newY] && grid[newX][newY] == 0){\\n                            q.add(new int[]{newX,newY});\\n                            vis[newX][newY] = true;\\n                        }\\n                    } \\n                }\\n            }\\n            minimumSteps++;\\n        }\\n        return -1;\\n    }\\n\\n    public boolean isValid(int i , int j , int n){\\n        if(i < 0 || j<0 || i >=n || j >= n) return false;\\n        return true;\\n    }\\n\\n    public void formGraph(int[][] grid , Queue<int[]> q , int x , int y , int n , boolean[][] vis , int[] dx , int[] dy){\\n        if(!isValid(x,y,n)) return;\\n        if(!vis[x][y] && grid[x][y] == 1){\\n            q.add(new int[] {x,y});\\n        }else{\\n            return;\\n        }\\n        vis[x][y] = true;\\n\\n        for(int i = 0 ; i < 4 ; i++){\\n            int newX = x + dx[i];\\n            int newY = y + dy[i];\\n            formGraph(grid , q, newX,newY,n,vis,dx,dy);\\n        }\\n    }\\n}\\n\\n\\n// class Solution {\\n//     public int shortestBridge(int[][] A) {\\n//         int m = A.length, n = A[0].length;\\n//         boolean[][] visited = new boolean[m][n];\\n//         int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n//         Queue<int[]> q = new LinkedList<>();\\n//         boolean found = false;\\n//         // 1. dfs to find an island, mark it in `visited`\\n//         for (int i = 0; i < m; i++) {\\n//             if (found) {\\n//                 break;\\n//             }\\n//             for (int j = 0; j < n; j++) {\\n//                 if (A[i][j] == 1) {\\n//                     dfs(A, visited, q, i, j, dirs);\\n//                     found = true;\\n//                     break;\\n//                 }\\n//             }\\n//         }\\n//         // 2. bfs to expand this island\\n//         int step = 0;\\n//         while (!q.isEmpty()) {\\n//             int size = q.size();\\n//             while (size-- > 0) {\\n//                 int[] cur = q.poll();\\n//                 for (int[] dir : dirs) {\\n//                     int i = cur[0] + dir[0];\\n//                     int j = cur[1] + dir[1];\\n//                     if (i >= 0 && j >= 0 && i < m && j < n && !visited[i][j]) {\\n//                         if (A[i][j] == 1) {\\n//                             return step;\\n//                         }\\n//                         q.offer(new int[]{i, j});\\n//                         visited[i][j] = true;\\n//                     }\\n//                 }\\n//             }\\n//             step++;\\n//         }\\n//         return -1;\\n//     }\\n//     private void dfs(int[][] A, boolean[][] visited, Queue<int[]> q, int i, int j, int[][] dirs) {\\n//         if (i < 0 || j < 0 || i >= A.length || j >= A[0].length || visited[i][j] || A[i][j] == 0) {\\n//             return;\\n//         }\\n//         visited[i][j] = true;\\n//         q.offer(new int[]{i, j});\\n//         for (int[] dir : dirs) {\\n//             dfs(A, visited, q, i + dir[0], j + dir[1], dirs);\\n//         }\\n//     }\\n// }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        Queue<int[]> q = new LinkedList<>();\\n        int[] dx = {-1,0,1,0};\\n        int[] dy = {0,-1,0,1};\\n        int n = grid.length;\\n        boolean[][] vis = new boolean[n][n];\\n        boolean breakEnable = false;\\n        for(int i = 0; i < n ; i++){\\n            if(breakEnable) break;\\n            for(int j = 0 ; j < n ; j++){\\n                if(grid[i][j] == 1){\\n                    formGraph(grid , q ,i , j ,  n ,vis , dx , dy);\\n                    breakEnable = true;\\n                    break;\\n                }\\n            }\\n        }\\n        int minimumSteps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                int[] curr = q.remove();\\n                for(int i = 0 ; i < 4 ; i++){\\n                    int newX = curr[0] + dx[i];\\n                    int newY = curr[1] + dy[i];\\n                    if(isValid(newX,newY,n)){\\n                        if(!vis[newX][newY] && grid[newX ][newY] == 1){\\n                            return minimumSteps;\\n                        }\\n                        else if(!vis[newX][newY] && grid[newX][newY] == 0){\\n                            q.add(new int[]{newX,newY});\\n                            vis[newX][newY] = true;\\n                        }\\n                    } \\n                }\\n            }\\n            minimumSteps++;\\n        }\\n        return -1;\\n    }\\n\\n    public boolean isValid(int i , int j , int n){\\n        if(i < 0 || j<0 || i >=n || j >= n) return false;\\n        return true;\\n    }\\n\\n    public void formGraph(int[][] grid , Queue<int[]> q , int x , int y , int n , boolean[][] vis , int[] dx , int[] dy){\\n        if(!isValid(x,y,n)) return;\\n        if(!vis[x][y] && grid[x][y] == 1){\\n            q.add(new int[] {x,y});\\n        }else{\\n            return;\\n        }\\n        vis[x][y] = true;\\n\\n        for(int i = 0 ; i < 4 ; i++){\\n            int newX = x + dx[i];\\n            int newY = y + dy[i];\\n            formGraph(grid , q, newX,newY,n,vis,dx,dy);\\n        }\\n    }\\n}\\n\\n\\n// class Solution {\\n//     public int shortestBridge(int[][] A) {\\n//         int m = A.length, n = A[0].length;\\n//         boolean[][] visited = new boolean[m][n];\\n//         int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n//         Queue<int[]> q = new LinkedList<>();\\n//         boolean found = false;\\n//         // 1. dfs to find an island, mark it in `visited`\\n//         for (int i = 0; i < m; i++) {\\n//             if (found) {\\n//                 break;\\n//             }\\n//             for (int j = 0; j < n; j++) {\\n//                 if (A[i][j] == 1) {\\n//                     dfs(A, visited, q, i, j, dirs);\\n//                     found = true;\\n//                     break;\\n//                 }\\n//             }\\n//         }\\n//         // 2. bfs to expand this island\\n//         int step = 0;\\n//         while (!q.isEmpty()) {\\n//             int size = q.size();\\n//             while (size-- > 0) {\\n//                 int[] cur = q.poll();\\n//                 for (int[] dir : dirs) {\\n//                     int i = cur[0] + dir[0];\\n//                     int j = cur[1] + dir[1];\\n//                     if (i >= 0 && j >= 0 && i < m && j < n && !visited[i][j]) {\\n//                         if (A[i][j] == 1) {\\n//                             return step;\\n//                         }\\n//                         q.offer(new int[]{i, j});\\n//                         visited[i][j] = true;\\n//                     }\\n//                 }\\n//             }\\n//             step++;\\n//         }\\n//         return -1;\\n//     }\\n//     private void dfs(int[][] A, boolean[][] visited, Queue<int[]> q, int i, int j, int[][] dirs) {\\n//         if (i < 0 || j < 0 || i >= A.length || j >= A[0].length || visited[i][j] || A[i][j] == 0) {\\n//             return;\\n//         }\\n//         visited[i][j] = true;\\n//         q.offer(new int[]{i, j});\\n//         for (int[] dir : dirs) {\\n//             dfs(A, visited, q, i + dir[0], j + dir[1], dirs);\\n//         }\\n//     }\\n// }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835707,
                "title": "c-bfs-easy-understanding",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint shortestBridge(vector<vector<int>>& grid) {\\n\\t\\t\\tvector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n\\t\\t\\tint chk=1;\\n\\t\\t\\tfor(int i=0; i<grid.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<grid[0].size(); j++){\\n\\t\\t\\t\\t\\tif(!v[i][j] && grid[i][j]){\\n\\t\\t\\t\\t\\t\\tv[i][j]=1;\\n\\t\\t\\t\\t\\t\\tqueue<pair<int, int>>q;\\n\\t\\t\\t\\t\\t\\tq.push({i, j});\\n\\t\\t\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\t\\t\\tint x=q.front().first, y=q.front().second;\\n\\t\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\t\\tif(x>0 && !v[x-1][y] && grid[x-1][y]){\\n\\t\\t\\t\\t\\t\\t\\t\\tv[x-1][y]=1;\\n\\t\\t\\t\\t\\t\\t\\t\\tq.push({x-1, y});\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(y>0 && !v[x][y-1] && grid[x][y-1]){\\n\\t\\t\\t\\t\\t\\t\\t\\tv[x][y-1]=1;\\n\\t\\t\\t\\t\\t\\t\\t\\tq.push({x, y-1});\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(x<grid.size()-1 && !v[x+1][y] && grid[x+1][y]){\\n\\t\\t\\t\\t\\t\\t\\t\\tv[x+1][y]=1;\\n\\t\\t\\t\\t\\t\\t\\t\\tq.push({x+1, y});\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(y<grid[0].size()-1 && !v[x][y+1] && grid[x][y+1]){\\n\\t\\t\\t\\t\\t\\t\\t\\tv[x][y+1]=1;\\n\\t\\t\\t\\t\\t\\t\\t\\tq.push({x, y+1});\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tchk=-1; break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(chk==-1){break;}\\n\\t\\t\\t}\\n\\t\\t\\t// for(int i=0; i<grid.size(); i++){\\n\\t\\t\\t//     for(int j=0; j<grid[0].size(); j++){\\n\\t\\t\\t//         cout<<v[i][j]<<\" \";\\n\\t\\t\\t//     }cout<<endl;\\n\\t\\t\\t// }cout<<endl;\\n\\t\\t\\tqueue<pair<pair<int, int>, int>>q;\\n\\t\\t\\tfor(int i=0; i<grid.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<grid[0].size(); j++){\\n\\t\\t\\t\\t\\tif(v[i][j]){\\n\\t\\t\\t\\t\\t\\tq.push({{i, j}, 0});\\n\\t\\t\\t\\t\\t\\t// if(i>0 && !v[i-1][j]){\\n\\t\\t\\t\\t\\t\\t//     q.push({{i, j}, 0});\\n\\t\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t\\t\\t// else if(j>0 && !v[i][j-1]){\\n\\t\\t\\t\\t\\t\\t//     q.push({{i, j}, 0});\\n\\t\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t\\t\\t// else if(i<grid.size()-1 && !v[i+1][j]){\\n\\t\\t\\t\\t\\t\\t//     q.push({{i, j}, 0});\\n\\t\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t\\t\\t// else if(j<grid[0].size()-1 && !v[i][j+1]){\\n\\t\\t\\t\\t\\t\\t//     q.push({{i, j}, 0});\\n\\t\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t\\t\\t// else if(i>0 && j>0 && !v[i-1][j-1]){\\n\\t\\t\\t\\t\\t\\t//     q.push({{i, j}, 0});\\n\\t\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t\\t\\t// else if(i>0 && j<grid[0].size()-1 && !v[i-1][j+1]){\\n\\t\\t\\t\\t\\t\\t//     q.push({{i, j}, 0});\\n\\t\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t\\t\\t// else if(i<grid.size()-1 && j<grid[0].size()-1 && !v[i+1][j+1]){\\n\\t\\t\\t\\t\\t\\t//     q.push({{i, j}, 0});\\n\\t\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t\\t\\t// else if(i<grid.size()-1 && j>0 && !v[i+1][j-1]){\\n\\t\\t\\t\\t\\t\\t//     q.push({{i, j}, 0});\\n\\t\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//cout<<q.size()<<\" \"<<\"chkkkk\"<<endl;\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint x=q.front().first.first, y=q.front().first.second, cnt=q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t//cout<<x<<\" \"<<y<<\" \"<<cnt<<endl;\\n\\t\\t\\t\\tif(x>0 && !v[x-1][y] && !grid[x-1][y]){\\n\\t\\t\\t\\t\\tv[x-1][y]=1;\\n\\t\\t\\t\\t\\tq.push({{x-1, y}, cnt+1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(x>0 && !v[x-1][y] && grid[x-1][y]){\\n\\t\\t\\t\\t\\tans=min(ans, cnt);\\n\\t\\t\\t\\t\\t//cout<<ans<<\" \"<<x-1<<\" \"<<y<<endl;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(y>0 && !v[x][y-1] && !grid[x][y-1]){\\n\\t\\t\\t\\t\\tv[x][y-1]=1;\\n\\t\\t\\t\\t\\tq.push({{x, y-1}, cnt+1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(y>0 && !v[x][y-1] && grid[x][y-1]){\\n\\t\\t\\t\\t\\tans=min(ans, cnt);\\n\\t\\t\\t\\t\\t//cout<<ans<<\" \"<<x<<\" \"<<y-1<<endl;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(x<grid.size()-1 && !v[x+1][y] && !grid[x+1][y]){\\n\\t\\t\\t\\t\\tv[x+1][y]=1;\\n\\t\\t\\t\\t\\tq.push({{x+1, y}, cnt+1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(x<grid.size()-1 && !v[x+1][y] && grid[x+1][y]){\\n\\t\\t\\t\\t\\tans=min(ans, cnt);\\n\\t\\t\\t\\t\\t//cout<<ans<<\" \"<<x+1<<\" \"<<y<<endl;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(y<grid[0].size()-1 && !v[x][y+1] && !grid[x][y+1]){\\n\\t\\t\\t\\t\\tv[x][y+1]=1;\\n\\t\\t\\t\\t\\tq.push({{x, y+1}, cnt+1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(y<grid[0].size()-1 && !v[x][y+1] && grid[x][y+1]){\\n\\t\\t\\t\\t\\tans=min(ans, cnt);\\n\\t\\t\\t\\t\\t//cout<<ans<<\" \"<<x<<\" \"<<y+1<<endl;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if(x>0 && y>0 && !v[x-1][y-1] && !grid[x-1][y-1]){\\n\\t\\t\\t\\t//     v[x-1][y-1]=1;\\n\\t\\t\\t\\t//     q.push({{x-1, y-1}, cnt+1});\\n\\t\\t\\t\\t// }\\n\\t\\t\\t\\t// else if(x>0 && y>0 && !v[x-1][y-1] && grid[x-1][y-1]){\\n\\t\\t\\t\\t//     ans=min(ans, cnt+1);\\n\\t\\t\\t\\t//     cout<<ans<<\" \"<<x-1<<\" \"<<y-1<<endl;\\n\\t\\t\\t\\t// }\\n\\t\\t\\t\\t// if(x>0 && y<grid[0].size()-1 && !v[x-1][y+1] && !grid[x-1][y+1]){\\n\\t\\t\\t\\t//     v[x-1][y+1]=1;\\n\\t\\t\\t\\t//     q.push({{x-1, y+1}, cnt+1});\\n\\t\\t\\t\\t// }\\n\\t\\t\\t\\t// else if(x>0 && y<grid[0].size()-1 && !v[x-1][y+1] && grid[x-1][y+1]){\\n\\t\\t\\t\\t//     ans=min(ans, cnt+1);\\n\\t\\t\\t\\t//     cout<<ans<<\" \"<<x-1<<\" \"<<y-1<<endl;\\n\\t\\t\\t\\t// }\\n\\t\\t\\t\\t// if(x<grid.size()-1 && y<grid[0].size()-1 && !v[x+1][y+1] && !grid[x+1][y+1]){\\n\\t\\t\\t\\t//     v[x+1][y+1]=1;\\n\\t\\t\\t\\t//     q.push({{x+1, y+1}, cnt+1});\\n\\t\\t\\t\\t// }\\n\\t\\t\\t\\t// else if(x<grid.size()-1 && y<grid[0].size()-1 && !v[x+1][y+1] && grid[x+1][y+1]){\\n\\t\\t\\t\\t//     ans=min(ans, cnt+1);\\n\\t\\t\\t\\t//     cout<<ans<<\" \"<<x+1<<\" \"<<y+1<<endl;\\n\\t\\t\\t\\t// }\\n\\t\\t\\t\\t// if(x<grid.size()-1 && y>0 && !v[x+1][y-1] && !grid[x+1][y-1]){\\n\\t\\t\\t\\t//     v[x+1][y-1]=1;\\n\\t\\t\\t\\t//     q.push({{x+1, y-1}, cnt+1});\\n\\t\\t\\t\\t// }\\n\\t\\t\\t\\t// else if(x<grid.size()-1 && y>0 && !v[x+1][y-1] && grid[x+1][y-1]){\\n\\t\\t\\t\\t//     ans=min(ans, cnt+1);\\n\\t\\t\\t\\t//     cout<<ans<<\" \"<<x+1<<\" \"<<y-1<<endl;\\n\\t\\t\\t\\t// }\\n\\t\\t\\t}\\n\\t\\t\\t// for(int i=0; i<grid.size(); i++){\\n\\t\\t\\t//     for(int j=0; j<grid[0].size(); j++){\\n\\t\\t\\t//         cout<<v[i][j]<<\" \";\\n\\t\\t\\t//     }cout<<endl;\\n\\t\\t\\t// }\\n\\t\\t\\t// cout<<endl;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint shortestBridge(vector<vector<int>>& grid) {\\n\\t\\t\\tvector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n\\t\\t\\tint chk=1;\\n\\t\\t\\tfor(int i=0; i<grid.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<grid[0].size(); j++){\\n\\t\\t\\t\\t\\tif(!v[i][j] && grid[i][j]){\\n\\t\\t\\t\\t\\t\\tv[i][j]=1;\\n\\t\\t\\t\\t\\t\\tqueue<pair<int, int>>q;\\n\\t\\t\\t\\t\\t\\tq.push({i, j}",
                "codeTag": "Java"
            },
            {
                "id": 2721678,
                "title": "934-shortest-bridge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought we can run make a visited 2D array and make it true for either island and then run multisource bfs until we reach the second island. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Make a 2d Visited array and make it true for either island.\\n2. Run MultiSource BFS until you reach second island.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2) N is size of graph\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fillQueue(queue<pair<int,int>>&helper, vector<vector<int>>& grid , int i, int j, int n, vector<vector<bool>>&visited){\\n        \\n        visited[i][j]=true;\\n        helper.push({i,j});\\n\\n        while(!helper.empty()){\\n            pair<int,int>front=helper.front();\\n            helper.pop();\\n            int x=front.first;\\n            int y=front.second;\\n\\n            if(x+1<n && visited[x+1][y]==false && grid[x+1][y]==1){\\n                helper.push({x+1,y});\\n                visited[x+1][y]=true;\\n            }\\n\\n            if(x-1>=0 && visited[x-1][y]==false && grid[x-1][y]==1){\\n                helper.push({x-1,y});\\n                visited[x-1][y]=true;\\n            }\\n            if(y+1<n && visited[x][y+1]==false && grid[x][y+1]==1){\\n                helper.push({x,y+1});\\n                visited[x][y+1]=true;\\n            }\\n            if(y-1>=0 && visited[x][y-1]==false && grid[x][y-1]==1){\\n                helper.push({x,y-1});\\n                visited[x][y-1]=true;\\n            }\\n            \\n        }\\n        return ;\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n       \\n        queue<pair<int,int>>pq;\\n\\n        int n=grid.size();\\n         vector<vector<bool>>visited(n,vector<bool>(n,false));\\n         bool flag=false;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1 && flag==false){\\n                    fillQueue(pq,grid,i,j,n,visited);\\n                    flag=true;\\n                   // cout<<\"yes\";\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(visited[i][j]==true){\\n                    pq.push({i,j});\\n                   \\n                }\\n            }\\n        }\\n\\n        int ans=0;\\n\\n        while(!pq.empty()){\\n\\n            int size=pq.size();\\n            while(size--){\\n                pair<int,int> front=pq.front();\\n                int x=front.first;\\n                int y=front.second;\\n                pq.pop();\\n\\n\\n                if(x+1<n && visited[x+1][y]==false){\\n                    if(grid[x+1][y]==1){\\n                        return ans;\\n                    }\\n                    else{\\n                        pq.push({x+1,y});\\n                        visited[x+1][y]=true;\\n                    }\\n                }\\n\\n                if(x-1>=0 && visited[x-1][y]==false){\\n                    if(grid[x-1][y]==1){\\n                        return ans;\\n                    }\\n                    else{\\n                        pq.push({x-1,y});\\n                        visited[x-1][y]=true;\\n                    }\\n                }\\n\\n                if(y+1<n && visited[x][y+1]==false){\\n                    if(grid[x][y+1]==1){\\n                        return ans;\\n                    }\\n                    else{\\n                        pq.push({x,y+1});\\n                        visited[x][y+1]=true;\\n                    }\\n                }\\n\\n                if(y-1>=0 && visited[x][y-1]==false){\\n                    if(grid[x][y-1]==1){\\n                        return ans;\\n                    }\\n                    else{\\n                        pq.push({x,y-1});\\n                        visited[x][y-1]=true;\\n                    }\\n                }\\n\\n            }\\n            ans++;\\n\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fillQueue(queue<pair<int,int>>&helper, vector<vector<int>>& grid , int i, int j, int n, vector<vector<bool>>&visited){\\n        \\n        visited[i][j]=true;\\n        helper.push({i,j});\\n\\n        while(!helper.empty()){\\n            pair<int,int>front=helper.front();\\n            helper.pop();\\n            int x=front.first;\\n            int y=front.second;\\n\\n            if(x+1<n && visited[x+1][y]==false && grid[x+1][y]==1){\\n                helper.push({x+1,y});\\n                visited[x+1][y]=true;\\n            }\\n\\n            if(x-1>=0 && visited[x-1][y]==false && grid[x-1][y]==1){\\n                helper.push({x-1,y});\\n                visited[x-1][y]=true;\\n            }\\n            if(y+1<n && visited[x][y+1]==false && grid[x][y+1]==1){\\n                helper.push({x,y+1});\\n                visited[x][y+1]=true;\\n            }\\n            if(y-1>=0 && visited[x][y-1]==false && grid[x][y-1]==1){\\n                helper.push({x,y-1});\\n                visited[x][y-1]=true;\\n            }\\n            \\n        }\\n        return ;\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n       \\n        queue<pair<int,int>>pq;\\n\\n        int n=grid.size();\\n         vector<vector<bool>>visited(n,vector<bool>(n,false));\\n         bool flag=false;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1 && flag==false){\\n                    fillQueue(pq,grid,i,j,n,visited);\\n                    flag=true;\\n                   // cout<<\"yes\";\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(visited[i][j]==true){\\n                    pq.push({i,j});\\n                   \\n                }\\n            }\\n        }\\n\\n        int ans=0;\\n\\n        while(!pq.empty()){\\n\\n            int size=pq.size();\\n            while(size--){\\n                pair<int,int> front=pq.front();\\n                int x=front.first;\\n                int y=front.second;\\n                pq.pop();\\n\\n\\n                if(x+1<n && visited[x+1][y]==false){\\n                    if(grid[x+1][y]==1){\\n                        return ans;\\n                    }\\n                    else{\\n                        pq.push({x+1,y});\\n                        visited[x+1][y]=true;\\n                    }\\n                }\\n\\n                if(x-1>=0 && visited[x-1][y]==false){\\n                    if(grid[x-1][y]==1){\\n                        return ans;\\n                    }\\n                    else{\\n                        pq.push({x-1,y});\\n                        visited[x-1][y]=true;\\n                    }\\n                }\\n\\n                if(y+1<n && visited[x][y+1]==false){\\n                    if(grid[x][y+1]==1){\\n                        return ans;\\n                    }\\n                    else{\\n                        pq.push({x,y+1});\\n                        visited[x][y+1]=true;\\n                    }\\n                }\\n\\n                if(y-1>=0 && visited[x][y-1]==false){\\n                    if(grid[x][y-1]==1){\\n                        return ans;\\n                    }\\n                    else{\\n                        pq.push({x,y-1});\\n                        visited[x][y-1]=true;\\n                    }\\n                }\\n\\n            }\\n            ans++;\\n\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2713875,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def dfs(self,x,y,m,n,grid,visited,lst):\\n        visited[x][y]=1\\n        lst.append([x,y,0])\\n        row=[-1,1,0,0]\\n        col=[0,0,-1,1]\\n        for i in range(4):\\n            if x+row[i]>=0 and x+row[i]<m and y+col[i]>=0 and y+col[i]<n and visited[x+row[i]][y+col[i]]==-1 and grid[x+row[i]][y+col[i]]==1:\\n                self.dfs(x+row[i],y+col[i],m,n,grid,visited,lst)\\n        \\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        visited=[[-1]*n for i in range(m)]\\n        lst=[]\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j]==-1 and grid[i][j]==1:\\n                    self.dfs(i,j,m,n,grid,visited,lst)\\n                    break\\n            else:\\n                continue\\n            break\\n        mn=float(\"infinity\")\\n        while lst:\\n            x,y,d=lst.pop(0)\\n            row=[-1,1,0,0]\\n            col=[0,0,-1,1]\\n            for i in range(4):\\n                if x+row[i]>=0 and x+row[i]<m and y+col[i]>=0 and y+col[i]<n and visited[x+row[i]][y+col[i]]==-1:\\n                    if grid[x+row[i]][y+col[i]]==1:\\n                        mn=min(mn,d)\\n                    else:\\n                        lst.append([x+row[i],y+col[i],d+1])\\n                        visited[x+row[i]][y+col[i]]=1\\n        return mn\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self,x,y,m,n,grid,visited,lst):\\n        visited[x][y]=1\\n        lst.append([x,y,0])\\n        row=[-1,1,0,0]\\n        col=[0,0,-1,1]\\n        for i in range(4):\\n            if x+row[i]>=0 and x+row[i]<m and y+col[i]>=0 and y+col[i]<n and visited[x+row[i]][y+col[i]]==-1 and grid[x+row[i]][y+col[i]]==1:\\n                self.dfs(x+row[i],y+col[i],m,n,grid,visited,lst)\\n        \\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        visited=[[-1]*n for i in range(m)]\\n        lst=[]\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j]==-1 and grid[i][j]==1:\\n                    self.dfs(i,j,m,n,grid,visited,lst)\\n                    break\\n            else:\\n                continue\\n            break\\n        mn=float(\"infinity\")\\n        while lst:\\n            x,y,d=lst.pop(0)\\n            row=[-1,1,0,0]\\n            col=[0,0,-1,1]\\n            for i in range(4):\\n                if x+row[i]>=0 and x+row[i]<m and y+col[i]>=0 and y+col[i]<n and visited[x+row[i]][y+col[i]]==-1:\\n                    if grid[x+row[i]][y+col[i]]==1:\\n                        mn=min(mn,d)\\n                    else:\\n                        lst.append([x+row[i],y+col[i],d+1])\\n                        visited[x+row[i]][y+col[i]]=1\\n        return mn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548690,
                "title": "c-dfs-bfs-with-explaination-fully-commented",
                "content": "```\\n// LOGIC:\\n    // 1) USING DFS MARK THE FIRST ISLAND VISITED AND STORE THEIR COORDINATES\\n    // 2) RUN BFS LEVEL BY LEVEL ANF LOOK FOR THE 1ST 1 OF 2ND ISLAND \\n    // 3) IF 1 OF 2ND ISLAND FOUND THEN RETURN THE CURRENT LVL ELSE MARK IT VISITED AND          ADD THE COORDINATES AS NEXT LEVEL CELLS\\n    \\n    void dfs(vector<vector<int>>& g,int i,int j ,int n,int m,queue<pair<int,int>>&q)\\n    {\\n        //if we go out of bounds then return\\n        if(i<0||j<0||i==n||j==m||g[i][j]==0||g[i][j]==-1)\\n            return;\\n        //add the coordinates of 1 in queue\\n        q.push({i,j});\\n        //mark it visited\\n        g[i][j]=-1;\\n        //go to all 4 directions and do the same\\n        dfs(g,i-1,j,n,m,q);\\n        dfs(g,i+1,j,n,m,q);\\n        dfs(g,i,j-1,n,m,q);\\n        dfs(g,i,j+1,n,m,q);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& g) {\\n        int n=g.size(),m=g[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            //this will help us break from outer loop\\n            bool f=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(g[i][j]==1)\\n                {\\n                    //if we got our first 1 then call dfs and store indexes of the island and leave the loops\\n                    dfs(g,i,j,n,m,q);\\n                    f=true;\\n                    break;\\n                }\\n            }\\n             if(f)\\n              break;\\n        }\\n        //this will store the distance\\n        int depth=0;\\n        \\n        while(!q.empty())\\n        {\\n        //travel level by level .. we get the ith level by size of the queue at that time\\n            int s=q.size();\\n            //traverse the cells in this level\\n            for(int i=0;i<s;i++)\\n            {\\n                //get the ith and jth of current cell\\n                int curr_i=q.front().first;\\n                int curr_j=q.front().second;\\n                q.pop();\\n                //these are the coordinates of 4 directions\\n                vector<pair<int,int>>dir={{0,1},{1,0},{-1,0},{0,-1}};\\n                //one by one add these directions to our current indexes\\n                for(auto x:dir)\\n                {\\n                    int new_i=curr_i+x.first;\\n                    int new_j=curr_j+x.second;\\n                    //if pur new indices are valid\\n                    if(new_i>=0&&new_i<n&&new_j>=0&&new_j<m)\\n                    {\\n                        //if we encounter a 1 then simply return the level at which we are and no need to look for anything further because this will be the first 1 of 2nd island\\n                         if(g[new_i][new_j]==1)\\n                          return depth;\\n                        // else if we get a 0 then mark it visited and add the coordinated to the queue as cells of next lvl \\n                        else if(g[new_i][new_j]==0)\\n                        {\\n                          q.push({new_i,new_j});\\n                          g[new_i][new_j]=-1;\\n                        }\\n                    }\\n                }\\n            }\\n            //once a level is traversed increase the depth/lvl\\n             depth++;\\n        }\\n        // return the lvl/depth at which the above loop stopped\\n        return depth;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n// LOGIC:\\n    // 1) USING DFS MARK THE FIRST ISLAND VISITED AND STORE THEIR COORDINATES\\n    // 2) RUN BFS LEVEL BY LEVEL ANF LOOK FOR THE 1ST 1 OF 2ND ISLAND \\n    // 3) IF 1 OF 2ND ISLAND FOUND THEN RETURN THE CURRENT LVL ELSE MARK IT VISITED AND          ADD THE COORDINATES AS NEXT LEVEL CELLS\\n    \\n    void dfs(vector<vector<int>>& g,int i,int j ,int n,int m,queue<pair<int,int>>&q)\\n    {\\n        //if we go out of bounds then return\\n        if(i<0||j<0||i==n||j==m||g[i][j]==0||g[i][j]==-1)\\n            return;\\n        //add the coordinates of 1 in queue\\n        q.push({i,j});\\n        //mark it visited\\n        g[i][j]=-1;\\n        //go to all 4 directions and do the same\\n        dfs(g,i-1,j,n,m,q);\\n        dfs(g,i+1,j,n,m,q);\\n        dfs(g,i,j-1,n,m,q);\\n        dfs(g,i,j+1,n,m,q);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& g) {\\n        int n=g.size(),m=g[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            //this will help us break from outer loop\\n            bool f=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(g[i][j]==1)\\n                {\\n                    //if we got our first 1 then call dfs and store indexes of the island and leave the loops\\n                    dfs(g,i,j,n,m,q);\\n                    f=true;\\n                    break;\\n                }\\n            }\\n             if(f)\\n              break;\\n        }\\n        //this will store the distance\\n        int depth=0;\\n        \\n        while(!q.empty())\\n        {\\n        //travel level by level .. we get the ith level by size of the queue at that time\\n            int s=q.size();\\n            //traverse the cells in this level\\n            for(int i=0;i<s;i++)\\n            {\\n                //get the ith and jth of current cell\\n                int curr_i=q.front().first;\\n                int curr_j=q.front().second;\\n                q.pop();\\n                //these are the coordinates of 4 directions\\n                vector<pair<int,int>>dir={{0,1},{1,0},{-1,0},{0,-1}};\\n                //one by one add these directions to our current indexes\\n                for(auto x:dir)\\n                {\\n                    int new_i=curr_i+x.first;\\n                    int new_j=curr_j+x.second;\\n                    //if pur new indices are valid\\n                    if(new_i>=0&&new_i<n&&new_j>=0&&new_j<m)\\n                    {\\n                        //if we encounter a 1 then simply return the level at which we are and no need to look for anything further because this will be the first 1 of 2nd island\\n                         if(g[new_i][new_j]==1)\\n                          return depth;\\n                        // else if we get a 0 then mark it visited and add the coordinated to the queue as cells of next lvl \\n                        else if(g[new_i][new_j]==0)\\n                        {\\n                          q.push({new_i,new_j});\\n                          g[new_i][new_j]=-1;\\n                        }\\n                    }\\n                }\\n            }\\n            //once a level is traversed increase the depth/lvl\\n             depth++;\\n        }\\n        // return the lvl/depth at which the above loop stopped\\n        return depth;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2449637,
                "title": "bfs-dfs-solution-island-expansion-c",
                "content": "```\\nclass Solution {\\n    private:\\n    void dfs(int i, int j, vector<vector<int>>& grid, queue<pair<int, int> > &q){\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        if (i < 0 || j < 0 || i >= rows || j >= cols || grid[i][j] != 1){\\n            return;\\n        }\\n        \\n        grid[i][j] = 2;\\n        q.push({i, j});\\n        dfs(i+1, j, grid, q);\\n        dfs(i-1, j, grid, q);\\n        dfs(i, j+1, grid, q);\\n        dfs(i, j-1, grid, q);\\n    }\\npublic:\\n    \\n    int dir[4][2] = {{0,1}, {1,0}, {-1, 0}, {0, -1}};\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        bool flag = false;\\n        \\n        queue<pair<int, int> >q;\\n        \\n        for (int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                if (grid[i][j] == 1 and !flag){\\n                    dfs(i, j, grid, q);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag){\\n                break;\\n            }\\n        }\\n        int ans= 0;\\n        while(!q.empty()){\\n            int Qsize = q.size();\\n            ans++;\\n            \\n            while(Qsize--){\\n                auto node = q.front();\\n                q.pop();\\n                int x = node.first;\\n                int y = node.second;\\n                \\n                for (auto it: dir){\\n                    int newX = x + it[0];\\n                    int newY = y + it[1];\\n                    \\n                    if (newX >= 0 && newY >= 0 && newX < rows && newY < cols){\\n                        if (grid[newX][newY] == 1){\\n                            return ans - 1;\\n                        }else if (grid[newX][newY] == 0) {\\n                            q.push({newX, newY});\\n                            grid[newX][newY] = 2;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private:\\n    void dfs(int i, int j, vector<vector<int>>& grid, queue<pair<int, int> > &q){\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        if (i < 0 || j < 0 || i >= rows || j >= cols || grid[i][j] != 1){\\n            return;\\n        }\\n        \\n        grid[i][j] = 2;\\n        q.push({i, j});\\n        dfs(i+1, j, grid, q);\\n        dfs(i-1, j, grid, q);\\n        dfs(i, j+1, grid, q);\\n        dfs(i, j-1, grid, q);\\n    }\\npublic:\\n    \\n    int dir[4][2] = {{0,1}, {1,0}, {-1, 0}, {0, -1}};\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        bool flag = false;\\n        \\n        queue<pair<int, int> >q;\\n        \\n        for (int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                if (grid[i][j] == 1 and !flag){\\n                    dfs(i, j, grid, q);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag){\\n                break;\\n            }\\n        }\\n        int ans= 0;\\n        while(!q.empty()){\\n            int Qsize = q.size();\\n            ans++;\\n            \\n            while(Qsize--){\\n                auto node = q.front();\\n                q.pop();\\n                int x = node.first;\\n                int y = node.second;\\n                \\n                for (auto it: dir){\\n                    int newX = x + it[0];\\n                    int newY = y + it[1];\\n                    \\n                    if (newX >= 0 && newY >= 0 && newX < rows && newY < cols){\\n                        if (grid[newX][newY] == 1){\\n                            return ans - 1;\\n                        }else if (grid[newX][newY] == 0) {\\n                            q.push({newX, newY});\\n                            grid[newX][newY] = 2;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393774,
                "title": "c-easy-dfs",
                "content": "\\tclass Solution {\\n\\tprivate:\\n\\t\\tvoid dfs(int i,int j,int row,int col,vector<vector<int>> &grid,vector<pair<int,int>> &p){\\n\\t\\t\\tif( i < 0 || j < 0 || i >= row || j >= col || grid[i][j] == 0) return;\\n\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\tp.push_back({i,j});\\n\\n\\t\\t\\tdfs(i+1,j,row,col,grid,p);\\n\\t\\t\\tdfs(i-1,j,row,col,grid,p);\\n\\t\\t\\tdfs(i,j+1,row,col,grid,p);\\n\\t\\t\\tdfs(i,j-1,row,col,grid,p);\\n\\n\\t\\t}\\n\\tpublic:\\n\\t\\tint shortestBridge(vector<vector<int>>& grid) {\\n\\n\\t\\t\\tint row = grid.size();\\n\\t\\t\\tif(row == 0) return 0;\\n\\t\\t\\tint col = grid[0].size();\\n\\n\\t\\t\\t// storing all cordinate of both island\\n\\t\\t\\tvector<pair<int,int>> x,y;\\n\\n\\t\\t\\t// use flag here because true for 1 island and storing cordinate in x and false for 2nd insland and storing in y \\n\\t\\t\\tbool flag = true;\\n\\t\\t\\tfor(int i = 0; i < row; i++){\\n\\t\\t\\t\\tfor(int j = 0; j < col; j++){\\n\\t\\t\\t\\t\\tif(grid[i][j] == 1){\\n\\t\\t\\t\\t\\t\\tif(flag){\\n\\t\\t\\t\\t\\t\\t\\tdfs(i,j,row,col,grid,x);\\n\\t\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\t}else dfs(i,j,row,col,grid,y);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint sz = x.size();\\n\\t\\t\\tint sz1 = y.size();\\n\\n\\t\\t\\tint ans = INT_MAX;\\n\\n\\t\\t\\t// getting minimum distance between x and y  cordinate and that\\'s the answer\\n\\t\\t\\tfor(int i = 0; i < sz; i++){\\n\\t\\t\\t\\tfor(int j = 0; j < sz1; j++){\\n\\t\\t\\t\\t\\tint dis = abs(x[i].first - y[j].first) + abs(x[i].second - y[j].second) - 1;\\n\\t\\t\\t\\t\\tans = min(ans,dis);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tprivate:\\n\\t\\tvoid dfs(int i,int j,int row,int col,vector<vector<int>> &grid,vector<pair<int,int>> &p){\\n\\t\\t\\tif( i < 0 || j < 0 || i >= row || j >= col || grid[i][j] == 0) return;\\n\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\tp.push_back({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 2311053,
                "title": "python-dfs-bfs-solution-with-full-explanation",
                "content": "# Explanation\\nTo tell the 2 islands different each other, we mark the first island with `2`\\'s using DFS. After that, we use BFS to flip zeroes. BFS is a classic method of finding shortest path (due to the frontier it holds). We maintain a queue, and during our DFS, we also append the current cell to the queue. In the BFS, we go through each of the directions and if the current cell is 0, we mark it with 3. If it\\'s 1, (we\\'ve reached the second island), we return our count. \\n\\n```py\\nclass Solution(object):\\n    def shortestBridge(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)  \\n        q = collections.deque()  \\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        # DFS\\n        def dfs(r, c):\\n            grid[r][c] = 2\\n            q.appendleft((r, c))\\n            for dr, dc in dirs:\\n                nr = r + dr\\n                nc = c + dc\\n                if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 1:\\n                    dfs(nr, nc)\\n\\n        # get the first cell of value 1\\n        for r in range(n):\\n            for c in range(n):\\n                if grid[r][c] == 1:\\n                    startr, startc = r, c\\n\\n        \\n        dfs(startr, startc)  # DFS\\n        res = 0\\n\\n        # BFS to flip 0s\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                r, c = q.pop()\\n                for dr, dc in dirs:\\n                    nr = r + dr\\n                    nc = c + dc\\n                    if 0 <= nr < n and 0 <= nc < n:\\n                        if not grid[nr][nc]:\\n                            grid[nr][nc] = 3\\n                            q.appendleft((nr, nc))\\n                        elif grid[nr][nc] == 1:\\n                            return res\\n            res += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```py\\nclass Solution(object):\\n    def shortestBridge(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)  \\n        q = collections.deque()  \\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        # DFS\\n        def dfs(r, c):\\n            grid[r][c] = 2\\n            q.appendleft((r, c))\\n            for dr, dc in dirs:\\n                nr = r + dr\\n                nc = c + dc\\n                if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 1:\\n                    dfs(nr, nc)\\n\\n        # get the first cell of value 1\\n        for r in range(n):\\n            for c in range(n):\\n                if grid[r][c] == 1:\\n                    startr, startc = r, c\\n\\n        \\n        dfs(startr, startc)  # DFS\\n        res = 0\\n\\n        # BFS to flip 0s\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                r, c = q.pop()\\n                for dr, dc in dirs:\\n                    nr = r + dr\\n                    nc = c + dc\\n                    if 0 <= nr < n and 0 <= nc < n:\\n                        if not grid[nr][nc]:\\n                            grid[nr][nc] = 3\\n                            q.appendleft((nr, nc))\\n                        elif grid[nr][nc] == 1:\\n                            return res\\n            res += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301443,
                "title": "c-easy-dfs-find-the-island-then-bfs-expand-the-island-and-count-steps",
                "content": "DFS + BFS \\n\\n\\t\\tvoid dfs(int i,int j,vector<vector<int>>& grid,int m,int n,queue<pair<int,int>>&q){\\n        if(i<0 || i>m-1 || j<0 || j>n-1 || grid[i][j]==0 || grid[i][j]==2)\\n             return;\\n        grid[i][j]=2;\\n        q.push({i,j});\\n         dfs(i-1,j,grid,m,n,q);\\n         dfs(i,j-1,grid,m,n,q);\\n         dfs(i,j+1,grid,m,n,q);\\n         dfs(i+1,j,grid,m,n,q);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){   //take one land and mark its adjacent lands using dfs and put them in queue\\n                    dfs(i,j,grid,m,n,q);\\n                    break;\\n                }\\n            }\\n            if(!q.empty())\\n                break;\\n        }\\n        int count=0;\\n        while(!q.empty()){    //expand the marked land using dfs until you get the next land and count the steps\\n            count++;\\n            int k=q.size();\\n            for(int i=0;i<k;i++){\\n                auto it=q.front();\\n                q.pop();\\n                vector<int> dr={-1,0,0,1};\\n                vector<int> dc={0,-1,1,0};\\n                for(int j=0;j<4;j++){\\n                    int x=it.first+dr[j];\\n                    int y=it.second+dc[j];\\n                    if(x>=0 && x<m && y>=0 && y<n && (grid[x][y]==0 || grid[x][y]==1)){\\n                        if(grid[x][y]==0){\\n                            q.push({x,y});\\n                            grid[x][y]=2;\\n                        }else{\\n                            return count-1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "DFS + BFS \\n\\n\\t\\tvoid dfs(int i,int j,vector<vector<int>>& grid,int m,int n,queue<pair<int,int>>&q){\\n        if(i<0 || i>m-1 || j<0 || j>n-1 || grid[i][j]==0 || grid[i][j]==2)\\n             return;\\n        grid[i][j]=2;\\n        q.push({i,j});\\n         dfs(i-1,j,grid,m,n,q);\\n         dfs(i,j-1,grid,m,n,q);\\n         dfs(i,j+1,grid,m,n,q);\\n         dfs(i+1,j,grid,m,n,q);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){   //take one land and mark its adjacent lands using dfs and put them in queue\\n                    dfs(i,j,grid,m,n,q);\\n                    break;\\n                }\\n            }\\n            if(!q.empty())\\n                break;\\n        }\\n        int count=0;\\n        while(!q.empty()){    //expand the marked land using dfs until you get the next land and count the steps\\n            count++;\\n            int k=q.size();\\n            for(int i=0;i<k;i++){\\n                auto it=q.front();\\n                q.pop();\\n                vector<int> dr={-1,0,0,1};\\n                vector<int> dc={0,-1,1,0};\\n                for(int j=0;j<4;j++){\\n                    int x=it.first+dr[j];\\n                    int y=it.second+dc[j];\\n                    if(x>=0 && x<m && y>=0 && y<n && (grid[x][y]==0 || grid[x][y]==1)){\\n                        if(grid[x][y]==0){\\n                            q.push({x,y});\\n                            grid[x][y]=2;\\n                        }else{\\n                            return count-1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2286355,
                "title": "dfs-to-get-island1-and-bfs-to-get-the-steps-similar-to-rotten-oranges",
                "content": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        n, result, queue = len(grid), 0, []\\n        \\n        def dfs(i,j):\\n            queue.append((i,j))\\n            grid[i][j] = -1\\n            for x,y in [(0,-1), (0,1), (-1, 0), (1,0)]:\\n                xi,yj = x+i,y+j\\n                if 0<=xi< n and 0<=yj< n and grid[xi][yj] == 1:\\n                    dfs(xi, yj)\\n        \\n        found = False\\n        for i in range(n):\\n            if found:\\n                break\\n            j = 0\\n            while not found and j<n:\\n                if grid[i][j] == 1:\\n                    dfs(i,j)\\n                    found = True\\n                    break\\n                j+=1\\n        \\n        \\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                i,j = queue.pop(0)\\n                for x,y in [(0,-1), (0,1), (-1, 0), (1,0)]:\\n                    xi,yj = x+i,y+j\\n                    if 0<=xi<n and 0<=yj<n and grid[xi][yj] != -1:\\n                        if grid[xi][yj] == 1:\\n                            return result\\n                        elif grid[xi][yj] == 0:\\n                            queue.append((xi,yj))\\n                            grid[xi][yj] = -1\\n            result+=1\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        n, result, queue = len(grid), 0, []\\n        \\n        def dfs(i,j):\\n            queue.append((i,j))\\n            grid[i][j] = -1\\n            for x,y in [(0,-1), (0,1), (-1, 0), (1,0)]:\\n                xi,yj = x+i,y+j\\n                if 0<=xi< n and 0<=yj< n and grid[xi][yj] == 1:\\n                    dfs(xi, yj)\\n        \\n        found = False\\n        for i in range(n):\\n            if found:\\n                break\\n            j = 0\\n            while not found and j<n:\\n                if grid[i][j] == 1:\\n                    dfs(i,j)\\n                    found = True\\n                    break\\n                j+=1\\n        \\n        \\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                i,j = queue.pop(0)\\n                for x,y in [(0,-1), (0,1), (-1, 0), (1,0)]:\\n                    xi,yj = x+i,y+j\\n                    if 0<=xi<n and 0<=yj<n and grid[xi][yj] != -1:\\n                        if grid[xi][yj] == 1:\\n                            return result\\n                        elif grid[xi][yj] == 0:\\n                            queue.append((xi,yj))\\n                            grid[xi][yj] = -1\\n            result+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281502,
                "title": "c-bfs-dfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int x,int y,vector<vector<int>>& grid,int dx[],int dy[]){\\n        grid[x][y]=2;\\n        for(int i=0;i<4;i++){\\n            int nx=x+dx[i];\\n            int ny=y+dy[i];\\n            if(nx<0 || ny<0 || nx>=grid.size() || ny>=grid[0].size() || grid[nx][ny]==0 || grid[nx][ny]==2) continue;\\n            dfs(nx,ny,grid,dx,dy);\\n        }\\n    }\\n    void colour(vector<vector<int>>& grid,int dx[],int dy[]){\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    dfs(i,j,grid,dx,dy);\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int dx[4]={0,0,1,-1};\\n        int dy[4]={1,-1,0,0};\\n        \\n        //coloured one island\\n        colour(grid,dx,dy);\\n\\n    \\n        // BFS traversal to find distance\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==2) q.push({i,j});\\n            }\\n        }\\n        int dis=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                // cout<<x<<\" \"<<y<<endl;\\n                for(int j=0;j<4;j++){\\n                    int nx=x+dx[j];\\n                    int ny=y+dy[j];\\n                    if(nx<0 || ny<0 || nx>=grid.size() || ny>=grid[0].size()) continue; \\n                    \\n                    if(grid[nx][ny]==1){\\n                        return dis;\\n                    }\\n                    if(grid[nx][ny]>=2) continue;\\n               \\n                    q.push({nx,ny});\\n                    grid[nx][ny]=1+grid[x][y];\\n                }\\n            }\\n            dis++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int x,int y,vector<vector<int>>& grid,int dx[],int dy[]){\\n        grid[x][y]=2;\\n        for(int i=0;i<4;i++){\\n            int nx=x+dx[i];\\n            int ny=y+dy[i];\\n            if(nx<0 || ny<0 || nx>=grid.size() || ny>=grid[0].size() || grid[nx][ny]==0 || grid[nx][ny]==2) continue;\\n            dfs(nx,ny,grid,dx,dy);\\n        }\\n    }\\n    void colour(vector<vector<int>>& grid,int dx[],int dy[]){\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    dfs(i,j,grid,dx,dy);\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int dx[4]={0,0,1,-1};\\n        int dy[4]={1,-1,0,0};\\n        \\n        //coloured one island\\n        colour(grid,dx,dy);\\n\\n    \\n        // BFS traversal to find distance\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==2) q.push({i,j});\\n            }\\n        }\\n        int dis=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                // cout<<x<<\" \"<<y<<endl;\\n                for(int j=0;j<4;j++){\\n                    int nx=x+dx[j];\\n                    int ny=y+dy[j];\\n                    if(nx<0 || ny<0 || nx>=grid.size() || ny>=grid[0].size()) continue; \\n                    \\n                    if(grid[nx][ny]==1){\\n                        return dis;\\n                    }\\n                    if(grid[nx][ny]>=2) continue;\\n               \\n                    q.push({nx,ny});\\n                    grid[nx][ny]=1+grid[x][y];\\n                }\\n            }\\n            dis++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2260402,
                "title": "python-split-island-method-logic-explained-explanation-and-comments",
                "content": "**Disclaimer: The best way to understand this logic is to copy paste my code and uncomment the portion that i have given. The Output on the console will be enough for you to understand. This post is just the walk through of my logic.**\\n\\nThe logic that I have used is that 1st I have created a dfs function which allows me to mark only **one ISLAND**. So, all of the 1\\'s of this island are changed to 2. \\nNow after this step in the entire grid the only elements are 0,1,2. \\nThe task is to find the distance between 2 and 1 which are nearest to each other.\\n\\nSo, for this what i did next is that while making the island i stored the entire address of the island cells in i1 array and kept the distance factor 0. Now i pop the 0th index element and search in 4 directions.\\n\\n........The possibilities are:-\\n\\n.........................1. The index doesn\\'t exist-->that case is tackled\\n\\n.........................2. if the index does exist, it could either be 0,1,2.\\n...................................a.If it is 1 then that is our answer\\n...................................b.If it is 2 that means the current cell is actually somewhere inside the island and from this cell the distance will never be shortest hence we disregard this.\\n...................................c.If it is 0 then we are somewhere between both the islands, so to avoid        comming to this square ever again we mark this as 2 and append this cell to the i1 array but in the distance part we add 1 as this is our distance that we need to travel. \\n\\n.........................3. This repeats and whn we finally find 1 we have the distance to that cell in the distance variable, d.\\n\\nIf you still have doubts then pls ask in the comment section and If you like the explanation and the code **pls upvote!** as that will encourage me to do more such posts.\\n\\n```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        \\n        #to print the grid current state\\n        #def printgrid():    \\n            #for i in range(n):\\n                #for j in range(n):\\n                    #print(grid[i][j],end=\" \")\\n                #print()\\n            #print()\\n        \\n        # printgrid()\\n            \\n        i1=[]\\n        #to make a island\\n        def dfs(i,j):\\n            #print(i,j)\\n            if 0<=i<n and 0<=j<n and grid[i][j]==1:\\n                i1.append((i,j,0))\\n                grid[i][j]=2\\n                dfs(i+1,j)\\n                dfs(i-1,j)\\n                dfs(i,j+1)\\n                dfs(i,j-1)\\n                return\\n            return\\n        \\n        #this finds the 1st 1 and we call the dfs and the island is created\\n        #breaker is to make sure that we only run the dfs function once\\n        breaker =False\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    dfs(i,j)\\n                    breaker=True\\n                    break\\n            if breaker:\\n                break\\n                \\n        \\n        # printgrid()\\n        # print(i1)\\n        \\n        dir=[(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        while i1:\\n            i,j,d=i1.pop(0)\\n            # print(f\"i={i} j={j} d={d}\")\\n            #base condition for the case where we find the ans\\n            if grid[i][j]==1:\\n                return d\\n            for dc,dr in dir:\\n                p,q=dr+i,dc+j\\n                if 0<=p<n and 0<=q<n and grid[p][q]!=2:\\n                    if grid[p][q]==1:\\n                        return d\\n                    grid[p][q]=2\\n                    i1.append((p,q,d+1))\\n                    # printgrid()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        \\n        #to print the grid current state\\n        #def printgrid():    \\n            #for i in range(n):\\n                #for j in range(n):\\n                    #print(grid[i][j],end=\" \")\\n                #print()\\n            #print()\\n        \\n        # printgrid()\\n            \\n        i1=[]\\n        #to make a island\\n        def dfs(i,j):\\n            #print(i,j)\\n            if 0<=i<n and 0<=j<n and grid[i][j]==1:\\n                i1.append((i,j,0))\\n                grid[i][j]=2\\n                dfs(i+1,j)\\n                dfs(i-1,j)\\n                dfs(i,j+1)\\n                dfs(i,j-1)\\n                return\\n            return\\n        \\n        #this finds the 1st 1 and we call the dfs and the island is created\\n        #breaker is to make sure that we only run the dfs function once\\n        breaker =False\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    dfs(i,j)\\n                    breaker=True\\n                    break\\n            if breaker:\\n                break\\n                \\n        \\n        # printgrid()\\n        # print(i1)\\n        \\n        dir=[(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        while i1:\\n            i,j,d=i1.pop(0)\\n            # print(f\"i={i} j={j} d={d}\")\\n            #base condition for the case where we find the ans\\n            if grid[i][j]==1:\\n                return d\\n            for dc,dr in dir:\\n                p,q=dr+i,dc+j\\n                if 0<=p<n and 0<=q<n and grid[p][q]!=2:\\n                    if grid[p][q]==1:\\n                        return d\\n                    grid[p][q]=2\\n                    i1.append((p,q,d+1))\\n                    # printgrid()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223146,
                "title": "c-bfs-dfs-fully-explained",
                "content": "The question involves execution of the following steps :\\n\\n1. For the first island, do the DFS traversal and mark all the indexes of first island as -1 which will further help us identify that -1 is part of first island. Keep the second island as it is.\\n2. So, till now, in our grid, -1 means first island, 1 means second island, 0 means water\\n2. Initialize a queue and push all the indexes that are 1 in the queue.\\n3. Do a BFS traversal starting from second island and keep on marking it\\'s adjacent elements which are 0 (water) to 1 (visited). Also keep incrementing the length of bridge by 1 for each push in te queue.\\n4. At last, when we reach at an index whose value is -1 (first island) return the length of the bridge.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int i,int j,vector<vector<int>>& grid,int r,int c)\\n    {\\n        if(i < 0 or j < 0 or i >= r or j >= c or grid[i][j] != 1)\\n            return;\\n            \\n        grid[i][j] = -1;\\n        solve(i+1,j,grid,r,c);\\n        solve(i-1,j,grid,r,c);\\n        solve(i,j-1,grid,r,c);\\n        solve(i,j+1,grid,r,c);\\n    }\\n    \\n    bool isValid (int i, int j, int n, int m, vector<vector<int>>& grid, int prev)\\n    {\\n        if (i<0 || j<0 || i>=n || j>=m || grid[i][j]==1)\\n            return false;\\n        \\n        grid[i][j]==0 ? grid[i][j]=1 : grid[i][j]=-1;\\n        return true;\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        int flag = 0;\\n        \\n        if(row == 0)\\n            return 0;\\n            \\n        for(int i = 0 ; i < row;i++)\\n        {\\n            for(int j = 0; j < col; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    solve(i,j,grid,row,col);\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            \\n            if (flag)\\n                break;\\n        }\\n        \\n        queue<vector<int>>q;\\n        \\n        for(int i = 0 ; i < row;i++)\\n        {\\n            for(int j = 0; j < col; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    q.push({i,j,0});\\n                }\\n            }\\n        }\\n        \\n        while (!q.empty())\\n        {\\n            int x = q.size();\\n            \\n            for (int k=0; k<x; k++)\\n            {\\n                auto it = q.front();\\n                \\n                int i = it[0];\\n                int j = it[1];\\n                int ans = it[2];\\n\\n                q.pop();\\n\\n                if (grid[i][j]==-1)\\n                    return ans-1;\\n                \\n                if (isValid(i+1,j,row,col,grid,grid[i][j]))\\n                    q.push({i+1,j,ans+1});\\n                if (isValid(i-1,j,row,col,grid,grid[i][j]))\\n                    q.push({i-1,j,ans+1});\\n                if (isValid(i,j+1,row,col,grid,grid[i][j]))\\n                    q.push({i,j+1,ans+1});\\n                if (isValid(i,j-1,row,col,grid,grid[i][j]))\\n                    q.push({i,j-1,ans+1});       \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\nFeel free to ask any question in the comment section.\\nI hope that you found the solution useful.\\nIf so, please do upvote and encourage me. \\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(int i,int j,vector<vector<int>>& grid,int r,int c)\\n    {\\n        if(i < 0 or j < 0 or i >= r or j >= c or grid[i][j] != 1)\\n            return;\\n            \\n        grid[i][j] = -1;\\n        solve(i+1,j,grid,r,c);\\n        solve(i-1,j,grid,r,c);\\n        solve(i,j-1,grid,r,c);\\n        solve(i,j+1,grid,r,c);\\n    }\\n    \\n    bool isValid (int i, int j, int n, int m, vector<vector<int>>& grid, int prev)\\n    {\\n        if (i<0 || j<0 || i>=n || j>=m || grid[i][j]==1)\\n            return false;\\n        \\n        grid[i][j]==0 ? grid[i][j]=1 : grid[i][j]=-1;\\n        return true;\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        int flag = 0;\\n        \\n        if(row == 0)\\n            return 0;\\n            \\n        for(int i = 0 ; i < row;i++)\\n        {\\n            for(int j = 0; j < col; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    solve(i,j,grid,row,col);\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            \\n            if (flag)\\n                break;\\n        }\\n        \\n        queue<vector<int>>q;\\n        \\n        for(int i = 0 ; i < row;i++)\\n        {\\n            for(int j = 0; j < col; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    q.push({i,j,0});\\n                }\\n            }\\n        }\\n        \\n        while (!q.empty())\\n        {\\n            int x = q.size();\\n            \\n            for (int k=0; k<x; k++)\\n            {\\n                auto it = q.front();\\n                \\n                int i = it[0];\\n                int j = it[1];\\n                int ans = it[2];\\n\\n                q.pop();\\n\\n                if (grid[i][j]==-1)\\n                    return ans-1;\\n                \\n                if (isValid(i+1,j,row,col,grid,grid[i][j]))\\n                    q.push({i+1,j,ans+1});\\n                if (isValid(i-1,j,row,col,grid,grid[i][j]))\\n                    q.push({i-1,j,ans+1});\\n                if (isValid(i,j+1,row,col,grid,grid[i][j]))\\n                    q.push({i,j+1,ans+1});\\n                if (isValid(i,j-1,row,col,grid,grid[i][j]))\\n                    q.push({i,j-1,ans+1});       \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204043,
                "title": "java-solution-find-one-island-using-dfs-search-other-island-using-bfs",
                "content": "**Approach**\\nThe solution is based on the fact that there are only two island components in the grid.\\n\\n**Step1.  Find Island1**\\nIn the first step, we would run a DFS to find the first island and would mark all the components of that island as visited.  \\nSimulataneously , add all the components of island1 to a queue (It would be used later in Step2) .\\n\\nif(visited[i][j] == 0), it means grid[i][j] is visited and is a component of island1.\\nif(visited[i][j]  == -1), it means grid[i][j] is not visited. It also means that either grid[i][j] == 0 or  it is part of second island.\\n\\n\\n**Step2. Find Shortest Distance From Island1 to Island2**\\nSince, The island 2 can be reached by multiple paths/components of Island1. Thus, to find the shortest distance, we need to run BFS from all the components of island1.\\nQueue<int[]> ue stores the indices of all the components of island1.\\n\\n\\nIn the BFS traversal, go through all the valid neighbours of each component ->\\nif neighbour is 0, i.e grid[i][j] == 0 We still have not reached Island2.  Hence, visited[i][j] = visited[x][y] + 1 .\\nelse if neighbour is 1 ie grid[i][j] == 1, It must be a part of Island2. (We have already traversed all the components of island1).  \\nIt should be the shortest distance between island1 and Island2. Hence, return visited[x][y].\\n\\n*Please feel free to ask any doubts. Also, Please upvote if you find it useful.*\\n\\n\\n\\n\\n```\\nclass Solution {\\n    int[] rows = {-1 , 0 , 1 , 0} ;\\n    int[] cols = {0 , 1 , 0, -1} ;\\n     Queue<int[]> ue = new LinkedList<>() ;\\n    \\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length ;\\n        int[][] visited = new int[n][n] ;\\n        \\n        for(int[] arr : visited)\\n            Arrays.fill(arr , -1) ;\\n        int count = 0 ;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(grid[i][j] == 1 && count == 0){\\n                    dfs(grid , n , i , j , visited) ;\\n                    count ++ ;\\n                }\\n            }\\n        }\\n        \\n        \\n        while(! ue.isEmpty() ){\\n            int[] arr = ue.peek();\\n            ue.poll() ;\\n            \\n            int x = arr[0] ;\\n            int y = arr[1] ;\\n            \\n            for(int k = 0 ; k < 4 ; k++){\\n                int i = x + rows[k] ;\\n                int j = y + cols[k] ;\\n                \\n                if(i >= 0 && j >= 0 && i < n && j < n && visited[i][j] == -1){\\n                    if(grid[i][j] == 1)\\n                        return visited[x][y] ;\\n                    else {\\n                       visited[i][j] = visited[x][y] + 1 ;\\n                        ue.add(new int[]{i , j} );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private void dfs(int[][] grid , int n , int i , int j , int[][] visited){\\n        visited[i][j] = 0 ;\\n        ue.add(new int[]{i , j} );\\n        \\n        for(int k = 0 ; k < 4 ; k++){\\n            int x = i + rows[k] ;\\n            int y = j + cols[k] ;\\n            \\n            if(x >= 0 && y >= 0 && x <n && y < n && grid[x][y] == 1 \\n               && visited[x][y] == -1)\\n                dfs(grid , n , x , y , visited) ;\\n        }\\n        \\n        \\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[] rows = {-1 , 0 , 1 , 0} ;\\n    int[] cols = {0 , 1 , 0, -1} ;\\n     Queue<int[]> ue = new LinkedList<>() ;\\n    \\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length ;\\n        int[][] visited = new int[n][n] ;\\n        \\n        for(int[] arr : visited)\\n            Arrays.fill(arr , -1) ;\\n        int count = 0 ;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(grid[i][j] == 1 && count == 0){\\n                    dfs(grid , n , i , j , visited) ;\\n                    count ++ ;\\n                }\\n            }\\n        }\\n        \\n        \\n        while(! ue.isEmpty() ){\\n            int[] arr = ue.peek();\\n            ue.poll() ;\\n            \\n            int x = arr[0] ;\\n            int y = arr[1] ;\\n            \\n            for(int k = 0 ; k < 4 ; k++){\\n                int i = x + rows[k] ;\\n                int j = y + cols[k] ;\\n                \\n                if(i >= 0 && j >= 0 && i < n && j < n && visited[i][j] == -1){\\n                    if(grid[i][j] == 1)\\n                        return visited[x][y] ;\\n                    else {\\n                       visited[i][j] = visited[x][y] + 1 ;\\n                        ue.add(new int[]{i , j} );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private void dfs(int[][] grid , int n , int i , int j , int[][] visited){\\n        visited[i][j] = 0 ;\\n        ue.add(new int[]{i , j} );\\n        \\n        for(int k = 0 ; k < 4 ; k++){\\n            int x = i + rows[k] ;\\n            int y = j + cols[k] ;\\n            \\n            if(x >= 0 && y >= 0 && x <n && y < n && grid[x][y] == 1 \\n               && visited[x][y] == -1)\\n                dfs(grid , n , x , y , visited) ;\\n        }\\n        \\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198749,
                "title": "c-dfs-solution-o-n-2",
                "content": "Time complexity : O(N^2)\\nSpace complexity : O(N^2)  //worst case\\n```\\n  vector<vector<bool>> visited;\\n    void dfs(vector<vector<int>>& grid,int i,int j,vector<pair<int,int>> &temp)\\n    {\\n        visited[i][j]=true;\\n        temp.push_back({i,j});\\n         if((i+1)<grid.size()&&grid[i+1][j]==1&&!visited[i+1][j])\\n            dfs(grid,i+1,j,temp);\\n         if((j+1)<grid[0].size()&&grid[i][j+1]==1&&!visited[i][j+1])\\n            dfs(grid,i,j+1,temp);\\n        if((i)>0&&grid[i-1][j]==1&&!visited[i-1][j])\\n            dfs(grid,i-1,j,temp);\\n         if(j>0&&grid[i][j-1]==1&&!visited[i][j-1])\\n            dfs(grid,i,j-1,temp);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n= grid.size(),i,j;\\n         for(i=0;i<n;i++)\\n          {\\n             vector<bool> temp(n,false);\\n             visited.push_back(temp);\\n          }\\n                \\n        vector<vector<pair<int,int>>> dist;\\n        for(i=0;i<n;i++)\\n            for(j=0;j<n;j++)\\n                if(!visited[i][j]&&grid[i][j])   //It will be true for 2 case\\n                   {\\n                    vector<pair<int,int>> temp;\\n                    dfs(grid,i,j,temp);\\n                    dist.push_back(temp);  //So we will get the dist vector of size 2\\n                    }\\n      int ans=INT_MAX;  \\n\\t  //Find the minimum distance\\n     for(i=0;i<dist[0].size();i++)\\n         for(j=0;j<dist[1].size();j++)\\n           {\\n             int r=abs((dist[0][i].first-dist[1][j].first));\\n             int l=abs( (dist[0][i].second-dist[1][j].second));\\n             int d= l+ r-1;\\n             ans=min(ans,abs(d));\\n             }\\n      return ans;  \\n    }\\n```\\nKindly upvote this if you found it helpful.",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n  vector<vector<bool>> visited;\\n    void dfs(vector<vector<int>>& grid,int i,int j,vector<pair<int,int>> &temp)\\n    {\\n        visited[i][j]=true;\\n        temp.push_back({i,j});\\n         if((i+1)<grid.size()&&grid[i+1][j]==1&&!visited[i+1][j])\\n            dfs(grid,i+1,j,temp);\\n         if((j+1)<grid[0].size()&&grid[i][j+1]==1&&!visited[i][j+1])\\n            dfs(grid,i,j+1,temp);\\n        if((i)>0&&grid[i-1][j]==1&&!visited[i-1][j])\\n            dfs(grid,i-1,j,temp);\\n         if(j>0&&grid[i][j-1]==1&&!visited[i][j-1])\\n            dfs(grid,i,j-1,temp);\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n= grid.size(),i,j;\\n         for(i=0;i<n;i++)\\n          {\\n             vector<bool> temp(n,false);\\n             visited.push_back(temp);\\n          }\\n                \\n        vector<vector<pair<int,int>>> dist;\\n        for(i=0;i<n;i++)\\n            for(j=0;j<n;j++)\\n                if(!visited[i][j]&&grid[i][j])   //It will be true for 2 case\\n                   {\\n                    vector<pair<int,int>> temp;\\n                    dfs(grid,i,j,temp);\\n                    dist.push_back(temp);  //So we will get the dist vector of size 2\\n                    }\\n      int ans=INT_MAX;  \\n\\t  //Find the minimum distance\\n     for(i=0;i<dist[0].size();i++)\\n         for(j=0;j<dist[1].size();j++)\\n           {\\n             int r=abs((dist[0][i].first-dist[1][j].first));\\n             int l=abs( (dist[0][i].second-dist[1][j].second));\\n             int d= l+ r-1;\\n             ans=min(ans,abs(d));\\n             }\\n      return ans;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2092265,
                "title": "kotlin-85-liner-faster-than-72-22-floodfill-bfs",
                "content": "```\\nclass Solution {\\n    private lateinit var grid: Array<IntArray>\\n    private val connected = Stack<Pair<Int, Int>>()\\n    var n = 0\\n    \\n    fun shortestBridge(grid: Array<IntArray>): Int {\\n        this.grid = grid\\n        this.n = grid.size\\n        \\n        var firstLand = -1 to -1\\n        \\n        for (i in 0 until n) {\\n            for (j in 0 until n) {\\n                if (grid[i][j] == 1) {\\n                    firstLand = i to j\\n                    break\\n                }\\n            }\\n            if (firstLand.first != -1) break\\n        }\\n        floodfill(firstLand.first, firstLand.second, 7)\\n        \\n        val boundary = ArrayDeque<Pair<Int, Int>>()\\n        while (connected.isNotEmpty()) {\\n            val point = connected.pop()\\n            if (isOnBoundary(point)) boundary.add(point)\\n        }\\n        \\n        var result = 0\\n        val already = HashSet<String>()\\n        \\n        while (boundary.isNotEmpty()) {\\n            val size = boundary.size\\n            for (i in 0 until size) {\\n                val position = boundary.poll()\\n                val x = position.first\\n                val y = position.second\\n                if (!already.contains(\"$x,$y\")) {\\n                    if (grid[x][y] == 1) return result - 1\\n                    val possible = listOf(\\n                        x + 1 to y,\\n                        x - 1 to y,\\n                        x to y + 1,\\n                        x to y - 1\\n                    ).filter { possible(it) && grid[it.first][it.second] != 7 }\\n                    boundary.addAll(possible)\\n                    already.add(\"$x,$y\")\\n                }\\n            }\\n            result++\\n        }\\n        \\n        return result\\n    }\\n    \\n    fun floodfill(x: Int, y: Int, color: Int) {\\n        if (grid[x][y] == 0) return\\n        if (grid[x][y] == color) return\\n        \\n        grid[x][y] = color\\n        connected.add(x to y)\\n        \\n        val possible = listOf(x + 1 to y, x - 1 to y, x to y + 1, x to y - 1)\\n        for (i in possible) {\\n            if (possible(i)) floodfill(i.first, i.second, color)\\n        }\\n    }\\n    \\n    fun possible(position: Pair<Int, Int>): Boolean {\\n        return position.first in 0 until n && position.second in 0 until n\\n    }\\n    \\n    fun isOnBoundary(position: Pair<Int, Int>): Boolean {\\n        val x = position.first\\n        val y = position.second\\n        val possible = listOf(\\n            x + 1 to y,\\n            x - 1 to y,\\n            x to y + 1,\\n            x to y - 1\\n        ).filter { possible(it) && grid[it.first][it.second] == 0 }\\n        \\n        return possible.isNotEmpty()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private lateinit var grid: Array<IntArray>\\n    private val connected = Stack<Pair<Int, Int>>()\\n    var n = 0\\n    \\n    fun shortestBridge(grid: Array<IntArray>): Int {\\n        this.grid = grid\\n        this.n = grid.size\\n        \\n        var firstLand = -1 to -1\\n        \\n        for (i in 0 until n) {\\n            for (j in 0 until n) {\\n                if (grid[i][j] == 1) {\\n                    firstLand = i to j\\n                    break\\n                }\\n            }\\n            if (firstLand.first != -1) break\\n        }\\n        floodfill(firstLand.first, firstLand.second, 7)\\n        \\n        val boundary = ArrayDeque<Pair<Int, Int>>()\\n        while (connected.isNotEmpty()) {\\n            val point = connected.pop()\\n            if (isOnBoundary(point)) boundary.add(point)\\n        }\\n        \\n        var result = 0\\n        val already = HashSet<String>()\\n        \\n        while (boundary.isNotEmpty()) {\\n            val size = boundary.size\\n            for (i in 0 until size) {\\n                val position = boundary.poll()\\n                val x = position.first\\n                val y = position.second\\n                if (!already.contains(\"$x,$y\")) {\\n                    if (grid[x][y] == 1) return result - 1\\n                    val possible = listOf(\\n                        x + 1 to y,\\n                        x - 1 to y,\\n                        x to y + 1,\\n                        x to y - 1\\n                    ).filter { possible(it) && grid[it.first][it.second] != 7 }\\n                    boundary.addAll(possible)\\n                    already.add(\"$x,$y\")\\n                }\\n            }\\n            result++\\n        }\\n        \\n        return result\\n    }\\n    \\n    fun floodfill(x: Int, y: Int, color: Int) {\\n        if (grid[x][y] == 0) return\\n        if (grid[x][y] == color) return\\n        \\n        grid[x][y] = color\\n        connected.add(x to y)\\n        \\n        val possible = listOf(x + 1 to y, x - 1 to y, x to y + 1, x to y - 1)\\n        for (i in possible) {\\n            if (possible(i)) floodfill(i.first, i.second, color)\\n        }\\n    }\\n    \\n    fun possible(position: Pair<Int, Int>): Boolean {\\n        return position.first in 0 until n && position.second in 0 until n\\n    }\\n    \\n    fun isOnBoundary(position: Pair<Int, Int>): Boolean {\\n        val x = position.first\\n        val y = position.second\\n        val possible = listOf(\\n            x + 1 to y,\\n            x - 1 to y,\\n            x to y + 1,\\n            x to y - 1\\n        ).filter { possible(it) && grid[it.first][it.second] == 0 }\\n        \\n        return possible.isNotEmpty()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065614,
                "title": "python-bfs-only-process-explained-easy-to-understand",
                "content": "Whenever the questions asks for \"shortest path\" of something, or \"connectivity\" of something, think of BFS first as it\\'s less error-prone than DFS for traversal problems.\\n\\nWe do 3 things here:\\n1. Find all the grid points on the first island, mark them.\\n2. Find all the grid points on the second island, mark them as well.\\n3. From the points on the first island, BFS until we get to the first point on the second island we encounter, that\\'s the shortest path we are looking for.\\n\\nNote that in a real interview, remember to do sanity checks for your inputs! For example in this code we are _assuming_ that the grid is not empty, and there are **always** two and **only** two islands.\\n\\nOther solutions here on the discussion board might involve marking the first island as something else (for example change them to `2`) in the original grid. While it is clever and use less memory, changing the input to your function is generally not a good thing to do, and some interviewers might not like that.\\n\\nYou can also refactor the core BFS logic away into a helper function, I think it might be easier to follow written like this :)\\n\\n```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        start1 = (-1, -1)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    start1 = (i, j)\\n                    break\\n        \\n        queue = collections.deque([start1])\\n        island1 = set([start1])\\n        while queue:\\n            i, j = queue.popleft()\\n            for new_i, new_j in [(i+1, j), (i, j+1), (i-1, j), (i, j-1)]:\\n                if not (0 <= new_i < len(grid) and 0 <= new_j < len(grid[0])):\\n                    continue\\n                if (new_i, new_j) in island1: # visited\\n                    continue\\n                if grid[new_i][new_j] == 0:\\n                    continue\\n                queue.append((new_i, new_j))\\n                island1.add((new_i, new_j))\\n        \\n        start2 = (-1, -1)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1 and (i, j) not in island1:\\n                    start2 = (i, j)\\n                    break\\n        \\n        queue = collections.deque([start2])\\n        island2 = set([start2])\\n        while queue:\\n            i, j = queue.popleft()\\n            for new_i, new_j in [(i+1, j), (i, j+1), (i-1, j), (i, j-1)]:\\n                if not (0 <= new_i < len(grid) and 0 <= new_j < len(grid[0])):\\n                    continue\\n                if (new_i, new_j) in island2: # visited\\n                    continue\\n                if grid[new_i][new_j] == 0:\\n                    continue\\n                queue.append((new_i, new_j))\\n                island2.add((new_i, new_j))\\n                \\n        queue = collections.deque([(0, i, j) for (i, j) in island1])\\n        visited = set(island1)\\n        while queue:\\n            step, i, j = queue.popleft()\\n            for new_i, new_j in [(i+1, j), (i, j+1), (i-1, j), (i, j-1)]:\\n                if not (0 <= new_i < len(grid) and 0 <= new_j < len(grid[0])):\\n                    continue\\n                if (new_i, new_j) in visited: # visited\\n                    continue\\n                if (new_i, new_j) in island2:\\n                    return step\\n                queue.append((step + 1, new_i, new_j))\\n                visited.add((new_i, new_j))\\n                \\n        return -1\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/6c9fea44-1e44-46b0-9b02-911b13942eed_1679267911.7222798.png)\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        start1 = (-1, -1)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    start1 = (i, j)\\n                    break\\n        \\n        queue = collections.deque([start1])\\n        island1 = set([start1])\\n        while queue:\\n            i, j = queue.popleft()\\n            for new_i, new_j in [(i+1, j), (i, j+1), (i-1, j), (i, j-1)]:\\n                if not (0 <= new_i < len(grid) and 0 <= new_j < len(grid[0])):\\n                    continue\\n                if (new_i, new_j) in island1: # visited\\n                    continue\\n                if grid[new_i][new_j] == 0:\\n                    continue\\n                queue.append((new_i, new_j))\\n                island1.add((new_i, new_j))\\n        \\n        start2 = (-1, -1)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1 and (i, j) not in island1:\\n                    start2 = (i, j)\\n                    break\\n        \\n        queue = collections.deque([start2])\\n        island2 = set([start2])\\n        while queue:\\n            i, j = queue.popleft()\\n            for new_i, new_j in [(i+1, j), (i, j+1), (i-1, j), (i, j-1)]:\\n                if not (0 <= new_i < len(grid) and 0 <= new_j < len(grid[0])):\\n                    continue\\n                if (new_i, new_j) in island2: # visited\\n                    continue\\n                if grid[new_i][new_j] == 0:\\n                    continue\\n                queue.append((new_i, new_j))\\n                island2.add((new_i, new_j))\\n                \\n        queue = collections.deque([(0, i, j) for (i, j) in island1])\\n        visited = set(island1)\\n        while queue:\\n            step, i, j = queue.popleft()\\n            for new_i, new_j in [(i+1, j), (i, j+1), (i-1, j), (i, j-1)]:\\n                if not (0 <= new_i < len(grid) and 0 <= new_j < len(grid[0])):\\n                    continue\\n                if (new_i, new_j) in visited: # visited\\n                    continue\\n                if (new_i, new_j) in island2:\\n                    return step\\n                queue.append((step + 1, new_i, new_j))\\n                visited.add((new_i, new_j))\\n                \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058123,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> DIR = {1, 0, -1, 0, 1};\\n    queue<pair<int, int>> q;\\n    int n, m;\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        int level = 0, color = 2;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j] == 1)\\n                    helper(grid, i, j, color++);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++){\\n                auto [r,c] = q.front();\\n                q.pop();\\n                for(int k = 0; k < 4; k++){\\n                    int nr = r + DIR[k], nc = c + DIR[k + 1];\\n                    if(nr < 0 || nc < 0 || nr == n || nc == m || grid[nr][nc] == 2) continue;\\n                    if(grid[nr][nc] == 3) return level;\\n                    grid[nr][nc] = 2;\\n                    q.push({nr, nc});\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n    void helper(vector<vector<int>>& grid, int i, int j, int color){\\n        if(i < 0 || j < 0 || i == n || j == m || grid[i][j] != 1)\\n            return;\\n        if(color == 2) q.push({i, j});\\n        grid[i][j] = color;\\n        for(int k = 0; k < 4; k++)\\n            helper(grid, i + DIR[k], j + DIR[k + 1], color);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> DIR = {1, 0, -1, 0, 1};\\n    queue<pair<int, int>> q;\\n    int n, m;\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        int level = 0, color = 2;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j] == 1)\\n                    helper(grid, i, j, color++);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++){\\n                auto [r,c] = q.front();\\n                q.pop();\\n                for(int k = 0; k < 4; k++){\\n                    int nr = r + DIR[k], nc = c + DIR[k + 1];\\n                    if(nr < 0 || nc < 0 || nr == n || nc == m || grid[nr][nc] == 2) continue;\\n                    if(grid[nr][nc] == 3) return level;\\n                    grid[nr][nc] = 2;\\n                    q.push({nr, nc});\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n    void helper(vector<vector<int>>& grid, int i, int j, int color){\\n        if(i < 0 || j < 0 || i == n || j == m || grid[i][j] != 1)\\n            return;\\n        if(color == 2) q.push({i, j});\\n        grid[i][j] = color;\\n        for(int k = 0; k < 4; k++)\\n            helper(grid, i + DIR[k], j + DIR[k + 1], color);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016290,
                "title": "java-dfs-bfs-solution-easy",
                "content": "**First Find all cells with value 1 using *DFS* and then apply *BFS* to find shortest Distance**\\n\\n\\tclass Solution {\\n\\t\\tQueue<int[]> q = new LinkedList<>();\\n\\t\\tprivate int[][] dirs = new int[][]{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n\\n\\t\\tpublic int shortestBridge(int[][] grid) {\\n\\t\\t\\tboolean flag = false;\\n\\n\\t\\t\\tfor(int i = 0; i < grid.length && !flag; i++){\\n\\t\\t\\t\\tfor(int j = 0; j < grid[0].length; j++){\\n\\t\\t\\t\\t\\tif(grid[i][j] == 1){\\n\\t\\t\\t\\t\\t\\tdfs(i, j, grid);\\n\\t\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tint[] cell = q.poll();\\n\\t\\t\\t\\tint i = cell[0], j = cell[1], dist = cell[2];\\n\\t\\t\\t\\tfor(int[] dir : dirs){\\n\\t\\t\\t\\t\\tint x = i + dir[0], y = j + dir[1];\\n\\t\\t\\t\\t\\tif(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length){\\n\\t\\t\\t\\t\\t\\tif(grid[x][y] == 1) return dist;\\n\\t\\t\\t\\t\\t\\tif(grid[x][y] == 0) {\\n\\t\\t\\t\\t\\t\\t\\tq.add(new int[]{x, y, dist+1});\\n\\t\\t\\t\\t\\t\\t\\tgrid[x][y] = 2;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tprivate void dfs(int i, int j, int[][] grid){\\n\\t\\t\\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != 1) return;\\n\\t\\t\\tgrid[i][j] = 2;\\n\\t\\t\\tq.add(new int[]{i, j, 0});\\n\\t\\t\\tdfs(i, j-1, grid);\\n\\t\\t\\tdfs(i, j+1, grid);\\n\\t\\t\\tdfs(i-1, j, grid);\\n\\t\\t\\tdfs(i+1, j, grid);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n\\t\\tQueue<int[]> q = new LinkedList<>();\\n\\t\\tprivate int[][] dirs = new int[][]{{0, -1}",
                "codeTag": "Java"
            },
            {
                "id": 1973240,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n\\tpublic void dfs(int a[][], int i, int j) {\\n\\t\\tif (i < 0 || i >= a.length || j < 0 ||  j >= a[0].length || a[i][j] == 0 || a[i][j] == 2) return;\\n\\t\\ta[i][j] = 2;\\n\\t\\tdfs(a,i-1,j);dfs(a,i+1,j);dfs(a,i,j-1);dfs(a,i,j+1);\\n\\t}\\n\\tpublic int shortestBridge(int[][] a) {\\n\\t\\tboolean found = false;\\n\\t\\tQueue<int[]> q = new LinkedList<>();\\n\\t\\tfor (int i = 0; i < a.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < a[0].length; j++) {\\n\\t\\t\\t\\t if (a[i][j] == 1 && !found) {\\n\\t\\t\\t\\t\\t found = true;\\n\\t\\t\\t\\t\\t dfs(a,i,j);\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\tif (found && a[i][j] == 1) q.add(new int[]{i,j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint ans = 0;\\n\\t\\twhile (!q.isEmpty()) {\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\tfor (int c = 0; c < size; c++) {\\n\\t\\t\\t\\tint b[] = q.remove();\\n\\t\\t\\t\\tint i = b[0];\\n\\t\\t\\t\\tint j = b[1];\\n\\t\\t\\t\\tif ((i > 0 && a[i-1][j] == 2) || (i < a.length-1 && a[i+1][j] == 2) || (j > 0 && a[i][j-1] == 2) || \\n\\t\\t\\t\\t\\t(j < a[0].length-1 && a[i][j+1] == 2)) return ans;\\n\\t\\t\\t\\tif (i > 0 && a[i-1][j] == 0) {\\n\\t\\t\\t\\t\\ta[i-1][j] = 1;\\n\\t\\t\\t\\t\\tq.add(new int[]{i-1,j});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (i < a.length-1 && a[i+1][j] == 0) {\\n\\t\\t\\t\\t\\ta[i+1][j] = 1;\\n\\t\\t\\t\\t\\tq.add(new int[]{i+1,j});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (j > 0 && a[i][j-1] == 0) {\\n\\t\\t\\t\\t\\ta[i][j-1] = 1;\\n\\t\\t\\t\\t\\tq.add(new int[]{i,j-1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (j < a[0].length-1 && a[i][j+1] == 0) {\\n\\t\\t\\t\\t\\ta[i][j+1] = 1;\\n\\t\\t\\t\\t\\tq.add(new int[]{i,j+1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\tpublic void dfs(int a[][], int i, int j) {\\n\\t\\tif (i < 0 || i >= a.length || j < 0 ||  j >= a[0].length || a[i][j] == 0 || a[i][j] == 2) return;\\n\\t\\ta[i][j] = 2;\\n\\t\\tdfs(a,i-1,j);dfs(a,i+1,j);dfs(a,i,j-1);dfs(a,i,j+1);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1912662,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 : Using DFS || Brute Force***\\n\\n* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(N * N)***\\n\\n```\\n    void dfs(vector<vector<int>>& grid, int i, int j, int n, vector<vector<int>>& res)\\n    {\\n        if(i < 0 || i >= n || j < 0 || j >= n || grid[i][j] == -1 || grid[i][j] == 0)\\n            return;\\n        \\n        grid[i][j] = -1;\\n        \\n        res.push_back({i, j});\\n        \\n        dfs(grid, i - 1, j, n, res);\\n        \\n        dfs(grid, i + 1, j, n, res);\\n        \\n        dfs(grid, i, j - 1, n, res);\\n        \\n        dfs(grid, i, j + 1, n, res);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        vector<vector<int>> island1;\\n        \\n        vector<vector<int>> island2;\\n        \\n        bool flag = true;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    if(flag)\\n                    {\\n                        dfs(grid, i, j, n, island1);\\n                        \\n                        flag = false;\\n                    }\\n                    else\\n                    {\\n                        dfs(grid, i, j, n, island2);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int i = 0; i < island1.size(); i++)\\n        {\\n            int x1 = island1[i][0];\\n            \\n            int y1 = island1[i][1];\\n            \\n            for(int j = 0; j < island2.size(); j++)\\n            {\\n                int x2 = island2[j][0];\\n                \\n                int y2 = island2[j][1];\\n                \\n                int d1 = abs(x1 - x2);\\n                \\n                int d2 = abs(y1 - y2);\\n                \\n                int d = d1 + d2 - 1;\\n                \\n                mini = min(mini, d);\\n            }\\n        }\\n        \\n        return mini;\\n    }\\n```\\n\\n\\n* ***Approach 2 : Using DFS && BFS***\\n\\n* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(N * N)***\\n\\n```\\n    set<pair<int, int>> vis;\\n    \\n    void dfs(vector<vector<int>>& grid, int i, int j, int n, queue<pair<int, int>>& q)\\n    {\\n        if(i < 0 || i >= n || j < 0 || j >= n || grid[i][j] == 0 || vis.find({i, j}) != vis.end())\\n            return;\\n        \\n        vis.insert({i, j});\\n        \\n        q.push({i, j});\\n        \\n        dfs(grid, i - 1, j, n, q);\\n        \\n        dfs(grid, i + 1, j, n, q);\\n        \\n        dfs(grid, i, j - 1, n, q);\\n        \\n        dfs(grid, i, j + 1, n, q);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        queue<pair<int, int>> q;\\n        \\n        bool flag = true;\\n        \\n        for(int i = 0; i < n && flag; i++)\\n        {\\n            for(int j = 0; j < n && flag; j++)\\n            {\\n                if(grid[i][j] == 1 && flag)\\n                {\\n                    dfs(grid, i, j, n, q);\\n                        \\n                    flag = false;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        vector<int> dx = {0, 0, 1, -1};\\n        \\n        vector<int> dy = {1, -1, 0, 0};\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            while(size--)\\n            {\\n                auto x = q.front();\\n                \\n                q.pop();\\n                \\n                int i = x.first;\\n                \\n                int j = x.second;\\n                \\n                for(int k = 0; k < 4; k++)\\n                {\\n                    int new_row = i + dx[k];\\n                    \\n                    int new_col = j + dy[k];\\n                    \\n                    if(new_row >= 0 && new_row <= n - 1 && new_col >= 0 && new_col <= n - 1 && vis.find({new_row, new_col}) == vis.end())\\n                    {\\n                        if(grid[new_row][new_col] == 1)\\n                        {\\n                            return ans;\\n                        }\\n                        \\n                        else\\n                        {\\n                            q.push({new_row, new_col});\\n                            \\n                            vis.insert({new_row, new_col});\\n                        }\\n                    }\\n                }   \\n            }\\n            \\n            ans++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```\\n\\n* ***Approach 3 : Space Optimized***\\n\\n* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(N * N)***\\n\\n```\\n    void dfs(vector<vector<int>>& grid, int i, int j, int n, queue<pair<int, int>>& q)\\n    {\\n        if(i < 0 || i >= n || j < 0 || j >= n || grid[i][j] == 0 || grid[i][j] == -1)\\n            return;\\n        \\n        grid[i][j] = -1;\\n        \\n        q.push({i, j});\\n        \\n        dfs(grid, i - 1, j, n, q);\\n        \\n        dfs(grid, i + 1, j, n, q);\\n        \\n        dfs(grid, i, j - 1, n, q);\\n        \\n        dfs(grid, i, j + 1, n, q);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        queue<pair<int, int>> q;\\n        \\n        bool flag = true;\\n        \\n        for(int i = 0; i < n && flag; i++)\\n        {\\n            for(int j = 0; j < n && flag; j++)\\n            {\\n                if(grid[i][j] == 1 && flag)\\n                {\\n                    dfs(grid, i, j, n, q);\\n                        \\n                    flag = false;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        vector<int> dx = {0, 0, 1, -1};\\n        \\n        vector<int> dy = {1, -1, 0, 0};\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            while(size--)\\n            {\\n                auto x = q.front();\\n                \\n                q.pop();\\n                \\n                int i = x.first;\\n                \\n                int j = x.second;\\n                \\n                for(int k = 0; k < 4; k++)\\n                {\\n                    int new_row = i + dx[k];\\n                    \\n                    int new_col = j + dy[k];\\n                    \\n                    if(new_row >= 0 && new_row <= n - 1 && new_col >= 0 && new_col <= n - 1 && grid[new_row][new_col] != -1)\\n                    {\\n                        if(grid[new_row][new_col] == 1)\\n                        {\\n                            return ans;\\n                        }\\n                        \\n                        else\\n                        {\\n                            q.push({new_row, new_col});\\n                            \\n                            grid[new_row][new_col] = -1;\\n                        }\\n                    }\\n                }   \\n            }\\n            \\n            ans++;\\n        }\\n        \\n        return ans; \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\n    void dfs(vector<vector<int>>& grid, int i, int j, int n, vector<vector<int>>& res)\\n    {\\n        if(i < 0 || i >= n || j < 0 || j >= n || grid[i][j] == -1 || grid[i][j] == 0)\\n            return;\\n        \\n        grid[i][j] = -1;\\n        \\n        res.push_back({i, j});\\n        \\n        dfs(grid, i - 1, j, n, res);\\n        \\n        dfs(grid, i + 1, j, n, res);\\n        \\n        dfs(grid, i, j - 1, n, res);\\n        \\n        dfs(grid, i, j + 1, n, res);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        vector<vector<int>> island1;\\n        \\n        vector<vector<int>> island2;\\n        \\n        bool flag = true;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    if(flag)\\n                    {\\n                        dfs(grid, i, j, n, island1);\\n                        \\n                        flag = false;\\n                    }\\n                    else\\n                    {\\n                        dfs(grid, i, j, n, island2);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int i = 0; i < island1.size(); i++)\\n        {\\n            int x1 = island1[i][0];\\n            \\n            int y1 = island1[i][1];\\n            \\n            for(int j = 0; j < island2.size(); j++)\\n            {\\n                int x2 = island2[j][0];\\n                \\n                int y2 = island2[j][1];\\n                \\n                int d1 = abs(x1 - x2);\\n                \\n                int d2 = abs(y1 - y2);\\n                \\n                int d = d1 + d2 - 1;\\n                \\n                mini = min(mini, d);\\n            }\\n        }\\n        \\n        return mini;\\n    }\\n```\n```\\n    set<pair<int, int>> vis;\\n    \\n    void dfs(vector<vector<int>>& grid, int i, int j, int n, queue<pair<int, int>>& q)\\n    {\\n        if(i < 0 || i >= n || j < 0 || j >= n || grid[i][j] == 0 || vis.find({i, j}) != vis.end())\\n            return;\\n        \\n        vis.insert({i, j});\\n        \\n        q.push({i, j});\\n        \\n        dfs(grid, i - 1, j, n, q);\\n        \\n        dfs(grid, i + 1, j, n, q);\\n        \\n        dfs(grid, i, j - 1, n, q);\\n        \\n        dfs(grid, i, j + 1, n, q);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        queue<pair<int, int>> q;\\n        \\n        bool flag = true;\\n        \\n        for(int i = 0; i < n && flag; i++)\\n        {\\n            for(int j = 0; j < n && flag; j++)\\n            {\\n                if(grid[i][j] == 1 && flag)\\n                {\\n                    dfs(grid, i, j, n, q);\\n                        \\n                    flag = false;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        vector<int> dx = {0, 0, 1, -1};\\n        \\n        vector<int> dy = {1, -1, 0, 0};\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            while(size--)\\n            {\\n                auto x = q.front();\\n                \\n                q.pop();\\n                \\n                int i = x.first;\\n                \\n                int j = x.second;\\n                \\n                for(int k = 0; k < 4; k++)\\n                {\\n                    int new_row = i + dx[k];\\n                    \\n                    int new_col = j + dy[k];\\n                    \\n                    if(new_row >= 0 && new_row <= n - 1 && new_col >= 0 && new_col <= n - 1 && vis.find({new_row, new_col}) == vis.end())\\n                    {\\n                        if(grid[new_row][new_col] == 1)\\n                        {\\n                            return ans;\\n                        }\\n                        \\n                        else\\n                        {\\n                            q.push({new_row, new_col});\\n                            \\n                            vis.insert({new_row, new_col});\\n                        }\\n                    }\\n                }   \\n            }\\n            \\n            ans++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```\n```\\n    void dfs(vector<vector<int>>& grid, int i, int j, int n, queue<pair<int, int>>& q)\\n    {\\n        if(i < 0 || i >= n || j < 0 || j >= n || grid[i][j] == 0 || grid[i][j] == -1)\\n            return;\\n        \\n        grid[i][j] = -1;\\n        \\n        q.push({i, j});\\n        \\n        dfs(grid, i - 1, j, n, q);\\n        \\n        dfs(grid, i + 1, j, n, q);\\n        \\n        dfs(grid, i, j - 1, n, q);\\n        \\n        dfs(grid, i, j + 1, n, q);\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        queue<pair<int, int>> q;\\n        \\n        bool flag = true;\\n        \\n        for(int i = 0; i < n && flag; i++)\\n        {\\n            for(int j = 0; j < n && flag; j++)\\n            {\\n                if(grid[i][j] == 1 && flag)\\n                {\\n                    dfs(grid, i, j, n, q);\\n                        \\n                    flag = false;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        vector<int> dx = {0, 0, 1, -1};\\n        \\n        vector<int> dy = {1, -1, 0, 0};\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            while(size--)\\n            {\\n                auto x = q.front();\\n                \\n                q.pop();\\n                \\n                int i = x.first;\\n                \\n                int j = x.second;\\n                \\n                for(int k = 0; k < 4; k++)\\n                {\\n                    int new_row = i + dx[k];\\n                    \\n                    int new_col = j + dy[k];\\n                    \\n                    if(new_row >= 0 && new_row <= n - 1 && new_col >= 0 && new_col <= n - 1 && grid[new_row][new_col] != -1)\\n                    {\\n                        if(grid[new_row][new_col] == 1)\\n                        {\\n                            return ans;\\n                        }\\n                        \\n                        else\\n                        {\\n                            q.push({new_row, new_col});\\n                            \\n                            grid[new_row][new_col] = -1;\\n                        }\\n                    }\\n                }   \\n            }\\n            \\n            ans++;\\n        }\\n        \\n        return ans; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1904260,
                "title": "java-dfs-bfs",
                "content": "```\\nclass Solution {\\n    final int island1 = Integer.MAX_VALUE;\\n    final int island2 = Integer.MIN_VALUE;    \\n    final int water = 0;\\n    final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1,0}};\\n    int m;\\n    int n;\\n    public int shortestBridge(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean marked = true;\\n        int target = 0;\\n        m: for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    target = markIsland(grid, i, j, q, marked ? island1 : island2, marked);\\n                    marked = false;\\n                    if(target == island2) \\n                        break m;\\n                } \\n            }\\n        }\\n        int bridge = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] c = q.poll();\\n                for (int[] dir: dirs) {\\n                    int x = dir[0] + c[0];\\n                    int y = dir[1] + c[1];\\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] > 0) continue;\\n                    if (grid[x][y] == island2) return bridge;\\n                    grid[x][y] = island1;\\n                    q.offer(new int[]{x, y});\\n                }\\n            }\\n            bridge++;\\n        }\\n        return bridge;\\n    }\\n    private int markIsland(int[][] grid, int x, int y,  Queue<int[]> q, int target, boolean offer) {\\n        if(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == water || grid[x][y] == target) return target;\\n        grid[x][y] = target;\\n        if (offer) {\\n            q.offer(new int[] {x, y});\\n        }\\n        markIsland(grid, x - 1, y, q, target, offer);\\n        markIsland(grid, x + 1, y, q, target, offer);\\n        markIsland(grid, x, y - 1, q, target, offer);\\n        markIsland(grid, x, y + 1, q, target, offer);\\n        return target;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    final int island1 = Integer.MAX_VALUE;\\n    final int island2 = Integer.MIN_VALUE;    \\n    final int water = 0;\\n    final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1,0}};\\n    int m;\\n    int n;\\n    public int shortestBridge(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean marked = true;\\n        int target = 0;\\n        m: for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    target = markIsland(grid, i, j, q, marked ? island1 : island2, marked);\\n                    marked = false;\\n                    if(target == island2) \\n                        break m;\\n                } \\n            }\\n        }\\n        int bridge = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] c = q.poll();\\n                for (int[] dir: dirs) {\\n                    int x = dir[0] + c[0];\\n                    int y = dir[1] + c[1];\\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] > 0) continue;\\n                    if (grid[x][y] == island2) return bridge;\\n                    grid[x][y] = island1;\\n                    q.offer(new int[]{x, y});\\n                }\\n            }\\n            bridge++;\\n        }\\n        return bridge;\\n    }\\n    private int markIsland(int[][] grid, int x, int y,  Queue<int[]> q, int target, boolean offer) {\\n        if(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == water || grid[x][y] == target) return target;\\n        grid[x][y] = target;\\n        if (offer) {\\n            q.offer(new int[] {x, y});\\n        }\\n        markIsland(grid, x - 1, y, q, target, offer);\\n        markIsland(grid, x + 1, y, q, target, offer);\\n        markIsland(grid, x, y - 1, q, target, offer);\\n        markIsland(grid, x, y + 1, q, target, offer);\\n        return target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901675,
                "title": "c-bfs-dfs-solution-explained",
                "content": "/*\\n    Approach: First we need to find the first Island and from there we can find the shortest distance to the other island.\\n    \\n    In order to find the first Island we iterater over grid matrix and whenever we encounter any 1 we call a dfs from there\\n    so that we visit all the nodes of the first island and mark that it has been visited and also push their co-ordinates into\\n    queue. now why are we pushing their co-ordinates into queue? because these co-ordinates will finally help us to find\\n    the distance to the second island. It is just like mulitsource BFS.\\n    \\n    Once we have got our first island we break out of loop which has been done using the variable isFirst in the code.\\n    \\n    Now once we have all the node\\'s co-ordinate in the queue we can run BFS to find the shortes distance from the first island \\n    to the second island.\\n    so we run simple BFS over all the elements present in our queue.\\n    \\n    we also maintain a res variable which will denote the min distance required to discover the distance to second island.\\n    \\n    now for every level we will have four kinds of nodes.\\n    1. grid[i][j]=1 and visited - this means that this node belongs to first island only.\\n    2. grid[i][j]=1 and non-visited - this meand that this is the first land of other island and this is what we need to find.\\n    3. grid[i][j]=0 and visited - this means that we have visited this node during our exploration and we need to explore more.\\n    4. grid[i][j]=0 and non-visited - this means we haven\\'t visited this and we are still continuing on our quest to find second island\\n    \\n    now if we think carefully case 1 and case 3 are no use to us.\\n    our only consideration should be case 2 and case 4.\\n    \\n    if we have got case 2 then we have found the first land and hence we return our ans as this will be the shortest distance\\n    to other island because BFS works in level order traversal method.\\n    \\n    if we have got case 4 then we need to continue to find our second island.\\n    \\n    now at last if all the elements of queue gets exhausted that means second island does not exist and hence we return -1.\\n\\t\\n\\tTime Complexity : O(n^2) + 2O(V+E) - O(n^2)\\n\\tSpace Complexity : O(n^2) for visited and O(E) for queue\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int n,m;\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,1,-1};\\n    \\n    void dfs(int x,int y,vector<vector<bool> >& visited,vector<vector<int> >& grid,queue<pair<int,int> >& q)\\n    {\\n        if(x<0 || y<0 || x>=n || y>=m || visited[x][y]==true || grid[x][y]==0)\\n            return;\\n        visited[x][y]=true;\\n        q.push({x,y});\\n        for(int i=0;i<4;++i)\\n        {\\n            int curx=x+dx[i];\\n            int cury=y+dy[i];\\n            dfs(curx,cury,visited,grid,q);\\n        }\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool> > visited(n,vector<bool>(m,false));\\n        bool isFirst=false;\\n        queue<pair<int,int> > q;\\n        for(int i=0;i<n;++i)\\n        {\\n            for(int j=0;j<m;++j)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    dfs(i,j,visited,grid,q);\\n                    isFirst=true;\\n                    break;\\n                }\\n            }\\n            if(isFirst)\\n                break;\\n        }\\n        int res=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                for(int i=0;i<4;++i)\\n                {\\n                    int curx=x+dx[i];\\n                    int cury=y+dy[i];\\n                    if(curx>=0 && curx<n && cury>=0 && cury<m && grid[curx][cury]==1 && visited[curx][cury]==false)\\n                    {\\n                        return res;\\n                    }\\n                    else if(curx>=0 && curx<n && cury>=0 && cury<m && grid[curx][cury]==0 && visited[curx][cury]==false)\\n                    {\\n                        visited[curx][cury]=true;\\n                        q.push({curx,cury});\\n                    }\\n                }   \\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int n,m;\\n    int dx[4]={1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1847003,
                "title": "easy-to-understand-c-bfs-with-steps",
                "content": "**IDEA**\\n1. Find the first indices whose value is 1 in the grid.\\n2. traverse over the first island and mark all those elements to 2. Simultaneosly push those indices to a queue. And queue contains all the indices which form island 1.\\n3. Now, use bfs till u get an index of 2nd island whose value is 1.\\n\\n```\\nint arr[5] = {0, 1, 0, -1, 0};\\nclass Solution {\\n    void helper(vector<vector<int>>& grid, int i, int j, vector<pair<int, int>>& v)\\n    {\\n        if (i<0 || j<0 || i>=grid.size() || j>=grid.size() || grid[i][j]!=1)\\n            return ;\\n        grid[i][j] = 2;\\n        v.push_back({i, j});\\n        for (int k=0; k<4; k++)\\n            helper(grid, i+arr[k], j+arr[k+1], v);\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid)\\n    {\\n        int n = grid.size();\\n        queue<pair<int, int>> q;\\n        vector<pair<int, int>> v;\\n        for (int i=0; i<n; i++)\\n        {\\n            bool flag = false;\\n            for (int j=0; j<n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    flag = true;\\n                    helper(grid, i, j, v);\\n                    break;\\n                }\\n            }\\n            if (flag)\\n                break;\\n        }\\n        for (auto i: v)\\n            q.push(i);\\n        \\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int m = q.size();\\n            for (int i=0; i<m; i++)\\n            {\\n                int x = q.front().first, y = q.front().second;\\n                q.pop();\\n                for (int k=0; k<4; k++)\\n                {\\n                    int dx = x+arr[k], dy = y+arr[k+1];\\n                    if (dx<0 || dy<0 || dx>=n || dy>=n)\\n                        continue;\\n                    if (grid[dx][dy] == 1)\\n                        return ans;\\n                    if (grid[dx][dy] == 0)\\n                    {\\n                        q.push({dx, dy});\\n                        grid[dx][dy] = 2;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint arr[5] = {0, 1, 0, -1, 0};\\nclass Solution {\\n    void helper(vector<vector<int>>& grid, int i, int j, vector<pair<int, int>>& v)\\n    {\\n        if (i<0 || j<0 || i>=grid.size() || j>=grid.size() || grid[i][j]!=1)\\n            return ;\\n        grid[i][j] = 2;\\n        v.push_back({i, j});\\n        for (int k=0; k<4; k++)\\n            helper(grid, i+arr[k], j+arr[k+1], v);\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid)\\n    {\\n        int n = grid.size();\\n        queue<pair<int, int>> q;\\n        vector<pair<int, int>> v;\\n        for (int i=0; i<n; i++)\\n        {\\n            bool flag = false;\\n            for (int j=0; j<n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    flag = true;\\n                    helper(grid, i, j, v);\\n                    break;\\n                }\\n            }\\n            if (flag)\\n                break;\\n        }\\n        for (auto i: v)\\n            q.push(i);\\n        \\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int m = q.size();\\n            for (int i=0; i<m; i++)\\n            {\\n                int x = q.front().first, y = q.front().second;\\n                q.pop();\\n                for (int k=0; k<4; k++)\\n                {\\n                    int dx = x+arr[k], dy = y+arr[k+1];\\n                    if (dx<0 || dy<0 || dx>=n || dy>=n)\\n                        continue;\\n                    if (grid[dx][dy] == 1)\\n                        return ans;\\n                    if (grid[dx][dy] == 0)\\n                    {\\n                        q.push({dx, dy});\\n                        grid[dx][dy] = 2;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784569,
                "title": "easy-to-understand-commented-dfs-bfs",
                "content": "# Please upvote if you find it helpful! :) Thank you!\\n```\\n# Approach 1: DFS + BFS\\n# Time:  O(N)\\n# Space: O(N)\\n\\n# Intuition:\\n# summary: \\n    # Locate the one island via DFS and expand its boundary via BFS until the other island is found.\\n# detail:\\n    # Start from one cell that is 1, then that belongs to one of the two islands that we know for sure exist and are disconnected.\\n    # do a DFS from that cell and get all the connected grid points that belong to it\\n    # then start a BFS from all the cells belonging to the island 1, one step at a time. At iteration ith of BFS we are i steps away from each cell belonging to island 1.\\n    # As soon as we reach to another cell that has never been visited and it is 1, that for sure belongs to the second island, and we are done. \\n    # Then the length of the bridge is the number of steps we traversed so far.\\n\\ndef shortestBridge(grid):\\n    \"\"\"\\n    :type grid: List[List[int]]\\n    :rtype: int\\n    \"\"\"\\n    from collections import deque\\n\\n    def first():\\n        for r in range(nr):\\n            for c in range(nc):\\n                if grid[r][c]:\\n                    return (r, c)\\n    \\n    nr, nc = len(grid), len(grid[0])\\n    dirs = [(+1,0),(-1,0),(0,+1),(0,-1)]\\n    # DFS from the first found cell (r,c) where grid[r][c]==1, to get all the cells (=1) that belong to island #1\\n    # we know we have two disconnected islands only\\n    stack = [first()]\\n    seen = set()\\n    while stack:\\n        r,c = stack.pop()\\n        for dr,dc in dirs:\\n            new_r, new_c = r+dr, c+dc\\n            if 0<=new_r<nr and 0<=new_c<nc and grid[new_r][new_c] == 1 and (new_r, new_c) not in seen:\\n                seen.append((new_r, new_c))\\n                stack.append((new_r, new_c))\\n\\n    q = deque([(r,c,0) for (r,c) in seen])\\n    while q:\\n        r,c,step = q.popleft()\\n        for dr,dc in dirs:\\n            new_r, new_c = r+dr, c+dc\\n            if 0<=new_r<nr and 0<=new_c<nc and (new_r, new_c) not in seen:\\n                if grid[new_r][new_c] == 1: # we have reached to the next island in the current BFS iteration\\n                    return step + 1\\n```",
                "solutionTags": [],
                "code": "```\\n# Approach 1: DFS + BFS\\n# Time:  O(N)\\n# Space: O(N)\\n\\n# Intuition:\\n# summary: \\n    # Locate the one island via DFS and expand its boundary via BFS until the other island is found.\\n# detail:\\n    # Start from one cell that is 1, then that belongs to one of the two islands that we know for sure exist and are disconnected.\\n    # do a DFS from that cell and get all the connected grid points that belong to it\\n    # then start a BFS from all the cells belonging to the island 1, one step at a time. At iteration ith of BFS we are i steps away from each cell belonging to island 1.\\n    # As soon as we reach to another cell that has never been visited and it is 1, that for sure belongs to the second island, and we are done. \\n    # Then the length of the bridge is the number of steps we traversed so far.\\n\\ndef shortestBridge(grid):\\n    \"\"\"\\n    :type grid: List[List[int]]\\n    :rtype: int\\n    \"\"\"\\n    from collections import deque\\n\\n    def first():\\n        for r in range(nr):\\n            for c in range(nc):\\n                if grid[r][c]:\\n                    return (r, c)\\n    \\n    nr, nc = len(grid), len(grid[0])\\n    dirs = [(+1,0),(-1,0),(0,+1),(0,-1)]\\n    # DFS from the first found cell (r,c) where grid[r][c]==1, to get all the cells (=1) that belong to island #1\\n    # we know we have two disconnected islands only\\n    stack = [first()]\\n    seen = set()\\n    while stack:\\n        r,c = stack.pop()\\n        for dr,dc in dirs:\\n            new_r, new_c = r+dr, c+dc\\n            if 0<=new_r<nr and 0<=new_c<nc and grid[new_r][new_c] == 1 and (new_r, new_c) not in seen:\\n                seen.append((new_r, new_c))\\n                stack.append((new_r, new_c))\\n\\n    q = deque([(r,c,0) for (r,c) in seen])\\n    while q:\\n        r,c,step = q.popleft()\\n        for dr,dc in dirs:\\n            new_r, new_c = r+dr, c+dc\\n            if 0<=new_r<nr and 0<=new_c<nc and (new_r, new_c) not in seen:\\n                if grid[new_r][new_c] == 1: # we have reached to the next island in the current BFS iteration\\n                    return step + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1700706,
                "title": "python-short-clean-dfs-bfs-beats-95",
                "content": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        def dfs(x, y):\\n            grid[x][y] = 2\\n            for dx, dy in d:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    if grid[nx][ny] == 1: dfs(nx, ny)\\n                    elif grid[nx][ny] == 0: \\n                        q.add((nx, ny))\\n                        \\n        m, n = len(grid), len(grid[0])\\n        d = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        q = set()\\n        \\n        for i, j in product(range(m), range(n)):\\n            if grid[i][j] == 1:\\n                dfs(i, j) # paint one island to 2, border 0 add to q\\n                break\\n        \\n        step = 0\\n        q = deque(q)\\n        while q:\\n            for _ in range(len(q)):\\n                x, y = q.popleft()\\n                for dx, dy in d:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < m and 0 <= ny < n:\\n                        if grid[nx][ny] == 1: return step + 1\\n                        if grid[nx][ny] == 0: \\n                            grid[nx][ny] = 2 # mark visited\\n                            q.append((nx, ny))\\n            step += 1\\n                        \\n        return step\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        def dfs(x, y):\\n            grid[x][y] = 2\\n            for dx, dy in d:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    if grid[nx][ny] == 1: dfs(nx, ny)\\n                    elif grid[nx][ny] == 0: \\n                        q.add((nx, ny))\\n                        \\n        m, n = len(grid), len(grid[0])\\n        d = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        q = set()\\n        \\n        for i, j in product(range(m), range(n)):\\n            if grid[i][j] == 1:\\n                dfs(i, j) # paint one island to 2, border 0 add to q\\n                break\\n        \\n        step = 0\\n        q = deque(q)\\n        while q:\\n            for _ in range(len(q)):\\n                x, y = q.popleft()\\n                for dx, dy in d:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < m and 0 <= ny < n:\\n                        if grid[nx][ny] == 1: return step + 1\\n                        if grid[nx][ny] == 0: \\n                            grid[nx][ny] = 2 # mark visited\\n                            q.append((nx, ny))\\n            step += 1\\n                        \\n        return step\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1674552,
                "title": "python-easy-understanding-solution-find-smallest-distance-between-2-disconnected-components",
                "content": "```\\nclass Solution:\\n    def isBoundary(self, grid, point) -> bool:\\n        x,y = point[0], point[1]\\n        if x-1 < 0 or y-1 < 0 or x+1 >= len(grid) or y+1 >= len(grid[x]): return True\\n        if grid[x-1][y] == 0: return True\\n        if grid[x+1][y] == 0: return True\\n        if grid[x][y-1] == 0: return True\\n        if grid[x][y+1] == 0: return True\\n        return False\\n    \\n    def dfs(self, grid, start, visited):\\n        x, y = start[0], start[1]\\n        if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[x]) or grid[x][y] != 1: return\\n        if start not in visited:\\n            visited.add(start)\\n            self.dfs(grid, (x+1, y), visited)\\n            self.dfs(grid, (x, y+1), visited)\\n            self.dfs(grid, (x-1, y), visited)\\n            self.dfs(grid, (x, y-1), visited)\\n    \\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        # find the shortest distance between 2 disconnected components\\n        island1, island2, positionsOfLand = set(), set(), set()\\n        \\n        for x in range(len(grid)):\\n            for y in range(len(grid[x])):\\n                if grid[x][y] == 1: positionsOfLand.add((x,y))\\n        \\n        for each in positionsOfLand:\\n            self.dfs(grid, each, island1)\\n            break\\n                    \\n        for each in positionsOfLand - island1:\\n            self.dfs(grid, each, island2)\\n            break\\n        \\n\\t    boundary1 = [each for each in island1 if self.isBoundary(grid, each)]\\n        boundary2 = [each for each in island2 if self.isBoundary(grid, each)]\\n                \\n        answer = float(\"inf\")\\n        for each1 in boundary1:\\n            for each2 in boundary2:\\n                x1, y1 = each1[0], each1[1]\\n                x2, y2 = each2[0], each2[1]\\n                answer = min(answer, (abs(x1-x2) + abs(y1-y2) - 1))\\n                if answer == 1: break\\n        return answer\\n```\\n\\nBasically I find two disconnected components first and loop through each pair of them to find the minimum distance. The 2 boundary sets is just for optimization purpose to avoid exceeding time limit.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isBoundary(self, grid, point) -> bool:\\n        x,y = point[0], point[1]\\n        if x-1 < 0 or y-1 < 0 or x+1 >= len(grid) or y+1 >= len(grid[x]): return True\\n        if grid[x-1][y] == 0: return True\\n        if grid[x+1][y] == 0: return True\\n        if grid[x][y-1] == 0: return True\\n        if grid[x][y+1] == 0: return True\\n        return False\\n    \\n    def dfs(self, grid, start, visited):\\n        x, y = start[0], start[1]\\n        if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[x]) or grid[x][y] != 1: return\\n        if start not in visited:\\n            visited.add(start)\\n            self.dfs(grid, (x+1, y), visited)\\n            self.dfs(grid, (x, y+1), visited)\\n            self.dfs(grid, (x-1, y), visited)\\n            self.dfs(grid, (x, y-1), visited)\\n    \\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        # find the shortest distance between 2 disconnected components\\n        island1, island2, positionsOfLand = set(), set(), set()\\n        \\n        for x in range(len(grid)):\\n            for y in range(len(grid[x])):\\n                if grid[x][y] == 1: positionsOfLand.add((x,y))\\n        \\n        for each in positionsOfLand:\\n            self.dfs(grid, each, island1)\\n            break\\n                    \\n        for each in positionsOfLand - island1:\\n            self.dfs(grid, each, island2)\\n            break\\n        \\n\\t    boundary1 = [each for each in island1 if self.isBoundary(grid, each)]\\n        boundary2 = [each for each in island2 if self.isBoundary(grid, each)]\\n                \\n        answer = float(\"inf\")\\n        for each1 in boundary1:\\n            for each2 in boundary2:\\n                x1, y1 = each1[0], each1[1]\\n                x2, y2 = each2[0], each2[1]\\n                answer = min(answer, (abs(x1-x2) + abs(y1-y2) - 1))\\n                if answer == 1: break\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529456,
                "title": "python-segmented-bfs-no-painting-expanding-needed",
                "content": "I see most of the solutions in the discussion are painting the grid to `2` to distingush between the two grid. But I **don\\'t** see the point of that. We simplily just need to make sure that every node is visited only once. Visited status is what we use to distingush the two island.\\n\\nThe overall algorithm holds same:\\n1. Find the first island and search all the connected 1s (bfs/dfs) - We mark those searched 1s as visited.\\n2. During the search, we also add all the edge 0s to the next bfs search queue. Those are the possible starting points for the bridge. \\n3. Start standard bfs search for shortest path in a grid with all the edge 0s already added to the queue.\\n4. We terminate the search when we reach a 1 that we **haven\\'t visited**. This can only be the second island because we already visited the first island entirely.\\n\\nFull Implementation:\\n\\n```\\nclass Solution(object):\\n    def shortestBridge(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n                \\n        numR = len(grid)\\n        numC = len(grid[0])\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        visited = [[False] * numC for _ in range(numR)]\\n        searchQueue = deque()\\n        \\n        def updateIsland(r, c):\\n            queue = deque()\\n            queue.append((r, c))\\n            visited[r][c] = True\\n            \\n            while queue:\\n                cr, cc = queue.popleft()\\n                for dr, dc in directions:\\n                    nr = cr + dr\\n                    nc = cc + dc\\n                    if 0 <= nr < numR and 0 <= nc < numC and not visited[nr][nc]:\\n                        visited[nr][nc] = True\\n                        if grid[nr][nc] == 1:\\n                            queue.append((nr, nc))\\n                        elif grid[nr][nc] == 0:\\n                            searchQueue.append((nr, nc, 1))\\n                    \\n        updated = False       \\n        for r in range(numR):\\n            for c in range(numC):\\n                if grid[r][c] == 1:\\n                    updateIsland(r, c)\\n                    updated = True\\n                    break\\n            if updated:\\n                break\\n        \\n        while searchQueue:\\n            r, c, flips = searchQueue.popleft()\\n            for dr, dc in directions:\\n                nr = r + dr\\n                nc = c + dc\\n                if 0 <= nr < numR and 0 <= nc < numC and not visited[nr][nc]:\\n                    if grid[nr][nc] == 1:\\n                        return flips\\n                    else:\\n                        searchQueue.append((nr, nc, flips + 1))\\n                        visited[nr][nc] = True\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def shortestBridge(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n                \\n        numR = len(grid)\\n        numC = len(grid[0])\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        visited = [[False] * numC for _ in range(numR)]\\n        searchQueue = deque()\\n        \\n        def updateIsland(r, c):\\n            queue = deque()\\n            queue.append((r, c))\\n            visited[r][c] = True\\n            \\n            while queue:\\n                cr, cc = queue.popleft()\\n                for dr, dc in directions:\\n                    nr = cr + dr\\n                    nc = cc + dc\\n                    if 0 <= nr < numR and 0 <= nc < numC and not visited[nr][nc]:\\n                        visited[nr][nc] = True\\n                        if grid[nr][nc] == 1:\\n                            queue.append((nr, nc))\\n                        elif grid[nr][nc] == 0:\\n                            searchQueue.append((nr, nc, 1))\\n                    \\n        updated = False       \\n        for r in range(numR):\\n            for c in range(numC):\\n                if grid[r][c] == 1:\\n                    updateIsland(r, c)\\n                    updated = True\\n                    break\\n            if updated:\\n                break\\n        \\n        while searchQueue:\\n            r, c, flips = searchQueue.popleft()\\n            for dr, dc in directions:\\n                nr = r + dr\\n                nc = c + dc\\n                if 0 <= nr < numR and 0 <= nc < numC and not visited[nr][nc]:\\n                    if grid[nr][nc] == 1:\\n                        return flips\\n                    else:\\n                        searchQueue.append((nr, nc, flips + 1))\\n                        visited[nr][nc] = True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499665,
                "title": "python-bidirectional-bfs",
                "content": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        #BFS to find the two islands and mark their cell as 2 and 3\\n        #Bidirectional BFS expanding two islands, record the count of two bfs levels, when one island touches the other, return the count of two bfs\\n        #O(n) time and space\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        mark = 2\\n        islands = []\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    islands.append(self.markIsland(i, j, grid, mark))\\n                    mark += 1\\n        flip = 0\\n        while True:\\n            for island in islands:\\n                if self.connect(island, grid):\\n                    return flip\\n                flip += 1\\n    \\n    def markIsland(self, i, j, grid, mark):\\n        m, n = len(grid), len(grid[0])\\n        q = deque([(i, j)])\\n        grid[i][j] = mark\\n        islands = deque()\\n        while q:\\n            for _ in range(len(q)):\\n                i, j = q.pop()\\n                islands.appendleft((i,j))\\n                for x, y in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                    ni, nj = i + x, j + y\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:\\n                        grid[ni][nj] = mark\\n                        q.appendleft((ni, nj))\\n        return islands\\n    \\n    def connect(self, island, grid):\\n        m, n = len(grid), len(grid[0])\\n        for _ in range(len(island)):\\n            i, j = island.pop()\\n            for x, y in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                ni, nj = i + x, j + y\\n                if 0 <= ni < m and 0 <= nj < n:\\n                    if grid[ni][nj] == grid[i][j]:\\n                        continue\\n                    elif grid[ni][nj] == 0:\\n                        grid[ni][nj] = grid[i][j]\\n                        island.appendleft((ni, nj))\\n                    else:\\n                        return True\\n        return False\\n                        \\n        \\n                \\n                    \\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        #BFS to find the two islands and mark their cell as 2 and 3\\n        #Bidirectional BFS expanding two islands, record the count of two bfs levels, when one island touches the other, return the count of two bfs\\n        #O(n) time and space\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        mark = 2\\n        islands = []\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    islands.append(self.markIsland(i, j, grid, mark))\\n                    mark += 1\\n        flip = 0\\n        while True:\\n            for island in islands:\\n                if self.connect(island, grid):\\n                    return flip\\n                flip += 1\\n    \\n    def markIsland(self, i, j, grid, mark):\\n        m, n = len(grid), len(grid[0])\\n        q = deque([(i, j)])\\n        grid[i][j] = mark\\n        islands = deque()\\n        while q:\\n            for _ in range(len(q)):\\n                i, j = q.pop()\\n                islands.appendleft((i,j))\\n                for x, y in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                    ni, nj = i + x, j + y\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:\\n                        grid[ni][nj] = mark\\n                        q.appendleft((ni, nj))\\n        return islands\\n    \\n    def connect(self, island, grid):\\n        m, n = len(grid), len(grid[0])\\n        for _ in range(len(island)):\\n            i, j = island.pop()\\n            for x, y in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                ni, nj = i + x, j + y\\n                if 0 <= ni < m and 0 <= nj < n:\\n                    if grid[ni][nj] == grid[i][j]:\\n                        continue\\n                    elif grid[ni][nj] == 0:\\n                        grid[ni][nj] = grid[i][j]\\n                        island.appendleft((ni, nj))\\n                    else:\\n                        return True\\n        return False\\n                        \\n        \\n                \\n                    \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491234,
                "title": "clean-c-dfs-bfs-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int x[4]={0,1,0,-1};\\n    int y[4]={1,0,-1,0};\\n    void dfs(vector<vector<int>>& g,queue<pair<int,int>>&q,int r,int c,int m,int n){\\n        g[r][c]=2;\\n        q.push({r,c});\\n        \\n        for(int i=0;i<4;i++){\\n            int u=r+x[i];\\n            int v=c+y[i];\\n            if(u < 0 or v < 0 or u >= m or v >= n or g[u][v] == 0 or g[u][v] == 2)\\n                continue;\\n            dfs(g,q,u,v,m,n);\\n        }\\n    }\\n    int bfs(vector<vector<int>>& g,queue<pair<int,int>>&que,int m,int n){\\n        int cnt=0;\\n        while(!que.empty()){\\n            int sz=que.size();\\n            cnt++;\\n            while(sz--){\\n                int p=que.front().first;\\n                int q=que.front().second;\\n                que.pop();\\n                for(int i=0;i<4;i++){\\n                    int u=p+x[i],v=q+y[i];\\n                    if(u < 0 or v < 0 or u >= m or v >= n or g[u][v] == 2)\\n                        continue;\\n                \\n                    if(g[u][v]==1) return cnt-1;\\n                    \\n                    g[u][v]=2;\\n                    que.push({u,v});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    int shortestBridge(vector<vector<int>>& A) {\\n        int m=A.size();\\n        int n=A[0].size();\\n        queue<pair<int,int>>q;\\n        bool istrue=false;\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(A[i][j]==1){\\n                    dfs(A,q,i,j,m,n);\\n                    istrue=true;\\n                    break;\\n                }\\n            }\\n            if(istrue) break;\\n        }\\n        \\n        ans=bfs(A,q,m,n);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x[4]={0,1,0,-1};\\n    int y[4]={1,0,-1,0};\\n    void dfs(vector<vector<int>>& g,queue<pair<int,int>>&q,int r,int c,int m,int n){\\n        g[r][c]=2;\\n        q.push({r,c});\\n        \\n        for(int i=0;i<4;i++){\\n            int u=r+x[i];\\n            int v=c+y[i];\\n            if(u < 0 or v < 0 or u >= m or v >= n or g[u][v] == 0 or g[u][v] == 2)\\n                continue;\\n            dfs(g,q,u,v,m,n);\\n        }\\n    }\\n    int bfs(vector<vector<int>>& g,queue<pair<int,int>>&que,int m,int n){\\n        int cnt=0;\\n        while(!que.empty()){\\n            int sz=que.size();\\n            cnt++;\\n            while(sz--){\\n                int p=que.front().first;\\n                int q=que.front().second;\\n                que.pop();\\n                for(int i=0;i<4;i++){\\n                    int u=p+x[i],v=q+y[i];\\n                    if(u < 0 or v < 0 or u >= m or v >= n or g[u][v] == 2)\\n                        continue;\\n                \\n                    if(g[u][v]==1) return cnt-1;\\n                    \\n                    g[u][v]=2;\\n                    que.push({u,v});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    int shortestBridge(vector<vector<int>>& A) {\\n        int m=A.size();\\n        int n=A[0].size();\\n        queue<pair<int,int>>q;\\n        bool istrue=false;\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(A[i][j]==1){\\n                    dfs(A,q,i,j,m,n);\\n                    istrue=true;\\n                    break;\\n                }\\n            }\\n            if(istrue) break;\\n        }\\n        \\n        ans=bfs(A,q,m,n);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467748,
                "title": "clean-python-solution-bfs-and-dfs",
                "content": "1. We mark the first island with 2\\'s with the help of DFS function and let the second island stay as groups of 1\\'s\\n2. Using BFS we explore all the immediate neighbours of the 1st island and add them to the queue.\\n3. Whenever we come across a 0, we mark it as 3 which indicates a bridge and add it to the queue too in order to explore it\\'s neighbours.\\n4. After the above steps, if we encounter a \"1\" which means we have reached the second island and return the result.\\n\\n\\n```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        queue=collections.deque()\\n        row,column=self.get_first(grid)\\n        self.dfs(row,column,grid,queue)\\n        print(grid)\\n        dirs=[(0,1),(1,0),(-1,0),(0,-1)]\\n        res=0\\n        \\n        while queue:\\n            size=len(queue)\\n            for _ in range(size):\\n                current_row,current_column=queue.popleft()\\n                \\n                # if grid[current_row][current_column]==1:\\n                #     return res\\n                for dx,dy in dirs:\\n                    x=current_row+dx\\n                    y=current_column+dy\\n                    \\n                    if 0<=x<len(grid) and 0<=y<len(grid[0]):\\n                        if grid[x][y]==0:\\n                            grid[x][y]=3\\n                            queue.append((x,y))\\n                        elif grid[x][y]==1:\\n                            return res\\n            res+=1\\n                             \\n    \\n    def get_first(self,grid):\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    return i,j\\n                    \\n    \\n    def dfs(self,i,j,grid,queue):\\n        \\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]!=1:\\n            return \\n        \\n        grid[i][j]=2\\n        queue.append((i,j))\\n        self.dfs(i+1,j,grid,queue)\\n        self.dfs(i,j+1,grid,queue)\\n        self.dfs(i-1,j,grid,queue)\\n        self.dfs(i,j-1,grid,queue)\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        queue=collections.deque()\\n        row,column=self.get_first(grid)\\n        self.dfs(row,column,grid,queue)\\n        print(grid)\\n        dirs=[(0,1),(1,0),(-1,0),(0,-1)]\\n        res=0\\n        \\n        while queue:\\n            size=len(queue)\\n            for _ in range(size):\\n                current_row,current_column=queue.popleft()\\n                \\n                # if grid[current_row][current_column]==1:\\n                #     return res\\n                for dx,dy in dirs:\\n                    x=current_row+dx\\n                    y=current_column+dy\\n                    \\n                    if 0<=x<len(grid) and 0<=y<len(grid[0]):\\n                        if grid[x][y]==0:\\n                            grid[x][y]=3\\n                            queue.append((x,y))\\n                        elif grid[x][y]==1:\\n                            return res\\n            res+=1\\n                             \\n    \\n    def get_first(self,grid):\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    return i,j\\n                    \\n    \\n    def dfs(self,i,j,grid,queue):\\n        \\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]!=1:\\n            return \\n        \\n        grid[i][j]=2\\n        queue.append((i,j))\\n        self.dfs(i+1,j,grid,queue)\\n        self.dfs(i,j+1,grid,queue)\\n        self.dfs(i-1,j,grid,queue)\\n        self.dfs(i,j-1,grid,queue)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1422324,
                "title": "java-dfs-bfs-99-time",
                "content": "1. (DFS) We start with adding the positions of zeroes (the edges) around the first island we find to the queue\\n2. (BFS) We keep \"expanding the island\" until we hit the other island\\n```\\nprivate static final int[][] DIRS = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n\\npublic int shortestBridge(int[][] grid) {\\n\\tint R = grid.length, C = grid[0].length;\\n\\tQueue<int[]> queue = new LinkedList();\\n\\tboolean[][] visited = new boolean[R][C];\\n\\tboolean found = false;\\n\\tfor (int r = 0; !found && r < R; r++) {\\n\\t\\tfor (int c = 0; !found && c < C; c++) {\\n\\t\\t\\tif (grid[r][c] == 1) {\\n\\t\\t\\t\\tdfs(queue, grid, R, C, r, c, visited);\\n\\t\\t\\t\\tfound = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint step = 0;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tstep++;\\n\\t\\tfor (int i = queue.size() - 1; i >= 0; i--) {\\n\\t\\t\\tint[] p = queue.poll();\\n\\t\\t\\tfor (int d = 0; d < DIRS.length; d++) {\\n\\t\\t\\t\\tint nr = p[0] + DIRS[d][0], nc = p[1] + DIRS[d][1];\\n\\t\\t\\t\\tif (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc]) {\\n\\t\\t\\t\\t\\tif (grid[nr][nc] == 1) {\\n\\t\\t\\t\\t\\t\\treturn step;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvisited[nr][nc] = true;\\n\\t\\t\\t\\t\\tqueue.add(new int[]{nr, nc});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n\\nprivate void dfs(Queue<int[]> queue, int[][] grid, int R, int C, int r, int c, boolean[][] visited) {\\n\\tif (visited[r][c]) {\\n\\t\\treturn;\\n\\t}\\n\\tvisited[r][c] = true;\\n\\tfor (int i = 0; i < DIRS.length; i++) {\\n\\t\\tint nr = r + DIRS[i][0], nc = c + DIRS[i][1];\\n\\t\\tif (nr >= 0 && nr < R && nc >= 0 && nc < C) {\\n\\t\\t\\tif (grid[nr][nc] == 1) {\\n\\t\\t\\t\\tdfs(queue, grid, R, C, nr, nc, visited);\\n\\t\\t\\t} else if (!visited[nr][nc]) {\\n\\t\\t\\t\\tvisited[nr][nc] = true;\\n\\t\\t\\t\\tqueue.add(new int[]{nr, nc});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nprivate static final int[][] DIRS = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n\\npublic int shortestBridge(int[][] grid) {\\n\\tint R = grid.length, C = grid[0].length;\\n\\tQueue<int[]> queue = new LinkedList();\\n\\tboolean[][] visited = new boolean[R][C];\\n\\tboolean found = false;\\n\\tfor (int r = 0; !found && r < R; r++) {\\n\\t\\tfor (int c = 0; !found && c < C; c++) {\\n\\t\\t\\tif (grid[r][c] == 1) {\\n\\t\\t\\t\\tdfs(queue, grid, R, C, r, c, visited);\\n\\t\\t\\t\\tfound = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint step = 0;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tstep++;\\n\\t\\tfor (int i = queue.size() - 1; i >= 0; i--) {\\n\\t\\t\\tint[] p = queue.poll();\\n\\t\\t\\tfor (int d = 0; d < DIRS.length; d++) {\\n\\t\\t\\t\\tint nr = p[0] + DIRS[d][0], nc = p[1] + DIRS[d][1];\\n\\t\\t\\t\\tif (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc]) {\\n\\t\\t\\t\\t\\tif (grid[nr][nc] == 1) {\\n\\t\\t\\t\\t\\t\\treturn step;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvisited[nr][nc] = true;\\n\\t\\t\\t\\t\\tqueue.add(new int[]{nr, nc});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n\\nprivate void dfs(Queue<int[]> queue, int[][] grid, int R, int C, int r, int c, boolean[][] visited) {\\n\\tif (visited[r][c]) {\\n\\t\\treturn;\\n\\t}\\n\\tvisited[r][c] = true;\\n\\tfor (int i = 0; i < DIRS.length; i++) {\\n\\t\\tint nr = r + DIRS[i][0], nc = c + DIRS[i][1];\\n\\t\\tif (nr >= 0 && nr < R && nc >= 0 && nc < C) {\\n\\t\\t\\tif (grid[nr][nc] == 1) {\\n\\t\\t\\t\\tdfs(queue, grid, R, C, nr, nc, visited);\\n\\t\\t\\t} else if (!visited[nr][nc]) {\\n\\t\\t\\t\\tvisited[nr][nc] = true;\\n\\t\\t\\t\\tqueue.add(new int[]{nr, nc});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351128,
                "title": "java-multi-source-bfs-o-n-m-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        boolean flag = false;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for(int i = 0; i < n && !flag; i ++){\\n            for(int j = 0; j < m && !flag; j++){\\n                if(grid[i][j] == 1){\\n                    dfs(i, j, dir, queue, grid);\\n                    flag = true;\\n                }\\n            }\\n        }\\n        \\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int idx = queue.poll();\\n                int r = idx / m;\\n                int c = idx % m;\\n                \\n                for(int d = 0; d < dir.length; d++){\\n                    int x = r + dir[d][0];\\n                    int y = c + dir[d][1];\\n\\n                    if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] != 2){\\n                        if(grid[x][y] == 1)\\n                            return level;\\n                        queue.add(x * m + y);\\n                        grid[x][y] = 2;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    \\n    public static void dfs(int i, int j , int[][] dir, Queue<Integer> queue, int[][] grid){\\n        grid[i][j] = 2;\\n        queue.add(i * grid[0].length + j);\\n        \\n        for(int d = 0; d < dir.length; d++){\\n            int x = i + dir[d][0];\\n            int y = j + dir[d][1];\\n            \\n            if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 1){\\n                dfs(x, y, dir, queue, grid);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        boolean flag = false;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for(int i = 0; i < n && !flag; i ++){\\n            for(int j = 0; j < m && !flag; j++){\\n                if(grid[i][j] == 1){\\n                    dfs(i, j, dir, queue, grid);\\n                    flag = true;\\n                }\\n            }\\n        }\\n        \\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int idx = queue.poll();\\n                int r = idx / m;\\n                int c = idx % m;\\n                \\n                for(int d = 0; d < dir.length; d++){\\n                    int x = r + dir[d][0];\\n                    int y = c + dir[d][1];\\n\\n                    if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] != 2){\\n                        if(grid[x][y] == 1)\\n                            return level;\\n                        queue.add(x * m + y);\\n                        grid[x][y] = 2;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    \\n    public static void dfs(int i, int j , int[][] dir, Queue<Integer> queue, int[][] grid){\\n        grid[i][j] = 2;\\n        queue.add(i * grid[0].length + j);\\n        \\n        for(int d = 0; d < dir.length; d++){\\n            int x = i + dir[d][0];\\n            int y = j + dir[d][1];\\n            \\n            if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 1){\\n                dfs(x, y, dir, queue, grid);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251436,
                "title": "java-using-dfs-and-distance-formula-dfs-bfs",
                "content": "**Approach 1: Using DFS to fill both the island and calculating  distance using distance formula [12ms]**\\n```\\nclass Node{\\n    int r,c;\\n    public Node(int r, int c){\\n        this.r = r;\\n        this.c = c;\\n    }\\n}\\nclass Solution {\\n    // val = +/-1 -> for island 1\\n    //       +/-2 -> for island 2\\n    // Minus sign for denoting a border\\n    // border is defined as cell whose next cell (either from the 4 directions) contains water i.e 0\\n    \\n    // Directions\\n    int[] x = {-1,1,0,0}; // left, right, up, down\\n    int[] y = {0,0,1,-1};\\n    \\n    // filling island with val i.e visiting all adjacent island and marking it with \"val\"\\n    public boolean dfs(int[][] grid, int i, int j, int n, int val){\\n        if(i<0||i>=n || j<0||j>=n || grid[i][j]==val || grid[i][j]==-val){ // return false, if cell is visited i.e either border or under border land\\n            return false;\\n        }\\n        if(grid[i][j]==0)\\n            return true;\\n        // visit only those cells which are 1\\n        grid[i][j] = val;\\n        for(int k=0;k<4;k++){\\n            if(dfs(grid, i+y[k], j+x[k], n, val)) // if dfs returns true means next cell is water, so (i,j) must be border\\n                grid[i][j] = -val;\\n        }\\n        return false;\\n    }\\n    public int shortestBridge(int[][] grid) {\\n        if(grid==null || grid.length < 2)\\n            return -1;\\n        int val = 2; // for island 1\\n        //  under border area will be +val\\n        //  border will  be -val\\n        // Example -> \\n        /*\\n             2 -2  2 -2  2\\n            -2  0 -2  0 -2\\n             0  0  0  0  0\\n            -3 -3  0 -3 -3\\n             3  3 -3  3  3\\n             \\n             Border of island 1 = (1,0) (0,1) (1,2) (0,3) (1,4)\\n             Border of island 2 = (3,0) (3,1) (4,2) (3,3) (3,4)\\n             Distance from each border = abs(r1-r2) + abs(c1-c2); // since one cell has four options to move\\n        */\\n        int n = grid.length;\\n        List<Node> border_1 = new LinkedList<>();\\n        List<Node> border_2 = new LinkedList<>();\\n        // storing border of islands\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    dfs(grid, i, j, n, val);\\n                    val++;\\n                }\\n                if(grid[i][j]==-2)\\n                    border_1.add(new Node(i, j));\\n                if(grid[i][j]==-3)\\n                    border_2.add(new Node(i, j));\\n            }\\n        }\\n        int min = Integer.MAX_VALUE;\\n        Iterator<Node> b1 = border_1.iterator();\\n        while(b1.hasNext()){\\n            Node island1 = b1.next();\\n            Iterator<Node> b2 = border_2.iterator();\\n            while(b2.hasNext()){\\n                Node island2 = b2.next();\\n                int dist = Math.abs(island1.r-island2.r) + Math.abs(island1.c-island2.c);\\n                min = Math.min(min, dist);\\n            }\\n        }\\n        return min-1; // minus 1 because the distance will contain border also\\n    }\\n}\\n```\\n**Approach 2: Using DFS and BFS [6ms]**\\n```\\nclass Node{\\n    int r,c;\\n    public Node(int r, int c){\\n        this.r = r;\\n        this.c = c;\\n    }\\n}\\nclass Solution {\\n    // Directions\\n    int[] x = {-1,1,0,0}; // left, right, up, down\\n    int[] y = {0,0,1,-1};\\n    public void fill(int[][] grid, int i, int j, int n, Queue<Node> queue){\\n        if(i<0 || i>=n || j<0 || j>=n || grid[i][j]!=1) // if not valid index or not land\\n            return;\\n        queue.add(new Node(i, j));\\n        grid[i][j] = 2; // visited\\n        for(int k=0;k<4;k++){\\n            fill(grid, i+y[k], j+x[k], n, queue);\\n        }\\n    }\\n    public int shortestBridge(int[][] grid) {\\n        if(grid==null || grid.length < 2)\\n            return -1;\\n        int n = grid.length;\\n        Queue<Node> queue = new LinkedList<>();\\n        boolean found = false;\\n        // just fill one island\\n         for(int i=0; i<n && !found; i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    fill(grid, i, j, n, queue);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int level = 0; // search level == approaching distance to next island\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-->0){\\n                Node node = queue.poll();\\n                for(int k=0;k<4;k++){\\n                    int i = node.r + y[k];\\n                    int j = node.c + x[k];\\n                    if(i<0 || i>=n || j<0 || j>=n || grid[i][j]==2)\\n                        continue;\\n                    if(grid[i][j]==1)\\n                        return level;\\n                    grid[i][j] = 2; // visit it\\n                    queue.add(new Node(i, j));\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Node{\\n    int r,c;\\n    public Node(int r, int c){\\n        this.r = r;\\n        this.c = c;\\n    }\\n}\\nclass Solution {\\n    // val = +/-1 -> for island 1\\n    //       +/-2 -> for island 2\\n    // Minus sign for denoting a border\\n    // border is defined as cell whose next cell (either from the 4 directions) contains water i.e 0\\n    \\n    // Directions\\n    int[] x = {-1,1,0,0}; // left, right, up, down\\n    int[] y = {0,0,1,-1};\\n    \\n    // filling island with val i.e visiting all adjacent island and marking it with \"val\"\\n    public boolean dfs(int[][] grid, int i, int j, int n, int val){\\n        if(i<0||i>=n || j<0||j>=n || grid[i][j]==val || grid[i][j]==-val){ // return false, if cell is visited i.e either border or under border land\\n            return false;\\n        }\\n        if(grid[i][j]==0)\\n            return true;\\n        // visit only those cells which are 1\\n        grid[i][j] = val;\\n        for(int k=0;k<4;k++){\\n            if(dfs(grid, i+y[k], j+x[k], n, val)) // if dfs returns true means next cell is water, so (i,j) must be border\\n                grid[i][j] = -val;\\n        }\\n        return false;\\n    }\\n    public int shortestBridge(int[][] grid) {\\n        if(grid==null || grid.length < 2)\\n            return -1;\\n        int val = 2; // for island 1\\n        //  under border area will be +val\\n        //  border will  be -val\\n        // Example -> \\n        /*\\n             2 -2  2 -2  2\\n            -2  0 -2  0 -2\\n             0  0  0  0  0\\n            -3 -3  0 -3 -3\\n             3  3 -3  3  3\\n             \\n             Border of island 1 = (1,0) (0,1) (1,2) (0,3) (1,4)\\n             Border of island 2 = (3,0) (3,1) (4,2) (3,3) (3,4)\\n             Distance from each border = abs(r1-r2) + abs(c1-c2); // since one cell has four options to move\\n        */\\n        int n = grid.length;\\n        List<Node> border_1 = new LinkedList<>();\\n        List<Node> border_2 = new LinkedList<>();\\n        // storing border of islands\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    dfs(grid, i, j, n, val);\\n                    val++;\\n                }\\n                if(grid[i][j]==-2)\\n                    border_1.add(new Node(i, j));\\n                if(grid[i][j]==-3)\\n                    border_2.add(new Node(i, j));\\n            }\\n        }\\n        int min = Integer.MAX_VALUE;\\n        Iterator<Node> b1 = border_1.iterator();\\n        while(b1.hasNext()){\\n            Node island1 = b1.next();\\n            Iterator<Node> b2 = border_2.iterator();\\n            while(b2.hasNext()){\\n                Node island2 = b2.next();\\n                int dist = Math.abs(island1.r-island2.r) + Math.abs(island1.c-island2.c);\\n                min = Math.min(min, dist);\\n            }\\n        }\\n        return min-1; // minus 1 because the distance will contain border also\\n    }\\n}\\n```\n```\\nclass Node{\\n    int r,c;\\n    public Node(int r, int c){\\n        this.r = r;\\n        this.c = c;\\n    }\\n}\\nclass Solution {\\n    // Directions\\n    int[] x = {-1,1,0,0}; // left, right, up, down\\n    int[] y = {0,0,1,-1};\\n    public void fill(int[][] grid, int i, int j, int n, Queue<Node> queue){\\n        if(i<0 || i>=n || j<0 || j>=n || grid[i][j]!=1) // if not valid index or not land\\n            return;\\n        queue.add(new Node(i, j));\\n        grid[i][j] = 2; // visited\\n        for(int k=0;k<4;k++){\\n            fill(grid, i+y[k], j+x[k], n, queue);\\n        }\\n    }\\n    public int shortestBridge(int[][] grid) {\\n        if(grid==null || grid.length < 2)\\n            return -1;\\n        int n = grid.length;\\n        Queue<Node> queue = new LinkedList<>();\\n        boolean found = false;\\n        // just fill one island\\n         for(int i=0; i<n && !found; i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    fill(grid, i, j, n, queue);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int level = 0; // search level == approaching distance to next island\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-->0){\\n                Node node = queue.poll();\\n                for(int k=0;k<4;k++){\\n                    int i = node.r + y[k];\\n                    int j = node.c + x[k];\\n                    if(i<0 || i>=n || j<0 || j>=n || grid[i][j]==2)\\n                        continue;\\n                    if(grid[i][j]==1)\\n                        return level;\\n                    grid[i][j] = 2; // visit it\\n                    queue.add(new Node(i, j));\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202329,
                "title": "java-solution-with-explanation-dfs-plus-bfs",
                "content": "Here we will find first island using DFS and mark all the elements as 2 and will put all the island into a queue . From all these locations , we will find another island and find the min distance connecting them using BFS \\n\\n```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        \\n        boolean marked=false;\\n        Queue<Pair<Integer,Integer>> q=new LinkedList<>();\\n        \\n        int bridge=0;\\n        \\n        for(int i=0;i<A.length;i++){\\n            \\n            if(marked) break;\\n            \\n            for(int j=0;j<A[0].length;j++){\\n                if(A[i][j]==1){\\n                    dfs(A,i,j,q);\\n                    marked=true;\\n                }\\n                if(marked) break;\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            int n=q.size();\\n            \\n            System.out.println(\"here\"+n);\\n\\n            for(int i=0;i<n;i++){\\n                Pair<Integer,Integer> pair=q.poll();\\n                \\n                int r=pair.getKey();\\n                int c=pair.getValue();\\n                \\n                if(r+1<A.length && A[r+1][c]==0){\\n                    q.add(new Pair(r+1,c));\\n                    A[r+1][c]=2;\\n                }\\n                if(r-1>=0 && A[r-1][c]==0){\\n                    q.add(new Pair(r+1,c));\\n                    A[r-1][c]=2;\\n                }\\n                if(c+1<A[0].length && A[r][c+1]==0){\\n                    q.add(new Pair(r,c+1));\\n                    A[r][c+1]=2;\\n                }\\n                if(c-1>=0 && A[r][c-1]==0){\\n                    q.add(new Pair(r,c-1));\\n                    A[r][c-1]=2;\\n                }\\n                \\n                if((r+1<A.length && A[r+1][c]==1) || \\n                   (r-1>=0 && A[r-1][c]==1) || \\n                   (c+1<A[0].length && A[r][c+1]==1)|| \\n                   (c-1>=0 && A[r][c-1]==1)) return bridge;\\n                \\n            }\\n            bridge++;\\n        }\\n        \\n        return 0;\\n    }\\n        \\n        \\n        \\n        \\n    \\n    \\n    public void dfs(int[][] A , int row, int col,Queue<Pair<Integer,Integer>> q){\\n        if(row<0 || col<0 || row==A.length || col==A[0].length || A[row][col]!=1) return ;\\n        \\n        A[row][col]=2;\\n        q.add(new Pair(row,col));\\n        dfs(A,row+1,col,q);\\n        dfs(A,row-1,col,q);\\n        dfs(A,row,col+1,q);\\n        dfs(A,row,col-1,q);\\n    }\\n    \\n    \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        \\n        boolean marked=false;\\n        Queue<Pair<Integer,Integer>> q=new LinkedList<>();\\n        \\n        int bridge=0;\\n        \\n        for(int i=0;i<A.length;i++){\\n            \\n            if(marked) break;\\n            \\n            for(int j=0;j<A[0].length;j++){\\n                if(A[i][j]==1){\\n                    dfs(A,i,j,q);\\n                    marked=true;\\n                }\\n                if(marked) break;\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            int n=q.size();\\n            \\n            System.out.println(\"here\"+n);\\n\\n            for(int i=0;i<n;i++){\\n                Pair<Integer,Integer> pair=q.poll();\\n                \\n                int r=pair.getKey();\\n                int c=pair.getValue();\\n                \\n                if(r+1<A.length && A[r+1][c]==0){\\n                    q.add(new Pair(r+1,c));\\n                    A[r+1][c]=2;\\n                }\\n                if(r-1>=0 && A[r-1][c]==0){\\n                    q.add(new Pair(r+1,c));\\n                    A[r-1][c]=2;\\n                }\\n                if(c+1<A[0].length && A[r][c+1]==0){\\n                    q.add(new Pair(r,c+1));\\n                    A[r][c+1]=2;\\n                }\\n                if(c-1>=0 && A[r][c-1]==0){\\n                    q.add(new Pair(r,c-1));\\n                    A[r][c-1]=2;\\n                }\\n                \\n                if((r+1<A.length && A[r+1][c]==1) || \\n                   (r-1>=0 && A[r-1][c]==1) || \\n                   (c+1<A[0].length && A[r][c+1]==1)|| \\n                   (c-1>=0 && A[r][c-1]==1)) return bridge;\\n                \\n            }\\n            bridge++;\\n        }\\n        \\n        return 0;\\n    }\\n        \\n        \\n        \\n        \\n    \\n    \\n    public void dfs(int[][] A , int row, int col,Queue<Pair<Integer,Integer>> q){\\n        if(row<0 || col<0 || row==A.length || col==A[0].length || A[row][col]!=1) return ;\\n        \\n        A[row][col]=2;\\n        q.add(new Pair(row,col));\\n        dfs(A,row+1,col,q);\\n        dfs(A,row-1,col,q);\\n        dfs(A,row,col+1,q);\\n        dfs(A,row,col-1,q);\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185314,
                "title": "clean-dfs-bfs-solution-with-explanation-python",
                "content": "Algorithm:\\n\\n1) Find the coordinate of a point that is a part of an island.\\n2) Using Depth-First Search turn every point that is part of the first island to 2 and add the coordinate to the visited set and the deque.\\n3) Using Breath-First Search find the shortest path from the first island to the second island.\\n4) Once any point that is part of the second island is found we stop the algorithm and return the coordinate\\n\\nTime Complexity: O(R * C)\\nSpace Complexity: O(R * C)\\n\\n\\n\\tclass Solution:\\n\\t\\t\\tdef shortestBridge(self, A: List[List[int]]) -> int:     \\n\\t\\t\\t\\tdef dfs(r, c):\\n\\t\\t\\t\\t\\tif r < 0 or c < 0 or r >= len(A) or c >= len(A[0]) or A[r][c] == 0 or A[r][c] == 2:\\n\\t\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\t\\tA[r][c] = 2\\n\\t\\t\\t\\t\\tvisited.add((r, c))\\n\\t\\t\\t\\t\\tqueue.append((r, c, 0))\\n\\n\\t\\t\\t\\t\\tdfs(r + 1, c)\\n\\t\\t\\t\\t\\tdfs(r - 1, c)\\n\\t\\t\\t\\t\\tdfs(r, c + 1)\\n\\t\\t\\t\\t\\tdfs(r, c - 1)\\n\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\tqueue = deque([])\\n\\t\\t\\t\\tnumRows = len(A)\\n\\t\\t\\t\\tnumCols = len(A[0])\\n\\t\\t\\t\\tdirections = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\t\\t\\t\\tflag = False\\n\\n\\t\\t\\t\\tfor r in range(numRows):\\n\\t\\t\\t\\t\\tfor c in range(numCols):\\n\\t\\t\\t\\t\\t\\tif A[r][c] == 1:\\n\\t\\t\\t\\t\\t\\t\\tdfs(r, c)\\n\\t\\t\\t\\t\\t\\t\\tflag = True\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\tif flag == True:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\twhile queue:\\n\\t\\t\\t\\t\\tr, c, steps = queue.popleft()\\n\\n\\t\\t\\t\\t\\tif A[r][c] == 1:\\n\\t\\t\\t\\t\\t\\treturn steps - 1\\n\\n\\t\\t\\t\\t\\tfor direct in directions:\\n\\t\\t\\t\\t\\t\\trow = r + direct[0]\\n\\t\\t\\t\\t\\t\\tcol = c + direct[1]\\n\\n\\t\\t\\t\\t\\t\\tif row >= 0 and col >= 0 and row < numRows and col < numCols and (row, col) not in visited:\\n\\t\\t\\t\\t\\t\\t\\tvisited.add((row, col))\\n\\t\\t\\t\\t\\t\\t\\tqueue.append((row, col, steps + 1))",
                "solutionTags": [],
                "code": "Algorithm:\\n\\n1) Find the coordinate of a point that is a part of an island.\\n2) Using Depth-First Search turn every point that is part of the first island to 2 and add the coordinate to the visited set and the deque.\\n3) Using Breath-First Search find the shortest path from the first island to the second island.\\n4) Once any point that is part of the second island is found we stop the algorithm and return the coordinate\\n\\nTime Complexity: O(R * C)\\nSpace Complexity: O(R * C)\\n\\n\\n\\tclass Solution:\\n\\t\\t\\tdef shortestBridge(self, A: List[List[int]]) -> int:     \\n\\t\\t\\t\\tdef dfs(r, c):\\n\\t\\t\\t\\t\\tif r < 0 or c < 0 or r >= len(A) or c >= len(A[0]) or A[r][c] == 0 or A[r][c] == 2:\\n\\t\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\t\\tA[r][c] = 2\\n\\t\\t\\t\\t\\tvisited.add((r, c))\\n\\t\\t\\t\\t\\tqueue.append((r, c, 0))\\n\\n\\t\\t\\t\\t\\tdfs(r + 1, c)\\n\\t\\t\\t\\t\\tdfs(r - 1, c)\\n\\t\\t\\t\\t\\tdfs(r, c + 1)\\n\\t\\t\\t\\t\\tdfs(r, c - 1)\\n\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\tqueue = deque([])\\n\\t\\t\\t\\tnumRows = len(A)\\n\\t\\t\\t\\tnumCols = len(A[0])\\n\\t\\t\\t\\tdirections = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\t\\t\\t\\tflag = False\\n\\n\\t\\t\\t\\tfor r in range(numRows):\\n\\t\\t\\t\\t\\tfor c in range(numCols):\\n\\t\\t\\t\\t\\t\\tif A[r][c] == 1:\\n\\t\\t\\t\\t\\t\\t\\tdfs(r, c)\\n\\t\\t\\t\\t\\t\\t\\tflag = True\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\tif flag == True:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\twhile queue:\\n\\t\\t\\t\\t\\tr, c, steps = queue.popleft()\\n\\n\\t\\t\\t\\t\\tif A[r][c] == 1:\\n\\t\\t\\t\\t\\t\\treturn steps - 1\\n\\n\\t\\t\\t\\t\\tfor direct in directions:\\n\\t\\t\\t\\t\\t\\trow = r + direct[0]\\n\\t\\t\\t\\t\\t\\tcol = c + direct[1]\\n\\n\\t\\t\\t\\t\\t\\tif row >= 0 and col >= 0 and row < numRows and col < numCols and (row, col) not in visited:\\n\\t\\t\\t\\t\\t\\t\\tvisited.add((row, col))\\n\\t\\t\\t\\t\\t\\t\\tqueue.append((row, col, steps + 1))",
                "codeTag": "Java"
            },
            {
                "id": 1105606,
                "title": "python-expand-one-island-with-visualization-easy-understand",
                "content": "```\\nclass Solution:\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        \"\"\"\\n        Idea is to expend one island by 4 firection. Level by level. \\n        Firstly, DFS to find all first island, add to queue\\n        Secondly, BFS travel level by level\\n        example:\\n            1 1 0 0 0\\n            1 0 0 0 0\\n            1 0 0 0 2\\n            0 0 0 0 2\\n            \\n            level = 0  ( X = in Seen)\\n            1 1[X]0 0\\n            1[X]0 0 0\\n            1[X]0 0 1\\n           [X]0 0 0 1\\n            \\n            level = 1  ( X = in Seen)\\n            1 1 X[X]0\\n            1 X[X]0 0\\n            1 X[X]0 1\\n            X[X]0 0 1\\n            \\n            level = 2  ( X = in Seen)\\n            1 1 X X[X]\\n            1 X X[X]0\\n            1 X X[X]1\\n            X X[X]0 1\\n            \\n            level = 3  ( X = in Seen)\\n            1 1 X X X\\n            1 X X X[X]\\n            1 X X X [1] <- found another 1 return level = 3\\n            X X X X 1\\n        \\n        \"\"\"\\n        \\n        seen, N, M, q = set(), len(A), len(A[0]), []\\n        \\n        def dfs(i,j):\\n            if (i,j) in seen or not(0<=i<N and 0<=j<M) or A[i][j]==0:\\n                return\\n            q.append((i,j))\\n            seen.add((i,j))\\n            dfs(i+1,j)\\n            dfs(i-1,j)\\n            dfs(i,j+1)\\n            dfs(i,j-1)\\n            \\n        \\n        foundFirst1 = False\\n        for x in range(N):\\n            for y in range(M):\\n                if A[x][y] == 1:\\n                    foundFirst1 = True\\n                    dfs(x,y)\\n                    break\\n            if foundFirst1:\\n                break\\n        \\n        # now q has all 1 for one island:\\n        level = 0\\n        directions = [(0,1), (0,-1), (1,0), (-1,0)]\\n        \\n        while(True):\\n            nextq = []\\n            for (i, j) in q:\\n                for di,dj in directions:\\n                    if (i+di, j+dj) not in seen and 0<=i+di<N and 0<=j+dj<M:\\n                        if A[i+di][j+dj] == 1:\\n                            return level\\n                        else:\\n                            seen.add((i+di, j+dj))\\n                            nextq.append((i+di, j+dj))\\n            level+=1\\n            q = nextq\\n        return level\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, A: List[List[int]]) -> int:\\n        \"\"\"\\n        Idea is to expend one island by 4 firection. Level by level. \\n        Firstly, DFS to find all first island, add to queue\\n        Secondly, BFS travel level by level\\n        example:\\n            1 1 0 0 0\\n            1 0 0 0 0\\n            1 0 0 0 2\\n            0 0 0 0 2\\n            \\n            level = 0  ( X = in Seen)\\n            1 1[X]0 0\\n            1[X]0 0 0\\n            1[X]0 0 1\\n           [X]0 0 0 1\\n            \\n            level = 1  ( X = in Seen)\\n            1 1 X[X]0\\n            1 X[X]0 0\\n            1 X[X]0 1\\n            X[X]0 0 1\\n            \\n            level = 2  ( X = in Seen)\\n            1 1 X X[X]\\n            1 X X[X]0\\n            1 X X[X]1\\n            X X[X]0 1\\n            \\n            level = 3  ( X = in Seen)\\n            1 1 X X X\\n            1 X X X[X]\\n            1 X X X [1] <- found another 1 return level = 3\\n            X X X X 1\\n        \\n        \"\"\"\\n        \\n        seen, N, M, q = set(), len(A), len(A[0]), []\\n        \\n        def dfs(i,j):\\n            if (i,j) in seen or not(0<=i<N and 0<=j<M) or A[i][j]==0:\\n                return\\n            q.append((i,j))\\n            seen.add((i,j))\\n            dfs(i+1,j)\\n            dfs(i-1,j)\\n            dfs(i,j+1)\\n            dfs(i,j-1)\\n            \\n        \\n        foundFirst1 = False\\n        for x in range(N):\\n            for y in range(M):\\n                if A[x][y] == 1:\\n                    foundFirst1 = True\\n                    dfs(x,y)\\n                    break\\n            if foundFirst1:\\n                break\\n        \\n        # now q has all 1 for one island:\\n        level = 0\\n        directions = [(0,1), (0,-1), (1,0), (-1,0)]\\n        \\n        while(True):\\n            nextq = []\\n            for (i, j) in q:\\n                for di,dj in directions:\\n                    if (i+di, j+dj) not in seen and 0<=i+di<N and 0<=j+dj<M:\\n                        if A[i+di][j+dj] == 1:\\n                            return level\\n                        else:\\n                            seen.add((i+di, j+dj))\\n                            nextq.append((i+di, j+dj))\\n            level+=1\\n            q = nextq\\n        return level\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874487,
                "title": "java-dfs-bfs-3-clear-steps",
                "content": "Important notice : You can combine Step 1 & Step 2 together but I just left like this for clear explanation.\\n```\\nclass Solution {\\n    static int[][] DIR = new int[][] {{1, 0}, {-1, 0}, {0 , 1}, {0 , -1}};\\n    public int shortestBridge(int[][] A) {\\n        \\n        //Step 1: Identify one of the islands using dfs and assign 2 to it.\\n        boolean identified  = false;\\n        int n = A.length;\\n        for(int i = 0; i < n && !identified; i++) {\\n            for(int j = 0; j < n; j++){\\n                if (A[i][j] == 1) {\\n                    dfs(A, i, j);\\n                    identified = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // Step 2: Add all points of island 1 to Queue (initialize BFS)\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        Set<String> visited = new HashSet<String>();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++){\\n                if (A[i][j] == 1) {\\n                    queue.add(new int[]{i, j});\\n                    visited.add(i + \",\" + j);\\n                }\\n            }\\n        }\\n        \\n        // Step 3: BFS to find island 2\\n        int steps = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 1; i <= size; i++){\\n                int[] current = queue.poll();\\n                for(int j = 0; j < DIR.length; j++){\\n                    int x = current[0] + DIR[j][0];\\n                    int y = current[1] + DIR[j][1];\\n                    if(x < 0 || x >= n || y < 0 || y >= n || visited.contains(x + \",\" + y)){\\n                        continue;\\n                    }\\n                    if (A[x][y] == 2) { // Found island 2\\n                        return steps;\\n                    }\\n                    queue.add(new int[]{x, y});\\n                    visited.add(x + \",\" + y);\\n                }\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n    \\n    public void dfs(int[][] A, int i, int j) {\\n        if (i < 0 || i == A.length || j < 0 || j == A.length || A[i][j] != 1) \\n            return;\\n        A[i][j] = 2;\\n        dfs(A, i + 1,j);\\n        dfs(A, i - 1, j);\\n        dfs(A, i, j + 1);\\n        dfs(A, i, j - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int[][] DIR = new int[][] {{1, 0}, {-1, 0}, {0 , 1}, {0 , -1}};\\n    public int shortestBridge(int[][] A) {\\n        \\n        //Step 1: Identify one of the islands using dfs and assign 2 to it.\\n        boolean identified  = false;\\n        int n = A.length;\\n        for(int i = 0; i < n && !identified; i++) {\\n            for(int j = 0; j < n; j++){\\n                if (A[i][j] == 1) {\\n                    dfs(A, i, j);\\n                    identified = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // Step 2: Add all points of island 1 to Queue (initialize BFS)\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        Set<String> visited = new HashSet<String>();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++){\\n                if (A[i][j] == 1) {\\n                    queue.add(new int[]{i, j});\\n                    visited.add(i + \",\" + j);\\n                }\\n            }\\n        }\\n        \\n        // Step 3: BFS to find island 2\\n        int steps = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 1; i <= size; i++){\\n                int[] current = queue.poll();\\n                for(int j = 0; j < DIR.length; j++){\\n                    int x = current[0] + DIR[j][0];\\n                    int y = current[1] + DIR[j][1];\\n                    if(x < 0 || x >= n || y < 0 || y >= n || visited.contains(x + \",\" + y)){\\n                        continue;\\n                    }\\n                    if (A[x][y] == 2) { // Found island 2\\n                        return steps;\\n                    }\\n                    queue.add(new int[]{x, y});\\n                    visited.add(x + \",\" + y);\\n                }\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n    \\n    public void dfs(int[][] A, int i, int j) {\\n        if (i < 0 || i == A.length || j < 0 || j == A.length || A[i][j] != 1) \\n            return;\\n        A[i][j] = 2;\\n        dfs(A, i + 1,j);\\n        dfs(A, i - 1, j);\\n        dfs(A, i, j + 1);\\n        dfs(A, i, j - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679347,
                "title": "java-4ms-faster-than-100-bfs-through-onion-layers",
                "content": "```\\nclass Solution {\\n    public int shortestBridge(int[][] a) {\\n        for (int i = 0; i < a.length; i++) {\\n            for (int j = 0; j < a.length; j++) {\\n                if (a[i][j] != 1) continue;\\n                dfs(a, i, j);\\n                return bfs(a);\\n            }\\n        }\\n        \\n        throw new RuntimeException();\\n    }\\n    \\n    private void dfs(int[][] a, int i, int j) {\\n        if (i < 0 || j < 0 || i == a.length || j == a.length || a[i][j] != 1) return;\\n        \\n        a[i][j] = 2;\\n        \\n        dfs(a, i - 1, j);\\n        dfs(a, i + 1, j);\\n        dfs(a, i, j - 1);\\n        dfs(a, i, j + 1);\\n    }\\n    \\n    private int bfs(int[][] a) {\\n        int currentLayer = 1;\\n        while (true) {\\n            currentLayer++;\\n            for (int i = 0; i < a.length; i++) {\\n                for (int j = 0; j < a.length; j++) {\\n                    if (a[i][j] == currentLayer) {\\n                        if (\\n                            (i > 0 && a[i-1][j] == 1) ||\\n                            (i < a.length-1 && a[i+1][j] == 1) ||\\n                            (j > 0 && a[i][j-1] == 1) ||\\n                            (j < a.length-1 && a[i][j+1] == 1)\\n                        ) return currentLayer - 2;\\n\\n                        if (i > 0 && a[i-1][j] == 0) a[i-1][j] = currentLayer+1;\\n                        if (i < a.length-1 && a[i+1][j] == 0) a[i+1][j] = currentLayer+1;\\n                        if (j > 0 && a[i][j-1] == 0) a[i][j-1] = currentLayer+1;\\n                        if (j < a.length-1 && a[i][j+1] == 0) a[i][j+1] = currentLayer+1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] a) {\\n        for (int i = 0; i < a.length; i++) {\\n            for (int j = 0; j < a.length; j++) {\\n                if (a[i][j] != 1) continue;\\n                dfs(a, i, j);\\n                return bfs(a);\\n            }\\n        }\\n        \\n        throw new RuntimeException();\\n    }\\n    \\n    private void dfs(int[][] a, int i, int j) {\\n        if (i < 0 || j < 0 || i == a.length || j == a.length || a[i][j] != 1) return;\\n        \\n        a[i][j] = 2;\\n        \\n        dfs(a, i - 1, j);\\n        dfs(a, i + 1, j);\\n        dfs(a, i, j - 1);\\n        dfs(a, i, j + 1);\\n    }\\n    \\n    private int bfs(int[][] a) {\\n        int currentLayer = 1;\\n        while (true) {\\n            currentLayer++;\\n            for (int i = 0; i < a.length; i++) {\\n                for (int j = 0; j < a.length; j++) {\\n                    if (a[i][j] == currentLayer) {\\n                        if (\\n                            (i > 0 && a[i-1][j] == 1) ||\\n                            (i < a.length-1 && a[i+1][j] == 1) ||\\n                            (j > 0 && a[i][j-1] == 1) ||\\n                            (j < a.length-1 && a[i][j+1] == 1)\\n                        ) return currentLayer - 2;\\n\\n                        if (i > 0 && a[i-1][j] == 0) a[i-1][j] = currentLayer+1;\\n                        if (i < a.length-1 && a[i+1][j] == 0) a[i+1][j] = currentLayer+1;\\n                        if (j > 0 && a[i][j-1] == 0) a[i][j-1] = currentLayer+1;\\n                        if (j < a.length-1 && a[i][j+1] == 0) a[i][j+1] = currentLayer+1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671134,
                "title": "c",
                "content": "1. identify the first island and the 0 surround it.\\n2. BFS to detect the shortest path to the second island.\\n\\n```\\npublic class Solution {\\n    public int ShortestBridge(int[][] A) {\\n        if (A == null || A.Length == 0)\\n            return 0;\\n        \\n        int result = Int32.MaxValue,\\n            i = 0,\\n            j = 0;\\n        int[] dx = new int[] { 0, 0, 1, -1 },\\n              dy = new int[] { 1, -1, 0, 0 };\\n        Queue<int[]> q1 = new Queue<int[]>();\\n        Queue<Tuple<int[], int>> q2 = new Queue<Tuple<int[], int>>();\\n        bool[,] visited = new bool[A.Length, A[0].Length];\\n        \\n        for (i = 0; i < A.Length; i++)\\n        {\\n            for (j = 0; j < A[0].Length; j++)\\n                if (A[i][j] == 1)\\n                    break;\\n            \\n            if (j < A[0].Length && A[i][j] == 1)\\n                break;\\n        }\\n        \\n        A[i][j] = 2;\\n        q1.Enqueue(new int[] { i, j });\\n                    \\n        while (q1.Count > 0)\\n        {\\n            int[] cur = q1.Dequeue();\\n                        \\n            for (int k = 0; k < 4; k++)\\n            {\\n                int newX = cur[0] + dx[k],\\n                    newY = cur[1] + dy[k];\\n                            \\n                if (newX > -1 && newX < A.Length && newY > -1 && newY < A[0].Length && !visited[newX, newY])\\n                {\\n                    visited[newX, newY] = true;\\n                                \\n                    if (A[newX][newY] == 1)\\n                    {\\n                        A[newX][newY] = 2;\\n                        q1.Enqueue(new int[] { newX, newY });\\n                    }\\n                    else if (A[newX][newY] == 0)\\n                        q2.Enqueue(new Tuple<int[], int>(new int[] { newX, newY }, 1));\\n                }\\n            }\\n        }\\n        \\n        while (q2.Count > 0)\\n        {\\n            var cur = q2.Dequeue();\\n            \\n            for (int k = 0; k < 4; k++)\\n            {\\n                int newX = cur.Item1[0] + dx[k],\\n                    newY = cur.Item1[1] + dy[k];\\n                \\n                if (newX > -1 && newX < A.Length && newY > -1 && newY < A[0].Length && !visited[newX, newY])\\n                {\\n                    visited[newX, newY] = true;\\n                    \\n                    if (A[newX][newY] == 1)\\n                        result = Math.Min(result, cur.Item2);\\n                    else if (A[newX][newY] == 0)\\n                        q2.Enqueue(new Tuple<int[], int> (new int[] { newX, newY }, cur.Item2 + 1));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int ShortestBridge(int[][] A) {\\n        if (A == null || A.Length == 0)\\n            return 0;\\n        \\n        int result = Int32.MaxValue,\\n            i = 0,\\n            j = 0;\\n        int[] dx = new int[] { 0, 0, 1, -1 }",
                "codeTag": "Java"
            },
            {
                "id": 467218,
                "title": "java-dfs-bfs",
                "content": "```\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        int ans=0;\\n        boolean finish=false;\\n        for(int row=0;row<grid.length;row++){\\n            for(int col=0;col<grid[0].length;col++){\\n                if(grid[row][col]==1){\\n                    dfs(grid,row,col); //change to 2\\n                    finish=true;\\n                    break;\\n                }\\n            }\\n            if(finish){\\n                break;\\n            }\\n        }\\n        boolean hasone=false;\\n        for(int row=0;row<grid.length;row++){\\n            for(int col=0;col<grid[0].length;col++){\\n                if(grid[row][col]==1){\\n                    hasone=true;\\n                }\\n            }\\n        }\\n        if(!hasone){\\n            return 0; //make sure at least one seperate\\n        }\\n        //bfs approach\\n        Set<Integer>set=new HashSet<>();\\n        Queue<List<Integer>>queue=new LinkedList<>();\\n        for(int row=0;row<grid.length;row++){\\n            for(int col=0;col<grid[0].length;col++){\\n                if(grid[row][col]==2){\\n                    if(check(grid,row+1,col)||check(grid,row-1,col)||check(grid,row,col+1)||check(grid,row,col-1)){\\n                        int id=row*grid[0].length+(col+1);\\n                        List<Integer>tuple=new ArrayList<>();\\n                        tuple.add(row);\\n                        tuple.add(col);\\n                        tuple.add(0);\\n                        queue.add(tuple);\\n                        set.add(id);\\n                    }\\n                }\\n            }\\n        }\\n        while(queue.size()!=0){\\n            List<Integer>tuple=queue.poll();\\n            int row=tuple.get(0);\\n            int col=tuple.get(1);\\n            //System.out.println(row+\"  \"+col);\\n            int level=tuple.get(2);\\n            ans=Math.max(ans,level);\\n            if(checkone(grid,row+1,col)||checkone(grid,row-1,col)||checkone(grid,row,col+1)||checkone(grid,row,col-1)){\\n                break;\\n            }\\n            if(check(grid,row+1,col)){\\n                int id=(row+1)*grid[0].length+(col+1);\\n                if(!set.contains(id)){\\n                    List<Integer>list=new ArrayList<>();\\n                    list.add(row+1);\\n                    list.add(col);\\n                    list.add(level+1);\\n                    queue.add(list);\\n                    set.add(id);\\n                }\\n            }\\n            if(check(grid,row-1,col)){\\n                int id=(row-1)*grid[0].length+(col+1);\\n                if(!set.contains(id)){\\n                    List<Integer>list=new ArrayList<>();\\n                    list.add(row-1);\\n                    list.add(col);\\n                    list.add(level+1);\\n                    queue.add(list);\\n                    set.add(id);\\n                }\\n            }\\n            if(check(grid,row,col+1)){\\n                int id=row*grid[0].length+(col+2);\\n                if(!set.contains(id)){\\n                    List<Integer>list=new ArrayList<>();\\n                    list.add(row);\\n                    list.add(col+1);\\n                    list.add(level+1);\\n                    queue.add(list);\\n                    set.add(id);\\n                }\\n            }\\n            if(check(grid,row,col-1)){\\n                int id=row*grid[0].length+(col);\\n                if(!set.contains(id)){\\n                    List<Integer>list=new ArrayList<>();\\n                    list.add(row);\\n                    list.add(col-1);\\n                    list.add(level+1);\\n                    queue.add(list);\\n                    set.add(id);\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean check(int grid[][],int row,int col){\\n        if(row<0||row>=grid.length||col<0||col>=grid[0].length){\\n            return false;\\n        }\\n        if(grid[row][col]==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n        public boolean checkone(int grid[][],int row,int col){\\n        if(row<0||row>=grid.length||col<0||col>=grid[0].length){\\n            return false;\\n        }\\n        if(grid[row][col]==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public void dfs(int grid[][],int row,int col){\\n        if(row<0||row>=grid.length||col<0||col>=grid[0].length){\\n            return;\\n        }\\n        if(grid[row][col]==0||grid[row][col]==2){\\n            return;\\n        }\\n        grid[row][col]=2;\\n        dfs(grid,row+1,col);\\n        dfs(grid,row-1,col);\\n        dfs(grid,row,col+1);\\n        dfs(grid,row,col-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        int ans=0;\\n        boolean finish=false;\\n        for(int row=0;row<grid.length;row++){\\n            for(int col=0;col<grid[0].length;col++){\\n                if(grid[row][col]==1){\\n                    dfs(grid,row,col); //change to 2\\n                    finish=true;\\n                    break;\\n                }\\n            }\\n            if(finish){\\n                break;\\n            }\\n        }\\n        boolean hasone=false;\\n        for(int row=0;row<grid.length;row++){\\n            for(int col=0;col<grid[0].length;col++){\\n                if(grid[row][col]==1){\\n                    hasone=true;\\n                }\\n            }\\n        }\\n        if(!hasone){\\n            return 0; //make sure at least one seperate\\n        }\\n        //bfs approach\\n        Set<Integer>set=new HashSet<>();\\n        Queue<List<Integer>>queue=new LinkedList<>();\\n        for(int row=0;row<grid.length;row++){\\n            for(int col=0;col<grid[0].length;col++){\\n                if(grid[row][col]==2){\\n                    if(check(grid,row+1,col)||check(grid,row-1,col)||check(grid,row,col+1)||check(grid,row,col-1)){\\n                        int id=row*grid[0].length+(col+1);\\n                        List<Integer>tuple=new ArrayList<>();\\n                        tuple.add(row);\\n                        tuple.add(col);\\n                        tuple.add(0);\\n                        queue.add(tuple);\\n                        set.add(id);\\n                    }\\n                }\\n            }\\n        }\\n        while(queue.size()!=0){\\n            List<Integer>tuple=queue.poll();\\n            int row=tuple.get(0);\\n            int col=tuple.get(1);\\n            //System.out.println(row+\"  \"+col);\\n            int level=tuple.get(2);\\n            ans=Math.max(ans,level);\\n            if(checkone(grid,row+1,col)||checkone(grid,row-1,col)||checkone(grid,row,col+1)||checkone(grid,row,col-1)){\\n                break;\\n            }\\n            if(check(grid,row+1,col)){\\n                int id=(row+1)*grid[0].length+(col+1);\\n                if(!set.contains(id)){\\n                    List<Integer>list=new ArrayList<>();\\n                    list.add(row+1);\\n                    list.add(col);\\n                    list.add(level+1);\\n                    queue.add(list);\\n                    set.add(id);\\n                }\\n            }\\n            if(check(grid,row-1,col)){\\n                int id=(row-1)*grid[0].length+(col+1);\\n                if(!set.contains(id)){\\n                    List<Integer>list=new ArrayList<>();\\n                    list.add(row-1);\\n                    list.add(col);\\n                    list.add(level+1);\\n                    queue.add(list);\\n                    set.add(id);\\n                }\\n            }\\n            if(check(grid,row,col+1)){\\n                int id=row*grid[0].length+(col+2);\\n                if(!set.contains(id)){\\n                    List<Integer>list=new ArrayList<>();\\n                    list.add(row);\\n                    list.add(col+1);\\n                    list.add(level+1);\\n                    queue.add(list);\\n                    set.add(id);\\n                }\\n            }\\n            if(check(grid,row,col-1)){\\n                int id=row*grid[0].length+(col);\\n                if(!set.contains(id)){\\n                    List<Integer>list=new ArrayList<>();\\n                    list.add(row);\\n                    list.add(col-1);\\n                    list.add(level+1);\\n                    queue.add(list);\\n                    set.add(id);\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean check(int grid[][],int row,int col){\\n        if(row<0||row>=grid.length||col<0||col>=grid[0].length){\\n            return false;\\n        }\\n        if(grid[row][col]==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n        public boolean checkone(int grid[][],int row,int col){\\n        if(row<0||row>=grid.length||col<0||col>=grid[0].length){\\n            return false;\\n        }\\n        if(grid[row][col]==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public void dfs(int grid[][],int row,int col){\\n        if(row<0||row>=grid.length||col<0||col>=grid[0].length){\\n            return;\\n        }\\n        if(grid[row][col]==0||grid[row][col]==2){\\n            return;\\n        }\\n        grid[row][col]=2;\\n        dfs(grid,row+1,col);\\n        dfs(grid,row-1,col);\\n        dfs(grid,row,col+1);\\n        dfs(grid,row,col-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316104,
                "title": "easy-solution-using-dfs-bfs-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    \\n    private static final int[][] DIRECTIONS = new int[][] {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    private static final int ISLAND1 = 2;\\n    private static final int ISLAND2 = 3;\\n    \\n    public int shortestBridge(int[][] islands) {\\n        if (islands == null || islands.length == 0 || islands[0] == null || islands[0].length == 0) return 0;\\n        //Step1: Paint all the island into two distinct island (island1 & island2) using DFS\\n        paintAllIslands(islands);\\n        //Step2: Get queue populated with all the nodes in island 1\\n        Queue<int[]> queue = getInitialQueue(islands, ISLAND1);\\n        //Step3: Get the shortest path to island 2 from each nodes of island1\\n        return getShortestPath(islands, queue, ISLAND1, ISLAND2);\\n    }\\n    \\n    private int getShortestPath(int[][] islands, Queue<int[]> queue, int sourceIsland, int targetIsland) {\\n        int m = islands.length, n = islands[0].length;\\n        while (!queue.isEmpty()) {\\n            int[] u = queue.poll();\\n            int i = u[0], j = u[1];\\n            for (int[] dir : DIRECTIONS) {\\n                int x = dir[0] + i, y = dir[1] + j;\\n                if (x < 0 || y < 0 || x >= m || y >= n || islands[x][y] == sourceIsland) continue;\\n                if (islands[x][y] == targetIsland) return u[2];\\n                queue.offer(new int[] {x, y, 1 + u[2]});\\n                islands[x][y] = sourceIsland;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    private Queue<int[]> getInitialQueue(int[][] islands, int island) {\\n        int m = islands.length, n = islands[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < islands.length; i++) {\\n            for (int j = 0; j < islands[0].length; j++) {\\n                if (islands[i][j] == island) queue.offer(new int[] {i, j, 0});\\n            }\\n        }\\n        return queue;\\n    }\\n\\n    private void paintAllIslands(int[][] islands) {\\n        int m = islands.length, n = islands[0].length, color = ISLAND1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (islands[i][j] == 1) {\\n                    paintIsland(islands, i, j, color++);\\n                    if (color == 4) return;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void paintIsland(int[][] islands, int i, int j, int color) {\\n        int m = islands.length, n = islands[0].length;\\n        if (i < 0 || j < 0 || i >= m || j >= n || islands[i][j] != 1) return;\\n        islands[i][j] = color;\\n        for (int[] dir : DIRECTIONS) {\\n            int x = dir[0] + i, y = dir[1] + j;\\n            paintIsland(islands, x, y, color);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static final int[][] DIRECTIONS = new int[][] {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    private static final int ISLAND1 = 2;\\n    private static final int ISLAND2 = 3;\\n    \\n    public int shortestBridge(int[][] islands) {\\n        if (islands == null || islands.length == 0 || islands[0] == null || islands[0].length == 0) return 0;\\n        //Step1: Paint all the island into two distinct island (island1 & island2) using DFS\\n        paintAllIslands(islands);\\n        //Step2: Get queue populated with all the nodes in island 1\\n        Queue<int[]> queue = getInitialQueue(islands, ISLAND1);\\n        //Step3: Get the shortest path to island 2 from each nodes of island1\\n        return getShortestPath(islands, queue, ISLAND1, ISLAND2);\\n    }\\n    \\n    private int getShortestPath(int[][] islands, Queue<int[]> queue, int sourceIsland, int targetIsland) {\\n        int m = islands.length, n = islands[0].length;\\n        while (!queue.isEmpty()) {\\n            int[] u = queue.poll();\\n            int i = u[0], j = u[1];\\n            for (int[] dir : DIRECTIONS) {\\n                int x = dir[0] + i, y = dir[1] + j;\\n                if (x < 0 || y < 0 || x >= m || y >= n || islands[x][y] == sourceIsland) continue;\\n                if (islands[x][y] == targetIsland) return u[2];\\n                queue.offer(new int[] {x, y, 1 + u[2]});\\n                islands[x][y] = sourceIsland;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    private Queue<int[]> getInitialQueue(int[][] islands, int island) {\\n        int m = islands.length, n = islands[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < islands.length; i++) {\\n            for (int j = 0; j < islands[0].length; j++) {\\n                if (islands[i][j] == island) queue.offer(new int[] {i, j, 0});\\n            }\\n        }\\n        return queue;\\n    }\\n\\n    private void paintAllIslands(int[][] islands) {\\n        int m = islands.length, n = islands[0].length, color = ISLAND1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (islands[i][j] == 1) {\\n                    paintIsland(islands, i, j, color++);\\n                    if (color == 4) return;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void paintIsland(int[][] islands, int i, int j, int color) {\\n        int m = islands.length, n = islands[0].length;\\n        if (i < 0 || j < 0 || i >= m || j >= n || islands[i][j] != 1) return;\\n        islands[i][j] = color;\\n        for (int[] dir : DIRECTIONS) {\\n            int x = dir[0] + i, y = dir[1] + j;\\n            paintIsland(islands, x, y, color);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298733,
                "title": "python-dfs-bfs",
                "content": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        rl, cl = len(grid), len(grid[0])\\n        d = ((1,0),(0,1),(-1,0),(0,-1))\\n        memo = [[0 for _ in range(cl)] for _ in range(rl)]\\n        q = collections.deque()\\n        \\n        def dfs(x,y):\\n            memo[x][y] = 1\\n            q.append((0,x,y))\\n            for i in d:\\n                nx = x + i[0]\\n                ny = y + i[1]\\n                if 0 <= nx < rl and 0 <= ny < cl and grid[nx][ny] == 1 and memo[nx][ny] == 0:\\n                    memo[nx][ny] = 1\\n                    dfs(nx, ny)\\n        \\n        flag = 0\\n        for i in range(rl):\\n            for j in range(cl):\\n                if grid[i][j] == 1:\\n                    dfs(i,j)\\n                    flag = 1\\n                    break\\n            if flag:\\n                break\\n\\n        while q:\\n            t,x,y = q.popleft()\\n            for i in d:\\n                nx = x + i[0]\\n                ny = y + i[1]\\n                if 0 <= nx < rl and 0 <= ny < cl and memo[nx][ny] == 0:\\n                    if grid[nx][ny] == 0:\\n                        q.append((t + 1, nx, ny))\\n                        memo[nx][ny] = 1\\n                    else:\\n                        return t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestBridge(self, grid: List[List[int]]) -> int:\\n        rl, cl = len(grid), len(grid[0])\\n        d = ((1,0),(0,1),(-1,0),(0,-1))\\n        memo = [[0 for _ in range(cl)] for _ in range(rl)]\\n        q = collections.deque()\\n        \\n        def dfs(x,y):\\n            memo[x][y] = 1\\n            q.append((0,x,y))\\n            for i in d:\\n                nx = x + i[0]\\n                ny = y + i[1]\\n                if 0 <= nx < rl and 0 <= ny < cl and grid[nx][ny] == 1 and memo[nx][ny] == 0:\\n                    memo[nx][ny] = 1\\n                    dfs(nx, ny)\\n        \\n        flag = 0\\n        for i in range(rl):\\n            for j in range(cl):\\n                if grid[i][j] == 1:\\n                    dfs(i,j)\\n                    flag = 1\\n                    break\\n            if flag:\\n                break\\n\\n        while q:\\n            t,x,y = q.popleft()\\n            for i in d:\\n                nx = x + i[0]\\n                ny = y + i[1]\\n                if 0 <= nx < rl and 0 <= ny < cl and memo[nx][ny] == 0:\\n                    if grid[nx][ny] == 0:\\n                        q.append((t + 1, nx, ny))\\n                        memo[nx][ny] = 1\\n                    else:\\n                        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189327,
                "title": "why-time-limit-exceeded",
                "content": "My solution is very direct, first finding the first island, mark it all as 2.\\nFinding the island is also using BSF.\\nSo my solution is BFS connect graph + BFS finding shortest distance.\\nAny one could take a look why this would TLE? For the connecting graph process, does BFS and DFS have the same time complexity?\\n```\\nclass Solution {\\n    int[] dx = {-1, 1, 0, 0};\\n    int[] dy = {0, 0, -1, 1};\\n        \\n    public int shortestBridge(int[][] A) {\\n        int m = A.length;\\n        int n = A[0].length;\\n        boolean flag = false;\\n        // preprocessing\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (A[i][j] == 1) {\\n                    int num = 2;\\n                    Queue<int[]> q = new LinkedList<>();\\n                    q.offer(new int[]{i, j});\\n                    while (!q.isEmpty()) {\\n                        int[] curr = q.poll();\\n                        A[curr[0]][curr[1]] = num;\\n                        for (int k = 0; k < dx.length; k++) {\\n                            int x = curr[0] + dx[k];\\n                            int y = curr[1] + dy[k];\\n                            if (isValid(x, y, m, n) && A[x][y] == 1) {\\n                                q.offer(new int[]{x, y});\\n                            }\\n                        }  \\n                    }\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n        \\n        int res = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (A[i][j] == 2) {\\n                    queue.offer(new int[]{i, j});\\n                }\\n            }\\n        }\\n        \\n        while (!queue.isEmpty()) {\\n            \\n            int size = queue.size();\\n            \\n            for (int time = 0; time < size; time++) {\\n                int[] curr = queue.poll();\\n                if (A[curr[0]][curr[1]] == 1) {\\n                    return res - 1;\\n                }\\n                A[curr[0]][curr[1]] = 2;\\n                for (int k = 0; k < dx.length; k++) {\\n                    int x = curr[0] + dx[k];\\n                    int y = curr[1] + dy[k];\\n                    if (isValid(x, y, m, n) && A[x][y] != 2) {\\n                        queue.offer(new int[]{x, y});\\n                    }\\n                }\\n                \\n            }\\n            res++;\\n        }\\n        return -1;\\n        \\n        \\n    }\\n    \\n    private boolean isValid(int i, int j, int m, int n) {\\n        return i >= 0 && i < m && j >= 0 && j < n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] dx = {-1, 1, 0, 0};\\n    int[] dy = {0, 0, -1, 1};\\n        \\n    public int shortestBridge(int[][] A) {\\n        int m = A.length;\\n        int n = A[0].length;\\n        boolean flag = false;\\n        // preprocessing\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (A[i][j] == 1) {\\n                    int num = 2;\\n                    Queue<int[]> q = new LinkedList<>();\\n                    q.offer(new int[]{i, j});\\n                    while (!q.isEmpty()) {\\n                        int[] curr = q.poll();\\n                        A[curr[0]][curr[1]] = num;\\n                        for (int k = 0; k < dx.length; k++) {\\n                            int x = curr[0] + dx[k];\\n                            int y = curr[1] + dy[k];\\n                            if (isValid(x, y, m, n) && A[x][y] == 1) {\\n                                q.offer(new int[]{x, y});\\n                            }\\n                        }  \\n                    }\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n        \\n        int res = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (A[i][j] == 2) {\\n                    queue.offer(new int[]{i, j});\\n                }\\n            }\\n        }\\n        \\n        while (!queue.isEmpty()) {\\n            \\n            int size = queue.size();\\n            \\n            for (int time = 0; time < size; time++) {\\n                int[] curr = queue.poll();\\n                if (A[curr[0]][curr[1]] == 1) {\\n                    return res - 1;\\n                }\\n                A[curr[0]][curr[1]] = 2;\\n                for (int k = 0; k < dx.length; k++) {\\n                    int x = curr[0] + dx[k];\\n                    int y = curr[1] + dy[k];\\n                    if (isValid(x, y, m, n) && A[x][y] != 2) {\\n                        queue.offer(new int[]{x, y});\\n                    }\\n                }\\n                \\n            }\\n            res++;\\n        }\\n        return -1;\\n        \\n        \\n    }\\n    \\n    private boolean isValid(int i, int j, int m, int n) {\\n        return i >= 0 && i < m && j >= 0 && j < n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189257,
                "title": "dfs-bfs-solution",
                "content": "\\n```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n        boolean[][] connected = new boolean[A.length][A[0].length];\\n        boolean[][] visited = new boolean[A.length][A[0].length];\\n        int count = 0;\\n\\t//Find a connected component\\n        Queue<int[]> bfs = new LinkedList<>();\\n        for(int i = 0; i < A.length; i++){\\n            for(int j = 0; j < A[i].length; j++){\\n                if(A[i][j] == 1){\\n                    dfs(i,j,A,connected,bfs);\\n                    count++;\\n                    break;\\n                }\\n            }\\n            if(count == 1)\\n                break;\\n        }\\n        \\n        int depth = 0;\\n\\t//Find shortest path\\n        while(!bfs.isEmpty()){\\n            int size = bfs.size();\\n            for(int i = 0; i < size; i++){\\n                int[] curr = bfs.poll();\\n                for(int[] dir : dirs){\\n                    int r = dir[0] + curr[0];\\n                    int c = dir[1] + curr[1];\\n                    if(r < 0 || c < 0 || r > A.length-1 || c > A[r].length-1 || connected[r][c] || visited[r][c]) continue;\\n                    visited[r][c] = true;\\n                    if(A[r][c] == 1)\\n                        return depth;\\n                    else\\n                        bfs.add(new int[]{r,c});\\n                }\\n            }\\n            depth++;\\n        }\\n        \\n        return -1;\\n                \\n    }\\n    \\n    \\n    void dfs(int i, int j, int[][] A, boolean[][] connected, Queue<int[]> bfs){\\n        if(i < 0 || j < 0 || i > A.length-1 || j > A[i].length-1 || connected[i][j] || A[i][j] == 0)\\n            return;\\n        connected[i][j] = true;\\n        bfs.add(new int[]{i,j});\\n        \\n        dfs(i-1,j,A,connected,bfs);\\n        dfs(i+1,j,A,connected,bfs);\\n        dfs(i,j-1,A,connected,bfs);\\n        dfs(i,j+1,A,connected,bfs);\\n\\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] A) {\\n        int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n        boolean[][] connected = new boolean[A.length][A[0].length];\\n        boolean[][] visited = new boolean[A.length][A[0].length];\\n        int count = 0;\\n\\t//Find a connected component\\n        Queue<int[]> bfs = new LinkedList<>();\\n        for(int i = 0; i < A.length; i++){\\n            for(int j = 0; j < A[i].length; j++){\\n                if(A[i][j] == 1){\\n                    dfs(i,j,A,connected,bfs);\\n                    count++;\\n                    break;\\n                }\\n            }\\n            if(count == 1)\\n                break;\\n        }\\n        \\n        int depth = 0;\\n\\t//Find shortest path\\n        while(!bfs.isEmpty()){\\n            int size = bfs.size();\\n            for(int i = 0; i < size; i++){\\n                int[] curr = bfs.poll();\\n                for(int[] dir : dirs){\\n                    int r = dir[0] + curr[0];\\n                    int c = dir[1] + curr[1];\\n                    if(r < 0 || c < 0 || r > A.length-1 || c > A[r].length-1 || connected[r][c] || visited[r][c]) continue;\\n                    visited[r][c] = true;\\n                    if(A[r][c] == 1)\\n                        return depth;\\n                    else\\n                        bfs.add(new int[]{r,c});\\n                }\\n            }\\n            depth++;\\n        }\\n        \\n        return -1;\\n                \\n    }\\n    \\n    \\n    void dfs(int i, int j, int[][] A, boolean[][] connected, Queue<int[]> bfs){\\n        if(i < 0 || j < 0 || i > A.length-1 || j > A[i].length-1 || connected[i][j] || A[i][j] == 0)\\n            return;\\n        connected[i][j] = true;\\n        bfs.add(new int[]{i,j});\\n        \\n        dfs(i-1,j,A,connected,bfs);\\n        dfs(i+1,j,A,connected,bfs);\\n        dfs(i,j-1,A,connected,bfs);\\n        dfs(i,j+1,A,connected,bfs);\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082601,
                "title": "easy-solution-using-bfs-java-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length;\\n        Queue<int[]> queue = new LinkedList<>();\\n\\n        boolean found = false;\\n        for(int i = 0; i < n && !found; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1) {\\n                    dfs(grid, n, i, j, queue);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int distance = 0;\\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();  \\n                for(int[] dirs: directions) {\\n                    int x = cur[0] + dirs[0];\\n                    int y = cur[1] + dirs[1];\\n                    if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 2) {\\n                        continue;\\n                    }\\n                    if (grid[x][y] == 1) {\\n                        return distance;\\n                    }\\n                    queue.add(new int[]{x, y});\\n                    grid[x][y] = 2;\\n                }\\n            }\\n            distance += 1;\\n        }\\n        return -1;\\n    }\\n\\n    public void dfs(int[][] grid, int n, int i, int j, Queue<int[]> queue) {\\n        if(i < 0 || j < 0 || i >= n || j >= n || grid[i][j] == 0 || grid[i][j] == 2)\\n            return;\\n        \\n        int[] arr = new int[2];\\n        arr[0] = i;\\n        arr[1] = j;\\n        queue.offer(arr);\\n\\n        grid[i][j] = 2;\\n        dfs(grid, n, i + 1, j, queue);\\n        dfs(grid, n, i, j + 1, queue);\\n        dfs(grid, n, i - 1, j, queue);\\n        dfs(grid, n, i, j - 1, queue);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length;\\n        Queue<int[]> queue = new LinkedList<>();\\n\\n        boolean found = false;\\n        for(int i = 0; i < n && !found; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1) {\\n                    dfs(grid, n, i, j, queue);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int distance = 0;\\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();  \\n                for(int[] dirs: directions) {\\n                    int x = cur[0] + dirs[0];\\n                    int y = cur[1] + dirs[1];\\n                    if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 2) {\\n                        continue;\\n                    }\\n                    if (grid[x][y] == 1) {\\n                        return distance;\\n                    }\\n                    queue.add(new int[]{x, y});\\n                    grid[x][y] = 2;\\n                }\\n            }\\n            distance += 1;\\n        }\\n        return -1;\\n    }\\n\\n    public void dfs(int[][] grid, int n, int i, int j, Queue<int[]> queue) {\\n        if(i < 0 || j < 0 || i >= n || j >= n || grid[i][j] == 0 || grid[i][j] == 2)\\n            return;\\n        \\n        int[] arr = new int[2];\\n        arr[0] = i;\\n        arr[1] = j;\\n        queue.offer(arr);\\n\\n        grid[i][j] = 2;\\n        dfs(grid, n, i + 1, j, queue);\\n        dfs(grid, n, i, j + 1, queue);\\n        dfs(grid, n, i - 1, j, queue);\\n        dfs(grid, n, i, j - 1, queue);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975016,
                "title": "simple-and-easy-to-understand-code-using-dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dir[4][2]={{1,0},{0,1},{0,-1},{-1,0}};\\n    bool vis[101][101];\\n    void dfs(int i,int j,vector<vector<int>>& grid){\\n    int n=grid.size();\\n    stack<pair<int,int>>st;\\n    st.push({i,j});\\n\\n    while(!st.empty()) {\\n        int x=st.top().first;\\n        int y=st.top().second;\\n        st.pop();\\n\\n        if (x<0 or y<0 or x>=n or y>=n or grid[x][y]==0) continue;\\n\\n        for(int idx=0;idx<4;idx++){\\n            int a=x+dir[idx][0];\\n            int b=y+dir[idx][1];\\n\\n            if (a>=0 and a<n and b>=0 and b<n and grid[a][b]==1 and !vis[a][b]) {\\n                st.push({a,b});\\n                vis[a][b]=true;\\n            }\\n        }\\n    }\\n}\\n#define arr array<int,3>\\n    int solve(int i,int j,pair<int,int>&to,vector<vector<int>>& grid){\\n        int x=to.first,y=to.second;\\n        int n=grid.size();\\n\\n        priority_queue<arr,vector<arr>,greater<arr>>pq;\\n\\n        vector<vector<int>>dist(n,vector<int>(n,1e8));\\n\\n        dist[i][j]=0;\\n\\n        pq.push({0,i,j});\\n\\n        while(!pq.empty()){\\n            auto temp=pq.top();\\n            pq.pop();\\n\\n            int dis=temp[0];\\n            int r=temp[1],c=temp[2];\\n\\n            if(grid[r][c]==0) dis++;\\n\\n            for(int idx=0;idx<4;idx++){\\n                int a=r+dir[idx][0];\\n                int b=c+dir[idx][1];\\n\\n                if(a>=0 and b>=0 and a<n and b<n){\\n                    if(dist[a][b]>dis){\\n                        dist[a][b]=dis;\\n                        pq.push({dis,a,b});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[x][y];\\n\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        memset(vis,false,sizeof vis);\\n\\n        pair<int,int>from,to;\\n\\n        bool flag=true;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1 and !vis[i][j]){\\n                    if(flag) from={i,j},flag=false;\\n                    else to={i,j};\\n                    dfs(i,j,grid);\\n                }\\n            }\\n        }\\n        memset(vis,false,sizeof vis);\\n\\n        int i=from.first,j=from.second;\\n\\n        int ans=solve(i,j,to,grid);\\n        // cout<<ans;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[4][2]={{1,0},{0,1},{0,-1},{-1,0}};\\n    bool vis[101][101];\\n    void dfs(int i,int j,vector<vector<int>>& grid){\\n    int n=grid.size();\\n    stack<pair<int,int>>st;\\n    st.push({i,j});\\n\\n    while(!st.empty()) {\\n        int x=st.top().first;\\n        int y=st.top().second;\\n        st.pop();\\n\\n        if (x<0 or y<0 or x>=n or y>=n or grid[x][y]==0) continue;\\n\\n        for(int idx=0;idx<4;idx++){\\n            int a=x+dir[idx][0];\\n            int b=y+dir[idx][1];\\n\\n            if (a>=0 and a<n and b>=0 and b<n and grid[a][b]==1 and !vis[a][b]) {\\n                st.push({a,b});\\n                vis[a][b]=true;\\n            }\\n        }\\n    }\\n}\\n#define arr array<int,3>\\n    int solve(int i,int j,pair<int,int>&to,vector<vector<int>>& grid){\\n        int x=to.first,y=to.second;\\n        int n=grid.size();\\n\\n        priority_queue<arr,vector<arr>,greater<arr>>pq;\\n\\n        vector<vector<int>>dist(n,vector<int>(n,1e8));\\n\\n        dist[i][j]=0;\\n\\n        pq.push({0,i,j});\\n\\n        while(!pq.empty()){\\n            auto temp=pq.top();\\n            pq.pop();\\n\\n            int dis=temp[0];\\n            int r=temp[1],c=temp[2];\\n\\n            if(grid[r][c]==0) dis++;\\n\\n            for(int idx=0;idx<4;idx++){\\n                int a=r+dir[idx][0];\\n                int b=c+dir[idx][1];\\n\\n                if(a>=0 and b>=0 and a<n and b<n){\\n                    if(dist[a][b]>dis){\\n                        dist[a][b]=dis;\\n                        pq.push({dis,a,b});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[x][y];\\n\\n    }\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        memset(vis,false,sizeof vis);\\n\\n        pair<int,int>from,to;\\n\\n        bool flag=true;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1 and !vis[i][j]){\\n                    if(flag) from={i,j},flag=false;\\n                    else to={i,j};\\n                    dfs(i,j,grid);\\n                }\\n            }\\n        }\\n        memset(vis,false,sizeof vis);\\n\\n        int i=from.first,j=from.second;\\n\\n        int ans=solve(i,j,to,grid);\\n        // cout<<ans;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3572833,
                "title": "c-solution-dfs-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef struct CELL\\n{\\n    int x;\\n    int y;\\n} CELL;\\n\\nbool checkForNeighbor(int** grid, int i, int j, int size, int checkFor, CELL* q, int *r, int setVisitedAs)\\n{\\n    bool res = false;\\n\\n    if ((j+1) < size && grid[i][j+1] == checkFor)\\n    {\\n        if (q)\\n        {\\n            q[++(*r)].x = i;\\n            q[*r].y = j + 1;\\n            grid[i][j+1] = setVisitedAs;\\n        }\\n        \\n        res = true;\\n    }\\n    if ((i+1) < size && grid[i+1][j] == checkFor)\\n    {\\n        if (q)\\n        {\\n            q[++(*r)].x = i+1;\\n            q[*r].y = j;\\n            grid[i+1][j] = setVisitedAs;\\n        }\\n\\n        res = true;\\n    }    \\n    if (j > 0 && grid[i][j-1] == checkFor)\\n    {\\n        if (q)\\n        {\\n            q[++(*r)].x = i;\\n            q[*r].y = j-1;\\n            grid[i][j-1] = setVisitedAs;\\n        }\\n\\n        res = true;\\n    }\\n    if (i > 0 && grid[i-1][j] == checkFor)\\n    {\\n        if (q)\\n        {\\n            q[++(*r)].x = i-1;\\n            q[*r].y = j;\\n            grid[i-1][j] = setVisitedAs;\\n        }\\n\\n        res = true;\\n    }\\n\\n    return res;\\n}\\n\\nvoid dfs(int** grid, int i, int j, int size, CELL* nextSearchQ , int* r2)\\n{\\n    grid[i][j] = 2; // 2 indicates a land cell as visited.\\n\\n    checkForNeighbor(grid, i, j, size, 0, nextSearchQ, r2, -1);\\n\\n    if ((j+1) < size && grid[i][j+1] == 1)\\n        dfs(grid, i, j + 1, size, nextSearchQ, r2);\\n    if ((i+1) < size && grid[i+1][j] == 1)\\n        dfs(grid, i+1, j, size, nextSearchQ, r2);\\n    if (j > 0 && grid[i][j-1] == 1)\\n        dfs(grid, i, j - 1, size, nextSearchQ, r2);\\n    if (i > 0 && grid[i-1][j] == 1)\\n        dfs(grid, i-1, j, size, nextSearchQ, r2);\\n}\\n\\nint shortestBridge(int** grid, int gridSize, int* gridColSize){\\n    CELL searchQ[gridSize*gridSize];\\n    CELL nextSearchQ[gridSize*gridSize];\\n    int f = -1;\\n    int r = -1;\\n    int r2 = -1;\\n    int i;\\n    int j;\\n    int distance = 1;\\n    int exit = 0;\\n\\n    for (i = 0; i < gridSize && !exit; i++)\\n        for (j = 0; j < gridSize; j++)\\n            if (grid[i][j] == 1)\\n            {\\n                dfs(grid, i, j, gridSize, nextSearchQ, &r2);\\n                exit = 1;\\n                break;\\n            }\\n\\n    while (r2 != -1)\\n    {\\n        memcpy(searchQ, nextSearchQ, sizeof(CELL) * (r2+1) );\\n        r = r2;\\n        f = -1;\\n        r2 = -1;\\n\\n        while (f < r)\\n        {\\n            f++;           \\n            if (checkForNeighbor(grid, searchQ[f].x, searchQ[f].y, gridSize, 1, NULL, NULL, 1))\\n                return distance;\\n\\n            checkForNeighbor(grid, searchQ[f].x, searchQ[f].y, gridSize, 0, nextSearchQ, &r2, -1);\\n        }\\n\\n        distance++;\\n    }\\n\\n    return distance;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct CELL\\n{\\n    int x;\\n    int y;\\n} CELL;\\n\\nbool checkForNeighbor(int** grid, int i, int j, int size, int checkFor, CELL* q, int *r, int setVisitedAs)\\n{\\n    bool res = false;\\n\\n    if ((j+1) < size && grid[i][j+1] == checkFor)\\n    {\\n        if (q)\\n        {\\n            q[++(*r)].x = i;\\n            q[*r].y = j + 1;\\n            grid[i][j+1] = setVisitedAs;\\n        }\\n        \\n        res = true;\\n    }\\n    if ((i+1) < size && grid[i+1][j] == checkFor)\\n    {\\n        if (q)\\n        {\\n            q[++(*r)].x = i+1;\\n            q[*r].y = j;\\n            grid[i+1][j] = setVisitedAs;\\n        }\\n\\n        res = true;\\n    }    \\n    if (j > 0 && grid[i][j-1] == checkFor)\\n    {\\n        if (q)\\n        {\\n            q[++(*r)].x = i;\\n            q[*r].y = j-1;\\n            grid[i][j-1] = setVisitedAs;\\n        }\\n\\n        res = true;\\n    }\\n    if (i > 0 && grid[i-1][j] == checkFor)\\n    {\\n        if (q)\\n        {\\n            q[++(*r)].x = i-1;\\n            q[*r].y = j;\\n            grid[i-1][j] = setVisitedAs;\\n        }\\n\\n        res = true;\\n    }\\n\\n    return res;\\n}\\n\\nvoid dfs(int** grid, int i, int j, int size, CELL* nextSearchQ , int* r2)\\n{\\n    grid[i][j] = 2; // 2 indicates a land cell as visited.\\n\\n    checkForNeighbor(grid, i, j, size, 0, nextSearchQ, r2, -1);\\n\\n    if ((j+1) < size && grid[i][j+1] == 1)\\n        dfs(grid, i, j + 1, size, nextSearchQ, r2);\\n    if ((i+1) < size && grid[i+1][j] == 1)\\n        dfs(grid, i+1, j, size, nextSearchQ, r2);\\n    if (j > 0 && grid[i][j-1] == 1)\\n        dfs(grid, i, j - 1, size, nextSearchQ, r2);\\n    if (i > 0 && grid[i-1][j] == 1)\\n        dfs(grid, i-1, j, size, nextSearchQ, r2);\\n}\\n\\nint shortestBridge(int** grid, int gridSize, int* gridColSize){\\n    CELL searchQ[gridSize*gridSize];\\n    CELL nextSearchQ[gridSize*gridSize];\\n    int f = -1;\\n    int r = -1;\\n    int r2 = -1;\\n    int i;\\n    int j;\\n    int distance = 1;\\n    int exit = 0;\\n\\n    for (i = 0; i < gridSize && !exit; i++)\\n        for (j = 0; j < gridSize; j++)\\n            if (grid[i][j] == 1)\\n            {\\n                dfs(grid, i, j, gridSize, nextSearchQ, &r2);\\n                exit = 1;\\n                break;\\n            }\\n\\n    while (r2 != -1)\\n    {\\n        memcpy(searchQ, nextSearchQ, sizeof(CELL) * (r2+1) );\\n        r = r2;\\n        f = -1;\\n        r2 = -1;\\n\\n        while (f < r)\\n        {\\n            f++;           \\n            if (checkForNeighbor(grid, searchQ[f].x, searchQ[f].y, gridSize, 1, NULL, NULL, 1))\\n                return distance;\\n\\n            checkForNeighbor(grid, searchQ[f].x, searchQ[f].y, gridSize, 0, nextSearchQ, &r2, -1);\\n        }\\n\\n        distance++;\\n    }\\n\\n    return distance;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3551840,
                "title": "c-easy-to-understand-bfs-dfs-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& vis,int n,int dr[],int dc[],\\n    queue<vector<int>>& pq){\\n        vis[i][j]=1;\\n        grid[i][j]=2;\\n        pq.push({0,i,j});\\n        for(int k=0;k<4;k++){\\n            int nrow=i+dr[k];\\n            int ncol=j+dc[k];\\n            if(nrow>=0 && ncol>=0 && nrow<n && ncol<n && grid[nrow][ncol] && !vis[nrow][ncol]){\\n                dfs(nrow,ncol,grid,vis,n,dr,dc,pq);\\n            }\\n        }\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        queue<vector<int>> q;\\n        int dr[]={-1,0,1,0};\\n        int dc[]={0,1,0,-1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] && !vis[i][j]){\\n                    dfs(i,j,grid,vis,n,dr,dc,q);\\n                    goto x; //to break nested for loops;\\n                }\\n            }\\n        }\\n        x:\\n        while(!q.empty()){\\n            int row=q.front()[1];\\n            int col=q.front()[2];\\n            int lvl=q.front()[0];\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow=row+dr[i];\\n                int ncol=col+dc[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<n){\\n                    if(grid[nrow][ncol]==1) return lvl;\\n                    else if(!vis[nrow][ncol] && grid[nrow][ncol]==0){\\n                        vis[nrow][ncol]=1;\\n                        q.push({lvl+1,nrow,ncol});\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& vis,int n,int dr[],int dc[],\\n    queue<vector<int>>& pq){\\n        vis[i][j]=1;\\n        grid[i][j]=2;\\n        pq.push({0,i,j});\\n        for(int k=0;k<4;k++){\\n            int nrow=i+dr[k];\\n            int ncol=j+dc[k];\\n            if(nrow>=0 && ncol>=0 && nrow<n && ncol<n && grid[nrow][ncol] && !vis[nrow][ncol]){\\n                dfs(nrow,ncol,grid,vis,n,dr,dc,pq);\\n            }\\n        }\\n    }\\npublic:\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        queue<vector<int>> q;\\n        int dr[]={-1,0,1,0};\\n        int dc[]={0,1,0,-1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] && !vis[i][j]){\\n                    dfs(i,j,grid,vis,n,dr,dc,q);\\n                    goto x; //to break nested for loops;\\n                }\\n            }\\n        }\\n        x:\\n        while(!q.empty()){\\n            int row=q.front()[1];\\n            int col=q.front()[2];\\n            int lvl=q.front()[0];\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow=row+dr[i];\\n                int ncol=col+dc[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<n){\\n                    if(grid[nrow][ncol]==1) return lvl;\\n                    else if(!vis[nrow][ncol] && grid[nrow][ncol]==0){\\n                        vis[nrow][ncol]=1;\\n                        q.push({lvl+1,nrow,ncol});\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549606,
                "title": "intuitive",
                "content": "just think about we start spreading the any one of iland untill we get the second iland so what we will do is first collect all connected cells which have \\'1\\' in a queue through DFS (can also go for BFS but DFS is more intutive ) and once we have all cells of one iland we will start pushing all possible adjecent cells untill we get a 1 then we will return ans-1( -1 because in the itraction we have already incremented ans by one  unit but in current itration itself we reached to another iland\\'s cell so no need to current increment so final result fill be \"ans-1\").\\nmy code:\\n\\n```\\nclass Solution {\\npublic:\\n    int x[4]={1,-1,0,0};\\n    int y[4]={0,0,1,-1};\\n    queue<pair<int,int>> q;\\n       \\n    void dfs(vector<vector<int>>&a, vector<vector<int>> &v,int i, int j)\\n    {\\n         \\n        if(i<0 || i>=a.size() || j<0 || j>=a[0].size()) return;\\n        if(v[i][j]==1|| a[i][j]==0) return ;\\n        v[i][j]=1;\\n        q.push({i,j});\\n        for(int k=0; k<4; k++)\\n        {\\n            dfs(a,v,i+x[k],j+y[k]);\\n        }\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& a) \\n    {\\n        int n=a.size(); int m=a[0].size();\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        \\n        int f=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(a[i][j]==1)\\n                {\\n                     // cout<<i<<\" hieshfkje \"<<j<<endl;\\n                     dfs(a,v,i,j);\\n                     f=1;\\n                     break;\\n                    \\n                }\\n               \\n            }\\n            if(f) break;\\n        }\\n        // cout<<q.size()<<endl;\\n        // cout<<\"hi\"<<endl;\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n           ans=ans+1;\\n           int s=q.size();\\n            cout<<endl<<endl;\\n            while(s--)\\n            {\\n                auto p=q.front(); q.pop();\\n                \\n                int xi=p.first;\\n                int yi=p.second;\\n                cout<<xi<<\" \"<<yi<<endl;\\n                for(int i=0; i<4; i++)\\n                {\\n                    int c=xi+x[i];\\n                    int d=yi+y[i];\\n                    if(c<0|| c>=a.size() || d<0|| d>=a[0].size()) continue;\\n                    else\\n                    {\\n                        if(v[c][d]==false)\\n                        {\\n                            if(a[c][d]==1)\\n                            {\\n                                return ans-1;\\n                            }\\n\\n                            else q.push({c,d});\\n                            v[c][d]=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(ans>2)\\n        return ans-2;\\n        return ans-1;\\n        \\n       \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x[4]={1,-1,0,0};\\n    int y[4]={0,0,1,-1};\\n    queue<pair<int,int>> q;\\n       \\n    void dfs(vector<vector<int>>&a, vector<vector<int>> &v,int i, int j)\\n    {\\n         \\n        if(i<0 || i>=a.size() || j<0 || j>=a[0].size()) return;\\n        if(v[i][j]==1|| a[i][j]==0) return ;\\n        v[i][j]=1;\\n        q.push({i,j});\\n        for(int k=0; k<4; k++)\\n        {\\n            dfs(a,v,i+x[k],j+y[k]);\\n        }\\n    }\\n    \\n    int shortestBridge(vector<vector<int>>& a) \\n    {\\n        int n=a.size(); int m=a[0].size();\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        \\n        int f=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(a[i][j]==1)\\n                {\\n                     // cout<<i<<\" hieshfkje \"<<j<<endl;\\n                     dfs(a,v,i,j);\\n                     f=1;\\n                     break;\\n                    \\n                }\\n               \\n            }\\n            if(f) break;\\n        }\\n        // cout<<q.size()<<endl;\\n        // cout<<\"hi\"<<endl;\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n           ans=ans+1;\\n           int s=q.size();\\n            cout<<endl<<endl;\\n            while(s--)\\n            {\\n                auto p=q.front(); q.pop();\\n                \\n                int xi=p.first;\\n                int yi=p.second;\\n                cout<<xi<<\" \"<<yi<<endl;\\n                for(int i=0; i<4; i++)\\n                {\\n                    int c=xi+x[i];\\n                    int d=yi+y[i];\\n                    if(c<0|| c>=a.size() || d<0|| d>=a[0].size()) continue;\\n                    else\\n                    {\\n                        if(v[c][d]==false)\\n                        {\\n                            if(a[c][d]==1)\\n                            {\\n                                return ans-1;\\n                            }\\n\\n                            else q.push({c,d});\\n                            v[c][d]=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(ans>2)\\n        return ans-2;\\n        return ans-1;\\n        \\n       \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3549571,
                "title": "java-shortest-bridge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find the shortest bridge between two islands in a given grid. We can solve this problem using a combination of depth-first search (DFS) and breadth-first search (BFS) algorithms.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Initialize a boolean visited array of size n x n to keep track of visited cells.\\n\\n2) Step 1: Find the first island and mark its cells as visited using DFS. Iterate through the grid and when a cell with a value of 1 is found, perform a DFS to mark all the connected cells as visited and mark them as part of the first island by setting their value to 2.\\n\\n3) Step 2: Use DFS to find the second island. Iterate through the grid and when a cell with a value of 1 and not visited is found, perform a DFS to check if it is part of the second island. If the second island is found, break the loop.\\n\\n4) Step 3: Use BFS to find the shortest path between the islands. Create a queue to store the cells of the first island. Enqueue the cells of the first island into the queue and mark them as visited. Initialize a variable minFlips to track the minimum number of flips required to reach the second island.\\n\\n5) While the queue is not empty, perform the following steps:\\n- Get the current cell from the front of the queue.\\n- Check the neighboring cells in all four directions (up, down, left, right).\\n- If a neighboring cell is within the grid boundaries, not visited, and has a value of 1, return the minFlips value since we have reached the second island.\\n- Otherwise, if the neighboring cell is within the grid boundaries, not visited, and has a value of 0, mark it as visited and enqueue it into the queue.\\n- Repeat the above steps for all cells in the queue.\\n- Increment minFlips by 1 after processing each level of the BFS.\\n6) If no path is found, return -1.\\n7) Finally, return the minFlips value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(n^2), where n is the size of the grid. We perform a DFS to find the first island, a DFS to find the second island, and a BFS to find the shortest path between the islands. Each cell is visited once during these operations.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n^2) for the visited array and the queue.\\n\\n# Code\\n```\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        \\n        // Step 1: Find the first island and mark its cells as visited\\n        boolean found = false;\\n        for (int i = 0; i < n; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    dfs(grid, i, j, visited);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // Step 2: Use DFS to find the second island\\n        for (int i = 0; i < n; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && !visited[i][j]) {\\n                    if (dfsFindSecondIsland(grid, i, j, visited)) {\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Step 3: Use BFS to find the shortest path between the islands\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(new int[]{i, j});\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        int minFlips = 0;\\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                int[] curr = queue.poll();\\n                \\n                for (int[] direction : directions) {\\n                    int newRow = curr[0] + direction[0];\\n                    int newCol = curr[1] + direction[1];\\n                    \\n                    if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && !visited[newRow][newCol]) {\\n                        if (grid[newRow][newCol] == 1) {\\n                            return minFlips;\\n                        } else {\\n                            visited[newRow][newCol] = true;\\n                            queue.offer(new int[]{newRow, newCol});\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            minFlips++;\\n        }\\n        \\n        return -1; // No path found\\n    }\\n    \\n    private void dfs(int[][] grid, int row, int col, boolean[][] visited) {\\n        int n = grid.length;\\n        \\n        if (row < 0 || row >= n || col < 0 || col >= n || visited[row][col] || grid[row][col] == 0) {\\n            return;\\n        }\\n        \\n        visited[row][col] = true;\\n        grid[row][col] = 2; // Mark as visited and part of the first island\\n        \\n        dfs(grid, row - 1, col, visited);\\n        dfs(grid, row + 1, col, visited);\\n        dfs(grid, row, col - 1, visited);\\n        dfs(grid, row, col + 1, visited);\\n    }\\n    \\n    private boolean dfsFindSecondIsland(int[][] grid, int row, int col, boolean[][] visited) {\\n        int n = grid.length;\\n        \\n        if (row < 0 || row >= n || col < 0 || col >= n || visited[row][col] || grid[row][col] == 0) {\\n            return false;\\n        }\\n        \\n        visited[row][col] = true;\\n        \\n        if (grid[row][col] == 1) {\\n            return true;\\n        }\\n        \\n        return dfsFindSecondIsland(grid, row - 1, col, visited) ||\\n               dfsFindSecondIsland(grid, row + 1, col, visited) ||\\n               dfsFindSecondIsland(grid, row, col - 1, visited) ||\\n               dfsFindSecondIsland(grid, row, col + 1, visited);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass Solution {\\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        \\n        // Step 1: Find the first island and mark its cells as visited\\n        boolean found = false;\\n        for (int i = 0; i < n; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    dfs(grid, i, j, visited);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // Step 2: Use DFS to find the second island\\n        for (int i = 0; i < n; i++) {\\n            if (found) {\\n                break;\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && !visited[i][j]) {\\n                    if (dfsFindSecondIsland(grid, i, j, visited)) {\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Step 3: Use BFS to find the shortest path between the islands\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(new int[]{i, j});\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        int minFlips = 0;\\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                int[] curr = queue.poll();\\n                \\n                for (int[] direction : directions) {\\n                    int newRow = curr[0] + direction[0];\\n                    int newCol = curr[1] + direction[1];\\n                    \\n                    if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && !visited[newRow][newCol]) {\\n                        if (grid[newRow][newCol] == 1) {\\n                            return minFlips;\\n                        } else {\\n                            visited[newRow][newCol] = true;\\n                            queue.offer(new int[]{newRow, newCol});\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            minFlips++;\\n        }\\n        \\n        return -1; // No path found\\n    }\\n    \\n    private void dfs(int[][] grid, int row, int col, boolean[][] visited) {\\n        int n = grid.length;\\n        \\n        if (row < 0 || row >= n || col < 0 || col >= n || visited[row][col] || grid[row][col] == 0) {\\n            return;\\n        }\\n        \\n        visited[row][col] = true;\\n        grid[row][col] = 2; // Mark as visited and part of the first island\\n        \\n        dfs(grid, row - 1, col, visited);\\n        dfs(grid, row + 1, col, visited);\\n        dfs(grid, row, col - 1, visited);\\n        dfs(grid, row, col + 1, visited);\\n    }\\n    \\n    private boolean dfsFindSecondIsland(int[][] grid, int row, int col, boolean[][] visited) {\\n        int n = grid.length;\\n        \\n        if (row < 0 || row >= n || col < 0 || col >= n || visited[row][col] || grid[row][col] == 0) {\\n            return false;\\n        }\\n        \\n        visited[row][col] = true;\\n        \\n        if (grid[row][col] == 1) {\\n            return true;\\n        }\\n        \\n        return dfsFindSecondIsland(grid, row - 1, col, visited) ||\\n               dfsFindSecondIsland(grid, row + 1, col, visited) ||\\n               dfsFindSecondIsland(grid, row, col - 1, visited) ||\\n               dfsFindSecondIsland(grid, row, col + 1, visited);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549304,
                "title": "c-easy-to-understand-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question is very similar to infection or disease spreading problem in tree / graph right(there we had to tell the time taken for it to spread to all), so thought process is similar for BFS\\nthat we would have to know which all elements are belonging to first island then we would step forward in all directions to see if we have second island till we have found it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is pretty simple we just have to maintain a queue and visited\\n-> first we have to find all elements of first island and push it in the queue\\n->then do the BFS for all the elements simlutaneously by keeping track of current size of queue and after catering to all current elements then we will increase the ans by 1\\n\\n->then repeat it for all the children pushed into the queue while doing previous loop until we find the first element of second island.\\n\\n->just then we would return the ans.\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThe time complexity of the shortestBridge function in the given code is O(N*M), where N is the number of rows in the grid and M is the number of columns in the grid. This is because the function uses a depth-first search (DFS) approach to traverse the grid and mark the elements of the first island as 2. After that, it performs a breadth-first search (BFS) starting from the elements of the first island in the queue. The BFS explores the grid until it finds the second island (marked as 1) or explores all the cells in the grid. In the worst case, it needs to explore all the cells of the grid, which contributes to the time complexity.\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(NM) because it uses additional space to store the visited grid, the queue q, and other variables. The visited grid has the same size as the input grid, requiring O(NM) space. The queue q can store at most all the cells of the grid, so it also contributes to O(NM) space. Overall, the space complexity is O(NM) as well.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(int i ,int j,vector<vector<int>>&grid){\\n        if(i>=0 && j>=0 && i<grid.size() && j<grid[0].size()) return true;\\n        return false;\\n    }\\n\\n    void dfs(int i ,int j,vector<vector<int>> &grid,queue<pair<int,int>>&q,vector<vector<int>>&visited){\\n        q.push(make_pair(i,j));\\n        grid[i][j]=2;\\n        visited[i][j]=1;\\n        //up\\n        if(isValid(i-1,j,grid) && grid[i-1][j]==1 && !visited[i-1][j]){\\n            dfs(i-1,j,grid,q,visited);\\n        }\\n        // down\\n        if (isValid(i+1, j,grid) && grid[i+1][j] == 1 && !visited[i+1][j]) {\\n            dfs(i+1, j, grid, q, visited); \\n        }\\n\\n        //left\\n        if (isValid(i, j-1,grid) && grid[i][j-1] == 1 && !visited[i][j-1]) {\\n            dfs(i, j-1, grid, q, visited); \\n        }\\n\\n        //right\\n        if (isValid(i, j+1,grid) && grid[i][j+1] == 1 && !visited[i][j+1]) {\\n            dfs(i, j+1, grid, q, visited); \\n        }\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        vector<vector<int>> visited(grid.size(),vector<int>(grid[0].size(),0));\\n        int flag=0;\\n        for(int i =0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    flag=1;\\n                    dfs(i,j,grid,q,visited);\\n                    break;\\n                }\\n            }\\n            if(flag) break;\\n        }\\n\\n        //till here the first island elements has been marked as 2 and pushed into the queue\\n        \\n        int ans=0;\\n        while(!q.empty()){\\n            int currSize=q.size();\\n            for(int i =0;i<currSize;i++){\\n                auto ele=q.front();q.pop();\\n                int r=ele.first; int c=ele.second;\\n                visited[r][c]=1;\\n                //up\\n                if (isValid(r-1, c, grid) && !visited[r-1][c]) {\\n                    if (grid[r-1][c] == 1) return ans;\\n                    else if (grid[r-1][c] == 0) {\\n                        visited[r-1][c]=1;\\n                        q.push(make_pair(r-1, c));\\n                    }\\n                }\\n                //down\\n                if (isValid(r+1, c, grid) && !visited[r+1][c]) {\\n                    if (grid[r+1][c] == 1) return ans;\\n                    else if (grid[r+1][c] == 0) {\\n                        q.push(make_pair(r+1, c));\\n                        visited[r+1][c]=1;\\n                    }\\n                }\\n                //left\\n                if (isValid(r, c-1, grid) && !visited[r][c-1]) {\\n                    if (grid[r][c-1] == 1) return ans;\\n                    else if (grid[r][c-1] == 0) {\\n                        q.push(make_pair(r, c-1));\\n                        visited[r][c-1]=1;\\n                    }\\n                }\\n                //right\\n                if (isValid(r, c+1, grid) && !visited[r][c+1]) {\\n                    if (grid[r][c+1] == 1) return ans;\\n                    else if (grid[r][c+1] == 0) {\\n                        q.push(make_pair(r, c+1));\\n                        visited[r][c+1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(int i ,int j,vector<vector<int>>&grid){\\n        if(i>=0 && j>=0 && i<grid.size() && j<grid[0].size()) return true;\\n        return false;\\n    }\\n\\n    void dfs(int i ,int j,vector<vector<int>> &grid,queue<pair<int,int>>&q,vector<vector<int>>&visited){\\n        q.push(make_pair(i,j));\\n        grid[i][j]=2;\\n        visited[i][j]=1;\\n        //up\\n        if(isValid(i-1,j,grid) && grid[i-1][j]==1 && !visited[i-1][j]){\\n            dfs(i-1,j,grid,q,visited);\\n        }\\n        // down\\n        if (isValid(i+1, j,grid) && grid[i+1][j] == 1 && !visited[i+1][j]) {\\n            dfs(i+1, j, grid, q, visited); \\n        }\\n\\n        //left\\n        if (isValid(i, j-1,grid) && grid[i][j-1] == 1 && !visited[i][j-1]) {\\n            dfs(i, j-1, grid, q, visited); \\n        }\\n\\n        //right\\n        if (isValid(i, j+1,grid) && grid[i][j+1] == 1 && !visited[i][j+1]) {\\n            dfs(i, j+1, grid, q, visited); \\n        }\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        vector<vector<int>> visited(grid.size(),vector<int>(grid[0].size(),0));\\n        int flag=0;\\n        for(int i =0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    flag=1;\\n                    dfs(i,j,grid,q,visited);\\n                    break;\\n                }\\n            }\\n            if(flag) break;\\n        }\\n\\n        //till here the first island elements has been marked as 2 and pushed into the queue\\n        \\n        int ans=0;\\n        while(!q.empty()){\\n            int currSize=q.size();\\n            for(int i =0;i<currSize;i++){\\n                auto ele=q.front();q.pop();\\n                int r=ele.first; int c=ele.second;\\n                visited[r][c]=1;\\n                //up\\n                if (isValid(r-1, c, grid) && !visited[r-1][c]) {\\n                    if (grid[r-1][c] == 1) return ans;\\n                    else if (grid[r-1][c] == 0) {\\n                        visited[r-1][c]=1;\\n                        q.push(make_pair(r-1, c));\\n                    }\\n                }\\n                //down\\n                if (isValid(r+1, c, grid) && !visited[r+1][c]) {\\n                    if (grid[r+1][c] == 1) return ans;\\n                    else if (grid[r+1][c] == 0) {\\n                        q.push(make_pair(r+1, c));\\n                        visited[r+1][c]=1;\\n                    }\\n                }\\n                //left\\n                if (isValid(r, c-1, grid) && !visited[r][c-1]) {\\n                    if (grid[r][c-1] == 1) return ans;\\n                    else if (grid[r][c-1] == 0) {\\n                        q.push(make_pair(r, c-1));\\n                        visited[r][c-1]=1;\\n                    }\\n                }\\n                //right\\n                if (isValid(r, c+1, grid) && !visited[r][c+1]) {\\n                    if (grid[r][c+1] == 1) return ans;\\n                    else if (grid[r][c+1] == 0) {\\n                        q.push(make_pair(r, c+1));\\n                        visited[r][c+1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549022,
                "title": "dfs-bfs",
                "content": "1. Run DFS to mark all cells that belong to one land.\\n2. Add their neighbors to a queue.\\n3. Run BFS until you find a cell that is 1 (this means that we have found the other land).\\n4. Return the current level.\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int r,c;\\n        public Pair(int r, int c){\\n            this.r=r;\\n            this.c=c;\\n        }\\n    }\\n    int n;\\n    Queue<Pair> q = new LinkedList<>();\\n    public int shortestBridge(int[][] grid) {\\n        // run connected componenet on one land\\n        n = grid.length;\\n        boolean f = false;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==1){\\n                    dfs(i,j, grid);\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            if(f) break;\\n        }\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                Pair cur = q.poll();\\n                if(cur.r < 0 || cur.r >=n || cur.c < 0 || cur.c >= n || \\n                grid[cur.r][cur.c] == -1){\\n                    continue;\\n                }\\n                if(grid[cur.r][cur.c] == 1){\\n                    return level;\\n                }\\n                // mark it as visited\\n                grid[cur.r][cur.c] = -1;\\n                // add its neighbors\\n                q.add(new Pair(cur.r+1, cur.c));\\n                q.add(new Pair(cur.r-1, cur.c));\\n                q.add(new Pair(cur.r, cur.c+1));\\n                q.add(new Pair(cur.r, cur.c-1));\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n    \\n    private void dfs(int r, int c, int[][] grid){\\n        if(r<0 || r>=n || c<0 || c>=n){\\n            return;\\n        }\\n        if(grid[r][c] == 0){\\n            // add to queue\\n            q.add(new Pair(r,c));\\n            // mark as visited\\n            grid[r][c] = 2;\\n            return;\\n        }\\n        if(grid[r][c] == 1){\\n            grid[r][c] = -1;\\n            dfs(r+1,c,grid);\\n            dfs(r-1, c, grid);\\n            dfs(r, c+1, grid);\\n            dfs(r,c-1,grid);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int r,c;\\n        public Pair(int r, int c){\\n            this.r=r;\\n            this.c=c;\\n        }\\n    }\\n    int n;\\n    Queue<Pair> q = new LinkedList<>();\\n    public int shortestBridge(int[][] grid) {\\n        // run connected componenet on one land\\n        n = grid.length;\\n        boolean f = false;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==1){\\n                    dfs(i,j, grid);\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            if(f) break;\\n        }\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                Pair cur = q.poll();\\n                if(cur.r < 0 || cur.r >=n || cur.c < 0 || cur.c >= n || \\n                grid[cur.r][cur.c] == -1){\\n                    continue;\\n                }\\n                if(grid[cur.r][cur.c] == 1){\\n                    return level;\\n                }\\n                // mark it as visited\\n                grid[cur.r][cur.c] = -1;\\n                // add its neighbors\\n                q.add(new Pair(cur.r+1, cur.c));\\n                q.add(new Pair(cur.r-1, cur.c));\\n                q.add(new Pair(cur.r, cur.c+1));\\n                q.add(new Pair(cur.r, cur.c-1));\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n    \\n    private void dfs(int r, int c, int[][] grid){\\n        if(r<0 || r>=n || c<0 || c>=n){\\n            return;\\n        }\\n        if(grid[r][c] == 0){\\n            // add to queue\\n            q.add(new Pair(r,c));\\n            // mark as visited\\n            grid[r][c] = 2;\\n            return;\\n        }\\n        if(grid[r][c] == 1){\\n            grid[r][c] = -1;\\n            dfs(r+1,c,grid);\\n            dfs(r-1, c, grid);\\n            dfs(r, c+1, grid);\\n            dfs(r,c-1,grid);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1641550,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1734247,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1819264,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1734246,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1875787,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1565687,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1669386,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1901064,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1573862,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1900360,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1641550,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1734247,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1819264,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1734246,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1875787,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1565687,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1669386,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1901064,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1573862,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1900360,
                "content": [
                    {
                        "username": "barstow123",
                        "content": "I had this problem in a FAANG interview."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "what\\'s the follow up question on this problem in the actual interview?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "A MasterPiece for DFS and BFS."
                    },
                    {
                        "username": "santanusen",
                        "content": "BFS can start from multiple sources is a great revelation."
                    },
                    {
                        "username": "nidhitvaishnav",
                        "content": "I had this question in Snap interview."
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Intuition\n- Use DFS for traversing the first island (BFS can also be used).\n- Use BFS to find the shortest path to the second island.\n### Approach\n- Traverse the first island using DFS.\n- While performing DFS, add all the water boundaries (i, j) where `grid[i][j] = 0` of the first island to the queue.\n- Utilize a multi-source BFS to determine the shortest path to the second island."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Feels like Hard instead of Medium."
                    },
                    {
                        "username": "charanarc3",
                        "content": "it is medium because of its constraints"
                    },
                    {
                        "username": "sykKo",
                        "content": "I know this is beyond this problem, but when I first read this question I ignored \"there\\'re two islands\" and thought about half an hour without any idea.\\nNow I\\'ve solved this problem and start thinking about this again. What if there\\'re more than 2 islands?\\nI haven\\'t got my answer from search engine because I don\\'t know how to describe this question, so can somebody give me a link to such solution?"
                    },
                    {
                        "username": "hero080",
                        "content": "You could actually just mark all the islands with different numbers and BFS (starting from their beaches) all of them.\\nBecause each of your BFS exists when it hits another island, the effective time complexity would be pretty close to linear."
                    },
                    {
                        "username": "shub_hamm",
                        "content": "now chat gpt is there for you"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I am thinking about this solution.\\n\\nStart with a single pass of DFS/BFS to find all islands, that should be easy.\\n\\nNext, simulate there are some scouts that is scouting from the edges of island, so that at time t = 1, all the sea that is distance 1 from the island is scouted, and that increase to distance 2 at t = 2, and so on. You can think of that as some sort of BFS ever enqueued states.\\n\\nOnce a scout reach another island (actually both scout will reach each other at the same time), we merge the islands by building a bridge between them. This should be the shortest distance between the two islands - when we merge the islands, we need to make sure the scouts are de-duplicated.\\n\\nAs the scouting goes on, eventually we should have merged all islands and we are done.\\n\\nActually implementing it should not be hard - I am not sure about proof of correctness and time/space complexities though.\\n\\nI am thinking about this is an analogy of the Kruskal\\'s minimum spanning tree algorithm. In the sense that we pick the two closest unmerged island and merge them together all the time."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "There is a question named shortest distance between land and water (or similar) that uses the idea of multi-source BFS. The idea for k - component islands is to start BFS from all the border points and add the distance value when all of them merge (stop when you meet the traces of another BFS) ( make a Seperate dist matrix)"
                    },
                    {
                        "username": "techie_guy",
                        "content": "Such an elegant question, a must for clearing your BFS and DFS concepts"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "this is the only question you will need to understand the concept of DFS and BFS."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "not if I could clear it without any bfs"
                    },
                    {
                        "username": "Hemanth0231",
                        "content": "![image](https://assets.leetcode.com/users/f20170231/image_1591271355.png)\\n\\n\\nWhat the hell is wrong with leetcode OJ?\\nHow to fix this?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Your program giving different results on different runs is not Leetcode\\'s issue. You might not have initialized values properly and some runs might have been okay with initial zero values while at other times another random value might have been there."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "send email to ask the support of leetcode.com\nthey will be glad you report a bug :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Medium on weekend is always very hard\n=======================\n\nThis test case is hopefully useful\ngrid =\n[[0,1,0,0,0],[0,1,0,1,1],[0,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0]]\ngride before returning: 2 for island A, -1, -2,.., -d denote the water region with distance d to island A.\n```\n -1  2 -1 -2  0\n -1  2 -1  1  1\n -2 -1 -2  0  1\n  0 -2  0  0  0\n  0  0  0  0  0\n```\nhttps://youtu.be/9Lx7yr-tmfI\n[Please turn on the English subtitles , if needed]\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/shortest-bridge/solutions/3546667/c-solution-with-distance-info-on-the-graph/"
                    }
                ]
            },
            {
                "id": 1900914,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "Problem-setter must get extra coins for such a wonderful question."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'ve never had a weekend since I started leetcode streak."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@toravipatel](/toravipatel) I\\'m an island boy"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true..same for me...it has now become addiction for me..."
                    },
                    {
                        "username": "ddiazghub",
                        "content": "What is going on, my program passes 97 out of 97 test cases but it is showing time limit exceeded on an empty test case"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yep, I also managed to solve it with a minor optimization. I changed the point from which DFS starts when searching for the second island from the first one. This allowed me to simplify the program's logic and remove some redundant statements."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@andreped](/andreped) I\\'ve found out that is not unique issue. It just means that you are almost there. I\\'ve managed to solve it with slight optimization replacing list with an array in one helper method."
                    },
                    {
                        "username": "andreped",
                        "content": "Same here. Did you manage to find out why? I had some timeouts in a test case earlier which I managed to resolve, but somehow stuck on the very last one..."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "I have the same issue. "
                    },
                    {
                        "username": "vatsa_",
                        "content": "What if you want to connect more than 2 bridges. In that case we might want to probably actually join the 2 islands and connect from there instead of just seeing what will be the shortest bridge. \\nAny idea on the best approach to solve that probelm ?"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/05/leetcode-934-Shortest-Bridge/\\nHope helpful"
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Approach:\\n1. Store all {i, j} of 1st island using DFS\\n2. Store all {i, j} of 2st island using DFS\\n3. Choose all possible {i, j} of 1st & 2nd island and find distance and return minimum distance"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You can store only one island and then find the closest \"1\" from each island tile that doesn\\'t belong to the island."
                    },
                    {
                        "username": "GD18",
                        "content": "DAMN this question was fun!, a little lengthy I feel, but this is like a perfect question for DFS AND BFS practice, legit this now is amongst my favs."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "isn\\'t it hard ??"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I do not think so concept is easy though use dfs then find shortest by bfs only implementation is there logic is simple i think"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Poor me, solving it using Disjoint Set Union..."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@sandeepmourya0720](/sandeepmourya0720) It was fun though :D "
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "lol I started with DSU too, pretty soon realized it will be more complicated than simple dfs and bfs"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang \\uD83E\\uDD79"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Gang gang"
                    }
                ]
            },
            {
                "id": 1900660,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "Problem-setter must get extra coins for such a wonderful question."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'ve never had a weekend since I started leetcode streak."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@toravipatel](/toravipatel) I\\'m an island boy"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true..same for me...it has now become addiction for me..."
                    },
                    {
                        "username": "ddiazghub",
                        "content": "What is going on, my program passes 97 out of 97 test cases but it is showing time limit exceeded on an empty test case"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yep, I also managed to solve it with a minor optimization. I changed the point from which DFS starts when searching for the second island from the first one. This allowed me to simplify the program's logic and remove some redundant statements."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@andreped](/andreped) I\\'ve found out that is not unique issue. It just means that you are almost there. I\\'ve managed to solve it with slight optimization replacing list with an array in one helper method."
                    },
                    {
                        "username": "andreped",
                        "content": "Same here. Did you manage to find out why? I had some timeouts in a test case earlier which I managed to resolve, but somehow stuck on the very last one..."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "I have the same issue. "
                    },
                    {
                        "username": "vatsa_",
                        "content": "What if you want to connect more than 2 bridges. In that case we might want to probably actually join the 2 islands and connect from there instead of just seeing what will be the shortest bridge. \\nAny idea on the best approach to solve that probelm ?"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/05/leetcode-934-Shortest-Bridge/\\nHope helpful"
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Approach:\\n1. Store all {i, j} of 1st island using DFS\\n2. Store all {i, j} of 2st island using DFS\\n3. Choose all possible {i, j} of 1st & 2nd island and find distance and return minimum distance"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You can store only one island and then find the closest \"1\" from each island tile that doesn\\'t belong to the island."
                    },
                    {
                        "username": "GD18",
                        "content": "DAMN this question was fun!, a little lengthy I feel, but this is like a perfect question for DFS AND BFS practice, legit this now is amongst my favs."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "isn\\'t it hard ??"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I do not think so concept is easy though use dfs then find shortest by bfs only implementation is there logic is simple i think"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Poor me, solving it using Disjoint Set Union..."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@sandeepmourya0720](/sandeepmourya0720) It was fun though :D "
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "lol I started with DSU too, pretty soon realized it will be more complicated than simple dfs and bfs"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang \\uD83E\\uDD79"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Gang gang"
                    }
                ]
            },
            {
                "id": 1900560,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "Problem-setter must get extra coins for such a wonderful question."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'ve never had a weekend since I started leetcode streak."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@toravipatel](/toravipatel) I\\'m an island boy"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true..same for me...it has now become addiction for me..."
                    },
                    {
                        "username": "ddiazghub",
                        "content": "What is going on, my program passes 97 out of 97 test cases but it is showing time limit exceeded on an empty test case"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yep, I also managed to solve it with a minor optimization. I changed the point from which DFS starts when searching for the second island from the first one. This allowed me to simplify the program's logic and remove some redundant statements."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@andreped](/andreped) I\\'ve found out that is not unique issue. It just means that you are almost there. I\\'ve managed to solve it with slight optimization replacing list with an array in one helper method."
                    },
                    {
                        "username": "andreped",
                        "content": "Same here. Did you manage to find out why? I had some timeouts in a test case earlier which I managed to resolve, but somehow stuck on the very last one..."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "I have the same issue. "
                    },
                    {
                        "username": "vatsa_",
                        "content": "What if you want to connect more than 2 bridges. In that case we might want to probably actually join the 2 islands and connect from there instead of just seeing what will be the shortest bridge. \\nAny idea on the best approach to solve that probelm ?"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/05/leetcode-934-Shortest-Bridge/\\nHope helpful"
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Approach:\\n1. Store all {i, j} of 1st island using DFS\\n2. Store all {i, j} of 2st island using DFS\\n3. Choose all possible {i, j} of 1st & 2nd island and find distance and return minimum distance"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You can store only one island and then find the closest \"1\" from each island tile that doesn\\'t belong to the island."
                    },
                    {
                        "username": "GD18",
                        "content": "DAMN this question was fun!, a little lengthy I feel, but this is like a perfect question for DFS AND BFS practice, legit this now is amongst my favs."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "isn\\'t it hard ??"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I do not think so concept is easy though use dfs then find shortest by bfs only implementation is there logic is simple i think"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Poor me, solving it using Disjoint Set Union..."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@sandeepmourya0720](/sandeepmourya0720) It was fun though :D "
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "lol I started with DSU too, pretty soon realized it will be more complicated than simple dfs and bfs"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang \\uD83E\\uDD79"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Gang gang"
                    }
                ]
            },
            {
                "id": 1574441,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "Problem-setter must get extra coins for such a wonderful question."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'ve never had a weekend since I started leetcode streak."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@toravipatel](/toravipatel) I\\'m an island boy"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true..same for me...it has now become addiction for me..."
                    },
                    {
                        "username": "ddiazghub",
                        "content": "What is going on, my program passes 97 out of 97 test cases but it is showing time limit exceeded on an empty test case"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yep, I also managed to solve it with a minor optimization. I changed the point from which DFS starts when searching for the second island from the first one. This allowed me to simplify the program's logic and remove some redundant statements."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@andreped](/andreped) I\\'ve found out that is not unique issue. It just means that you are almost there. I\\'ve managed to solve it with slight optimization replacing list with an array in one helper method."
                    },
                    {
                        "username": "andreped",
                        "content": "Same here. Did you manage to find out why? I had some timeouts in a test case earlier which I managed to resolve, but somehow stuck on the very last one..."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "I have the same issue. "
                    },
                    {
                        "username": "vatsa_",
                        "content": "What if you want to connect more than 2 bridges. In that case we might want to probably actually join the 2 islands and connect from there instead of just seeing what will be the shortest bridge. \\nAny idea on the best approach to solve that probelm ?"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/05/leetcode-934-Shortest-Bridge/\\nHope helpful"
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Approach:\\n1. Store all {i, j} of 1st island using DFS\\n2. Store all {i, j} of 2st island using DFS\\n3. Choose all possible {i, j} of 1st & 2nd island and find distance and return minimum distance"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You can store only one island and then find the closest \"1\" from each island tile that doesn\\'t belong to the island."
                    },
                    {
                        "username": "GD18",
                        "content": "DAMN this question was fun!, a little lengthy I feel, but this is like a perfect question for DFS AND BFS practice, legit this now is amongst my favs."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "isn\\'t it hard ??"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I do not think so concept is easy though use dfs then find shortest by bfs only implementation is there logic is simple i think"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Poor me, solving it using Disjoint Set Union..."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@sandeepmourya0720](/sandeepmourya0720) It was fun though :D "
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "lol I started with DSU too, pretty soon realized it will be more complicated than simple dfs and bfs"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang \\uD83E\\uDD79"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Gang gang"
                    }
                ]
            },
            {
                "id": 1568068,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "Problem-setter must get extra coins for such a wonderful question."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'ve never had a weekend since I started leetcode streak."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@toravipatel](/toravipatel) I\\'m an island boy"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true..same for me...it has now become addiction for me..."
                    },
                    {
                        "username": "ddiazghub",
                        "content": "What is going on, my program passes 97 out of 97 test cases but it is showing time limit exceeded on an empty test case"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yep, I also managed to solve it with a minor optimization. I changed the point from which DFS starts when searching for the second island from the first one. This allowed me to simplify the program's logic and remove some redundant statements."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@andreped](/andreped) I\\'ve found out that is not unique issue. It just means that you are almost there. I\\'ve managed to solve it with slight optimization replacing list with an array in one helper method."
                    },
                    {
                        "username": "andreped",
                        "content": "Same here. Did you manage to find out why? I had some timeouts in a test case earlier which I managed to resolve, but somehow stuck on the very last one..."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "I have the same issue. "
                    },
                    {
                        "username": "vatsa_",
                        "content": "What if you want to connect more than 2 bridges. In that case we might want to probably actually join the 2 islands and connect from there instead of just seeing what will be the shortest bridge. \\nAny idea on the best approach to solve that probelm ?"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/05/leetcode-934-Shortest-Bridge/\\nHope helpful"
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Approach:\\n1. Store all {i, j} of 1st island using DFS\\n2. Store all {i, j} of 2st island using DFS\\n3. Choose all possible {i, j} of 1st & 2nd island and find distance and return minimum distance"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You can store only one island and then find the closest \"1\" from each island tile that doesn\\'t belong to the island."
                    },
                    {
                        "username": "GD18",
                        "content": "DAMN this question was fun!, a little lengthy I feel, but this is like a perfect question for DFS AND BFS practice, legit this now is amongst my favs."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "isn\\'t it hard ??"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I do not think so concept is easy though use dfs then find shortest by bfs only implementation is there logic is simple i think"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Poor me, solving it using Disjoint Set Union..."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@sandeepmourya0720](/sandeepmourya0720) It was fun though :D "
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "lol I started with DSU too, pretty soon realized it will be more complicated than simple dfs and bfs"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang \\uD83E\\uDD79"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Gang gang"
                    }
                ]
            },
            {
                "id": 1901389,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "Problem-setter must get extra coins for such a wonderful question."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'ve never had a weekend since I started leetcode streak."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@toravipatel](/toravipatel) I\\'m an island boy"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true..same for me...it has now become addiction for me..."
                    },
                    {
                        "username": "ddiazghub",
                        "content": "What is going on, my program passes 97 out of 97 test cases but it is showing time limit exceeded on an empty test case"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yep, I also managed to solve it with a minor optimization. I changed the point from which DFS starts when searching for the second island from the first one. This allowed me to simplify the program's logic and remove some redundant statements."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@andreped](/andreped) I\\'ve found out that is not unique issue. It just means that you are almost there. I\\'ve managed to solve it with slight optimization replacing list with an array in one helper method."
                    },
                    {
                        "username": "andreped",
                        "content": "Same here. Did you manage to find out why? I had some timeouts in a test case earlier which I managed to resolve, but somehow stuck on the very last one..."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "I have the same issue. "
                    },
                    {
                        "username": "vatsa_",
                        "content": "What if you want to connect more than 2 bridges. In that case we might want to probably actually join the 2 islands and connect from there instead of just seeing what will be the shortest bridge. \\nAny idea on the best approach to solve that probelm ?"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/05/leetcode-934-Shortest-Bridge/\\nHope helpful"
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Approach:\\n1. Store all {i, j} of 1st island using DFS\\n2. Store all {i, j} of 2st island using DFS\\n3. Choose all possible {i, j} of 1st & 2nd island and find distance and return minimum distance"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You can store only one island and then find the closest \"1\" from each island tile that doesn\\'t belong to the island."
                    },
                    {
                        "username": "GD18",
                        "content": "DAMN this question was fun!, a little lengthy I feel, but this is like a perfect question for DFS AND BFS practice, legit this now is amongst my favs."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "isn\\'t it hard ??"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I do not think so concept is easy though use dfs then find shortest by bfs only implementation is there logic is simple i think"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Poor me, solving it using Disjoint Set Union..."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@sandeepmourya0720](/sandeepmourya0720) It was fun though :D "
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "lol I started with DSU too, pretty soon realized it will be more complicated than simple dfs and bfs"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang \\uD83E\\uDD79"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Gang gang"
                    }
                ]
            },
            {
                "id": 1901282,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "Problem-setter must get extra coins for such a wonderful question."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'ve never had a weekend since I started leetcode streak."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@toravipatel](/toravipatel) I\\'m an island boy"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true..same for me...it has now become addiction for me..."
                    },
                    {
                        "username": "ddiazghub",
                        "content": "What is going on, my program passes 97 out of 97 test cases but it is showing time limit exceeded on an empty test case"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yep, I also managed to solve it with a minor optimization. I changed the point from which DFS starts when searching for the second island from the first one. This allowed me to simplify the program's logic and remove some redundant statements."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@andreped](/andreped) I\\'ve found out that is not unique issue. It just means that you are almost there. I\\'ve managed to solve it with slight optimization replacing list with an array in one helper method."
                    },
                    {
                        "username": "andreped",
                        "content": "Same here. Did you manage to find out why? I had some timeouts in a test case earlier which I managed to resolve, but somehow stuck on the very last one..."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "I have the same issue. "
                    },
                    {
                        "username": "vatsa_",
                        "content": "What if you want to connect more than 2 bridges. In that case we might want to probably actually join the 2 islands and connect from there instead of just seeing what will be the shortest bridge. \\nAny idea on the best approach to solve that probelm ?"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/05/leetcode-934-Shortest-Bridge/\\nHope helpful"
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Approach:\\n1. Store all {i, j} of 1st island using DFS\\n2. Store all {i, j} of 2st island using DFS\\n3. Choose all possible {i, j} of 1st & 2nd island and find distance and return minimum distance"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You can store only one island and then find the closest \"1\" from each island tile that doesn\\'t belong to the island."
                    },
                    {
                        "username": "GD18",
                        "content": "DAMN this question was fun!, a little lengthy I feel, but this is like a perfect question for DFS AND BFS practice, legit this now is amongst my favs."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "isn\\'t it hard ??"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I do not think so concept is easy though use dfs then find shortest by bfs only implementation is there logic is simple i think"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Poor me, solving it using Disjoint Set Union..."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@sandeepmourya0720](/sandeepmourya0720) It was fun though :D "
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "lol I started with DSU too, pretty soon realized it will be more complicated than simple dfs and bfs"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang \\uD83E\\uDD79"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Gang gang"
                    }
                ]
            },
            {
                "id": 1901148,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "Problem-setter must get extra coins for such a wonderful question."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'ve never had a weekend since I started leetcode streak."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@toravipatel](/toravipatel) I\\'m an island boy"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true..same for me...it has now become addiction for me..."
                    },
                    {
                        "username": "ddiazghub",
                        "content": "What is going on, my program passes 97 out of 97 test cases but it is showing time limit exceeded on an empty test case"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yep, I also managed to solve it with a minor optimization. I changed the point from which DFS starts when searching for the second island from the first one. This allowed me to simplify the program's logic and remove some redundant statements."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@andreped](/andreped) I\\'ve found out that is not unique issue. It just means that you are almost there. I\\'ve managed to solve it with slight optimization replacing list with an array in one helper method."
                    },
                    {
                        "username": "andreped",
                        "content": "Same here. Did you manage to find out why? I had some timeouts in a test case earlier which I managed to resolve, but somehow stuck on the very last one..."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "I have the same issue. "
                    },
                    {
                        "username": "vatsa_",
                        "content": "What if you want to connect more than 2 bridges. In that case we might want to probably actually join the 2 islands and connect from there instead of just seeing what will be the shortest bridge. \\nAny idea on the best approach to solve that probelm ?"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/05/leetcode-934-Shortest-Bridge/\\nHope helpful"
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Approach:\\n1. Store all {i, j} of 1st island using DFS\\n2. Store all {i, j} of 2st island using DFS\\n3. Choose all possible {i, j} of 1st & 2nd island and find distance and return minimum distance"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You can store only one island and then find the closest \"1\" from each island tile that doesn\\'t belong to the island."
                    },
                    {
                        "username": "GD18",
                        "content": "DAMN this question was fun!, a little lengthy I feel, but this is like a perfect question for DFS AND BFS practice, legit this now is amongst my favs."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "isn\\'t it hard ??"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I do not think so concept is easy though use dfs then find shortest by bfs only implementation is there logic is simple i think"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Poor me, solving it using Disjoint Set Union..."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@sandeepmourya0720](/sandeepmourya0720) It was fun though :D "
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "lol I started with DSU too, pretty soon realized it will be more complicated than simple dfs and bfs"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang \\uD83E\\uDD79"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Gang gang"
                    }
                ]
            },
            {
                "id": 1901100,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "Problem-setter must get extra coins for such a wonderful question."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'ve never had a weekend since I started leetcode streak."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@toravipatel](/toravipatel) I\\'m an island boy"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true..same for me...it has now become addiction for me..."
                    },
                    {
                        "username": "ddiazghub",
                        "content": "What is going on, my program passes 97 out of 97 test cases but it is showing time limit exceeded on an empty test case"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yep, I also managed to solve it with a minor optimization. I changed the point from which DFS starts when searching for the second island from the first one. This allowed me to simplify the program's logic and remove some redundant statements."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@andreped](/andreped) I\\'ve found out that is not unique issue. It just means that you are almost there. I\\'ve managed to solve it with slight optimization replacing list with an array in one helper method."
                    },
                    {
                        "username": "andreped",
                        "content": "Same here. Did you manage to find out why? I had some timeouts in a test case earlier which I managed to resolve, but somehow stuck on the very last one..."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "I have the same issue. "
                    },
                    {
                        "username": "vatsa_",
                        "content": "What if you want to connect more than 2 bridges. In that case we might want to probably actually join the 2 islands and connect from there instead of just seeing what will be the shortest bridge. \\nAny idea on the best approach to solve that probelm ?"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/05/leetcode-934-Shortest-Bridge/\\nHope helpful"
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Approach:\\n1. Store all {i, j} of 1st island using DFS\\n2. Store all {i, j} of 2st island using DFS\\n3. Choose all possible {i, j} of 1st & 2nd island and find distance and return minimum distance"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You can store only one island and then find the closest \"1\" from each island tile that doesn\\'t belong to the island."
                    },
                    {
                        "username": "GD18",
                        "content": "DAMN this question was fun!, a little lengthy I feel, but this is like a perfect question for DFS AND BFS practice, legit this now is amongst my favs."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "isn\\'t it hard ??"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I do not think so concept is easy though use dfs then find shortest by bfs only implementation is there logic is simple i think"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Poor me, solving it using Disjoint Set Union..."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@sandeepmourya0720](/sandeepmourya0720) It was fun though :D "
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "lol I started with DSU too, pretty soon realized it will be more complicated than simple dfs and bfs"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang \\uD83E\\uDD79"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Gang gang"
                    }
                ]
            },
            {
                "id": 1900756,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "Problem-setter must get extra coins for such a wonderful question."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'ve never had a weekend since I started leetcode streak."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@toravipatel](/toravipatel) I\\'m an island boy"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true..same for me...it has now become addiction for me..."
                    },
                    {
                        "username": "ddiazghub",
                        "content": "What is going on, my program passes 97 out of 97 test cases but it is showing time limit exceeded on an empty test case"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yep, I also managed to solve it with a minor optimization. I changed the point from which DFS starts when searching for the second island from the first one. This allowed me to simplify the program's logic and remove some redundant statements."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@andreped](/andreped) I\\'ve found out that is not unique issue. It just means that you are almost there. I\\'ve managed to solve it with slight optimization replacing list with an array in one helper method."
                    },
                    {
                        "username": "andreped",
                        "content": "Same here. Did you manage to find out why? I had some timeouts in a test case earlier which I managed to resolve, but somehow stuck on the very last one..."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "I have the same issue. "
                    },
                    {
                        "username": "vatsa_",
                        "content": "What if you want to connect more than 2 bridges. In that case we might want to probably actually join the 2 islands and connect from there instead of just seeing what will be the shortest bridge. \\nAny idea on the best approach to solve that probelm ?"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/05/leetcode-934-Shortest-Bridge/\\nHope helpful"
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Approach:\\n1. Store all {i, j} of 1st island using DFS\\n2. Store all {i, j} of 2st island using DFS\\n3. Choose all possible {i, j} of 1st & 2nd island and find distance and return minimum distance"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You can store only one island and then find the closest \"1\" from each island tile that doesn\\'t belong to the island."
                    },
                    {
                        "username": "GD18",
                        "content": "DAMN this question was fun!, a little lengthy I feel, but this is like a perfect question for DFS AND BFS practice, legit this now is amongst my favs."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "isn\\'t it hard ??"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I do not think so concept is easy though use dfs then find shortest by bfs only implementation is there logic is simple i think"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Poor me, solving it using Disjoint Set Union..."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@sandeepmourya0720](/sandeepmourya0720) It was fun though :D "
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "lol I started with DSU too, pretty soon realized it will be more complicated than simple dfs and bfs"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang \\uD83E\\uDD79"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Gang gang"
                    }
                ]
            },
            {
                "id": 1900634,
                "content": [
                    {
                        "username": "Jaideep_dahiya",
                        "content": "[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\\nCan someone explain how in the above testcase there are 2 islands ? \\nSorry if this is trivial but i am poor at graph questions.\\nThanks!"
                    },
                    {
                        "username": "RybakovIS",
                        "content": "You can paint this:\\n**1** **1**  **1** **1**  **1**\\n**1** 0 0 0 **1**\\n**1** 0 <ins>**1**</ins> 0 **1**\\n**1** 0 0 0 **1**\\n**1** **1**  **1** **1**  **1**"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Island inside an island\\u2026"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Flipkart OLT problem "
                    },
                    {
                        "username": "who_rules",
                        "content": "I would estimate it as upper-medium. Not very hard, but a lot of code"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "I think we can modify 1 of the island with something like \\'2\\' and apply bfs and return the the minimum no of cells taken from bfs of 2 to encouter 1"
                    },
                    {
                        "username": "loloksEth",
                        "content": "midium/hard   80/20 i think because of constrains"
                    },
                    {
                        "username": "arijit__12",
                        "content": "If we are traversing through an matrix if we are encountering 1 it means that is obv a part of island beacuse there is exactly 2 island exist and now if we encounter zero we can count till we reach 1 while flpping we can convert that 0 into 1.and we can extract the min of that.\\nIs this not an valid idea??? first I came up with this "
                    },
                    {
                        "username": "arijit__12",
                        "content": "[@Blatogh](/Blatogh) ok thank u"
                    },
                    {
                        "username": "Blatogh",
                        "content": "If you do this question you will see this idea is only valid for the ISLAND that only occupies one block. The question\\'s islands are not only occuping on block of the matrix. "
                    },
                    {
                        "username": "Blatogh",
                        "content": "BFS + DFS is the better than using 2 BFS. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "What does it mean for the 1\\'s to be \"4-directionally connected\"? The test cases seem to to include lagoons of zeros with at least one neighbor being in the island of 1\\'s ... unless I\\'m misreading some of these matrices. On the other hand, the test cases don\\'t seem to include \"lagoons\" inside of an island with internal zeros (0\\'s with all neighbors being 0), otherwise I think my solution would have failed. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "[@andreped](/andreped) Thanks for the helpful response. I was overly concerned with the notion of 4-connectivity on boundaries and corners. Similar in spirit to your solution, I marked all pixels in the first group as visited, so the second bfs never terminated on them if I had started in a lagoon-like thing...that\\'s what I was a bit concerned about, but didn\\'t have to be."
                    },
                    {
                        "username": "andreped",
                        "content": "If you are familiar with connectivity in graph analysis, we often use 4 or 8 connectivity when comparing neighbours, for instance pixels in an image.\n\nFor 4 connected we only look at the 4 closest neighbours which are the vertical and horizontal neighbours. Whereas for 8 we also include the four diagonal neighbours (4 + 4 = 8).\n\nTo understand it, here is a simple example, which generates 2 islands with 4 connectivity (as diagonal is excluded), but only 1 island with 8 connectivity.\n\n1 1 0\n0 1 0\n0 0 1\n\nAlso: adding a simple lagoon unit test is probably a good idea, if that is not already included. I implemented a simple region growing-based method (DFS-like) to find the first group and assigned all remaining 1 pixels to the other, as we knew apriori that there were only two groups.\n\n"
                    },
                    {
                        "username": "Archit_Srivastava",
                        "content": "can we use priority queue in this question???"
                    },
                    {
                        "username": "tanishq0_0",
                        "content": "Weekend it is!!"
                    }
                ]
            },
            {
                "id": 2048198,
                "content": [
                    {
                        "username": "Jaideep_dahiya",
                        "content": "[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\\nCan someone explain how in the above testcase there are 2 islands ? \\nSorry if this is trivial but i am poor at graph questions.\\nThanks!"
                    },
                    {
                        "username": "RybakovIS",
                        "content": "You can paint this:\\n**1** **1**  **1** **1**  **1**\\n**1** 0 0 0 **1**\\n**1** 0 <ins>**1**</ins> 0 **1**\\n**1** 0 0 0 **1**\\n**1** **1**  **1** **1**  **1**"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Island inside an island\\u2026"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Flipkart OLT problem "
                    },
                    {
                        "username": "who_rules",
                        "content": "I would estimate it as upper-medium. Not very hard, but a lot of code"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "I think we can modify 1 of the island with something like \\'2\\' and apply bfs and return the the minimum no of cells taken from bfs of 2 to encouter 1"
                    },
                    {
                        "username": "loloksEth",
                        "content": "midium/hard   80/20 i think because of constrains"
                    },
                    {
                        "username": "arijit__12",
                        "content": "If we are traversing through an matrix if we are encountering 1 it means that is obv a part of island beacuse there is exactly 2 island exist and now if we encounter zero we can count till we reach 1 while flpping we can convert that 0 into 1.and we can extract the min of that.\\nIs this not an valid idea??? first I came up with this "
                    },
                    {
                        "username": "arijit__12",
                        "content": "[@Blatogh](/Blatogh) ok thank u"
                    },
                    {
                        "username": "Blatogh",
                        "content": "If you do this question you will see this idea is only valid for the ISLAND that only occupies one block. The question\\'s islands are not only occuping on block of the matrix. "
                    },
                    {
                        "username": "Blatogh",
                        "content": "BFS + DFS is the better than using 2 BFS. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "What does it mean for the 1\\'s to be \"4-directionally connected\"? The test cases seem to to include lagoons of zeros with at least one neighbor being in the island of 1\\'s ... unless I\\'m misreading some of these matrices. On the other hand, the test cases don\\'t seem to include \"lagoons\" inside of an island with internal zeros (0\\'s with all neighbors being 0), otherwise I think my solution would have failed. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "[@andreped](/andreped) Thanks for the helpful response. I was overly concerned with the notion of 4-connectivity on boundaries and corners. Similar in spirit to your solution, I marked all pixels in the first group as visited, so the second bfs never terminated on them if I had started in a lagoon-like thing...that\\'s what I was a bit concerned about, but didn\\'t have to be."
                    },
                    {
                        "username": "andreped",
                        "content": "If you are familiar with connectivity in graph analysis, we often use 4 or 8 connectivity when comparing neighbours, for instance pixels in an image.\n\nFor 4 connected we only look at the 4 closest neighbours which are the vertical and horizontal neighbours. Whereas for 8 we also include the four diagonal neighbours (4 + 4 = 8).\n\nTo understand it, here is a simple example, which generates 2 islands with 4 connectivity (as diagonal is excluded), but only 1 island with 8 connectivity.\n\n1 1 0\n0 1 0\n0 0 1\n\nAlso: adding a simple lagoon unit test is probably a good idea, if that is not already included. I implemented a simple region growing-based method (DFS-like) to find the first group and assigned all remaining 1 pixels to the other, as we knew apriori that there were only two groups.\n\n"
                    },
                    {
                        "username": "Archit_Srivastava",
                        "content": "can we use priority queue in this question???"
                    },
                    {
                        "username": "tanishq0_0",
                        "content": "Weekend it is!!"
                    }
                ]
            },
            {
                "id": 2043386,
                "content": [
                    {
                        "username": "Jaideep_dahiya",
                        "content": "[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\\nCan someone explain how in the above testcase there are 2 islands ? \\nSorry if this is trivial but i am poor at graph questions.\\nThanks!"
                    },
                    {
                        "username": "RybakovIS",
                        "content": "You can paint this:\\n**1** **1**  **1** **1**  **1**\\n**1** 0 0 0 **1**\\n**1** 0 <ins>**1**</ins> 0 **1**\\n**1** 0 0 0 **1**\\n**1** **1**  **1** **1**  **1**"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Island inside an island\\u2026"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Flipkart OLT problem "
                    },
                    {
                        "username": "who_rules",
                        "content": "I would estimate it as upper-medium. Not very hard, but a lot of code"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "I think we can modify 1 of the island with something like \\'2\\' and apply bfs and return the the minimum no of cells taken from bfs of 2 to encouter 1"
                    },
                    {
                        "username": "loloksEth",
                        "content": "midium/hard   80/20 i think because of constrains"
                    },
                    {
                        "username": "arijit__12",
                        "content": "If we are traversing through an matrix if we are encountering 1 it means that is obv a part of island beacuse there is exactly 2 island exist and now if we encounter zero we can count till we reach 1 while flpping we can convert that 0 into 1.and we can extract the min of that.\\nIs this not an valid idea??? first I came up with this "
                    },
                    {
                        "username": "arijit__12",
                        "content": "[@Blatogh](/Blatogh) ok thank u"
                    },
                    {
                        "username": "Blatogh",
                        "content": "If you do this question you will see this idea is only valid for the ISLAND that only occupies one block. The question\\'s islands are not only occuping on block of the matrix. "
                    },
                    {
                        "username": "Blatogh",
                        "content": "BFS + DFS is the better than using 2 BFS. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "What does it mean for the 1\\'s to be \"4-directionally connected\"? The test cases seem to to include lagoons of zeros with at least one neighbor being in the island of 1\\'s ... unless I\\'m misreading some of these matrices. On the other hand, the test cases don\\'t seem to include \"lagoons\" inside of an island with internal zeros (0\\'s with all neighbors being 0), otherwise I think my solution would have failed. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "[@andreped](/andreped) Thanks for the helpful response. I was overly concerned with the notion of 4-connectivity on boundaries and corners. Similar in spirit to your solution, I marked all pixels in the first group as visited, so the second bfs never terminated on them if I had started in a lagoon-like thing...that\\'s what I was a bit concerned about, but didn\\'t have to be."
                    },
                    {
                        "username": "andreped",
                        "content": "If you are familiar with connectivity in graph analysis, we often use 4 or 8 connectivity when comparing neighbours, for instance pixels in an image.\n\nFor 4 connected we only look at the 4 closest neighbours which are the vertical and horizontal neighbours. Whereas for 8 we also include the four diagonal neighbours (4 + 4 = 8).\n\nTo understand it, here is a simple example, which generates 2 islands with 4 connectivity (as diagonal is excluded), but only 1 island with 8 connectivity.\n\n1 1 0\n0 1 0\n0 0 1\n\nAlso: adding a simple lagoon unit test is probably a good idea, if that is not already included. I implemented a simple region growing-based method (DFS-like) to find the first group and assigned all remaining 1 pixels to the other, as we knew apriori that there were only two groups.\n\n"
                    },
                    {
                        "username": "Archit_Srivastava",
                        "content": "can we use priority queue in this question???"
                    },
                    {
                        "username": "tanishq0_0",
                        "content": "Weekend it is!!"
                    }
                ]
            },
            {
                "id": 2039725,
                "content": [
                    {
                        "username": "Jaideep_dahiya",
                        "content": "[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\\nCan someone explain how in the above testcase there are 2 islands ? \\nSorry if this is trivial but i am poor at graph questions.\\nThanks!"
                    },
                    {
                        "username": "RybakovIS",
                        "content": "You can paint this:\\n**1** **1**  **1** **1**  **1**\\n**1** 0 0 0 **1**\\n**1** 0 <ins>**1**</ins> 0 **1**\\n**1** 0 0 0 **1**\\n**1** **1**  **1** **1**  **1**"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Island inside an island\\u2026"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Flipkart OLT problem "
                    },
                    {
                        "username": "who_rules",
                        "content": "I would estimate it as upper-medium. Not very hard, but a lot of code"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "I think we can modify 1 of the island with something like \\'2\\' and apply bfs and return the the minimum no of cells taken from bfs of 2 to encouter 1"
                    },
                    {
                        "username": "loloksEth",
                        "content": "midium/hard   80/20 i think because of constrains"
                    },
                    {
                        "username": "arijit__12",
                        "content": "If we are traversing through an matrix if we are encountering 1 it means that is obv a part of island beacuse there is exactly 2 island exist and now if we encounter zero we can count till we reach 1 while flpping we can convert that 0 into 1.and we can extract the min of that.\\nIs this not an valid idea??? first I came up with this "
                    },
                    {
                        "username": "arijit__12",
                        "content": "[@Blatogh](/Blatogh) ok thank u"
                    },
                    {
                        "username": "Blatogh",
                        "content": "If you do this question you will see this idea is only valid for the ISLAND that only occupies one block. The question\\'s islands are not only occuping on block of the matrix. "
                    },
                    {
                        "username": "Blatogh",
                        "content": "BFS + DFS is the better than using 2 BFS. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "What does it mean for the 1\\'s to be \"4-directionally connected\"? The test cases seem to to include lagoons of zeros with at least one neighbor being in the island of 1\\'s ... unless I\\'m misreading some of these matrices. On the other hand, the test cases don\\'t seem to include \"lagoons\" inside of an island with internal zeros (0\\'s with all neighbors being 0), otherwise I think my solution would have failed. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "[@andreped](/andreped) Thanks for the helpful response. I was overly concerned with the notion of 4-connectivity on boundaries and corners. Similar in spirit to your solution, I marked all pixels in the first group as visited, so the second bfs never terminated on them if I had started in a lagoon-like thing...that\\'s what I was a bit concerned about, but didn\\'t have to be."
                    },
                    {
                        "username": "andreped",
                        "content": "If you are familiar with connectivity in graph analysis, we often use 4 or 8 connectivity when comparing neighbours, for instance pixels in an image.\n\nFor 4 connected we only look at the 4 closest neighbours which are the vertical and horizontal neighbours. Whereas for 8 we also include the four diagonal neighbours (4 + 4 = 8).\n\nTo understand it, here is a simple example, which generates 2 islands with 4 connectivity (as diagonal is excluded), but only 1 island with 8 connectivity.\n\n1 1 0\n0 1 0\n0 0 1\n\nAlso: adding a simple lagoon unit test is probably a good idea, if that is not already included. I implemented a simple region growing-based method (DFS-like) to find the first group and assigned all remaining 1 pixels to the other, as we knew apriori that there were only two groups.\n\n"
                    },
                    {
                        "username": "Archit_Srivastava",
                        "content": "can we use priority queue in this question???"
                    },
                    {
                        "username": "tanishq0_0",
                        "content": "Weekend it is!!"
                    }
                ]
            },
            {
                "id": 1940115,
                "content": [
                    {
                        "username": "Jaideep_dahiya",
                        "content": "[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\\nCan someone explain how in the above testcase there are 2 islands ? \\nSorry if this is trivial but i am poor at graph questions.\\nThanks!"
                    },
                    {
                        "username": "RybakovIS",
                        "content": "You can paint this:\\n**1** **1**  **1** **1**  **1**\\n**1** 0 0 0 **1**\\n**1** 0 <ins>**1**</ins> 0 **1**\\n**1** 0 0 0 **1**\\n**1** **1**  **1** **1**  **1**"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Island inside an island\\u2026"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Flipkart OLT problem "
                    },
                    {
                        "username": "who_rules",
                        "content": "I would estimate it as upper-medium. Not very hard, but a lot of code"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "I think we can modify 1 of the island with something like \\'2\\' and apply bfs and return the the minimum no of cells taken from bfs of 2 to encouter 1"
                    },
                    {
                        "username": "loloksEth",
                        "content": "midium/hard   80/20 i think because of constrains"
                    },
                    {
                        "username": "arijit__12",
                        "content": "If we are traversing through an matrix if we are encountering 1 it means that is obv a part of island beacuse there is exactly 2 island exist and now if we encounter zero we can count till we reach 1 while flpping we can convert that 0 into 1.and we can extract the min of that.\\nIs this not an valid idea??? first I came up with this "
                    },
                    {
                        "username": "arijit__12",
                        "content": "[@Blatogh](/Blatogh) ok thank u"
                    },
                    {
                        "username": "Blatogh",
                        "content": "If you do this question you will see this idea is only valid for the ISLAND that only occupies one block. The question\\'s islands are not only occuping on block of the matrix. "
                    },
                    {
                        "username": "Blatogh",
                        "content": "BFS + DFS is the better than using 2 BFS. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "What does it mean for the 1\\'s to be \"4-directionally connected\"? The test cases seem to to include lagoons of zeros with at least one neighbor being in the island of 1\\'s ... unless I\\'m misreading some of these matrices. On the other hand, the test cases don\\'t seem to include \"lagoons\" inside of an island with internal zeros (0\\'s with all neighbors being 0), otherwise I think my solution would have failed. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "[@andreped](/andreped) Thanks for the helpful response. I was overly concerned with the notion of 4-connectivity on boundaries and corners. Similar in spirit to your solution, I marked all pixels in the first group as visited, so the second bfs never terminated on them if I had started in a lagoon-like thing...that\\'s what I was a bit concerned about, but didn\\'t have to be."
                    },
                    {
                        "username": "andreped",
                        "content": "If you are familiar with connectivity in graph analysis, we often use 4 or 8 connectivity when comparing neighbours, for instance pixels in an image.\n\nFor 4 connected we only look at the 4 closest neighbours which are the vertical and horizontal neighbours. Whereas for 8 we also include the four diagonal neighbours (4 + 4 = 8).\n\nTo understand it, here is a simple example, which generates 2 islands with 4 connectivity (as diagonal is excluded), but only 1 island with 8 connectivity.\n\n1 1 0\n0 1 0\n0 0 1\n\nAlso: adding a simple lagoon unit test is probably a good idea, if that is not already included. I implemented a simple region growing-based method (DFS-like) to find the first group and assigned all remaining 1 pixels to the other, as we knew apriori that there were only two groups.\n\n"
                    },
                    {
                        "username": "Archit_Srivastava",
                        "content": "can we use priority queue in this question???"
                    },
                    {
                        "username": "tanishq0_0",
                        "content": "Weekend it is!!"
                    }
                ]
            },
            {
                "id": 1910777,
                "content": [
                    {
                        "username": "Jaideep_dahiya",
                        "content": "[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\\nCan someone explain how in the above testcase there are 2 islands ? \\nSorry if this is trivial but i am poor at graph questions.\\nThanks!"
                    },
                    {
                        "username": "RybakovIS",
                        "content": "You can paint this:\\n**1** **1**  **1** **1**  **1**\\n**1** 0 0 0 **1**\\n**1** 0 <ins>**1**</ins> 0 **1**\\n**1** 0 0 0 **1**\\n**1** **1**  **1** **1**  **1**"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Island inside an island\\u2026"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Flipkart OLT problem "
                    },
                    {
                        "username": "who_rules",
                        "content": "I would estimate it as upper-medium. Not very hard, but a lot of code"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "I think we can modify 1 of the island with something like \\'2\\' and apply bfs and return the the minimum no of cells taken from bfs of 2 to encouter 1"
                    },
                    {
                        "username": "loloksEth",
                        "content": "midium/hard   80/20 i think because of constrains"
                    },
                    {
                        "username": "arijit__12",
                        "content": "If we are traversing through an matrix if we are encountering 1 it means that is obv a part of island beacuse there is exactly 2 island exist and now if we encounter zero we can count till we reach 1 while flpping we can convert that 0 into 1.and we can extract the min of that.\\nIs this not an valid idea??? first I came up with this "
                    },
                    {
                        "username": "arijit__12",
                        "content": "[@Blatogh](/Blatogh) ok thank u"
                    },
                    {
                        "username": "Blatogh",
                        "content": "If you do this question you will see this idea is only valid for the ISLAND that only occupies one block. The question\\'s islands are not only occuping on block of the matrix. "
                    },
                    {
                        "username": "Blatogh",
                        "content": "BFS + DFS is the better than using 2 BFS. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "What does it mean for the 1\\'s to be \"4-directionally connected\"? The test cases seem to to include lagoons of zeros with at least one neighbor being in the island of 1\\'s ... unless I\\'m misreading some of these matrices. On the other hand, the test cases don\\'t seem to include \"lagoons\" inside of an island with internal zeros (0\\'s with all neighbors being 0), otherwise I think my solution would have failed. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "[@andreped](/andreped) Thanks for the helpful response. I was overly concerned with the notion of 4-connectivity on boundaries and corners. Similar in spirit to your solution, I marked all pixels in the first group as visited, so the second bfs never terminated on them if I had started in a lagoon-like thing...that\\'s what I was a bit concerned about, but didn\\'t have to be."
                    },
                    {
                        "username": "andreped",
                        "content": "If you are familiar with connectivity in graph analysis, we often use 4 or 8 connectivity when comparing neighbours, for instance pixels in an image.\n\nFor 4 connected we only look at the 4 closest neighbours which are the vertical and horizontal neighbours. Whereas for 8 we also include the four diagonal neighbours (4 + 4 = 8).\n\nTo understand it, here is a simple example, which generates 2 islands with 4 connectivity (as diagonal is excluded), but only 1 island with 8 connectivity.\n\n1 1 0\n0 1 0\n0 0 1\n\nAlso: adding a simple lagoon unit test is probably a good idea, if that is not already included. I implemented a simple region growing-based method (DFS-like) to find the first group and assigned all remaining 1 pixels to the other, as we knew apriori that there were only two groups.\n\n"
                    },
                    {
                        "username": "Archit_Srivastava",
                        "content": "can we use priority queue in this question???"
                    },
                    {
                        "username": "tanishq0_0",
                        "content": "Weekend it is!!"
                    }
                ]
            },
            {
                "id": 1910675,
                "content": [
                    {
                        "username": "Jaideep_dahiya",
                        "content": "[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\\nCan someone explain how in the above testcase there are 2 islands ? \\nSorry if this is trivial but i am poor at graph questions.\\nThanks!"
                    },
                    {
                        "username": "RybakovIS",
                        "content": "You can paint this:\\n**1** **1**  **1** **1**  **1**\\n**1** 0 0 0 **1**\\n**1** 0 <ins>**1**</ins> 0 **1**\\n**1** 0 0 0 **1**\\n**1** **1**  **1** **1**  **1**"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Island inside an island\\u2026"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Flipkart OLT problem "
                    },
                    {
                        "username": "who_rules",
                        "content": "I would estimate it as upper-medium. Not very hard, but a lot of code"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "I think we can modify 1 of the island with something like \\'2\\' and apply bfs and return the the minimum no of cells taken from bfs of 2 to encouter 1"
                    },
                    {
                        "username": "loloksEth",
                        "content": "midium/hard   80/20 i think because of constrains"
                    },
                    {
                        "username": "arijit__12",
                        "content": "If we are traversing through an matrix if we are encountering 1 it means that is obv a part of island beacuse there is exactly 2 island exist and now if we encounter zero we can count till we reach 1 while flpping we can convert that 0 into 1.and we can extract the min of that.\\nIs this not an valid idea??? first I came up with this "
                    },
                    {
                        "username": "arijit__12",
                        "content": "[@Blatogh](/Blatogh) ok thank u"
                    },
                    {
                        "username": "Blatogh",
                        "content": "If you do this question you will see this idea is only valid for the ISLAND that only occupies one block. The question\\'s islands are not only occuping on block of the matrix. "
                    },
                    {
                        "username": "Blatogh",
                        "content": "BFS + DFS is the better than using 2 BFS. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "What does it mean for the 1\\'s to be \"4-directionally connected\"? The test cases seem to to include lagoons of zeros with at least one neighbor being in the island of 1\\'s ... unless I\\'m misreading some of these matrices. On the other hand, the test cases don\\'t seem to include \"lagoons\" inside of an island with internal zeros (0\\'s with all neighbors being 0), otherwise I think my solution would have failed. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "[@andreped](/andreped) Thanks for the helpful response. I was overly concerned with the notion of 4-connectivity on boundaries and corners. Similar in spirit to your solution, I marked all pixels in the first group as visited, so the second bfs never terminated on them if I had started in a lagoon-like thing...that\\'s what I was a bit concerned about, but didn\\'t have to be."
                    },
                    {
                        "username": "andreped",
                        "content": "If you are familiar with connectivity in graph analysis, we often use 4 or 8 connectivity when comparing neighbours, for instance pixels in an image.\n\nFor 4 connected we only look at the 4 closest neighbours which are the vertical and horizontal neighbours. Whereas for 8 we also include the four diagonal neighbours (4 + 4 = 8).\n\nTo understand it, here is a simple example, which generates 2 islands with 4 connectivity (as diagonal is excluded), but only 1 island with 8 connectivity.\n\n1 1 0\n0 1 0\n0 0 1\n\nAlso: adding a simple lagoon unit test is probably a good idea, if that is not already included. I implemented a simple region growing-based method (DFS-like) to find the first group and assigned all remaining 1 pixels to the other, as we knew apriori that there were only two groups.\n\n"
                    },
                    {
                        "username": "Archit_Srivastava",
                        "content": "can we use priority queue in this question???"
                    },
                    {
                        "username": "tanishq0_0",
                        "content": "Weekend it is!!"
                    }
                ]
            },
            {
                "id": 1901440,
                "content": [
                    {
                        "username": "Jaideep_dahiya",
                        "content": "[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\\nCan someone explain how in the above testcase there are 2 islands ? \\nSorry if this is trivial but i am poor at graph questions.\\nThanks!"
                    },
                    {
                        "username": "RybakovIS",
                        "content": "You can paint this:\\n**1** **1**  **1** **1**  **1**\\n**1** 0 0 0 **1**\\n**1** 0 <ins>**1**</ins> 0 **1**\\n**1** 0 0 0 **1**\\n**1** **1**  **1** **1**  **1**"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Island inside an island\\u2026"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Flipkart OLT problem "
                    },
                    {
                        "username": "who_rules",
                        "content": "I would estimate it as upper-medium. Not very hard, but a lot of code"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "I think we can modify 1 of the island with something like \\'2\\' and apply bfs and return the the minimum no of cells taken from bfs of 2 to encouter 1"
                    },
                    {
                        "username": "loloksEth",
                        "content": "midium/hard   80/20 i think because of constrains"
                    },
                    {
                        "username": "arijit__12",
                        "content": "If we are traversing through an matrix if we are encountering 1 it means that is obv a part of island beacuse there is exactly 2 island exist and now if we encounter zero we can count till we reach 1 while flpping we can convert that 0 into 1.and we can extract the min of that.\\nIs this not an valid idea??? first I came up with this "
                    },
                    {
                        "username": "arijit__12",
                        "content": "[@Blatogh](/Blatogh) ok thank u"
                    },
                    {
                        "username": "Blatogh",
                        "content": "If you do this question you will see this idea is only valid for the ISLAND that only occupies one block. The question\\'s islands are not only occuping on block of the matrix. "
                    },
                    {
                        "username": "Blatogh",
                        "content": "BFS + DFS is the better than using 2 BFS. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "What does it mean for the 1\\'s to be \"4-directionally connected\"? The test cases seem to to include lagoons of zeros with at least one neighbor being in the island of 1\\'s ... unless I\\'m misreading some of these matrices. On the other hand, the test cases don\\'t seem to include \"lagoons\" inside of an island with internal zeros (0\\'s with all neighbors being 0), otherwise I think my solution would have failed. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "[@andreped](/andreped) Thanks for the helpful response. I was overly concerned with the notion of 4-connectivity on boundaries and corners. Similar in spirit to your solution, I marked all pixels in the first group as visited, so the second bfs never terminated on them if I had started in a lagoon-like thing...that\\'s what I was a bit concerned about, but didn\\'t have to be."
                    },
                    {
                        "username": "andreped",
                        "content": "If you are familiar with connectivity in graph analysis, we often use 4 or 8 connectivity when comparing neighbours, for instance pixels in an image.\n\nFor 4 connected we only look at the 4 closest neighbours which are the vertical and horizontal neighbours. Whereas for 8 we also include the four diagonal neighbours (4 + 4 = 8).\n\nTo understand it, here is a simple example, which generates 2 islands with 4 connectivity (as diagonal is excluded), but only 1 island with 8 connectivity.\n\n1 1 0\n0 1 0\n0 0 1\n\nAlso: adding a simple lagoon unit test is probably a good idea, if that is not already included. I implemented a simple region growing-based method (DFS-like) to find the first group and assigned all remaining 1 pixels to the other, as we knew apriori that there were only two groups.\n\n"
                    },
                    {
                        "username": "Archit_Srivastava",
                        "content": "can we use priority queue in this question???"
                    },
                    {
                        "username": "tanishq0_0",
                        "content": "Weekend it is!!"
                    }
                ]
            },
            {
                "id": 1901372,
                "content": [
                    {
                        "username": "Jaideep_dahiya",
                        "content": "[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\\nCan someone explain how in the above testcase there are 2 islands ? \\nSorry if this is trivial but i am poor at graph questions.\\nThanks!"
                    },
                    {
                        "username": "RybakovIS",
                        "content": "You can paint this:\\n**1** **1**  **1** **1**  **1**\\n**1** 0 0 0 **1**\\n**1** 0 <ins>**1**</ins> 0 **1**\\n**1** 0 0 0 **1**\\n**1** **1**  **1** **1**  **1**"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Island inside an island\\u2026"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Flipkart OLT problem "
                    },
                    {
                        "username": "who_rules",
                        "content": "I would estimate it as upper-medium. Not very hard, but a lot of code"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "I think we can modify 1 of the island with something like \\'2\\' and apply bfs and return the the minimum no of cells taken from bfs of 2 to encouter 1"
                    },
                    {
                        "username": "loloksEth",
                        "content": "midium/hard   80/20 i think because of constrains"
                    },
                    {
                        "username": "arijit__12",
                        "content": "If we are traversing through an matrix if we are encountering 1 it means that is obv a part of island beacuse there is exactly 2 island exist and now if we encounter zero we can count till we reach 1 while flpping we can convert that 0 into 1.and we can extract the min of that.\\nIs this not an valid idea??? first I came up with this "
                    },
                    {
                        "username": "arijit__12",
                        "content": "[@Blatogh](/Blatogh) ok thank u"
                    },
                    {
                        "username": "Blatogh",
                        "content": "If you do this question you will see this idea is only valid for the ISLAND that only occupies one block. The question\\'s islands are not only occuping on block of the matrix. "
                    },
                    {
                        "username": "Blatogh",
                        "content": "BFS + DFS is the better than using 2 BFS. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "What does it mean for the 1\\'s to be \"4-directionally connected\"? The test cases seem to to include lagoons of zeros with at least one neighbor being in the island of 1\\'s ... unless I\\'m misreading some of these matrices. On the other hand, the test cases don\\'t seem to include \"lagoons\" inside of an island with internal zeros (0\\'s with all neighbors being 0), otherwise I think my solution would have failed. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "[@andreped](/andreped) Thanks for the helpful response. I was overly concerned with the notion of 4-connectivity on boundaries and corners. Similar in spirit to your solution, I marked all pixels in the first group as visited, so the second bfs never terminated on them if I had started in a lagoon-like thing...that\\'s what I was a bit concerned about, but didn\\'t have to be."
                    },
                    {
                        "username": "andreped",
                        "content": "If you are familiar with connectivity in graph analysis, we often use 4 or 8 connectivity when comparing neighbours, for instance pixels in an image.\n\nFor 4 connected we only look at the 4 closest neighbours which are the vertical and horizontal neighbours. Whereas for 8 we also include the four diagonal neighbours (4 + 4 = 8).\n\nTo understand it, here is a simple example, which generates 2 islands with 4 connectivity (as diagonal is excluded), but only 1 island with 8 connectivity.\n\n1 1 0\n0 1 0\n0 0 1\n\nAlso: adding a simple lagoon unit test is probably a good idea, if that is not already included. I implemented a simple region growing-based method (DFS-like) to find the first group and assigned all remaining 1 pixels to the other, as we knew apriori that there were only two groups.\n\n"
                    },
                    {
                        "username": "Archit_Srivastava",
                        "content": "can we use priority queue in this question???"
                    },
                    {
                        "username": "tanishq0_0",
                        "content": "Weekend it is!!"
                    }
                ]
            },
            {
                "id": 1901352,
                "content": [
                    {
                        "username": "Jaideep_dahiya",
                        "content": "[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\\nCan someone explain how in the above testcase there are 2 islands ? \\nSorry if this is trivial but i am poor at graph questions.\\nThanks!"
                    },
                    {
                        "username": "RybakovIS",
                        "content": "You can paint this:\\n**1** **1**  **1** **1**  **1**\\n**1** 0 0 0 **1**\\n**1** 0 <ins>**1**</ins> 0 **1**\\n**1** 0 0 0 **1**\\n**1** **1**  **1** **1**  **1**"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Island inside an island\\u2026"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Flipkart OLT problem "
                    },
                    {
                        "username": "who_rules",
                        "content": "I would estimate it as upper-medium. Not very hard, but a lot of code"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "I think we can modify 1 of the island with something like \\'2\\' and apply bfs and return the the minimum no of cells taken from bfs of 2 to encouter 1"
                    },
                    {
                        "username": "loloksEth",
                        "content": "midium/hard   80/20 i think because of constrains"
                    },
                    {
                        "username": "arijit__12",
                        "content": "If we are traversing through an matrix if we are encountering 1 it means that is obv a part of island beacuse there is exactly 2 island exist and now if we encounter zero we can count till we reach 1 while flpping we can convert that 0 into 1.and we can extract the min of that.\\nIs this not an valid idea??? first I came up with this "
                    },
                    {
                        "username": "arijit__12",
                        "content": "[@Blatogh](/Blatogh) ok thank u"
                    },
                    {
                        "username": "Blatogh",
                        "content": "If you do this question you will see this idea is only valid for the ISLAND that only occupies one block. The question\\'s islands are not only occuping on block of the matrix. "
                    },
                    {
                        "username": "Blatogh",
                        "content": "BFS + DFS is the better than using 2 BFS. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "What does it mean for the 1\\'s to be \"4-directionally connected\"? The test cases seem to to include lagoons of zeros with at least one neighbor being in the island of 1\\'s ... unless I\\'m misreading some of these matrices. On the other hand, the test cases don\\'t seem to include \"lagoons\" inside of an island with internal zeros (0\\'s with all neighbors being 0), otherwise I think my solution would have failed. "
                    },
                    {
                        "username": "stultiloquator",
                        "content": "[@andreped](/andreped) Thanks for the helpful response. I was overly concerned with the notion of 4-connectivity on boundaries and corners. Similar in spirit to your solution, I marked all pixels in the first group as visited, so the second bfs never terminated on them if I had started in a lagoon-like thing...that\\'s what I was a bit concerned about, but didn\\'t have to be."
                    },
                    {
                        "username": "andreped",
                        "content": "If you are familiar with connectivity in graph analysis, we often use 4 or 8 connectivity when comparing neighbours, for instance pixels in an image.\n\nFor 4 connected we only look at the 4 closest neighbours which are the vertical and horizontal neighbours. Whereas for 8 we also include the four diagonal neighbours (4 + 4 = 8).\n\nTo understand it, here is a simple example, which generates 2 islands with 4 connectivity (as diagonal is excluded), but only 1 island with 8 connectivity.\n\n1 1 0\n0 1 0\n0 0 1\n\nAlso: adding a simple lagoon unit test is probably a good idea, if that is not already included. I implemented a simple region growing-based method (DFS-like) to find the first group and assigned all remaining 1 pixels to the other, as we knew apriori that there were only two groups.\n\n"
                    },
                    {
                        "username": "Archit_Srivastava",
                        "content": "can we use priority queue in this question???"
                    },
                    {
                        "username": "tanishq0_0",
                        "content": "Weekend it is!!"
                    }
                ]
            },
            {
                "id": 1901309,
                "content": [
                    {
                        "username": "ercanK",
                        "content": "I couldn't understand the purpose of the bold phrase. Appreciated if somebody can explain.\n\n\"An island is a 4-directionally connected group of 1's <b>not connected to any other 1's</b>.\"\n\nWhat extra information does it try to provide? Isn't it enough to say `An island is a 4-directionally connected group of 1's`"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "A combination of DFS and BFS. Liked it!"
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "This problem isn\\'t particularly \"hard\", it\\'s just two medium problems in a row. If you don\\'t know where to get started, you should do [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) first, and then come back to this one. You can do it!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be hard"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "What does it mean really? Last executed input is an empty test case.\\n![image](https://private-user-images.githubusercontent.com/103294459/239735009-5c115785-655f-422d-895d-363ec750f95e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJrZXkxIiwiZXhwIjoxNjg0NjY1NDQwLCJuYmYiOjE2ODQ2NjUxNDAsInBhdGgiOiIvMTAzMjk0NDU5LzIzOTczNTAwOS01YzExNTc4NS02NTVmLTQyMmQtODk1ZC0zNjNlYzc1MGY5NWUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQUlXTkpZQVg0Q1NWRUg1M0ElMkYyMDIzMDUyMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA1MjFUMTAzMjIwWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NzIyNzA5ZTViNmE5NTI0MmVhMTAzNzVkZjdlY2ZiZDExYzI2YzdmY2QwNjkzMWY5ODA3YmYzZWQzYTBjODVkNiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.0bx6Tghv0Cq3AXnEb2Z6je0ynSIuuGBnQY0-CIUuHxE)"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Did it without using bfs by taking the minimum absolute difference of coordinates of the two islands. But it not a good solution tbh."
                    },
                    {
                        "username": "user5201tx",
                        "content": "Someone please explain the problem to me. where is the island in these examples above ?? I can see only 1 island in the 3rd example at most !"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in the 3rd example\n[\n[1,1,1,1,1],\n[1,0,0,0,1],\n[1,0,1,0,1],\n[1,0,0,0,1],\n[1,1,1,1,1]\n]\nthe first island is at outer layer and the second island is at the middle \n\nin the first example\n[\n[0,1],\n[1,0]\n]\nthe first island is at the top right and the second island is at the bottom left\n\nin the second example\n[\n[0,1,0],\n[0,0,0],\n[0,0,1]\n]\nthe first island is at the top middle and the second island is at the bottom right"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "Why do i keep getting memory limit exceeded on test case 55... I\\'m using DFS + BFS"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I also did using dfs+bfs i did not get memory limit exceeded"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "nvm... forgot to mark visited in BFS part so it was adding duplicates. runs at 97% faster now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Thank you for the easy weekend, hopefully the guy with the cat picture that types things in bold managed to keep his streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "(ﾉ*ФωФ)ﾉ"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "`class Solution {\\npublic:\\n  \\n    void dfs(vector<vector<int>>& grid, vector<pair<int ,int >>&store, int row, int col) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0 || grid[row][col] == 3) {\\n            return;\\n        }\\n        store.push_back({row, col});\\n        grid[row][col] = 3;\\n        \\n        dfs(grid, store, row, col - 1);\\n        dfs(grid, store, row + 1, col);\\n        dfs(grid, store, row, col + 1);\\n        dfs(grid, store, row - 1, col);\\n    }\\n\\n    int minDistance(vector<vector<int>>& grid,vector<vector<bool>>& visited, int row, int col, int count) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || visited[row][col]==true) {\\n            return INT_MAX;\\n        }\\n        if (grid[row][col] == 1) {\\n            return count;\\n        }\\n\\n        visited[row][col]=true;\\n\\n        int s1 = minDistance(grid,visited, row, col - 1, count + 1);\\n        int s2 = minDistance(grid,visited, row + 1, col, count + 1);\\n        int s3 = minDistance(grid,visited, row, col + 1, count + 1);\\n        int s4 = minDistance(grid,visited, row - 1, col, count + 1);\\n\\n        visited[row][col]=false;\\n\\n        return min({s1, s2, s3, s4});\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<pair<int ,int >> store;\\n        bool flag = false;\\n        int minDist = INT_MAX;\\n        vector<vector<bool>> visited(row,vector<bool >(col,false));\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 1) { \\n                    dfs(grid, store, i, j);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < store.size(); i++) {\\n            minDist = min(minDistance(grid,visited, store[i].first, store[i].second, 0), minDist);\\n        }\\n        return minDist-1;\\n        \\n    }\\n\\n\\n};`this solution give me TLE \\nGive me tips to improve  this solution\\n"
                    }
                ]
            },
            {
                "id": 1901283,
                "content": [
                    {
                        "username": "ercanK",
                        "content": "I couldn't understand the purpose of the bold phrase. Appreciated if somebody can explain.\n\n\"An island is a 4-directionally connected group of 1's <b>not connected to any other 1's</b>.\"\n\nWhat extra information does it try to provide? Isn't it enough to say `An island is a 4-directionally connected group of 1's`"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "A combination of DFS and BFS. Liked it!"
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "This problem isn\\'t particularly \"hard\", it\\'s just two medium problems in a row. If you don\\'t know where to get started, you should do [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) first, and then come back to this one. You can do it!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be hard"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "What does it mean really? Last executed input is an empty test case.\\n![image](https://private-user-images.githubusercontent.com/103294459/239735009-5c115785-655f-422d-895d-363ec750f95e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJrZXkxIiwiZXhwIjoxNjg0NjY1NDQwLCJuYmYiOjE2ODQ2NjUxNDAsInBhdGgiOiIvMTAzMjk0NDU5LzIzOTczNTAwOS01YzExNTc4NS02NTVmLTQyMmQtODk1ZC0zNjNlYzc1MGY5NWUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQUlXTkpZQVg0Q1NWRUg1M0ElMkYyMDIzMDUyMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA1MjFUMTAzMjIwWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NzIyNzA5ZTViNmE5NTI0MmVhMTAzNzVkZjdlY2ZiZDExYzI2YzdmY2QwNjkzMWY5ODA3YmYzZWQzYTBjODVkNiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.0bx6Tghv0Cq3AXnEb2Z6je0ynSIuuGBnQY0-CIUuHxE)"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Did it without using bfs by taking the minimum absolute difference of coordinates of the two islands. But it not a good solution tbh."
                    },
                    {
                        "username": "user5201tx",
                        "content": "Someone please explain the problem to me. where is the island in these examples above ?? I can see only 1 island in the 3rd example at most !"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in the 3rd example\n[\n[1,1,1,1,1],\n[1,0,0,0,1],\n[1,0,1,0,1],\n[1,0,0,0,1],\n[1,1,1,1,1]\n]\nthe first island is at outer layer and the second island is at the middle \n\nin the first example\n[\n[0,1],\n[1,0]\n]\nthe first island is at the top right and the second island is at the bottom left\n\nin the second example\n[\n[0,1,0],\n[0,0,0],\n[0,0,1]\n]\nthe first island is at the top middle and the second island is at the bottom right"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "Why do i keep getting memory limit exceeded on test case 55... I\\'m using DFS + BFS"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I also did using dfs+bfs i did not get memory limit exceeded"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "nvm... forgot to mark visited in BFS part so it was adding duplicates. runs at 97% faster now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Thank you for the easy weekend, hopefully the guy with the cat picture that types things in bold managed to keep his streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "(ﾉ*ФωФ)ﾉ"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "`class Solution {\\npublic:\\n  \\n    void dfs(vector<vector<int>>& grid, vector<pair<int ,int >>&store, int row, int col) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0 || grid[row][col] == 3) {\\n            return;\\n        }\\n        store.push_back({row, col});\\n        grid[row][col] = 3;\\n        \\n        dfs(grid, store, row, col - 1);\\n        dfs(grid, store, row + 1, col);\\n        dfs(grid, store, row, col + 1);\\n        dfs(grid, store, row - 1, col);\\n    }\\n\\n    int minDistance(vector<vector<int>>& grid,vector<vector<bool>>& visited, int row, int col, int count) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || visited[row][col]==true) {\\n            return INT_MAX;\\n        }\\n        if (grid[row][col] == 1) {\\n            return count;\\n        }\\n\\n        visited[row][col]=true;\\n\\n        int s1 = minDistance(grid,visited, row, col - 1, count + 1);\\n        int s2 = minDistance(grid,visited, row + 1, col, count + 1);\\n        int s3 = minDistance(grid,visited, row, col + 1, count + 1);\\n        int s4 = minDistance(grid,visited, row - 1, col, count + 1);\\n\\n        visited[row][col]=false;\\n\\n        return min({s1, s2, s3, s4});\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<pair<int ,int >> store;\\n        bool flag = false;\\n        int minDist = INT_MAX;\\n        vector<vector<bool>> visited(row,vector<bool >(col,false));\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 1) { \\n                    dfs(grid, store, i, j);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < store.size(); i++) {\\n            minDist = min(minDistance(grid,visited, store[i].first, store[i].second, 0), minDist);\\n        }\\n        return minDist-1;\\n        \\n    }\\n\\n\\n};`this solution give me TLE \\nGive me tips to improve  this solution\\n"
                    }
                ]
            },
            {
                "id": 1901163,
                "content": [
                    {
                        "username": "ercanK",
                        "content": "I couldn't understand the purpose of the bold phrase. Appreciated if somebody can explain.\n\n\"An island is a 4-directionally connected group of 1's <b>not connected to any other 1's</b>.\"\n\nWhat extra information does it try to provide? Isn't it enough to say `An island is a 4-directionally connected group of 1's`"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "A combination of DFS and BFS. Liked it!"
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "This problem isn\\'t particularly \"hard\", it\\'s just two medium problems in a row. If you don\\'t know where to get started, you should do [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) first, and then come back to this one. You can do it!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be hard"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "What does it mean really? Last executed input is an empty test case.\\n![image](https://private-user-images.githubusercontent.com/103294459/239735009-5c115785-655f-422d-895d-363ec750f95e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJrZXkxIiwiZXhwIjoxNjg0NjY1NDQwLCJuYmYiOjE2ODQ2NjUxNDAsInBhdGgiOiIvMTAzMjk0NDU5LzIzOTczNTAwOS01YzExNTc4NS02NTVmLTQyMmQtODk1ZC0zNjNlYzc1MGY5NWUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQUlXTkpZQVg0Q1NWRUg1M0ElMkYyMDIzMDUyMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA1MjFUMTAzMjIwWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NzIyNzA5ZTViNmE5NTI0MmVhMTAzNzVkZjdlY2ZiZDExYzI2YzdmY2QwNjkzMWY5ODA3YmYzZWQzYTBjODVkNiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.0bx6Tghv0Cq3AXnEb2Z6je0ynSIuuGBnQY0-CIUuHxE)"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Did it without using bfs by taking the minimum absolute difference of coordinates of the two islands. But it not a good solution tbh."
                    },
                    {
                        "username": "user5201tx",
                        "content": "Someone please explain the problem to me. where is the island in these examples above ?? I can see only 1 island in the 3rd example at most !"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in the 3rd example\n[\n[1,1,1,1,1],\n[1,0,0,0,1],\n[1,0,1,0,1],\n[1,0,0,0,1],\n[1,1,1,1,1]\n]\nthe first island is at outer layer and the second island is at the middle \n\nin the first example\n[\n[0,1],\n[1,0]\n]\nthe first island is at the top right and the second island is at the bottom left\n\nin the second example\n[\n[0,1,0],\n[0,0,0],\n[0,0,1]\n]\nthe first island is at the top middle and the second island is at the bottom right"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "Why do i keep getting memory limit exceeded on test case 55... I\\'m using DFS + BFS"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I also did using dfs+bfs i did not get memory limit exceeded"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "nvm... forgot to mark visited in BFS part so it was adding duplicates. runs at 97% faster now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Thank you for the easy weekend, hopefully the guy with the cat picture that types things in bold managed to keep his streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "(ﾉ*ФωФ)ﾉ"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "`class Solution {\\npublic:\\n  \\n    void dfs(vector<vector<int>>& grid, vector<pair<int ,int >>&store, int row, int col) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0 || grid[row][col] == 3) {\\n            return;\\n        }\\n        store.push_back({row, col});\\n        grid[row][col] = 3;\\n        \\n        dfs(grid, store, row, col - 1);\\n        dfs(grid, store, row + 1, col);\\n        dfs(grid, store, row, col + 1);\\n        dfs(grid, store, row - 1, col);\\n    }\\n\\n    int minDistance(vector<vector<int>>& grid,vector<vector<bool>>& visited, int row, int col, int count) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || visited[row][col]==true) {\\n            return INT_MAX;\\n        }\\n        if (grid[row][col] == 1) {\\n            return count;\\n        }\\n\\n        visited[row][col]=true;\\n\\n        int s1 = minDistance(grid,visited, row, col - 1, count + 1);\\n        int s2 = minDistance(grid,visited, row + 1, col, count + 1);\\n        int s3 = minDistance(grid,visited, row, col + 1, count + 1);\\n        int s4 = minDistance(grid,visited, row - 1, col, count + 1);\\n\\n        visited[row][col]=false;\\n\\n        return min({s1, s2, s3, s4});\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<pair<int ,int >> store;\\n        bool flag = false;\\n        int minDist = INT_MAX;\\n        vector<vector<bool>> visited(row,vector<bool >(col,false));\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 1) { \\n                    dfs(grid, store, i, j);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < store.size(); i++) {\\n            minDist = min(minDistance(grid,visited, store[i].first, store[i].second, 0), minDist);\\n        }\\n        return minDist-1;\\n        \\n    }\\n\\n\\n};`this solution give me TLE \\nGive me tips to improve  this solution\\n"
                    }
                ]
            },
            {
                "id": 1901155,
                "content": [
                    {
                        "username": "ercanK",
                        "content": "I couldn't understand the purpose of the bold phrase. Appreciated if somebody can explain.\n\n\"An island is a 4-directionally connected group of 1's <b>not connected to any other 1's</b>.\"\n\nWhat extra information does it try to provide? Isn't it enough to say `An island is a 4-directionally connected group of 1's`"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "A combination of DFS and BFS. Liked it!"
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "This problem isn\\'t particularly \"hard\", it\\'s just two medium problems in a row. If you don\\'t know where to get started, you should do [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) first, and then come back to this one. You can do it!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be hard"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "What does it mean really? Last executed input is an empty test case.\\n![image](https://private-user-images.githubusercontent.com/103294459/239735009-5c115785-655f-422d-895d-363ec750f95e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJrZXkxIiwiZXhwIjoxNjg0NjY1NDQwLCJuYmYiOjE2ODQ2NjUxNDAsInBhdGgiOiIvMTAzMjk0NDU5LzIzOTczNTAwOS01YzExNTc4NS02NTVmLTQyMmQtODk1ZC0zNjNlYzc1MGY5NWUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQUlXTkpZQVg0Q1NWRUg1M0ElMkYyMDIzMDUyMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA1MjFUMTAzMjIwWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NzIyNzA5ZTViNmE5NTI0MmVhMTAzNzVkZjdlY2ZiZDExYzI2YzdmY2QwNjkzMWY5ODA3YmYzZWQzYTBjODVkNiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.0bx6Tghv0Cq3AXnEb2Z6je0ynSIuuGBnQY0-CIUuHxE)"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Did it without using bfs by taking the minimum absolute difference of coordinates of the two islands. But it not a good solution tbh."
                    },
                    {
                        "username": "user5201tx",
                        "content": "Someone please explain the problem to me. where is the island in these examples above ?? I can see only 1 island in the 3rd example at most !"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in the 3rd example\n[\n[1,1,1,1,1],\n[1,0,0,0,1],\n[1,0,1,0,1],\n[1,0,0,0,1],\n[1,1,1,1,1]\n]\nthe first island is at outer layer and the second island is at the middle \n\nin the first example\n[\n[0,1],\n[1,0]\n]\nthe first island is at the top right and the second island is at the bottom left\n\nin the second example\n[\n[0,1,0],\n[0,0,0],\n[0,0,1]\n]\nthe first island is at the top middle and the second island is at the bottom right"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "Why do i keep getting memory limit exceeded on test case 55... I\\'m using DFS + BFS"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I also did using dfs+bfs i did not get memory limit exceeded"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "nvm... forgot to mark visited in BFS part so it was adding duplicates. runs at 97% faster now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Thank you for the easy weekend, hopefully the guy with the cat picture that types things in bold managed to keep his streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "(ﾉ*ФωФ)ﾉ"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "`class Solution {\\npublic:\\n  \\n    void dfs(vector<vector<int>>& grid, vector<pair<int ,int >>&store, int row, int col) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0 || grid[row][col] == 3) {\\n            return;\\n        }\\n        store.push_back({row, col});\\n        grid[row][col] = 3;\\n        \\n        dfs(grid, store, row, col - 1);\\n        dfs(grid, store, row + 1, col);\\n        dfs(grid, store, row, col + 1);\\n        dfs(grid, store, row - 1, col);\\n    }\\n\\n    int minDistance(vector<vector<int>>& grid,vector<vector<bool>>& visited, int row, int col, int count) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || visited[row][col]==true) {\\n            return INT_MAX;\\n        }\\n        if (grid[row][col] == 1) {\\n            return count;\\n        }\\n\\n        visited[row][col]=true;\\n\\n        int s1 = minDistance(grid,visited, row, col - 1, count + 1);\\n        int s2 = minDistance(grid,visited, row + 1, col, count + 1);\\n        int s3 = minDistance(grid,visited, row, col + 1, count + 1);\\n        int s4 = minDistance(grid,visited, row - 1, col, count + 1);\\n\\n        visited[row][col]=false;\\n\\n        return min({s1, s2, s3, s4});\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<pair<int ,int >> store;\\n        bool flag = false;\\n        int minDist = INT_MAX;\\n        vector<vector<bool>> visited(row,vector<bool >(col,false));\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 1) { \\n                    dfs(grid, store, i, j);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < store.size(); i++) {\\n            minDist = min(minDistance(grid,visited, store[i].first, store[i].second, 0), minDist);\\n        }\\n        return minDist-1;\\n        \\n    }\\n\\n\\n};`this solution give me TLE \\nGive me tips to improve  this solution\\n"
                    }
                ]
            },
            {
                "id": 1901095,
                "content": [
                    {
                        "username": "ercanK",
                        "content": "I couldn't understand the purpose of the bold phrase. Appreciated if somebody can explain.\n\n\"An island is a 4-directionally connected group of 1's <b>not connected to any other 1's</b>.\"\n\nWhat extra information does it try to provide? Isn't it enough to say `An island is a 4-directionally connected group of 1's`"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "A combination of DFS and BFS. Liked it!"
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "This problem isn\\'t particularly \"hard\", it\\'s just two medium problems in a row. If you don\\'t know where to get started, you should do [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) first, and then come back to this one. You can do it!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be hard"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "What does it mean really? Last executed input is an empty test case.\\n![image](https://private-user-images.githubusercontent.com/103294459/239735009-5c115785-655f-422d-895d-363ec750f95e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJrZXkxIiwiZXhwIjoxNjg0NjY1NDQwLCJuYmYiOjE2ODQ2NjUxNDAsInBhdGgiOiIvMTAzMjk0NDU5LzIzOTczNTAwOS01YzExNTc4NS02NTVmLTQyMmQtODk1ZC0zNjNlYzc1MGY5NWUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQUlXTkpZQVg0Q1NWRUg1M0ElMkYyMDIzMDUyMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA1MjFUMTAzMjIwWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NzIyNzA5ZTViNmE5NTI0MmVhMTAzNzVkZjdlY2ZiZDExYzI2YzdmY2QwNjkzMWY5ODA3YmYzZWQzYTBjODVkNiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.0bx6Tghv0Cq3AXnEb2Z6je0ynSIuuGBnQY0-CIUuHxE)"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Did it without using bfs by taking the minimum absolute difference of coordinates of the two islands. But it not a good solution tbh."
                    },
                    {
                        "username": "user5201tx",
                        "content": "Someone please explain the problem to me. where is the island in these examples above ?? I can see only 1 island in the 3rd example at most !"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in the 3rd example\n[\n[1,1,1,1,1],\n[1,0,0,0,1],\n[1,0,1,0,1],\n[1,0,0,0,1],\n[1,1,1,1,1]\n]\nthe first island is at outer layer and the second island is at the middle \n\nin the first example\n[\n[0,1],\n[1,0]\n]\nthe first island is at the top right and the second island is at the bottom left\n\nin the second example\n[\n[0,1,0],\n[0,0,0],\n[0,0,1]\n]\nthe first island is at the top middle and the second island is at the bottom right"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "Why do i keep getting memory limit exceeded on test case 55... I\\'m using DFS + BFS"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I also did using dfs+bfs i did not get memory limit exceeded"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "nvm... forgot to mark visited in BFS part so it was adding duplicates. runs at 97% faster now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Thank you for the easy weekend, hopefully the guy with the cat picture that types things in bold managed to keep his streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "(ﾉ*ФωФ)ﾉ"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "`class Solution {\\npublic:\\n  \\n    void dfs(vector<vector<int>>& grid, vector<pair<int ,int >>&store, int row, int col) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0 || grid[row][col] == 3) {\\n            return;\\n        }\\n        store.push_back({row, col});\\n        grid[row][col] = 3;\\n        \\n        dfs(grid, store, row, col - 1);\\n        dfs(grid, store, row + 1, col);\\n        dfs(grid, store, row, col + 1);\\n        dfs(grid, store, row - 1, col);\\n    }\\n\\n    int minDistance(vector<vector<int>>& grid,vector<vector<bool>>& visited, int row, int col, int count) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || visited[row][col]==true) {\\n            return INT_MAX;\\n        }\\n        if (grid[row][col] == 1) {\\n            return count;\\n        }\\n\\n        visited[row][col]=true;\\n\\n        int s1 = minDistance(grid,visited, row, col - 1, count + 1);\\n        int s2 = minDistance(grid,visited, row + 1, col, count + 1);\\n        int s3 = minDistance(grid,visited, row, col + 1, count + 1);\\n        int s4 = minDistance(grid,visited, row - 1, col, count + 1);\\n\\n        visited[row][col]=false;\\n\\n        return min({s1, s2, s3, s4});\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<pair<int ,int >> store;\\n        bool flag = false;\\n        int minDist = INT_MAX;\\n        vector<vector<bool>> visited(row,vector<bool >(col,false));\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 1) { \\n                    dfs(grid, store, i, j);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < store.size(); i++) {\\n            minDist = min(minDistance(grid,visited, store[i].first, store[i].second, 0), minDist);\\n        }\\n        return minDist-1;\\n        \\n    }\\n\\n\\n};`this solution give me TLE \\nGive me tips to improve  this solution\\n"
                    }
                ]
            },
            {
                "id": 1900874,
                "content": [
                    {
                        "username": "ercanK",
                        "content": "I couldn't understand the purpose of the bold phrase. Appreciated if somebody can explain.\n\n\"An island is a 4-directionally connected group of 1's <b>not connected to any other 1's</b>.\"\n\nWhat extra information does it try to provide? Isn't it enough to say `An island is a 4-directionally connected group of 1's`"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "A combination of DFS and BFS. Liked it!"
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "This problem isn\\'t particularly \"hard\", it\\'s just two medium problems in a row. If you don\\'t know where to get started, you should do [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) first, and then come back to this one. You can do it!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be hard"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "What does it mean really? Last executed input is an empty test case.\\n![image](https://private-user-images.githubusercontent.com/103294459/239735009-5c115785-655f-422d-895d-363ec750f95e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJrZXkxIiwiZXhwIjoxNjg0NjY1NDQwLCJuYmYiOjE2ODQ2NjUxNDAsInBhdGgiOiIvMTAzMjk0NDU5LzIzOTczNTAwOS01YzExNTc4NS02NTVmLTQyMmQtODk1ZC0zNjNlYzc1MGY5NWUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQUlXTkpZQVg0Q1NWRUg1M0ElMkYyMDIzMDUyMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA1MjFUMTAzMjIwWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NzIyNzA5ZTViNmE5NTI0MmVhMTAzNzVkZjdlY2ZiZDExYzI2YzdmY2QwNjkzMWY5ODA3YmYzZWQzYTBjODVkNiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.0bx6Tghv0Cq3AXnEb2Z6je0ynSIuuGBnQY0-CIUuHxE)"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Did it without using bfs by taking the minimum absolute difference of coordinates of the two islands. But it not a good solution tbh."
                    },
                    {
                        "username": "user5201tx",
                        "content": "Someone please explain the problem to me. where is the island in these examples above ?? I can see only 1 island in the 3rd example at most !"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in the 3rd example\n[\n[1,1,1,1,1],\n[1,0,0,0,1],\n[1,0,1,0,1],\n[1,0,0,0,1],\n[1,1,1,1,1]\n]\nthe first island is at outer layer and the second island is at the middle \n\nin the first example\n[\n[0,1],\n[1,0]\n]\nthe first island is at the top right and the second island is at the bottom left\n\nin the second example\n[\n[0,1,0],\n[0,0,0],\n[0,0,1]\n]\nthe first island is at the top middle and the second island is at the bottom right"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "Why do i keep getting memory limit exceeded on test case 55... I\\'m using DFS + BFS"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I also did using dfs+bfs i did not get memory limit exceeded"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "nvm... forgot to mark visited in BFS part so it was adding duplicates. runs at 97% faster now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Thank you for the easy weekend, hopefully the guy with the cat picture that types things in bold managed to keep his streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "(ﾉ*ФωФ)ﾉ"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "`class Solution {\\npublic:\\n  \\n    void dfs(vector<vector<int>>& grid, vector<pair<int ,int >>&store, int row, int col) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0 || grid[row][col] == 3) {\\n            return;\\n        }\\n        store.push_back({row, col});\\n        grid[row][col] = 3;\\n        \\n        dfs(grid, store, row, col - 1);\\n        dfs(grid, store, row + 1, col);\\n        dfs(grid, store, row, col + 1);\\n        dfs(grid, store, row - 1, col);\\n    }\\n\\n    int minDistance(vector<vector<int>>& grid,vector<vector<bool>>& visited, int row, int col, int count) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || visited[row][col]==true) {\\n            return INT_MAX;\\n        }\\n        if (grid[row][col] == 1) {\\n            return count;\\n        }\\n\\n        visited[row][col]=true;\\n\\n        int s1 = minDistance(grid,visited, row, col - 1, count + 1);\\n        int s2 = minDistance(grid,visited, row + 1, col, count + 1);\\n        int s3 = minDistance(grid,visited, row, col + 1, count + 1);\\n        int s4 = minDistance(grid,visited, row - 1, col, count + 1);\\n\\n        visited[row][col]=false;\\n\\n        return min({s1, s2, s3, s4});\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<pair<int ,int >> store;\\n        bool flag = false;\\n        int minDist = INT_MAX;\\n        vector<vector<bool>> visited(row,vector<bool >(col,false));\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 1) { \\n                    dfs(grid, store, i, j);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < store.size(); i++) {\\n            minDist = min(minDistance(grid,visited, store[i].first, store[i].second, 0), minDist);\\n        }\\n        return minDist-1;\\n        \\n    }\\n\\n\\n};`this solution give me TLE \\nGive me tips to improve  this solution\\n"
                    }
                ]
            },
            {
                "id": 1900845,
                "content": [
                    {
                        "username": "ercanK",
                        "content": "I couldn't understand the purpose of the bold phrase. Appreciated if somebody can explain.\n\n\"An island is a 4-directionally connected group of 1's <b>not connected to any other 1's</b>.\"\n\nWhat extra information does it try to provide? Isn't it enough to say `An island is a 4-directionally connected group of 1's`"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "A combination of DFS and BFS. Liked it!"
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "This problem isn\\'t particularly \"hard\", it\\'s just two medium problems in a row. If you don\\'t know where to get started, you should do [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) first, and then come back to this one. You can do it!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be hard"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "What does it mean really? Last executed input is an empty test case.\\n![image](https://private-user-images.githubusercontent.com/103294459/239735009-5c115785-655f-422d-895d-363ec750f95e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJrZXkxIiwiZXhwIjoxNjg0NjY1NDQwLCJuYmYiOjE2ODQ2NjUxNDAsInBhdGgiOiIvMTAzMjk0NDU5LzIzOTczNTAwOS01YzExNTc4NS02NTVmLTQyMmQtODk1ZC0zNjNlYzc1MGY5NWUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQUlXTkpZQVg0Q1NWRUg1M0ElMkYyMDIzMDUyMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA1MjFUMTAzMjIwWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NzIyNzA5ZTViNmE5NTI0MmVhMTAzNzVkZjdlY2ZiZDExYzI2YzdmY2QwNjkzMWY5ODA3YmYzZWQzYTBjODVkNiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.0bx6Tghv0Cq3AXnEb2Z6je0ynSIuuGBnQY0-CIUuHxE)"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Did it without using bfs by taking the minimum absolute difference of coordinates of the two islands. But it not a good solution tbh."
                    },
                    {
                        "username": "user5201tx",
                        "content": "Someone please explain the problem to me. where is the island in these examples above ?? I can see only 1 island in the 3rd example at most !"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in the 3rd example\n[\n[1,1,1,1,1],\n[1,0,0,0,1],\n[1,0,1,0,1],\n[1,0,0,0,1],\n[1,1,1,1,1]\n]\nthe first island is at outer layer and the second island is at the middle \n\nin the first example\n[\n[0,1],\n[1,0]\n]\nthe first island is at the top right and the second island is at the bottom left\n\nin the second example\n[\n[0,1,0],\n[0,0,0],\n[0,0,1]\n]\nthe first island is at the top middle and the second island is at the bottom right"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "Why do i keep getting memory limit exceeded on test case 55... I\\'m using DFS + BFS"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I also did using dfs+bfs i did not get memory limit exceeded"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "nvm... forgot to mark visited in BFS part so it was adding duplicates. runs at 97% faster now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Thank you for the easy weekend, hopefully the guy with the cat picture that types things in bold managed to keep his streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "(ﾉ*ФωФ)ﾉ"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "`class Solution {\\npublic:\\n  \\n    void dfs(vector<vector<int>>& grid, vector<pair<int ,int >>&store, int row, int col) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0 || grid[row][col] == 3) {\\n            return;\\n        }\\n        store.push_back({row, col});\\n        grid[row][col] = 3;\\n        \\n        dfs(grid, store, row, col - 1);\\n        dfs(grid, store, row + 1, col);\\n        dfs(grid, store, row, col + 1);\\n        dfs(grid, store, row - 1, col);\\n    }\\n\\n    int minDistance(vector<vector<int>>& grid,vector<vector<bool>>& visited, int row, int col, int count) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || visited[row][col]==true) {\\n            return INT_MAX;\\n        }\\n        if (grid[row][col] == 1) {\\n            return count;\\n        }\\n\\n        visited[row][col]=true;\\n\\n        int s1 = minDistance(grid,visited, row, col - 1, count + 1);\\n        int s2 = minDistance(grid,visited, row + 1, col, count + 1);\\n        int s3 = minDistance(grid,visited, row, col + 1, count + 1);\\n        int s4 = minDistance(grid,visited, row - 1, col, count + 1);\\n\\n        visited[row][col]=false;\\n\\n        return min({s1, s2, s3, s4});\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<pair<int ,int >> store;\\n        bool flag = false;\\n        int minDist = INT_MAX;\\n        vector<vector<bool>> visited(row,vector<bool >(col,false));\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 1) { \\n                    dfs(grid, store, i, j);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < store.size(); i++) {\\n            minDist = min(minDistance(grid,visited, store[i].first, store[i].second, 0), minDist);\\n        }\\n        return minDist-1;\\n        \\n    }\\n\\n\\n};`this solution give me TLE \\nGive me tips to improve  this solution\\n"
                    }
                ]
            },
            {
                "id": 1900444,
                "content": [
                    {
                        "username": "ercanK",
                        "content": "I couldn't understand the purpose of the bold phrase. Appreciated if somebody can explain.\n\n\"An island is a 4-directionally connected group of 1's <b>not connected to any other 1's</b>.\"\n\nWhat extra information does it try to provide? Isn't it enough to say `An island is a 4-directionally connected group of 1's`"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "A combination of DFS and BFS. Liked it!"
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "This problem isn\\'t particularly \"hard\", it\\'s just two medium problems in a row. If you don\\'t know where to get started, you should do [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) first, and then come back to this one. You can do it!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be hard"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "What does it mean really? Last executed input is an empty test case.\\n![image](https://private-user-images.githubusercontent.com/103294459/239735009-5c115785-655f-422d-895d-363ec750f95e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJrZXkxIiwiZXhwIjoxNjg0NjY1NDQwLCJuYmYiOjE2ODQ2NjUxNDAsInBhdGgiOiIvMTAzMjk0NDU5LzIzOTczNTAwOS01YzExNTc4NS02NTVmLTQyMmQtODk1ZC0zNjNlYzc1MGY5NWUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQUlXTkpZQVg0Q1NWRUg1M0ElMkYyMDIzMDUyMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA1MjFUMTAzMjIwWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NzIyNzA5ZTViNmE5NTI0MmVhMTAzNzVkZjdlY2ZiZDExYzI2YzdmY2QwNjkzMWY5ODA3YmYzZWQzYTBjODVkNiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.0bx6Tghv0Cq3AXnEb2Z6je0ynSIuuGBnQY0-CIUuHxE)"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Did it without using bfs by taking the minimum absolute difference of coordinates of the two islands. But it not a good solution tbh."
                    },
                    {
                        "username": "user5201tx",
                        "content": "Someone please explain the problem to me. where is the island in these examples above ?? I can see only 1 island in the 3rd example at most !"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in the 3rd example\n[\n[1,1,1,1,1],\n[1,0,0,0,1],\n[1,0,1,0,1],\n[1,0,0,0,1],\n[1,1,1,1,1]\n]\nthe first island is at outer layer and the second island is at the middle \n\nin the first example\n[\n[0,1],\n[1,0]\n]\nthe first island is at the top right and the second island is at the bottom left\n\nin the second example\n[\n[0,1,0],\n[0,0,0],\n[0,0,1]\n]\nthe first island is at the top middle and the second island is at the bottom right"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "Why do i keep getting memory limit exceeded on test case 55... I\\'m using DFS + BFS"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I also did using dfs+bfs i did not get memory limit exceeded"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "nvm... forgot to mark visited in BFS part so it was adding duplicates. runs at 97% faster now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Thank you for the easy weekend, hopefully the guy with the cat picture that types things in bold managed to keep his streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "(ﾉ*ФωФ)ﾉ"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "`class Solution {\\npublic:\\n  \\n    void dfs(vector<vector<int>>& grid, vector<pair<int ,int >>&store, int row, int col) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0 || grid[row][col] == 3) {\\n            return;\\n        }\\n        store.push_back({row, col});\\n        grid[row][col] = 3;\\n        \\n        dfs(grid, store, row, col - 1);\\n        dfs(grid, store, row + 1, col);\\n        dfs(grid, store, row, col + 1);\\n        dfs(grid, store, row - 1, col);\\n    }\\n\\n    int minDistance(vector<vector<int>>& grid,vector<vector<bool>>& visited, int row, int col, int count) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || visited[row][col]==true) {\\n            return INT_MAX;\\n        }\\n        if (grid[row][col] == 1) {\\n            return count;\\n        }\\n\\n        visited[row][col]=true;\\n\\n        int s1 = minDistance(grid,visited, row, col - 1, count + 1);\\n        int s2 = minDistance(grid,visited, row + 1, col, count + 1);\\n        int s3 = minDistance(grid,visited, row, col + 1, count + 1);\\n        int s4 = minDistance(grid,visited, row - 1, col, count + 1);\\n\\n        visited[row][col]=false;\\n\\n        return min({s1, s2, s3, s4});\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<pair<int ,int >> store;\\n        bool flag = false;\\n        int minDist = INT_MAX;\\n        vector<vector<bool>> visited(row,vector<bool >(col,false));\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 1) { \\n                    dfs(grid, store, i, j);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < store.size(); i++) {\\n            minDist = min(minDistance(grid,visited, store[i].first, store[i].second, 0), minDist);\\n        }\\n        return minDist-1;\\n        \\n    }\\n\\n\\n};`this solution give me TLE \\nGive me tips to improve  this solution\\n"
                    }
                ]
            },
            {
                "id": 1900353,
                "content": [
                    {
                        "username": "ercanK",
                        "content": "I couldn't understand the purpose of the bold phrase. Appreciated if somebody can explain.\n\n\"An island is a 4-directionally connected group of 1's <b>not connected to any other 1's</b>.\"\n\nWhat extra information does it try to provide? Isn't it enough to say `An island is a 4-directionally connected group of 1's`"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "A combination of DFS and BFS. Liked it!"
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "This problem isn\\'t particularly \"hard\", it\\'s just two medium problems in a row. If you don\\'t know where to get started, you should do [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) first, and then come back to this one. You can do it!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be hard"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "What does it mean really? Last executed input is an empty test case.\\n![image](https://private-user-images.githubusercontent.com/103294459/239735009-5c115785-655f-422d-895d-363ec750f95e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJrZXkxIiwiZXhwIjoxNjg0NjY1NDQwLCJuYmYiOjE2ODQ2NjUxNDAsInBhdGgiOiIvMTAzMjk0NDU5LzIzOTczNTAwOS01YzExNTc4NS02NTVmLTQyMmQtODk1ZC0zNjNlYzc1MGY5NWUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQUlXTkpZQVg0Q1NWRUg1M0ElMkYyMDIzMDUyMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA1MjFUMTAzMjIwWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NzIyNzA5ZTViNmE5NTI0MmVhMTAzNzVkZjdlY2ZiZDExYzI2YzdmY2QwNjkzMWY5ODA3YmYzZWQzYTBjODVkNiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.0bx6Tghv0Cq3AXnEb2Z6je0ynSIuuGBnQY0-CIUuHxE)"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Did it without using bfs by taking the minimum absolute difference of coordinates of the two islands. But it not a good solution tbh."
                    },
                    {
                        "username": "user5201tx",
                        "content": "Someone please explain the problem to me. where is the island in these examples above ?? I can see only 1 island in the 3rd example at most !"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in the 3rd example\n[\n[1,1,1,1,1],\n[1,0,0,0,1],\n[1,0,1,0,1],\n[1,0,0,0,1],\n[1,1,1,1,1]\n]\nthe first island is at outer layer and the second island is at the middle \n\nin the first example\n[\n[0,1],\n[1,0]\n]\nthe first island is at the top right and the second island is at the bottom left\n\nin the second example\n[\n[0,1,0],\n[0,0,0],\n[0,0,1]\n]\nthe first island is at the top middle and the second island is at the bottom right"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "Why do i keep getting memory limit exceeded on test case 55... I\\'m using DFS + BFS"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I also did using dfs+bfs i did not get memory limit exceeded"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "nvm... forgot to mark visited in BFS part so it was adding duplicates. runs at 97% faster now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Thank you for the easy weekend, hopefully the guy with the cat picture that types things in bold managed to keep his streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "(ﾉ*ФωФ)ﾉ"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "`class Solution {\\npublic:\\n  \\n    void dfs(vector<vector<int>>& grid, vector<pair<int ,int >>&store, int row, int col) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0 || grid[row][col] == 3) {\\n            return;\\n        }\\n        store.push_back({row, col});\\n        grid[row][col] = 3;\\n        \\n        dfs(grid, store, row, col - 1);\\n        dfs(grid, store, row + 1, col);\\n        dfs(grid, store, row, col + 1);\\n        dfs(grid, store, row - 1, col);\\n    }\\n\\n    int minDistance(vector<vector<int>>& grid,vector<vector<bool>>& visited, int row, int col, int count) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || visited[row][col]==true) {\\n            return INT_MAX;\\n        }\\n        if (grid[row][col] == 1) {\\n            return count;\\n        }\\n\\n        visited[row][col]=true;\\n\\n        int s1 = minDistance(grid,visited, row, col - 1, count + 1);\\n        int s2 = minDistance(grid,visited, row + 1, col, count + 1);\\n        int s3 = minDistance(grid,visited, row, col + 1, count + 1);\\n        int s4 = minDistance(grid,visited, row - 1, col, count + 1);\\n\\n        visited[row][col]=false;\\n\\n        return min({s1, s2, s3, s4});\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<pair<int ,int >> store;\\n        bool flag = false;\\n        int minDist = INT_MAX;\\n        vector<vector<bool>> visited(row,vector<bool >(col,false));\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 1) { \\n                    dfs(grid, store, i, j);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < store.size(); i++) {\\n            minDist = min(minDistance(grid,visited, store[i].first, store[i].second, 0), minDist);\\n        }\\n        return minDist-1;\\n        \\n    }\\n\\n\\n};`this solution give me TLE \\nGive me tips to improve  this solution\\n"
                    }
                ]
            },
            {
                "id": 1822718,
                "content": [
                    {
                        "username": "ercanK",
                        "content": "I couldn't understand the purpose of the bold phrase. Appreciated if somebody can explain.\n\n\"An island is a 4-directionally connected group of 1's <b>not connected to any other 1's</b>.\"\n\nWhat extra information does it try to provide? Isn't it enough to say `An island is a 4-directionally connected group of 1's`"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "A combination of DFS and BFS. Liked it!"
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "This problem isn\\'t particularly \"hard\", it\\'s just two medium problems in a row. If you don\\'t know where to get started, you should do [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) first, and then come back to this one. You can do it!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be hard"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "What does it mean really? Last executed input is an empty test case.\\n![image](https://private-user-images.githubusercontent.com/103294459/239735009-5c115785-655f-422d-895d-363ec750f95e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJrZXkxIiwiZXhwIjoxNjg0NjY1NDQwLCJuYmYiOjE2ODQ2NjUxNDAsInBhdGgiOiIvMTAzMjk0NDU5LzIzOTczNTAwOS01YzExNTc4NS02NTVmLTQyMmQtODk1ZC0zNjNlYzc1MGY5NWUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQUlXTkpZQVg0Q1NWRUg1M0ElMkYyMDIzMDUyMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA1MjFUMTAzMjIwWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NzIyNzA5ZTViNmE5NTI0MmVhMTAzNzVkZjdlY2ZiZDExYzI2YzdmY2QwNjkzMWY5ODA3YmYzZWQzYTBjODVkNiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.0bx6Tghv0Cq3AXnEb2Z6je0ynSIuuGBnQY0-CIUuHxE)"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Did it without using bfs by taking the minimum absolute difference of coordinates of the two islands. But it not a good solution tbh."
                    },
                    {
                        "username": "user5201tx",
                        "content": "Someone please explain the problem to me. where is the island in these examples above ?? I can see only 1 island in the 3rd example at most !"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in the 3rd example\n[\n[1,1,1,1,1],\n[1,0,0,0,1],\n[1,0,1,0,1],\n[1,0,0,0,1],\n[1,1,1,1,1]\n]\nthe first island is at outer layer and the second island is at the middle \n\nin the first example\n[\n[0,1],\n[1,0]\n]\nthe first island is at the top right and the second island is at the bottom left\n\nin the second example\n[\n[0,1,0],\n[0,0,0],\n[0,0,1]\n]\nthe first island is at the top middle and the second island is at the bottom right"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "Why do i keep getting memory limit exceeded on test case 55... I\\'m using DFS + BFS"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "I also did using dfs+bfs i did not get memory limit exceeded"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "nvm... forgot to mark visited in BFS part so it was adding duplicates. runs at 97% faster now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Thank you for the easy weekend, hopefully the guy with the cat picture that types things in bold managed to keep his streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "(ﾉ*ФωФ)ﾉ"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "`class Solution {\\npublic:\\n  \\n    void dfs(vector<vector<int>>& grid, vector<pair<int ,int >>&store, int row, int col) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0 || grid[row][col] == 3) {\\n            return;\\n        }\\n        store.push_back({row, col});\\n        grid[row][col] = 3;\\n        \\n        dfs(grid, store, row, col - 1);\\n        dfs(grid, store, row + 1, col);\\n        dfs(grid, store, row, col + 1);\\n        dfs(grid, store, row - 1, col);\\n    }\\n\\n    int minDistance(vector<vector<int>>& grid,vector<vector<bool>>& visited, int row, int col, int count) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || visited[row][col]==true) {\\n            return INT_MAX;\\n        }\\n        if (grid[row][col] == 1) {\\n            return count;\\n        }\\n\\n        visited[row][col]=true;\\n\\n        int s1 = minDistance(grid,visited, row, col - 1, count + 1);\\n        int s2 = minDistance(grid,visited, row + 1, col, count + 1);\\n        int s3 = minDistance(grid,visited, row, col + 1, count + 1);\\n        int s4 = minDistance(grid,visited, row - 1, col, count + 1);\\n\\n        visited[row][col]=false;\\n\\n        return min({s1, s2, s3, s4});\\n    }\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<pair<int ,int >> store;\\n        bool flag = false;\\n        int minDist = INT_MAX;\\n        vector<vector<bool>> visited(row,vector<bool >(col,false));\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 1) { \\n                    dfs(grid, store, i, j);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < store.size(); i++) {\\n            minDist = min(minDistance(grid,visited, store[i].first, store[i].second, 0), minDist);\\n        }\\n        return minDist-1;\\n        \\n    }\\n\\n\\n};`this solution give me TLE \\nGive me tips to improve  this solution\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Increasing Decreasing String",
        "question_content": "<p>You are given a string <code>s</code>. Reorder the string using the following algorithm:</p>\n\n<ol>\n\t<li>Pick the <strong>smallest</strong> character from <code>s</code> and <strong>append</strong> it to the result.</li>\n\t<li>Pick the <strong>smallest</strong> character from <code>s</code> which is greater than the last appended character to the result and <strong>append</strong> it.</li>\n\t<li>Repeat step 2 until you cannot pick more characters.</li>\n\t<li>Pick the <strong>largest</strong> character from <code>s</code> and <strong>append</strong> it to the result.</li>\n\t<li>Pick the <strong>largest</strong> character from <code>s</code> which is smaller than the last appended character to the result and <strong>append</strong> it.</li>\n\t<li>Repeat step 5 until you cannot pick more characters.</li>\n\t<li>Repeat the steps from 1 to 6 until you pick all characters from <code>s</code>.</li>\n</ol>\n\n<p>In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.</p>\n\n<p>Return <em>the result string after sorting </em><code>s</code><em> with this algorithm</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aaaabbbbcccc&quot;\n<strong>Output:</strong> &quot;abccbaabccba&quot;\n<strong>Explanation:</strong> After steps 1, 2 and 3 of the first iteration, result = &quot;abc&quot;\nAfter steps 4, 5 and 6 of the first iteration, result = &quot;abccba&quot;\nFirst iteration is done. Now s = &quot;aabbcc&quot; and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = &quot;abccbaabc&quot;\nAfter steps 4, 5 and 6 of the second iteration, result = &quot;abccbaabccba&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;rat&quot;\n<strong>Output:</strong> &quot;art&quot;\n<strong>Explanation:</strong> The word &quot;rat&quot; becomes &quot;art&quot; after re-ordering it with the mentioned algorithm.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> consists of only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 531811,
                "title": "java-python-3-two-clean-codes-w-explanation-and-analysis",
                "content": "**Q & A:**\\n\\nQ1: TreeSet<>(tm.keySet()) vs TreeSet(tm.descendingKeySet()).\\nIn first Java code, I thought TreeSet will always sort from small to large, if you don\\'t specify descending order, no matter what order you put in the ().. can you explain why this works..\\n\\nA1: `TreeSet(SortedSet())` will use the same ordering  as the `SortedSet()`.\\n\\n**End of Q & A.**\\n\\n----\\n**Java**\\n1. Use TreeMap to count each char in `s`;\\n2. Append to StringBuilder the keys in TreeMap in sorted order, decrease the count of each key, and remove the entry if reaching `0`;\\n3. Do the similar operation in step 2, but in descending order of the keys;\\n4. Repeat 2 and 3 till the TreeMap is empty.\\n\\n```java\\n    public String sortString(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        TreeMap<Character, Integer> tm = new TreeMap<>();\\n        for (char c : s.toCharArray()) {\\n            tm.put(c, 1 + tm.getOrDefault(c, 0));\\n        }\\n        boolean asc = true;\\n        while (!tm.isEmpty()) {\\n            for (char c : asc ? new TreeSet<>(tm.keySet()) : new TreeSet(tm.descendingKeySet())) {\\n                ans.append(c);\\n                tm.put(c, tm.get(c) - 1);\\n                tm.remove(c, 0);\\n            }\\n            asc = !asc; // same as asc ^= true;\\n        }\\n        return ans.toString();\\n    }\\n```\\nUse array instead of TreeMap to get better time performance. runtime: 1 ms, beat 100%.\\n```java\\n    public String sortString(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray())\\n            ++count[c - \\'a\\'];\\n        while (ans.length() < s.length()) {\\n            add(count, ans, true);\\n            add(count, ans, false);\\n        }\\n        return ans.toString();\\n    }\\n    private void add(int[] cnt, StringBuilder ans, boolean asc) {\\n        for (int i = 0; i < 26; ++i) {\\n            int j = asc ? i : 25 - i;\\n            if (cnt[j]-- > 0)\\n                ans.append((char)(j + \\'a\\'));\\n        }\\n    }\\n```\\n**Python 3**\\n```python\\n    def sortString(self, s: str) -> str:\\n        cnt, ans, asc = collections.Counter(s), [], True\\n        while cnt:                                                                  # if Counter not empty.\\n            for c in sorted(cnt) if asc else reversed(sorted(cnt)):                 # traverse keys in ascending/descending order.\\n                ans.append(c)                                                       # append the key.\\n                cnt[c] -= 1                                                         # decrease the count.\\n                if cnt[c] == 0:                                                     # if the count reaches to 0.\\n                    del cnt[c]                                                      # remove the key from the Counter.\\n            asc = not asc                                                           # change the direction, same as asc ^= True.\\n        return \\'\\'.join(ans)\\n```\\nSimilar version, but no removal of key from the Counter.\\n```python\\n    def sortString(self, s: str) -> str:\\n        cnt, ans, asc  = collections.Counter(s), [], True\\n        while len(ans) < len(s):                                # if not finish.\\n            for i in range(26):                                 # traverse lower case letters.\\n                c = string.ascii_lowercase[i if asc else ~i]    # in ascending/descending order.\\n                if cnt[c] > 0:                                  # if the count > 0.\\n                    ans.append(c)                               # append the character.\\n                    cnt[c] -= 1                                 # decrease the count.\\n            asc = not asc                                       # change direction.\\n        return \\'\\'.join(ans)\\n```\\n**Analysis:**\\nSince there are only `26` distinct lower case letters, sorting and each TreeMap operation cost at most `26 * log26`, which can be regarded as a constant.\\n\\nTime & space: `O(n)`, where `n` = `s.length()`.",
                "solutionTags": [],
                "code": "```java\\n    public String sortString(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        TreeMap<Character, Integer> tm = new TreeMap<>();\\n        for (char c : s.toCharArray()) {\\n            tm.put(c, 1 + tm.getOrDefault(c, 0));\\n        }\\n        boolean asc = true;\\n        while (!tm.isEmpty()) {\\n            for (char c : asc ? new TreeSet<>(tm.keySet()) : new TreeSet(tm.descendingKeySet())) {\\n                ans.append(c);\\n                tm.put(c, tm.get(c) - 1);\\n                tm.remove(c, 0);\\n            }\\n            asc = !asc; // same as asc ^= true;\\n        }\\n        return ans.toString();\\n    }\\n```\n```java\\n    public String sortString(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray())\\n            ++count[c - \\'a\\'];\\n        while (ans.length() < s.length()) {\\n            add(count, ans, true);\\n            add(count, ans, false);\\n        }\\n        return ans.toString();\\n    }\\n    private void add(int[] cnt, StringBuilder ans, boolean asc) {\\n        for (int i = 0; i < 26; ++i) {\\n            int j = asc ? i : 25 - i;\\n            if (cnt[j]-- > 0)\\n                ans.append((char)(j + \\'a\\'));\\n        }\\n    }\\n```\n```python\\n    def sortString(self, s: str) -> str:\\n        cnt, ans, asc = collections.Counter(s), [], True\\n        while cnt:                                                                  # if Counter not empty.\\n            for c in sorted(cnt) if asc else reversed(sorted(cnt)):                 # traverse keys in ascending/descending order.\\n                ans.append(c)                                                       # append the key.\\n                cnt[c] -= 1                                                         # decrease the count.\\n                if cnt[c] == 0:                                                     # if the count reaches to 0.\\n                    del cnt[c]                                                      # remove the key from the Counter.\\n            asc = not asc                                                           # change the direction, same as asc ^= True.\\n        return \\'\\'.join(ans)\\n```\n```python\\n    def sortString(self, s: str) -> str:\\n        cnt, ans, asc  = collections.Counter(s), [], True\\n        while len(ans) < len(s):                                # if not finish.\\n            for i in range(26):                                 # traverse lower case letters.\\n                c = string.ascii_lowercase[i if asc else ~i]    # in ascending/descending order.\\n                if cnt[c] > 0:                                  # if the count > 0.\\n                    ans.append(c)                               # append the character.\\n                    cnt[c] -= 1                                 # decrease the count.\\n            asc = not asc                                       # change direction.\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 533002,
                "title": "c-counts",
                "content": "```cpp\\nstring sortString(string s, string res = \"\") {\\n    int cnt[26] = {};\\n    for (auto ch: s)\\n        ++cnt[ch - \\'a\\'];\\n    while (s.size() != res.size()) {\\n        for (auto i = 0; i < 26; ++i)\\n            res += string(--cnt[i] >= 0 ? 1 : 0, \\'a\\' + i); \\n        for (int i = 25; i >=0; --i)\\n            res += string(--cnt[i] >= 0 ? 1 : 0, \\'a\\' + i);          \\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring sortString(string s, string res = \"\") {\\n    int cnt[26] = {};\\n    for (auto ch: s)\\n        ++cnt[ch - \\'a\\'];\\n    while (s.size() != res.size()) {\\n        for (auto i = 0; i < 26; ++i)\\n            res += string(--cnt[i] >= 0 ? 1 : 0, \\'a\\' + i); \\n        for (int i = 25; i >=0; --i)\\n            res += string(--cnt[i] >= 0 ? 1 : 0, \\'a\\' + i);          \\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 626626,
                "title": "simple-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        s = list(s)\\n        result = \\'\\'\\n        while s:\\n            for letter in sorted(set(s)):\\n                s.remove(letter)\\n                result += letter\\n            for letter in sorted(set(s), reverse=True):\\n                s.remove(letter)\\n                result += letter\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        s = list(s)\\n        result = \\'\\'\\n        while s:\\n            for letter in sorted(set(s)):\\n                s.remove(letter)\\n                result += letter\\n            for letter in sorted(set(s), reverse=True):\\n                s.remove(letter)\\n                result += letter\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532281,
                "title": "java-simple-beats-100-percent",
                "content": "* calculates freq of each character\\n* Step 1: If accumulated all characters, we are done, else\\n* Step 2: accumulate from \\'a\\' -> \\'z\\', \\n* Step 3: accumulate from \\'z\\' -> \\'a\\'\\n* Go to Step 1.\\n\\n\\n```\\npublic String sortString(String s) {\\n        int len = s.length();\\n        int[] freq = new int[26];\\n        for (int index = 0; index < len; index++) {\\n            freq[s.charAt(index) - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder(len);\\n        int count = 0;\\n        while (count < len) {\\n            // sorting up\\n            for (int i = 0; i < 26; i++) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i] = freq[i] - 1;\\n                    count++;\\n                }\\n            }\\n            // sorting down\\n            for (int i = 25; i >= 0; i--) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i] = freq[i] - 1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\nPlease vote up if you like the solution as encouragement!\\n",
                "solutionTags": [],
                "code": "```\\npublic String sortString(String s) {\\n        int len = s.length();\\n        int[] freq = new int[26];\\n        for (int index = 0; index < len; index++) {\\n            freq[s.charAt(index) - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder(len);\\n        int count = 0;\\n        while (count < len) {\\n            // sorting up\\n            for (int i = 0; i < 26; i++) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i] = freq[i] - 1;\\n                    count++;\\n                }\\n            }\\n            // sorting down\\n            for (int i = 25; i >= 0; i--) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i] = freq[i] - 1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 531928,
                "title": "python-easy-to-understand-solution-explained",
                "content": "Steps:\\n1. Count the number of occurrences of every letter.\\n2. Sort in alphabetic order.\\n3. Follow the procedure defined in the problem statement.\\n```python\\ndef sortString(self, s: str) -> str:\\n    d = sorted([c, n] for c, n in collections.Counter(s).items())\\n    r = []\\n    while len(r) < len(s):\\n        for i in range(len(d)):\\n            if d[i][1]:\\n                r.append(d[i][0])\\n                d[i][1] -= 1\\n        for i in range(len(d)):\\n            if d[~i][1]:\\n                r.append(d[~i][0])\\n                d[~i][1] -= 1\\n    return \\'\\'.join(r)\\n```\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef sortString(self, s: str) -> str:\\n    d = sorted([c, n] for c, n in collections.Counter(s).items())\\n    r = []\\n    while len(r) < len(s):\\n        for i in range(len(d)):\\n            if d[i][1]:\\n                r.append(d[i][0])\\n                d[i][1] -= 1\\n        for i in range(len(d)):\\n            if d[~i][1]:\\n                r.append(d[~i][0])\\n                d[~i][1] -= 1\\n    return \\'\\'.join(r)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 582477,
                "title": "c-solution-easy-to-understand-runtime-4-ms-faster-than-98-52-memory-usage-7-7-mb",
                "content": "***Resources: https://github.com/AJAYKR00KJ/LeetCode_Solution***\\n\\n**Time Complexity: O( N * 2 * 26 ) = O(N)  for very large N**\\n**Space Complexity: O ( 52 ) = constant space**\\n```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string res=\"\";\\n        int a[26]={0},k=0;\\n        for(int i=0;i<s.length();i++)\\n        {a[s[i]-\\'a\\']++;k++;}\\n        while(k)\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                if(a[i]>0) { res+=i+\\'a\\';k--;a[i]--;}\\n            }\\n            for(int i=25;i>=0;i--)\\n            {\\n                if(a[i]>0) { res+=i+\\'a\\';k--;a[i]--;}\\n            }\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string res=\"\";\\n        int a[26]={0},k=0;\\n        for(int i=0;i<s.length();i++)\\n        {a[s[i]-\\'a\\']++;k++;}\\n        while(k)\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                if(a[i]>0) { res+=i+\\'a\\';k--;a[i]--;}\\n            }\\n            for(int i=25;i>=0;i--)\\n            {\\n                if(a[i]>0) { res+=i+\\'a\\';k--;a[i]--;}\\n            }\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531865,
                "title": "java-easy-solution",
                "content": "```\\npublic String sortString(String s) {\\n        int[] chars = new int[26];\\n        \\n        for(char c:s.toCharArray()){\\n            chars[c-\\'a\\']++;\\n        }\\n        StringBuilder output = new StringBuilder();\\n        \\n        while(output.length()<s.length()){\\n            for(int i=0;i<26;i++){\\n                if(chars[i] != 0){\\n                    output.append((char)(i+\\'a\\'));\\n                    chars[i]--;\\n                }\\n            }\\n            for(int i=25;i>=0;i--){\\n                if(chars[i] != 0){\\n                    output.append((char)(i+\\'a\\'));\\n                    chars[i]--;\\n                }\\n            }\\n        }\\n        \\n        return output.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String sortString(String s) {\\n        int[] chars = new int[26];\\n        \\n        for(char c:s.toCharArray()){\\n            chars[c-\\'a\\']++;\\n        }\\n        StringBuilder output = new StringBuilder();\\n        \\n        while(output.length()<s.length()){\\n            for(int i=0;i<26;i++){\\n                if(chars[i] != 0){\\n                    output.append((char)(i+\\'a\\'));\\n                    chars[i]--;\\n                }\\n            }\\n            for(int i=25;i>=0;i--){\\n                if(chars[i] != 0){\\n                    output.append((char)(i+\\'a\\'));\\n                    chars[i]--;\\n                }\\n            }\\n        }\\n        \\n        return output.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 543172,
                "title": "python-3-using-set-and-sort-with-commentary",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        s = list(s)\\n        # Big S: O(n)\\n        result = []\\n        \\n        # Logic is capture distinct char with set\\n        # Remove found char from initial string\\n        \\n        # Big O: O(n)\\n        while len(s) > 0:\\n\\n            # Big O: O(n log n) Space: O(n)\\n            smallest = sorted(set(s))\\n            # Big O: O(s) - reduced set\\n            for small in smallest:\\n                result.append(small)\\n                s.remove(small)\\n                \\n            # Big O: O(n log n) Space: O(n)\\n            largest = sorted(set(s), reverse = True)\\n            # Big O: O(s) - reduced set\\n            for large in largest:\\n                result.append(large)\\n                s.remove(large)\\n        \\n        return \\'\\'.join(result)\\n    \\n        # Summary:  Big O(n)^2 Space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        s = list(s)\\n        # Big S: O(n)\\n        result = []\\n        \\n        # Logic is capture distinct char with set\\n        # Remove found char from initial string\\n        \\n        # Big O: O(n)\\n        while len(s) > 0:\\n\\n            # Big O: O(n log n) Space: O(n)\\n            smallest = sorted(set(s))\\n            # Big O: O(s) - reduced set\\n            for small in smallest:\\n                result.append(small)\\n                s.remove(small)\\n                \\n            # Big O: O(n log n) Space: O(n)\\n            largest = sorted(set(s), reverse = True)\\n            # Big O: O(s) - reduced set\\n            for large in largest:\\n                result.append(large)\\n                s.remove(large)\\n        \\n        return \\'\\'.join(result)\\n    \\n        # Summary:  Big O(n)^2 Space: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532065,
                "title": "javascript-solution",
                "content": "``` javascript\\nvar sortString = function(s) {\\n    let temp = new Array(26).fill(0);\\n    let ans = [];\\n    \\n    for (let i=0; i<s.length; i++) {\\n        temp[s.charCodeAt(i) - 97] += 1;   \\n    }\\n   \\n    let flag = true;\\n    while(ans.length < s.length) {\\n       for (let i=0; i<temp.length; i++) {\\n           var pos = i;\\n           if (!flag) {\\n               pos = 25-i;\\n           }\\n           if (temp[pos] !==0) {\\n               ans.push(String.fromCharCode(pos+97));\\n               temp[pos] -= 1;\\n           }\\n       }\\n        \\n       flag = !flag; \\n    }\\n    ans = ans.join(\\'\\');\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar sortString = function(s) {\\n    let temp = new Array(26).fill(0);\\n    let ans = [];\\n    \\n    for (let i=0; i<s.length; i++) {\\n        temp[s.charCodeAt(i) - 97] += 1;   \\n    }\\n   \\n    let flag = true;\\n    while(ans.length < s.length) {\\n       for (let i=0; i<temp.length; i++) {\\n           var pos = i;\\n           if (!flag) {\\n               pos = 25-i;\\n           }\\n           if (temp[pos] !==0) {\\n               ans.push(String.fromCharCode(pos+97));\\n               temp[pos] -= 1;\\n           }\\n       }\\n        \\n       flag = !flag; \\n    }\\n    ans = ans.join(\\'\\');\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532293,
                "title": "4-lines-python-sort-by-key",
                "content": "```\\ndef sortString(self, s):\\n    def key(c, phase={}):\\n        p = phase[c] = phase.get(c, -1) + 1\\n        return p, ord(c) * (-1)**p\\n    return \\'\\'.join(sorted(s, key=key))\\n```\\nGets accepted in about 72 ms.\\n\\nFor example for input string `aabbb`, the keys are:\\n```\\nFirst \\'a\\':  (0, 97)\\nSecond \\'a\\': (1, -97)\\nFirst \\'b\\':  (0, 98)\\nSecond \\'b\\': (1, -98)\\nThird \\'b\\':  (2, 98)\\n```\\nSo then sorting sorts by phase and inside each phase by ascending or descending character:\\n```\\nPhase 0: (0, 97), (0, 98)     (first \\'a\\', first \\'b\\')\\nPhase 1: (1, -98), (1, -97)   (second \\'b\\', second \\'a\\')\\nPhase 2: (2, 98)              (third \\'b\\')\\n```",
                "solutionTags": [],
                "code": "```\\ndef sortString(self, s):\\n    def key(c, phase={}):\\n        p = phase[c] = phase.get(c, -1) + 1\\n        return p, ord(c) * (-1)**p\\n    return \\'\\'.join(sorted(s, key=key))\\n```\n```\\nFirst \\'a\\':  (0, 97)\\nSecond \\'a\\': (1, -97)\\nFirst \\'b\\':  (0, 98)\\nSecond \\'b\\': (1, -98)\\nThird \\'b\\':  (2, 98)\\n```\n```\\nPhase 0: (0, 97), (0, 98)     (first \\'a\\', first \\'b\\')\\nPhase 1: (1, -98), (1, -97)   (second \\'b\\', second \\'a\\')\\nPhase 2: (2, 98)              (third \\'b\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 682330,
                "title": "java-o-n",
                "content": "1, Count all characters\\' appearance as a pool (cnt[])\\n2, append those characters based on availability in the pool\\n```\\n    public String sortString(String s) {\\n        int n = s.length(), cnt[] = new int[26];\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        StringBuilder sb = new StringBuilder();\\n        while (n > 0) {\\n            for (int i = 0; i < 26 && n > 0; i++) {\\n                if (cnt[i] > 0) {\\n                    cnt[i]--;\\n                    sb.append((char) (\\'a\\' + i));\\n                    n--;\\n                }\\n            }\\n            for (int i = 25; i >= 0 && n > 0; i--) {\\n                if (cnt[i] > 0) {\\n                    cnt[i]--;\\n                    sb.append((char) (\\'a\\' + i));\\n                    n--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String sortString(String s) {\\n        int n = s.length(), cnt[] = new int[26];\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        StringBuilder sb = new StringBuilder();\\n        while (n > 0) {\\n            for (int i = 0; i < 26 && n > 0; i++) {\\n                if (cnt[i] > 0) {\\n                    cnt[i]--;\\n                    sb.append((char) (\\'a\\' + i));\\n                    n--;\\n                }\\n            }\\n            for (int i = 25; i >= 0 && n > 0; i--) {\\n                if (cnt[i] > 0) {\\n                    cnt[i]--;\\n                    sb.append((char) (\\'a\\' + i));\\n                    n--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 885979,
                "title": "my-java-solutions-with-comments-and-idea",
                "content": "```\\n// so the idea here is to first count the frequency of all charcaters present inside the given input text.\\n// then we take the frequency.\\n// until our resulting string < len(input string)\\n    // first we go from a - > z and check whther we have a frequency > 0, if yes, then we uodate our result and decrease the frequency.\\n    // same way, we do z -> a and check the same as above and append to the result.\\n// finally this result will give us the answe according to the algorithm provided in the question.\\n\\nclass Solution {\\n    public String sortString(String s) {\\n        int [] freq = new int[26];\\n        for (char ch: s.toCharArray()) {\\n            freq[ch - \\'a\\'] += 1;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while (sb.length() < s.length()) {\\n            for (int i=0; i<26; i++) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i] -= 1;\\n                }\\n            }\\n            for (int i=25; i>=0; i--) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i] -= 1;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n// so the idea here is to first count the frequency of all charcaters present inside the given input text.\\n// then we take the frequency.\\n// until our resulting string < len(input string)\\n    // first we go from a - > z and check whther we have a frequency > 0, if yes, then we uodate our result and decrease the frequency.\\n    // same way, we do z -> a and check the same as above and append to the result.\\n// finally this result will give us the answe according to the algorithm provided in the question.\\n\\nclass Solution {\\n    public String sortString(String s) {\\n        int [] freq = new int[26];\\n        for (char ch: s.toCharArray()) {\\n            freq[ch - \\'a\\'] += 1;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while (sb.length() < s.length()) {\\n            for (int i=0; i<26; i++) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i] -= 1;\\n                }\\n            }\\n            for (int i=25; i>=0; i--) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i] -= 1;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531836,
                "title": "c-simple-char-count-solution",
                "content": "```csharp\\npublic string SortString(string s) \\n{\\n\\tStringBuilder sb = new StringBuilder();\\n\\tint[] chars = new int[26];\\n\\tforeach(var c in s)\\n\\t{\\n\\t\\tchars[c - \\'a\\']++;\\n\\t}\\n\\n\\tint count = 0;\\n\\n\\twhile(count < s.Length)\\n\\t{\\n\\t\\tfor(int i = 0; i < chars.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif(chars[i] > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.Append((char)(i + \\'a\\'));\\n\\t\\t\\t\\tchars[i]--;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor(int i = chars.Length - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(chars[i] > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.Append((char)(i + \\'a\\'));\\n\\t\\t\\t\\tchars[i]--;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tstring result = sb.ToString();\\n\\treturn result; \\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic string SortString(string s) \\n{\\n\\tStringBuilder sb = new StringBuilder();\\n\\tint[] chars = new int[26];\\n\\tforeach(var c in s)\\n\\t{\\n\\t\\tchars[c - \\'a\\']++;\\n\\t}\\n\\n\\tint count = 0;\\n\\n\\twhile(count < s.Length)\\n\\t{\\n\\t\\tfor(int i = 0; i < chars.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif(chars[i] > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.Append((char)(i + \\'a\\'));\\n\\t\\t\\t\\tchars[i]--;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor(int i = chars.Length - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(chars[i] > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.Append((char)(i + \\'a\\'));\\n\\t\\t\\t\\tchars[i]--;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tstring result = sb.ToString();\\n\\treturn result; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3182061,
                "title": "finding-solutions-in-an-easy-understandable-and-fast-way",
                "content": "# Intuition\\n[Java] Finding solutions in an easy, understandable and fast way\\n\\n# Approach\\nThe goal is to find a solution to the example using only while and for operators\\n\\n# Complexity\\n- Time complexity:\\nRuntime: 5 ms       Beats :47.73%\\nMemory:  42.1 MB    Beats :91.92%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[27];\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n//Find the number of occurrences of each letter in the text S and \\n//place it in an array\\n        for(int i=0;i<s.length();i++){\\n            int num = str.indexOf((s.charAt(i)));\\n            arr[++num]=arr[num]+1;\\n        }\\n\\n        int len = s.length();\\n        int count=0;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        while(count<len){\\n            for(int i=1;i<27;i++){\\n                if(arr[i]>0){\\n                    ans.append(str.charAt(i - 1));\\n                    arr[i]=arr[i]-1;\\n                    count++;\\n                }\\n            }\\n            for(int j=26;j>=1;j--){\\n                if(arr[j]>0){\\n                    ans.append(str.charAt(j - 1));\\n                    arr[j]=arr[j]-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return new String(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[27];\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n//Find the number of occurrences of each letter in the text S and \\n//place it in an array\\n        for(int i=0;i<s.length();i++){\\n            int num = str.indexOf((s.charAt(i)));\\n            arr[++num]=arr[num]+1;\\n        }\\n\\n        int len = s.length();\\n        int count=0;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        while(count<len){\\n            for(int i=1;i<27;i++){\\n                if(arr[i]>0){\\n                    ans.append(str.charAt(i - 1));\\n                    arr[i]=arr[i]-1;\\n                    count++;\\n                }\\n            }\\n            for(int j=26;j>=1;j--){\\n                if(arr[j]>0){\\n                    ans.append(str.charAt(j - 1));\\n                    arr[j]=arr[j]-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return new String(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531844,
                "title": "c-min-and-max-heaps-count-array",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string t;\\n\\t\\tpriority_queue<char, vector<char>, greater<char>> pq1(s.begin(), s.end());\\n        priority_queue<char> pq2;\\n        \\n        while (!pq1.empty() || !pq2.empty()) {\\n            bool isFirst(true);\\n            while (!pq1.empty()) {\\n                if (isFirst) {\\n                    t += pq1.top();\\n                    isFirst = false;\\n                } else if (t.back() < pq1.top()) t += pq1.top();\\n                else pq2.push(pq1.top());\\n                pq1.pop();\\n            }\\n            isFirst = true;\\n            while (!pq2.empty()) {\\n                if (isFirst) {\\n                    t += pq2.top();\\n                    isFirst = false;\\n                } else if (t.back() > pq2.top()) t += pq2.top();\\n                else pq1.push(pq2.top());\\n                pq2.pop();\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        int letters[26] = {};\\n        string t;\\n        \\n        for (const char& c: s) letters[c - \\'a\\']++;\\n            \\n        while (true) {\\n            for (int i = 0; i < 26; ++i)\\n                if (letters[i]-- > 0)\\n                    t += \\'a\\' + i;\\n            for (int i = 25; i >= 0; --i)\\n                if (letters[i]-- > 0)\\n                    t += \\'a\\' + i;\\n            if (s.length() == t.length()) break;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string t;\\n\\t\\tpriority_queue<char, vector<char>, greater<char>> pq1(s.begin(), s.end());\\n        priority_queue<char> pq2;\\n        \\n        while (!pq1.empty() || !pq2.empty()) {\\n            bool isFirst(true);\\n            while (!pq1.empty()) {\\n                if (isFirst) {\\n                    t += pq1.top();\\n                    isFirst = false;\\n                } else if (t.back() < pq1.top()) t += pq1.top();\\n                else pq2.push(pq1.top());\\n                pq1.pop();\\n            }\\n            isFirst = true;\\n            while (!pq2.empty()) {\\n                if (isFirst) {\\n                    t += pq2.top();\\n                    isFirst = false;\\n                } else if (t.back() > pq2.top()) t += pq2.top();\\n                else pq1.push(pq2.top());\\n                pq2.pop();\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        int letters[26] = {};\\n        string t;\\n        \\n        for (const char& c: s) letters[c - \\'a\\']++;\\n            \\n        while (true) {\\n            for (int i = 0; i < 26; ++i)\\n                if (letters[i]-- > 0)\\n                    t += \\'a\\' + i;\\n            for (int i = 25; i >= 0; --i)\\n                if (letters[i]-- > 0)\\n                    t += \\'a\\' + i;\\n            if (s.length() == t.length()) break;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424376,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring sortString(string s) {\\n\\n\\t\\t\\tunordered_map<char, int> mp;\\n\\n\\t\\t\\tfor(auto i : s){\\n\\t\\t\\t\\tmp[i]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring ans = \"\";\\n\\n\\t\\t\\tbool found = true;\\n\\t\\t\\twhile(found){\\n\\n\\t\\t\\t\\tfound = false;\\n\\t\\t\\t\\t// For steps 1,2,3\\n\\t\\t\\t\\tfor(char c=\\'a\\' ; c<=\\'z\\' ; c++){\\n\\t\\t\\t\\t\\tif(mp[c]){\\n\\t\\t\\t\\t\\t\\tans.push_back(c);\\n\\t\\t\\t\\t\\t\\tmp[c]--;\\n\\t\\t\\t\\t\\t\\tfound= true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// For steps 4,5,6\\n\\t\\t\\t\\tfor(char c=\\'z\\' ; c>=\\'a\\' ; c--){\\n\\t\\t\\t\\t\\tif(mp[c]){\\n\\t\\t\\t\\t\\t\\tans.push_back(c);\\n\\t\\t\\t\\t\\t\\tmp[c]--;\\n\\t\\t\\t\\t\\t\\tfound= true;                    \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring sortString(string s) {\\n\\n\\t\\t\\tunordered_map<char, int> mp;\\n\\n\\t\\t\\tfor(auto i : s){\\n\\t\\t\\t\\tmp[i]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 798774,
                "title": "java-o-n-simple",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] alphabet = new int[26];\\n        \\n        for(char c: s.toCharArray()) {\\n            alphabet[c - \\'a\\']++;\\n        }\\n        \\n        int i = 0;\\n        boolean plus = true;\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(len > 0) {\\n            if (alphabet[i] > 0) {\\n                sb.append((char) (i + \\'a\\'));\\n                alphabet[i]--;\\n                len--;\\n            }\\n            \\n            if (((plus) && (i == 25)) || ((!plus) && (i == 0))) {\\n                plus = !plus;\\n            } else {\\n                i += plus? 1 : -1;\\n            }\\n        }\\n        \\n        return sb.toString(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] alphabet = new int[26];\\n        \\n        for(char c: s.toCharArray()) {\\n            alphabet[c - \\'a\\']++;\\n        }\\n        \\n        int i = 0;\\n        boolean plus = true;\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(len > 0) {\\n            if (alphabet[i] > 0) {\\n                sb.append((char) (i + \\'a\\'));\\n                alphabet[i]--;\\n                len--;\\n            }\\n            \\n            if (((plus) && (i == 25)) || ((!plus) && (i == 0))) {\\n                plus = !plus;\\n            } else {\\n                i += plus? 1 : -1;\\n            }\\n        }\\n        \\n        return sb.toString(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073396,
                "title": "python-3-simple-clean-code-beats-98-speed",
                "content": "Strategy : \\n1. Maintain a counter/dictionary of all characters\\n2. Maintain a list of sorted characters\\n3. Everytime a character is chosen from the dictionary its count is reduced, if it becomes zero the dictionary key is removed\\n4. Iterate over this list in ascending and descending order alternatively, adding elements to the result string, unitl the dictionary is not empty\\n```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        \\n        res = \\'\\'\\n        counter = dict(collections.Counter(s))\\n        chars = sorted(list(set(s)))\\n        \\n        while(counter):\\n            for char in chars:\\n                if char in counter:\\n                    res += char\\n                    counter[char] -= 1\\n                    if counter[char] == 0:\\n                        del counter[char]\\n            for char in reversed(chars):\\n                if char in counter:\\n                    res += char\\n                    counter[char] -= 1\\n                    if counter[char] == 0:\\n                        del counter[char]\\n                        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        \\n        res = \\'\\'\\n        counter = dict(collections.Counter(s))\\n        chars = sorted(list(set(s)))\\n        \\n        while(counter):\\n            for char in chars:\\n                if char in counter:\\n                    res += char\\n                    counter[char] -= 1\\n                    if counter[char] == 0:\\n                        del counter[char]\\n            for char in reversed(chars):\\n                if char in counter:\\n                    res += char\\n                    counter[char] -= 1\\n                    if counter[char] == 0:\\n                        del counter[char]\\n                        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801753,
                "title": "very-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string res=\"\";\\n        int n=s.length();\\n        vector<int> count(26,0);\\n        for(auto ch: s){\\n            count[ch-\\'a\\']++;\\n        }\\n        while(n>res.size()){\\n            for(int i=0;i<26;i++){\\n                if(count[i]>0){\\n                    res+=i+\\'a\\';\\n                    count[i]--;\\n                }\\n            }\\n            for(int j=25;j>=0;j--){\\n                if(count[j]>0){\\n                    res+=j+\\'a\\';\\n                    count[j]--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string res=\"\";\\n        int n=s.length();\\n        vector<int> count(26,0);\\n        for(auto ch: s){\\n            count[ch-\\'a\\']++;\\n        }\\n        while(n>res.size()){\\n            for(int i=0;i<26;i++){\\n                if(count[i]>0){\\n                    res+=i+\\'a\\';\\n                    count[i]--;\\n                }\\n            }\\n            for(int j=25;j>=0;j--){\\n                if(count[j]>0){\\n                    res+=j+\\'a\\';\\n                    count[j]--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715160,
                "title": "simple-javascript",
                "content": "```\\nvar sortString = function (s) {\\n  let arr = Array.from(s), ret = \\'\\';\\n\\n  arr.sort();\\n\\n  while (arr.length) {\\n    arr = arr.filter((x, i) => {\\n      if (i === 0 || x !== ret[ret.length - 1]) {\\n        ret += x;\\n        return false;\\n      }\\n      return true;\\n    });\\n\\n    arr.reverse();\\n  }\\n\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortString = function (s) {\\n  let arr = Array.from(s), ret = \\'\\';\\n\\n  arr.sort();\\n\\n  while (arr.length) {\\n    arr = arr.filter((x, i) => {\\n      if (i === 0 || x !== ret[ret.length - 1]) {\\n        ret += x;\\n        return false;\\n      }\\n      return true;\\n    });\\n\\n    arr.reverse();\\n  }\\n\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 552336,
                "title": "simple-javascript-solutions-w-regexp-sort",
                "content": "```\\nconst sortString = s => {\\n    s = s.split``.sort().join``\\n    let result = \\'\\'\\n    while(s.length){\\n        result += s.match(/([a-z])(?!\\\\1)/gi).join``\\n        s = s.replace(/([a-z])(?!\\\\1)/gi, \\'\\')\\n        result += (s.match(/([a-z])(?!\\\\1)/gi) || []).reverse().join``\\n        s = s.replace(/([a-z])(?!\\\\1)/gi, \\'\\')\\n    }\\n    return result\\n};\\n```\\nw/ Sorting and Character Counting\\n```\\nconst sortString = s => {\\n    let count = Array(26).fill(0), result = \\'\\'\\n    for(const char of s)count[char.charCodeAt() - 97]++\\n    let chars = [...new Set(s)].sort()\\n    while(result.length < s.length){\\n        for(const char of chars){\\n            let idx = char.charCodeAt() - 97 \\n            if(count[idx]){\\n                result += char\\n                count[idx]--\\n            }\\n        }\\n        for(let i = chars.length-1; i >= 0; i--){\\n            let char = chars[i], idx = char.charCodeAt() - 97\\n            if(count[idx]){\\n                result += char\\n                count[idx]--\\n            }\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sortString = s => {\\n    s = s.split``.sort().join``\\n    let result = \\'\\'\\n    while(s.length){\\n        result += s.match(/([a-z])(?!\\\\1)/gi).join``\\n        s = s.replace(/([a-z])(?!\\\\1)/gi, \\'\\')\\n        result += (s.match(/([a-z])(?!\\\\1)/gi) || []).reverse().join``\\n        s = s.replace(/([a-z])(?!\\\\1)/gi, \\'\\')\\n    }\\n    return result\\n};\\n```\n```\\nconst sortString = s => {\\n    let count = Array(26).fill(0), result = \\'\\'\\n    for(const char of s)count[char.charCodeAt() - 97]++\\n    let chars = [...new Set(s)].sort()\\n    while(result.length < s.length){\\n        for(const char of chars){\\n            let idx = char.charCodeAt() - 97 \\n            if(count[idx]){\\n                result += char\\n                count[idx]--\\n            }\\n        }\\n        for(let i = chars.length-1; i >= 0; i--){\\n            let char = chars[i], idx = char.charCodeAt() - 97\\n            if(count[idx]){\\n                result += char\\n                count[idx]--\\n            }\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 549753,
                "title": "super-easy-python3-solution",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        result = []\\n        s = list(s)\\n        flag = True\\n        while len(s)!=0:\\n            if flag:\\n                temp = sorted(set(s))\\n            else:\\n                temp = sorted(set(s), reverse = True)\\n            for ch in temp: s.remove(ch)\\n            result.extend(temp)  \\n            flag = not flag\\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        result = []\\n        s = list(s)\\n        flag = True\\n        while len(s)!=0:\\n            if flag:\\n                temp = sorted(set(s))\\n            else:\\n                temp = sorted(set(s), reverse = True)\\n            for ch in temp: s.remove(ch)\\n            result.extend(temp)  \\n            flag = not flag\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779044,
                "title": "java-simple-bucket-technique-with-multiple-passes",
                "content": "```\\n    // make a char frequency array of characters and the frequency with that they occur.\\n    // pick an array index at which count > 0 add it to the result, increment the index until you find the next non zero            count char. add it to result and increment index. keep doing so until you reach the end of array.\\n    // this was bascially step 2.\\n    \\n    //set index to array.length and decremtn index until you find a char with nonzero count; add that to result and keep         //decrementing and adding non zero count chars until you reach 0;\\n    \\n    //check if the length of appended string is equal to the original string, if not so repeat the above two steps of \\n    //passing in forward direction and then in backward until the length of appended string equals the original.\\n    \\n    //return the result\\n    \\n    //Time Complexity = O(n)\\n    //Space Complexity = O(1);\\n    \\n    public String sortString(String s) {\\n        \\n        int[] charArr = new int[26];\\n        \\n        for(int i=0; i<s.length(); i++){\\n            charArr[s.charAt(i) - \\'a\\']++;            \\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(sb.length() != s.length()){\\n            for(int i=0; i<26; i++){\\n                if(charArr[i] > 0){\\n                    sb.append((char) (\\'a\\' + i));\\n                    charArr[i]--;\\n                }\\n            }\\n            \\n            \\n            for(int j=25; j>=0; j--){\\n                if(charArr[j] > 0){\\n                    sb.append((char) (\\'a\\' + j));\\n                    charArr[j]--;\\n                }\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    // make a char frequency array of characters and the frequency with that they occur.\\n    // pick an array index at which count > 0 add it to the result, increment the index until you find the next non zero            count char. add it to result and increment index. keep doing so until you reach the end of array.\\n    // this was bascially step 2.\\n    \\n    //set index to array.length and decremtn index until you find a char with nonzero count; add that to result and keep         //decrementing and adding non zero count chars until you reach 0;\\n    \\n    //check if the length of appended string is equal to the original string, if not so repeat the above two steps of \\n    //passing in forward direction and then in backward until the length of appended string equals the original.\\n    \\n    //return the result\\n    \\n    //Time Complexity = O(n)\\n    //Space Complexity = O(1);\\n    \\n    public String sortString(String s) {\\n        \\n        int[] charArr = new int[26];\\n        \\n        for(int i=0; i<s.length(); i++){\\n            charArr[s.charAt(i) - \\'a\\']++;            \\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(sb.length() != s.length()){\\n            for(int i=0; i<26; i++){\\n                if(charArr[i] > 0){\\n                    sb.append((char) (\\'a\\' + i));\\n                    charArr[i]--;\\n                }\\n            }\\n            \\n            \\n            for(int j=25; j>=0; j--){\\n                if(charArr[j] > 0){\\n                    sb.append((char) (\\'a\\' + j));\\n                    charArr[j]--;\\n                }\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 734966,
                "title": "c-using-map",
                "content": "Anyone that figures out how to use iterators and delete any element that has 0 frequency in the map after loops, please post below. I would be very grateful! I tried to mess with iterator and reverse iterator but I seem not to be able to comprehend how it works, especially in deleting key in the map (for this problem to work out specifically)\\n\\n```\\n//Runtime: 56 ms, faster than 20.47% of C++ online submissions for Increasing Decreasing String.\\n//Memory Usage: 8.1 MB, less than 24.70% of C++ online submissions for Increasing Decreasing String.\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string res;\\n        map<char , int> m;\\n        for (int i =0; i < s.size(); i++){\\n            m[s[i]] += 1;\\n        }\\n        int n = s.size();\\n        int size = res.size();\\n        while(size!=n){\\n             for (map<char, int>::iterator itr = m.begin(); itr != m.end();itr++ ){\\n                if (itr->second != 0){\\n                    itr->second = itr->second - 1;\\n                    res.push_back(itr->first);\\n                    ++size;  \\n                }\\n            }\\n            //------\\n            for (map<char, int>::reverse_iterator it = m.rbegin(); it != m.rend();  it++){\\n                if (it->second != 0){\\n                    it->second = it->second - 1;\\n                    res.push_back(it->first);\\n                    ++size;\\n                }\\n            }\\n        }   \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//Runtime: 56 ms, faster than 20.47% of C++ online submissions for Increasing Decreasing String.\\n//Memory Usage: 8.1 MB, less than 24.70% of C++ online submissions for Increasing Decreasing String.\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string res;\\n        map<char , int> m;\\n        for (int i =0; i < s.size(); i++){\\n            m[s[i]] += 1;\\n        }\\n        int n = s.size();\\n        int size = res.size();\\n        while(size!=n){\\n             for (map<char, int>::iterator itr = m.begin(); itr != m.end();itr++ ){\\n                if (itr->second != 0){\\n                    itr->second = itr->second - 1;\\n                    res.push_back(itr->first);\\n                    ++size;  \\n                }\\n            }\\n            //------\\n            for (map<char, int>::reverse_iterator it = m.rbegin(); it != m.rend();  it++){\\n                if (it->second != 0){\\n                    it->second = it->second - 1;\\n                    res.push_back(it->first);\\n                    ++size;\\n                }\\n            }\\n        }   \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698878,
                "title": "o-n-o-1-time-space-using-van-emde-boas-tree",
                "content": "The van Emde Boas (vEB) tree can find successor and predecessors of a given letter in O(log log u) time and O(u) space where u is the number of possible letters in the alphabet; 26 in this case. Using vEB is a sledge hammer to the thumbtack of a problem here; but its kinda fun to learn vEB\\'s using a toy problem. I have seen several O(n)/O(1) solutions in the discussion I recommend anyone of those over this solution unless you want some vEB exposure. \\n\\nThis youtube video covers the subject well https://www.youtube.com/watch?v=hmReJCupbNU&t=4178s.\\n\\nThe following solution implements a basic binary vEB with O(log u) time to find its predecessor/successor and O(u) space. \\n\\n```\\npublic string SortString(string s) {\\n\\t// keeps track of the binary vEB tree\\n\\t// each bit indicates whether or not its corresponding cluster has an item\\n\\tvar tree = 0ul; \\n\\tvar freq = new int[26];\\n\\tfor (int i = 0; i < s.Length; ++i) add(s[i] - \\'a\\');\\n\\n\\tvar res = s.ToArray();\\n\\tvar (j, x) = (0, default(int?));\\n\\twhile (tree > 0) {\\n\\t\\twhile ((x = nxt(x ?? -1)).HasValue) {\\n\\t\\t\\tres[j++] = (char)(x.Value + \\'a\\');\\n\\t\\t\\trmv(x.Value);\\n\\t\\t}\\n\\t\\twhile ((x = prv(x ?? 32)).HasValue) {\\n\\t\\t\\tres[j++] = (char)(x.Value + \\'a\\');\\n\\t\\t\\trmv(x.Value);\\n\\t\\t}\\n\\t}\\n\\treturn new string(res);\\n\\n    // adds a new value to the frequency list and vEB tree\\n\\tvoid add(int i)\\n\\t{\\n\\t\\tif (freq[i]++ == 0) // add i to the vEB if its the first time we are adding i\\n\\t\\t{\\n\\t\\t\\ti += 31; // translate to the value to the appropriate leaf index in the vEB\\n\\t\\t\\t// walk up the anscestors path setting them to 1 to indicate the new value exists\\n\\t\\t\\twhile ((tree & 1ul << i) == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree |= 1ul << i; // set the bit at i to 1\\n\\t\\t\\t\\ti = (i - 1) / 2; // move to the parent\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    // removes a value from the frequency list and vEB tree\\n\\tvoid rmv(int i)\\n\\t{\\n\\t\\tif (--freq[i] == 0) // remove i from the vEB if we just removed the last instance from freq \\n\\t\\t{\\n\\t\\t\\ti += 31; // translate to the value to the appropriate leaf index in the vEB\\n\\t\\t\\t// walk up the anscestors path setting them to 0 if they have no children\\n\\t\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree ^= 1ul << i; // set the bit at i to 0\\n\\t\\t\\t\\ti = (i - 1) / 2; // move to the parent\\n\\t\\t\\t} while (tree > 0 && ((tree & 1ul << 2 * i + 1) | (tree & 1ul << 2 * i + 2)) == 0); // neither child has a value\\n\\t\\t}\\n\\t}\\n\\n    // finds the next value in the vEB after i and returns null if not found\\n\\tint? nxt(int i)\\n\\t{\\n\\t\\tif (tree == 0 || i > 30) return null; // the tree is empty or there can\\'t be a larger item\\n\\t\\ti = i < 0 ? 31 : i + 32; // translate the value to the first vEB leaf index that could be the successor\\n\\t\\tvar m = 63; // one more than the largest value in the lowest layer\\n\\t\\twhile (i < m) // while there can still potentially be a successor value\\n\\t\\t{\\n\\t\\t\\t// check if the successor value is in the current cluster\\n\\t\\t\\tif ((tree & 1ul << i) > 0) break;\\n\\t\\t\\tif (i % 2 == 1 && (tree & 1ul << ++i) > 0) break;\\n\\t\\t\\t\\n\\t\\t\\t// we didn\\'t find it in this cluster, lets move to the cluster just after the current clusters parent\\n\\t\\t\\ti = (i - 1) / 2 + 1;\\n\\t\\t\\tm = (m - 1) / 2;\\n\\t\\t}\\n\\t\\tif (i >= m) return null; // we found the successor does not exist\\n\\t\\t// we know the current cluster\\'s descendants contain the successor, lets drill down to the left most descendant  \\n\\t\\twhile (i < 31)\\n\\t\\t\\ti = (tree & 1ul << 2 * i + 1) > 0 ? 2 * i + 1 : 2 * i + 2;\\n\\t\\treturn i - 31;\\n\\t}\\n\\n\\t// finds the previous value in the vEB before i and returns null if not found\\n\\tint? prv(int i)\\n\\t{\\n\\t\\tif (tree == 0 || i < 1) return null; // the tree is empty or there can\\'t be a smaller item\\n\\t\\ti = i > 31 ? 62 : i + 30; // translate the value to the first vEB leaf index that could be the predecessor\\n\\t\\tvar m = 30; // one less than the minimum value in the lowest level \\n\\t\\twhile (i > m) // while there can still potentially be a previous value\\n\\t\\t{\\n\\t\\t\\t// check if the previous value is in the current cluster\\n\\t\\t\\tif ((tree & 1ul << i) > 0) break; \\n\\t\\t\\tif (i % 2 == 0 && (tree & 1ul << --i) > 0) break; \\n\\t\\t\\t\\n\\t\\t\\t// we didn\\'t find it in this cluster, lets move to the previous parent cluster\\n\\t\\t\\ti = (i - 1) / 2 - 1;\\n\\t\\t\\tm = (m - 1) / 2;\\n\\t\\t}\\n\\t\\tif (i <= m) return null; // we found a predecessor does not exist\\n\\t\\t\\n\\t\\t// we know a previous exits somewhere under the children of this cluster\\n\\t\\t// we drill down to the right most leaf from the current cluster\\n\\t\\twhile (i < 31)\\n\\t\\t\\ti = (tree & 1ul << 2 * i + 2) > 0 ? 2 * i + 2 : 2 * i + 1;\\n\\t\\treturn i - 31; // translate the leaf index back to the value \\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic string SortString(string s) {\\n\\t// keeps track of the binary vEB tree\\n\\t// each bit indicates whether or not its corresponding cluster has an item\\n\\tvar tree = 0ul; \\n\\tvar freq = new int[26];\\n\\tfor (int i = 0; i < s.Length; ++i) add(s[i] - \\'a\\');\\n\\n\\tvar res = s.ToArray();\\n\\tvar (j, x) = (0, default(int?));\\n\\twhile (tree > 0) {\\n\\t\\twhile ((x = nxt(x ?? -1)).HasValue) {\\n\\t\\t\\tres[j++] = (char)(x.Value + \\'a\\');\\n\\t\\t\\trmv(x.Value);\\n\\t\\t}\\n\\t\\twhile ((x = prv(x ?? 32)).HasValue) {\\n\\t\\t\\tres[j++] = (char)(x.Value + \\'a\\');\\n\\t\\t\\trmv(x.Value);\\n\\t\\t}\\n\\t}\\n\\treturn new string(res);\\n\\n    // adds a new value to the frequency list and vEB tree\\n\\tvoid add(int i)\\n\\t{\\n\\t\\tif (freq[i]++ == 0) // add i to the vEB if its the first time we are adding i\\n\\t\\t{\\n\\t\\t\\ti += 31; // translate to the value to the appropriate leaf index in the vEB\\n\\t\\t\\t// walk up the anscestors path setting them to 1 to indicate the new value exists\\n\\t\\t\\twhile ((tree & 1ul << i) == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree |= 1ul << i; // set the bit at i to 1\\n\\t\\t\\t\\ti = (i - 1) / 2; // move to the parent\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    // removes a value from the frequency list and vEB tree\\n\\tvoid rmv(int i)\\n\\t{\\n\\t\\tif (--freq[i] == 0) // remove i from the vEB if we just removed the last instance from freq \\n\\t\\t{\\n\\t\\t\\ti += 31; // translate to the value to the appropriate leaf index in the vEB\\n\\t\\t\\t// walk up the anscestors path setting them to 0 if they have no children\\n\\t\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree ^= 1ul << i; // set the bit at i to 0\\n\\t\\t\\t\\ti = (i - 1) / 2; // move to the parent\\n\\t\\t\\t} while (tree > 0 && ((tree & 1ul << 2 * i + 1) | (tree & 1ul << 2 * i + 2)) == 0); // neither child has a value\\n\\t\\t}\\n\\t}\\n\\n    // finds the next value in the vEB after i and returns null if not found\\n\\tint? nxt(int i)\\n\\t{\\n\\t\\tif (tree == 0 || i > 30) return null; // the tree is empty or there can\\'t be a larger item\\n\\t\\ti = i < 0 ? 31 : i + 32; // translate the value to the first vEB leaf index that could be the successor\\n\\t\\tvar m = 63; // one more than the largest value in the lowest layer\\n\\t\\twhile (i < m) // while there can still potentially be a successor value\\n\\t\\t{\\n\\t\\t\\t// check if the successor value is in the current cluster\\n\\t\\t\\tif ((tree & 1ul << i) > 0) break;\\n\\t\\t\\tif (i % 2 == 1 && (tree & 1ul << ++i) > 0) break;\\n\\t\\t\\t\\n\\t\\t\\t// we didn\\'t find it in this cluster, lets move to the cluster just after the current clusters parent\\n\\t\\t\\ti = (i - 1) / 2 + 1;\\n\\t\\t\\tm = (m - 1) / 2;\\n\\t\\t}\\n\\t\\tif (i >= m) return null; // we found the successor does not exist\\n\\t\\t// we know the current cluster\\'s descendants contain the successor, lets drill down to the left most descendant  \\n\\t\\twhile (i < 31)\\n\\t\\t\\ti = (tree & 1ul << 2 * i + 1) > 0 ? 2 * i + 1 : 2 * i + 2;\\n\\t\\treturn i - 31;\\n\\t}\\n\\n\\t// finds the previous value in the vEB before i and returns null if not found\\n\\tint? prv(int i)\\n\\t{\\n\\t\\tif (tree == 0 || i < 1) return null; // the tree is empty or there can\\'t be a smaller item\\n\\t\\ti = i > 31 ? 62 : i + 30; // translate the value to the first vEB leaf index that could be the predecessor\\n\\t\\tvar m = 30; // one less than the minimum value in the lowest level \\n\\t\\twhile (i > m) // while there can still potentially be a previous value\\n\\t\\t{\\n\\t\\t\\t// check if the previous value is in the current cluster\\n\\t\\t\\tif ((tree & 1ul << i) > 0) break; \\n\\t\\t\\tif (i % 2 == 0 && (tree & 1ul << --i) > 0) break; \\n\\t\\t\\t\\n\\t\\t\\t// we didn\\'t find it in this cluster, lets move to the previous parent cluster\\n\\t\\t\\ti = (i - 1) / 2 - 1;\\n\\t\\t\\tm = (m - 1) / 2;\\n\\t\\t}\\n\\t\\tif (i <= m) return null; // we found a predecessor does not exist\\n\\t\\t\\n\\t\\t// we know a previous exits somewhere under the children of this cluster\\n\\t\\t// we drill down to the right most leaf from the current cluster\\n\\t\\twhile (i < 31)\\n\\t\\t\\ti = (tree & 1ul << 2 * i + 2) > 0 ? 2 * i + 2 : 2 * i + 1;\\n\\t\\treturn i - 31; // translate the leaf index back to the value \\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539610,
                "title": "i-don-t-understand-their-expected-output",
                "content": "I don\\'t understand their expected output. \\n\\n```\\nInput: s = \"rat\"\\nOutput: \"art\"\\n```\\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm.\\n\\nI think it should be `arttra`. \\n\\n1. Pick the smallest character from s and append it to the result.\\n1. Pick the smallest character from s which is greater than the last appended character to the result and append it.\\n1. Repeat step 2 until you cannot pick more characters.\\n1. Pick the largest character from s and append it to the result.\\n1. Pick the largest character from s which is smaller than the last appended character to the result and append it.\\n1. Repeat step 5 until you cannot pick more characters.\\n1. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nAren\\'t they skipping step 4? What am I missing?",
                "solutionTags": [],
                "code": "```\\nInput: s = \"rat\"\\nOutput: \"art\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539132,
                "title": "java-beats-100-of-both-time-and-space",
                "content": "```\\npublic String sortString(String s) {\\n        StringBuilder res = new StringBuilder(s.length());\\n        int[] letterCount = new int[26];\\n        int sLength = s.length();\\n        \\n        // populate letter count array\\n        for(char c : s.toCharArray())\\n        {\\n            letterCount[c - \\'a\\']++;\\n        }\\n        \\n        while(sLength != 0)\\n        {\\n            // move forward and append characters to res\\n            for(int i=0; i<letterCount.length; i++)\\n            {\\n                if(letterCount[i] != 0)\\n                {\\n                    char c = (char) (\\'a\\' + i);\\n                    res.append(c);\\n                    letterCount[i]--;\\n                    sLength--;\\n                }\\n            }\\n            \\n            // move backwards and append characters to res\\n            for(int i=letterCount.length-1; i>=0; i--)\\n            {\\n                if(letterCount[i] != 0)\\n                {\\n                    char c = (char) (\\'a\\' + i);\\n                    res.append(c);\\n                    letterCount[i]--;\\n                    sLength--;\\n                }\\n            }\\n        }\\n        \\n        return res.toString();\\n    }",
                "solutionTags": [],
                "code": "```\\npublic String sortString(String s) {\\n        StringBuilder res = new StringBuilder(s.length());\\n        int[] letterCount = new int[26];\\n        int sLength = s.length();\\n        \\n        // populate letter count array\\n        for(char c : s.toCharArray())\\n        {\\n            letterCount[c - \\'a\\']++;\\n        }\\n        \\n        while(sLength != 0)\\n        {\\n            // move forward and append characters to res\\n            for(int i=0; i<letterCount.length; i++)\\n            {\\n                if(letterCount[i] != 0)\\n                {\\n                    char c = (char) (\\'a\\' + i);\\n                    res.append(c);\\n                    letterCount[i]--;\\n                    sLength--;\\n                }\\n            }\\n            \\n            // move backwards and append characters to res\\n            for(int i=letterCount.length-1; i>=0; i--)\\n            {\\n                if(letterCount[i] != 0)\\n                {\\n                    char c = (char) (\\'a\\' + i);\\n                    res.append(c);\\n                    letterCount[i]--;\\n                    sLength--;\\n                }\\n            }\\n        }\\n        \\n        return res.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 536868,
                "title": "rust-simple-solution-0ms",
                "content": "```Rust\\nimpl Solution {\\n    pub fn sort_string(s: String) -> String {\\n        let mut arr = vec![0; 26];\\n        for c in s.chars() {\\n            arr[c as usize - \\'a\\' as usize] += 1;\\n        }\\n        let mut res = String::from(\"\");\\n        let mut cter = s.len();\\n        let mut pivot = 0;\\n\\n        while cter > 0 {\\n            for i in 0..26 {\\n                let j = if pivot == 0 {i as usize} else {(25 - i) as usize};\\n                if arr[j] > 0 {\\n                    arr[j] -= 1;\\n                    res.push((j as u8 + 97) as char);\\n                    cter -= 1;\\n                }\\n            }\\n            pivot = 1 - pivot;\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn sort_string(s: String) -> String {\\n        let mut arr = vec![0; 26];\\n        for c in s.chars() {\\n            arr[c as usize - \\'a\\' as usize] += 1;\\n        }\\n        let mut res = String::from(\"\");\\n        let mut cter = s.len();\\n        let mut pivot = 0;\\n\\n        while cter > 0 {\\n            for i in 0..26 {\\n                let j = if pivot == 0 {i as usize} else {(25 - i) as usize};\\n                if arr[j] > 0 {\\n                    arr[j] -= 1;\\n                    res.push((j as u8 + 97) as char);\\n                    cter -= 1;\\n                }\\n            }\\n            pivot = 1 - pivot;\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3712679,
                "title": "89-java-solution-simple-and-easy-to-understand-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create int array for alphabets of length 26.\\n2. Put the character frequency by iterating the input string.\\n3. Run 2 loops (forward and reverse) and store the non zero number (character) in a string builder and decrement its frequency.\\n4. Convert and print the string.\\n\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[26];\\n\\n        for(int i=0; i<s.length(); i++){\\n            int index = s.charAt(i)-\\'a\\';\\n            arr[index] = arr[index]+1;\\n        }\\n\\n        // System.out.print(Arrays.toString(arr));\\n\\n        StringBuilder sb = new StringBuilder();\\n        while(sb.length() < s.length()){\\n        \\n        for(int i=0; i<26; i++){\\n            if (arr[i]>0){\\n                char ch = (char)(\\'a\\'+i);\\n                sb.append(ch);\\n                arr[i]--;\\n            }\\n        }\\n\\n        for(int i=25; i>=0; i--){\\n            if (arr[i]>0){\\n                char ch = (char)(\\'a\\'+i);\\n                sb.append(ch);\\n                arr[i]--;\\n            }\\n        }\\n\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[26];\\n\\n        for(int i=0; i<s.length(); i++){\\n            int index = s.charAt(i)-\\'a\\';\\n            arr[index] = arr[index]+1;\\n        }\\n\\n        // System.out.print(Arrays.toString(arr));\\n\\n        StringBuilder sb = new StringBuilder();\\n        while(sb.length() < s.length()){\\n        \\n        for(int i=0; i<26; i++){\\n            if (arr[i]>0){\\n                char ch = (char)(\\'a\\'+i);\\n                sb.append(ch);\\n                arr[i]--;\\n            }\\n        }\\n\\n        for(int i=25; i>=0; i--){\\n            if (arr[i]>0){\\n                char ch = (char)(\\'a\\'+i);\\n                sb.append(ch);\\n                arr[i]--;\\n            }\\n        }\\n\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306135,
                "title": "very-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] freq = new int[26];\\n        String ans = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            freq[ch]++;\\n        }\\n        while(ans.length() != s.length()){  \\n        for(int i = 0; i < freq.length; i++){\\n            if(freq[i] > 0){\\n               \\tchar c =(char) (i + \\'a\\');\\n                ans+= c;\\n                freq[i]--;\\n            }\\n        }\\n        for(int i = freq.length -1; i >= 0; i--){\\n            if(freq[i] > 0){\\n                char c =(char) (i + \\'a\\');\\n                ans+= c;\\n                freq[i]--;\\n            }\\n        }\\n     }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] freq = new int[26];\\n        String ans = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            freq[ch]++;\\n        }\\n        while(ans.length() != s.length()){  \\n        for(int i = 0; i < freq.length; i++){\\n            if(freq[i] > 0){\\n               \\tchar c =(char) (i + \\'a\\');\\n                ans+= c;\\n                freq[i]--;\\n            }\\n        }\\n        for(int i = freq.length -1; i >= 0; i--){\\n            if(freq[i] > 0){\\n                char c =(char) (i + \\'a\\');\\n                ans+= c;\\n                freq[i]--;\\n            }\\n        }\\n     }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456106,
                "title": "simple-to-understand-c-code-with-slight-explaination-0-ms-100-faster-code-o-26-n",
                "content": "Hint : Just store the frequency of each character in frequency array which will be in sorted order starting from a-z ,traverse 2 times one for increasing part and other for decreasing part till size is greater tha zero. \\n```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        int freq[26]={0};\\n        int n=s.size();\\n        for(int i=0 ; i<n ; i++)\\n            freq[s[i]-\\'a\\']++;\\n        string str=\"\";\\n        while(n>0)\\n        {\\n            for(int i=0 ; i<26 ; i++)\\n            {\\n                if(freq[i]>0)\\n                {\\n                    str+=(i+\\'a\\');\\n                    n--;\\n                    freq[i]--;\\n                }\\n            }\\n            for(int i=25 ; i>=0 ; i--)\\n            {\\n                if(freq[i]>0)\\n                {\\n                    str+=(i+\\'a\\');\\n                    n--;\\n                    freq[i]--;\\n                }\\n            }\\n                \\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        int freq[26]={0};\\n        int n=s.size();\\n        for(int i=0 ; i<n ; i++)\\n            freq[s[i]-\\'a\\']++;\\n        string str=\"\";\\n        while(n>0)\\n        {\\n            for(int i=0 ; i<26 ; i++)\\n            {\\n                if(freq[i]>0)\\n                {\\n                    str+=(i+\\'a\\');\\n                    n--;\\n                    freq[i]--;\\n                }\\n            }\\n            for(int i=25 ; i>=0 ; i--)\\n            {\\n                if(freq[i]>0)\\n                {\\n                    str+=(i+\\'a\\');\\n                    n--;\\n                    freq[i]--;\\n                }\\n            }\\n                \\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075223,
                "title": "simple-python3-solution-with-string-list-manipulation",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        \\n        A = [a for a in s]\\n        \\n        res = []\\n        while len(A)>0:            \\n            M=list(set(A))\\n            M.sort()        # Unique characters of (remaining) string, sorted\\n    \\n            # Pick smallest->largest\\n            for c in M:\\n                res.append(c)\\n                A.remove(c)\\n\\n            # Check if something is left from the original string (list)\\n            M = list(set(A))\\n            M.sort()\\n\\n            # Pick largest->smallest from what\\'s left\\n            for c in M[::-1]:\\n                res.append(c)\\n                A.remove(c)\\n\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        \\n        A = [a for a in s]\\n        \\n        res = []\\n        while len(A)>0:            \\n            M=list(set(A))\\n            M.sort()        # Unique characters of (remaining) string, sorted\\n    \\n            # Pick smallest->largest\\n            for c in M:\\n                res.append(c)\\n                A.remove(c)\\n\\n            # Check if something is left from the original string (list)\\n            M = list(set(A))\\n            M.sort()\\n\\n            # Pick largest->smallest from what\\'s left\\n            for c in M[::-1]:\\n                res.append(c)\\n                A.remove(c)\\n\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055818,
                "title": "java-2ms-100-time-70-space-well-explained-with-comments",
                "content": "```\\npublic String sortString(String s) {\\n       //first initialising i with length of the string\\n        int i=s.length();\\n\\t\\t//String builder to get  the result and for appending characters\\n        StringBuilder d=new StringBuilder();\\n\\t\\t//initialising counter array to count the characters and its length is 26 because  only lower case letters\\n        int[] ar=new int[26];\\n\\t\\t//increasing the count for each character in s\\n        for(int j=0;j<i;j++){\\n            ar[s.charAt(j)-\\'a\\']++;\\n        }\\n\\t\\t//Using while loop to check whether i > 0 so that String s has characters\\n        while(i>0){\\n\\t\\t//first of all appending all characters available in s(ascending order)  to d and decrementing the count and also i\\n            for(int j=0;j<26;j++){\\n                if(ar[j]>0){\\n                d.append((char)(\\'a\\'+j));\\n                    ar[j]--;\\n                    i--;\\n                    }\\n            }\\n\\t\\t\\t//then in descending order until i becomes zero this while loop goes\\n            for(int j=25;j>=0;j--){\\n                if(ar[j]>0){\\n                d.append((char)(\\'a\\'+j));\\n                    ar[j]--;\\n                    i--;\\n                    }\\n            }\\n        }\\n\\t\\t//converting String Builder to String\\n        return d.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\npublic String sortString(String s) {\\n       //first initialising i with length of the string\\n        int i=s.length();\\n\\t\\t//String builder to get  the result and for appending characters\\n        StringBuilder d=new StringBuilder();\\n\\t\\t//initialising counter array to count the characters and its length is 26 because  only lower case letters\\n        int[] ar=new int[26];\\n\\t\\t//increasing the count for each character in s\\n        for(int j=0;j<i;j++){\\n            ar[s.charAt(j)-\\'a\\']++;\\n        }\\n\\t\\t//Using while loop to check whether i > 0 so that String s has characters\\n        while(i>0){\\n\\t\\t//first of all appending all characters available in s(ascending order)  to d and decrementing the count and also i\\n            for(int j=0;j<26;j++){\\n                if(ar[j]>0){\\n                d.append((char)(\\'a\\'+j));\\n                    ar[j]--;\\n                    i--;\\n                    }\\n            }\\n\\t\\t\\t//then in descending order until i becomes zero this while loop goes\\n            for(int j=25;j>=0;j--){\\n                if(ar[j]>0){\\n                d.append((char)(\\'a\\'+j));\\n                    ar[j]--;\\n                    i--;\\n                    }\\n            }\\n        }\\n\\t\\t//converting String Builder to String\\n        return d.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036224,
                "title": "python-solution",
                "content": "\\th = collections.Counter(s)\\n\\tkeys = sorted(h.keys())\\n\\tresult = \"\"\\n\\twhile h:\\n\\t\\tfor k in keys:\\n\\t\\t\\tif h[k]:\\n\\t\\t\\t\\tresult += k\\n\\t\\t\\t\\th[k] -= 1\\n\\t\\t\\t\\tif h[k] == 0:\\n\\t\\t\\t\\t\\tdel h[k]\\n\\t\\tkeys = keys[::-1]\\n\\treturn result",
                "solutionTags": [],
                "code": "\\th = collections.Counter(s)\\n\\tkeys = sorted(h.keys())\\n\\tresult = \"\"\\n\\twhile h:\\n\\t\\tfor k in keys:\\n\\t\\t\\tif h[k]:\\n\\t\\t\\t\\tresult += k\\n\\t\\t\\t\\th[k] -= 1\\n\\t\\t\\t\\tif h[k] == 0:\\n\\t\\t\\t\\t\\tdel h[k]\\n\\t\\tkeys = keys[::-1]\\n\\treturn result",
                "codeTag": "Unknown"
            },
            {
                "id": 691395,
                "title": "c-char-counter-table",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n\\n        int char_counter[26] = {0};\\n        for(auto& c : s) ++char_counter[c-\\'a\\'];\\n\\n        int count=0;\\n        while(count < s.size()) {\\n            for(int i=0; i<26; ++i) {\\n                if(char_counter[i]-- > 0) s[count++] = i+\\'a\\';\\n            }\\n\\n            for(int i=26-1; i>=0; --i) {\\n                if(char_counter[i]-- > 0) s[count++] = i+\\'a\\';\\n            }\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n\\n        int char_counter[26] = {0};\\n        for(auto& c : s) ++char_counter[c-\\'a\\'];\\n\\n        int count=0;\\n        while(count < s.size()) {\\n            for(int i=0; i<26; ++i) {\\n                if(char_counter[i]-- > 0) s[count++] = i+\\'a\\';\\n            }\\n\\n            for(int i=26-1; i>=0; --i) {\\n                if(char_counter[i]-- > 0) s[count++] = i+\\'a\\';\\n            }\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652758,
                "title": "easy-python",
                "content": "class Solution:\\n    def sortString(self, s: str) -> str:\\n        l=sorted(set(s))\\n        out=\\'\\'\\n        ls=list(s)\\n        while ls:\\n            for i in l:\\n                if i in ls:\\n                    out+=i\\n                    ls.remove(i)\\n            for i in l[::-1]:\\n                if i in ls:\\n                    out+=i\\n                    ls.remove(i)\\n        return out\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def sortString(self, s: str) -> str:\\n        l=sorted(set(s))\\n        out=\\'\\'\\n        ls=list(s)\\n        while ls:\\n            for i in l:\\n                if i in ls:\\n                    out+=i\\n                    ls.remove(i)\\n            for i in l[::-1]:\\n                if i in ls:\\n                    out+=i\\n                    ls.remove(i)\\n        return out\\n",
                "codeTag": "Java"
            },
            {
                "id": 619428,
                "title": "java-fast-solution-based-on-the-solutions-of-others-thank-you",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder charString = new StringBuilder(s.length());\\n        int[] charFrequency = new int[26];\\n        int charCount = 0;\\n        \\n        // store the frequency with which characters appear in s into an array  \\n        // sized to hold all lowercase letters\\n        for (int i = 0; i < s.length(); i++) {\\n            charFrequency[s.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        while (charCount < s.length()) {\\n            // add characters to result in ascending order\\n            for (int j = 0; j < 26; j++) {\\n                if (charFrequency[j] > 0) {\\n                    charString.append((char)(j + \\'a\\'));\\n                    charFrequency[j] = charFrequency[j] - 1;\\n                    charCount++;\\n                }\\n            }\\n            //add characters to result in descending order\\n            for (int k = 25; k >=0; k--) {\\n                if (charFrequency[k] > 0) {\\n                    charString.append((char)(k + \\'a\\'));\\n                    charFrequency[k] = charFrequency[k] - 1;\\n                    charCount++;\\n                }\\n            }\\n        }\\n        return charString.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder charString = new StringBuilder(s.length());\\n        int[] charFrequency = new int[26];\\n        int charCount = 0;\\n        \\n        // store the frequency with which characters appear in s into an array  \\n        // sized to hold all lowercase letters\\n        for (int i = 0; i < s.length(); i++) {\\n            charFrequency[s.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        while (charCount < s.length()) {\\n            // add characters to result in ascending order\\n            for (int j = 0; j < 26; j++) {\\n                if (charFrequency[j] > 0) {\\n                    charString.append((char)(j + \\'a\\'));\\n                    charFrequency[j] = charFrequency[j] - 1;\\n                    charCount++;\\n                }\\n            }\\n            //add characters to result in descending order\\n            for (int k = 25; k >=0; k--) {\\n                if (charFrequency[k] > 0) {\\n                    charString.append((char)(k + \\'a\\'));\\n                    charFrequency[k] = charFrequency[k] - 1;\\n                    charCount++;\\n                }\\n            }\\n        }\\n        return charString.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584184,
                "title": "python3-very-simple-no-sorting",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        freq = [0] * 26\\n        for ch in s:\\n            freq[ord(ch) - ord(\\'a\\')] += 1\\n        ret = \\'\\'\\n        a = ord(\\'a\\')\\n        while len(ret) < len(s):\\n            i = 0\\n            while i < 26:\\n                if freq[i]:\\n                    ret += chr(i + a)\\n                    freq[i] -= 1\\n                i += 1\\n            i = 25\\n            while i > -1:\\n                if freq[i]:\\n                    ret += chr(i + a)\\n                    freq[i] -= 1\\n                i -= 1\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        freq = [0] * 26\\n        for ch in s:\\n            freq[ord(ch) - ord(\\'a\\')] += 1\\n        ret = \\'\\'\\n        a = ord(\\'a\\')\\n        while len(ret) < len(s):\\n            i = 0\\n            while i < 26:\\n                if freq[i]:\\n                    ret += chr(i + a)\\n                    freq[i] -= 1\\n                i += 1\\n            i = 25\\n            while i > -1:\\n                if freq[i]:\\n                    ret += chr(i + a)\\n                    freq[i] -= 1\\n                i -= 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542686,
                "title": "1370-multiline-javascript-solution",
                "content": "Typically I\\'m offering a \"regex solution\" or \"recursive solution\" or \"1-line solution\", and often a combination of those, but I think this is a pretty good solution with regards to runtime.\\n\\n> Runtime: **64 ms**, faster than *92.70%* of JavaScript online submissions\\n> Memory Usage: **37.4 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```javascript\\nconst sortString = s => {\\n  const cnts = new Array(26).fill(0);\\n  for (let i = 0; i < s.length; i++) cnts[s.charCodeAt(i) - 97]++;\\n  const res = new Array(Math.max(...cnts)).fill(\\'\\');\\n  for (let i = 0; i < 26; i++)\\n    for (let j = 0; j < cnts[i]; j++)\\n      if (0 === j % 2) res[j] += String.fromCharCode(i + 97);\\n      else res[j] = String.fromCharCode(i + 97) + res[j];\\n  return res.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst sortString = s => {\\n  const cnts = new Array(26).fill(0);\\n  for (let i = 0; i < s.length; i++) cnts[s.charCodeAt(i) - 97]++;\\n  const res = new Array(Math.max(...cnts)).fill(\\'\\');\\n  for (let i = 0; i < 26; i++)\\n    for (let j = 0; j < cnts[i]; j++)\\n      if (0 === j % 2) res[j] += String.fromCharCode(i + 97);\\n      else res[j] = String.fromCharCode(i + 97) + res[j];\\n  return res.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539522,
                "title": "clean-python-code",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        answer, ct, increase = [], Counter(s), True\\n        ordered_chars = sorted(set(s))\\n        while ct:\\n            tmp = []\\n            for char in ordered_chars:\\n                if ct[char] > 0:\\n                    tmp.append(char)\\n                    ct[char] -= 1\\n                else:\\n                    del ct[char]\\n            if not increase:\\n                tmp.reverse()\\n            answer.extend(tmp)\\n            increase = not increase\\n        return \\'\\'.join(answer)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        answer, ct, increase = [], Counter(s), True\\n        ordered_chars = sorted(set(s))\\n        while ct:\\n            tmp = []\\n            for char in ordered_chars:\\n                if ct[char] > 0:\\n                    tmp.append(char)\\n                    ct[char] -= 1\\n                else:\\n                    del ct[char]\\n            if not increase:\\n                tmp.reverse()\\n            answer.extend(tmp)\\n            increase = not increase\\n        return \\'\\'.join(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531863,
                "title": "python-heap",
                "content": "```\\nimport heapq\\nfrom collections import Counter\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        ctr =Counter(s)\\n        res , temp  =[] , []\\n        for k , v in ctr.items():\\n            heapq.heappush(res , (ord(k) , k , v))\\n        result = \"\"\\n        while res:\\n            while res:\\n                cur_val , cur , count = heapq.heappop(res)\\n                result+=cur\\n                if count -1 > 0:\\n                    heapq.heappush(temp , (-cur_val , cur , count-1))\\n            while temp:\\n                cur_val , cur , count = heapq.heappop(temp)\\n                result+=cur\\n                if count -1 > 0:\\n                    heapq.heappush(res , (-cur_val , cur , count-1))\\n        return result",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nfrom collections import Counter\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        ctr =Counter(s)\\n        res , temp  =[] , []\\n        for k , v in ctr.items():\\n            heapq.heappush(res , (ord(k) , k , v))\\n        result = \"\"\\n        while res:\\n            while res:\\n                cur_val , cur , count = heapq.heappop(res)\\n                result+=cur\\n                if count -1 > 0:\\n                    heapq.heappush(temp , (-cur_val , cur , count-1))\\n            while temp:\\n                cur_val , cur , count = heapq.heappop(temp)\\n                result+=cur\\n                if count -1 > 0:\\n                    heapq.heappush(res , (-cur_val , cur , count-1))\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 531851,
                "title": "c-intuitive-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    string sortString(string s) \\n    {\\n        string result=\"\";\\n        int a[26];\\n        memset(a,0,sizeof(a));\\n        for(int i=0;i<s.length();i++) //counts of each alphabet\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        while(true)\\n        {\\n            int flag=0;\\n            for(int i=0;i<26;i++) //from smallest to largest\\n            {\\n                if(a[i]>0)\\n                {\\n                    result+=(char)(i+\\'a\\');\\n                    a[i]--;\\n                    flag=1;\\n                }\\n            }\\n            for(int i=25;i>-1;i--) //from largest to smallest\\n            {\\n                if(a[i]>0)\\n                {\\n                    result+=(char)(i+\\'a\\');\\n                    a[i]--;\\n                    flag=1;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    string sortString(string s) \\n    {\\n        string result=\"\";\\n        int a[26];\\n        memset(a,0,sizeof(a));\\n        for(int i=0;i<s.length();i++) //counts of each alphabet\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        while(true)\\n        {\\n            int flag=0;\\n            for(int i=0;i<26;i++) //from smallest to largest\\n            {\\n                if(a[i]>0)\\n                {\\n                    result+=(char)(i+\\'a\\');\\n                    a[i]--;\\n                    flag=1;\\n                }\\n            }\\n            for(int i=25;i>-1;i--) //from largest to smallest\\n            {\\n                if(a[i]>0)\\n                {\\n                    result+=(char)(i+\\'a\\');\\n                    a[i]--;\\n                    flag=1;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531832,
                "title": "java-maintain-a-count-array",
                "content": "```\\nclass Solution {\\n    public static boolean check(int[] arr) {\\n        for(int i = 0; i < 26; i++) if(arr[i] != 0) return true;\\n        return false;\\n    }\\n    public String sortString(String s) {\\n        int n = s.length();\\n        int[] arr = new int[26];\\n        StringBuilder res = new StringBuilder();\\n        for(int i = 0; i < n; i++) arr[s.charAt(i) - \\'a\\']++;\\n        while(check(arr)) {\\n            for(int i = 0; i < 26; i++) {\\n                if(arr[i] > 0) {\\n                    arr[i]--;\\n                    res.append((char)(i + 97));\\n                } \\n            }\\n            for(int i = 25; i > -1; i--) {\\n                if(arr[i] > 0) {\\n                    arr[i]--;\\n                    res.append((char)(i + 97));\\n                } \\n            }\\n        }\\n        return res.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static boolean check(int[] arr) {\\n        for(int i = 0; i < 26; i++) if(arr[i] != 0) return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3581355,
                "title": "simple-java-solution-count-array",
                "content": "# Code\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] alpha = new int[27];\\n        for(char ch : s.toCharArray())\\n        {\\n            alpha[ch-\\'a\\']++;\\n        }\\n        String result = \"\";\\n        boolean flag = false;\\n        while(flag!=true)\\n        {\\n            flag = true;\\n            for(int i = 0;i<27;i++)\\n            {\\n                if(alpha[i]!=0)\\n                {\\n                    result = result+(char)(i+97);\\n                    alpha[i]--;\\n                    flag = false;\\n                }\\n            }\\n            flag = true;\\n            for(int j = 26;j>=0;j--)\\n            {\\n                if(alpha[j]!=0)\\n                {\\n                    result = result+(char)(j+97);\\n                    alpha[j]--;\\n                    flag = false;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Counting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] alpha = new int[27];\\n        for(char ch : s.toCharArray())\\n        {\\n            alpha[ch-\\'a\\']++;\\n        }\\n        String result = \"\";\\n        boolean flag = false;\\n        while(flag!=true)\\n        {\\n            flag = true;\\n            for(int i = 0;i<27;i++)\\n            {\\n                if(alpha[i]!=0)\\n                {\\n                    result = result+(char)(i+97);\\n                    alpha[i]--;\\n                    flag = false;\\n                }\\n            }\\n            flag = true;\\n            for(int j = 26;j>=0;j--)\\n            {\\n                if(alpha[j]!=0)\\n                {\\n                    result = result+(char)(j+97);\\n                    alpha[j]--;\\n                    flag = false;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142843,
                "title": "python-using-dict-beats-95",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a frequency map of s.\\n\\nIterate over all the letters of s in sorted manner and add that character to result .\\n\\nRepeat above step but for reversed string.\\n \\nIf the frequency becomes 0 then we delete the key from dict.\\n\\n# Code\\n```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        freq = {}\\n        letters = sorted(set(s))\\n        res = \"\"\\n        for i in s:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i] = 1\\n        while freq:\\n            for i in letters:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n            for i in letters[::-1]:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        freq = {}\\n        letters = sorted(set(s))\\n        res = \"\"\\n        for i in s:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i] = 1\\n        while freq:\\n            for i in letters:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n            for i in letters[::-1]:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924562,
                "title": "increasing-decreasing-string-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int len = s.length();\\n        int[] freq = new int[26];\\n        for (int i = 0; i < len; i++) {\\n            freq[s.charAt(i) - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        while (count < len) {\\n            for (int i = 0; i < 26; i++) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i]--;\\n                    count++;\\n                }\\n            }\\n\\n            for (int i = 25; i >= 0; i--) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i]--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int len = s.length();\\n        int[] freq = new int[26];\\n        for (int i = 0; i < len; i++) {\\n            freq[s.charAt(i) - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        while (count < len) {\\n            for (int i = 0; i < 26; i++) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i]--;\\n                    count++;\\n                }\\n            }\\n\\n            for (int i = 25; i >= 0; i--) {\\n                if (freq[i] > 0) {\\n                    sb.append((char) (i + \\'a\\'));\\n                    freq[i]--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685000,
                "title": "js-easy-solution-with-hashmap",
                "content": "```\\nvar sortString = function(s) {\\n    const hashmap = {};\\n    let output = \\'\\';\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        const code = s.charCodeAt(i);\\n        if (!hashmap[code]) {\\n            hashmap[code] = 1;\\n        } else {\\n            hashmap[code]++;\\n        }\\n    }\\n    const temp = Object.entries(hashmap);\\n    let cursor = 0;\\n    let direction = 1;\\n\\n    while (output.length < s.length && temp.length) {\\n        output += String.fromCharCode(temp[cursor][0]);\\n        if (temp[cursor][1] > 1) {\\n            temp[cursor][1]--;\\n        } else {\\n            temp.splice(cursor, 1);\\n            cursor = cursor + (direction === 1 ? -1 : 0);\\n        }\\n        cursor += direction;\\n        if (cursor === -1 || cursor === temp.length) {\\n            direction = -direction;\\n            cursor += direction;\\n        }\\n    }\\n\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortString = function(s) {\\n    const hashmap = {};\\n    let output = \\'\\';\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        const code = s.charCodeAt(i);\\n        if (!hashmap[code]) {\\n            hashmap[code] = 1;\\n        } else {\\n            hashmap[code]++;\\n        }\\n    }\\n    const temp = Object.entries(hashmap);\\n    let cursor = 0;\\n    let direction = 1;\\n\\n    while (output.length < s.length && temp.length) {\\n        output += String.fromCharCode(temp[cursor][0]);\\n        if (temp[cursor][1] > 1) {\\n            temp[cursor][1]--;\\n        } else {\\n            temp.splice(cursor, 1);\\n            cursor = cursor + (direction === 1 ? -1 : 0);\\n        }\\n        cursor += direction;\\n        if (cursor === -1 || cursor === temp.length) {\\n            direction = -direction;\\n            cursor += direction;\\n        }\\n    }\\n\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545454,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        \\n        //count the frequency of each character\\n        int[] freq = new int[26];\\n        for(int i = 0; i < s.length(); i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            freq[ch]++;\\n        }\\n \\n        String ans = \"\";\\n        \\n        //loop until both the answer string and given string\\'s lengths are same\\n        while(ans.length() != s.length()){  \\n        \\n            //loop over a to z\\n        for(int i = 0; i < freq.length; i++){\\n            if(freq[i] > 0){\\n               \\tchar c =(char) (i + \\'a\\');\\n                ans+= c;\\n                freq[i]--;\\n            }\\n        }\\n        \\n        //loop over z to a\\n        for(int i = freq.length -1; i >= 0; i--){\\n            if(freq[i] > 0){\\n                char c =(char) (i + \\'a\\');\\n                ans+= c;\\n                freq[i]--;\\n            }\\n        }\\n     }\\n        return ans;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        \\n        //count the frequency of each character\\n        int[] freq = new int[26];\\n        for(int i = 0; i < s.length(); i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            freq[ch]++;\\n        }\\n \\n        String ans = \"\";\\n        \\n        //loop until both the answer string and given string\\'s lengths are same\\n        while(ans.length() != s.length()){  \\n        \\n            //loop over a to z\\n        for(int i = 0; i < freq.length; i++){\\n            if(freq[i] > 0){\\n               \\tchar c =(char) (i + \\'a\\');\\n                ans+= c;\\n                freq[i]--;\\n            }\\n        }\\n        \\n        //loop over z to a\\n        for(int i = freq.length -1; i >= 0; i--){\\n            if(freq[i] > 0){\\n                char c =(char) (i + \\'a\\');\\n                ans+= c;\\n                freq[i]--;\\n            }\\n        }\\n     }\\n        return ans;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050081,
                "title": "python-o-n-easy-alphabet-solution",
                "content": "**Python:**\\n```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        result = []\\n        chars = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        while s:\\n            for c in chars:\\n                if c in s:\\n                    result.append(c)\\n                    s = s.replace(c,\\'\\',1)\\n                else:\\n                    chars = chars.replace(c,\\'\\')\\n            chars = chars[::-1]\\n        return \\'\\'.join(result)\\n```\\n\\n\\n**Complexity:**\\nTime:   O(n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        result = []\\n        chars = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        while s:\\n            for c in chars:\\n                if c in s:\\n                    result.append(c)\\n                    s = s.replace(c,\\'\\',1)\\n                else:\\n                    chars = chars.replace(c,\\'\\')\\n            chars = chars[::-1]\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971174,
                "title": "c-explained-easy-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        \\n        map<char,int> m;  // to store the frequency of character        \\n        int count=0; // to count total  number of character or we can use s.size()\\n        \\n        //store the values in map         \\n        for(auto i:s){\\n            m[i]++;\\n            count++;\\n        }\\n   \\n        \\n        string ans=\"\"; // ans to return\\n        while(count){\\n            \\n            // increasing order\\n            for(auto i:m){\\n                if(i.second!=0 && count!=0){\\n                    m[i.first]--;\\n                    ans+=i.first;   //add character to ans \\n                    count--;\\n                }\\n            }\\n            \\n            // decreasing order\\n            for(auto it=m.rbegin();it!=m.rend();it++){\\n                if(it->second!=0 && count!=0){\\n                    m[it->first]--;\\n                    ans+=it->first; // add character to ans\\n                    count--;\\n                }\\n            }\\n        }\\n        return ans; // return final ans\\n    }\\n    \\n};\\n```\\n**Please Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        \\n        map<char,int> m;  // to store the frequency of character        \\n        int count=0; // to count total  number of character or we can use s.size()\\n        \\n        //store the values in map         \\n        for(auto i:s){\\n            m[i]++;\\n            count++;\\n        }\\n   \\n        \\n        string ans=\"\"; // ans to return\\n        while(count){\\n            \\n            // increasing order\\n            for(auto i:m){\\n                if(i.second!=0 && count!=0){\\n                    m[i.first]--;\\n                    ans+=i.first;   //add character to ans \\n                    count--;\\n                }\\n            }\\n            \\n            // decreasing order\\n            for(auto it=m.rbegin();it!=m.rend();it++){\\n                if(it->second!=0 && count!=0){\\n                    m[it->first]--;\\n                    ans+=it->first; // add character to ans\\n                    count--;\\n                }\\n            }\\n        }\\n        return ans; // return final ans\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832912,
                "title": "java-easy-to-understand-solution-using-treemap",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int n = s.length();\\n        TreeMap<Character,Integer> map = new TreeMap<>();\\n        for(char ch : s.toCharArray()){\\n            map.put(ch , map.getOrDefault(ch,0)+1);\\n        }\\n        StringBuilder ans=new StringBuilder();\\n        \\n        while( n > 0 ){\\n            \\n            for(char ch:map.keySet()){\\n                if(map.get(ch) > 0){\\n                  ans.append(ch);\\n                  map.put(ch,map.get(ch)-1);\\n                  n--;\\n                }\\n            }\\n            \\n            StringBuilder rev = new StringBuilder();\\n            \\n            for(char ch:map.keySet()){\\n               if(map.get(ch) > 0){\\n                  rev.append(ch);\\n                  map.put(ch,map.get(ch)-1);\\n                  n--;\\n                }\\n             }\\n            ans.append(rev.reverse());\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int n = s.length();\\n        TreeMap<Character,Integer> map = new TreeMap<>();\\n        for(char ch : s.toCharArray()){\\n            map.put(ch , map.getOrDefault(ch,0)+1);\\n        }\\n        StringBuilder ans=new StringBuilder();\\n        \\n        while( n > 0 ){\\n            \\n            for(char ch:map.keySet()){\\n                if(map.get(ch) > 0){\\n                  ans.append(ch);\\n                  map.put(ch,map.get(ch)-1);\\n                  n--;\\n                }\\n            }\\n            \\n            StringBuilder rev = new StringBuilder();\\n            \\n            for(char ch:map.keySet()){\\n               if(map.get(ch) > 0){\\n                  rev.append(ch);\\n                  map.put(ch,map.get(ch)-1);\\n                  n--;\\n                }\\n             }\\n            ans.append(rev.reverse());\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690192,
                "title": "c-easy-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        map<char, int>mpp;\\n        string ans=\"\";\\n        for(int i=0; i<s.length(); i++){\\n            mpp[s[i]]++;\\n        }\\n        \\n        map<char, int>::iterator itr;\\n        map<char, int>::reverse_iterator it;\\n        \\n        while(s.size() != ans.size()){\\n            for(itr = mpp.begin(); itr != mpp.end(); ++itr){\\n                if(itr->second>0){\\n                    ans+=itr->first;\\n                }\\n                itr->second--;\\n            }\\n            \\n            for (it = mpp.rbegin(); it != mpp.rend(); it++){\\n                if(it->second>0){\\n                    ans+=it->first;\\n                }\\n                it->second--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        map<char, int>mpp;\\n        string ans=\"\";\\n        for(int i=0; i<s.length(); i++){\\n            mpp[s[i]]++;\\n        }\\n        \\n        map<char, int>::iterator itr;\\n        map<char, int>::reverse_iterator it;\\n        \\n        while(s.size() != ans.size()){\\n            for(itr = mpp.begin(); itr != mpp.end(); ++itr){\\n                if(itr->second>0){\\n                    ans+=itr->first;\\n                }\\n                itr->second--;\\n            }\\n            \\n            for (it = mpp.rbegin(); it != mpp.rend(); it++){\\n                if(it->second>0){\\n                    ans+=it->first;\\n                }\\n                it->second--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607654,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        int count[26]={0};\\n        string ans=\"\";\\n        // first of all store the frequency in the array\\n        for(int i=0;i<s.length();i++) {\\n            count[s[i]-\\'a\\']++;\\n        }\\n        while(true) {\\n            bool found=false;\\n            // move from \\'a\\' to \\'z\\' and append if ith character if present\\n            for(int i=0;i<26;i++) {\\n                if(count[i]>0) {\\n                    found=true;\\n                    ans.push_back(\\'a\\'+i);\\n                    count[i]--;\\n                }\\n            }\\n            // if all the characters are used then terminate\\n            if(!found) {\\n                break;\\n            }\\n            found=false;\\n            // similarly move in the backward direction and append the characters\\n            for(int i=25;i>=0;i--) {\\n                if(count[i]>0) {\\n                    found=true;\\n                    ans.push_back(\\'a\\'+i);\\n                    count[i]--;\\n                }\\n            }\\n            // if all the characters are used then terminate\\n            if(!found) {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        int count[26]={0};\\n        string ans=\"\";\\n        // first of all store the frequency in the array\\n        for(int i=0;i<s.length();i++) {\\n            count[s[i]-\\'a\\']++;\\n        }\\n        while(true) {\\n            bool found=false;\\n            // move from \\'a\\' to \\'z\\' and append if ith character if present\\n            for(int i=0;i<26;i++) {\\n                if(count[i]>0) {\\n                    found=true;\\n                    ans.push_back(\\'a\\'+i);\\n                    count[i]--;\\n                }\\n            }\\n            // if all the characters are used then terminate\\n            if(!found) {\\n                break;\\n            }\\n            found=false;\\n            // similarly move in the backward direction and append the characters\\n            for(int i=25;i>=0;i--) {\\n                if(count[i]>0) {\\n                    found=true;\\n                    ans.push_back(\\'a\\'+i);\\n                    count[i]--;\\n                }\\n            }\\n            // if all the characters are used then terminate\\n            if(!found) {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467385,
                "title": "java-o-n-clean-simple-solution-no-auxiliary-ds",
                "content": "**Hit the UPVOTE! :) Thankyou <3**\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        \\n        StringBuilder temp = new StringBuilder(s);\\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(temp.length() != 0){\\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                int index = temp.indexOf(c+\"\");\\n                if(index != -1){\\n                    sb.append(c);\\n                    temp.deleteCharAt(index);\\n                }\\n               \\n            }\\n            for(char c=\\'z\\';c>=\\'a\\';c--){\\n                int index = temp.indexOf(c+\"\");\\n                if(index != -1){\\n                    sb.append(c);\\n                    temp.deleteCharAt(index);\\n                }               \\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        \\n        StringBuilder temp = new StringBuilder(s);\\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(temp.length() != 0){\\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                int index = temp.indexOf(c+\"\");\\n                if(index != -1){\\n                    sb.append(c);\\n                    temp.deleteCharAt(index);\\n                }\\n               \\n            }\\n            for(char c=\\'z\\';c>=\\'a\\';c--){\\n                int index = temp.indexOf(c+\"\");\\n                if(index != -1){\\n                    sb.append(c);\\n                    temp.deleteCharAt(index);\\n                }               \\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449868,
                "title": "java-solution-simple-use-of-hashmap-with-explanation",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n            HashMap<Character, Integer> map= new HashMap<>();\\n             StringBuilder sb= new StringBuilder();\\n            \\n            //Count the frequency of each character.\\n        for(char ch: s.toCharArray())\\n            map.put(ch, map.getOrDefault(ch,0)+1);  \\n            \\n                 //Repeat until the frequency of all characters becomes zero\\n            while(map.size()>0){\\n                    //Loop over all character from \\'a\\' to \\'z\\' \\n               for(int i=0; i<26; i++){\\n                    char ch= (char)(97+i);\\n                    //append the character if it exists \\n                    if(map.containsKey(ch)) {\\n                            sb.append(ch);\\n                    //and decrease frequency by 1\\n                      map.put(ch, map.get(ch)-1);\\n                       if(map.get(ch)==0) \\n                               map.remove(ch);     \\n                    }\\n               } \\n                    //Loop over all character from \\'z\\' to \\'a\\' \\n               for(int i=25; i>=0; i--){\\n                    char ch= (char)(97+i);\\n                    //append the character if it exists \\n                    if(map.containsKey(ch)) {\\n                            sb.append(ch);\\n                    //and decrease frequency by 1\\n                      map.put(ch, map.get(ch)-1);\\n                       if(map.get(ch)==0)\\n                               map.remove(ch);     \\n                    } \\n               }\\n            }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n            HashMap<Character, Integer> map= new HashMap<>();\\n             StringBuilder sb= new StringBuilder();\\n            \\n            //Count the frequency of each character.\\n        for(char ch: s.toCharArray())\\n            map.put(ch, map.getOrDefault(ch,0)+1);  \\n            \\n                 //Repeat until the frequency of all characters becomes zero\\n            while(map.size()>0){\\n                    //Loop over all character from \\'a\\' to \\'z\\' \\n               for(int i=0; i<26; i++){\\n                    char ch= (char)(97+i);\\n                    //append the character if it exists \\n                    if(map.containsKey(ch)) {\\n                            sb.append(ch);\\n                    //and decrease frequency by 1\\n                      map.put(ch, map.get(ch)-1);\\n                       if(map.get(ch)==0) \\n                               map.remove(ch);     \\n                    }\\n               } \\n                    //Loop over all character from \\'z\\' to \\'a\\' \\n               for(int i=25; i>=0; i--){\\n                    char ch= (char)(97+i);\\n                    //append the character if it exists \\n                    if(map.containsKey(ch)) {\\n                            sb.append(ch);\\n                    //and decrease frequency by 1\\n                      map.put(ch, map.get(ch)-1);\\n                       if(map.get(ch)==0)\\n                               map.remove(ch);     \\n                    } \\n               }\\n            }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425674,
                "title": "easy-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] count = new int[26];\\n        for (char ch : s.toCharArray()) {\\n            count[ch - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int length = s.length();\\n        while (length > 0) {\\n            for (int i = 0; i < 26; i++) {\\n                if (count[i] > 0) {\\n                    count[i]--;\\n                    sb.append((char) (i + \\'a\\'));\\n                    length--;\\n                }\\n            }\\n            for (int i = 25; i >= 0; i--) {\\n                if (count[i] > 0) {\\n                    count[i]--;\\n                    sb.append((char) (i + \\'a\\'));\\n                    length--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\nfeel free to ask any questions",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] count = new int[26];\\n        for (char ch : s.toCharArray()) {\\n            count[ch - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int length = s.length();\\n        while (length > 0) {\\n            for (int i = 0; i < 26; i++) {\\n                if (count[i] > 0) {\\n                    count[i]--;\\n                    sb.append((char) (i + \\'a\\'));\\n                    length--;\\n                }\\n            }\\n            for (int i = 25; i >= 0; i--) {\\n                if (count[i] > 0) {\\n                    count[i]--;\\n                    sb.append((char) (i + \\'a\\'));\\n                    length--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202746,
                "title": "100-in-java-easy-to-understand",
                "content": "class Solution {\\n    public String sortString(String s) {\\n        int[] count = new int[26];\\n        for(char c : s.toCharArray()){\\n            count[c - 97]++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(s.length() != sb.length()){\\n            Solution.addlth(sb, count);\\n            Solution.addhtl(sb, count);\\n        }\\n        return sb.toString();\\n        \\n    \\n    }\\n    static void addlth(StringBuilder ss, int[] count){\\n        for(int i = 0; i < 26; ++i){\\n            if(count[i] > 0){\\n                ss.append((char)(i+97));\\n                count[i] -= 1;\\n            }\\n        }\\n    }\\n    static void addhtl(StringBuilder ss, int[] count){\\n        for(int i = 25; i >= 0; --i){\\n            if(count[i] > 0){\\n                ss.append((char)(i+97));\\n                count[i] -= 1;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String sortString(String s) {\\n        int[] count = new int[26];\\n        for(char c : s.toCharArray()){\\n            count[c - 97]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1148395,
                "title": "simple-o-n-c",
                "content": "```\\nstring sortString(string s) {\\n        vector<int>da(26,0);\\n        int  cnt=0;\\n        string  ans;\\n        for(auto i:s)\\n        {   \\n            da[i-\\'a\\']++;\\n            cnt++;\\n        }\\n        while(cnt)\\n        {\\n            for(int i=0;i<=25;i++)\\n            {\\n                if(da[i])\\n                {\\n                    da[i]--;\\n                    ans+=\\'a\\'+i;\\n                    cnt--;\\n                }\\n            }\\n            for(int i=25;i>=0;i--)\\n            {\\n                if(da[i])\\n                {\\n                    da[i]--;\\n                    ans+=\\'a\\'+i;\\n                    cnt--;\\n                }\\n            }\\n            cout<<cnt<<\"\\\\n\";\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring sortString(string s) {\\n        vector<int>da(26,0);\\n        int  cnt=0;\\n        string  ans;\\n        for(auto i:s)\\n        {   \\n            da[i-\\'a\\']++;\\n            cnt++;\\n        }\\n        while(cnt)\\n        {\\n            for(int i=0;i<=25;i++)\\n            {\\n                if(da[i])\\n                {\\n                    da[i]--;\\n                    ans+=\\'a\\'+i;\\n                    cnt--;\\n                }\\n            }\\n            for(int i=25;i>=0;i--)\\n            {\\n                if(da[i])\\n                {\\n                    da[i]--;\\n                    ans+=\\'a\\'+i;\\n                    cnt--;\\n                }\\n            }\\n            cout<<cnt<<\"\\\\n\";\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1073641,
                "title": "c-solution-runs-in-4-ms",
                "content": "```\\nchar m[26];\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        for(const char &c:s) ++m[c-\\'a\\'];\\n        int rem = 0;\\n        int len = s.length();\\n        int mn = 0;\\n        while(rem < len && !(mn = 0))\\n            for(int i = 0, j = 51; j >= 0; ++i,--j,mn = min(i,j))\\n                if (m[mn]) s[rem] = mn+\\'a\\',++rem,--m[mn];\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nchar m[26];\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        for(const char &c:s) ++m[c-\\'a\\'];\\n        int rem = 0;\\n        int len = s.length();\\n        int mn = 0;\\n        while(rem < len && !(mn = 0))\\n            for(int i = 0, j = 51; j >= 0; ++i,--j,mn = min(i,j))\\n                if (m[mn]) s[rem] = mn+\\'a\\',++rem,--m[mn];\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072397,
                "title": "very-easy-java-solution-no-complex-java-library-objects-used",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    char arr[];\\n    int n;\\n    public boolean isNull()\\n    {\\n        for(int i=0; i<n; i++)\\n            if(arr[i]!=\\'0\\')\\n                return false;\\n        return true;\\n    }\\n    public String sortString(String s) \\n    {\\n        arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        n = s.length();\\n        String res=\"\";\\n        while(!isNull())\\n        {\\n            char ref=\\'0\\';\\n            for(int i=0; i<n; i++)\\n            {\\n                char temp = arr[i];\\n                if(temp !=\\'0\\')\\n                {\\n                    if(ref==\\'0\\')\\n                    {\\n                        res+=temp;\\n                        ref = temp;\\n                        arr[i]=\\'0\\';\\n                    }\\n                    else if(temp>ref)\\n                    {\\n                        res+=temp;\\n                        ref = temp;\\n                        arr[i]=\\'0\\';\\n                    }\\n                        \\n                }\\n            }\\n            // System.out.println(res);\\n            char ref1=\\'0\\';\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                char temp = arr[j];\\n                if(temp!=\\'0\\')\\n                {\\n                    if(ref1==\\'0\\')\\n                    {\\n                        res+=temp;\\n                        ref1 = temp;\\n                        arr[j]=\\'0\\';\\n                    }\\n                    else if(temp<ref1)\\n                    {\\n                        res+=temp;\\n                        ref1 = temp;\\n                        arr[j]=\\'0\\';\\n                    }\\n                }\\n            }\\n            // System.out.println(res);\\n        }\\n        return res;\\n    }\\n}\\n\\n//By Arindam Ghosh\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    char arr[];\\n    int n;\\n    public boolean isNull()\\n    {\\n        for(int i=0; i<n; i++)\\n            if(arr[i]!=\\'0\\')\\n                return false;\\n        return true;\\n    }\\n    public String sortString(String s) \\n    {\\n        arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        n = s.length();\\n        String res=\"\";\\n        while(!isNull())\\n        {\\n            char ref=\\'0\\';\\n            for(int i=0; i<n; i++)\\n            {\\n                char temp = arr[i];\\n                if(temp !=\\'0\\')\\n                {\\n                    if(ref==\\'0\\')\\n                    {\\n                        res+=temp;\\n                        ref = temp;\\n                        arr[i]=\\'0\\';\\n                    }\\n                    else if(temp>ref)\\n                    {\\n                        res+=temp;\\n                        ref = temp;\\n                        arr[i]=\\'0\\';\\n                    }\\n                        \\n                }\\n            }\\n            // System.out.println(res);\\n            char ref1=\\'0\\';\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                char temp = arr[j];\\n                if(temp!=\\'0\\')\\n                {\\n                    if(ref1==\\'0\\')\\n                    {\\n                        res+=temp;\\n                        ref1 = temp;\\n                        arr[j]=\\'0\\';\\n                    }\\n                    else if(temp<ref1)\\n                    {\\n                        res+=temp;\\n                        ref1 = temp;\\n                        arr[j]=\\'0\\';\\n                    }\\n                }\\n            }\\n            // System.out.println(res);\\n        }\\n        return res;\\n    }\\n}\\n\\n//By Arindam Ghosh\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004044,
                "title": "python3-faster-than-100-using-hints",
                "content": "![image](https://assets.leetcode.com/users/images/b4a47458-8dd3-4172-926f-75d59f0f9bad_1609902631.4732957.png)\\n\\n```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n\\t\\t#result string\\n        result:str = \"\"\\n        #Table of frequencies\\n        freqTable = []\\n        \\'\\'\\'\\n        create sorted set in order to pick unique character in ascending order -> step 1-2,\\n        then do it again in descending order -> step 4-5\\n        had to use \"dict.fromkeys()\" instead of set() to preserve the order of elements\\n        \\'\\'\\'\\n        sortedSet = sorted(list(dict.fromkeys(s)))\\n        #counting frequencies\\n        for x in sortedSet:\\n            freqTable.append(s.count(x))\\n        \\n        #while there are some unused characters with frequency > 0 -> step 7\\n        while(sum(freqTable) != 0):\\n            #appending characters in ascending order -> step 1-2-3\\n            for i in range(len(sortedSet)):\\n\\t\\t\\t\\t#if frequency of particular character is > 0 we can add it to our result string\\n                if freqTable[i] > 0:\\n                    result += sortedSet[i]\\n\\t\\t\\t\\t\\t#Decreasing frequency of a character\\n                    freqTable[i] -= 1\\n            #appending characters in descending order -> step 4-5-6\\n            for i in range(len(sortedSet)-1, -1, -1):\\n                if freqTable[i] > 0:\\n                    result += sortedSet[i]\\n                    freqTable[i] -= 1\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n\\t\\t#result string\\n        result:str = \"\"\\n        #Table of frequencies\\n        freqTable = []\\n        \\'\\'\\'\\n        create sorted set in order to pick unique character in ascending order -> step 1-2,\\n        then do it again in descending order -> step 4-5\\n        had to use \"dict.fromkeys()\" instead of set() to preserve the order of elements\\n        \\'\\'\\'\\n        sortedSet = sorted(list(dict.fromkeys(s)))\\n        #counting frequencies\\n        for x in sortedSet:\\n            freqTable.append(s.count(x))\\n        \\n        #while there are some unused characters with frequency > 0 -> step 7\\n        while(sum(freqTable) != 0):\\n            #appending characters in ascending order -> step 1-2-3\\n            for i in range(len(sortedSet)):\\n\\t\\t\\t\\t#if frequency of particular character is > 0 we can add it to our result string\\n                if freqTable[i] > 0:\\n                    result += sortedSet[i]\\n\\t\\t\\t\\t\\t#Decreasing frequency of a character\\n                    freqTable[i] -= 1\\n            #appending characters in descending order -> step 4-5-6\\n            for i in range(len(sortedSet)-1, -1, -1):\\n                if freqTable[i] > 0:\\n                    result += sortedSet[i]\\n                    freqTable[i] -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001714,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        map<char,int> m;\\n        for(char x: s) m[x]++;                               //map initilation map[ character, number of occurance ]\\n        string v;\\n        while(v.size()!=s.size()){                           \\n            for(auto i= m.begin(); i!= m.end(); i++){        //iterating map form begining to end\\n                if(i->second != 0){\\n                    v+=i->first;\\n                    m[i->first]--;\\n                }\\n            }\\n            for(auto i= m.rbegin(); i!= m.rend(); i++){      //iterating map form end to begining\\n                if(i->second != 0){\\n                    v+=i->first;\\n                    m[i->first]--;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string sortString(string s) {\\n        map<char,int> m;\\n        for(char x: s) m[x]++;                               //map initilation map[ character, number of occurance ]\\n        string v;\\n        while(v.size()!=s.size()){                           \\n            for(auto i= m.begin(); i!= m.end(); i++){        //iterating map form begining to end\\n                if(i->second != 0){\\n                    v+=i->first;\\n                    m[i->first]--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 974069,
                "title": "java-2ms-100-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int len = s.length();\\n        int n[] = new int[26];\\n        for(int i=0; i<len; i++)n[s.charAt(i)-\\'a\\']++;\\n        \\n        char x[] = new char[len]; int ind=0;\\n        \\n        while(ind<len){\\n            for(int i=0; i<26; i++) if(n[i]>0){x[ind++]=(char)(i+\\'a\\'); n[i]--;}\\n            for(int i=25; i>=0; i--)if(n[i]>0){x[ind++]=(char)(i+\\'a\\'); n[i]--;}\\n        }\\n        return new String(x);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int len = s.length();\\n        int n[] = new int[26];\\n        for(int i=0; i<len; i++)n[s.charAt(i)-\\'a\\']++;\\n        \\n        char x[] = new char[len]; int ind=0;\\n        \\n        while(ind<len){\\n            for(int i=0; i<26; i++) if(n[i]>0){x[ind++]=(char)(i+\\'a\\'); n[i]--;}\\n            for(int i=25; i>=0; i--)if(n[i]>0){x[ind++]=(char)(i+\\'a\\'); n[i]--;}\\n        }\\n        return new String(x);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947063,
                "title": "javascript-solution",
                "content": "```\\nvar sortString = function(s) {\\n    const n = s.length;\\n    const count = new Array(26).fill(0);\\n    \\n    for (const char of s) {\\n        const index = char.charCodeAt(0) - 97;\\n        count[index]++;\\n    }\\n    \\n    let res = \"\";\\n    \\n    while (res.length < n) {\\n        for (let j = 0; j < 26 && res.length < n; j++) {\\n            if (count[j] > 0) {\\n                \\n                const char = String.fromCharCode(j + 97);\\n                res += char;\\n                count[j]--;\\n            }\\n        }\\n        \\n        if (res.length === n) return res;\\n        \\n        for (let k = 25; k >= 0 && res.length < n; k--) {\\n            if (count[k] > 0) {\\n                \\n                const char = String.fromCharCode(k + 97);\\n                res += char;\\n                count[k]--;\\n            }\\n        }\\n        \\n        if (res.length === n) return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortString = function(s) {\\n    const n = s.length;\\n    const count = new Array(26).fill(0);\\n    \\n    for (const char of s) {\\n        const index = char.charCodeAt(0) - 97;\\n        count[index]++;\\n    }\\n    \\n    let res = \"\";\\n    \\n    while (res.length < n) {\\n        for (let j = 0; j < 26 && res.length < n; j++) {\\n            if (count[j] > 0) {\\n                \\n                const char = String.fromCharCode(j + 97);\\n                res += char;\\n                count[j]--;\\n            }\\n        }\\n        \\n        if (res.length === n) return res;\\n        \\n        for (let k = 25; k >= 0 && res.length < n; k--) {\\n            if (count[k] > 0) {\\n                \\n                const char = String.fromCharCode(k + 97);\\n                res += char;\\n                count[k]--;\\n            }\\n        }\\n        \\n        if (res.length === n) return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906571,
                "title": "java-2ms-100-using-char-frequency-array-o-n",
                "content": "```\\npublic String sortString(String s) {\\n\\tchar[] chars = new char[26];\\n\\tStringBuilder sb = new StringBuilder();\\n\\n\\tfor(char cc : s.toCharArray()) {\\n\\t\\tchars[cc - \\'a\\']++;\\n\\t}\\n\\n\\tboolean picked = false;\\n\\n\\tdo {\\n\\t\\tpicked = false;\\n\\t\\tfor(int i=0; i<chars.length; i++) {\\n\\t\\t\\tif(chars[i] > 0) {\\n\\t\\t\\t\\tsb.append((char) (\\'a\\' + i));\\n\\t\\t\\t\\tchars[i]--;\\n\\t\\t\\t\\tpicked = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(!picked) break;\\n\\n\\t\\tpicked = false;\\n\\t\\tfor(int i=chars.length-1; i>=0; i--) {\\n\\t\\t\\tif(chars[i] > 0) {\\n\\t\\t\\t\\tsb.append((char) (\\'a\\' + i));\\n\\t\\t\\t\\tchars[i]--;\\n\\t\\t\\t\\tpicked = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} while(picked = true);\\n\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String sortString(String s) {\\n\\tchar[] chars = new char[26];\\n\\tStringBuilder sb = new StringBuilder();\\n\\n\\tfor(char cc : s.toCharArray()) {\\n\\t\\tchars[cc - \\'a\\']++;\\n\\t}\\n\\n\\tboolean picked = false;\\n\\n\\tdo {\\n\\t\\tpicked = false;\\n\\t\\tfor(int i=0; i<chars.length; i++) {\\n\\t\\t\\tif(chars[i] > 0) {\\n\\t\\t\\t\\tsb.append((char) (\\'a\\' + i));\\n\\t\\t\\t\\tchars[i]--;\\n\\t\\t\\t\\tpicked = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(!picked) break;\\n\\n\\t\\tpicked = false;\\n\\t\\tfor(int i=chars.length-1; i>=0; i--) {\\n\\t\\t\\tif(chars[i] > 0) {\\n\\t\\t\\t\\tsb.append((char) (\\'a\\' + i));\\n\\t\\t\\t\\tchars[i]--;\\n\\t\\t\\t\\tpicked = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} while(picked = true);\\n\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849748,
                "title": "c-simple-solution-w-comments-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        // Map used for storing all chars in the input string s\\n        // The map will order the chars for us in ascending order\\n        map<char, int> letters;\\n        // Store the length of s\\n        int n = s.length();\\n        // Add all chars to the map\\n        for(int i = 0; i < n; i++)\\n            letters[s[i]]++;\\n        \\n        // Result answer vector\\n        string ans = \"\";\\n        // Only loop through for the length of the original string\\n        while(n != 0){\\n            // Create an iterator for the map\\n            map<char, int> :: iterator itr;\\n            // Loop through the map forwards, adding each char and decrementing its count\\n            for(itr = letters.begin(); itr != letters.end(); itr++){\\n                if(itr->second != 0){\\n                    ans += itr->first;\\n                    itr->second = itr->second - 1;\\n                    n--;\\n                }\\n            }\\n            // Create a reverse iterator for the map\\n            map<char, int> :: reverse_iterator it;\\n            // Loop through the map backwards, adding each char and decrementing its count\\n            for(it = letters.rbegin(); it != letters.rend(); it++){\\n                if(it->second != 0){\\n                    ans += it->first;\\n                    it->second = it->second - 1;\\n                    n--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        // Map used for storing all chars in the input string s\\n        // The map will order the chars for us in ascending order\\n        map<char, int> letters;\\n        // Store the length of s\\n        int n = s.length();\\n        // Add all chars to the map\\n        for(int i = 0; i < n; i++)\\n            letters[s[i]]++;\\n        \\n        // Result answer vector\\n        string ans = \"\";\\n        // Only loop through for the length of the original string\\n        while(n != 0){\\n            // Create an iterator for the map\\n            map<char, int> :: iterator itr;\\n            // Loop through the map forwards, adding each char and decrementing its count\\n            for(itr = letters.begin(); itr != letters.end(); itr++){\\n                if(itr->second != 0){\\n                    ans += itr->first;\\n                    itr->second = itr->second - 1;\\n                    n--;\\n                }\\n            }\\n            // Create a reverse iterator for the map\\n            map<char, int> :: reverse_iterator it;\\n            // Loop through the map backwards, adding each char and decrementing its count\\n            for(it = letters.rbegin(); it != letters.rend(); it++){\\n                if(it->second != 0){\\n                    ans += it->first;\\n                    it->second = it->second - 1;\\n                    n--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838660,
                "title": "python-two-stacks-with-explanation-60ms-with-91-fast",
                "content": "The idea is to use a stack to store alphabets with non-zero counts. In the meantime a dictionary records counts for each alphabet. Every time it will pop one letter into output and decrease counts by 1. If this letter has more counts available it will be put into the other stack. Repeat until stack is empty. Running time is ~60ms and 91% faster. \\n\\n```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        c = collections.Counter(s)\\n        stack= []\\n        for ch in string.ascii_lowercase[::-1]:\\n            if c[ch] > 0:\\n                stack.append(ch)\\n        res = \"\"\\n        while stack:\\n            temp = []\\n            while stack:\\n                ch = stack.pop()\\n                res += ch\\n                if c[ch] > 1:\\n                    c[ch] -= 1\\n                    temp.append(ch)\\n            stack = temp[:]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        c = collections.Counter(s)\\n        stack= []\\n        for ch in string.ascii_lowercase[::-1]:\\n            if c[ch] > 0:\\n                stack.append(ch)\\n        res = \"\"\\n        while stack:\\n            temp = []\\n            while stack:\\n                ch = stack.pop()\\n                res += ch\\n                if c[ch] > 1:\\n                    c[ch] -= 1\\n                    temp.append(ch)\\n            stack = temp[:]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806164,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        std::map<char,int> alpha;\\n        string ans=\"\";\\n        \\n        for(const auto &i:s)\\n        {\\n            if(alpha.find(i)==alpha.end())\\n            {\\n                alpha.insert({i,1});\\n            }\\n            else\\n            {\\n                alpha[i]++;\\n            }\\n        }\\n        \\n        int len=s.size();\\n        \\n        while(len)\\n        {\\n            for(auto &[key,val] : alpha)\\n            {\\n                if(val)\\n                {\\n                    ans+=key;\\n                    val--;\\n                    len--;\\n                }\\n            }\\n            for(auto x=alpha.rbegin();x!=alpha.rend();x++)\\n            {\\n                if(x->second)\\n                {\\n                    ans+=x->first;\\n                    x->second--;\\n                    len--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        std::map<char,int> alpha;\\n        string ans=\"\";\\n        \\n        for(const auto &i:s)\\n        {\\n            if(alpha.find(i)==alpha.end())\\n            {\\n                alpha.insert({i,1});\\n            }\\n            else\\n            {\\n                alpha[i]++;\\n            }\\n        }\\n        \\n        int len=s.size();\\n        \\n        while(len)\\n        {\\n            for(auto &[key,val] : alpha)\\n            {\\n                if(val)\\n                {\\n                    ans+=key;\\n                    val--;\\n                    len--;\\n                }\\n            }\\n            for(auto x=alpha.rbegin();x!=alpha.rend();x++)\\n            {\\n                if(x->second)\\n                {\\n                    ans+=x->first;\\n                    x->second--;\\n                    len--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786071,
                "title": "go-solution-with-a-direction-flag",
                "content": "```go\\nfunc sortString(s string) string {\\n\\tchars := make([]int, 26)\\n\\tfor _, ch := range s {\\n\\t\\tchars[ch-97]++\\n\\t}\\n\\n    var buf strings.Builder\\n\\ti, direction := 0, 1\\n\\tfor buf.Len() < len(s) {\\n\\t\\tif i == 26 {\\n\\t\\t\\ti = 25\\n\\t\\t\\tdirection = -1\\n\\t\\t}\\n\\t\\t\\n\\t\\tif i == -1 {\\n\\t\\t\\ti = 0\\n\\t\\t\\tdirection = 1\\n\\t\\t}\\n\\t\\tif chars[i] > 0 {\\n\\t\\t\\tbuf.WriteByte(byte(i + 97))\\n\\t\\t\\tchars[i]--\\n\\t\\t}\\n\\n\\t\\ti += direction\\n\\t}\\n\\n    return buf.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc sortString(s string) string {\\n\\tchars := make([]int, 26)\\n\\tfor _, ch := range s {\\n\\t\\tchars[ch-97]++\\n\\t}\\n\\n    var buf strings.Builder\\n\\ti, direction := 0, 1\\n\\tfor buf.Len() < len(s) {\\n\\t\\tif i == 26 {\\n\\t\\t\\ti = 25\\n\\t\\t\\tdirection = -1\\n\\t\\t}\\n\\t\\t\\n\\t\\tif i == -1 {\\n\\t\\t\\ti = 0\\n\\t\\t\\tdirection = 1\\n\\t\\t}\\n\\t\\tif chars[i] > 0 {\\n\\t\\t\\tbuf.WriteByte(byte(i + 97))\\n\\t\\t\\tchars[i]--\\n\\t\\t}\\n\\n\\t\\ti += direction\\n\\t}\\n\\n    return buf.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 743065,
                "title": "simple-python-3-solution",
                "content": "```\\n    def sortString(self, s: str) -> str:\\n        storage = {}\\n        for ch in s:\\n            if ch in storage:\\n                storage[ch] += 1\\n            else:\\n                storage[ch] = 1\\n        result = []\\n        smallest = True\\n        while storage:\\n            keys = [key for key in storage]\\n            keys = sorted(keys) if smallest else sorted(keys, reverse=True)\\n            smallest = not smallest\\n            for key in keys:\\n                result.append(key)\\n                if storage[key] == 1:\\n                    del storage[key]\\n                else:\\n                    storage[key] -= 1\\n        return \\'\\'.join(result)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def sortString(self, s: str) -> str:\\n        storage = {}\\n        for ch in s:\\n            if ch in storage:\\n                storage[ch] += 1\\n            else:\\n                storage[ch] = 1\\n        result = []\\n        smallest = True\\n        while storage:\\n            keys = [key for key in storage]\\n            keys = sorted(keys) if smallest else sorted(keys, reverse=True)\\n            smallest = not smallest\\n            for key in keys:\\n                result.append(key)\\n                if storage[key] == 1:\\n                    del storage[key]\\n                else:\\n                    storage[key] -= 1\\n        return \\'\\'.join(result)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 732589,
                "title": "c-solution-100-speed-memory-o-2n",
                "content": "```\\nchar * sortString(char * s){\\n    int dict[26]={0}, i, len=strlen(s),p=0;\\n    for(i=0;i<len;i++)\\n        dict[s[i]-\\'a\\']++;\\n    while(p!=len){\\n        for(i=0;i<26;i++)\\n            if(dict[i]!=0){\\n                s[p++]=\\'a\\'+i;\\n                dict[i]--;\\n            }\\n        for(i=25;i>=0;i--)\\n            if(dict[i]!=0){\\n                s[p++]=\\'a\\'+i;\\n                dict[i]--;\\n            }\\n    }\\n    return s;\\n}\\n\\nThe code has 2 phases:\\n1.  Collecting in a supporting array all the letters (strlen(s) steps)\\n2.  Iterating in the 2 directions the dictionary picking one letter at time (strlen(s) steps)\\n\\nFor a total of 2n operations.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * sortString(char * s){\\n    int dict[26]={0}, i, len=strlen(s),p=0;\\n    for(i=0;i<len;i++)\\n        dict[s[i]-\\'a\\']++;\\n    while(p!=len){\\n        for(i=0;i<26;i++)\\n            if(dict[i]!=0){\\n                s[p++]=\\'a\\'+i;\\n                dict[i]--;\\n            }\\n        for(i=25;i>=0;i--)\\n            if(dict[i]!=0){\\n                s[p++]=\\'a\\'+i;\\n                dict[i]--;\\n            }\\n    }\\n    return s;\\n}\\n\\nThe code has 2 phases:\\n1.  Collecting in a supporting array all the letters (strlen(s) steps)\\n2.  Iterating in the 2 directions the dictionary picking one letter at time (strlen(s) steps)\\n\\nFor a total of 2n operations.",
                "codeTag": "Unknown"
            },
            {
                "id": 715149,
                "title": "java-faster-than-100-clean-code",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder res = new StringBuilder();\\n        int arr[] = new int[26], total = s.length();\\n        for(char c : s.toCharArray())\\n            arr[c-\\'a\\']++;\\n        while(total > 0){\\n            int smallest = 0, largest = 25;\\n            while(smallest < 26 && arr[smallest] == 0)\\n                smallest++;\\n            while(smallest < 26){\\n                if(arr[smallest] != 0){\\n                    res.append((char)(\\'a\\'+smallest));\\n                    arr[smallest]--;\\n                    total--;\\n                }\\n                smallest++;\\n            }\\n            while(largest >=0 && arr[largest] == 0)\\n                largest--;\\n            while(largest >= 0){\\n                if(arr[largest] != 0){\\n                    res.append((char)(\\'a\\'+largest));\\n                    arr[largest]--;\\n                    total--;\\n                }\\n                largest--;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String sortString(String s) {\\n        StringBuilder res = new StringBuilder();\\n        int arr[] = new int[26], total = s.length();\\n        for(char c : s.toCharArray())\\n            arr[c-\\'a\\']++;\\n        while(total > 0){\\n            int smallest = 0, largest = 25;\\n            while(smallest < 26 && arr[smallest] == 0)\\n                smallest++;\\n            while(smallest < 26){\\n                if(arr[smallest] != 0){\\n                    res.append((char)(\\'a\\'+smallest));\\n                    arr[smallest]--;\\n                    total--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 626953,
                "title": "java-no-nested-loops-simple-fast-solution",
                "content": "Runtime: 2 ms, faster than 100.00% of Java online submissions for Increasing Decreasing String.\\nMemory Usage: 39.4 MB, less than 100.00% of Java online submissions for Increasing Decreasing String.\\n\\n1. Calculates frequency of each character and puts it into counts map;\\n2. Depends on the direction goes back and forth through the counts map and pick the available character.\\n\\n\\n```\\npublic String sortString(String s) {\\n    int[] cs = new int[26];\\n\\n    for (char c : s.toCharArray()) {\\n        cs[c - \\'a\\']++;\\n    }\\n\\n    int n = s.length();\\n    int i = 0;\\n    int dir = 1;\\n\\tStringBuilder result = new StringBuilder();\\n    while (n > 0) {\\n        if (i < 0) {\\n            dir = 1;\\n        } else if (i == cs.length) {\\n            dir = -1;\\n        } else if (cs[i] > 0) {\\n            cs[i]--;\\n            n--;\\n\\n            result.append((char)(\\'a\\' + i));\\n        }\\n\\n        i += dir;\\n    }\\n\\n    return result.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String sortString(String s) {\\n    int[] cs = new int[26];\\n\\n    for (char c : s.toCharArray()) {\\n        cs[c - \\'a\\']++;\\n    }\\n\\n    int n = s.length();\\n    int i = 0;\\n    int dir = 1;\\n\\tStringBuilder result = new StringBuilder();\\n    while (n > 0) {\\n        if (i < 0) {\\n            dir = 1;\\n        } else if (i == cs.length) {\\n            dir = -1;\\n        } else if (cs[i] > 0) {\\n            cs[i]--;\\n            n--;\\n\\n            result.append((char)(\\'a\\' + i));\\n        }\\n\\n        i += dir;\\n    }\\n\\n    return result.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571185,
                "title": "c-iteratively-build-string-with-zigzag-iteration-98-speed-100-memory",
                "content": "Count characters using an array instead of a map or vector to improve speed. At each step in the iteration go forwards and backwards through the alphabet to add letters until the whole string is built.\\n\\n```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        int letters[26];\\n        fill_n(letters, 26, 0);\\n        for (auto& c : s) letters[c-\\'a\\']++;\\n        string ans = \"\";\\n        while (ans.size() < s.size()){\\n            for (int i = 0; i < 26; i++)\\n                if (letters[i] > 0){\\n                    ans += (char)(i+\\'a\\');\\n                    letters[i]--;\\n                }\\n            for (int i = 25; i >= 0; i--)\\n                if (letters[i] > 0){\\n                    ans += (char)(i+\\'a\\');\\n                    letters[i]--;\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        int letters[26];\\n        fill_n(letters, 26, 0);\\n        for (auto& c : s) letters[c-\\'a\\']++;\\n        string ans = \"\";\\n        while (ans.size() < s.size()){\\n            for (int i = 0; i < 26; i++)\\n                if (letters[i] > 0){\\n                    ans += (char)(i+\\'a\\');\\n                    letters[i]--;\\n                }\\n            for (int i = 25; i >= 0; i--)\\n                if (letters[i] > 0){\\n                    ans += (char)(i+\\'a\\');\\n                    letters[i]--;\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559268,
                "title": "python3-solution-runtime-95-33-52ms-memory-100-14mb",
                "content": "```Python\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        raw = {i:s.count(i) for i in set(s)}\\n        seq = sorted(raw.keys())\\n        out = \"\"\\n        while sum(raw.values())>0:\\n            for i in seq:\\n                if raw[i]>0:\\n                    out+=i\\n                    raw[i]-=1\\n            for i in seq[::-1]:\\n                if raw[i]>0:\\n                    out+=i\\n                    raw[i]-=1\\n        return out      \\n                    \\n```\\n\\n            \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        raw = {i:s.count(i) for i in set(s)}\\n        seq = sorted(raw.keys())\\n        out = \"\"\\n        while sum(raw.values())>0:\\n            for i in seq:\\n                if raw[i]>0:\\n                    out+=i\\n                    raw[i]-=1\\n            for i in seq[::-1]:\\n                if raw[i]>0:\\n                    out+=i\\n                    raw[i]-=1\\n        return out      \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 542495,
                "title": "java-solution-with-array-beats-100-time-and-space",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n      int[] counts = new int[26];\\n      for (char x : s.toCharArray()) {\\n        counts[x-\\'a\\']++;\\n      }\\n      \\n      boolean change = true;\\n      StringBuilder sb = new StringBuilder();\\n      while (change) {\\n        change = false;\\n        \\n        for (int i = 0; i < 26; i++) {\\n          if (counts[i] > 0) {\\n            sb.append((char)(\\'a\\' + i));\\n            counts[i]--;\\n            change = true;\\n          }\\n        }\\n\\n        for (int i = 25; i >= 0; i--) {\\n          if (counts[i] > 0) {\\n            sb.append((char)(\\'a\\' + i));\\n            counts[i]--;\\n            change = true;\\n          }\\n        }\\n      }\\n      \\n      return sb.toString();\\n      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n      int[] counts = new int[26];\\n      for (char x : s.toCharArray()) {\\n        counts[x-\\'a\\']++;\\n      }\\n      \\n      boolean change = true;\\n      StringBuilder sb = new StringBuilder();\\n      while (change) {\\n        change = false;\\n        \\n        for (int i = 0; i < 26; i++) {\\n          if (counts[i] > 0) {\\n            sb.append((char)(\\'a\\' + i));\\n            counts[i]--;\\n            change = true;\\n          }\\n        }\\n\\n        for (int i = 25; i >= 0; i--) {\\n          if (counts[i] > 0) {\\n            sb.append((char)(\\'a\\' + i));\\n            counts[i]--;\\n            change = true;\\n          }\\n        }\\n      }\\n      \\n      return sb.toString();\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534870,
                "title": "java-bucket-sort-and-keep-frequency",
                "content": "```\\n    public String sortString(String s) {\\n        int[] freq = new int[26];\\n        for(char c : s.toCharArray()){\\n            freq[c-\\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(sb.length()<s.length()){\\n            for(int i=0; i<26; i++){\\n                if(freq[i]>0){\\n                    sb.append((char)(\\'a\\'+i));\\n                    freq[i]--;\\n                }\\n            }\\n            for(int i=25; i>=0; i--){\\n                if(freq[i]>0){\\n                    sb.append((char)(\\'a\\'+i));\\n                    freq[i]--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String sortString(String s) {\\n        int[] freq = new int[26];\\n        for(char c : s.toCharArray()){\\n            freq[c-\\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(sb.length()<s.length()){\\n            for(int i=0; i<26; i++){\\n                if(freq[i]>0){\\n                    sb.append((char)(\\'a\\'+i));\\n                    freq[i]--;\\n                }\\n            }\\n            for(int i=25; i>=0; i--){\\n                if(freq[i]>0){\\n                    sb.append((char)(\\'a\\'+i));\\n                    freq[i]--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534104,
                "title": "c-short-and-easy-to-understand-20-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        vector<int> counter(26, 0);\\n        string ans;\\n        \\n        for (int i = 0; i < s.length(); i++)\\n            counter[s[i] - \\'a\\']++;\\n\\n        while (any_of(counter.begin(), counter.end(), [](int n) { return n > 0; })) {\\n            for (int i = 0; i < counter.size(); i++)\\n                if(counter[i]-- > 0) \\n\\t\\t\\t\\t\\tans += (i + \\'a\\');\\n\\n            for (int i = counter.size() - 1; i >= 0; i--)\\n                if (counter[i]-- > 0)\\n                    ans += (i + \\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        vector<int> counter(26, 0);\\n        string ans;\\n        \\n        for (int i = 0; i < s.length(); i++)\\n            counter[s[i] - \\'a\\']++;\\n\\n        while (any_of(counter.begin(), counter.end(), [](int n) { return n > 0; })) {\\n            for (int i = 0; i < counter.size(); i++)\\n                if(counter[i]-- > 0) \\n\\t\\t\\t\\t\\tans += (i + \\'a\\');\\n\\n            for (int i = counter.size() - 1; i >= 0; i--)\\n                if (counter[i]-- > 0)\\n                    ans += (i + \\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531942,
                "title": "java-simple-char-count-back-and-forth-3ms",
                "content": "```\\n\\nclass Solution {\\n    public String sortString(String s) {\\n        int N = s.length();\\n        int[] counts = new int[26];\\n        int i, total = N;\\n        \\n        for(i = 0; i < N; i++){\\n            counts[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        StringBuilder builder = new StringBuilder();\\n        \\n        boolean forward = true;\\n        while(total > 0){\\n            if(forward){\\n                for(i = 0; i < 26; i++){\\n                    if(counts[i] != 0){\\n                        builder.append((char)(\\'a\\' + i));\\n                        --counts[i];\\n                        --total;\\n                    }\\n                }\\n            }else{\\n                for(i = 25; i >= 0; i--){\\n                    if(counts[i] != 0){\\n                        builder.append((char)(\\'a\\' + i));\\n                        --counts[i];\\n                        --total;\\n                    }\\n                }\\n            }\\n            \\n            forward = !forward;\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public String sortString(String s) {\\n        int N = s.length();\\n        int[] counts = new int[26];\\n        int i, total = N;\\n        \\n        for(i = 0; i < N; i++){\\n            counts[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        StringBuilder builder = new StringBuilder();\\n        \\n        boolean forward = true;\\n        while(total > 0){\\n            if(forward){\\n                for(i = 0; i < 26; i++){\\n                    if(counts[i] != 0){\\n                        builder.append((char)(\\'a\\' + i));\\n                        --counts[i];\\n                        --total;\\n                    }\\n                }\\n            }else{\\n                for(i = 25; i >= 0; i--){\\n                    if(counts[i] != 0){\\n                        builder.append((char)(\\'a\\' + i));\\n                        --counts[i];\\n                        --total;\\n                    }\\n                }\\n            }\\n            \\n            forward = !forward;\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089360,
                "title": "frequency-mapping-approach-in-2-steps-0ms-c",
                "content": "Mapping the frequency of each character in the array.\\n(We can also create a map for this frequency mapping)\\n\\nafter that there are only 2 simple steps, \\n\\n1- take all characters in ascending order\\n2- take all characters in descending order\\n\\nthis is how in 2 steps we achieve the logic.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string result = \"\";\\n        int freq[26] = {0};\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            freq[s[i] - 97]++;\\n        }\\n\\n        int n = s.length();\\n\\n        while(n != 0)\\n        {\\n            for(int i = 0; i < 26; i++)\\n            {\\n                if(freq[i] >= 1)\\n                {\\n                    result += (char)(97 + i);\\n                    n--;\\n                    freq[i]--;\\n                }\\n            }\\n            for(int i = 25; i >= 0; i--)\\n            {\\n                if(freq[i] >= 1)\\n                {\\n                    result += (char)(97 + i);\\n                    n--;\\n                    freq[i]--;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string result = \"\";\\n        int freq[26] = {0};\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            freq[s[i] - 97]++;\\n        }\\n\\n        int n = s.length();\\n\\n        while(n != 0)\\n        {\\n            for(int i = 0; i < 26; i++)\\n            {\\n                if(freq[i] >= 1)\\n                {\\n                    result += (char)(97 + i);\\n                    n--;\\n                    freq[i]--;\\n                }\\n            }\\n            for(int i = 25; i >= 0; i--)\\n            {\\n                if(freq[i] >= 1)\\n                {\\n                    result += (char)(97 + i);\\n                    n--;\\n                    freq[i]--;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560810,
                "title": "increasing-decreasing-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        int i, j;\\n        map<char, int> mp;\\n        string s1 = \"\";\\n        string temp = \"\";\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        while(s1.length()<s.length())\\n        {\\n            for(auto it:mp)\\n            {\\n                if(it.second>0)\\n                {\\n                    s1 += it.first;\\n                    mp[it.first]--;\\n                }\\n            }\\n            for(auto it:mp)\\n            {\\n                if(it.second>0)\\n                {\\n                    temp += it.first;\\n                    mp[it.first]--;\\n                }\\n            }\\n            reverse(temp.begin(), temp.end());\\n            s1 += temp;\\n            temp.clear();\\n        }\\n        return s1;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/2e9c2751-1d66-4083-b92e-5a6b1792cb52_1684994282.0868623.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        int i, j;\\n        map<char, int> mp;\\n        string s1 = \"\";\\n        string temp = \"\";\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        while(s1.length()<s.length())\\n        {\\n            for(auto it:mp)\\n            {\\n                if(it.second>0)\\n                {\\n                    s1 += it.first;\\n                    mp[it.first]--;\\n                }\\n            }\\n            for(auto it:mp)\\n            {\\n                if(it.second>0)\\n                {\\n                    temp += it.first;\\n                    mp[it.first]--;\\n                }\\n            }\\n            reverse(temp.begin(), temp.end());\\n            s1 += temp;\\n            temp.clear();\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235228,
                "title": "simple-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        set<char>st;\\n        unordered_map<char,int>mp;\\n        for(auto x:s){\\n            st.insert(x);\\n            mp[x]++;\\n        }\\n        string res=\"\",temp=\"\";\\n        for(auto x:st) temp+=x;\\n        while(res.size()<s.size()){\\n            for(int i=0;i<temp.size();i++){\\n                if(mp[temp[i]]>0){\\n                    res+=temp[i];\\n                    mp[temp[i]]--;\\n                }\\n            }\\n            for(int i=temp.size()-1;i>=0;i--){\\n                if(mp[temp[i]]>0){\\n                    res+=temp[i];\\n                    mp[temp[i]]--;\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        set<char>st;\\n        unordered_map<char,int>mp;\\n        for(auto x:s){\\n            st.insert(x);\\n            mp[x]++;\\n        }\\n        string res=\"\",temp=\"\";\\n        for(auto x:st) temp+=x;\\n        while(res.size()<s.size()){\\n            for(int i=0;i<temp.size();i++){\\n                if(mp[temp[i]]>0){\\n                    res+=temp[i];\\n                    mp[temp[i]]--;\\n                }\\n            }\\n            for(int i=temp.size()-1;i>=0;i--){\\n                if(mp[temp[i]]>0){\\n                    res+=temp[i];\\n                    mp[temp[i]]--;\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130565,
                "title": "javascript-hashmap-readable-and-easy-to-understand-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar sortString = function (s) {\\n  const map = new Array(26).fill(0);\\n\\n  for (const char of s) {\\n    const charCode = char.charCodeAt(0) - 97;\\n    map[charCode]++;\\n  }\\n\\n  function appendCharToRes(i) {\\n    const char = String.fromCharCode(i + 97);\\n    res += char;\\n    map[i]--;\\n  }\\n\\n  let res = \"\";\\n\\n  while (res.length !== s.length) {\\n    for (let i = 0; i < map.length; i++) {\\n      if (!map[i]) continue;\\n      appendCharToRes(i);\\n    }\\n\\n    for (let i = map.length - 1; i >= 0; i--) {\\n      if (!map[i]) continue;\\n      appendCharToRes(i);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar sortString = function (s) {\\n  const map = new Array(26).fill(0);\\n\\n  for (const char of s) {\\n    const charCode = char.charCodeAt(0) - 97;\\n    map[charCode]++;\\n  }\\n\\n  function appendCharToRes(i) {\\n    const char = String.fromCharCode(i + 97);\\n    res += char;\\n    map[i]--;\\n  }\\n\\n  let res = \"\";\\n\\n  while (res.length !== s.length) {\\n    for (let i = 0; i < map.length; i++) {\\n      if (!map[i]) continue;\\n      appendCharToRes(i);\\n    }\\n\\n    for (let i = map.length - 1; i >= 0; i--) {\\n      if (!map[i]) continue;\\n      appendCharToRes(i);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2767133,
                "title": "easy-slip-like-water",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string sortString(string s) \\n    {\\n        int mp[26]={0};\\n        string res=\"\";\\n        for(char c:s)mp[c-\\'a\\']++;\\n        while(res.size()!=s.size())\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                if(mp[i])\\n                {\\n                    res+=\\'a\\'+i;\\n                    mp[i]--;\\n                }\\n            }\\n            for(int i=25;i>=0;i--)\\n            {\\n                if(mp[i])\\n                {\\n                    res+=\\'a\\'+i;\\n                    mp[i]--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string sortString(string s) \\n    {\\n        int mp[26]={0};\\n        string res=\"\";\\n        for(char c:s)mp[c-\\'a\\']++;\\n        while(res.size()!=s.size())\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                if(mp[i])\\n                {\\n                    res+=\\'a\\'+i;\\n                    mp[i]--;\\n                }\\n            }\\n            for(int i=25;i>=0;i--)\\n            {\\n                if(mp[i])\\n                {\\n                    res+=\\'a\\'+i;\\n                    mp[i]--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608245,
                "title": "c-faster-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n   void pick(vector<int>&arr , int i , string &res){\\n\\tif(arr[i]){\\n\\t\\tres+= \\'a\\' + i;\\n\\t\\tarr[i]--;\\n\\t}\\n}\\n\\nstring sortString(string s) {\\n    vector<int>arr(26);\\n    string res;\\n    for(char c : s)\\n        arr[c - \\'a\\']++;\\n    while(true){\\n        for(int i = 0; i < 26; i++)\\n            pick(arr, i , res);\\n        for(int i = 25; i >= 0; i--)\\n            pick(arr, i , res);\\n        if(res.size() == s.size()) return res;\\n    }\\n    return res;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   void pick(vector<int>&arr , int i , string &res){\\n\\tif(arr[i]){\\n\\t\\tres+= \\'a\\' + i;\\n\\t\\tarr[i]--;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2553235,
                "title": "java-string-array-simple-solution",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int arr[] = new int[27];\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<s.length();i++){\\n            int num = str.indexOf(Character.toString(s.charAt(i)));\\n            num=num+1;\\n            arr[num]=arr[num]+1;\\n        }\\n        int len = s.length();\\n        int count=0;\\n        String ans = \"\";\\n        while(count<len){\\n            for(int i=1;i<27;i++){\\n                if(arr[i]>0){\\n                    ans=ans+Character.toString(str.charAt(i-1));\\n                    arr[i]=arr[i]-1;\\n                    count++;\\n                }\\n            }\\n            for(int j=26;j>=1;j--){\\n                if(arr[j]>0){\\n                    ans=ans+Character.toString(str.charAt(j-1));\\n                    arr[j]=arr[j]-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int arr[] = new int[27];\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<s.length();i++){\\n            int num = str.indexOf(Character.toString(s.charAt(i)));\\n            num=num+1;\\n            arr[num]=arr[num]+1;\\n        }\\n        int len = s.length();\\n        int count=0;\\n        String ans = \"\";\\n        while(count<len){\\n            for(int i=1;i<27;i++){\\n                if(arr[i]>0){\\n                    ans=ans+Character.toString(str.charAt(i-1));\\n                    arr[i]=arr[i]-1;\\n                    count++;\\n                }\\n            }\\n            for(int j=26;j>=1;j--){\\n                if(arr[j]>0){\\n                    ans=ans+Character.toString(str.charAt(j-1));\\n                    arr[j]=arr[j]-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514075,
                "title": "python-space-and-memory-efficient-solution",
                "content": "Please **Upvote** if solution helps\\n\\n```\\nclass Solution:\\n    def sort_hm(self, s1,hm, keys):\\n        for k in keys:\\n            if hm[k] >0:\\n                s1 += k\\n                hm[k] -=1\\n        return s1, hm\\n    \\n    def sortString(self, s: str) -> str:\\n        # Logic is based on counts\\n        # Create hash map first\\n        hm = {}\\n        for i in s:\\n            hm[i] = hm.get(i,0) + 1\\n        \\n        s1=\\'\\'\\n        while(len(s1) != len(s)):\\n            \\n            # step 1,2,3 of algoriths\\n            keys = sorted(hm)\\n            s1, hm = self.sort_hm(s1,hm, keys)\\n\\n            # step 4,5,6 of algoriths\\n            keys = sorted(hm,reverse=True)\\n            s1, hm = self.sort_hm(s1,hm, keys)\\n            \\n        return s1\\n```\\n![image](https://assets.leetcode.com/users/images/992c85d0-ca41-46fe-a30c-0ab41bd672ea_1662037470.0328603.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sort_hm(self, s1,hm, keys):\\n        for k in keys:\\n            if hm[k] >0:\\n                s1 += k\\n                hm[k] -=1\\n        return s1, hm\\n    \\n    def sortString(self, s: str) -> str:\\n        # Logic is based on counts\\n        # Create hash map first\\n        hm = {}\\n        for i in s:\\n            hm[i] = hm.get(i,0) + 1\\n        \\n        s1=\\'\\'\\n        while(len(s1) != len(s)):\\n            \\n            # step 1,2,3 of algoriths\\n            keys = sorted(hm)\\n            s1, hm = self.sort_hm(s1,hm, keys)\\n\\n            # step 4,5,6 of algoriths\\n            keys = sorted(hm,reverse=True)\\n            s1, hm = self.sort_hm(s1,hm, keys)\\n            \\n        return s1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470124,
                "title": "simple-c-using-mapping",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        vector<int> v(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int x = s[i]-\\'a\\';\\n            v[x]++;\\n        }\\n        \\n        string ans=\"\";\\n        int i=0;\\n        while(ans.size()<s.size())\\n        {\\n            if(i==0)\\n            {\\n                for(i=0;i<v.size();i++){\\n                    if(v[i]>0)\\n                    {\\n                        char c = i+\\'a\\';\\n                        ans+=c;\\n                        v[i]--;\\n                    }\\n                }\\n                i=v.size();\\n            }\\n            if(i==v.size())\\n            {\\n                for(i=v.size()-1;i>=0;i--){\\n                    if(v[i]>0)\\n                    {\\n                        char c = i+\\'a\\';\\n                        ans+=c;\\n                        v[i]--;\\n                    }\\n                }\\n                i=0;\\n            }\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        vector<int> v(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int x = s[i]-\\'a\\';\\n            v[x]++;\\n        }\\n        \\n        string ans=\"\";\\n        int i=0;\\n        while(ans.size()<s.size())\\n        {\\n            if(i==0)\\n            {\\n                for(i=0;i<v.size();i++){\\n                    if(v[i]>0)\\n                    {\\n                        char c = i+\\'a\\';\\n                        ans+=c;\\n                        v[i]--;\\n                    }\\n                }\\n                i=v.size();\\n            }\\n            if(i==v.size())\\n            {\\n                for(i=v.size()-1;i>=0;i--){\\n                    if(v[i]>0)\\n                    {\\n                        char c = i+\\'a\\';\\n                        ans+=c;\\n                        v[i]--;\\n                    }\\n                }\\n                i=0;\\n            }\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326953,
                "title": "simply-simulation-approach-in-python-reverse-iteration-in-loop-until-task-is-done",
                "content": "```\\ndef sortString(self, s: str) -> str:\\n\\tcounts = Counter(s)            # count chars in s\\n    chars = sorted(counts.keys())  # sorted keys (chars )\\n        \\n    res = []\\n    i = 0                          # pointer to next char\\n    inc = 1                        # increment value, direction (1 - go forward, -1 for backwards)\\n    while len(res) < len(s):\\n\\t\\tif counts[chars[i]] > 0:    # if char count > 0\\n\\t\\t\\tres.append(chars[i])    # append it to res\\n            counts[chars[i]] -= 1   # decrement char count\\n            \\n        i+=inc                      # increment pointer to next char\\n        if i in (-1, len(chars)):   # if we reached end or begining\\n\\t\\t\\tinc = -inc              # reverse current direction\\n            i+=inc                  # correct current position\\n            \\n        return \\'\\'.join(res)\\n",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\ndef sortString(self, s: str) -> str:\\n\\tcounts = Counter(s)            # count chars in s\\n    chars = sorted(counts.keys())  # sorted keys (chars )\\n        \\n    res = []\\n    i = 0                          # pointer to next char\\n    inc = 1                        # increment value, direction (1 - go forward, -1 for backwards)\\n    while len(res) < len(s):\\n\\t\\tif counts[chars[i]] > 0:    # if char count > 0\\n\\t\\t\\tres.append(chars[i])    # append it to res\\n            counts[chars[i]] -= 1   # decrement char count\\n            \\n        i+=inc                      # increment pointer to next char\\n        if i in (-1, len(chars)):   # if we reached end or begining\\n\\t\\t\\tinc = -inc              # reverse current direction\\n            i+=inc                  # correct current position\\n            \\n        return \\'\\'.join(res)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2286633,
                "title": "c-solution-with-frequency-array",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        \\n        vector<int>freq(150, 0);\\n        \\n        for(char ch:s)\\n            freq[ch]++;\\n        \\n        string res = \"\";\\n        \\n        bool found = true;\\n        while(found)\\n        {\\n            found = false;\\n            for(char c=\\'a\\'; c<=\\'z\\'; c++)\\n                if (freq[c])\\n                {\\n                    res.push_back(c);\\n                    freq[c]--;\\n                    found = true;\\n                }\\n\\n            for(char c=\\'z\\'; c>=\\'a\\'; c--)\\n                if(freq[c])\\n                {\\n                    res.push_back(c);\\n                    freq[c]--;\\n                    found = true;\\n                }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        \\n        vector<int>freq(150, 0);\\n        \\n        for(char ch:s)\\n            freq[ch]++;\\n        \\n        string res = \"\";\\n        \\n        bool found = true;\\n        while(found)\\n        {\\n            found = false;\\n            for(char c=\\'a\\'; c<=\\'z\\'; c++)\\n                if (freq[c])\\n                {\\n                    res.push_back(c);\\n                    freq[c]--;\\n                    found = true;\\n                }\\n\\n            for(char c=\\'z\\'; c>=\\'a\\'; c--)\\n                if(freq[c])\\n                {\\n                    res.push_back(c);\\n                    freq[c]--;\\n                    found = true;\\n                }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214274,
                "title": "c-solution",
                "content": "```\\nstring sortString(string s) {\\n        int str[27];\\n        memset(str,0,sizeof(str));\\n        for (auto c:s) {\\n            str[c-\\'a\\']++;\\n        }\\n        string ans=\"\";\\n        int len = s.size();\\n        while (len > 0){\\n            for (int i=0; i<27 && len != 0;i++){\\n                if (str[i]) {\\n                    ans += char(i+\\'a\\');\\n                    str[i]--;\\n                    len--;\\n                }\\n            }\\n            \\n            for (int i=26; i>=0 && len != 0;i--){\\n                if (str[i]) {\\n                    ans += char(i+\\'a\\');\\n                    str[i]--;\\n                    len--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring sortString(string s) {\\n        int str[27];\\n        memset(str,0,sizeof(str));\\n        for (auto c:s) {\\n            str[c-\\'a\\']++;\\n        }\\n        string ans=\"\";\\n        int len = s.size();\\n        while (len > 0){\\n            for (int i=0; i<27 && len != 0;i++){\\n                if (str[i]) {\\n                    ans += char(i+\\'a\\');\\n                    str[i]--;\\n                    len--;\\n                }\\n            }\\n            \\n            for (int i=26; i>=0 && len != 0;i--){\\n                if (str[i]) {\\n                    ans += char(i+\\'a\\');\\n                    str[i]--;\\n                    len--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2167833,
                "title": "python-python-3-hashmap-easy-understand-solution-beats-97",
                "content": "```\\nclass Solution(object):\\n    def sortString(self, s):\\n        dict = {}\\n        for s1 in s:\\n            dict[s1] = dict.get(s1, 0)+1\\n        list1 = sorted(list(set(s)))\\n        \\n        result = \\'\\'\\n        while len(result) < len(s):\\n            for l in list1:\\n                if l in dict and dict[l] != 0:\\n                    result += l\\n                    dict[l] -= 1\\n            \\n            for l in list1[::-1]:\\n                if l in dict and dict[l] != 0:\\n                    result += l\\n                    dict[l] -= 1\\n                        \\n        return result",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution(object):\\n    def sortString(self, s):\\n        dict = {}",
                "codeTag": "Java"
            },
            {
                "id": 2073830,
                "title": "count-and-reduce-range-tricks-java",
                "content": "```java\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] count = new int[26];\\n        int i = 0, last = 0;\\n        do {\\n            ++count[s.charAt(i) - \\'a\\'];\\n        } while (++i < s.length());\\n        \\n        StringBuilder res = new StringBuilder(s.length());\\n        do {\\n            for(i = last; i < 26; ++i) {\\n                if(count[i] > 0) {\\n                    res.append((char) (i + \\'a\\'));\\n                    last = i;\\n                    --count[i];\\n                }\\n            }\\n            for(i = last; i >=0; --i) {\\n                if(count[i] > 0) {\\n                    res.append((char) (i + \\'a\\'));\\n                    last = i;\\n                    --count[i];\\n                }\\n            }\\n        } while (res.length() < s.length());\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] count = new int[26];\\n        int i = 0, last = 0;\\n        do {\\n            ++count[s.charAt(i) - \\'a\\'];\\n        } while (++i < s.length());\\n        \\n        StringBuilder res = new StringBuilder(s.length());\\n        do {\\n            for(i = last; i < 26; ++i) {\\n                if(count[i] > 0) {\\n                    res.append((char) (i + \\'a\\'));\\n                    last = i;\\n                    --count[i];\\n                }\\n            }\\n            for(i = last; i >=0; --i) {\\n                if(count[i] > 0) {\\n                    res.append((char) (i + \\'a\\'));\\n                    last = i;\\n                    --count[i];\\n                }\\n            }\\n        } while (res.length() < s.length());\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059303,
                "title": "faster-than-97-using-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        vector<int> cnt(26,0);\\n        int n = s.size();\\n        for(int i=0;i<n;++i){\\n            cnt[s[i]-\\'a\\']++;\\n        }\\n        string ans = \"\";\\n        while(ans.size()<n){\\n            for(int j=0;j<26;++j){\\n                if(cnt[j]>0){\\n                    ans.push_back(j+\\'a\\');\\n                    cnt[j]-=1;\\n                }\\n            }\\n            for(int j=25;j>=0;--j){\\n                if(cnt[j]>0){\\n                    ans.push_back(j+\\'a\\');\\n                    cnt[j]-=1;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};****\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        vector<int> cnt(26,0);\\n        int n = s.size();\\n        for(int i=0;i<n;++i){\\n            cnt[s[i]-\\'a\\']++;\\n        }\\n        string ans = \"\";\\n        while(ans.size()<n){\\n            for(int j=0;j<26;++j){\\n                if(cnt[j]>0){\\n                    ans.push_back(j+\\'a\\');\\n                    cnt[j]-=1;\\n                }\\n            }\\n            for(int j=25;j>=0;--j){\\n                if(cnt[j]>0){\\n                    ans.push_back(j+\\'a\\');\\n                    cnt[j]-=1;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011355,
                "title": "fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) \\n    {\\n        StringBuilder sb = new StringBuilder();\\n        int arr[] = new int[26];\\n        for(char ch:s.toCharArray())\\n            arr[ch-97]++;\\n        int n = s.length();\\n        int i=0;\\n        boolean flag=true;\\n        while(n!=sb.length())\\n        {\\n            if(arr[i]!=0)\\n            {\\n                sb.append((char)(i+97));\\n                arr[i]--;\\n            }\\n            if(flag)\\n            {\\n                i++;\\n                if(i==26)\\n                {\\n                    flag=false;\\n                    i--;\\n                }\\n            }\\n            else\\n            {\\n                i--;\\n                if(i==-1)\\n                {\\n                    flag=true;\\n                    i++;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String sortString(String s) \\n    {\\n        StringBuilder sb = new StringBuilder();\\n        int arr[] = new int[26];\\n        for(char ch:s.toCharArray())\\n            arr[ch-97]++;\\n        int n = s.length();\\n        int i=0;\\n        boolean flag=true;\\n        while(n!=sb.length())\\n        {\\n            if(arr[i]!=0)\\n            {\\n                sb.append((char)(i+97));\\n                arr[i]--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1894458,
                "title": "java-easy-solution-frequency-counter-0ms-100-beat",
                "content": "![image](https://assets.leetcode.com/users/images/c182e04e-5c5b-474b-82dd-62fd934e37f6_1648560416.8791192.png)\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder answer = new StringBuilder(s.length());\\n        int[] frequencyTable = new int[26];\\n        for(char letter: s.toCharArray()) {\\n            frequencyTable[letter - \\'a\\']++;\\n        }\\n        while(answer.length() < s.length()) {\\n            reorder(answer, frequencyTable, true);\\n            reorder(answer, frequencyTable, false);\\n        }\\n        return answer.toString();\\n    }\\n    \\n    public void reorder(StringBuilder builder, int[] table, boolean decider) {\\n        for(int i=0;i<26;i++) {\\n            int j = decider ? i : 25 - i;\\n            if(table[j]-- > 0) {\\n                builder.append((char)(j + \\'a\\'));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder answer = new StringBuilder(s.length());\\n        int[] frequencyTable = new int[26];\\n        for(char letter: s.toCharArray()) {\\n            frequencyTable[letter - \\'a\\']++;\\n        }\\n        while(answer.length() < s.length()) {\\n            reorder(answer, frequencyTable, true);\\n            reorder(answer, frequencyTable, false);\\n        }\\n        return answer.toString();\\n    }\\n    \\n    public void reorder(StringBuilder builder, int[] table, boolean decider) {\\n        for(int i=0;i<26;i++) {\\n            int j = decider ? i : 25 - i;\\n            if(table[j]-- > 0) {\\n                builder.append((char)(j + \\'a\\'));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846524,
                "title": "java-beats-100",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {    \\n        \\n        int [] map = new int [26];\\n        int total=s.length();\\n        for(int i=0;i<s.length();i++){\\n           map[s.charAt(i)-\\'a\\']++;\\n        }\\n\\n        StringBuilder str = new StringBuilder();\\n        \\n        while(total>0){\\n\\n        char last=\\' \\';\\n        for(int i=0;i<map.length;i++){\\n            if(map[i]>0){\\n                map[i]--;\\n                total--;\\n                str.append((char) (i+\\'a\\'));\\n            }\\n        }\\n        last=\\' \\';\\n        for(int i=map.length-1;i>=0;i--){\\n            if(map[i]>0){\\n                map[i]--;\\n                total--;\\n                str.append((char) (i+\\'a\\'));\\n            }\\n        }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {    \\n        \\n        int [] map = new int [26];\\n        int total=s.length();\\n        for(int i=0;i<s.length();i++){\\n           map[s.charAt(i)-\\'a\\']++;\\n        }\\n\\n        StringBuilder str = new StringBuilder();\\n        \\n        while(total>0){\\n\\n        char last=\\' \\';\\n        for(int i=0;i<map.length;i++){\\n            if(map[i]>0){\\n                map[i]--;\\n                total--;\\n                str.append((char) (i+\\'a\\'));\\n            }\\n        }\\n        last=\\' \\';\\n        for(int i=map.length-1;i>=0;i--){\\n            if(map[i]>0){\\n                map[i]--;\\n                total--;\\n                str.append((char) (i+\\'a\\'));\\n            }\\n        }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776545,
                "title": "tricky-java-solution-in-3ms-85-faster",
                "content": "\\tpublic String sortString(String s) {\\n\\t\\tint sLength = s.length();\\n\\t\\tchar[] charAlphabet = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\\n\\t\\tStringBuilder output = new StringBuilder();\\n\\t\\tint[] alphabets = new int[26];\\n\\t\\tfor(int i = 0;i<s.length();i++)\\n\\t\\t\\talphabets[s.charAt(i)-\\'a\\']++;\\n\\t\\t\\n\\t\\twhile(sLength>0) {\\n\\t\\t\\tfor(int j=0;j<alphabets.length;j++) {\\n\\t\\t\\t\\tif(alphabets[j]>0) {\\n\\t\\t\\t\\t\\toutput.append(charAlphabet[j]);\\n\\t\\t\\t\\t\\talphabets[j] = alphabets[j]-1;\\n\\t\\t\\t\\t\\tsLength--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int k=alphabets.length;k>0;k--) {\\n\\t\\t\\t\\tif(alphabets[k-1]>0) {\\n\\t\\t\\t\\t\\toutput.append(charAlphabet[k-1]);\\n\\t\\t\\t\\t\\talphabets[k-1] = alphabets[k-1]-1;\\n\\t\\t\\t\\t\\tsLength--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn output.toString();\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic String sortString(String s) {\\n\\t\\tint sLength = s.length();\\n\\t\\tchar[] charAlphabet = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\\n\\t\\tStringBuilder output = new StringBuilder();\\n\\t\\tint[] alphabets = new int[26];\\n\\t\\tfor(int i = 0;i<s.length();i++)\\n\\t\\t\\talphabets[s.charAt(i)-\\'a\\']++;\\n\\t\\t\\n\\t\\twhile(sLength>0) {\\n\\t\\t\\tfor(int j=0;j<alphabets.length;j++) {\\n\\t\\t\\t\\tif(alphabets[j]>0) {\\n\\t\\t\\t\\t\\toutput.append(charAlphabet[j]);\\n\\t\\t\\t\\t\\talphabets[j] = alphabets[j]-1;\\n\\t\\t\\t\\t\\tsLength--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int k=alphabets.length;k>0;k--) {\\n\\t\\t\\t\\tif(alphabets[k-1]>0) {\\n\\t\\t\\t\\t\\toutput.append(charAlphabet[k-1]);\\n\\t\\t\\t\\t\\talphabets[k-1] = alphabets[k-1]-1;\\n\\t\\t\\t\\t\\tsLength--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn output.toString();\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1775277,
                "title": "java-solution-increasing-decreasing-string-using-hashmap",
                "content": "Java Solution using HashMap\\nP.S. : This is not the most optimised solution but it is easy to understand.\\n```\\nimport java.io.*;\\nimport java.util.*;\\nclass Solution {\\n    public String sortString(String s) {        \\n        if(s.length()<=1) return s;\\n        Map<Character,Integer> map = new TreeMap<Character,Integer>();\\n        int L = s.length();\\n        for(int i=0;i<L;i++){\\n            char c =s.charAt(i);\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        String result =\"\";        \\n        while(result.length()<L){\\n            for(Map.Entry<Character,Integer> e : map.entrySet()){\\n                if(e.getValue()>=1){\\n                    result += \"\"+Character.toString(e.getKey());\\n                    map.put(e.getKey(),e.getValue()-1);\\n                }\\n               \\n            }            \\n            ArrayList<Character> list = new ArrayList<>(map.keySet());\\n            list.sort(Collections.reverseOrder());\\n            Set<Character> keyS = new LinkedHashSet<>(list);\\n           \\n            for (Character key : keyS) {\\n                if(map.get(key)>=1){\\n                    result += Character.toString(key);\\n                    map.put(key,map.get(key)-1);\\n                }                \\n               \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\nHappy Coding!!!\\nDo upvote if you like the Solution.\\nAny queries or suggestions? Sure!! Ping me :\\n* [[LinkedIn](https://www.linkedin.com/in/rohitm17/)]  \\n* [[Twitter](https://twitter.com/rohit_mittal17)]\\n* [[GitHub](https://github.com/rohitm17)]\\n* [[Medium](https://medium.com/@rohitm17)]",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.io.*;\\nimport java.util.*;\\nclass Solution {\\n    public String sortString(String s) {        \\n        if(s.length()<=1) return s;\\n        Map<Character,Integer> map = new TreeMap<Character,Integer>();\\n        int L = s.length();\\n        for(int i=0;i<L;i++){\\n            char c =s.charAt(i);\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        String result =\"\";        \\n        while(result.length()<L){\\n            for(Map.Entry<Character,Integer> e : map.entrySet()){\\n                if(e.getValue()>=1){\\n                    result += \"\"+Character.toString(e.getKey());\\n                    map.put(e.getKey(),e.getValue()-1);\\n                }\\n               \\n            }            \\n            ArrayList<Character> list = new ArrayList<>(map.keySet());\\n            list.sort(Collections.reverseOrder());\\n            Set<Character> keyS = new LinkedHashSet<>(list);\\n           \\n            for (Character key : keyS) {\\n                if(map.get(key)>=1){\\n                    result += Character.toString(key);\\n                    map.put(key,map.get(key)-1);\\n                }                \\n               \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754936,
                "title": "java-simple-explained",
                "content": "**Idea:** With frequency of each letter, then append increasing-decreasing alternately till the letters run out\\n>**T/S:** O(n)/O(1), where n  = size(s)\\n```\\npublic String sortString(String s) {\\n\\tvar letterCount = new int[26];\\n\\tfor (var i = 0; i < s.length(); i++)\\n\\t\\tletterCount[s.charAt(i) - \\'a\\']++;\\n\\n\\tvar wavy = new StringBuilder();\\n\\twhile (wavy.length() < s.length()) {\\n\\t\\tfor (var i = 0; i < 26; i++) \\n\\t\\t\\tappend(letterCount, i, wavy);\\n\\t\\tfor (var i = 25; i >= 0; i--)\\n\\t\\t\\tappend(letterCount, i, wavy);\\n\\t}\\n\\n\\treturn wavy.toString();\\n}\\n\\nprivate void append(int[] letterCount, int i, StringBuilder wavy) {\\n\\tif (letterCount[i]-- < 1)\\n\\t\\treturn;\\n\\twavy.append((char) (\\'a\\' + i));\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String sortString(String s) {\\n\\tvar letterCount = new int[26];\\n\\tfor (var i = 0; i < s.length(); i++)\\n\\t\\tletterCount[s.charAt(i) - \\'a\\']++;\\n\\n\\tvar wavy = new StringBuilder();\\n\\twhile (wavy.length() < s.length()) {\\n\\t\\tfor (var i = 0; i < 26; i++) \\n\\t\\t\\tappend(letterCount, i, wavy);\\n\\t\\tfor (var i = 25; i >= 0; i--)\\n\\t\\t\\tappend(letterCount, i, wavy);\\n\\t}\\n\\n\\treturn wavy.toString();\\n}\\n\\nprivate void append(int[] letterCount, int i, StringBuilder wavy) {\\n\\tif (letterCount[i]-- < 1)\\n\\t\\treturn;\\n\\twavy.append((char) (\\'a\\' + i));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1683469,
                "title": "easy-to-understand-simple-python-code",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        char_count = {}\\n        for c in s:\\n            char_count[c] = char_count.get(c,0)+1\\n        \\n        new_word =\"\"\\n        n = len(s)\\n        while n:\\n            for c in sorted(set(s)):\\n                if char_count[c]:\\n                    new_word = new_word+c\\n                    char_count[c] = char_count.get(c)-1\\n                    n = n-1\\n            for c in sorted(set(s), reverse=True):\\n                if char_count[c]:\\n                    new_word = new_word+c\\n                    char_count[c] = char_count.get(c)-1\\n                    n = n-1\\n        return new_word",
                "solutionTags": [],
                "code": "class Solution:\\n    def sortString(self, s: str) -> str:\\n        char_count = {}",
                "codeTag": "Java"
            },
            {
                "id": 1665560,
                "title": "java-solution",
                "content": "The solution is a little bit complex and not efficient but its an honest work!!!\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int i =0;\\n        int length = s.length();\\n        char arr[] = s.toCharArray();\\n        Arrays.sort(arr);\\n        s = new String(arr);\\n        StringBuilder output = new StringBuilder();\\n        while(i<length)\\n        {\\n        \\t// appending the smallest to the result\\n        \\toutput.append(s.charAt(0));\\n        \\ti++;\\n        \\t// finding the smallest character which is greater then last appended character\\n        \\ts = s.substring(1);\\n        \\tString temp = new String(s);\\n        \\ts = new String();\\n        \\tfor(int x =0;x< temp.length();x++)\\n        \\t{\\n        \\t\\tif(temp.charAt(x)-output.charAt(output.length()-1)>0)\\n        \\t\\t{\\n        \\t\\t\\toutput.append(temp.charAt(x));\\n        \\t\\t\\ti++;\\n        \\t\\t}\\n        \\t\\t// extracting the remaining string\\n        \\t\\telse {\\n        \\t\\t\\ts = s+temp.charAt(x);\\n        \\t\\t}\\n        \\t}\\n        \\tif(i == length)break;\\n        \\t// appending the largest to the result\\n        \\toutput.append(s.charAt(s.length()-1));\\n        \\ti++;\\n        \\t// finding the largest character which is smaller then last appended character\\n        \\ts = s.substring(0,s.length()-1);\\n        \\ttemp = new String(s);\\n        \\ts = new String();\\n        \\tfor(int x = temp.length()-1;x>=0;x--)\\n        \\t{\\n        \\t\\tif(temp.charAt(x)-output.charAt(output.length()-1)<0)\\n        \\t\\t{\\n        \\t\\t\\toutput.append(temp.charAt(x));\\n        \\t\\t\\ti++;\\n        \\t\\t}\\n        \\t\\telse\\n        \\t\\t\\ts =temp.charAt(x)+ s;\\n        \\t}\\n        }\\n        return output.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int i =0;\\n        int length = s.length();\\n        char arr[] = s.toCharArray();\\n        Arrays.sort(arr);\\n        s = new String(arr);\\n        StringBuilder output = new StringBuilder();\\n        while(i<length)\\n        {\\n        \\t// appending the smallest to the result\\n        \\toutput.append(s.charAt(0));\\n        \\ti++;\\n        \\t// finding the smallest character which is greater then last appended character\\n        \\ts = s.substring(1);\\n        \\tString temp = new String(s);\\n        \\ts = new String();\\n        \\tfor(int x =0;x< temp.length();x++)\\n        \\t{\\n        \\t\\tif(temp.charAt(x)-output.charAt(output.length()-1)>0)\\n        \\t\\t{\\n        \\t\\t\\toutput.append(temp.charAt(x));\\n        \\t\\t\\ti++;\\n        \\t\\t}\\n        \\t\\t// extracting the remaining string\\n        \\t\\telse {\\n        \\t\\t\\ts = s+temp.charAt(x);\\n        \\t\\t}\\n        \\t}\\n        \\tif(i == length)break;\\n        \\t// appending the largest to the result\\n        \\toutput.append(s.charAt(s.length()-1));\\n        \\ti++;\\n        \\t// finding the largest character which is smaller then last appended character\\n        \\ts = s.substring(0,s.length()-1);\\n        \\ttemp = new String(s);\\n        \\ts = new String();\\n        \\tfor(int x = temp.length()-1;x>=0;x--)\\n        \\t{\\n        \\t\\tif(temp.charAt(x)-output.charAt(output.length()-1)<0)\\n        \\t\\t{\\n        \\t\\t\\toutput.append(temp.charAt(x));\\n        \\t\\t\\ti++;\\n        \\t\\t}\\n        \\t\\telse\\n        \\t\\t\\ts =temp.charAt(x)+ s;\\n        \\t}\\n        }\\n        return output.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656066,
                "title": "java-soluton",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[26];\\n        for(char c:s.toCharArray()){\\n            arr[c-\\'a\\']++;\\n        }\\n        int size = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(size<s.length()){\\n            for(int i = 0;i<arr.length;i++){\\n                if(arr[i]>0){\\n                    sb.append((char)(i+\\'a\\'));\\n                    arr[i]--;\\n                    size++;\\n                }  \\n            }\\n             for(int i = arr.length-1;i>=0;i--){\\n                if(arr[i]>0){\\n                    sb.append((char)(i+\\'a\\'));\\n                    arr[i]--;\\n                    size++;\\n                }  \\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[26];\\n        for(char c:s.toCharArray()){\\n            arr[c-\\'a\\']++;\\n        }\\n        int size = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(size<s.length()){\\n            for(int i = 0;i<arr.length;i++){\\n                if(arr[i]>0){\\n                    sb.append((char)(i+\\'a\\'));\\n                    arr[i]--;\\n                    size++;\\n                }  \\n            }\\n             for(int i = arr.length-1;i>=0;i--){\\n                if(arr[i]>0){\\n                    sb.append((char)(i+\\'a\\'));\\n                    arr[i]--;\\n                    size++;\\n                }  \\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609380,
                "title": "python3-o-n-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        dct,res=collections.Counter(s),[]\\n        while len(res)!=len(s):\\n            for el in string.ascii_lowercase:\\n                if el in dct and dct[el]>0:\\n                    res.append(el)\\n                    dct[el]-=1\\n            for el in string.ascii_lowercase[::-1]:\\n                if el in dct and dct[el]>0:\\n                    res.append(el)\\n                    dct[el]-=1\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        dct,res=collections.Counter(s),[]\\n        while len(res)!=len(s):\\n            for el in string.ascii_lowercase:\\n                if el in dct and dct[el]>0:\\n                    res.append(el)\\n                    dct[el]-=1\\n            for el in string.ascii_lowercase[::-1]:\\n                if el in dct and dct[el]>0:\\n                    res.append(el)\\n                    dct[el]-=1\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605971,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        map<char, int> mp;\\n        for(const char c : s) {\\n            ++mp[c];\\n        }\\n        string ret;\\n        while(!mp.empty()) {\\n            for(auto it = mp.begin(); it != mp.end();) {\\n                if(it->second == 0) {\\n                    it = mp.erase(it);\\n                    continue;\\n                }\\n                ret += it->first;\\n                if(--it->second == 0) {\\n                    it = mp.erase(it);\\n                } else {\\n                    ++it;\\n                }\\n            }\\n            \\n            for(auto it = mp.rbegin(); it != mp.rend(); ++it) {\\n                ret += it->first;\\n                --it->second;\\n            }            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        map<char, int> mp;\\n        for(const char c : s) {\\n            ++mp[c];\\n        }\\n        string ret;\\n        while(!mp.empty()) {\\n            for(auto it = mp.begin(); it != mp.end();) {\\n                if(it->second == 0) {\\n                    it = mp.erase(it);\\n                    continue;\\n                }\\n                ret += it->first;\\n                if(--it->second == 0) {\\n                    it = mp.erase(it);\\n                } else {\\n                    ++it;\\n                }\\n            }\\n            \\n            for(auto it = mp.rbegin(); it != mp.rend(); ++it) {\\n                ret += it->first;\\n                --it->second;\\n            }            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597865,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        letter_count = Counter(sorted(s))\\n        res = \\'\\'\\n        \\n        while len(res) < len(s):\\n            # Forward\\n            for k, v in letter_count.items():\\n                if v != 0:\\n                    res += k\\n                    letter_count[k] = v - 1\\n                    \\n            # Backward\\n            for k, v in reversed(letter_count.items()):\\n                if v != 0:\\n                    res += k\\n                    letter_count[k] = v - 1\\n            \\n        return res\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        letter_count = Counter(sorted(s))\\n        res = \\'\\'\\n        \\n        while len(res) < len(s):\\n            # Forward\\n            for k, v in letter_count.items():\\n                if v != 0:\\n                    res += k\\n                    letter_count[k] = v - 1\\n                    \\n            # Backward\\n            for k, v in reversed(letter_count.items()):\\n                if v != 0:\\n                    res += k\\n                    letter_count[k] = v - 1\\n            \\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575783,
                "title": "python-3-57-faster",
                "content": "```\\nclass Solution:\\n    def sortString(self, s1: str) -> str:\\n        res = []\\n        ln = len(s1)\\n        if ln <=1:\\n            return s1\\n        s = sorted (set(s1))\\n        rs = list(s)[::-1]\\n        if len (s) ==1:\\n            return s1\\n        d = {}\\n        for i in s1:\\n            if i in d.keys():\\n                d[i] +=1\\n            else:\\n                d[i] =1\\n                \\n        cnt =0\\n        while (cnt<ln):\\n            for i in s:\\n                if cnt <ln and d[i] >=1:\\n                    res.append(i)\\n                    cnt +=1\\n                    d[i] -=1\\n            for j in rs:\\n                if cnt <ln and d[j] >=1:\\n                    res.append(j)\\n                    d[j] -=1\\n                    cnt +=1\\n        return  \"\".join(res) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortString(self, s1: str) -> str:\\n        res = []\\n        ln = len(s1)\\n        if ln <=1:\\n            return s1\\n        s = sorted (set(s1))\\n        rs = list(s)[::-1]\\n        if len (s) ==1:\\n            return s1\\n        d = {}\\n        for i in s1:\\n            if i in d.keys():\\n                d[i] +=1\\n            else:\\n                d[i] =1\\n                \\n        cnt =0\\n        while (cnt<ln):\\n            for i in s:\\n                if cnt <ln and d[i] >=1:\\n                    res.append(i)\\n                    cnt +=1\\n                    d[i] -=1\\n            for j in rs:\\n                if cnt <ln and d[j] >=1:\\n                    res.append(j)\\n                    d[j] -=1\\n                    cnt +=1\\n        return  \"\".join(res) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528967,
                "title": "simple-easy-c-soln-in-brute",
                "content": "class Solution {\\npublic:\\n*     string sortString(string s) {\\n        int n=s.size();\\n        int ar[26]={0};\\n        for(int i=0;i<n;i++){\\n            int k=s[i]-\\'a\\';\\n            ar[k]++;\\n        }\\n        string ans;\\n        int l=0;\\n        while(l<n){\\n            for(int i=0;i<26;i++){\\n                if(ar[i]>0){\\n                    ans+=(\\'a\\'+i);\\n                    l++;\\n                    ar[i]--;\\n                }\\n            }\\n            for(int i=25;i>=0;i--){\\n                if(ar[i]>0){\\n                    ans+=(\\'a\\'+i);\\n                    l++;\\n                    ar[i]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n*     string sortString(string s) {\\n        int n=s.size();\\n        int ar[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1494536,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder temp = new StringBuilder(s);\\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(temp.length() != 0){\\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                int index = temp.indexOf(c+\"\");\\n                if(index != -1){\\n                    sb.append(c);\\n                    temp.deleteCharAt(index);\\n                }\\n               \\n            }\\n            for(char c=\\'z\\';c>=\\'a\\';c--){\\n                int index = temp.indexOf(c+\"\");\\n                if(index != -1){\\n                    sb.append(c);\\n                    temp.deleteCharAt(index);\\n                }               \\n            }\\n        }\\n        \\n        return sb.toString(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder temp = new StringBuilder(s);\\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(temp.length() != 0){\\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                int index = temp.indexOf(c+\"\");\\n                if(index != -1){\\n                    sb.append(c);\\n                    temp.deleteCharAt(index);\\n                }\\n               \\n            }\\n            for(char c=\\'z\\';c>=\\'a\\';c--){\\n                int index = temp.indexOf(c+\"\");\\n                if(index != -1){\\n                    sb.append(c);\\n                    temp.deleteCharAt(index);\\n                }               \\n            }\\n        }\\n        \\n        return sb.toString(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481728,
                "title": "python3-faster-than-95-consistently-commented",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        dict = {\\n            \\'a\\' : 0, \\'b\\' : 0, \\'c\\' : 0, \\'d\\' : 0, \\'e\\' : 0, \\'f\\' : 0,\\n            \\'g\\' : 0, \\'h\\' : 0, \\'i\\' : 0, \\'j\\' : 0, \\'k\\' : 0, \\'l\\' : 0,\\n            \\'m\\' : 0, \\'n\\' : 0, \\'o\\' : 0, \\'p\\' : 0, \\'q\\' : 0, \\'r\\' : 0,\\n            \\'s\\' : 0, \\'t\\' : 0, \\'u\\' : 0, \\'v\\' : 0, \\'w\\' : 0, \\'x\\' : 0,\\n            \\'y\\' : 0, \\'z\\' : 0 \\n        }\\n        \\n        # Set the number of occurences of each letter \\n        # to its corresponding letter in the dict\\n        for i in s:\\n            dict[i] = dict[i] + 1\\n        \\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        out = \\'\\'\\n        while len(out) < len(s):\\n            \\n            # part 1 increasing ord value of letters\\n            for i in range(0, len(alpha)):\\n                if dict[alpha[i]] > 0:\\n                    out = out + alpha[i]\\n                    dict[alpha[i]] = dict[alpha[i]] - 1\\n                    \\n            # decreasing ord value of letters\\n            for i in range(len(alpha) - 1, -1, -1):\\n                if dict[alpha[i]] > 0:\\n                    out = out + alpha[i]\\n                    dict[alpha[i]] = dict[alpha[i]] - 1 \\n                    \\n        return out\\n````",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        dict = {\\n            \\'a\\' : 0, \\'b\\' : 0, \\'c\\' : 0, \\'d\\' : 0, \\'e\\' : 0, \\'f\\' : 0,\\n            \\'g\\' : 0, \\'h\\' : 0, \\'i\\' : 0, \\'j\\' : 0, \\'k\\' : 0, \\'l\\' : 0,\\n            \\'m\\' : 0, \\'n\\' : 0, \\'o\\' : 0, \\'p\\' : 0, \\'q\\' : 0, \\'r\\' : 0,\\n            \\'s\\' : 0, \\'t\\' : 0, \\'u\\' : 0, \\'v\\' : 0, \\'w\\' : 0, \\'x\\' : 0,\\n            \\'y\\' : 0, \\'z\\' : 0 \\n        }\\n        \\n        # Set the number of occurences of each letter \\n        # to its corresponding letter in the dict\\n        for i in s:\\n            dict[i] = dict[i] + 1\\n        \\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        out = \\'\\'\\n        while len(out) < len(s):\\n            \\n            # part 1 increasing ord value of letters\\n            for i in range(0, len(alpha)):\\n                if dict[alpha[i]] > 0:\\n                    out = out + alpha[i]\\n                    dict[alpha[i]] = dict[alpha[i]] - 1\\n                    \\n            # decreasing ord value of letters\\n            for i in range(len(alpha) - 1, -1, -1):\\n                if dict[alpha[i]] > 0:\\n                    out = out + alpha[i]\\n                    dict[alpha[i]] = dict[alpha[i]] - 1 \\n                    \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449907,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n            //array count stores the count of each alphabet\\n            StringBuilder sb = new StringBuilder();\\n            int[] count= new int[26]; \\n            int len= s.length();\\n              //Count the frequency of each character.\\n            for(int ch: s.toCharArray()) \\n                    count[ch-\\'a\\']++;\\n             //Repeat until the frequency of all characters becomes zero\\n            while(len>0){\\n                     //Loop over all character from \\'a\\' to \\'z\\' \\n                 for(int i=0; i<26; i++)\\n                         if(count[i]>0){\\n                                 count[i]--;\\n                                 sb.append((char)(97+i));\\n                                 len--;\\n                         }   \\n                 //Loop over all character from \\'z\\' to \\'a\\'    \\n                 for(int i=25; i>=0; i--)\\n                         if(count[i]>0){\\n                                 count[i]--;\\n                                 sb.append((char)(97+i));\\n                                 len--;\\n                         }   \\n                    \\n            }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n            //array count stores the count of each alphabet\\n            StringBuilder sb = new StringBuilder();\\n            int[] count= new int[26]; \\n            int len= s.length();\\n              //Count the frequency of each character.\\n            for(int ch: s.toCharArray()) \\n                    count[ch-\\'a\\']++;\\n             //Repeat until the frequency of all characters becomes zero\\n            while(len>0){\\n                     //Loop over all character from \\'a\\' to \\'z\\' \\n                 for(int i=0; i<26; i++)\\n                         if(count[i]>0){\\n                                 count[i]--;\\n                                 sb.append((char)(97+i));\\n                                 len--;\\n                         }   \\n                 //Loop over all character from \\'z\\' to \\'a\\'    \\n                 for(int i=25; i>=0; i--)\\n                         if(count[i]>0){\\n                                 count[i]--;\\n                                 sb.append((char)(97+i));\\n                                 len--;\\n                         }   \\n                    \\n            }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403851,
                "title": "weeb-does-python",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef sortString(self, s: str) -> str:\\n\\t\\t\\tstring, memo = sorted(set(s)), Counter(s)\\n\\t\\t\\tresult = \"\"\\n\\t\\t\\tcount = 0\\n\\n\\t\\t\\twhile len(result) < len(s):\\n\\t\\t\\t\\tif count == 0:\\n\\t\\t\\t\\t\\tfor char in string:\\n\\t\\t\\t\\t\\t\\tif memo[char] == 0: continue\\n\\t\\t\\t\\t\\t\\tresult += char\\n\\t\\t\\t\\t\\t\\tmemo[char] -= 1\\n\\n\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\t\\tif count == 1:\\n\\t\\t\\t\\t\\tfor char in string[::-1]:\\n\\t\\t\\t\\t\\t\\tif memo[char] == 0: continue\\n\\t\\t\\t\\t\\t\\tresult += char\\n\\t\\t\\t\\t\\t\\tmemo[char] -= 1\\n\\n\\t\\t\\t\\t\\tcount -=1\\n\\n\\t\\t\\treturn result\\n\\nAnyways, its time for some anime recommendations\\nCheck out **\\u30A2\\u30A6\\u30C8\\u30D6\\u30EC\\u30A4\\u30AF\\u30FB\\u30AB\\u30F3\\u30D1\\u30CB\\u30FC (Outbreak Company)**\\n\\n# Episodes: 12\\n# Genres: Harem, Comedy, Parody, Fantasy\\n\\nAn anime with a half elf girl, a queen loli, and a cute female furry. \\n**Cultured anime**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\tclass Solution:\\n\\t\\tdef sortString(self, s: str) -> str:\\n\\t\\t\\tstring, memo = sorted(set(s)), Counter(s)\\n\\t\\t\\tresult = \"\"\\n\\t\\t\\tcount = 0\\n\\n\\t\\t\\twhile len(result) < len(s):\\n\\t\\t\\t\\tif count == 0:\\n\\t\\t\\t\\t\\tfor char in string:\\n\\t\\t\\t\\t\\t\\tif memo[char] == 0: continue\\n\\t\\t\\t\\t\\t\\tresult += char\\n\\t\\t\\t\\t\\t\\tmemo[char] -= 1\\n\\n\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\t\\tif count == 1:\\n\\t\\t\\t\\t\\tfor char in string[::-1]:\\n\\t\\t\\t\\t\\t\\tif memo[char] == 0: continue\\n\\t\\t\\t\\t\\t\\tresult += char\\n\\t\\t\\t\\t\\t\\tmemo[char] -= 1\\n\\n\\t\\t\\t\\t\\tcount -=1\\n\\n\\t\\t\\treturn result\\n\\nAnyways, its time for some anime recommendations\\nCheck out **\\u30A2\\u30A6\\u30C8\\u30D6\\u30EC\\u30A4\\u30AF\\u30FB\\u30AB\\u30F3\\u30D1\\u30CB\\u30FC (Outbreak Company)**\\n\\n# Episodes: 12\\n# Genres: Harem, Comedy, Parody, Fantasy\\n\\nAn anime with a half elf girl, a queen loli, and a cute female furry. \\n**Cultured anime**",
                "codeTag": "Java"
            },
            {
                "id": 1402513,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public String sortString(String s) {\\n        int a[]=new int[26];\\n        int i,c=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-\\'a\\']++;\\n        }\\n        StringBuilder nm=new StringBuilder();\\n        while(c<s.length())\\n        {\\n            for(i=0;i<26;i++)\\n            {\\n                if(a[i]>0)\\n                {\\n                    nm.append((char)(\\'a\\'+i));\\n                    a[i]--;\\n                    c++;\\n                }\\n            }\\n            for(i=25;i>=0;i--)\\n            {\\n                if(a[i]>0)\\n                {\\n                    nm.append((char)(\\'a\\'+i));\\n                    a[i]--;\\n                    c++;\\n                }\\n            }\\n        }\\n        return nm.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public String sortString(String s) {\\n        int a[]=new int[26];\\n        int i,c=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1398535,
                "title": "python3-beginner-friendly-solution-using-set",
                "content": "```\\n    def sortString(self, s: str) -> str:\\n        totalist = list(s)\\n        my_list = []\\n        count = False #sort asc\\n        while len(totalist) != 0:\\n            if(count == False):\\n                set1 = sorted(set(s))\\n                count = True\\n            else:\\n                set1 = sorted(set(s),reverse=True)\\n                count = False\\n               \\n            for i in set1:\\n                my_list.append(i)\\n                totalist.remove(i)\\n           \\n            s = \\'\\'.join(map(str, totalist)) \\n        s = \"\"\\n        return s.join(my_list)\\n```",
                "solutionTags": [],
                "code": "```\\n    def sortString(self, s: str) -> str:\\n        totalist = list(s)\\n        my_list = []\\n        count = False #sort asc\\n        while len(totalist) != 0:\\n            if(count == False):\\n                set1 = sorted(set(s))\\n                count = True\\n            else:\\n                set1 = sorted(set(s),reverse=True)\\n                count = False\\n               \\n            for i in set1:\\n                my_list.append(i)\\n                totalist.remove(i)\\n           \\n            s = \\'\\'.join(map(str, totalist)) \\n        s = \"\"\\n        return s.join(my_list)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1397127,
                "title": "count-sort-o-n-time-o-n-space-explained",
                "content": "Count all chars we have in the string. It takes **O(N) time, O(1) space** because `ALPHABET_LEN` is a constant.\\nNext we can append chars to the `result` array **(O(N) space)** in the order we need by using a flag `isForward` and iterating over a chars counter untill the result is complete `s.length - result.length === 0` which takes **O(26N) == O(N) time**. In the end we simpy return a string, joined from our `result` chars array.\\n\\n**FYI:** In case if we use string instead of an array it would be **O(1) space**, but it works slower due to the string immutability and memory allocation.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar sortString = function(s) {\\n    const START = \\'a\\'.charCodeAt(0);\\n    const ALPHABET_LEN = 26;\\n    const counter = new Array(ALPHABET_LEN).fill(0);\\n    const len = s.length;\\n    \\n    for (const ch of s) {\\n        ++counter[ch.charCodeAt(0) - START];\\n    }\\n    \\n    const result = [];\\n    let isForward = true\\n    \\n    while (len - result.length > 0) {\\n        for (let i = 0; i < ALPHABET_LEN; ++i) {\\n            const chIdx = isForward ? i : ALPHABET_LEN - i - 1;\\n            appendChar(chIdx);\\n        }\\n        isForward = !isForward;\\n    }\\n    \\n    return result.join(\\'\\');\\n    \\n    function appendChar(chIdx) {\\n        if (counter[chIdx] > 0) {\\n            result.push(String.fromCharCode(START + chIdx));\\n            --counter[chIdx];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar sortString = function(s) {\\n    const START = \\'a\\'.charCodeAt(0);\\n    const ALPHABET_LEN = 26;\\n    const counter = new Array(ALPHABET_LEN).fill(0);\\n    const len = s.length;\\n    \\n    for (const ch of s) {\\n        ++counter[ch.charCodeAt(0) - START];\\n    }\\n    \\n    const result = [];\\n    let isForward = true\\n    \\n    while (len - result.length > 0) {\\n        for (let i = 0; i < ALPHABET_LEN; ++i) {\\n            const chIdx = isForward ? i : ALPHABET_LEN - i - 1;\\n            appendChar(chIdx);\\n        }\\n        isForward = !isForward;\\n    }\\n    \\n    return result.join(\\'\\');\\n    \\n    function appendChar(chIdx) {\\n        if (counter[chIdx] > 0) {\\n            result.push(String.fromCharCode(START + chIdx));\\n            --counter[chIdx];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1356668,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn sort_string(s: String) -> String {\\n        let mut res = String::with_capacity(s.len());\\n        let mut counter = [0; 26];\\n        let (mut incr, mut ind) = (1, 0);\\n\\n        s.as_bytes()\\n            .iter()\\n            .for_each(|b| counter[(*b - b\\'a\\') as usize] += 1);\\n\\n        while res.len() < s.len() {\\n            if counter[ind as usize] > 0 {\\n                res.push((b\\'a\\' + ind as u8) as char);\\n                counter[ind as usize] -= 1;\\n            };\\n\\n            ind += incr;\\n            if ind < 0 || ind > 25 {\\n                ind = if ind < 0 { 0 } else { 25 }; // ind.clamp(0, 25) doesn\\'t work in this old version of Rust\\n                incr *= -1;\\n            };\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn sort_string(s: String) -> String {\\n        let mut res = String::with_capacity(s.len());\\n        let mut counter = [0; 26];\\n        let (mut incr, mut ind) = (1, 0);\\n\\n        s.as_bytes()\\n            .iter()\\n            .for_each(|b| counter[(*b - b\\'a\\') as usize] += 1);\\n\\n        while res.len() < s.len() {\\n            if counter[ind as usize] > 0 {\\n                res.push((b\\'a\\' + ind as u8) as char);\\n                counter[ind as usize] -= 1;\\n            };\\n\\n            ind += incr;\\n            if ind < 0 || ind > 25 {\\n                ind = if ind < 0 { 0 } else { 25 }; // ind.clamp(0, 25) doesn\\'t work in this old version of Rust\\n                incr *= -1;\\n            };\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351461,
                "title": "faster-than-97-99-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string sortString(string s) {\\n        string str;\\n        vector<int> freq(26,0);\\n        for(int i = 0; i<s.size();i++){\\n            freq[s[i] - \\'a\\']++;\\n        }\\n        while(str.size()!=s.size()){\\n            for(int i = 0; i<26;i++){\\n                if(freq[i]!=0){\\n                    str+= \\'a\\'+ i;\\n                    freq[i]--;\\n                }\\n            }\\n            for(int i = 25; i>=0;i--){\\n                if(freq[i]!=0){\\n                    str+= \\'a\\'+ i;\\n                    freq[i]--;\\n                }\\n            }\\n        }\\n            \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string sortString(string s) {\\n        string str;\\n        vector<int> freq(26,0);\\n        for(int i = 0; i<s.size();i++){\\n            freq[s[i] - \\'a\\']++;\\n        }\\n        while(str.size()!=s.size()){\\n            for(int i = 0; i<26;i++){\\n                if(freq[i]!=0){\\n                    str+= \\'a\\'+ i;\\n                    freq[i]--;\\n                }\\n            }\\n            for(int i = 25; i>=0;i--){\\n                if(freq[i]!=0){\\n                    str+= \\'a\\'+ i;\\n                    freq[i]--;\\n                }\\n            }\\n        }\\n            \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340370,
                "title": "python3-dictionary-solution-o-n-time",
                "content": "\\tclass Solution:\\n\\t\\tdef sortString(self, s: str) -> str:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tRuntime: 52 ms, faster than 97.69% of Python3 online submissions for Increasing Decreasing String.\\n\\t\\t\\tMemory Usage: 14.1 MB, less than 85.05% of Python3 online submissions for Increasing Decreasing String.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmyDict=defaultdict(int)\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tmyDict[i]+=1\\n\\t\\t\\tmyList=sorted(list(myDict.keys()))\\n\\t\\t\\tresult=\\'\\'\\n\\t\\t\\twhile myDict:\\n\\t\\t\\t\\tfor key in myList:\\n\\t\\t\\t\\t\\tif key in myDict:\\n\\t\\t\\t\\t\\t\\tresult+=key\\n\\t\\t\\t\\t\\t\\tmyDict[key]-=1\\n\\t\\t\\t\\t\\t\\tif myDict[key]==0:\\n\\t\\t\\t\\t\\t\\t\\tdel myDict[key]\\n\\t\\t\\t\\tmyList=myList[::-1]\\n\\t\\t\\treturn result",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sortString(self, s: str) -> str:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tRuntime: 52 ms, faster than 97.69% of Python3 online submissions for Increasing Decreasing String.\\n\\t\\t\\tMemory Usage: 14.1 MB, less than 85.05% of Python3 online submissions for Increasing Decreasing String.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmyDict=defaultdict(int)\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tmyDict[i]+=1\\n\\t\\t\\tmyList=sorted(list(myDict.keys()))\\n\\t\\t\\tresult=\\'\\'\\n\\t\\t\\twhile myDict:\\n\\t\\t\\t\\tfor key in myList:\\n\\t\\t\\t\\t\\tif key in myDict:\\n\\t\\t\\t\\t\\t\\tresult+=key\\n\\t\\t\\t\\t\\t\\tmyDict[key]-=1\\n\\t\\t\\t\\t\\t\\tif myDict[key]==0:\\n\\t\\t\\t\\t\\t\\t\\tdel myDict[key]\\n\\t\\t\\t\\tmyList=myList[::-1]\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 1340313,
                "title": "java-simple-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder result = new StringBuilder();\\n\\t\\t\\n\\t\\t//All the characters from \\'s\\' is traversed and its count is updated in charArr as below\\n        int[] charArr = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            charArr[s.charAt(i)-\\'a\\']++;\\n        }\\n\\t\\t\\n\\t\\t//until the stringbuilder\\'s length is equal to \\'s\\' length, we traverse forward and backward and push characters where we find count>0 and decrement the count in charrArr, we do forward and backward since the array will hold the count of sorted character.\\n\\t\\t\\n        boolean isAscending = true;\\n        int i=0;\\n        while(result.length()<s.length()){\\n\\t\\t\\t//on forward when pointer reaches one after the end we reset it to end and move reverse\\n            if(isAscending && i==26){\\n                i=25;\\n                isAscending = false;\\n            }\\n\\t\\t\\t//on reverse when pointer reaches one before the start we reset it to start and move forward\\n            if(!isAscending && i==-1){\\n                i=0;\\n                isAscending = true;\\n            }\\n            if(charArr[i]>0){\\n                result.append((char)(i+\\'a\\'));\\n                charArr[i]--;\\n            }\\n            if(isAscending){\\n                i++;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder result = new StringBuilder();\\n\\t\\t\\n\\t\\t//All the characters from \\'s\\' is traversed and its count is updated in charArr as below\\n        int[] charArr = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            charArr[s.charAt(i)-\\'a\\']++;\\n        }\\n\\t\\t\\n\\t\\t//until the stringbuilder\\'s length is equal to \\'s\\' length, we traverse forward and backward and push characters where we find count>0 and decrement the count in charrArr, we do forward and backward since the array will hold the count of sorted character.\\n\\t\\t\\n        boolean isAscending = true;\\n        int i=0;\\n        while(result.length()<s.length()){\\n\\t\\t\\t//on forward when pointer reaches one after the end we reset it to end and move reverse\\n            if(isAscending && i==26){\\n                i=25;\\n                isAscending = false;\\n            }\\n\\t\\t\\t//on reverse when pointer reaches one before the start we reset it to start and move forward\\n            if(!isAscending && i==-1){\\n                i=0;\\n                isAscending = true;\\n            }\\n            if(charArr[i]>0){\\n                result.append((char)(i+\\'a\\'));\\n                charArr[i]--;\\n            }\\n            if(isAscending){\\n                i++;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287872,
                "title": "easy-c-solution",
                "content": "(\\'\\'\\') class Solution {\\npublic:\\n    string sortString(string s) {\\n        \\n        vector<int> freq(26, 0);\\n        \\n        for(int i=0; i<s.size( ); i++){\\n            \\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n        string res = \"\";\\n        \\n        while(res.size( ) < s.size( )){\\n            \\n            for(int i = 0; i < 26; i++){\\n                \\n                \\n                if(freq[i] > 0){\\n                    \\n                    char ch = \\'a\\' + i;\\n                    \\n                    res.push_back(ch);\\n                    \\n                    freq[i]--;\\n                }\\n            }\\n            \\n            for(int i=25; i >= 0; i--){\\n                    \\n                 if(freq[i] > 0){\\n                    \\n                    char ch = \\'a\\' + i;\\n                    \\n                    res.push_back(ch);\\n                    \\n                    freq[i]--;\\n                }\\n                \\n            }\\n        }\\n        \\n        return res;  \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string sortString(string s) {\\n        \\n        vector<int> freq(26, 0);\\n        \\n        for(int i=0; i<s.size( ); i++){\\n            \\n            freq[s[i]-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1273300,
                "title": "c-solution",
                "content": "```\\npublic string SortString(string s)\\n{\\n\\tint[] freq = new int[26];\\n\\n\\tforeach (char a in s)\\n\\t{\\n\\t\\tfreq[a - \\'a\\']++;\\n\\t}\\n\\n\\tStringBuilder sb = new StringBuilder();\\n\\n\\tint count = s.Length;\\n\\n\\twhile (count > 0)\\n\\t{\\n\\t\\t// smallest\\n\\t\\tfor (int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tif (freq[i] > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.Append((char)(i + \\'a\\'));\\n\\t\\t\\t\\tfreq[i]--;\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// largest\\n\\t\\tfor (int i = 25; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif (freq[i] > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.Append((char)(i + \\'a\\'));\\n\\t\\t\\t\\tfreq[i]--;\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn sb.ToString();\\n}\\n```",
                "solutionTags": [
                    "String",
                    "Enumeration"
                ],
                "code": "```\\npublic string SortString(string s)\\n{\\n\\tint[] freq = new int[26];\\n\\n\\tforeach (char a in s)\\n\\t{\\n\\t\\tfreq[a - \\'a\\']++;\\n\\t}\\n\\n\\tStringBuilder sb = new StringBuilder();\\n\\n\\tint count = s.Length;\\n\\n\\twhile (count > 0)\\n\\t{\\n\\t\\t// smallest\\n\\t\\tfor (int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tif (freq[i] > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.Append((char)(i + \\'a\\'));\\n\\t\\t\\t\\tfreq[i]--;\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// largest\\n\\t\\tfor (int i = 25; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif (freq[i] > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.Append((char)(i + \\'a\\'));\\n\\t\\t\\t\\tfreq[i]--;\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn sb.ToString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1263160,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    \\n    StringBuilder sb = new StringBuilder();\\n    \\n    int alpha[] = new int[26];\\n    \\n    int len = 0;\\n    \\n    public void traverse(int type){\\n        if(type==1){\\n            for(int i=0;i<26;i++){\\n                if(len==0){return;}\\n                if(alpha[i]>0){alpha[i]--;sb.append((char)(\\'a\\'+i));len--;}\\n            }\\n        }\\n        else{\\n            for(int i=25;i>=0;i--){\\n                if(len==0){return;}\\n                if(alpha[i]>0){alpha[i]--;sb.append((char)(\\'a\\'+i));len--;}\\n            }\\n        }\\n    }\\n    public String sortString(String s) {\\n        \\n        \\n        for(char x:s.toCharArray()){alpha[x-\\'a\\']+=1;}\\n        \\n        len=s.length();\\n        int type=1;\\n        while(len>0){\\n            traverse(type);\\n            type*=-1;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    StringBuilder sb = new StringBuilder();\\n    \\n    int alpha[] = new int[26];\\n    \\n    int len = 0;\\n    \\n    public void traverse(int type){\\n        if(type==1){\\n            for(int i=0;i<26;i++){\\n                if(len==0){return;}\\n                if(alpha[i]>0){alpha[i]--;sb.append((char)(\\'a\\'+i));len--;}\\n            }\\n        }\\n        else{\\n            for(int i=25;i>=0;i--){\\n                if(len==0){return;}\\n                if(alpha[i]>0){alpha[i]--;sb.append((char)(\\'a\\'+i));len--;}\\n            }\\n        }\\n    }\\n    public String sortString(String s) {\\n        \\n        \\n        for(char x:s.toCharArray()){alpha[x-\\'a\\']+=1;}\\n        \\n        len=s.length();\\n        int type=1;\\n        while(len>0){\\n            traverse(type);\\n            type*=-1;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260226,
                "title": "c-beginner-stl-map",
                "content": "```\\nstring sortString(string s) {\\n\\tint l = s.size();\\n\\tmap<char, int> m;\\n\\tfor (auto i : s) { \\t\\tm[i]++;\\t}\\n\\ts.clear();\\n\\t// algo begin\\n\\twhile (l) {\\n\\t\\tfor (auto it = m.begin(); it != m.end(); ++it) {\\n\\t\\t\\tif (it->second) {\\n\\t\\t\\t\\ts += it->first;\\n\\t\\t\\t\\t--it->second;\\n\\t\\t\\t\\tl--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!l) break;\\n\\t\\tfor (auto it = m.rbegin(); it != m.rend(); ++it) {\\n\\t\\t\\tif (it->second) {\\n\\t\\t\\t\\ts += it->first;\\n\\t\\t\\t\\t--it->second;\\n\\t\\t\\t\\tl--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn s;\\n}\\n```\\n\\n**** Notice*****\\nNever try to delete any node by iterator during Looping, or you are grueling yourself in keep the map runs will.\\n\\nI tried 3 hours then abandoned.\\n\\nIf you still liked that, and you climbed the top of it.  Please let me study your code. [the validation of reverse_interator and erease(rit) were still mocking me]\\n\\n",
                "solutionTags": [],
                "code": "```\\nstring sortString(string s) {\\n\\tint l = s.size();\\n\\tmap<char, int> m;\\n\\tfor (auto i : s) { \\t\\tm[i]++;\\t}\\n\\ts.clear();\\n\\t// algo begin\\n\\twhile (l) {\\n\\t\\tfor (auto it = m.begin(); it != m.end(); ++it) {\\n\\t\\t\\tif (it->second) {\\n\\t\\t\\t\\ts += it->first;\\n\\t\\t\\t\\t--it->second;\\n\\t\\t\\t\\tl--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!l) break;\\n\\t\\tfor (auto it = m.rbegin(); it != m.rend(); ++it) {\\n\\t\\t\\tif (it->second) {\\n\\t\\t\\t\\ts += it->first;\\n\\t\\t\\t\\t--it->second;\\n\\t\\t\\t\\tl--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1254497,
                "title": "java-naive-solution-with-comments-easy-solution",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int totalChar=s.length();\\n        int counter[]=new int[26];\\n        \\n        for(char ch:s.toCharArray()){\\n            counter[ch-\\'a\\']++;\\n        }\\n        int i=0;\\n        \\n        //this flag will help to tell us the direction in which we need to traverse\\n        boolean reverse=false;\\n        \\n        //using StringBuilder because it takes less time to update as compared to String\\n        StringBuilder sb=new StringBuilder();\\n        \\n        //since the total number of characters in output will be same as input\\n        while(i<totalChar){\\n            \\n            //initially traversing string left to right\\n            if(reverse==false){\\n                for(int j=0;j<26 && i<totalChar;j++){\\n                    if(counter[j]!=0){\\n                        counter[j]--;\\n                        i++;\\n                        sb.append((char)(\\'a\\'+j));\\n                    }\\n                }\\n                //since we traverse till the end of the list, reversing the direction\\n                reverse=!reverse;\\n            }\\n            \\n             //traversing string right to left\\n            if(reverse==true){\\n                for(int j=25;j>=0 && i<totalChar;j--){\\n                    if(counter[j]!=0){\\n                        counter[j]--;\\n                        i++;\\n                        sb.append((char)(\\'a\\'+j));\\n                    }\\n                }\\n                reverse=!reverse;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String sortString(String s) {\\n        int totalChar=s.length();\\n        int counter[]=new int[26];\\n        \\n        for(char ch:s.toCharArray()){\\n            counter[ch-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1231600,
                "title": "python3-python-code",
                "content": "\\tdef sortString(self, s: str) -> str:\\n        res = \"\"\\n        while s != \"\":\\n            res += \"\".join(sorted(set(s)))\\n            for i in set(s):\\n                s = s.replace(i, \"\", 1)\\n            res += \"\".join(sorted(set(s), reverse=True))\\n            for i in set(s):\\n                s = s.replace(i, \"\", 1)\\n        return res\\n\\t\\t``\\n\\t\\t\\nif you need an explanation, write a comment to me plz.",
                "solutionTags": [],
                "code": "\\tdef sortString(self, s: str) -> str:\\n        res = \"\"\\n        while s != \"\":\\n            res += \"\".join(sorted(set(s)))\\n            for i in set(s):\\n                s = s.replace(i, \"\", 1)\\n            res += \"\".join(sorted(set(s), reverse=True))\\n            for i in set(s):\\n                s = s.replace(i, \"\", 1)\\n        return res\\n\\t\\t``\\n\\t\\t\\nif you need an explanation, write a comment to me plz.",
                "codeTag": "Python3"
            },
            {
                "id": 1205643,
                "title": "python3-solution-using-dictionary",
                "content": "class Solution:\\n\\n    def sortString(self, s: str) -> str:\\n        d={}\\n        \\n        for i in s:\\n            if i not in d:\\n                d[i]=1\\n            else:\\n                d[i]+=1\\n        res=\\'\\'\\n        keys = sorted(d.keys())\\n        \\n        while True:\\n            if len(res)==len(s):\\n                return res\\n            for i in keys + keys[::-1]:\\n                if d[i]>0:\\n                    res+=i\\n                    d[i]-=1\\n        return res\\n                \\n                    \\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def sortString(self, s: str) -> str:\\n        d={}",
                "codeTag": "Java"
            },
            {
                "id": 1203749,
                "title": "easiest-of-them-all-java",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        char[] arr = new char[28];\\n        for(int i = 0; i < s.length(); i++){\\n            int x = s.charAt(i) - \\'a\\' + 1;\\n            arr[x]++;\\n        }\\n        int t = 0;\\n        int k = 0;\\n        String result = \"\";\\n        while(result.length() < s.length()){\\n            if(arr[t] > 0){\\n                arr[t]--;\\n                result += (char) (\\'a\\' + t - 1);\\n            }\\n            if(t == 27){\\n                k = 1;\\n            }\\n            if(t == 0){\\n                k = 0;\\n            }\\n            if(k == 0){\\n                t++;\\n            }\\n            if(k == 1){\\n                t--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        char[] arr = new char[28];\\n        for(int i = 0; i < s.length(); i++){\\n            int x = s.charAt(i) - \\'a\\' + 1;\\n            arr[x]++;\\n        }\\n        int t = 0;\\n        int k = 0;\\n        String result = \"\";\\n        while(result.length() < s.length()){\\n            if(arr[t] > 0){\\n                arr[t]--;\\n                result += (char) (\\'a\\' + t - 1);\\n            }\\n            if(t == 27){\\n                k = 1;\\n            }\\n            if(t == 0){\\n                k = 0;\\n            }\\n            if(k == 0){\\n                t++;\\n            }\\n            if(k == 1){\\n                t--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185140,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar sortString = function(s) {\\n\\t\\tconst map = {};\\n\\t\\tconst sort = [...new Set(s)].sort((a, b) => a.localeCompare(b));\\n\\t\\tlet increase = true;\\n\\t\\tlet result = \\'\\';\\n\\n\\t\\t[...s].forEach(s => map[s] = s in map ? map[s] + 1 : 1)\\n\\n\\t\\twhile (result.length < s.length) {\\n\\t\\t\\tresult += sort[increase ? \\'reduce\\' : \\'reduceRight\\']((acc, curr) => {\\n\\t\\t\\t\\tif (map[curr]) {\\n\\t\\t\\t\\t\\tmap[curr] -= 1\\n\\t\\t\\t\\t\\treturn acc + curr\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse return acc\\n\\t\\t\\t}, \\'\\')\\n\\t\\t\\tincrease = !increase\\n\\t\\t}\\n\\t\\treturn result\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar sortString = function(s) {\\n\\t\\tconst map = {};\\n\\t\\tconst sort = [...new Set(s)].sort((a, b) => a.localeCompare(b));\\n\\t\\tlet increase = true;\\n\\t\\tlet result = \\'\\';\\n\\n\\t\\t[...s].forEach(s => map[s] = s in map ? map[s] + 1 : 1)\\n\\n\\t\\twhile (result.length < s.length) {\\n\\t\\t\\tresult += sort[increase ? \\'reduce\\' : \\'reduceRight\\']((acc, curr) => {\\n\\t\\t\\t\\tif (map[curr]) {\\n\\t\\t\\t\\t\\tmap[curr] -= 1\\n\\t\\t\\t\\t\\treturn acc + curr\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse return acc\\n\\t\\t\\t}, \\'\\')\\n\\t\\t\\tincrease = !increase\\n\\t\\t}\\n\\t\\treturn result\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1171431,
                "title": "python-using-counter-52ms-95",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        cntr = Counter(s)\\n        set_s = sorted(cntr.keys())\\n\\t\\tres = \\'\\'\\n        while len(res) < len(s):\\n            for c in set_s:\\n                if cntr[c]:\\n                    res += c\\n                    cntr[c] -= 1\\n            set_s = set_s[::-1]\\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        cntr = Counter(s)\\n        set_s = sorted(cntr.keys())\\n\\t\\tres = \\'\\'\\n        while len(res) < len(s):\\n            for c in set_s:\\n                if cntr[c]:\\n                    res += c\\n                    cntr[c] -= 1\\n            set_s = set_s[::-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038550,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] freq = new int[26];\\n        \\n        for (char ch : s.toCharArray()) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        while (count < s.length()) {\\n            for (int i = 0; i < 26; ++i) {\\n                if (freq[i] > 0) {\\n                    sb.append((char)(\\'a\\' + i));\\n                    count++;\\n                    freq[i]--;\\n                }\\n            }\\n            \\n            for (int i = 25; i >= 0; --i) {\\n                if (freq[i] > 0) {\\n                    sb.append((char)(\\'a\\' + i));\\n                    count++;\\n                    freq[i]--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] freq = new int[26];\\n        \\n        for (char ch : s.toCharArray()) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        while (count < s.length()) {\\n            for (int i = 0; i < 26; ++i) {\\n                if (freq[i] > 0) {\\n                    sb.append((char)(\\'a\\' + i));\\n                    count++;\\n                    freq[i]--;\\n                }\\n            }\\n            \\n            for (int i = 25; i >= 0; --i) {\\n                if (freq[i] > 0) {\\n                    sb.append((char)(\\'a\\' + i));\\n                    count++;\\n                    freq[i]--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029127,
                "title": "simple-map-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string res = \"\";\\n        map<char,int> record;\\n        int n = s.size();\\n        for(int i=0; i<n; i++){\\n            record[s[i]]++;\\n        }\\n        int cnt = 0;\\n        while(cnt<n){\\n            for(auto it = record.begin(); (cnt <n && it!=record.end()); it++){\\n                if(it->second > 0){\\n                    res += it->first;\\n                    it->second--;\\n                    cnt++;\\n                }\\n            }\\n            for(auto it=record.rbegin(); (cnt<n && it!=record.rend()); it++){\\n                //increment the reverse iterator\\n                if(it->second > 0){\\n                    res += it->first;\\n                    it->second--;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        string res = \"\";\\n        map<char,int> record;\\n        int n = s.size();\\n        for(int i=0; i<n; i++){\\n            record[s[i]]++;\\n        }\\n        int cnt = 0;\\n        while(cnt<n){\\n            for(auto it = record.begin(); (cnt <n && it!=record.end()); it++){\\n                if(it->second > 0){\\n                    res += it->first;\\n                    it->second--;\\n                    cnt++;\\n                }\\n            }\\n            for(auto it=record.rbegin(); (cnt<n && it!=record.rend()); it++){\\n                //increment the reverse iterator\\n                if(it->second > 0){\\n                    res += it->first;\\n                    it->second--;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986362,
                "title": "java-easy-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        // To store the values of the 26 letter alphabets\\n\\t\\tint[] ch = new int[26];\\n        \\n\\t\\t//loop through the string and store the value in the correct index in the ch array\\n\\t\\t// (ch-97) is to get the index between 0 to 25 to fit in the ch array\\n\\t\\t// This is needed to count the frequency of each character available\\n        for (int i = 0;i<s.length();i++){\\n            int index = s.charAt(i) - 97;\\n            ch[index]++;\\n        }\\n        \\n\\t\\tStringBuilder sb = new StringBuilder();\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        //loop through the length of the string\\n\\t\\t// i - varible to track a to z index in ch array\\n\\t\\t// j - variable for tracking string index\\n        while (j < s.length()){\\n            // loop from a to z index and append appropriate index to the string builder\\n\\t\\t\\t// ch[i]-- is to reduce the frequency\\n            while (i < ch.length){\\n                if (ch[i]-- > 0)\\n                    sb.append((char)(97+i));\\n                i++;\\n            }\\n            i--;\\n            \\n            // loop from z to a index\\n            while (i >= 0){\\n                if (ch[i]-- > 0)\\n                    sb.append((char)(97+i));\\n                i--;\\n            }\\n            i++;\\n            j = sb.toString().length(); //modified from j++ as per the comment below\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        // To store the values of the 26 letter alphabets\\n\\t\\tint[] ch = new int[26];\\n        \\n\\t\\t//loop through the string and store the value in the correct index in the ch array\\n\\t\\t// (ch-97) is to get the index between 0 to 25 to fit in the ch array\\n\\t\\t// This is needed to count the frequency of each character available\\n        for (int i = 0;i<s.length();i++){\\n            int index = s.charAt(i) - 97;\\n            ch[index]++;\\n        }\\n        \\n\\t\\tStringBuilder sb = new StringBuilder();\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        //loop through the length of the string\\n\\t\\t// i - varible to track a to z index in ch array\\n\\t\\t// j - variable for tracking string index\\n        while (j < s.length()){\\n            // loop from a to z index and append appropriate index to the string builder\\n\\t\\t\\t// ch[i]-- is to reduce the frequency\\n            while (i < ch.length){\\n                if (ch[i]-- > 0)\\n                    sb.append((char)(97+i));\\n                i++;\\n            }\\n            i--;\\n            \\n            // loop from z to a index\\n            while (i >= 0){\\n                if (ch[i]-- > 0)\\n                    sb.append((char)(97+i));\\n                i--;\\n            }\\n            i++;\\n            j = sb.toString().length(); //modified from j++ as per the comment below\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960086,
                "title": "python-faster-than-100",
                "content": "```\\nd = {}\\nfor char in s:\\n\\td[char] = d.get(char, 0) + 1\\nprint(d, sorted(d.keys())[::-1])\\n\\nfinal = \"\"\\n        \\ndef rearrange(final, sorted_keys):\\n\\tfor char in sorted_keys:\\n\\t\\tfinal += char\\n\\t\\td[char] -= 1\\n\\t\\tif d[char] == 0:\\n\\t\\t\\tdel d[char]\\n\\treturn final\\n\\nwhile d:\\n\\tfinal = rearrange(final, sorted(d.keys()))\\n\\tfinal = rearrange(final, sorted(d.keys())[::-1])\\n\\t# print(final, d)\\nreturn final",
                "solutionTags": [],
                "code": "```\\nd = {}\\nfor char in s:\\n\\td[char] = d.get(char, 0) + 1\\nprint(d, sorted(d.keys())[::-1])\\n\\nfinal = \"\"\\n        \\ndef rearrange(final, sorted_keys):\\n\\tfor char in sorted_keys:\\n\\t\\tfinal += char\\n\\t\\td[char] -= 1\\n\\t\\tif d[char] == 0:\\n\\t\\t\\tdel d[char]\\n\\treturn final\\n\\nwhile d:\\n\\tfinal = rearrange(final, sorted(d.keys()))\\n\\tfinal = rearrange(final, sorted(d.keys())[::-1])\\n\\t# print(final, d)\\nreturn final",
                "codeTag": "Python3"
            },
            {
                "id": 948427,
                "title": "12-line-concise-pyhton-solution",
                "content": "1. Counter the number of different characters in `s`, saved as `dic`.\\n2. Use `li`and `li[::-1]` to get sorted keys of `dic`.\\n3. Traverse `li` and `li[::-1]`, update `dic` and add valid character into the end of `ret` until `len(ret) == len(s)`.\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        dic = Counter(s)\\n        li = sorted(dic.keys())\\n        ret = \\'\\'\\n        while len(ret) < len(s):\\n            for c in [*li, *li[::-1]]:\\n                if dic[c]:\\n                    ret += c\\n                    dic[c] -= 1\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        dic = Counter(s)\\n        li = sorted(dic.keys())\\n        ret = \\'\\'\\n        while len(ret) < len(s):\\n            for c in [*li, *li[::-1]]:\\n                if dic[c]:\\n                    ret += c\\n                    dic[c] -= 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940638,
                "title": "c-97",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(const string& s) {\\n        const int len=26;\\n        \\n        vector<int> v(len);\\n        for(auto i:s) ++v[i-\\'a\\'];\\n        \\n        string res;\\n        while(res.size()<s.size()) {\\n            \\n            for(int i=0; i<len; ++i)\\n                if(v[i]) {res+=i+\\'a\\'; --v[i];}\\n            \\n            for(int i=len-1; i>-1; --i)\\n                if(v[i]) {res+=i+\\'a\\'; --v[i];}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(const string& s) {\\n        const int len=26;\\n        \\n        vector<int> v(len);\\n        for(auto i:s) ++v[i-\\'a\\'];\\n        \\n        string res;\\n        while(res.size()<s.size()) {\\n            \\n            for(int i=0; i<len; ++i)\\n                if(v[i]) {res+=i+\\'a\\'; --v[i];}\\n            \\n            for(int i=len-1; i>-1; --i)\\n                if(v[i]) {res+=i+\\'a\\'; --v[i];}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933812,
                "title": "python-3-runtime-faster-than-96-23",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        letterOrder = [\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\',\\n                       \\'l\\', \\'m\\', \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n\\n        def addSmallToLarge(result=str, s=str, letterOrder=list):\\n            for i in range(len(letterOrder)):\\n                if letterOrder[i] in s:\\n                    result += letterOrder[i]\\n                    s = s.replace(letterOrder[i], \\'\\', 1)\\n\\n            return result, s\\n\\n        def addLargeToSmall(result=str, s=str, letterOrder=list):\\n            for i in reversed(range(len(letterOrder))):\\n                if letterOrder[i] in s:\\n                    result += letterOrder[i]\\n                    s = s.replace(letterOrder[i], \\'\\', 1)\\n\\n            return result, s\\n\\n        result = \\'\\'\\n        while s != \\'\\':\\n            result, s = addSmallToLarge(result, s, letterOrder)\\n            result, s = addLargeToSmall(result, s, letterOrder)\\n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        letterOrder = [\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\',\\n                       \\'l\\', \\'m\\', \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n\\n        def addSmallToLarge(result=str, s=str, letterOrder=list):\\n            for i in range(len(letterOrder)):\\n                if letterOrder[i] in s:\\n                    result += letterOrder[i]\\n                    s = s.replace(letterOrder[i], \\'\\', 1)\\n\\n            return result, s\\n\\n        def addLargeToSmall(result=str, s=str, letterOrder=list):\\n            for i in reversed(range(len(letterOrder))):\\n                if letterOrder[i] in s:\\n                    result += letterOrder[i]\\n                    s = s.replace(letterOrder[i], \\'\\', 1)\\n\\n            return result, s\\n\\n        result = \\'\\'\\n        while s != \\'\\':\\n            result, s = addSmallToLarge(result, s, letterOrder)\\n            result, s = addLargeToSmall(result, s, letterOrder)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930252,
                "title": "python-3-solution-using-hash-100-space-79-runtime",
                "content": "```\\ndef sortString(self, s: str) -> str:\\n\\tl_original = len(s)\\n\\tdic = collections.Counter(s)\\n\\ts = sorted(set(s))\\n\\tl_set = len(s)\\n\\tl_res = 0\\n\\tres = \"\"\\n\\twhile l_res<l_original:\\n\\t\\tfor i in range(0, l_set):\\n\\t\\t\\tif dic[s[i]]:\\n\\t\\t\\t\\tres+=s[i]\\n\\t\\t\\t\\tdic[s[i]]-=1\\n\\t\\t\\t\\tl_res+=1\\n\\t\\tfor i in range(l_set-1, -1, -1):\\n\\t\\t\\tif dic[s[i]]:\\n\\t\\t\\t\\tres+=s[i]\\n\\t\\t\\t\\tdic[s[i]]-=1\\n\\t\\t\\t\\tl_res+=1\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\ndef sortString(self, s: str) -> str:\\n\\tl_original = len(s)\\n\\tdic = collections.Counter(s)\\n\\ts = sorted(set(s))\\n\\tl_set = len(s)\\n\\tl_res = 0\\n\\tres = \"\"\\n\\twhile l_res<l_original:\\n\\t\\tfor i in range(0, l_set):\\n\\t\\t\\tif dic[s[i]]:\\n\\t\\t\\t\\tres+=s[i]\\n\\t\\t\\t\\tdic[s[i]]-=1\\n\\t\\t\\t\\tl_res+=1\\n\\t\\tfor i in range(l_set-1, -1, -1):\\n\\t\\t\\tif dic[s[i]]:\\n\\t\\t\\t\\tres+=s[i]\\n\\t\\t\\t\\tdic[s[i]]-=1\\n\\t\\t\\t\\tl_res+=1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 921086,
                "title": "java-o-n-100-faster",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        \\n        int start = 25;\\n        int end = 0;\\n        int [] map = new int[26];\\n\\n        for(char c : s.toCharArray()) {\\n            if(c - \\'a\\'< start) start = c - \\'a\\';\\n            if(c - \\'a\\'> end) end = c - \\'a\\';\\n            map[c-\\'a\\']++;\\n        }\\n\\n        int count = s.length(), j = 0;\\n        char[] c = new char[count];\\n\\n        while(count > 0){\\n            for(int i = start; i <= end; i++)\\n                if(map[i]-- > 0) {c[j++] = (char)(i+\\'a\\');count--;}\\n            \\n            for(int i = end; i >= start; i--)\\n                if(map[i]-- > 0) {c[j++] = (char)(i+\\'a\\');count--;}\\n            \\n        }\\n        return new StringBuilder().append(c).toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        \\n        int start = 25;\\n        int end = 0;\\n        int [] map = new int[26];\\n\\n        for(char c : s.toCharArray()) {\\n            if(c - \\'a\\'< start) start = c - \\'a\\';\\n            if(c - \\'a\\'> end) end = c - \\'a\\';\\n            map[c-\\'a\\']++;\\n        }\\n\\n        int count = s.length(), j = 0;\\n        char[] c = new char[count];\\n\\n        while(count > 0){\\n            for(int i = start; i <= end; i++)\\n                if(map[i]-- > 0) {c[j++] = (char)(i+\\'a\\');count--;}\\n            \\n            for(int i = end; i >= start; i--)\\n                if(map[i]-- > 0) {c[j++] = (char)(i+\\'a\\');count--;}\\n            \\n        }\\n        return new StringBuilder().append(c).toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919939,
                "title": "python-3-collections-ordereddict-approach",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        # Our ordered dict so we can keep the order in which we put our letter, which will be sorted!\\n        letter_dict = collections.OrderedDict()\\n        # Final string to return\\n        final_str = \"\"\\n\\n        # Put our items in our ordered dictionary. The smallest letter\\n        # will always be first this way. The key is the letter and the value is\\n        # the amount of times it appears\\n        for letter in sorted(s):\\n            # Increment the value of the letter if it exists in our dictionary\\n            try:\\n                letter_dict[letter] += 1\\n            # If letter is not in our dict, add it and set its value to one\\n            except KeyError:\\n                letter_dict[letter] = 1\\n\\n        # We\\'re going to go back and forth in our ordered dict until theres nothing left\\n        # because we will delete items when they\\'re value reaches 0\\n        while len(letter_dict) > 0:\\n            # dictionary().keys returns an iterator in Python 3\\n            # which prevents deletion during iteration. By wrapping it around\\n            # list, we turn the keys iterator into a list so that we\\'re not iterating\\n            # the dictionary itself, allowing deletion. In the end, we end up with\\n            # a dictionary size of 0\\n            for key in list(letter_dict.keys()):\\n                # If the value is greater than 0, it means the word still appears in our string\\n                if letter_dict[key] > 0:\\n                    # Add it to our final string\\n                    final_str += key\\n                    # Decrement the value by one\\n                    letter_dict[key] -= 1\\n                else:\\n                    # If the value is 0, delete that key because we don\\'t need it anymore!\\n                    del letter_dict[key]\\n\\n            # Do the same as above, but in reverse\\n            for key in list(reversed(letter_dict.keys())):\\n                # If the value is greater than 0, it means the word still appears in our string\\n                if letter_dict[key] > 0:\\n                    # Add it to our final string\\n                    final_str += key\\n                    # Decrement the value by one\\n                    letter_dict[key] -= 1\\n                else:\\n                    # If the value is 0, delete that key because we don\\'t need it anymore!\\n                    del letter_dict[key]\\n\\n        return final_str\\n    \\n\\'\\'\\'\\nComplexity Analysis\\n-----------------------------\\n\\nFirst, adding to our dictionary is O(n) time and O(n) space\\nThen, the sorted method is O(n Log(n)). Iterating through the\\ndictionary is O(n), where n is the size of the string s.\\n\\nSo we know our space complexity is O(n) plus a small optimization \\nwhere we delete all items by the end of the program\\n\\nThe time complexity comes down to O(n) + O(n Log(n)) + O(n)\\nwhich when we take the dominant term, we get our run time as\\nO(n Log(n))\\n\\n\\nRuntime: 52 ms, faster than 96.89% of Python3 online submissions for Increasing Decreasing String.\\nMemory Usage: 14.3 MB, less than 100.00% of Python3 online submissions for Increasing Decreasing String.\\n\\'\\'\\'\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        # Our ordered dict so we can keep the order in which we put our letter, which will be sorted!\\n        letter_dict = collections.OrderedDict()\\n        # Final string to return\\n        final_str = \"\"\\n\\n        # Put our items in our ordered dictionary. The smallest letter\\n        # will always be first this way. The key is the letter and the value is\\n        # the amount of times it appears\\n        for letter in sorted(s):\\n            # Increment the value of the letter if it exists in our dictionary\\n            try:\\n                letter_dict[letter] += 1\\n            # If letter is not in our dict, add it and set its value to one\\n            except KeyError:\\n                letter_dict[letter] = 1\\n\\n        # We\\'re going to go back and forth in our ordered dict until theres nothing left\\n        # because we will delete items when they\\'re value reaches 0\\n        while len(letter_dict) > 0:\\n            # dictionary().keys returns an iterator in Python 3\\n            # which prevents deletion during iteration. By wrapping it around\\n            # list, we turn the keys iterator into a list so that we\\'re not iterating\\n            # the dictionary itself, allowing deletion. In the end, we end up with\\n            # a dictionary size of 0\\n            for key in list(letter_dict.keys()):\\n                # If the value is greater than 0, it means the word still appears in our string\\n                if letter_dict[key] > 0:\\n                    # Add it to our final string\\n                    final_str += key\\n                    # Decrement the value by one\\n                    letter_dict[key] -= 1\\n                else:\\n                    # If the value is 0, delete that key because we don\\'t need it anymore!\\n                    del letter_dict[key]\\n\\n            # Do the same as above, but in reverse\\n            for key in list(reversed(letter_dict.keys())):\\n                # If the value is greater than 0, it means the word still appears in our string\\n                if letter_dict[key] > 0:\\n                    # Add it to our final string\\n                    final_str += key\\n                    # Decrement the value by one\\n                    letter_dict[key] -= 1\\n                else:\\n                    # If the value is 0, delete that key because we don\\'t need it anymore!\\n                    del letter_dict[key]\\n\\n        return final_str\\n    \\n\\'\\'\\'\\nComplexity Analysis\\n-----------------------------\\n\\nFirst, adding to our dictionary is O(n) time and O(n) space\\nThen, the sorted method is O(n Log(n)). Iterating through the\\ndictionary is O(n), where n is the size of the string s.\\n\\nSo we know our space complexity is O(n) plus a small optimization \\nwhere we delete all items by the end of the program\\n\\nThe time complexity comes down to O(n) + O(n Log(n)) + O(n)\\nwhich when we take the dominant term, we get our run time as\\nO(n Log(n))\\n\\n\\nRuntime: 52 ms, faster than 96.89% of Python3 online submissions for Increasing Decreasing String.\\nMemory Usage: 14.3 MB, less than 100.00% of Python3 online submissions for Increasing Decreasing String.\\n\\'\\'\\'\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878881,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\npublic String sortString(String str) {\\n    StringBuilder sb = new StringBuilder(\"\");\\n\\tint[] map = new int[26];\\n    char[] arr = str.toCharArray();\\n\\tfor (int i=0;i<arr.length;i++)\\n\\t\\tmap[arr[i] - \\'a\\']++;\\n    \\n\\tboolean flag = true;\\n    //Once all the characters are exhauseted the flag cant be reverted back to true as it cant enter the if condition.\\n\\twhile (flag) {\\n\\t\\tflag = false;\\n        //Iterating for the increasing string.\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif(map[i]!=0) {\\n\\t\\t\\t\\tsb.append((char)(i+\\'a\\'));\\n\\t\\t\\t\\tmap[i]--;\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t}\\n\\t\\t}\\n        //Iterating for the decreasing string.\\n\\t\\tfor (int i = 25; i >= 0; i--) {\\n\\t\\t\\tif(map[i]!=0) {\\n\\t\\t\\t\\tsb.append((char)(i+\\'a\\'));\\n\\t\\t\\t\\tmap[i]--;\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn sb.toString();\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic String sortString(String str) {\\n    StringBuilder sb = new StringBuilder(\"\");\\n\\tint[] map = new int[26];\\n    char[] arr = str.toCharArray();\\n\\tfor (int i=0;i<arr.length;i++)\\n\\t\\tmap[arr[i] - \\'a\\']++;\\n    \\n\\tboolean flag = true;\\n    //Once all the characters are exhauseted the flag cant be reverted back to true as it cant enter the if condition.\\n\\twhile (flag) {\\n\\t\\tflag = false;\\n        //Iterating for the increasing string.\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif(map[i]!=0) {\\n\\t\\t\\t\\tsb.append((char)(i+\\'a\\'));\\n\\t\\t\\t\\tmap[i]--;\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t}\\n\\t\\t}\\n        //Iterating for the decreasing string.\\n\\t\\tfor (int i = 25; i >= 0; i--) {\\n\\t\\t\\tif(map[i]!=0) {\\n\\t\\t\\t\\tsb.append((char)(i+\\'a\\'));\\n\\t\\t\\t\\tmap[i]--;\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn sb.toString();\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873858,
                "title": "java-2-solutions-with-explanation",
                "content": "/*\\nExplanation:\\n1) store each char of string in frequency array\\n2) loop till length of ans is not equal to length of string and do following \\n3) two loops one from 0 to 25 and other from 25 to 0\\n4)  if we found char present then append to answer and decrement freq array val \\n*/\\n**Solution**\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int frequency[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            frequency[s.charAt(i)-\\'a\\']++;\\n        }\\n        StringBuilder ans=new StringBuilder();\\n        while(ans.length()!=s.length())\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                if(frequency[i]>0)\\n                {\\n                    ans.append((char)(i+97));\\n                    frequency[i]--;\\n                }\\n            }\\n            for(int i=25;i>=0;i--)\\n            {\\n                if(frequency[i]>0)\\n                {\\n                    ans.append((char)(i+97));\\n                    frequency[i]--;\\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\\n**Solution with one loop pass only**\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int frequency[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            frequency[s.charAt(i)-\\'a\\']++;\\n        }\\n        StringBuilder ans=new StringBuilder();\\n        StringBuilder ans1;\\n        StringBuilder ans2;\\n        while(ans.length()!=s.length())\\n        {\\n            ans1=new StringBuilder();\\n            ans2=new StringBuilder();\\n            for(int i=0;i<26;i++)\\n            {\\n                if(frequency[i]>0)\\n                {\\n                    ans1.append((char)(i+97));\\n                    frequency[i]--;\\n                }\\n\\t\\t\\t\\t//This condition ensures that if letter between M and z should be 2 or more as they are not covered in ans1\\n\\t\\t\\t\\t//but need not to be true and required freq 1 or more for letter from A to M as thy are already cover in asn1\\n                if((frequency[25-i]>1 && 25-i>=12) || (frequency[25-i]>0 && 25-i<=12)) \\n                {\\n                    ans2.append((char)(122-i));\\n                    frequency[25-i]--;\\n                }\\n            }\\n            ans.append(ans1.toString());\\n            ans.append(ans2.toString());\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        int frequency[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            frequency[s.charAt(i)-\\'a\\']++;\\n        }\\n        StringBuilder ans=new StringBuilder();\\n        while(ans.length()!=s.length())\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                if(frequency[i]>0)\\n                {\\n                    ans.append((char)(i+97));\\n                    frequency[i]--;\\n                }\\n            }\\n            for(int i=25;i>=0;i--)\\n            {\\n                if(frequency[i]>0)\\n                {\\n                    ans.append((char)(i+97));\\n                    frequency[i]--;\\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int frequency[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            frequency[s.charAt(i)-\\'a\\']++;\\n        }\\n        StringBuilder ans=new StringBuilder();\\n        StringBuilder ans1;\\n        StringBuilder ans2;\\n        while(ans.length()!=s.length())\\n        {\\n            ans1=new StringBuilder();\\n            ans2=new StringBuilder();\\n            for(int i=0;i<26;i++)\\n            {\\n                if(frequency[i]>0)\\n                {\\n                    ans1.append((char)(i+97));\\n                    frequency[i]--;\\n                }\\n\\t\\t\\t\\t//This condition ensures that if letter between M and z should be 2 or more as they are not covered in ans1\\n\\t\\t\\t\\t//but need not to be true and required freq 1 or more for letter from A to M as thy are already cover in asn1\\n                if((frequency[25-i]>1 && 25-i>=12) || (frequency[25-i]>0 && 25-i<=12)) \\n                {\\n                    ans2.append((char)(122-i));\\n                    frequency[25-i]--;\\n                }\\n            }\\n            ans.append(ans1.toString());\\n            ans.append(ans2.toString());\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872360,
                "title": "c-easy-solution-using-typecast-and-frequency-array-beats-99-9-time",
                "content": "1. store the frequency of all the occuring characters in the array(by simple letter->index translation for 0-25 representing the alphabets in lower case)\\n2. while your string is not built to it\\'s final length(as it should be), loop:\\n3.   once, traverse your frequency array from start to end(increasing order), if a letter has appeared in the original string, add it to result string and decrease the frequency by one\\n4.   then traverse it from end to start(decreasing order), and do the same\\n5.   this way you keep switching between increasing and decreasing and working with the remaining frequencies from the original string\\n\\n```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        \\n        vector<int> freq(26, 0);\\n        \\n        for(int i=0; i<s.length(); i++)\\n            freq[s[i]-\\'a\\']++;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                if(freq[j]>0)\\n                {\\n                    s[i++]=static_cast<char>(97+j);\\n                    freq[j]--;\\n                }\\n            }\\n            \\n            for(int j=25; j>=0; j--)\\n            {\\n                if(freq[j]>0)\\n                {\\n                    s[i++]= static_cast<char>(97+j);\\n                    freq[j]--;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        \\n        vector<int> freq(26, 0);\\n        \\n        for(int i=0; i<s.length(); i++)\\n            freq[s[i]-\\'a\\']++;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                if(freq[j]>0)\\n                {\\n                    s[i++]=static_cast<char>(97+j);\\n                    freq[j]--;\\n                }\\n            }\\n            \\n            for(int j=25; j>=0; j--)\\n            {\\n                if(freq[j]>0)\\n                {\\n                    s[i++]= static_cast<char>(97+j);\\n                    freq[j]--;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836018,
                "title": "easy-cpp",
                "content": "```\\nclass Solution \\n{\\n        public:\\n        string sortString(string s) \\n        {\\n                char ch=\\'I\\';\\n                int i,count[26]={0};\\n                string s1;\\n                for(i=0;i<s.size();i++)\\n                        count[s[i]-\\'a\\']++;\\n                for(i=0;i<26;)\\n                {\\n                        if(count[i]>0)\\n                        {\\n                                s1.push_back(i+\\'a\\');\\n                                count[i]--;\\n                        }\\n                        if(ch==\\'I\\')\\n                                i++;\\n                        else\\n                                i--;\\n                        if(i==26)\\n                        {\\n                                ch=\\'D\\';        //Decreasing\\n                                i--;       \\n                        }\\n                        else if(i==-1)\\n                        {\\n                                ch=\\'I\\';         //Increasing\\n                                i++;\\n                        }\\n                        if(s1.size()==s.size())\\n                                break;\\n                }\\n                return s1;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n        public:\\n        string sortString(string s) \\n        {\\n                char ch=\\'I\\';\\n                int i,count[26]={0};\\n                string s1;\\n                for(i=0;i<s.size();i++)\\n                        count[s[i]-\\'a\\']++;\\n                for(i=0;i<26;)\\n                {\\n                        if(count[i]>0)\\n                        {\\n                                s1.push_back(i+\\'a\\');\\n                                count[i]--;\\n                        }\\n                        if(ch==\\'I\\')\\n                                i++;\\n                        else\\n                                i--;\\n                        if(i==26)\\n                        {\\n                                ch=\\'D\\';        //Decreasing\\n                                i--;       \\n                        }\\n                        else if(i==-1)\\n                        {\\n                                ch=\\'I\\';         //Increasing\\n                                i++;\\n                        }\\n                        if(s1.size()==s.size())\\n                                break;\\n                }\\n                return s1;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820804,
                "title": "easy-java-solution-with-quick-video-explanation",
                "content": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = s.length();\\n        int[] frequency = new int[26];\\n        \\n        for (int i = 0; i < count; i++) {\\n            frequency[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        while (count > 0) {\\n            for (int i = 0; i < frequency.length; i++) {\\n                if (frequency[i] != 0) {\\n                    sb.append((char)(i+97));\\n                    frequency[i]--;\\n                    count--;\\n                }\\n            }\\n            for (int i = frequency.length-1; i >= 0; i--) {\\n                if (frequency[i] != 0) {\\n                    sb.append((char)(i+97));\\n                    frequency[i]--;\\n                    count--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\nMy quick video explanation:\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pwXTE1wVOIo\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String sortString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = s.length();\\n        int[] frequency = new int[26];\\n        \\n        for (int i = 0; i < count; i++) {\\n            frequency[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        while (count > 0) {\\n            for (int i = 0; i < frequency.length; i++) {\\n                if (frequency[i] != 0) {\\n                    sb.append((char)(i+97));\\n                    frequency[i]--;\\n                    count--;\\n                }\\n            }\\n            for (int i = frequency.length-1; i >= 0; i--) {\\n                if (frequency[i] != 0) {\\n                    sb.append((char)(i+97));\\n                    frequency[i]--;\\n                    count--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815085,
                "title": "easy-python-solution-using-dic",
                "content": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        dic = {}\\n        for x in s:\\n            if x not in dic:\\n                dic[x] = 1\\n            else:\\n                dic[x] += 1\\n        turns = 1\\n        output = \"\"\\n        while set(dic.values())!={0}:\\n            for x in \"abcdefghijklmnopqrstuvwxyz\"[::turns]:\\n                if x in dic:\\n                    if dic[x] != 0:\\n                        output += x\\n                        dic[x] -= 1\\n            turns = -turns\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        dic = {}\\n        for x in s:\\n            if x not in dic:\\n                dic[x] = 1\\n            else:\\n                dic[x] += 1\\n        turns = 1\\n        output = \"\"\\n        while set(dic.values())!={0}:\\n            for x in \"abcdefghijklmnopqrstuvwxyz\"[::turns]:\\n                if x in dic:\\n                    if dic[x] != 0:\\n                        output += x\\n                        dic[x] -= 1\\n            turns = -turns\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811127,
                "title": "simple-javascript-solution-easy-to-understand",
                "content": "```\\n\\nvar sortString = function(s) {\\n    let chars = {};\\n    for (let i = 0; i < s.length; i++) {\\n        if (chars[s[i]]) { \\n            chars[s[i]]++;\\n        } else {\\n            chars[s[i]] = 1;\\n        }\\n    }\\n    \\n    let allChars = Object.keys(chars);\\n    allChars.sort((a,b) => { if (a < b) { return -1; }})\\n    \\n    let count = s.length;\\n    let output = \\'\\';\\n    \\n    while (count > 0) {\\n        for (let j = 0; j < allChars.length; j++) {\\n            if (chars[allChars[j]] > 0) {\\n                output += allChars[j];\\n                chars[allChars[j]]--;\\n                count--;\\n            }\\n        }\\n        for (let j = allChars.length-1; j >= 0; j--) {\\n            if (chars[allChars[j]] > 0) {\\n                output += allChars[j];\\n                chars[allChars[j]]--;\\n                count--;\\n            }\\n        }\\n    }\\n    return output;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar sortString = function(s) {\\n    let chars = {};\\n    for (let i = 0; i < s.length; i++) {\\n        if (chars[s[i]]) { \\n            chars[s[i]]++;\\n        } else {\\n            chars[s[i]] = 1;\\n        }\\n    }\\n    \\n    let allChars = Object.keys(chars);\\n    allChars.sort((a,b) => { if (a < b) { return -1; }})\\n    \\n    let count = s.length;\\n    let output = \\'\\';\\n    \\n    while (count > 0) {\\n        for (let j = 0; j < allChars.length; j++) {\\n            if (chars[allChars[j]] > 0) {\\n                output += allChars[j];\\n                chars[allChars[j]]--;\\n                count--;\\n            }\\n        }\\n        for (let j = allChars.length-1; j >= 0; j--) {\\n            if (chars[allChars[j]] > 0) {\\n                output += allChars[j];\\n                chars[allChars[j]]--;\\n                count--;\\n            }\\n        }\\n    }\\n    return output;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 800857,
                "title": "c-hashmap-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        // store the characters in map, map sorts the characters automatically\\n        map<char, int> mp;\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) // count the frequency of the characters in the given string\\n            mp[s[i]]++;\\n        string ans = \"\";\\n        while(n != 0){ // keep a check for the length of the string\\n            map<char, int> :: iterator itr;\\n            for(itr = mp.begin(); itr != mp.end(); itr++){ // do according to the mentioned algorithm, first pick out the smallest character in the given string, keep appending till all characters are not covered\\n                if(itr->second != 0){\\n                    ans += itr->first;\\n                    itr->second = itr->second - 1;\\n                    n--;\\n                }\\n            }\\n            map<char, int> :: reverse_iterator it;\\n            for(it = mp.rbegin(); it != mp.rend(); it++){ // now go reverse and do according to the algorithm stated, keep appending from the end\\n                if(it->second != 0){\\n                    ans += it->first;\\n                    it->second = it->second - 1;\\n                    n--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n        // store the characters in map, map sorts the characters automatically\\n        map<char, int> mp;\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) // count the frequency of the characters in the given string\\n            mp[s[i]]++;\\n        string ans = \"\";\\n        while(n != 0){ // keep a check for the length of the string\\n            map<char, int> :: iterator itr;\\n            for(itr = mp.begin(); itr != mp.end(); itr++){ // do according to the mentioned algorithm, first pick out the smallest character in the given string, keep appending till all characters are not covered\\n                if(itr->second != 0){\\n                    ans += itr->first;\\n                    itr->second = itr->second - 1;\\n                    n--;\\n                }\\n            }\\n            map<char, int> :: reverse_iterator it;\\n            for(it = mp.rbegin(); it != mp.rend(); it++){ // now go reverse and do according to the algorithm stated, keep appending from the end\\n                if(it->second != 0){\\n                    ans += it->first;\\n                    it->second = it->second - 1;\\n                    n--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794640,
                "title": "php-solution-is-based-on-array-reverse",
                "content": "```\\nfunction sortString($s) {\\n\\t$s = str_split($s);\\n\\tsort($s);\\n\\n\\t$res = \\'\\';\\n\\twhile(count($s)) {\\n\\t\\t$prev = \\'\\';\\n\\n\\t\\tforeach($s as $key => $char) {\\n\\t\\t\\tif($char == $prev) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$prev = $char;\\n\\t\\t\\t$res .= $char;\\n\\t\\t\\tunset($s[$key]);\\n\\t\\t}\\n\\n\\t\\t$s = array_reverse($s);\\n\\t}\\n\\n\\treturn $res;\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction sortString($s) {\\n\\t$s = str_split($s);\\n\\tsort($s);\\n\\n\\t$res = \\'\\';\\n\\twhile(count($s)) {\\n\\t\\t$prev = \\'\\';\\n\\n\\t\\tforeach($s as $key => $char) {\\n\\t\\t\\tif($char == $prev) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$prev = $char;\\n\\t\\t\\t$res .= $char;\\n\\t\\t\\tunset($s[$key]);\\n\\t\\t}\\n\\n\\t\\t$s = array_reverse($s);\\n\\t}\\n\\n\\treturn $res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 792454,
                "title": "python-3",
                "content": "```\\n\\nimport string\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        \\n        if len(s)==1:\\n            return s\\n        \\n        alphabets = [x for x in string.ascii_lowercase]\\n        alphabets_reversed = sorted(alphabets, reverse=True)\\n        \\n        answer_array, n, s = list(), len(s), list(s)\\n        \\n        \\n        while n>0:\\n            for element in alphabets:\\n                if element in s:\\n                    answer_array.append(element)\\n                    s.remove(element)\\n                    n-=1\\n                    \\n            for value in alphabets_reversed:\\n                if value in s:\\n                    answer_array.append(value)\\n                    s.remove(value)\\n                    n-=1\\n                    \\n        return \"\".join(answer_array)\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nimport string\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        \\n        if len(s)==1:\\n            return s\\n        \\n        alphabets = [x for x in string.ascii_lowercase]\\n        alphabets_reversed = sorted(alphabets, reverse=True)\\n        \\n        answer_array, n, s = list(), len(s), list(s)\\n        \\n        \\n        while n>0:\\n            for element in alphabets:\\n                if element in s:\\n                    answer_array.append(element)\\n                    s.remove(element)\\n                    n-=1\\n                    \\n            for value in alphabets_reversed:\\n                if value in s:\\n                    answer_array.append(value)\\n                    s.remove(value)\\n                    n-=1\\n                    \\n        return \"\".join(answer_array)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759976,
                "title": "python-solution-using-recursion",
                "content": "```class Solution:\\n    def sortString(self, s: str) -> str:\\n        return self.recursion(s, [])\\n\\t\\t\\n    # recursive function from a to z then z to a\\n    def recursion(self, s: str, arr: list) -> str:\\n        if len(s) == 0:\\n            return \"\".join(arr)\\n        else:\\n            for i in range(ord(\"a\"), ord(\"z\")+1):\\n                if chr(i) in s:\\n                    arr.append(chr(i))\\n                    s = s.replace(chr(i), \"\", 1)\\n            for i in range(ord(\"z\"), ord(\"a\")-1, -1):\\n                if chr(i) in s:\\n                    arr.append(chr(i))\\n                    s = s.replace(chr(i), \"\", 1)\\n        return self.recursion(s, arr)```\\nI am just a beginner so if anyone can tell me how to optimize my code, Your Welcome.",
                "solutionTags": [],
                "code": "```class Solution:\\n    def sortString(self, s: str) -> str:\\n        return self.recursion(s, [])\\n\\t\\t\\n    # recursive function from a to z then z to a\\n    def recursion(self, s: str, arr: list) -> str:\\n        if len(s) == 0:\\n            return \"\".join(arr)\\n        else:\\n            for i in range(ord(\"a\"), ord(\"z\")+1):\\n                if chr(i) in s:\\n                    arr.append(chr(i))\\n                    s = s.replace(chr(i), \"\", 1)\\n            for i in range(ord(\"z\"), ord(\"a\")-1, -1):\\n                if chr(i) in s:\\n                    arr.append(chr(i))\\n                    s = s.replace(chr(i), \"\", 1)\\n        return self.recursion(s, arr)```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567459,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1726492,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1810917,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1728435,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 2015491,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1959175,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1796321,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1574400,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 2069580,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1987969,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1567459,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1726492,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1810917,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1728435,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 2015491,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1959175,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1796321,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1574400,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 2069580,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            },
            {
                "id": 1987969,
                "content": [
                    {
                        "username": "statx2",
                        "content": "Is it only me or also the others who find this problem really meaningless?"
                    },
                    {
                        "username": "Astros",
                        "content": "I understand your comment and agree with it in part. On the other hand, the problem is (slightly) interesting because of the fact that we are given an algorithm and we have to be able to translate it into code. \\n\\nPerhaps easy and not medium ?"
                    },
                    {
                        "username": "Astros",
                        "content": "\\nI was able to solve this problem, and I must say that the hardest part was figuring out what should be done. Am I the only one who thinks that the problem description needs to be (slightly) revised?\\n\\nI might propose something like this that is not very different from the original but easier to read and understand: \\n\\n--- \\n You are given a string `s`.  Reorder the string using the following algorithm:\\n\\n   1. Pick the smallest character from `s` and append it to the result.\\n   2. Pick the smallest character from `s` which is greater than the last appended character to the result and append it.\\n   3. Repeat step 2 until you cannot pick more characters.\\n   4. Pick the largest character from` s `and append it to the result.\\n   5. Pick the largest character from `s` which is smaller than the last appended character to the result and append it.\\n   6. Repeat step 5 until you cannot pick more characters.\\n   7. Repeat the steps from 1 to 6 until you pick all characters from s.\\n\\nReturn the result string after sorting `s` with this algorithm.\\n\\nNote that the order relation used in the algorithm is the alphabetical one. \\n\\n---\\n\\n"
                    },
                    {
                        "username": "jwalkertrained",
                        "content": "If you\\'re given this problem.. The company never wanted you."
                    },
                    {
                        "username": "eduard92",
                        "content": "One more problem at 3am... bang a wall of text."
                    },
                    {
                        "username": "najwer23",
                        "content": "it\\'s me sometimes xD"
                    },
                    {
                        "username": "District_12",
                        "content": "For someone who\\'s created this problem - I hate you."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Hint: Just find frequency of each character and do what the problem statement asks"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I am curious whether there can be an in-place (O(1)) algorithm for this"
                    },
                    {
                        "username": "bparanj",
                        "content": "The algorithm to sort a string as described in the problem doesn\\'t lend itself to an in-place solution. The constraints of the problem, where we need to find the smallest and largest characters, almost inevitably involve a sorting operation, which can\\'t be done in constant space for arbitrary inputs.\\n\\nAn in-place algorithm doesn\\'t use any extra space and only a constant amount of extra space is allowed for variables. The process of sorting usually requires extra space for comparison and movement of elements.\\n\\nMoreover, strings in Python are immutable, so any operation that modifies a string effectively creates a new one. So, technically speaking, it\\'s not possible to have an in-place algorithm that sorts a string in Python.\\n\\nHowever, if the input was a list of characters instead of a string, and if we had a constraint on the range of these characters (for instance, if they were all lowercase English letters), we could potentially devise an in-place algorithm that would use a variant of counting sort. But that algorithm wouldn\\'t be able to solve this problem, because this problem requires us to create a new string that is not just a sorted version of the original string, but a string created by a specific set of rules."
                    },
                    {
                        "username": "shenar-gold",
                        "content": "Hi! Is it correct output for example 3  or I\\'m missing something?\\n\\nExample 3:\\nInput: s = \"leetcode\"\\nOutput 1: \"cdelotee\"\\n\\nMy output:\\nInput: s = \"leetcode\"\\nOutput 2: \"cdetoeel\"\\n\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "the \\'l\\' and \\'o\\' should definitely appear before the \\'t\\' in the output if the steps are followed correctly.  "
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Find the frequency and just follow the algorithm . \\nIn my case i used string builder so that i can easily append the char to string ."
                    },
                    {
                        "username": "potatopie",
                        "content": "why doesnt my code work? value error in \\'\\'list_s.remove(k)\\'\\'\\n\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        set_s=set(s) #give distinct characters\\n        sorted_Alist=sorted(set_s) #give a sorted ascending list small to large\\n        sorted_Dlist=sorted(set_s,reverse=True) #give a sorted descending list large to small\\n\\n\\n        outputstring=\\'\\'\\n        list_s=list(s)\\n        while len(list_s)>0: #need to iterate over the whole string\\n            for j in sorted_Alist: #[a,b,c]\\n                list_s.remove(j)\\n                outputstring+=j\\n            for k in sorted_Dlist: #[c,b,a]\\n                list_s.remove(k)\\n                outputstring+=k\\n\\n        return outputstring \\n"
                    }
                ]
            }
        ]
    }
]