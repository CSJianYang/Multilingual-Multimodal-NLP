[
    {
        "title": "The Winner University",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576139,
                "content": [
                    {
                        "username": "xyz12345",
                        "content": "with nye as\\n(\\nselect count(student_id) as nnum\\nfrom newyork\\nwhere score >= 90)\\n\\n, cal as\\n(select count(student_id) as cnum\\nfrom california\\nwhere score >= 90)\\n\\nselect \\ncase   when  nnum > cnum then   \"New York University\"\\n          when  cnum >nnum  then   \"California University\"\\n          else    \"No Winner\"\\nend as winner\\nfrom nye, cal"
                    },
                    {
                        "username": "Paonevergivup",
                        "content": "with cte as(\\nselect \"NYU\" as School,count(student_id) as count_student\\nfrom NewYork\\nwhere score>=90\\nunion all\\nselect \"CU\" as School,count(student_id) as count_student\\nfrom California\\nwhere score>=90)\\n, cte2 as(\\nselect School, dense_rank() over(order by count_student desc) as rank_num\\nfrom cte)\\n\\nselect case when count(School)>1 then \"No Winner\" when School=\"NYU\" then \"New York University\" else \"California University\"  end as winner\\nfrom cte2\\nwhere rank_num=1"
                    }
                ]
            },
            {
                "id": 1576107,
                "content": [
                    {
                        "username": "xyz12345",
                        "content": "with nye as\\n(\\nselect count(student_id) as nnum\\nfrom newyork\\nwhere score >= 90)\\n\\n, cal as\\n(select count(student_id) as cnum\\nfrom california\\nwhere score >= 90)\\n\\nselect \\ncase   when  nnum > cnum then   \"New York University\"\\n          when  cnum >nnum  then   \"California University\"\\n          else    \"No Winner\"\\nend as winner\\nfrom nye, cal"
                    },
                    {
                        "username": "Paonevergivup",
                        "content": "with cte as(\\nselect \"NYU\" as School,count(student_id) as count_student\\nfrom NewYork\\nwhere score>=90\\nunion all\\nselect \"CU\" as School,count(student_id) as count_student\\nfrom California\\nwhere score>=90)\\n, cte2 as(\\nselect School, dense_rank() over(order by count_student desc) as rank_num\\nfrom cte)\\n\\nselect case when count(School)>1 then \"No Winner\" when School=\"NYU\" then \"New York University\" else \"California University\"  end as winner\\nfrom cte2\\nwhere rank_num=1"
                    }
                ]
            }
        ]
    },
    {
        "title": "Time Needed to Buy Tickets",
        "question_content": "<p>There are <code>n</code> people in a line queuing to buy tickets, where the <code>0<sup>th</sup></code> person is at the <strong>front</strong> of the line and the <code>(n - 1)<sup>th</sup></code> person is at the <strong>back</strong> of the line.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>tickets</code> of length <code>n</code> where the number of tickets that the <code>i<sup>th</sup></code> person would like to buy is <code>tickets[i]</code>.</p>\n\n<p>Each person takes <strong>exactly 1 second</strong> to buy a ticket. A person can only buy <strong>1 ticket at a time</strong> and has to go back to <strong>the end</strong> of the line (which happens <strong>instantaneously</strong>) in order to buy more tickets. If a person does not have any tickets left to buy, the person will <strong>leave </strong>the line.</p>\n\n<p>Return <em>the <strong>time taken</strong> for the person at position </em><code>k</code><em>&nbsp;</em><strong><em>(0-indexed)</em>&nbsp;</strong><em>to finish buying tickets</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tickets = [2,3,2], k = 2\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \n- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].\n- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].\nThe person at&nbsp;position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tickets = [5,1,1,1], k = 0\n<strong>Output:</strong> 8\n<strong>Explanation:</strong>\n- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].\n- In the next 4 passes, only the person in position 0 is buying tickets.\nThe person at&nbsp;position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == tickets.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= tickets[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt; n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576932,
                "title": "c-one-pass",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Brute Force Simulation\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(SUM(A))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < A.size(); ++i) {\\n                if (A[i] == 0) continue;\\n                A[i]--;\\n                ++step;\\n                if (A[k] == 0) return step;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n## Solution 2. One Pass\\n\\nFor `i <= k`, `A[i]` contributes `min(A[k], A[i])` steps.\\n\\nFor `i > k`, `A[i]` contributes `min(A[k] - 1, A[i])` steps.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            ans += min(A[k] - (i > k), A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(SUM(A))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < A.size(); ++i) {\\n                if (A[i] == 0) continue;\\n                A[i]--;\\n                ++step;\\n                if (A[k] == 0) return step;\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            ans += min(A[k] - (i > k), A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577093,
                "title": "o-n",
                "content": "We know the value of `k`-th element. Elements before `k` (and the element itself) will appear in the line `min(t[k], t[i])` times.\\n\\nAll elements after `k` will appear in the line  `min(t[k] - 1, t[i])` times.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def timeRequiredToBuy(self, t: List[int], k: int) -> int:\\n        return sum(min(v, t[k] if i <= k else t[k] - 1) for i, v in enumerate(t))\\n```\\n**Java**\\n```java\\npublic int timeRequiredToBuy(int[] t, int k) {\\n    return IntStream.range(0, t.length).map(i -> Math.min(t[i], i > k ? t[k] - 1 : t[k])).sum();\\n}\\n```\\n**C++**\\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    int res = 0, sz = t.size(), cap = t[k];\\n    for (int i = 0; i < sz; ++i)\\n        res += min(cap - (i > k), t[i]);\\n    return res;\\n}\\n```\\nAlso a (slightly mouthful) functional version.\\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    return accumulate(begin(t), begin(t) + k + 1, 0, [&](int s, int v){ return s + min(v, t[k]); })\\n        + accumulate(begin(t) + k + 1, end(t), 0, [&](int s, int v){ return s + min(v, t[k] - 1); });\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def timeRequiredToBuy(self, t: List[int], k: int) -> int:\\n        return sum(min(v, t[k] if i <= k else t[k] - 1) for i, v in enumerate(t))\\n```\n```java\\npublic int timeRequiredToBuy(int[] t, int k) {\\n    return IntStream.range(0, t.length).map(i -> Math.min(t[i], i > k ? t[k] - 1 : t[k])).sum();\\n}\\n```\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    int res = 0, sz = t.size(), cap = t[k];\\n    for (int i = 0; i < sz; ++i)\\n        res += min(cap - (i > k), t[i]);\\n    return res;\\n}\\n```\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    return accumulate(begin(t), begin(t) + k + 1, 0, [&](int s, int v){ return s + min(v, t[k]); })\\n        + accumulate(begin(t) + k + 1, end(t), 0, [&](int s, int v){ return s + min(v, t[k] - 1); });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577018,
                "title": "python-bruteforce-and-o-n",
                "content": "Please upvote if you find it helpful\\n\\nBruteForce:\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore\\n                tickets[i] -= 1 # decrease the value by 1 everytime\\n                secs += 1 # increase secs by 1\\n\\n            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator\\n            \\n        return secs\\n```\\n\\nO(N):\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(x, tickets[k] if i <= k else tickets[k] - 1) for i, x in enumerate(tickets))\\n```\\nThe values before tickets[k] will appear min(x, t[x]) times and values after tickets[k] will appear min(x, t[x] -1) times\\nLet\\'s take an example:\\n`tickets = [5, 2, 3, 4]` and `k = 2`\\n```1st iteration: [4, 1, 2, 3]```\\n```2nd iteration: [3, 0, 1, 2]```\\n```3rd iteration: [2, 0, 0, 1]```\\nYou see `tickets[0]` appeared 3 times which is min(5, 3) and that is 3, \\n             `tickets[1]` appeared 2 times which is min(2, 3) that is 2, \\n\\t\\t\\t `tickets[2]` appeared 3 times which is min(3, 3) that is 3 and \\n\\t\\t\\t `tickets[3]` appeared 2 times which is min(4, 2) that is 2.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore\\n                tickets[i] -= 1 # decrease the value by 1 everytime\\n                secs += 1 # increase secs by 1\\n\\n            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator\\n            \\n        return secs\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(x, tickets[k] if i <= k else tickets[k] - 1) for i, x in enumerate(tickets))\\n```\n```1st iteration: [4, 1, 2, 3]```\n```2nd iteration: [3, 0, 1, 2]```\n```3rd iteration: [2, 0, 0, 1]```",
                "codeTag": "Java"
            },
            {
                "id": 1576926,
                "title": "java-o-n-one-pass-explained",
                "content": "**Explanation / Approach:**\\nBrute force is somewhat easy to come up with. You just need to iterate as long as tickets[k] != 0.\\n\\n**For an optimized approach :**\\n1. Add min(tickets[i],tickets[k]) upto k (inclusive).\\n2. Add min(tickets[i],tickets[k] - 1) after k.\\n3. Return the count.\\n\\nTime : O(n) , Space : O(1)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                res += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                res += Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                res += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                res += Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589830,
                "title": "c-brute-force-vs-single-pass-solution-compared-and-explained-100-time-80-space",
                "content": "Given the constraints, we can easily afford to go for a brute force-ish solution first (a fully legitimate approach during any interview, as long as you keep the computationt time reasonable - I wouldn\\'t do this if either the queue length or the amount of tickets each queuer might buy were in the order of billions!), so we will go for it first.\\n\\nIn order to solve our problem we will first of all declare an accumulator variable `res`, initially set to `0` and that will store how many turns we have to wait until the `k`th slot has bought all his tickets.\\n\\nWe will then have an outer loop just to check that - `ts[k]` still having pending tickets to buy and inside it we will run another one, using the pointer `i` to parse `ts` until `ts[k]` is not `0` and in which we will:\\n* check if the currently pointed element `ts[i]` still has elements to remove and, in case:\\n\\t* decrease `ts[i]` by `1`;\\n\\t* increase `res` by `1`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0;\\n        // running loops until we get all our tickets\\n        while (ts[k]) {\\n            // running one loop\\n            for (int i = 0, lmt = ts.size(); i < lmt && ts[k]; i++) {\\n                // decreasing one slot and increasing res, if the slot still queues\\n                if (ts[i]) {\\n                    ts[i]--;\\n                    res++;\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, wait a minute \\uD83E\\uDD14 ...\\n\\nDo we really need to decrease all the cells one by one?\\n\\nWell, probably not, since we might quickly notice that the waiting time each slot to the left of `k` contributes is equal to the minimum between its current value and `ts[k]`, that we will call `target` for convenience; and it\\'s almost the same for all the elements to the right of it, being the minimum between its current value and `target - 1` (since we will go and touch them always after having decreased `ts[k]`.\\n\\nSo, we can put this into code and get much better performance with this version:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue\\n        for (int i = 0, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and what we need to get\\n            res += min(ts[i], target - (i > k));\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFinal micro-optimised version to avoid one conditional inside the loop (which probably would not even shine in terms of performance compared to allocating variables for a sole `for` loop unless we were to get really big ranges):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue up to k, included\\n        for (int i = 0; i <= k; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        // parsing the queue up from  k, excluded\\n        target--;\\n        for (int i = k + 1, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0;\\n        // running loops until we get all our tickets\\n        while (ts[k]) {\\n            // running one loop\\n            for (int i = 0, lmt = ts.size(); i < lmt && ts[k]; i++) {\\n                // decreasing one slot and increasing res, if the slot still queues\\n                if (ts[i]) {\\n                    ts[i]--;\\n                    res++;\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue\\n        for (int i = 0, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and what we need to get\\n            res += min(ts[i], target - (i > k));\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue up to k, included\\n        for (int i = 0; i <= k; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        // parsing the queue up from  k, excluded\\n        target--;\\n        for (int i = k + 1, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577090,
                "title": "easy-to-understand",
                "content": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n     \\n    let countTime = 0;\\n\\n    while(tickets[k] !== 0){\\n\\n        for(let i = 0; i < tickets.length; i++){\\n            \\n            if(tickets[k] == 0){\\n                return countTime;\\n            }\\n            if(tickets[i] !== 0){\\n                tickets[i] = tickets[i] - 1;\\n                countTime++;\\n            }\\n        }\\n\\n    }\\n\\n    return countTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n     \\n    let countTime = 0;\\n\\n    while(tickets[k] !== 0){\\n\\n        for(let i = 0; i < tickets.length; i++){\\n            \\n            if(tickets[k] == 0){\\n                return countTime;\\n            }\\n            if(tickets[i] !== 0){\\n                tickets[i] = tickets[i] - 1;\\n                countTime++;\\n            }\\n        }\\n\\n    }\\n\\n    return countTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778911,
                "title": "python-o-n-easy-method",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t#Loop through all elements in list only once.  \\n\\t\\t\\n        nums = tickets \\n        time_sec = 0\\n\\t\\t# save the number of tickets to be bought by person standing at k position\\n        least_tickets = nums[k]     \\n\\t\\t#(3) Any person nums[i] having tickets more than the k pos person, will buy tickets least_tickets times only.\\n\\t\\t#(2) Person nums[i] having tickets less than kth person ( nums[i] < least_tickets ), and standing before him(i<k), will be able to buy nums[i] amount.\\n\\t\\t#(1) Person nums[i] standing after kth person having more tickets than kth person, will be able to buy one less than the ticket kth person can buy(condition: least_tickets - 1).\\n        for i in range(len(nums)):                  \\n            if k < i and nums[i] >= least_tickets :         #(1)\\n                time_sec += (least_tickets - 1)\\n            elif nums[i] < least_tickets :                   #(2)\\n                time_sec += nums[i]\\n            else:                                            #(3)\\n                time_sec += least_tickets\\n\\t\\t\\t\\t\\n        return time_sec\\n        \\nPlease upvote if you find it useful and well-explained!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t#Loop through all elements in list only once.  \\n\\t\\t\\n        nums = tickets \\n        time_sec = 0\\n\\t\\t# save the number of tickets to be bought by person standing at k position\\n        least_tickets = nums[k]     \\n\\t\\t#(3) Any person nums[i] having tickets more than the k pos person, will buy tickets least_tickets times only.\\n\\t\\t#(2) Person nums[i] having tickets less than kth person ( nums[i] < least_tickets ), and standing before him(i<k), will be able to buy nums[i] amount.\\n\\t\\t#(1) Person nums[i] standing after kth person having more tickets than kth person, will be able to buy one less than the ticket kth person can buy(condition: least_tickets - 1).\\n        for i in range(len(nums)):                  \\n            if k < i and nums[i] >= least_tickets :         #(1)\\n                time_sec += (least_tickets - 1)\\n            elif nums[i] < least_tickets :                   #(2)\\n                time_sec += nums[i]\\n            else:                                            #(3)\\n                time_sec += least_tickets\\n\\t\\t\\t\\t\\n        return time_sec\\n        \\nPlease upvote if you find it useful and well-explained!",
                "codeTag": "Java"
            },
            {
                "id": 1576991,
                "title": "python-1-liner",
                "content": "```python\\nreturn sum(min(tickets[k] - (i > k), num) for i, num in enumerate(tickets))\\n```",
                "solutionTags": [],
                "code": "```python\\nreturn sum(min(tickets[k] - (i > k), num) for i, num in enumerate(tickets))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577014,
                "title": "java-easy-solution-o-n",
                "content": "**Time Needed to Buy Tickets**\\n\\nSimple and crisp Solution - \\n\\n**Input:** tickets = [2,3,2], k = 2\\n**Output:** 6\\n**Explanation:** \\n- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].\\n- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].\\nThe person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\\n\\n```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTaken = 0;\\n        while(tickets[k] > 0) {\\n        \\tfor(int i = 0; i < tickets.length; i++) {\\n        \\t\\tif(tickets[i] > 0) {\\n        \\t\\t\\ttickets[i]--;\\n        \\t\\t\\ttimeTaken++;\\n        \\t\\t}\\n                if(tickets[k] == 0)  break;\\n        \\t}\\n        }\\n        return timeTaken;\\n    }\\n```\\n\\t\\nTime Complexity - **O(n^2)**\\n\\n\\t\\n```\\n\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t      int timeTaken = 0;\\n          for(int i = 0; i < tickets.length; i++){\\n                if(tickets[i] <= tickets[k]){\\n                     timeTaken += tickets[i];\\n                }\\n                else  timeTaken += tickets[k];\\n                if(i > k && tickets[i] >= tickets[k])  timeTaken--;\\n          }\\n          return timeTaken;\\n    }\\n```\\t\\n\\t\\nTime Complexity - **O(n)**\\n\\nCredit - @yadavharsha50",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTaken = 0;\\n        while(tickets[k] > 0) {\\n        \\tfor(int i = 0; i < tickets.length; i++) {\\n        \\t\\tif(tickets[i] > 0) {\\n        \\t\\t\\ttickets[i]--;\\n        \\t\\t\\ttimeTaken++;\\n        \\t\\t}\\n                if(tickets[k] == 0)  break;\\n        \\t}\\n        }\\n        return timeTaken;\\n    }\\n```\n```\\n\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t      int timeTaken = 0;\\n          for(int i = 0; i < tickets.length; i++){\\n                if(tickets[i] <= tickets[k]){\\n                     timeTaken += tickets[i];\\n                }\\n                else  timeTaken += tickets[k];\\n                if(i > k && tickets[i] >= tickets[k])  timeTaken--;\\n          }\\n          return timeTaken;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584144,
                "title": "c-very-easy-o-n-my-thought",
                "content": "Hint :- Simple solustion is to count time for every element and return sum of it. \\n\\nJust bruthforces, Element before k index take min of element or that index value and ,after k index it take min of element-1 or that index. Here element-1 because in last round we will not go for element which index is greater then k.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int ans =0;\\n            int n = tickets.size();\\n            int ele = tickets[k];\\n            for(int i=0;i< n; i++){\\n                    if(i<=k){\\n                        ans+= min(ele, tickets[i]);\\n                    }else{\\n                        ans+= min(ele-1, tickets[i]);   \\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```\\n\\n**Upvote If like my solustion ::)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int ans =0;\\n            int n = tickets.size();\\n            int ele = tickets[k];\\n            for(int i=0;i< n; i++){\\n                    if(i<=k){\\n                        ans+= min(ele, tickets[i]);\\n                    }else{\\n                        ans+= min(ele-1, tickets[i]);   \\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189150,
                "title": "c-solution-beats-100-easy-to-understand-and-easy-solution",
                "content": "# Intuition\\nWe have to just keep decreasing 1 from each element.\\n\\n# Approach\\n1. We will traverse the array and keep decreasing 1 from every element till the element at kth position gets 0.\\n2. We will also keep a count variable to keep track of the steps required for kth element to reach 0.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0, i = 0;\\n\\n        while(tickets[k] != 0){\\n            if(i == tickets.size()){\\n                i = 0;\\n            }\\n            if(tickets[i] == 0){\\n                i++;\\n                continue;\\n            }\\n            tickets[i]--;\\n            count++;\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0, i = 0;\\n\\n        while(tickets[k] != 0){\\n            if(i == tickets.size()){\\n                i = 0;\\n            }\\n            if(tickets[i] == 0){\\n                i++;\\n                continue;\\n            }\\n            tickets[i]--;\\n            count++;\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582397,
                "title": "1-ms-java-solution",
                "content": "```\\n public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int seconds = 0;\\n        int i = 0;\\n        while(tickets[k] != 0)\\n        {\\n            if(tickets[i] != 0)\\n            {\\n                tickets[i] = tickets[i] -1;\\n                seconds++;\\n            }\\n            if(i == tickets.length - 1)\\n            {\\n                i = 0;\\n                continue;\\n            }\\n                i++;\\n        }\\n\\n        return seconds;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int seconds = 0;\\n        int i = 0;\\n        while(tickets[k] != 0)\\n        {\\n            if(tickets[i] != 0)\\n            {\\n                tickets[i] = tickets[i] -1;\\n                seconds++;\\n            }\\n            if(i == tickets.length - 1)\\n            {\\n                i = 0;\\n                continue;\\n            }\\n                i++;\\n        }\\n\\n        return seconds;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2037468,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<pair<int,int>>q;\\n        int time = 0;\\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            q.push({tickets[i],i});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<int,int> tmp = q.front();\\n            q.pop();\\n            --tmp.first;\\n            ++time;\\n            if(tmp.first == 0 && tmp.second == k)\\n            {\\n                break;\\n            }\\n            else if(tmp.first != 0)\\n            {\\n                q.push({tmp.first,tmp.second});\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<pair<int,int>>q;\\n        int time = 0;\\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            q.push({tickets[i],i});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<int,int> tmp = q.front();\\n            q.pop();\\n            --tmp.first;\\n            ++time;\\n            if(tmp.first == 0 && tmp.second == k)\\n            {\\n                break;\\n            }\\n            else if(tmp.first != 0)\\n            {\\n                q.push({tmp.first,tmp.second});\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577912,
                "title": "brute-deque-optimised-in-one-pass",
                "content": "1)BRUTE FORCE APPROACH -> \\nA) SIMULATE THE GIVEN PROBLEM USING DEQUE DATA STRUCTURE  \\nKEEP A COUNTER WHEN KTH ELEMENT BECOMES 0 THATS EASY :)\\n\\nTC -> O(K * ARR[K]) -> IN WORST CASE IF K IS LAST ELEMENT\\nSC -> O(2*N) -> TAKEN A PAIR\\n\\nCODE -> \\n```\\n\\t\\tdeque<pair<int,int>>dq;\\n        for(int i = 0;  i < tickets.size(); i++) {\\n            dq.push_back({tickets[i] , i});\\n        }\\n        int ans = 0;\\n        while(!dq.empty()) {\\n            int val = dq.front().first;\\n            int idx = dq.front().second;\\n            val--;\\n            ans++;\\n            if(idx == k && val == 0) {\\n                break;\\n            }\\n            if(val == 0) {\\n                dq.pop_front();\\n            } else {\\n                dq.pop_front();\\n                dq.push_back({val, idx});\\n            }\\n        }\\n        return ans;\\n```\\n\\nOPTIMISED APPROACH->\\n\\nTHINK WITH RESPECT TO K -> TAKE 2 CASES\\n1) ELEMENTS BEFORE K -> WILL TAKE MIN(ARR[I] , ARR[K]) STEPS IN TOTAL\\n2) ELEMENTS AFTER K  ->  WILL TAKE MIN(ARR[I] , ARR[K] - 1 STEPS) IN TOTAL\\n3) YOUR ANS IS (1 + 2) -> \\n\\nCODE -> \\n```\\n\\t int ans = 1;\\n        int val = tickets[k];\\n        for(int i = 0 ; i < tickets.size(); i++) {\\n            if(i < k) {\\n                //THE ELEMENTS THAT LIE BEFORE K\\n                if(tickets[i]  < val) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += val;\\n                }\\n            } else {\\n                //THE ELEMENTS THAT LIE AFTER K\\n                if(tickets[i] < val - 1) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += (val - 1);\\n                }   \\n            }   \\n        } \\n        return ans;\\n```\\n\\nTC -> O(N) SINGLE PASS\\nSC -> O(1) :)\\n\\nTHANK YOU DO SHARE AND UPVOTE IF YOU LIKED THE APPROACH\\n",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\n\\t\\tdeque<pair<int,int>>dq;\\n        for(int i = 0;  i < tickets.size(); i++) {\\n            dq.push_back({tickets[i] , i});\\n        }\\n        int ans = 0;\\n        while(!dq.empty()) {\\n            int val = dq.front().first;\\n            int idx = dq.front().second;\\n            val--;\\n            ans++;\\n            if(idx == k && val == 0) {\\n                break;\\n            }\\n            if(val == 0) {\\n                dq.pop_front();\\n            } else {\\n                dq.pop_front();\\n                dq.push_back({val, idx});\\n            }\\n        }\\n        return ans;\\n```\n```\\n\\t int ans = 1;\\n        int val = tickets[k];\\n        for(int i = 0 ; i < tickets.size(); i++) {\\n            if(i < k) {\\n                //THE ELEMENTS THAT LIE BEFORE K\\n                if(tickets[i]  < val) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += val;\\n                }\\n            } else {\\n                //THE ELEMENTS THAT LIE AFTER K\\n                if(tickets[i] < val - 1) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += (val - 1);\\n                }   \\n            }   \\n        } \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918164,
                "title": "brute-force-optimized-queue-interviewer-mindset",
                "content": "# Intuition\\n1. Brute force using loop iteration\\n2. optimised using one loop\\n3. Queue solution for more in depth\\n\\n# Approach\\nWe find out min of tickets[i] and tickets[k]\\n\\n\\n\\n## Brute force approach\\n- Time complexity: O(N^2)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k){\\n        int n= tickets.length;\\n        int time=0;\\n    \\n        if(tickets[k]==1) return k+1;\\n        while(tickets[k]>0){\\n            for(int i=0;i<n;i++){\\n                if(tickets[i]==0) continue;\\n                tickets[i]=tickets[i]-1;\\n                time++;\\n                if(tickets[k]==0) break;\\n            }\\n        }k--;\\n        return time;\\n    }\\n}\\n\\n```\\n## Optimized approach: without extra space\\n\\n- Time complexity: O(N)\\n- - space complexity: O(1)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                time += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                time+= Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n\\n```\\n## Queue approach : taking extra space\\n- Time complexity: O(N)\\n- space complexity: O(N)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\n            q.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```\\n![cat-upvote.jpg](https://assets.leetcode.com/users/images/7c799b02-abd9-44f8-98a2-e4830340d206_1692193011.7738297.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k){\\n        int n= tickets.length;\\n        int time=0;\\n    \\n        if(tickets[k]==1) return k+1;\\n        while(tickets[k]>0){\\n            for(int i=0;i<n;i++){\\n                if(tickets[i]==0) continue;\\n                tickets[i]=tickets[i]-1;\\n                time++;\\n                if(tickets[k]==0) break;\\n            }\\n        }k--;\\n        return time;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                time += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                time+= Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\n            q.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615121,
                "title": "100-beats-o-n-solution-without-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n       int n=tickets.size();\\n       int total=tickets[k];\\n\\n        for(int i=0;i<k;i++){\\n            total+=min(tickets[k],tickets[i]);\\n        }\\n        for(int i=k+1;i<n;i++){\\n            total+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n       int n=tickets.size();\\n       int total=tickets[k];\\n\\n        for(int i=0;i<k;i++){\\n            total+=min(tickets[k],tickets[i]);\\n        }\\n        for(int i=k+1;i<n;i++){\\n            total+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567182,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n    int count=0;\\n        while(tickets[k]>0){\\n            for(int i=0;i<tickets.length;i++){\\n                if(tickets[i]>0){\\n                    tickets[i]-=1;\\n                    count++;\\n                }\\n                if(tickets[k]==0)break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n    int count=0;\\n        while(tickets[k]>0){\\n            for(int i=0;i<tickets.length;i++){\\n                if(tickets[i]>0){\\n                    tickets[i]-=1;\\n                    count++;\\n                }\\n                if(tickets[k]==0)break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489688,
                "title": "python-simple-and-clean-beats-77-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n##### **Single Pass Solution**\\n1. People before *k-th* person will take mininum of reqd tickets and *k-th* person ticket\\n2. People after *k-th* person will take 1 ticket less than, because after oue person takes the ticket the objective will be completed and we do not need to count more time for people **standing after him**\\n\\n##### **Implementation**\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num = tickets[k]\\n        res = 0\\n        for i in range(k+1):\\n            res += min(tickets[i],num)\\n        for i in range(k+1,len(tickets)):\\n            res += min(tickets[i],num-1)\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7ab4074a-00a1-49e3-a1fb-fc62d50bfe0f_1661594988.4600484.png)\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num = tickets[k]\\n        res = 0\\n        for i in range(k+1):\\n            res += min(tickets[i],num)\\n        for i in range(k+1,len(tickets)):\\n            res += min(tickets[i],num-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763737,
                "title": "java-solution-faster-than-100-of-all-submissions-o-n",
                "content": "```\\n\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n      int output = 0;\\n      int n = tickets.length;\\n      for  (int i = 0;i<n;i++){\\n          if(tickets[i] < tickets[k]){\\n              output += tickets[i];\\n          }else{\\n                if(i <= k){\\n                  output += tickets[k];\\n              }else { \\n                  output += tickets[k] - 1;\\n              } \\n          }\\n\\n      }\\n      return output;\\n    }\\n}\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n      int output = 0;\\n      int n = tickets.length;\\n      for  (int i = 0;i<n;i++){\\n          if(tickets[i] < tickets[k]){\\n              output += tickets[i];\\n          }else{\\n                if(i <= k){\\n                  output += tickets[k];\\n              }else { \\n                  output += tickets[k] - 1;\\n              } \\n          }\\n\\n      }\\n      return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577071,
                "title": "c-0ms-explained-easy-one-pass",
                "content": "Three cases possible are,\\n\\n`If` the ticket holders have less tickets to buy than our Kth ticket holder, they will have got all the tickets they wanted before kth ticket holder gets all its tickets,\\n\\n`else if` the ticket holders have more ticketsto buy than our Kth ticket holder, and they are ahead in line(position < k) then, they will have bought `tickets[k]` tickets before kth ticket holder gets all the tickets it needs,\\n\\n`else if` the ticket holders have more tickets to buy than our Kth ticket holder, and they are behind in line(position > k) then, they will have bought 1 ticket less than `tickets[k]` before kth ticket holder gets all the tickets it needs.\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int ticket = tickets[k];\\n        int res = 0;\\n        for(int i = 0; i<tickets.size(); i++){\\n          if(tickets[i] < ticket) res+=tickets[i];\\n          else if(tickets[i] >= ticket and i <= k) res+=ticket;\\n          else if(tickets[i] >= ticket and i > k) res+=ticket-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int ticket = tickets[k];\\n        int res = 0;\\n        for(int i = 0; i<tickets.size(); i++){\\n          if(tickets[i] < ticket) res+=tickets[i];\\n          else if(tickets[i] >= ticket and i <= k) res+=ticket;\\n          else if(tickets[i] >= ticket and i > k) res+=ticket-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490739,
                "title": "very-easy-java-solution-using-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        while(!queue.isEmpty()){\\n            int index = queue.poll();\\n            tickets[index]--;\\n            ans++;\\n            if(tickets[index] == 0 && index == k){\\n                return ans;\\n            }\\n            if(tickets[index] > 0){\\n                queue.add(index);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        while(!queue.isEmpty()){\\n            int index = queue.poll();\\n            tickets[index]--;\\n            ans++;\\n            if(tickets[index] == 0 && index == k){\\n                return ans;\\n            }\\n            if(tickets[index] > 0){\\n                queue.add(index);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607037,
                "title": "java-simple-code-100-faster",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int seconds = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]) seconds += tickets[i]; // only add the time needed to buy his tickets\\n            else{\\n                if(i <= k) seconds += tickets[k]; \\n                else seconds += tickets[k] - 1; \\n            }\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int seconds = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]) seconds += tickets[i]; // only add the time needed to buy his tickets\\n            else{\\n                if(i <= k) seconds += tickets[k]; \\n                else seconds += tickets[k] - 1; \\n            }\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495619,
                "title": "one-pass-c-easy-to-understand",
                "content": "People infront of our target person will get all their tickets before our target man if they want tickets less than or equal to him. If they want more tickets than him they will only get tickets equal to him till target man gets all his tickets.\\n\\nFor people behind target man, they will get all tickets if they want tickets strictly less than him. If they want more than him, they will get one less than tickets target man wants till he gets all his tickets.\\n\\'\\'\\'\\n              \\n    class Solution {\\n    public:\\n        int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int n=tickets.size();\\n            int time=tickets[k];\\n            for(int i=0;i<tickets.size();i++){\\n            //Elements infront of target\\n                  //If they are smaller or equal to target value collect them whole \\n                  //If they are greater collect target value\\n            if(i<k){\\n                if(tickets[i]<=tickets[k]){\\n                    time+=tickets[i];\\n                }\\n                else{\\n                    time+=tickets[k];\\n                }\\n            }\\n            //Elements behind target\\n                  //If they are smaller than target value collect them whole \\n                  //If they are greater collect (target-1) value\\n            else if(i>k){\\n                if(tickets[i]<tickets[k]){\\n                    time+=tickets[i];\\n                }\\n                else{\\n                    time+=(tickets[k]-1);\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\t\\t\\t        \\n\\t\\t\\t      \\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n        int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int n=tickets.size();\\n            int time=tickets[k];\\n            for(int i=0;i<tickets.size();i++){\\n            //Elements infront of target\\n                  //If they are smaller or equal to target value collect them whole \\n                  //If they are greater collect target value\\n            if(i<k){\\n                if(tickets[i]<=tickets[k]){\\n                    time+=tickets[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1642918,
                "title": "simple-c-solution-0ms",
                "content": "This is easy to understand solution..\\nDo give a like!.\\n\\n\\n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n    int n=tickets.size(),ans=0;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        if(i>k)\\n            ans+=min(tickets[i],tickets[k]-1);\\n        else if(i<k)\\n            ans+=min(tickets[i],tickets[k]);\\n        else\\n            ans+=tickets[k];\\n                \\n    }\\n        \\n    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "This is easy to understand solution..\\nDo give a like!.\\n\\n\\n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n    int n=tickets.size(),ans=0;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        if(i>k)\\n            ans+=min(tickets[i],tickets[k]-1);\\n        else if(i<k)\\n            ans+=min(tickets[i],tickets[k]);\\n        else\\n            ans+=tickets[k];\\n                \\n    }\\n        \\n    return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3485730,
                "title": "python3-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        n=len(tickets)\\n        q=deque([i for i in range(n)])\\n        \\n        time=0\\n        \\n        while q:\\n            for i in range(len(q)):\\n\\n                node=q.popleft()\\n                tickets[node]-=1\\n                if tickets[node]>=1:\\n                    q.append(node)\\n                \\n                time+=1\\n                if tickets[k]==0:\\n                    return time\\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        n=len(tickets)\\n        q=deque([i for i in range(n)])\\n        \\n        time=0\\n        \\n        while q:\\n            for i in range(len(q)):\\n\\n                node=q.popleft()\\n                tickets[node]-=1\\n                if tickets[node]>=1:\\n                    q.append(node)\\n                \\n                time+=1\\n                if tickets[k]==0:\\n                    return time\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253744,
                "title": "c-2-ways-bruteforce-optimal",
                "content": "# Method-1 [Brute Force]\\n\\n![image](https://assets.leetcode.com/users/images/c883d3c4-59d3-430e-a16d-5e1b6532e52b_1657263680.476677.png)\\n\\n**n==t.size()\\nT->O(tickets[k] * n) && S->(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\twhile(1){\\n\\t\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\t\\tif(t[i]>0){\\n\\t\\t\\t\\t\\t\\tt[i]--;\\n\\t\\t\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\t\\t\\tif(t[k]==0)return time;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n# Method-2 [Optimal solution]\\t\\n\\t\\n![image](https://assets.leetcode.com/users/images/98e24ff0-6f30-429b-8292-63a194bf3895_1657264759.6914196.png)\\n\\n**In one pass!\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\tif(t[i]<t[k])time+=t[i];\\n\\t\\t\\t\\telse time+=t[k];\\n\\t\\t\\t\\tif(i>k && t[i]>=t[k])time--;\\n\\t\\t\\t}\\n\\t\\t\\treturn time;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\twhile(1){\\n\\t\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\t\\tif(t[i]>0){\\n\\t\\t\\t\\t\\t\\tt[i]--;\\n\\t\\t\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\t\\t\\tif(t[k]==0)return time;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2147186,
                "title": "c-queue-cycle",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> q;\\n        for(int i : tickets) q.push(i);\\n        int res = 0;\\n        int p = k;\\n        \\n        while(true){\\n            res++;\\n            if(q.front()-- > 1) q.push(q.front());\\n            else if(p == 0) break;\\n            q.pop();\\n            if(--p < 0) p = q.size() - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> q;\\n        for(int i : tickets) q.push(i);\\n        int res = 0;\\n        int p = k;\\n        \\n        while(true){\\n            res++;\\n            if(q.front()-- > 1) q.push(q.front());\\n            else if(p == 0) break;\\n            q.pop();\\n            if(--p < 0) p = q.size() - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104569,
                "title": "0-ms-java-solution",
                "content": "suppose the given array is [2,3,7,5,1,2,7] and k is pointing to element = 5.\\nwe need to find that each element is reduced how many times till we get 0 at the index 3. The element before 5 will be reduced by = **minimum of (value of ith element, value of kth element)**\\n the element before 5 are [2,3,7,5] and these will be reduced to [0,0,2,0] when the kth guy get ticket \\n \\n![image](https://assets.leetcode.com/users/images/bfea9c2c-94db-4fa0-8e6b-f20bf067424a_1654226809.5009036.png)\\n\\nnow element after 5 are [1,2,7] here we have a case, the element 1,2 will be completly reduce to 0 but the element greater than k will reduce to 1 lesser than the kth element (shown below ) because the kth element guy got the ticket and we don\\'t need to worry about the leftover.\\n\\n![image](https://assets.leetcode.com/users/images/c826088c-eaf7-4d83-9543-a55494e2c89c_1654226960.949127.png)\\n\\n**please upvote my solution if u like it \\u2764\\uFE0F** \\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0 ; i < tickets.length; ++i){\\n            if(i <=k){\\n                count += Math.min(tickets[i], tickets[k]);\\n            }\\n            else\\n                count += Math.min(tickets[i], tickets[k] - 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0 ; i < tickets.length; ++i){\\n            if(i <=k){\\n                count += Math.min(tickets[i], tickets[k]);\\n            }\\n            else\\n                count += Math.min(tickets[i], tickets[k] - 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084750,
                "title": "python-simple-readable-easy-to-understand-solution-beats-69",
                "content": "The approach is as follows:\\n1. Keep track of the number of seconds (this is what will be returned)\\n2. As long as the person at k index still has tickets to buy:\\n\\t* Sell tickets to everyone in the line who still has tickets to buy\\n\\t* Add a second for each ticket sold\\n3. Return how many seconds were needed to sell the person at k index all of their tickets\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num_seconds = 0\\n        \\n        while tickets[k] > 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0 and tickets[k] > 0:\\n                    tickets[i] -= 1\\n                    num_seconds += 1\\n\\n        return num_seconds\\n```\\n![image](https://assets.leetcode.com/users/images/6c478172-bc00-416c-9d13-fbda59d8cb15_1653763898.4271393.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num_seconds = 0\\n        \\n        while tickets[k] > 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0 and tickets[k] > 0:\\n                    tickets[i] -= 1\\n                    num_seconds += 1\\n\\n        return num_seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958399,
                "title": "c-easy-o-n",
                "content": "***Upvote If you like the solution***\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int num=tickets[k],tt=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(num>tickets[i]){\\n                tt+=tickets[i];\\n            }\\n            else if(num<=tickets[i]){\\n                tt+=num;\\n            }\\n        }\\n        for(int i=k+1;i<tickets.size();i++){\\n            if(tickets[i]>=num){\\n                tt-=1;\\n            }\\n        }\\n        return tt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int num=tickets[k],tt=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(num>tickets[i]){\\n                tt+=tickets[i];\\n            }\\n            else if(num<=tickets[i]){\\n                tt+=num;\\n            }\\n        }\\n        for(int i=k+1;i<tickets.size();i++){\\n            if(tickets[i]>=num){\\n                tt-=1;\\n            }\\n        }\\n        return tt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612829,
                "title": "python-o-n-time-complexity-faster-than-97",
                "content": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        ans = 0\\n        \\n\\t\\t# people at the front will always get 1 ticket first\\n\\t\\t# get minimum to know how many times a person will queue and buy before kth person\\n        for tix in range(k+1):\\n            ans += min(tickets[tix], tickets[k])\\n\\n\\t\\t# contrary to people at the front, \\n\\t\\t# kth person will only go behind everyone *(people initially behind k)* for tickets[k]-1 times \\n        for tix in range(k+1, len(tickets)):\\n            ans += min(tickets[tix], tickets[k]-1)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        ans = 0\\n        \\n\\t\\t# people at the front will always get 1 ticket first\\n\\t\\t# get minimum to know how many times a person will queue and buy before kth person\\n        for tix in range(k+1):\\n            ans += min(tickets[tix], tickets[k])\\n\\n\\t\\t# contrary to people at the front, \\n\\t\\t# kth person will only go behind everyone *(people initially behind k)* for tickets[k]-1 times \\n        for tix in range(k+1, len(tickets)):\\n            ans += min(tickets[tix], tickets[k]-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576949,
                "title": "python3-1-line",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(tickets[k]-int(i>k), x) for i, x in enumerate(tickets))\\n```\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ans = behind = 0 \\n        for i, x in enumerate(tickets): \\n            if i > k: behind = 1\\n            if x < tickets[k] - behind: ans += x\\n            else: ans += tickets[k] - behind\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(tickets[k]-int(i>k), x) for i, x in enumerate(tickets))\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ans = behind = 0 \\n        for i, x in enumerate(tickets): \\n            if i > k: behind = 1\\n            if x < tickets[k] - behind: ans += x\\n            else: ans += tickets[k] - behind\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981218,
                "title": "two-simple-solutions-in-python3-queue-ds-inifinite-looping",
                "content": "# Intuition\\nFollowing to the description of the problem, the task goal is to calculate **min amount of time**, that `K`- buyer needs to spend in order to buy tickets.\\n\\nSomehow we need to iterate over all buyers, reduce the current amount of tickets they\\'re bying at the moment, shift the current buyer to **the END of a** `queue` and repeat the process.\\n\\n---\\n\\n- **Queue DS**\\n\\nIf you haven\\'t already familiar with [Queue DS](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)), just follow the link to know more!\\n\\n1. change `tickets` variable by initializing a `deque` and **map** `i` and `v` for current buyer, \\n2. initialize `ans` variable and `while` loop, that\\'ll iterate **infinitely**\\n3. pop from `tickets` current buyer\\n4. increment total amount `ans` \\n5. check, if the current buyer has bought all of the tickets, and return `ans`\\n6. otherwise, if he needs to buy **more** tickets, return him to the `tickets` queue\\n\\n```python\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        tickets = deque([[i, v] for i, v in enumerate(tickets)])\\n        ans = 0\\n\\n        while True:\\n            i, v = tickets.popleft()\\n            ans += 1\\n\\n            if i == k and v - 1 == 0:\\n                return ans\\n            \\n            if v > 1:\\n                tickets.append([i, v - 1])\\n```\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating infinitely over all `tickets` buyers\\n\\n- Space complexity: **O(n)**, to map indexes and values for `tickets`\\n\\n---\\n\\n- **Inifinite looping**\\nThe approach is the same, but we **mutate** the initial values of `tickets`.\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        if tickets[k] == 0:\\n            return 0\\n        \\n        i = 0\\n        ans = 0\\n\\n        while True:\\n            if tickets[i]:\\n                tickets[i] -= 1\\n                ans += 1\\n\\n            if i == k and tickets[i] == 0:\\n                return ans\\n            \\n            i += 1\\n            \\n            if i == len(tickets):\\n                i = 0\\n\\n```\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating infinitely over all `tickets` buyers\\n\\n- Space complexity: **O(1)**, because we don\\'t use extra space.\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        tickets = deque([[i, v] for i, v in enumerate(tickets)])\\n        ans = 0\\n\\n        while True:\\n            i, v = tickets.popleft()\\n            ans += 1\\n\\n            if i == k and v - 1 == 0:\\n                return ans\\n            \\n            if v > 1:\\n                tickets.append([i, v - 1])\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        if tickets[k] == 0:\\n            return 0\\n        \\n        i = 0\\n        ans = 0\\n\\n        while True:\\n            if tickets[i]:\\n                tickets[i] -= 1\\n                ans += 1\\n\\n            if i == k and tickets[i] == 0:\\n                return ans\\n            \\n            i += 1\\n            \\n            if i == len(tickets):\\n                i = 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367526,
                "title": "time-needed-to-buy-tickets-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int i, time=0;\\n        while(true)\\n        {\\n            for(i=0 ; i<tickets.size() ; i++)\\n            {\\n                if(tickets[k]==0)\\n                    return time;\\n                else if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    time++;\\n                }\\n            }\\n            i=0;\\n        }\\n        return time;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int i, time=0;\\n        while(true)\\n        {\\n            for(i=0 ; i<tickets.size() ; i++)\\n            {\\n                if(tickets[k]==0)\\n                    return time;\\n                else if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    time++;\\n                }\\n            }\\n            i=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158772,
                "title": "easy-solution-with-explanation",
                "content": "If you like it, please upvote\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    // current index\\n    let i = 0;\\n    // number of steps\\n    let steps = 0;\\n\\n    // while tickets[k] > 0\\n    while (tickets[k]) {\\n        // we do not need to reset i because it is easier to calculate index in the array\\n        const index = i % tickets.length;\\n        if (tickets[index]) {\\n            // if element is not 0 then decrement the value and increment the number of steps\\n            tickets[index]--;\\n            steps++;\\n        }\\n        // every time move to next element\\n        i++;\\n    }\\n\\n    return steps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    // current index\\n    let i = 0;\\n    // number of steps\\n    let steps = 0;\\n\\n    // while tickets[k] > 0\\n    while (tickets[k]) {\\n        // we do not need to reset i because it is easier to calculate index in the array\\n        const index = i % tickets.length;\\n        if (tickets[index]) {\\n            // if element is not 0 then decrement the value and increment the number of steps\\n            tickets[index]--;\\n            steps++;\\n        }\\n        // every time move to next element\\n        i++;\\n    }\\n\\n    return steps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3076905,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans =0;\\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                ans+=Math.min(tickets[i],tickets[k]);\\n            }else{\\n                ans+=Math.min(tickets[k]-1,tickets[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans =0;\\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                ans+=Math.min(tickets[i],tickets[k]);\\n            }else{\\n                ans+=Math.min(tickets[k]-1,tickets[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061869,
                "title": "java-1ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i] > 0) {\\n                    count++;\\n                    tickets[i]--;\\n                }\\n                if (i == k && tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i] > 0) {\\n                    count++;\\n                    tickets[i]--;\\n                }\\n                if (i == k && tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936461,
                "title": "cpp-queue-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        queue<int> q;\\n        int n=tickets.size();\\n        for(int i=0;i<n;i++) q.push(i);\\n\\n        while(true)\\n        {\\n            if(tickets[k]==0) break;\\n            int curr=q.front();\\n            time++;\\n            tickets[curr]--;\\n            q.pop();\\n            if(tickets[curr]!=0) \\n            {\\n                q.push(curr);\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        queue<int> q;\\n        int n=tickets.size();\\n        for(int i=0;i<n;i++) q.push(i);\\n\\n        while(true)\\n        {\\n            if(tickets[k]==0) break;\\n            int curr=q.front();\\n            time++;\\n            tickets[curr]--;\\n            q.pop();\\n            if(tickets[curr]!=0) \\n            {\\n                q.push(curr);\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919190,
                "title": "c-basic-solution-beats-100",
                "content": "# Intuition\\nBasic C++ Solution using logic\\n\\n# Approach\\nCounting tickets to be bought before and after k by taking minima.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(i<=k)\\n              time+=min(tickets[i],tickets[k]);\\n            else\\n              time+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(i<=k)\\n              time+=min(tickets[i],tickets[k]);\\n            else\\n              time+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903503,
                "title": "js-very-easy-and-fast-solution-o-n",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let output = 0;\\n    const kTickets = tickets[k];\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i !== k) {\\n            const currentTickets = tickets[i];\\n            const dif = currentTickets - kTickets;\\n            if (i < k) {\\n                output += kTickets + (dif < 0 ? dif : 0);\\n            } else {\\n                output += (dif + 1 > 0 ? kTickets - 1 : currentTickets);\\n            }\\n        }\\n    }\\n    return output + kTickets;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let output = 0;\\n    const kTickets = tickets[k];\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i !== k) {\\n            const currentTickets = tickets[i];\\n            const dif = currentTickets - kTickets;\\n            if (i < k) {\\n                output += kTickets + (dif < 0 ? dif : 0);\\n            } else {\\n                output += (dif + 1 > 0 ? kTickets - 1 : currentTickets);\\n            }\\n        }\\n    }\\n    return output + kTickets;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852598,
                "title": "java-code-without-queue-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n    int ans=0;\\n\\n    while(tickets[k]>0){\\n        \\n    int count=0;\\n\\n    for(int j=0;j<tickets.length;j++){\\n\\n        if(tickets[j]>0&&tickets[k]!=0){\\n            tickets[j]-=1;\\n            count+=1;\\n        }\\n\\n    }\\n\\n    ans=ans+count;\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n    int ans=0;\\n\\n    while(tickets[k]>0){\\n        \\n    int count=0;\\n\\n    for(int j=0;j<tickets.length;j++){\\n\\n        if(tickets[j]>0&&tickets[k]!=0){\\n            tickets[j]-=1;\\n            count+=1;\\n        }\\n\\n    }\\n\\n    ans=ans+count;\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724197,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=tickets[k];\\n        for(int i=0;i<tickets.size();i++){\\n        if(i<k){\\n            if(tickets[i]<=tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=tickets[k];\\n            }\\n        }\\n        else if(i>k){\\n            if(tickets[i]<tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=(tickets[k]-1);\\n            }\\n        }\\n    }\\n    return time;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=tickets[k];\\n        for(int i=0;i<tickets.size();i++){\\n        if(i<k){\\n            if(tickets[i]<=tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=tickets[k];\\n            }\\n        }\\n        else if(i>k){\\n            if(tickets[i]<tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=(tickets[k]-1);\\n            }\\n        }\\n    }\\n    return time;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596216,
                "title": "java-time-complexity-o-n-and-space-complexity-o-1-100-faster",
                "content": "Idea is quite simple\\n1. All the seconds will be consumed if tickets[i] < tickets [k].\\n2. If tickets[i] > tickets[k] then only tickets[k] will be consumed.\\n3. Just an exception to the 2nd point is that for the last iteration when all the people will consume 1 second, this will be people from 0 -> k. Hence we do tickets[k] - 1\\n\\n```\\nint minRequired = tickets[k];\\n        int output = 0;\\n\\n        for (int i = 0; i < tickets.length; i++) {\\n            if(tickets[i] < minRequired){\\n                output += tickets[i];\\n            }else {\\n\\n                if(i > k){\\n                    output--;\\n                }\\n                output += minRequired;\\n            }\\n        }\\n\\n        return output;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Idea is quite simple\\n1. All the seconds will be consumed if tickets[i] < tickets [k].\\n2. If tickets[i] > tickets[k] then only tickets[k] will be consumed.\\n3. Just an exception to the 2nd point is that for the last iteration when all the people will consume 1 second, this will be people from 0 -> k. Hence we do tickets[k] - 1\\n\\n```\\nint minRequired = tickets[k];\\n        int output = 0;\\n\\n        for (int i = 0; i < tickets.length; i++) {\\n            if(tickets[i] < minRequired){\\n                output += tickets[i];\\n            }else {\\n\\n                if(i > k){\\n                    output--;\\n                }\\n                output += minRequired;\\n            }\\n        }\\n\\n        return output;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2558725,
                "title": "java-solution-using-single-queue",
                "content": "In this solution, I multiply the target index \\'k\\' content with \\'-1\\'. to keep track of the customer.\\nAnd, I reduce the number of tickets by 1. Once the target customer\\'s tickets count reduces to zero, I return the time-taken.\\n\\n```java\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        if(tickets[k] == 0) return 0;\\n        \\n        tickets[k] = -1 * tickets[k];\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for(int n : tickets){\\n            if(n != 0) queue.offerLast(n);\\n        }\\n        \\n        int timeTaken = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int ticket = queue.pollFirst();\\n            \\n            boolean target = ticket < 0;\\n            \\n            if(ticket < 0) ticket += 1;\\n            else ticket -= 1;\\n            \\n            ++timeTaken;\\n            \\n            if(ticket == 0 && target) break;\\n            if(ticket != 0) queue.offerLast(ticket);\\n        }\\n        \\n        return timeTaken;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Iterator"
                ],
                "code": "```java\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        if(tickets[k] == 0) return 0;\\n        \\n        tickets[k] = -1 * tickets[k];\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for(int n : tickets){\\n            if(n != 0) queue.offerLast(n);\\n        }\\n        \\n        int timeTaken = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int ticket = queue.pollFirst();\\n            \\n            boolean target = ticket < 0;\\n            \\n            if(ticket < 0) ticket += 1;\\n            else ticket -= 1;\\n            \\n            ++timeTaken;\\n            \\n            if(ticket == 0 && target) break;\\n            if(ticket != 0) queue.offerLast(ticket);\\n        }\\n        \\n        return timeTaken;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195525,
                "title": "java-o-n-100-faster-solution",
                "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int t=tickets[k],tt=0;\\n        \\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                if(tickets[i]<=t){\\n                    tt+=tickets[i];\\n                }else{\\n                    tt+=t;\\n                }\\n            }else{\\n                if(tickets[i]<t){\\n                    tt+=tickets[i];\\n                }else{\\n                    tt+=(t-1);\\n                }\\n            }\\n        }\\n        \\n        return tt;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int t=tickets[k],tt=0;\\n        \\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                if(tickets[i]<=t){\\n                    tt+=tickets[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2126547,
                "title": "c-solution-0ms-100-faster-explained",
                "content": "**Method:**\\n\\n* There can be 3 cases:\\n* Case 1 :\\n    * If the ticket holders have less tickets to buy than our Kth ticket holder\\n    * Then, they will have got all the tickets they wanted before kth ticket holder gets all its tickets\\n* Case 2:\\n    * if the ticket holders have more tickets to buy than our Kth ticket holder and they are ahead in line(position < k) \\n    * Then, they will have bought \"tickets[k]\" tickets before kth ticket holder gets all the tickets it needs\\n* Case 3:\\n    * if the ticket holders have more tickets to buy than our Kth ticket holder, and they are behind in line(position > k) \\n    * Then, they will have bought 1 ticket less than tickets[k] before kth ticket holder gets all the tickets it needs.\\n\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int timeRequiredToBuy(vector<int> &tickets, int k)\\n    {\\n        int n = tickets.size();\\n        int t = tickets[k];\\n        int s = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (tickets[i] < t)\\n            {\\n                s += tickets[i];\\n            }\\n            else\\n            {\\n                if (i <= k)\\n                {\\n                    s += t;\\n                }\\n                else\\n                {\\n                    s += t - 1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int timeRequiredToBuy(vector<int> &tickets, int k)\\n    {\\n        int n = tickets.size();\\n        int t = tickets[k];\\n        int s = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (tickets[i] < t)\\n            {\\n                s += tickets[i];\\n            }\\n            else\\n            {\\n                if (i <= k)\\n                {\\n                    s += t;\\n                }\\n                else\\n                {\\n                    s += t - 1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903082,
                "title": "python-solution-using-list-as-queue",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        while(tickets[k]!=0):\\n            c+=1\\n\\t\\t\\t#check if kth element is now the first element of our queue.\\n            if(tickets[0]==1):\\n                tickets.pop(0)\\n                if(k==0):\\n                    return(c)\\n                else:\\n                    k-=1\\n            else:\\n\\t\\t\\t#if no of tickets of person at first position in queue are more than 1 we move to the back\\n                tickets.append(tickets[0]-1)\\n                tickets.pop(0)\\n                if(k==0):\\n                    k=len(tickets)-1\\n                else:\\n                    k-=1\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        while(tickets[k]!=0):\\n            c+=1\\n\\t\\t\\t#check if kth element is now the first element of our queue.\\n            if(tickets[0]==1):\\n                tickets.pop(0)\\n                if(k==0):\\n                    return(c)\\n                else:\\n                    k-=1\\n            else:\\n\\t\\t\\t#if no of tickets of person at first position in queue are more than 1 we move to the back\\n                tickets.append(tickets[0]-1)\\n                tickets.pop(0)\\n                if(k==0):\\n                    k=len(tickets)-1\\n                else:\\n                    k-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826842,
                "title": "c-solution-with-comments-faster-than-100-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int need = tickets[k];\\n        int wait = need; // k has to buy their own tickets.\\n        \\n        // For each person ahead of k in line, k has to wait for them\\n        // to buy up to as many tickets as k needs.\\n        for (int i = 0; i < k; ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        // For each person in line after k, k has to wait for them\\n        // to buy up to 1 fewer ticket than k needs.\\n        --need;\\n        for (int i = k + 1; i < tickets.size(); ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        return wait;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int need = tickets[k];\\n        int wait = need; // k has to buy their own tickets.\\n        \\n        // For each person ahead of k in line, k has to wait for them\\n        // to buy up to as many tickets as k needs.\\n        for (int i = 0; i < k; ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        // For each person in line after k, k has to wait for them\\n        // to buy up to 1 fewer ticket than k needs.\\n        --need;\\n        for (int i = k + 1; i < tickets.size(); ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        return wait;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726337,
                "title": "c-o-n-solution",
                "content": "eg: [84,49,5,24,70,77,87,8]\\n       k = 3\\n\\t   time added due to index 0(84) : 24\\n\\t   time added due to index 1(49) : 24\\n\\t   time added due to index 2(5) : 5\\n\\t   time added due to index 3(24) : 24\\n\\t   time added due to index 4(70) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 5(77) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 5(87) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 6(8) : 8\\n     total time = 154 ans\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        for(int i = 0;i < n;i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        for(int i = 0;i < n;i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604802,
                "title": "python-one-pass-o-1-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        x=tickets[k]\\n        answer=0\\n        for i in range(0,k+1):\\n            answer+=min(x,tickets[i])\\n        \\n        for i in range(k+1,len(tickets)):\\n            answer+=min(x-1,tickets[i]) \\n        \\n        return answer",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        x=tickets[k]\\n        answer=0\\n        for i in range(0,k+1):\\n            answer+=min(x,tickets[i])\\n        \\n        for i in range(k+1,len(tickets)):\\n            answer+=min(x-1,tickets[i]) \\n        \\n        return answer",
                "codeTag": "Java"
            },
            {
                "id": 1599519,
                "title": "one-pass-100-solution-o-n",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        \\n        for(int i = 0;i<k;i++){\\n            if(tickets[i] >= tickets[k])\\n                res+= tickets[k];\\n            else\\n                res+= tickets[i];\\n        }\\n        for(int i = k+1;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]-1)\\n                res+= tickets[k]-1;\\n            else\\n                res+= tickets[i];\\n        }\\n        \\n        return res + tickets[k];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        \\n        for(int i = 0;i<k;i++){\\n            if(tickets[i] >= tickets[k])\\n                res+= tickets[k];\\n            else\\n                res+= tickets[i];\\n        }\\n        for(int i = k+1;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]-1)\\n                res+= tickets[k]-1;\\n            else\\n                res+= tickets[i];\\n        }\\n        \\n        return res + tickets[k];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577065,
                "title": "c-brute-force",
                "content": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    tickets[i] -= 1;\\n                    res += 1;\\n                }\\n                if(tickets[k] == 0) break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    tickets[i] -= 1;\\n                    res += 1;\\n                }\\n                if(tickets[k] == 0) break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577017,
                "title": "javascript-one-pass",
                "content": "```javascript\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let total = 0;\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i === k || tickets[i] < tickets[k]) {\\n            total += tickets[i];\\n        } else if (i > k) {\\n            total +=  tickets[k] - 1;\\n        } else {\\n            total += tickets[k];\\n        }\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let total = 0;\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i === k || tickets[i] < tickets[k]) {\\n            total += tickets[i];\\n        } else if (i > k) {\\n            total +=  tickets[k] - 1;\\n        } else {\\n            total += tickets[k];\\n        }\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576972,
                "title": "c-2073-time-needed-to-buy-tickets",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0; \\n        for (int i = 0; i < tickets.size(); ++i) {\\n            if (i == k+1) tickets[k] -= 1; \\n            ans += min(tickets[i], tickets[k]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0; \\n        for (int i = 0; i < tickets.size(); ++i) {\\n            if (i == k+1) tickets[k] -= 1; \\n            ans += min(tickets[i], tickets[k]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576966,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ret = 0\\n        while tickets[k]:\\n            for i, t in enumerate(tickets):\\n                if t > 0:\\n                    tickets[i] = tickets[i] - 1\\n                    ret += 1\\n                if i == k:\\n                    if tickets[i] == 0:\\n                        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ret = 0\\n        while tickets[k]:\\n            for i, t in enumerate(tickets):\\n                if t > 0:\\n                    tickets[i] = tickets[i] - 1\\n                    ret += 1\\n                if i == k:\\n                    if tickets[i] == 0:\\n                        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576950,
                "title": "java-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] arr, int k) {\\n        int count = 0;\\n        while(true)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]>0)\\n                {\\n                    arr[i] = arr[i]-1;\\n                    count = count+1;\\n                }\\n                if(arr[k] == 0)\\n                {\\n                    return count;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] arr, int k) {\\n        int count = 0;\\n        while(true)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]>0)\\n                {\\n                    arr[i] = arr[i]-1;\\n                    count = count+1;\\n                }\\n                if(arr[k] == 0)\\n                {\\n                    return count;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894192,
                "title": "c-linq",
                "content": "```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k)\\n      => tickets\\n          .Select((n, i) => Math.Min(n, tickets[k]) - (i > k && n >= tickets[k] ? 1 : 0))\\n          .Sum();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k)\\n      => tickets\\n          .Select((n, i) => Math.Min(n, tickets[k]) - (i > k && n >= tickets[k] ? 1 : 0))\\n          .Sum();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668409,
                "title": "c-solution-using-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int summation(vector<int>tickets){\\n        int sum = 0 ; \\n        for(int i = 0 ; i < tickets.size() ; i++){\\n            sum += tickets[i];\\n        }\\n        return sum;\\n    }\\n    int solve(vector<int> tickets, int k,int mid){\\n        int i = 0;\\n        int n = tickets.size();\\n        while(mid != 0){\\n            if(tickets[i] != 0){\\n                mid--;\\n                tickets[i]--;\\n            }\\n            i = (i + 1) % n;;\\n            if(tickets[k] == 0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = summation(tickets);\\n        \\n        int s = 1 , e = sum , ans = 0;\\n\\n        while(s <= e){\\n            int mid = s + (e - s) / 2;\\n            int val = solve(tickets,k,mid);\\n\\n            if(val == 0){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int summation(vector<int>tickets){\\n        int sum = 0 ; \\n        for(int i = 0 ; i < tickets.size() ; i++){\\n            sum += tickets[i];\\n        }\\n        return sum;\\n    }\\n    int solve(vector<int> tickets, int k,int mid){\\n        int i = 0;\\n        int n = tickets.size();\\n        while(mid != 0){\\n            if(tickets[i] != 0){\\n                mid--;\\n                tickets[i]--;\\n            }\\n            i = (i + 1) % n;;\\n            if(tickets[k] == 0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = summation(tickets);\\n        \\n        int s = 1 , e = sum , ans = 0;\\n\\n        while(s <= e){\\n            int mid = s + (e - s) / 2;\\n            int val = solve(tickets,k,mid);\\n\\n            if(val == 0){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633906,
                "title": "time-needed-to-buy-tickets-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI will be taking the given array index in the queue array rather than the acutal stored values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will first enqueue index of the given array in the queue array. We are queuing the array index rather than its value because we need to focus on the person for who we need to find the time taken to buy his tickets. The time will be incremented by 1s for everytime we iterate over the loop. First we will assign the first/front element of the queue to the temp variable(here in my program it is front). Then we will dequeue that first element from the <b>queue</b>. After that we will start checking with the conditions. First condition is, we will check for the value of the tickets[front] is atleast 1 if it is, then we will decrement it by 1. Second Condition, we will check if the front(temp variable) is equal to the k and if the value of the tickets[front] is 0 if it is, then we will break the loop and return the time. Third Condition, we will check if the front!=k and the tickets[front] is equal to 0 if it is, we will continue with the iteration we don\\'t enqueue that element again in the queue. If the condition 2, 3 fails then will enqueue that front(temp variable) in the queue again.\\n\\nAt last of the code I have reintialized the head and tail to -1; As sometimes there are some unexpected behavior in leetcode while executing the test cases.\\n\\n# Code\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define N 10000 \\n\\nint queue[N];\\n\\nint head=-1, tail=-1; \\n\\nint isEmpty(), isFull();\\n\\nvoid enqueue(int x), dequeue();\\nint peek();\\n\\nint isEmpty() {\\n    if(head == -1 && tail==-1) \\n        return 1;\\n    else \\n        return 0;\\n}\\n\\nint isFull() {\\n    if(tail==N-1)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nvoid enqueue(int x) {\\n    if(isFull()) { \\n        printf(\"ERROR: queue overflow\\\\n\");\\n        exit(1); //Enqueuing Failure\\n    }\\n    else if(isEmpty()) {\\n        tail++, head++;\\n        queue[tail] = x;\\n    }\\n    else {\\n        queue[++tail] = x;\\n    }\\n}\\n\\nvoid dequeue() {\\n   if(isEmpty()) {\\n    printf(\"ERROR: queue underflow\\\\n add some elements\\\\n\");\\n   }\\n   else if(head == tail) {\\n    head = -1;\\n    tail = -1;\\n   }\\n   else if(!isEmpty()) {\\n    queue[head++];\\n   }\\n}\\n\\nint peek() {\\n    if(isEmpty()) {\\n        printf(\"NO ELEMENTS\\\\n\");\\n        return;\\n    }\\n    else {\\n       return queue[head];\\n    }\\n}\\n\\n\\nint timeRequiredToBuy(int* tickets, int ticketsSize, int k){\\n    int time=0;\\n    for(int itr=0; itr<ticketsSize; itr++) {\\n        enqueue(itr);\\n    }\\n    while(1) {\\n       time++; \\n       int front=peek();\\n       dequeue();\\n       if(tickets[front]>=1) \\n\\t       tickets[front]--;\\n       if(tickets[front]==0 && front!=k)\\n\\t       continue;\\n       if(tickets[front]==0 && front==k)\\n\\t       break;\\n       enqueue(front);\\n    }\\n    head=-1;\\n    tail=-1;\\n    return time;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define N 10000 \\n\\nint queue[N];\\n\\nint head=-1, tail=-1; \\n\\nint isEmpty(), isFull();\\n\\nvoid enqueue(int x), dequeue();\\nint peek();\\n\\nint isEmpty() {\\n    if(head == -1 && tail==-1) \\n        return 1;\\n    else \\n        return 0;\\n}\\n\\nint isFull() {\\n    if(tail==N-1)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nvoid enqueue(int x) {\\n    if(isFull()) { \\n        printf(\"ERROR: queue overflow\\\\n\");\\n        exit(1); //Enqueuing Failure\\n    }\\n    else if(isEmpty()) {\\n        tail++, head++;\\n        queue[tail] = x;\\n    }\\n    else {\\n        queue[++tail] = x;\\n    }\\n}\\n\\nvoid dequeue() {\\n   if(isEmpty()) {\\n    printf(\"ERROR: queue underflow\\\\n add some elements\\\\n\");\\n   }\\n   else if(head == tail) {\\n    head = -1;\\n    tail = -1;\\n   }\\n   else if(!isEmpty()) {\\n    queue[head++];\\n   }\\n}\\n\\nint peek() {\\n    if(isEmpty()) {\\n        printf(\"NO ELEMENTS\\\\n\");\\n        return;\\n    }\\n    else {\\n       return queue[head];\\n    }\\n}\\n\\n\\nint timeRequiredToBuy(int* tickets, int ticketsSize, int k){\\n    int time=0;\\n    for(int itr=0; itr<ticketsSize; itr++) {\\n        enqueue(itr);\\n    }\\n    while(1) {\\n       time++; \\n       int front=peek();\\n       dequeue();\\n       if(tickets[front]>=1) \\n\\t       tickets[front]--;\\n       if(tickets[front]==0 && front!=k)\\n\\t       continue;\\n       if(tickets[front]==0 && front==k)\\n\\t       break;\\n       enqueue(front);\\n    }\\n    head=-1;\\n    tail=-1;\\n    return time;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3450924,
                "title": "javascript-100-o-n-time-o-1-space",
                "content": "# Approach\\n\\nTake the `tickets` array below as an example.\\n\\n`[ 8, 2, 4, 6, 1]`\\n\\nIf we wanted to compute the result for `k = 2` (`tickets[2] = 4`), we would have to consider the following scenarios:\\n\\n1. It would take 4 seconds to buy the tickets for the target person, since `tickets[k] == 4`\\n2. `tickets[0]` is 8, but we only need 4 tickets, therefore we only wait for him 4 times\\n3. `tickets[1]` is 2, which is smaller than 4. This person would leave the before we finish buying our tickets, therefore we would only wait for him 2 times\\n4. `tickets[3]` is 6, but we are initially in front of him, therefore we only wait for him after we are placed at the back of the queue, or `tickets[k] - 1` times\\n\\n```\\nfunction timeRequiredToBuy(tickets, k) {\\n    // Scenario 1\\n    let result = tickets[k];\\n\\n    // Scenario 2 and 3\\n    for (let i = 0; i < k; i++) {\\n        result += Math.min(tickets[k], tickets[i]);\\n    }\\n\\n    // Scenario 4\\n    for (let i = k + 1; i < tickets.length; i++) {\\n        result += Math.min(tickets[k] - 1, tickets[i]);\\n    }\\n\\n    return result;\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nfunction timeRequiredToBuy(tickets, k) {\\n    // Scenario 1\\n    let result = tickets[k];\\n\\n    // Scenario 2 and 3\\n    for (let i = 0; i < k; i++) {\\n        result += Math.min(tickets[k], tickets[i]);\\n    }\\n\\n    // Scenario 4\\n    for (let i = k + 1; i < tickets.length; i++) {\\n        result += Math.min(tickets[k] - 1, tickets[i]);\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3198622,
                "title": "100-easy-js-solution-explained-with-proper-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Implemented the problem with the *greedy approach* that involves buying tickets from a queue.\\n- The *goal* of the problem is :-\\n*\"To calculate the amount of time required to buy all the tickets at position k, where each purchase takes one unit of time and the buyer moves to the next position in the queue after each purchase.\"*\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- The *tickets* array represents the number of available tickets at each *position* in the *queue*, and the function *timeRequiredToBuy* takes *two* *arguments*: *tickets* and *k*.\\n1. The approach taken in the below code is to use a *while* loop that continues until the kth element of the tickets array becomes 0. \\n2. Within the *while* loop, the code uses a *modulo operator* to wrap around the queue and ensure that it starts over at the beginning after reaching the end.\\n3. On each *iteration* of the *while* loop, the code checks if the current position has any *available tickets*.\\n4.  If it does, it *decrements* the ticket count and increments a counter for the number of tickets purchased.\\n5. Finally, the function returns the *total count of tickets* purchased, which represents the *time required to buy all the tickets at position k.*\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here N is the length of the tickets array. \\n2. This is because the while loop will continue until the kth element of the tickets array becomes 0, and each iteration of the while loop will iterate over each element of the tickets array once.\\n\\n\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because the only additional space used is for the variables i, count, and pos, which are all constant in size and do not depend on the size of the input.\\n2.  The tickets array is modified in place, so no additional space is used for it.\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n\\n    let N = tickets.length;\\n\\n    // current index\\n    let i = 0;\\n\\n    // no. of count\\n    let count = 0;\\n\\n    while (tickets[k] > 0) {\\n\\n        let pos = i % N;\\n\\n        if (tickets[pos]) {\\n\\n            tickets[pos]--;\\n            count++;\\n        }  \\n        // moving everytime to next element\\n        i++;\\n    }\\n    return count;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/6f36285e-0bab-460e-9f8c-0f16bf19e852_1676657371.1775663.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n\\n    let N = tickets.length;\\n\\n    // current index\\n    let i = 0;\\n\\n    // no. of count\\n    let count = 0;\\n\\n    while (tickets[k] > 0) {\\n\\n        let pos = i % N;\\n\\n        if (tickets[pos]) {\\n\\n            tickets[pos]--;\\n            count++;\\n        }  \\n        // moving everytime to next element\\n        i++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2847752,
                "title": "time-needed-to-buy-tickets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\nq.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\nq.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833494,
                "title": "explained-java-soln",
                "content": "\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n\\n        int time=0;\\n\\n  \\n       for(int i =0; i<tickets.length;i++){\\n// if position i<k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i].   \\n\\n           if(i<k){\\n               if(tickets[i]<=tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]\\n                else \\n                time+=tickets[k];\\n           }\\n// if position i>k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i]. \\n\\n           if(i>k){\\n               if(tickets[i]<tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]-1(cause loop will break before time hits ticket[k] for later part.),\\n                else\\n                time+=tickets[k]-1;\\n           }\\n//if i==k just add time+=tickets[k]\\n\\n                if(i==k) time+=tickets[k];\\n\\n\\n\\n           \\n           System.out.println(time);\\n           \\n\\n\\n       }\\n\\n        \\n\\n        return time;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n\\n        int time=0;\\n\\n  \\n       for(int i =0; i<tickets.length;i++){\\n// if position i<k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i].   \\n\\n           if(i<k){\\n               if(tickets[i]<=tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]\\n                else \\n                time+=tickets[k];\\n           }\\n// if position i>k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i]. \\n\\n           if(i>k){\\n               if(tickets[i]<tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]-1(cause loop will break before time hits ticket[k] for later part.),\\n                else\\n                time+=tickets[k]-1;\\n           }\\n//if i==k just add time+=tickets[k]\\n\\n                if(i==k) time+=tickets[k];\\n\\n\\n\\n           \\n           System.out.println(time);\\n           \\n\\n\\n       }\\n\\n        \\n\\n        return time;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557446,
                "title": "js-two-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/2073-time-needed-to-buy-tickets-queue.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n**Javascript One Liner code**\\n\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    return tickets.reduce((x, v, i)=>x + Math.min(v, tickets[k] - (i > k)), 0);\\n};\\n```\\n\\n```\\nRuntime: 96 ms, faster than 38.86% of JavaScript online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 41.6 MB, less than 89.10% of JavaScript online submissions for Time Needed to Buy Tickets.\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    return tickets.reduce((x, v, i)=>x + Math.min(v, tickets[k] - (i > k)), 0);\\n};\\n```\n```\\nRuntime: 96 ms, faster than 38.86% of JavaScript online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 41.6 MB, less than 89.10% of JavaScript online submissions for Time Needed to Buy Tickets.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2553069,
                "title": "python-easy-queue-and-recursion-solution",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        queue = deque(tickets)\\n        \\n        self.time_taken = 0\\n        \\n        self.rec(queue, k)\\n        \\n        return self.time_taken\\n    \\n    def rec(self, queue, k):\\n        for idx, ele in enumerate(queue):\\n            if ele:\\n                queue[idx] -= 1\\n                if idx == k and not queue[idx]:\\n                    self.time_taken += 1\\n                    return self.time_taken\\n                else:\\n                    self.time_taken += 1\\n        self.rec(queue, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        queue = deque(tickets)\\n        \\n        self.time_taken = 0\\n        \\n        self.rec(queue, k)\\n        \\n        return self.time_taken\\n    \\n    def rec(self, queue, k):\\n        for idx, ele in enumerate(queue):\\n            if ele:\\n                queue[idx] -= 1\\n                if idx == k and not queue[idx]:\\n                    self.time_taken += 1\\n                    return self.time_taken\\n                else:\\n                    self.time_taken += 1\\n        self.rec(queue, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458459,
                "title": "go-simple-solution-using-queue-60-faster-70-less-memory-needed",
                "content": "func timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tout := 0\\n\\tendMainLoop := false\\n\\n\\tfor !endMainLoop {\\n\\n\\t\\tend := len(tickets)\\n\\n\\t\\tif tickets[k] == 1 {\\n\\t\\t\\tend = k + 1\\n\\t\\t\\tendMainLoop = true\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < end; i++ {\\n\\n\\t\\t\\telem := tickets[0]\\n\\n\\t\\t\\tif elem > 0 {\\n\\t\\t\\t\\telem--\\n\\t\\t\\t\\tout++\\n\\t\\t\\t}\\n\\n\\t\\t\\ttickets = append(tickets[1:], elem)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "func timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tout := 0\\n\\tendMainLoop := false\\n\\n\\tfor !endMainLoop {\\n\\n\\t\\tend := len(tickets)\\n\\n\\t\\tif tickets[k] == 1 {\\n\\t\\t\\tend = k + 1\\n\\t\\t\\tendMainLoop = true\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < end; i++ {\\n\\n\\t\\t\\telem := tickets[0]\\n\\n\\t\\t\\tif elem > 0 {\\n\\t\\t\\t\\telem--\\n\\t\\t\\t\\tout++\\n\\t\\t\\t}\\n\\n\\t\\t\\ttickets = append(tickets[1:], elem)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2429131,
                "title": "c-simply-explained-with-steps",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < tickets.size(); ++i) {\\n                if (tickets[i] == 0) continue; // skips element, does not count if ticket is 0, like it\\'s not even there\\n                tickets[i]--; // decreases by 1 of all elements one by one\\n                ++step; // 1 second increment\\n                if (tickets[k] == 0) return step; // if target is having 0 tickets, return total time\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < tickets.size(); ++i) {\\n                if (tickets[i] == 0) continue; // skips element, does not count if ticket is 0, like it\\'s not even there\\n                tickets[i]--; // decreases by 1 of all elements one by one\\n                ++step; // 1 second increment\\n                if (tickets[k] == 0) return step; // if target is having 0 tickets, return total time\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400565,
                "title": "c-easy-approach",
                "content": "Basically we need to find the time to make tickets[k] equals to zero.\\nIn every iteration if the element is not equal to zero then decrease it by one and increase the count of time.\\nint i could be greatter than n so use i%n so that it remains in range of array given.\\n```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=0;\\n        int i=0;\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n            }\\n            i++;\\n        }\\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=0;\\n        int i=0;\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n            }\\n            i++;\\n        }\\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2343054,
                "title": "short-javascript-solution",
                "content": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let seconds = 0;\\n\\n    while (tickets[k] > 0) {\\n        for (let i = 0; i < tickets.length; i++) {\\n            if (tickets[k] === 0) break\\n            if (tickets[i] > 0) {\\n                tickets[i]--\\n                seconds++\\n            }\\n        }\\n    }\\n\\t\\n    return seconds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let seconds = 0;\\n\\n    while (tickets[k] > 0) {\\n        for (let i = 0; i < tickets.length; i++) {\\n            if (tickets[k] === 0) break\\n            if (tickets[i] > 0) {\\n                tickets[i]--\\n                seconds++\\n            }\\n        }\\n    }\\n\\t\\n    return seconds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326133,
                "title": "c-all-approaches-complexity-analysis-efficient-solution",
                "content": "2 APPROACHES : \\n1. Queue\\nTC : O( t )   ->t is the time ( iterations) done to make the tickets[ k ]=0 \\nSC : O(N)  -> We store N elements in queue at first\\n\\n2. Vector :\\nTC : O( t ) \\nSC : O(1) ->no extra space required\\n\\nNOTE  :The runtime and memory usage of vector soution is less than that of Queue solution .\\n(as it can be seen clearly as well from the complexity analysis) \\n\\nUPVOTE IF YOU LIKE \\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n// USING QUEUE : \\n    int timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<nums.size();i++){\\n            q.push({nums[i],i});\\n        }\\n    \\n        while(!q.empty()){\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            p.first--;\\n            ans+=1;\\n            if(p.second==k && p.first==0)return ans;\\n            else if(p.first!=0)q.push(p);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nUSING VECTOR :\\nRuntime and memory usage of This solution is better than the queue sol.\\n*/\\nint timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        while(nums[k]!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]==0 && i!=k)continue;\\n                nums[i]--;\\n                ans+=1;\\n                if(nums[k]==0)return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// USING QUEUE : \\n    int timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<nums.size();i++){\\n            q.push({nums[i],i});\\n        }\\n    \\n        while(!q.empty()){\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            p.first--;\\n            ans+=1;\\n            if(p.second==k && p.first==0)return ans;\\n            else if(p.first!=0)q.push(p);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nUSING VECTOR :\\nRuntime and memory usage of This solution is better than the queue sol.\\n*/\\nint timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        while(nums[k]!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]==0 && i!=k)continue;\\n                nums[i]--;\\n                ans+=1;\\n                if(nums[k]==0)return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319753,
                "title": "o-n-python-treat-kth-and-kth-differently",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        l=len(tickets)\\n        for i in range(l):\\n            if i <= k:\\n                c+= min(tickets[k],tickets[i])\\n            else:\\n                c+= min(tickets[k]-1,tickets[i])\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        l=len(tickets)\\n        for i in range(l):\\n            if i <= k:\\n                c+= min(tickets[k],tickets[i])\\n            else:\\n                c+= min(tickets[k]-1,tickets[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296280,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        seconds = 0\\n        while tickets[k]!=0:\\n            \\n            for i in range(len(tickets)):\\n                if tickets[i]!=0 and tickets[k]!=0:\\n                    tickets[i] = tickets[i]-1\\n                    seconds +=1\\n        return seconds\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        seconds = 0\\n        while tickets[k]!=0:\\n            \\n            for i in range(len(tickets)):\\n                if tickets[i]!=0 and tickets[k]!=0:\\n                    tickets[i] = tickets[i]-1\\n                    seconds +=1\\n        return seconds\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282082,
                "title": "java-easy-solution-o-n-2-mehods",
                "content": "#### 1) \\n```\\nclass Solution {\\n  public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < tickets.length; i++) {\\n             ans += Math.min(tickets[i], tickets[k]);\\n\\n            if (i > k && tickets[i] >= tickets[k]) {\\n                ans--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n#### 2)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[k] == 0) {\\n                    return ans;\\n                }\\n                if (tickets[i] != 0) {\\n                    tickets[i] = tickets[i] - 1;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < tickets.length; i++) {\\n             ans += Math.min(tickets[i], tickets[k]);\\n\\n            if (i > k && tickets[i] >= tickets[k]) {\\n                ans--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[k] == 0) {\\n                    return ans;\\n                }\\n                if (tickets[i] != 0) {\\n                    tickets[i] = tickets[i] - 1;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271454,
                "title": "best-solution-in-c",
                "content": "**Please upvote if you like it :)**\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count=0;\\n        while(tickets[k])\\n        {\\n            for(int i=0;i<tickets.size();i++)\\n            {\\n                if(tickets[i])\\n                {\\n                    tickets[i]=tickets[i]-1;\\n                    count++;\\n                    if(tickets[k]==0)\\n                        return count;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count=0;\\n        while(tickets[k])\\n        {\\n            for(int i=0;i<tickets.size();i++)\\n            {\\n                if(tickets[i])\\n                {\\n                    tickets[i]=tickets[i]-1;\\n                    count++;\\n                    if(tickets[k]==0)\\n                        return count;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2269001,
                "title": "use-only-one-for-loop-10-lines-of-codes-bruteforce-java-solution",
                "content": "\\n2073. Time Needed to Buy Tickets\\njava solution\\nOnly 10 lines of codes\\n```\\n\\n\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n          int time=0;\\n          for(int i=0; i<tickets.length; i++){\\n              if(tickets[i]<tickets[k]) time+=tickets[i];\\n              else if(i<=k && tickets[i]>=tickets[k])time+=tickets[k];\\n              else if(i>k && tickets[i]>=tickets[k]) time+=tickets[k]-1;   \\n          }\\n          return(time);\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue"
                ],
                "code": "```\\n\\n\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n          int time=0;\\n          for(int i=0; i<tickets.length; i++){\\n              if(tickets[i]<tickets[k]) time+=tickets[i];\\n              else if(i<=k && tickets[i]>=tickets[k])time+=tickets[k];\\n              else if(i>k && tickets[i]>=tickets[k]) time+=tickets[k]-1;   \\n          }\\n          return(time);\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235304,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        \\n        //find the kth person and find m tickets to buy \\n        int times=tickets[k];\\n        \\n        //loop the array m-1 times\\n        for(int i:tickets)\\n        {   \\n            //if i>=m-1, that means this person has enough tickets to buy\\n            if(i>=times)\\n            {\\n                ans+=times-1;\\n            }else  //if i<m-1 that means this person does not have enough tickets to buy\\n            {\\n                ans+=i;\\n            }\\n        }\\n        \\n        //last lopp and stop at the person k\\n        for(int i=0;i<k+1;i++)\\n        {   ////if i>m-1, that means this person has enough tickets to buy\\n            if(tickets[i]>times-1)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        \\n        //find the kth person and find m tickets to buy \\n        int times=tickets[k];\\n        \\n        //loop the array m-1 times\\n        for(int i:tickets)\\n        {   \\n            //if i>=m-1, that means this person has enough tickets to buy\\n            if(i>=times)\\n            {\\n                ans+=times-1;\\n            }else  //if i<m-1 that means this person does not have enough tickets to buy\\n            {\\n                ans+=i;\\n            }\\n        }\\n        \\n        //last lopp and stop at the person k\\n        for(int i=0;i<k+1;i++)\\n        {   ////if i>m-1, that means this person has enough tickets to buy\\n            if(tickets[i]>times-1)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153645,
                "title": "c-o-n-solution-0ms-100-faster",
                "content": "**Important observations**\\n* Person standing at index i, before kth index , will buy either **tickets[k]** ticket or **tickets[i]** whichever is minimum,  before kth person buys the ticket. same is applicable for kth person.\\n* Person after kth index, will buy minimum of  **tickets[k] -1** ticket or **tickets[i]** ticket, before kth person buys all the tickets.\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        for(int i = 0; i <= k; i++) {\\n            res += min(tickets[k], tickets[i]);\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++) {\\n            res += min(tickets[k] - 1 , tickets[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        for(int i = 0; i <= k; i++) {\\n            res += min(tickets[k], tickets[i]);\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++) {\\n            res += min(tickets[k] - 1 , tickets[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098427,
                "title": "c-easy-solution-brute-force-to-optimized",
                "content": "\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        \\n// <------------------------------------------------------------------->\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t // Approach - 1 TC O(N*K) and SC O(1)\\n        int n=tickets.size();\\n        int cnt=0;\\n        while(tickets[k]>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    cnt++;\\n                }\\n                if(tickets[k]==0 )\\n                {\\n                    return cnt;\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n        \\n// <------------------------------------------------------------------->\\n\\n        // Appraoch - 2 TC O(N) and SC O(1)\\n        int i=0;\\n        int n=tickets.size();\\n        int sum=0;\\n        while(i<n)\\n        {\\n            if(i<=k)\\n                sum+=min(tickets[i],tickets[k]);\\n            else\\n                sum+=min(tickets[i],tickets[k]-1);\\n            i++;\\n        }\\n        return sum;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        \\n// <------------------------------------------------------------------->\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t // Approach - 1 TC O(N*K) and SC O(1)\\n        int n=tickets.size();\\n        int cnt=0;\\n        while(tickets[k]>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    cnt++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2096061,
                "title": "c-easy-solution-and-understandable",
                "content": "Solution 1 :\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = 0, x = tickets[k];\\n        for(int i = 0; i <= k; i++){\\n            if(tickets[i] <= x)\\n                sum+=tickets[i];\\n            else\\n                sum+=x;\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++){\\n            if(tickets[i] <= (x-1))\\n                sum+=tickets[i];\\n            else\\n                sum+=(x-1);\\n        }\\n        return sum;\\n    }\\n};\\n```\\nSolution 2 :\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = 0;\\n        while(tickets[k] > 0){\\n            for(int i = 0; i < tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    t++;\\n                    tickets[i]--;\\n                }\\n                if(tickets[k]==0)\\n                    break;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = 0, x = tickets[k];\\n        for(int i = 0; i <= k; i++){\\n            if(tickets[i] <= x)\\n                sum+=tickets[i];\\n            else\\n                sum+=x;\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++){\\n            if(tickets[i] <= (x-1))\\n                sum+=tickets[i];\\n            else\\n                sum+=(x-1);\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = 0;\\n        while(tickets[k] > 0){\\n            for(int i = 0; i < tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    t++;\\n                    tickets[i]--;\\n                }\\n                if(tickets[k]==0)\\n                    break;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011975,
                "title": "simple-python-solution-with-detailed-explanation-easy-to-understand",
                "content": "iterate through tickets, if any number is bigger than ticket[k], when index <= k, nums + tickets[k] (because you can\\'t go over tickets[k] steps to finish purchasing tickets for the kth person), however, for people behind kth person, you only need to purchase ticket[k]-1 steps. if tickets[i] is smaller than ticket[k], these people will only take tickets[i] steps before they leave the queue.\\n\\nif you like my solution, please give me a thumb up!\\n\\n```\\n\\n```class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        nums = 0        \\n        \\n        for i in range(len(tickets)):       \\n                if tickets[i] >= tickets[k]:\\n                    if i <= k:\\n                        nums += tickets[k]\\n                    else:\\n                        nums += tickets[k] - 1\\n                else:\\n                        nums += tickets[i]\\n\\n        return nums",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937637,
                "title": "faster-than-94-90-javascript-solution",
                "content": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n  let ans = 0;\\n  let i = 0;\\n  while (tickets[k] !== 0) {\\n    if (i === tickets.length) {\\n      i = 0;\\n    }\\n    if (tickets[i] != 0) {\\n      tickets[i] -= 1;\\n      ans++;\\n    }\\n    i++;\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n  let ans = 0;\\n  let i = 0;\\n  while (tickets[k] !== 0) {\\n    if (i === tickets.length) {\\n      i = 0;\\n    }\\n    if (tickets[i] != 0) {\\n      tickets[i] -= 1;\\n      ans++;\\n    }\\n    i++;\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934516,
                "title": "java-queue-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0;i <tickets.length; i++) {\\n            queue.add(i);\\n        }\\n        int count=0;\\n        while(!queue.isEmpty()) {\\n            count++;\\n            int index = queue.poll();\\n            if(tickets[index] >= 1) {\\n                tickets[index] -= 1;\\n            }\\n            //now I will check he can go back to last of queue or not\\n            if(index != k && tickets[index] == 0) { \\n                //he is the normal guy, which means he can leave the queue\\n                continue;\\n            }\\n            //he is the Kth guy, he cannot leave the Queue instead he can BREAK the Queue :)\\n            if(index == k && tickets[index] == 0) {\\n                break;\\n            }\\n            //in all other case we need to add the guy back to Queue\\n            queue.offer(index);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0;i <tickets.length; i++) {\\n            queue.add(i);\\n        }\\n        int count=0;\\n        while(!queue.isEmpty()) {\\n            count++;\\n            int index = queue.poll();\\n            if(tickets[index] >= 1) {\\n                tickets[index] -= 1;\\n            }\\n            //now I will check he can go back to last of queue or not\\n            if(index != k && tickets[index] == 0) { \\n                //he is the normal guy, which means he can leave the queue\\n                continue;\\n            }\\n            //he is the Kth guy, he cannot leave the Queue instead he can BREAK the Queue :)\\n            if(index == k && tickets[index] == 0) {\\n                break;\\n            }\\n            //in all other case we need to add the guy back to Queue\\n            queue.offer(index);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921486,
                "title": "c-cpp-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0,n = tickets.size();\\n        while(tickets[k] > 0){\\n            for(int i = 0;i<n && tickets[k] > 0;i++){\\n                if(tickets[i] > 0){\\n                    ans++;\\n                    tickets[i]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/06178cb3-e0a6-4b9f-add8-fd6380c82517_1649302549.1251898.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0,n = tickets.size();\\n        while(tickets[k] > 0){\\n            for(int i = 0;i<n && tickets[k] > 0;i++){\\n                if(tickets[i] > 0){\\n                    ans++;\\n                    tickets[i]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914472,
                "title": "python-easy-solution-one-pass-no-extra-memory",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        length = len(tickets)\\n        count = 0\\n        \\n        for i in range(k+1):\\n            if tickets[i] - tickets[k] < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k]\\n        \\n        for i in range(k+1, length):\\n            if tickets[i] - (tickets[k] - 1) < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k] - 1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        length = len(tickets)\\n        count = 0\\n        \\n        for i in range(k+1):\\n            if tickets[i] - tickets[k] < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k]\\n        \\n        for i in range(k+1, length):\\n            if tickets[i] - (tickets[k] - 1) < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k] - 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904304,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        item = tickets[k]\\n        time = 0\\n        \\n        while tickets[k] != 0:\\n            for i in range(n):\\n                if tickets[i] > 0:\\n                    tickets[i] -= 1\\n                    time += 1\\n                \\n                if i == k and tickets[i] == 0:\\n                    return time\\n        \\n        return time\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        item = tickets[k]\\n        time = 0\\n        \\n        while tickets[k] != 0:\\n            for i in range(n):\\n                if tickets[i] > 0:\\n                    tickets[i] -= 1\\n                    time += 1\\n                \\n                if i == k and tickets[i] == 0:\\n                    return time\\n        \\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894215,
                "title": "c-solution-o-n-time-o-1-space-just-two-loops-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n      int timeTaken = 0;\\n      int ticketsAtIndexK = tickets[k];\\n      for(int i = k+1; i < tickets.size(); i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK - 1);\\n      \\n      for(int i = 0; i <= k; i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK);\\n      \\n      return timeTaken;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n      int timeTaken = 0;\\n      int ticketsAtIndexK = tickets[k];\\n      for(int i = k+1; i < tickets.size(); i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK - 1);\\n      \\n      for(int i = 0; i <= k; i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK);\\n      \\n      return timeTaken;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888755,
                "title": "c-solution-with-queue-and-shallow-copies",
                "content": "Put references to the elements of the array in a queue. This allows you to monitor directly tickets[k], preventing you from becoming insane in keeping track of it with a variable.\\n\\n``` \\nclass Solution {\\npublic:\\n    // Time Complexity: O(n*tickets[k]), it loops for the entire queue (size = n, n times) until tickets[k] becomes 0 (k times)\\n    // Space Complexity: O(n), creates a queue of size n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        queue<int*> q;\\n        for(int i=0; i< tickets.size(); i++)\\n            q.push(&tickets[i]);                // add references of the tickets to a queue\\n        \\n        int count = 0;\\n        while(tickets[k] != 0)                  // repeat until ticket[k] is zero\\n        {\\n            int* ptr = q.front();               // get the reference at the front of the queue, namely ticket[i]\\n            q.pop();                            // remove it from the queue\\n            (*ptr)--;                           // reduce the value of ticket[i]\\n            if(*ptr != 0)                       // if it is not zero, \\n                q.push(ptr);                    // add it back to the queue\\n            count++;                            // increase counter\\n        }\\n        return count;                           // return the counter\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    // Time Complexity: O(n*tickets[k]), it loops for the entire queue (size = n, n times) until tickets[k] becomes 0 (k times)\\n    // Space Complexity: O(n), creates a queue of size n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        queue<int*> q;\\n        for(int i=0; i< tickets.size(); i++)\\n            q.push(&tickets[i]);                // add references of the tickets to a queue\\n        \\n        int count = 0;\\n        while(tickets[k] != 0)                  // repeat until ticket[k] is zero\\n        {\\n            int* ptr = q.front();               // get the reference at the front of the queue, namely ticket[i]\\n            q.pop();                            // remove it from the queue\\n            (*ptr)--;                           // reduce the value of ticket[i]\\n            if(*ptr != 0)                       // if it is not zero, \\n                q.push(ptr);                    // add it back to the queue\\n            count++;                            // increase counter\\n        }\\n        return count;                           // return the counter\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857998,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        seconds = 0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i] != 0:\\n                    seconds += 1\\n                    tickets[i] -= 1\\n                else:\\n                    continue\\n                if tickets[k] == 0:\\n                    return seconds",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        seconds = 0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i] != 0:\\n                    seconds += 1\\n                    tickets[i] -= 1\\n                else:\\n                    continue\\n                if tickets[k] == 0:\\n                    return seconds",
                "codeTag": "Java"
            },
            {
                "id": 1820628,
                "title": "o-n-long-but-understandable-code-try-this-python",
                "content": "class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\n        second=0\\n        a=tickets[k]\\n        while a!=0:\\n            for i in range(len(tickets)):\\n                if tickets[i]!=0:\\n                    second+=1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if a==0:\\n                    return second\\n            a=tickets[k]\\n            \\n        return second",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\n        second=0\\n        a=tickets[k]\\n        while a!=0:\\n            for i in range(len(tickets)):\\n                if tickets[i]!=0:\\n                    second+=1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if a==0:\\n                    return second\\n            a=tickets[k]\\n            \\n        return second",
                "codeTag": "Java"
            },
            {
                "id": 1802939,
                "title": "python-3-easy-to-understand",
                "content": "Runtime: 64 ms, faster than 43.29% of Python3 online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 13.9 MB, less than 86.76% of Python3 online submissions for Time Needed to Buy Tickets\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        p = 0                       #pointer\\n        clock = 0                   #clock\\n        while tickets[k] > 0:       #stop when person k has bought all required tickets\\n            if tickets[p] != 0:     #only buy a ticket if person p still needs to buy tickets\\n                tickets[p] -= 1     #person p buys a ticket\\n                clock += 1          #increment clock whenever a ticket is bought\\n            p += 1                  #move pointer to next person\\n            p %= len(tickets)       #loop pointer from end of list to start of list\\n        return clock\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        p = 0                       #pointer\\n        clock = 0                   #clock\\n        while tickets[k] > 0:       #stop when person k has bought all required tickets\\n            if tickets[p] != 0:     #only buy a ticket if person p still needs to buy tickets\\n                tickets[p] -= 1     #person p buys a ticket\\n                clock += 1          #increment clock whenever a ticket is bought\\n            p += 1                  #move pointer to next person\\n            p %= len(tickets)       #loop pointer from end of list to start of list\\n        return clock\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793517,
                "title": "c-tc-o-n-sc-o-1-100-faster",
                "content": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int result=0;\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            \\n            result+= i<=k ?min(tickets[i],tickets[k]): min(tickets[i],tickets[k]-1);\\n            \\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int result=0;\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            \\n            result+= i<=k ?min(tickets[i],tickets[k]): min(tickets[i],tickets[k]-1);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1746430,
                "title": "typescript-100",
                "content": "Your runtime beats 100 % of typescript submissions\\nYour memory usage beats 14.29 % of typescript submissions (43.5 MB)\\n```\\nfunction timeRequiredToBuy(tickets: number[], k: number): number {\\n    let result: number = 0;\\n    for (let i: number = 0; true; i = i === tickets.length ? 0 : i + 1) {\\n        if (tickets[i] > 0) {\\n            tickets[i]--;\\n            result++;\\n            if (tickets[i] === 0 && i === k) {\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction timeRequiredToBuy(tickets: number[], k: number): number {\\n    let result: number = 0;\\n    for (let i: number = 0; true; i = i === tickets.length ? 0 : i + 1) {\\n        if (tickets[i] > 0) {\\n            tickets[i]--;\\n            result++;\\n            if (tickets[i] === 0 && i === k) {\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1744017,
                "title": "c-faster-than-100-of-submissions-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<k+1; i++){\\n            if(tickets[i]<=tickets[k]){\\n                ans+=tickets[i];\\n            }\\n            else{\\n                ans+=tickets[k];\\n            }\\n        }\\n        for(int i=k+1; i<tickets.size(); i++){\\n             if(tickets[i]<tickets[k]){\\n                ans+=tickets[i];\\n            }\\n            else{\\n                ans+=tickets[k]-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<k+1; i++){\\n            if(tickets[i]<=tickets[k]){\\n                ans+=tickets[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1742844,
                "title": "java-o-n-soln-easy-for-beginners",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){\\n            if(i==tickets.length-1){\\n                if(tickets[i]==0){\\n                    i=0;\\n                continue;\\n            }\\n            else{\\n                tickets[i]=tickets[i]-1;\\n                count++;\\n                i=0;\\n                continue;\\n            }\\n            }\\n            else{\\n            if(tickets[i]==0){\\n                i++;\\n                continue;\\n            }\\n            else{\\n                tickets[i]=tickets[i]-1;\\n                count++;\\n            }\\n            i++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){\\n            if(i==tickets.length-1){\\n                if(tickets[i]==0){\\n                    i=0;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1741714,
                "title": "java-easy-solution-optimal-100-faster-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=k;i>=0;i--)\\n            ans+=Math.min(tickets[k],tickets[i]);\\n        for(int i=tickets.length-1;i>k;i--)\\n            ans+=Math.min(tickets[k]-1,tickets[i]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=k;i>=0;i--)\\n            ans+=Math.min(tickets[k],tickets[i]);\\n        for(int i=tickets.length-1;i>k;i--)\\n            ans+=Math.min(tickets[k]-1,tickets[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715695,
                "title": "java-easy-understanding-0ms-for-loop",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int val = tickets[k];\\n        for(int i=0; i<tickets.length; i++){\\n            if(i <= k)\\n                count += (val > tickets[i]) ? tickets[i] : val;\\n            else\\n                count += (val > tickets[i]) ? tickets[i] : val-1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int val = tickets[k];\\n        for(int i=0; i<tickets.length; i++){\\n            if(i <= k)\\n                count += (val > tickets[i]) ? tickets[i] : val;\\n            else\\n                count += (val > tickets[i]) ? tickets[i] : val-1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688697,
                "title": "java-o-n-easy-to-understand-intuition",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets == null || tickets.length == 0 || k > tickets.length) \\n            return 0;\\n        \\n        /*\\n          Intuition: Since 1 ticket is bought in 1 second. Number of tickets bought will give us the total time taken. \\n          We know we have to buy \"tickets[k]\" number of tickets. 2 cases possible: \\n\\n    Case-1: Going in a loop we are purchasing tickets and until we purchase \"tickets[k]\" number of tickets the people infront(left) of us buy tickets which is equal to Math.min(tickets[i], tickets[k]) because tickets[i] can be greater/lesser than tickets[k], and we can only buy the minimum of both. \\n          Ex-1: tickets[i], tickets[k] => 2, 4 implies i\\'th person can only buy 2 tickets. \\n          Ex-2: tickets[i], tickets[k] => 5, 3 implies i\\'th person can only buy 3 tickets and he still has 2 more tickets to buy which we dont have to wait for\\n        \\n    Case-2: Once we buy all the required tickets (i.e., tickets[k] becomes 0) we no longer have to buy(count) the tickets which are behind(right) of us. That means we only have to buy tickets until the last iteration before which tickets[k] becomes 0 i.e., the previous iteration where tickets[k]-1 are the amount of tickets to be bought.\\n    \\n    Note: If above cases don\\'t make sense. Think of it this way, we have divided the cases into 2 parts. One which are on & before(to the left) of \\'k\\' and other which are to the right of \\'k\\'\\n        */\\n        \\n        \\n        int timeTaken = 0; // TimeTaken = TicketsBought\\n        \\n        \\n        // The way to calculate number of tickets bought\\n        for(int i=0; i<tickets.length; i++) {\\n            if(i <= k) {\\n                timeTaken += Math.min(tickets[i], tickets[k]);  // Case 1\\n            } else {\\n                timeTaken += Math.min(tickets[k]-1, tickets[i]); // Case 2\\n            }\\n        }\\n        \\n        return timeTaken;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets == null || tickets.length == 0 || k > tickets.length) \\n            return 0;\\n        \\n        /*\\n          Intuition: Since 1 ticket is bought in 1 second. Number of tickets bought will give us the total time taken. \\n          We know we have to buy \"tickets[k]\" number of tickets. 2 cases possible: \\n\\n    Case-1: Going in a loop we are purchasing tickets and until we purchase \"tickets[k]\" number of tickets the people infront(left) of us buy tickets which is equal to Math.min(tickets[i], tickets[k]) because tickets[i] can be greater/lesser than tickets[k], and we can only buy the minimum of both. \\n          Ex-1: tickets[i], tickets[k] => 2, 4 implies i\\'th person can only buy 2 tickets. \\n          Ex-2: tickets[i], tickets[k] => 5, 3 implies i\\'th person can only buy 3 tickets and he still has 2 more tickets to buy which we dont have to wait for\\n        \\n    Case-2: Once we buy all the required tickets (i.e., tickets[k] becomes 0) we no longer have to buy(count) the tickets which are behind(right) of us. That means we only have to buy tickets until the last iteration before which tickets[k] becomes 0 i.e., the previous iteration where tickets[k]-1 are the amount of tickets to be bought.\\n    \\n    Note: If above cases don\\'t make sense. Think of it this way, we have divided the cases into 2 parts. One which are on & before(to the left) of \\'k\\' and other which are to the right of \\'k\\'\\n        */\\n        \\n        \\n        int timeTaken = 0; // TimeTaken = TicketsBought\\n        \\n        \\n        // The way to calculate number of tickets bought\\n        for(int i=0; i<tickets.length; i++) {\\n            if(i <= k) {\\n                timeTaken += Math.min(tickets[i], tickets[k]);  // Case 1\\n            } else {\\n                timeTaken += Math.min(tickets[k]-1, tickets[i]); // Case 2\\n            }\\n        }\\n        \\n        return timeTaken;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650061,
                "title": "0-ms-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(tickets[k]-(i>k),tickets[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(tickets[k]-(i>k),tickets[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650041,
                "title": "c-o-n-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(tickets[i]>=tickets[k]) ans+=(i<=k?tickets[k]:tickets[k]-1);\\n            else ans+=tickets[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(tickets[i]>=tickets[k]) ans+=(i<=k?tickets[k]:tickets[k]-1);\\n            else ans+=tickets[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637234,
                "title": "java-100-faster-short-solution",
                "content": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTakenForK = 0;\\n       \\n        for(int i = 0; i < tickets.length; i++){\\n            if(i < k) timeTakenForK+=Math.min(tickets[k], tickets[i]);\\n            if(i > k) timeTakenForK+=Math.min(tickets[k] - 1, tickets[i]);\\n            if(i == k)timeTakenForK+=tickets[k];}\\n  \\n        return timeTakenForK;}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTakenForK = 0;\\n       \\n        for(int i = 0; i < tickets.length; i++){\\n            if(i < k) timeTakenForK+=Math.min(tickets[k], tickets[i]);\\n            if(i > k) timeTakenForK+=Math.min(tickets[k] - 1, tickets[i]);\\n            if(i == k)timeTakenForK+=tickets[k];}\\n  \\n        return timeTakenForK;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1632040,
                "title": "easy-one-pass-o-n",
                "content": "For the people ahead of the person at `idx=k` they all get down to the minimum of their value and the value of the person at position `k`, for the people behind that person, since we stop as soon as the the person at position `k` has bought all his/her tickets, they get to minimum of  their value and the value of the person at position `k` minus `1`.\\n```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        tot, idx = 0, len(tickets)-1\\n\\n        while(idx>=0):\\n            tot += min(tickets[k], tickets[idx]) if idx<=k else min(tickets[k]-1, tickets[idx])\\n            idx-=1\\n            \\n        return tot \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        tot, idx = 0, len(tickets)-1\\n\\n        while(idx>=0):\\n            tot += min(tickets[k], tickets[idx]) if idx<=k else min(tickets[k]-1, tickets[idx])\\n            idx-=1\\n            \\n        return tot \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622513,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0,n=tickets.size(),fix=tickets[k];\\n        for(int i=0;i<fix-1;i++){\\n            for(int j=0;j<n;j++){\\n                if(tickets[j]>0) ans++;\\n                tickets[j]--;\\n            }\\n        }\\n        for(int j=0;j<=k;j++){\\n            if(tickets[j]>0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0,n=tickets.size(),fix=tickets[k];\\n        for(int i=0;i<fix-1;i++){\\n            for(int j=0;j<n;j++){\\n                if(tickets[j]>0) ans++;\\n                tickets[j]--;\\n            }\\n        }\\n        for(int j=0;j<=k;j++){\\n            if(tickets[j]>0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603655,
                "title": "java-o-n-0ms-4-line-answer",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<=k; i++) ans+=Math.min(tickets[i], tickets[k]);\\n        for(int i=k+1; i<tickets.length; i++)ans+=Math.min(tickets[i], tickets[k]-1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<=k; i++) ans+=Math.min(tickets[i], tickets[k]);\\n        for(int i=k+1; i<tickets.length; i++)ans+=Math.min(tickets[i], tickets[k]-1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591130,
                "title": "java-100-easy-solution",
                "content": "Apulatjonov\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]){\\n                count += tickets[i];\\n            }else{\\n                count += tickets[k];\\n            }\\n        }\\n        for(int i = k; i < tickets.length; i++){\\n            if(tickets[i] >= tickets[k])\\n                count--;\\n        }\\n        return ++count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]){\\n                count += tickets[i];\\n            }else{\\n                count += tickets[k];\\n            }\\n        }\\n        for(int i = k; i < tickets.length; i++){\\n            if(tickets[i] >= tickets[k])\\n                count--;\\n        }\\n        return ++count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588109,
                "title": "c-simple-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = tickets[k];\\n        for(int i = 0; i < k; i++) {\\n            t += min(tickets[i], tickets[k]);\\n        }\\n        for(int i = k+1; i<tickets.size(); i++) {\\n            t += min(tickets[i], tickets[k]-1);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = tickets[k];\\n        for(int i = 0; i < k; i++) {\\n            t += min(tickets[i], tickets[k]);\\n        }\\n        for(int i = k+1; i<tickets.size(); i++) {\\n            t += min(tickets[i], tickets[k]-1);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583361,
                "title": "javascript-brute-force",
                "content": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let time = 0\\n    while(tickets[k]){\\n        for(i = 0; i < tickets.length; i++){\\n           if(tickets[i] && tickets[k]) {\\n               time+=1\\n               tickets[i]-=1\\n           } \\n        }\\n    }\\n    return time\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let time = 0\\n    while(tickets[k]){\\n        for(i = 0; i < tickets.length; i++){\\n           if(tickets[i] && tickets[k]) {\\n               time+=1\\n               tickets[i]-=1\\n           } \\n        }\\n    }\\n    return time\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582832,
                "title": "c-gcc-100-bytes-0-ms-5-9-mb",
                "content": "```\\ni,s;timeRequiredToBuy(int*a,int n,int k){i=s=0;\\nwhile(a[k])a[i]-=a[i]?s++,1:0,i=++i<n?i:0;return s;}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ni,s;timeRequiredToBuy(int*a,int n,int k){i=s=0;\\nwhile(a[k])a[i]-=a[i]?s++,1:0,i=++i<n?i:0;return s;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581974,
                "title": "python-2-line-explain",
                "content": "- For k\\'s first ticket, it\\'ll take k seconds to get the turn\\n- After that, ppl before k will need -1 tickets, after k remain same\\n- Then for the remaining rounds, each ppl will buy at most ticket[k] -1 before job done, plus ticket[k] seconds for k to buy\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        remaining = [t-1 for t in tickets[:k]] + tickets[k+1:]\\n        return k + sum(min(r, tickets[k] - 1) for r in remaining) + tickets[k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        remaining = [t-1 for t in tickets[:k]] + tickets[k+1:]\\n        return k + sum(min(r, tickets[k] - 1) for r in remaining) + tickets[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581364,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        a=tickets[k]\\n        x=0\\n        while(a!=0):\\n            for i in range(len(tickets)):\\n                if(tickets[i]!=0):\\n                    x=x+1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if(a==0):\\n                    return(x)\\n\\t\\t\\t#print(tickets)\\n            a=tickets[k]\\n        return(x)\\n```\\nIf u liked the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        a=tickets[k]\\n        x=0\\n        while(a!=0):\\n            for i in range(len(tickets)):\\n                if(tickets[i]!=0):\\n                    x=x+1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if(a==0):\\n                    return(x)\\n\\t\\t\\t#print(tickets)\\n            a=tickets[k]\\n        return(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580231,
                "title": "python-o-n-faster-than-99",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        x = tickets[k]\\n        res = 0\\n        for i in range(k + 1):\\n            res += min(x, tickets[i])\\n\\n        for i in range(k + 1, len(tickets)):\\n            res += min(x - 1, tickets[i])\\n\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        x = tickets[k]\\n        res = 0\\n        for i in range(k + 1):\\n            res += min(x, tickets[i])\\n\\n        for i in range(k + 1, len(tickets)):\\n            res += min(x - 1, tickets[i])\\n\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1580050,
                "title": "c-o-n-tc-and-o-1-sc-clean",
                "content": "A simple Approch should be to traverse the array and adding elements eqaul to , or less than kth element .\\n\\n\\n\\'\\'\\'\\n\\n         int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int t = 0;  //time taken by kth person to buy the tickets\\n\\t\\t\\n        for(int i = 0; i<tickets.size(); i++){\\n\\t\\t\\n            if(i <= k){\\n\\t\\t\\t//for person is placed earliear than kth person \\n                t = t+ min(tickets[i],  tickets[k]);\\n            }\\n            if(i > k){\\n\\t\\t\\t// for persons placed after the kth person\\n                t = t+ min(tickets[i],  tickets[k]-1);\\n            }\\n        }return t;\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nDry run this code with different test cases and eventually you will know the conditions\\n\\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "A simple Approch should be to traverse the array and adding elements eqaul to , or less than kth element .\\n\\n\\n\\'\\'\\'\\n\\n         int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int t = 0;  //time taken by kth person to buy the tickets\\n\\t\\t\\n        for(int i = 0; i<tickets.size(); i++){\\n\\t\\t\\n            if(i <= k){\\n\\t\\t\\t//for person is placed earliear than kth person \\n                t = t+ min(tickets[i],  tickets[k]);\\n            }\\n            if(i > k){\\n\\t\\t\\t// for persons placed after the kth person\\n                t = t+ min(tickets[i],  tickets[k]-1);\\n            }\\n        }return t;\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nDry run this code with different test cases and eventually you will know the conditions\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1579383,
                "title": "python-one-pass-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        res = tickets[k] #it has to buy all at kth position\\n        \\n        for i in range(n):\\n            if i < k:\\n                res += min(tickets[i], tickets[k])  # for all pos before k it will exhaust all tickets or get till number till kth place\\n                \\n            elif i > k:\\n                res += min(tickets[i], tickets[k]-1) #for all pos after k it can exhaust all tickets or get 1 less than the kth gets finished\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        res = tickets[k] #it has to buy all at kth position\\n        \\n        for i in range(n):\\n            if i < k:\\n                res += min(tickets[i], tickets[k])  # for all pos before k it will exhaust all tickets or get till number till kth place\\n                \\n            elif i > k:\\n                res += min(tickets[i], tickets[k]-1) #for all pos after k it can exhaust all tickets or get 1 less than the kth gets finished\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578792,
                "title": "c-simple-approach-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                { if(tickets[i] > 0) \\n                {\\n                    tickets[i]--;\\n                    count++;\\n                }\\n                }\\n              if(tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                { if(tickets[i] > 0) \\n                {\\n                    tickets[i]--;\\n                    count++;\\n                }\\n                }\\n              if(tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578006,
                "title": "c-solution-beats-100-o-n-onepass",
                "content": "```\\nint timeRequiredToBuy(vector<int>& tk, int k) {\\n        int val=tk[k];\\n        int ans=0;\\n        for(int i=0;i<tk.size();i++){\\n            if(tk[i]>val)ans+=val;\\n            else ans+=tk[i];\\n            if(i>k && tk[i]>=tk[k])ans--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tk, int k) {\\n        int val=tk[k];\\n        int ans=0;\\n        for(int i=0;i<tk.size();i++){\\n            if(tk[i]>val)ans+=val;\\n            else ans+=tk[i];\\n            if(i>k && tk[i]>=tk[k])ans--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577999,
                "title": "c-brute-force-to-optimal-easy-to-understand",
                "content": "Time Needed to Buy Tickets - \\n\\n\\n**1) Brute Force -**\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          while(tickets[k]!=0)\\n          {\\n              for(int i=0;i<tickets.size();i++)\\n              {\\n                  if(tickets[i]>0)\\n                  {\\n                      tickets[i]-=1;\\n                      cnt++;\\n                  }\\n                 if(tickets[k]==0)\\n                  {break;}\\n              }\\n          }\\n       return cnt; \\n    }\\n};\\n```\\n\\n**2) Optimal Solution - O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          for(int i=0;i<tickets.size();i++)\\n          {\\n              cnt+=min(tickets[k] - (i>k),tickets[i]);\\n          }\\n       return cnt; \\n    }\\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          while(tickets[k]!=0)\\n          {\\n              for(int i=0;i<tickets.size();i++)\\n              {\\n                  if(tickets[i]>0)\\n                  {\\n                      tickets[i]-=1;\\n                      cnt++;\\n                  }\\n                 if(tickets[k]==0)\\n                  {break;}\\n              }\\n          }\\n       return cnt; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          for(int i=0;i<tickets.size();i++)\\n          {\\n              cnt+=min(tickets[k] - (i>k),tickets[i]);\\n          }\\n       return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577952,
                "title": "c-one-traversal-solution-one-pass-o-n-beats-100-of-c-codes",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577387,
                "title": "c-one-pass-solution",
                "content": "**Intuition**\\npeople ```k``` and people before ```k``` will need to buy ```Min(tickets[i], tickets[k])```.\\npeople after ```k``` don\\'t need to buy any tickets if people ```k``` already got all the tickets, so people after ```k``` need to buy  ```Min(tickets[i], tickets[k] - 1)```.\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int res  = 0;\\n        \\n        for(int i = 0; i < tickets.Length; i++)\\n        {\\n            if(i <= k)\\n                res += Math.Min(tickets[i], tickets[k]);\\n            else if(i > k)\\n                res += Math.Min(tickets[i], tickets[k] - 1);\\n        }\\n       \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```k```\n```k```\n```Min(tickets[i], tickets[k])```\n```k```\n```k```\n```k```\n```Min(tickets[i], tickets[k] - 1)```\n```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int res  = 0;\\n        \\n        for(int i = 0; i < tickets.Length; i++)\\n        {\\n            if(i <= k)\\n                res += Math.Min(tickets[i], tickets[k]);\\n            else if(i > k)\\n                res += Math.Min(tickets[i], tickets[k] - 1);\\n        }\\n       \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577113,
                "title": "c-one-pass-simulation",
                "content": "<strong>Logical Thinking</strong>\\n<p>We can easily solve this problem through <code>simulation</code>. Suppose the <code>k<sup>th</sup></code> person needs <code>target = tickets[k]</code> tickets, then when this person leaves, the people in front of him <code>i < k</code> must have bought the same number of tickets (if they need more tickets), i.e. each of them bought <code>min(target, tickets[i])</code>. Similarly, the people behind him <code>i > k</code> must have bought <code>1</code> less tickets, i.e. <code>min(target - 1, tickets[i])</code>.</p>\\n\\n\\n<strong>C++</strong>\\n\\n```\\n//  Topic   : 2073. Time Needed to Buy Tickets (https://leetcode.com/problems/time-needed-to-buy-tickets/)\\n//  Author  : YCX\\n//  Time    : O(N)\\n//  Space   : O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0, target = tickets[k], n = tickets.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i <= k)\\n                ans += min<int>(tickets[i], target);\\n            else\\n                ans += min<int>(tickets[i], target - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\n//  Topic   : 2073. Time Needed to Buy Tickets (https://leetcode.com/problems/time-needed-to-buy-tickets/)\\n//  Author  : YCX\\n//  Time    : O(N)\\n//  Space   : O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0, target = tickets[k], n = tickets.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i <= k)\\n                ans += min<int>(tickets[i], target);\\n            else\\n                ans += min<int>(tickets[i], target - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577096,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void solve(vector<int> &nums, int k)\\n    {\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            nums[i] = nums[i]-1;\\n                ans++;\\n            if(nums[k] == 0)\\n                return;\\n        }\\n    }\\n    \\n    int timeRequiredToBuy(vector<int> &nums, int k) \\n    {    \\n        while(true)\\n        {\\n            if(nums[k]==0)\\n                break;\\n            solve(nums,k);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void solve(vector<int> &nums, int k)\\n    {\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            nums[i] = nums[i]-1;\\n                ans++;\\n            if(nums[k] == 0)\\n                return;\\n        }\\n    }\\n    \\n    int timeRequiredToBuy(vector<int> &nums, int k) \\n    {    \\n        while(true)\\n        {\\n            if(nums[k]==0)\\n                break;\\n            solve(nums,k);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576994,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        res = i = 0\\n        \\n        while tickets[k]:\\n            try:\\n                j = tickets[i]\\n                if j:\\n                    tickets[i] = j - 1\\n                    i += 1\\n                    res += 1\\n                else:\\n                    i += 1\\n            except:\\n                i = 0\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        res = i = 0\\n        \\n        while tickets[k]:\\n            try:\\n                j = tickets[i]\\n                if j:\\n                    tickets[i] = j - 1\\n                    i += 1\\n                    res += 1\\n                else:\\n                    i += 1\\n            except:\\n                i = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576925,
                "title": "java-brute-force-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\n    public int timeRequiredToBuy(int[] tickets, int k)\\n    {\\n        int time = 0;\\n        while(true)\\n        {\\n            for(int i = 0; i < tickets.length; i++)\\n            {\\n                if(tickets[i]-- >= 1)\\n                    time++;\\n                if(tickets[k] == 0)\\n                    return time;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int timeRequiredToBuy(int[] tickets, int k)\\n    {\\n        int time = 0;\\n        while(true)\\n        {\\n            for(int i = 0; i < tickets.length; i++)\\n            {\\n                if(tickets[i]-- >= 1)\\n                    time++;\\n                if(tickets[k] == 0)\\n                    return time;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576918,
                "title": "python-java-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, ticket in enumerate(tickets):\\n\\t\\t\\t\\tif i <= k:\\n\\t\\t\\t\\t\\tres += min(ticket, tickets[k])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif ticket < tickets[k]:\\n\\t\\t\\t\\t\\t\\tres += ticket\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int i = 0; i < tickets.length; i ++) {\\n\\t\\t\\t\\tif (i <= k) {\\n\\t\\t\\t\\t\\tres += Math.min(tickets[i], tickets[k]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (tickets[i] < tickets[k]) {\\n\\t\\t\\t\\t\\t\\tres += tickets[i];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, ticket in enumerate(tickets):\\n\\t\\t\\t\\tif i <= k:\\n\\t\\t\\t\\t\\tres += min(ticket, tickets[k])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif ticket < tickets[k]:\\n\\t\\t\\t\\t\\t\\tres += ticket\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int i = 0; i < tickets.length; i ++) {\\n\\t\\t\\t\\tif (i <= k) {\\n\\t\\t\\t\\t\\tres += Math.min(tickets[i], tickets[k]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4077206,
                "title": "o-n-with-readable-code-simple-for-loop",
                "content": "## Approach\\n<!-- Describe your approach to solving the problem. -->\\ndeclare variable ans = 0, this variable will be the counter (and the answer).\\nthe target is tickets[k]. \\nif the index is less or equal to k (the target index):\\n- if the tickets[index] is bigger than target add ans equals target.\\n- else (tickets[index] is less than target) add ans equals tickets[index].\\n\\nelse (index is bigger than k (the target index))\\n- if the tickets[index] is bigger than target add ans equals target-1 (-1 because we assume that in the last recursion stopped in target index).\\n- else (tickets[index] is less than target) add ans equals tickets[index].\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1) (?)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0 ;\\n        for(int x = 0 ; x<tickets.length ; x++){\\n            if(x <= k){\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k];\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }else{\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k]-1;\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0 ;\\n        for(int x = 0 ; x<tickets.length ; x++){\\n            if(x <= k){\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k];\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }else{\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k]-1;\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061851,
                "title": "beats-100-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n\\n        while(tickets[k]>0){\\n            for(int j=0;j<tickets.size();j++){\\n//decrementing ticket at j and incrementing ans only if k > 0 && j > 0\\n                if(tickets[k]!=0 && tickets[j]>0){\\n                    tickets[j]--;\\n                    ans++;\\n                }\\n        }\\n\\n        \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n\\n        while(tickets[k]>0){\\n            for(int j=0;j<tickets.size();j++){\\n//decrementing ticket at j and incrementing ans only if k > 0 && j > 0\\n                if(tickets[k]!=0 && tickets[j]>0){\\n                    tickets[j]--;\\n                    ans++;\\n                }\\n        }\\n\\n        \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059886,
                "title": "easiest-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust need to think how can we iterate the vector again and again\\nand to do this i have used the method of circular queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(1)\\n        {\\n            if(tickets[i]!=0)\\n            {\\n                cnt++;\\n                tickets[i]--;\\n            }\\n            if(i==k&&tickets[k]==0)\\n             return cnt;\\n            i=(i+1)%n;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(1)\\n        {\\n            if(tickets[i]!=0)\\n            {\\n                cnt++;\\n                tickets[i]--;\\n            }\\n            if(i==k&&tickets[k]==0)\\n             return cnt;\\n            i=(i+1)%n;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055339,
                "title": "0-ms-solution-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, we mainly take count of contribution of every index value while a loop runs.\\n\\nIf value at any index (i) **before** given index (k) is **greater**, then **it will contribute same as tickets[k**]. Because, while running the loop the value of tickets[i] will run  for (tickets[k]) times.\\n\\nIf value at any index (i) **after** given index (k) is **greater** or equals, then **it will contribute same as (tickets[k]-1)**. Because, before reaching the loop for the last time, index at k will get the ticket. So, we won\\'t take the last count.\\n\\nIf value at any index (i) is less than value at given index (k), then the we will not change the value of it. Because, it will be 0 before tickets[k] time. It will contribute tickets[i].\\n\\nWe will update the no of contibution with value of any index.\\nThen, we will take the sum of the whole array and that\\'s the answer. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int sum=0;\\n        for (int i=0;i<tickets.length;i++){\\n            if (k>i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k];\\n            }\\n            if (k<i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k]-1;\\n            }\\n        }\\n\\n        for (int i=0;i<tickets.length;i++){\\n            sum+=tickets[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int sum=0;\\n        for (int i=0;i<tickets.length;i++){\\n            if (k>i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k];\\n            }\\n            if (k<i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k]-1;\\n            }\\n        }\\n\\n        for (int i=0;i<tickets.length;i++){\\n            sum+=tickets[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048214,
                "title": "java-simple-using-queue-t-n",
                "content": "# Intuition\\nUsed Queue\\n\\n# Approach\\n1. Number of People in queue.(count same as ticket).\\n2. remove from queue when tickets[queue.peek()] == 0,\\n3. otherwise queue.add(queue.peek()) & queue.remove(); \\n\\n# Complexity\\n- Time complexity:\\nOnly one while loop : T(n)\\nremove and add take : O(1)\\nTherfore TimeComplexity : T(n).\\n\\n- Space complexity:\\nSpace Complexity is the space taken by queue which is O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            tickets[queue.peek()]--;\\n            if(tickets[queue.peek()] == 0){\\n                queue.remove();\\n            }else if(tickets[queue.peek()] != 0){\\n                queue.add(queue.peek());\\n                queue.remove();\\n            }\\n            count++;\\n            if(tickets[k] == 0){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            tickets[queue.peek()]--;\\n            if(tickets[queue.peek()] == 0){\\n                queue.remove();\\n            }else if(tickets[queue.peek()] != 0){\\n                queue.add(queue.peek());\\n                queue.remove();\\n            }\\n            count++;\\n            if(tickets[k] == 0){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045024,
                "title": "time-needed-to-buy-tickets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndecreasing array values with base case condition until ticket[k] becomes zero.\\nAnd if there is only one ticket needs to buy then just do time = k+1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->2ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n39.80 mb\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int time=0;\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets[k]==1){\\n            return k+1;\\n        }\\n        while(tickets[k]>0){\\n            for(int i = 0;i<tickets.length;i++){\\n                if(tickets[i]==0){\\n                    continue;\\n                }\\n                time++;\\n                tickets[i] = tickets[i] - 1;\\n                if(tickets[k]==0){\\n                    break;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int time=0;\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets[k]==1){\\n            return k+1;\\n        }\\n        while(tickets[k]>0){\\n            for(int i = 0;i<tickets.length;i++){\\n                if(tickets[i]==0){\\n                    continue;\\n                }\\n                time++;\\n                tickets[i] = tickets[i] - 1;\\n                if(tickets[k]==0){\\n                    break;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037603,
                "title": "easy-solution-to-timerequiredtobuy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- I could move the elements position for each round\\n- I just need the seconds value\\n- How do I know when to stop iterating?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolution with JavaScript. Reduce each element by one until the `k`$$th$$ element is equal to cero.\\n\\n# Complexity\\n- Time complexity: ---\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let sec = 0;\\n    const ticketsLength = tickets.length;\\n    \\n    while (tickets[k]!==0) {\\n        for (let i = 0; i < ticketsLength; i++) {\\n            if (tickets[i] > 0) {\\n                tickets[i]--;\\n                sec++;\\n            }\\n            if(i===k) if(tickets[k]===0) break;\\n        }\\n    }\\n    return sec;\\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let sec = 0;\\n    const ticketsLength = tickets.length;\\n    \\n    while (tickets[k]!==0) {\\n        for (let i = 0; i < ticketsLength; i++) {\\n            if (tickets[i] > 0) {\\n                tickets[i]--;\\n                sec++;\\n            }\\n            if(i===k) if(tickets[k]===0) break;\\n        }\\n    }\\n    return sec;\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036091,
                "title": "easy-solution-100",
                "content": "# Approach\\nLinear Search\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tic, int k) {\\n        int ans=0;\\n        for(int i=0;i<tic.size();i++)\\n        {\\n            if(tic[i]>tic[k])\\n            {\\n                ans+=tic[k];\\n            }\\n            else\\n            {\\n                ans+=tic[i];\\n            }\\n            if(tic[i]>=tic[k]&&i>k)\\n            {\\n                ans--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tic, int k) {\\n        int ans=0;\\n        for(int i=0;i<tic.size();i++)\\n        {\\n            if(tic[i]>tic[k])\\n            {\\n                ans+=tic[k];\\n            }\\n            else\\n            {\\n                ans+=tic[i];\\n            }\\n            if(tic[i]>=tic[k]&&i>k)\\n            {\\n                ans--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033039,
                "title": "beats-100-runtime-and-100-memory",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n???\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# @param {Integer[]} tickets\\n# @param {Integer} k\\n# @return {Integer}\\ndef time_required_to_buy(tickets, k)\\n\\n    amount_of_tickets = tickets[k]\\n    track_location_of_k = k\\n    seconds = 0\\n    index = 0\\n    val = nil\\n    while tickets.size > 0  \\n        if 0 != k\\n            k = k - 1\\n        else\\n            if tickets[k] == 1\\n                return seconds + 1\\n            end\\n\\n            k = tickets.size - 1\\n        end\\n\\n        val = tickets.shift\\n        val = val - 1\\n\\n        if val != 0\\n            tickets << val\\n        end\\n\\n        seconds = seconds + 1\\n    end\\n\\n    seconds\\nend\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} tickets\\n# @param {Integer} k\\n# @return {Integer}\\ndef time_required_to_buy(tickets, k)\\n\\n    amount_of_tickets = tickets[k]\\n    track_location_of_k = k\\n    seconds = 0\\n    index = 0\\n    val = nil\\n    while tickets.size > 0  \\n        if 0 != k\\n            k = k - 1\\n        else\\n            if tickets[k] == 1\\n                return seconds + 1\\n            end\\n\\n            k = tickets.size - 1\\n        end\\n\\n        val = tickets.shift\\n        val = val - 1\\n\\n        if val != 0\\n            tickets << val\\n        end\\n\\n        seconds = seconds + 1\\n    end\\n\\n    seconds\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4032185,
                "title": "c-o-n-deque-implementation-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n     int time=0;\\n     deque<int>dq;\\n     //storing indexes of given array of tickets\\n     for(int i=0;i<tickets.size();i++){\\n         dq.push_back(i);\\n     }\\n     //k points to original array of tickets\\n     while(tickets[k]!=0){\\n         //selling ticket 1 at a time \\n         tickets[dq.front()]=tickets[dq.front()]-1;\\n         //increasing time by 1\\n         time++;\\n         //if person completes buying popping out its index from deque\\n         if(tickets[dq.front()]==0){\\n             dq.pop_front();\\n         }\\n         //pushing back that index to end of deque\\n         else{\\n             int temp=dq.front();\\n             dq.pop_front();\\n             dq.push_back(temp);\\n         }\\n     }\\n     return time;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n     int time=0;\\n     deque<int>dq;\\n     //storing indexes of given array of tickets\\n     for(int i=0;i<tickets.size();i++){\\n         dq.push_back(i);\\n     }\\n     //k points to original array of tickets\\n     while(tickets[k]!=0){\\n         //selling ticket 1 at a time \\n         tickets[dq.front()]=tickets[dq.front()]-1;\\n         //increasing time by 1\\n         time++;\\n         //if person completes buying popping out its index from deque\\n         if(tickets[dq.front()]==0){\\n             dq.pop_front();\\n         }\\n         //pushing back that index to end of deque\\n         else{\\n             int temp=dq.front();\\n             dq.pop_front();\\n             dq.push_back(temp);\\n         }\\n     }\\n     return time;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022322,
                "title": "easy-o-n",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let max = tickets[k]\\n    let total = 0\\n    let rem = 0\\n\\n    for(let idx in tickets) {\\n        let ticket = tickets[idx]\\n        if(idx > k && ticket >= max) rem++\\n        total += Math.min(max, ticket)\\n    }\\n\\n    return total - rem\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let max = tickets[k]\\n    let total = 0\\n    let rem = 0\\n\\n    for(let idx in tickets) {\\n        let ticket = tickets[idx]\\n        if(idx > k && ticket >= max) rem++\\n        total += Math.min(max, ticket)\\n    }\\n\\n    return total - rem\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008932,
                "title": "0ms-beats-100-00-of-users-with-java",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n\\n        for(int i=0;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]){\\n                if(i>k){\\n                    count += tickets[k] - 1;\\n                }\\n                else{\\n                    count += tickets[k];\\n                }\\n            }\\n            else{\\n                count += tickets[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n\\n        for(int i=0;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]){\\n                if(i>k){\\n                    count += tickets[k] - 1;\\n                }\\n                else{\\n                    count += tickets[k];\\n                }\\n            }\\n            else{\\n                count += tickets[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008532,
                "title": "go",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tc := 0\\n\\ti := 0\\n\\n\\tfor {\\n\\n\\t\\tif tickets[i] != 0 {\\n\\t\\t\\ttickets[i] -= 1\\n\\t\\t\\tc += 1\\n\\t\\t}\\n\\t\\tfmt.Println(c, i, tickets[i])\\n\\t\\tif i == k && tickets[k] == 0 {\\n\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif len(tickets)-1 == i {\\n\\t\\t\\ti = 0\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t}\\n\\n    return c\\n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tc := 0\\n\\ti := 0\\n\\n\\tfor {\\n\\n\\t\\tif tickets[i] != 0 {\\n\\t\\t\\ttickets[i] -= 1\\n\\t\\t\\tc += 1\\n\\t\\t}\\n\\t\\tfmt.Println(c, i, tickets[i])\\n\\t\\tif i == k && tickets[k] == 0 {\\n\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif len(tickets)-1 == i {\\n\\t\\t\\ti = 0\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t}\\n\\n    return c\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002763,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n  let queue = []\\n  let totalTime = 0;\\n  for(let i = 0; i < tickets.length; i++){\\n    queue.push({pos:i, no_of_tickets_needTo_buy: tickets[i]})\\n  }\\n  while(queue.length > 0){\\n    const person = queue.shift();\\n    if(person.no_of_tickets_needTo_buy > 0){\\n      person.no_of_tickets_needTo_buy --\\n      queue.push(person)\\n      totalTime ++\\n      if(person.pos === k && person.no_of_tickets_needTo_buy === 0) return totalTime;\\n    }\\n  }\\n  return totalTime\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n  let queue = []\\n  let totalTime = 0;\\n  for(let i = 0; i < tickets.length; i++){\\n    queue.push({pos:i, no_of_tickets_needTo_buy: tickets[i]})\\n  }\\n  while(queue.length > 0){\\n    const person = queue.shift();\\n    if(person.no_of_tickets_needTo_buy > 0){\\n      person.no_of_tickets_needTo_buy --\\n      queue.push(person)\\n      totalTime ++\\n      if(person.pos === k && person.no_of_tickets_needTo_buy === 0) return totalTime;\\n    }\\n  }\\n  return totalTime\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002364,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt = 0, a = 0;\\n\\n        while(tickets[k] != 0){\\n            if(a == tickets.size()){\\n                a = 0;\\n            }\\n            if(tickets[a] == 0){\\n                a++;\\n                continue;\\n            }\\n            tickets[a]--;\\n            cnt++;\\n            a++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt = 0, a = 0;\\n\\n        while(tickets[k] != 0){\\n            if(a == tickets.size()){\\n                a = 0;\\n            }\\n            if(tickets[a] == 0){\\n                a++;\\n                continue;\\n            }\\n            tickets[a]--;\\n            cnt++;\\n            a++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001871,
                "title": "c-solution-using-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> line;\\n        int n = tickets.size();\\n        int time = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            line.push(i);\\n        }\\n\\n        while (!line.empty()) {\\n            int current = line.front(); \\n            line.pop();\\n\\n            if (tickets[current] > 0) {\\n                tickets[current]--;\\n                time++;\\n\\n                if (current == k && tickets[k] == 0) {\\n                    break;\\n                }\\n\\n                line.push(current); \\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> line;\\n        int n = tickets.size();\\n        int time = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            line.push(i);\\n        }\\n\\n        while (!line.empty()) {\\n            int current = line.front(); \\n            line.pop();\\n\\n            if (tickets[current] > 0) {\\n                tickets[current]--;\\n                time++;\\n\\n                if (current == k && tickets[k] == 0) {\\n                    break;\\n                }\\n\\n                line.push(current); \\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001811,
                "title": "c-iterative-solve",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        vector<int> remain = tickets;\\n        int time = 0;\\n\\n        while (remain[k] > 0) {\\n            for (int i = 0; i < n; i++) {\\n                if (remain[i] > 0) {\\n                    remain[i]--;\\n                    time++;\\n\\n                    if (i==k && remain[i]==0) { \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        vector<int> remain = tickets;\\n        int time = 0;\\n\\n        while (remain[k] > 0) {\\n            for (int i = 0; i < n; i++) {\\n                if (remain[i] > 0) {\\n                    remain[i]--;\\n                    time++;\\n\\n                    if (i==k && remain[i]==0) { \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998439,
                "title": "o-n-c-solution",
                "content": "# Complexity\\n- Time complexity:\\n***O(N)***\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        for(int i = 0;i<a.size();i++){\\n            if(i<=k)cnt+=min(a[i],a[k]);\\n            else cnt+=min(a[k]-1,a[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        for(int i = 0;i<a.size();i++){\\n            if(i<=k)cnt+=min(a[i],a[k]);\\n            else cnt+=min(a[k]-1,a[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998421,
                "title": "100-easy-c-solution-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        while(a[k]){\\n            for(int i = 0;i<a.size();i++){\\n                if(a[i])a[i]--,cnt++;\\n                if(!a[k])break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        while(a[k]){\\n            for(int i = 0;i<a.size();i++){\\n                if(a[i])a[i]--,cnt++;\\n                if(!a[k])break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995977,
                "title": "easy-o-1-solution-without-queue",
                "content": "# Intuition\\nnothing XD\\n\\n# Approach\\niterate over array and keep track \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int i=0;\\n        int sec=0;\\n        while(tickets[k]>0){\\n\\n            if(tickets[i]>0){\\n                tickets[i] = tickets[i]-1;\\n                i = (i+1)%tickets.length;\\n                sec++;\\n            }else{\\n                i = (i+1)%tickets.length;\\n            }\\n        }\\n\\n        return sec;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int i=0;\\n        int sec=0;\\n        while(tickets[k]>0){\\n\\n            if(tickets[i]>0){\\n                tickets[i] = tickets[i]-1;\\n                i = (i+1)%tickets.length;\\n                sec++;\\n            }else{\\n                i = (i+1)%tickets.length;\\n            }\\n        }\\n\\n        return sec;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985951,
                "title": "simple-c-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& t, int k) {\\n        int ans=0;\\n        while(t[k]!=0){\\n            for(int i=0;i<t.size();i++){\\n                if(t[i]>0){\\n                    t[i]=t[i]-1;\\n                    ans++;\\n                }\\n                if(t[k]==0)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& t, int k) {\\n        int ans=0;\\n        while(t[k]!=0){\\n            for(int i=0;i<t.size();i++){\\n                if(t[i]>0){\\n                    t[i]=t[i]-1;\\n                    ans++;\\n                }\\n                if(t[k]==0)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984228,
                "title": "simple-c-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\nLinear Time complexity\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n                i++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n                i++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980174,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int n = tickets[k];\\n        while (n > 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i]-- > 0) {\\n                    count++;\\n                    if (i == k) {\\n                        n--;\\n                    }\\n                    if (tickets[k] == 0) {\\n                        return count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int n = tickets[k];\\n        while (n > 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i]-- > 0) {\\n                    count++;\\n                    if (i == k) {\\n                        n--;\\n                    }\\n                    if (tickets[k] == 0) {\\n                        return count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980063,
                "title": "java-easy-o-n-100-beats-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s assume there are n person standing in the queue a\\na1, a2, a3, ... ak ... an\\ni\\'th person will buy ai number of tickets. \\n\\nObservations\\nFor any person standing at the j\\'th position in the queue such that \\nj <= k, \\nthe one thing is sure, that person will make the k\\'th person to wait by min(aj, ak)\\n\\nand if \\nj > k\\nthen the j\\'th person will make the k\\'th person to wait longer by min(aj, ak-1)\\n\\nUsing the above two observations, we can write an algorithm with O(N) Time Complexity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        // O(N) solution\\n        int time = 0; \\n        for ( int i=0; i < tickets.length; i++){\\n            if ( i <= k){\\n                time += ( tickets[i] <= tickets[k])?tickets[i]:tickets[k];\\n            }\\n            else{\\n                time += (tickets[i] < tickets[k])?tickets[i]: (tickets[k]-1);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        // O(N) solution\\n        int time = 0; \\n        for ( int i=0; i < tickets.length; i++){\\n            if ( i <= k){\\n                time += ( tickets[i] <= tickets[k])?tickets[i]:tickets[k];\\n            }\\n            else{\\n                time += (tickets[i] < tickets[k])?tickets[i]: (tickets[k]-1);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971374,
                "title": "js-time-o-n-space-o-1-single-for-loop",
                "content": "# Intuition & Approach\\nCycle the array, if tickets at i is greater than or equal to tickets at k you add to seconds the value of tickets at k, otherwise (if the number is smaller) you add tickets at k.\\nif the number at k is larger then the number at i and it is positioned after k so that i > k, you need to subtract 1 for each occourrence (we need to stop when tickets[k] reaches 0, so we dont need to count iterations afterwards)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let seconds = 0\\n    for(let i = 0; i < tickets.length; i++){\\n        if(tickets[i] >= tickets[k]){\\n            seconds += tickets[k]\\n            if(i > k) {\\n                seconds -= 1\\n            }\\n        } else {\\n            seconds += tickets[i]\\n        }\\n    }\\n    return seconds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let seconds = 0\\n    for(let i = 0; i < tickets.length; i++){\\n        if(tickets[i] >= tickets[k]){\\n            seconds += tickets[k]\\n            if(i > k) {\\n                seconds -= 1\\n            }\\n        } else {\\n            seconds += tickets[i]\\n        }\\n    }\\n    return seconds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966793,
                "title": "with-basic-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count=0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i]>0:\\n                    tickets[i]-=1\\n                    count+=1\\n                if tickets[k]==0:\\n                    return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count=0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i]>0:\\n                    tickets[i]-=1\\n                    count+=1\\n                if tickets[k]==0:\\n                    return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963719,
                "title": "easy-to-understand-python3-solution-tc-m-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count = 0\\n\\n        check = tickets[k]\\n\\n        while check != 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0:\\n                    if tickets[k] == 0:\\n                        break\\n                    count += 1\\n                    tickets[i] -= 1\\n            check = tickets[k]\\n            \\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count = 0\\n\\n        check = tickets[k]\\n\\n        while check != 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0:\\n                    if tickets[k] == 0:\\n                        break\\n                    count += 1\\n                    tickets[i] -= 1\\n            check = tickets[k]\\n            \\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956695,
                "title": "python-one-liner",
                "content": "# Approach\\n- the ticket less than the kth customer must spend all their time\\nsum(i for i in tickets if i <= tickets[k])\\n- the ticket more than the kth customer must spend the time equal to the kth customer\\nlen([i for i in tickets if i > tickets[k]])*tickets[k]\\n- the ticket more than the kth customer but after the kth customer need to minus one seconds beacuse when the kth customer finished, the program finished\\nlen([i for i in tickets[k+1:] if i >= tickets[k]])\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(i for i in tickets if i <= tickets[k]) + len([i for i in tickets if i > tickets[k]])*tickets[k] - len([i for i in tickets[k+1:] if i >= tickets[k]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(i for i in tickets if i <= tickets[k]) + len([i for i in tickets if i > tickets[k]])*tickets[k] - len([i for i in tickets[k+1:] if i >= tickets[k]])\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1628030,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1928915,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1930154,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 2010067,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 2010064,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1969342,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1919927,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Nodes in Even Length Groups",
        "question_content": "<p>You are given the <code>head</code> of a linked list.</p>\n\n<p>The nodes in the linked list are <strong>sequentially</strong> assigned to <strong>non-empty</strong> groups whose lengths form the sequence of the natural numbers (<code>1, 2, 3, 4, ...</code>). The <strong>length</strong> of a group is the number of nodes assigned to it. In other words,</p>\n\n<ul>\n\t<li>The <code>1<sup>st</sup></code> node is assigned to the first group.</li>\n\t<li>The <code>2<sup>nd</sup></code> and the <code>3<sup>rd</sup></code> nodes are assigned to the second group.</li>\n\t<li>The <code>4<sup>th</sup></code>, <code>5<sup>th</sup></code>, and <code>6<sup>th</sup></code> nodes are assigned to the third group, and so on.</li>\n</ul>\n\n<p>Note that the length of the last group may be less than or equal to <code>1 + the length of the second to last group</code>.</p>\n\n<p><strong>Reverse</strong> the nodes in each group with an <strong>even</strong> length, and return <em>the</em> <code>head</code> <em>of the modified linked list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg1.png\" style=\"width: 699px; height: 124px;\" />\n<pre>\n<strong>Input:</strong> head = [5,2,6,3,9,1,7,3,8,4]\n<strong>Output:</strong> [5,6,2,3,9,1,4,8,3,7]\n<strong>Explanation:</strong>\n- The length of the first group is 1, which is odd, hence no reversal occurs.\n- The length of the second group is 2, which is even, hence the nodes are reversed.\n- The length of the third group is 3, which is odd, hence no reversal occurs.\n- The length of the last group is 4, which is even, hence the nodes are reversed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg2.png\" style=\"width: 284px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,0,6]\n<strong>Output:</strong> [1,0,1,6]\n<strong>Explanation:</strong>\n- The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 1. No reversal occurs.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/17/ex3.png\" style=\"width: 348px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,0,6,5]\n<strong>Output:</strong> [1,0,1,5,6]\n<strong>Explanation:</strong>\n- The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 2. The nodes are reversed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576952,
                "title": "c-well-commented-clear-code-idea-explained-in-brief",
                "content": "\\n\\n**Idea**\\n* I traverse the list in groups where the sizes are in the increasing order of natural numbers. \\n* Whenever a group with even length is encountered, that group is reversed using the reverse function and I proceed with processing the next group. \\n* The solution involves several pointers which track the current group\\u2019s head, tail and the next group\\u2019s head. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    \\n    // Function to reverse a linked list\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // Creating a dummy node to avoid adding checks for the first node\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        // Loop to determine the lengths of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                // If even sized group is found\\n                // Reversing the group and setting prev and head appropriately\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                // If group is odd sized, then simply going towards the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        // Returning the head\\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n*Space Complexity: O(1)*\\n*Time Complexity: O(n)*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Function to reverse a linked list\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // Creating a dummy node to avoid adding checks for the first node\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        // Loop to determine the lengths of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                // If even sized group is found\\n                // Reversing the group and setting prev and head appropriately\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                // If group is odd sized, then simply going towards the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        // Returning the head\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576911,
                "title": "java-two-pointers-stack",
                "content": "**Idea :** \\n1. \\ttemp is pointing end of a particular group\\n1. \\tstart is pointing starting of a particular group\\n1. \\twhile traversing put node\\'s values in stack (LIFO)\\n1. \\twhen the count of nodes in a group is == to the count of nodes required for that group and is even \\nthen move start pointer ahead and update values of nodes in that group.\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int groupRequired = 1;\\n        ListNode temp = head;\\n        while(temp != null){\\n            int count = 0;\\n            ListNode start = temp;\\n            Stack<Integer> stack = new Stack<>();\\n            while(count != groupRequired && temp != null){\\n                stack.push(temp.val);\\n                temp = temp.next;\\n                count++;\\n            }\\n            if(count % 2 == 0) {\\n                while(start != temp){\\n                    start.val = stack.pop();\\n                    start = start.next;\\n                }\\n            }\\n            groupRequired++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int groupRequired = 1;\\n        ListNode temp = head;\\n        while(temp != null){\\n            int count = 0;\\n            ListNode start = temp;\\n            Stack<Integer> stack = new Stack<>();\\n            while(count != groupRequired && temp != null){\\n                stack.push(temp.val);\\n                temp = temp.next;\\n                count++;\\n            }\\n            if(count % 2 == 0) {\\n                while(start != temp){\\n                    start.val = stack.pop();\\n                    start = start.next;\\n                }\\n            }\\n            groupRequired++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577032,
                "title": "python-reverse-linked-list-o-1-space",
                "content": "Similiar to [25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/), reverse a range of linked list when the range has an even length\\n```\\ndef reverseEvenLengthGroups(head):\\n\\tprev = head\\n\\td = 2 # the head doesn\\'t need to be reversed anytime so starts with length 2\\n\\twhile prev.next:\\n\\t\\tnode, n = prev, 0\\n\\t\\tfor _ in range(d):\\n\\t\\t\\tif not node.next:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tn += 1\\n\\t\\t\\tnode = node.next\\n\\t\\tif n & 1:  # odd length\\n\\t\\t\\tprev = node\\n\\t\\telse:      # even length\\n\\t\\t\\tnode, rev = prev.next, None\\n\\t\\t\\tfor _ in range(n):\\n\\t\\t\\t\\tnode.next, node, rev = rev, node.next, node\\n\\t\\t\\tprev.next.next, prev.next, prev = node, rev, prev.next\\n\\t\\td += 1\\n\\treturn head\\n```\\n\\nCheat during the contest to save time, convert linked list to a list and then just do slice reversion.\\nOf course cost extra O(n) space\\n```\\ndef reverseEvenLengthGroups(self, head):\\n\\ta = []\\n\\tnode = head\\n\\twhile node:\\n\\t\\ta.append(node.val)\\n\\t\\tnode = node.next\\n\\ti, d, n = 0, 1, len(a)\\n\\twhile i < n:\\n\\t\\tif min(d, n-i) & 1 == 0:\\n\\t\\t\\ta[i:i+d] = a[i:i+d][::-1]\\n\\t\\ti += d\\n\\t\\td += 1\\n\\tnode = head\\n\\tfor x in a:\\n\\t\\tnode.val = x\\n\\t\\tnode = node.next\\n\\treturn head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef reverseEvenLengthGroups(head):\\n\\tprev = head\\n\\td = 2 # the head doesn\\'t need to be reversed anytime so starts with length 2\\n\\twhile prev.next:\\n\\t\\tnode, n = prev, 0\\n\\t\\tfor _ in range(d):\\n\\t\\t\\tif not node.next:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tn += 1\\n\\t\\t\\tnode = node.next\\n\\t\\tif n & 1:  # odd length\\n\\t\\t\\tprev = node\\n\\t\\telse:      # even length\\n\\t\\t\\tnode, rev = prev.next, None\\n\\t\\t\\tfor _ in range(n):\\n\\t\\t\\t\\tnode.next, node, rev = rev, node.next, node\\n\\t\\t\\tprev.next.next, prev.next, prev = node, rev, prev.next\\n\\t\\td += 1\\n\\treturn head\\n```\n```\\ndef reverseEvenLengthGroups(self, head):\\n\\ta = []\\n\\tnode = head\\n\\twhile node:\\n\\t\\ta.append(node.val)\\n\\t\\tnode = node.next\\n\\ti, d, n = 0, 1, len(a)\\n\\twhile i < n:\\n\\t\\tif min(d, n-i) & 1 == 0:\\n\\t\\t\\ta[i:i+d] = a[i:i+d][::-1]\\n\\t\\ti += d\\n\\t\\td += 1\\n\\tnode = head\\n\\tfor x in a:\\n\\t\\tnode.val = x\\n\\t\\tnode = node.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1577372,
                "title": "constant-memory",
                "content": "> Trap: if the last group is incomplete, we still need to reverse it if it has even number of elements.\\n\\nI re-used the `reverseList` function from my solution for [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/). It reverses `n` elements starting from a specific node.\\n\\nNow, we just need to find the groups. For each grop, we track `start` (`start->next` is the first element in the group), and the number of elements available.\\n\\n**C++**\\n```cpp\\nListNode* reverseList(ListNode* cur, int n) {\\n    ListNode *start = cur, *prev = nullptr;\\n    while (--n >= 0) {\\n        swap(cur->next, prev);\\n        if (--n >= 0)\\n            swap(prev->next, cur);\\n    }\\n    start->next = cur;\\n    return prev;\\n}  \\nListNode* reverseEvenLengthGroups(ListNode* head) {\\n    int group = 2, cnt = 0;\\n    auto *start = head, *p = head->next;\\n    while (p != nullptr) {\\n        if (++cnt == group) {\\n            if (group % 2 == 0) {\\n                p = start->next;\\n                start->next = reverseList(start->next, cnt);\\n            }\\n            start = p;\\n            cnt = 0;\\n            ++group;\\n        }\\n        p = p->next;\\n    }\\n    if (cnt % 2 == 0 && start->next != nullptr)\\n        start->next = reverseList(start->next, cnt);\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nListNode* reverseList(ListNode* cur, int n) {\\n    ListNode *start = cur, *prev = nullptr;\\n    while (--n >= 0) {\\n        swap(cur->next, prev);\\n        if (--n >= 0)\\n            swap(prev->next, cur);\\n    }\\n    start->next = cur;\\n    return prev;\\n}  \\nListNode* reverseEvenLengthGroups(ListNode* head) {\\n    int group = 2, cnt = 0;\\n    auto *start = head, *p = head->next;\\n    while (p != nullptr) {\\n        if (++cnt == group) {\\n            if (group % 2 == 0) {\\n                p = start->next;\\n                start->next = reverseList(start->next, cnt);\\n            }\\n            start = p;\\n            cnt = 0;\\n            ++group;\\n        }\\n        p = p->next;\\n    }\\n    if (cnt % 2 == 0 && start->next != nullptr)\\n        start->next = reverseList(start->next, cnt);\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577077,
                "title": "java-reverse-list-o-1-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // Check corner case with null.\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        // Count number of nodes in total.\\n        ListNode ptr = head;\\n        int total = 0;\\n        while (ptr != null) {\\n            total++;\\n            ptr = ptr.next;\\n        }\\n        \\n        int numOfNodes = 1;\\n        ListNode cur = head, pre = null;\\n        while (cur != null) {\\n            numOfNodes = Math.min(numOfNodes, total);\\n            total -= numOfNodes;\\n            if (numOfNodes % 2 == 1) {\\n                // Odd: Move pointers.\\n                int cnt = 0;\\n                while (cur != null && cnt++ < numOfNodes) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else {\\n                // Even: Reverse List\\n                ListNode[] res = reverseList(cur, numOfNodes);\\n                pre.next = res[0];\\n                pre = cur;\\n                cur = res[1];\\n            }\\n            numOfNodes++;\\n        }\\n        return head;\\n    }\\n    \\n    // Reverse from node with n nodes.\\n    private ListNode[] reverseList(ListNode node, int n) {\\n        ListNode pre = null, cur = node, post = null;\\n        while (n-- > 0) {\\n            post = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = post;\\n        }\\n        node.next = cur;\\n        return new ListNode[]{pre, post};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // Check corner case with null.\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        // Count number of nodes in total.\\n        ListNode ptr = head;\\n        int total = 0;\\n        while (ptr != null) {\\n            total++;\\n            ptr = ptr.next;\\n        }\\n        \\n        int numOfNodes = 1;\\n        ListNode cur = head, pre = null;\\n        while (cur != null) {\\n            numOfNodes = Math.min(numOfNodes, total);\\n            total -= numOfNodes;\\n            if (numOfNodes % 2 == 1) {\\n                // Odd: Move pointers.\\n                int cnt = 0;\\n                while (cur != null && cnt++ < numOfNodes) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else {\\n                // Even: Reverse List\\n                ListNode[] res = reverseList(cur, numOfNodes);\\n                pre.next = res[0];\\n                pre = cur;\\n                cur = res[1];\\n            }\\n            numOfNodes++;\\n        }\\n        return head;\\n    }\\n    \\n    // Reverse from node with n nodes.\\n    private ListNode[] reverseList(ListNode node, int n) {\\n        ListNode pre = null, cur = node, post = null;\\n        while (n-- > 0) {\\n            post = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = post;\\n        }\\n        node.next = cur;\\n        return new ListNode[]{pre, post};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577058,
                "title": "python3-using-stack",
                "content": "Downvoters, leave a comment! \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n, node = 0, head\\n        while node: n, node = n+1, node.next\\n        \\n        k, node = 0, head \\n        while n: \\n            k += 1\\n            size = min(k, n)\\n            stack = []\\n            if not size & 1: \\n                temp = node \\n                for _ in range(size): \\n                    stack.append(temp.val)\\n                    temp = temp.next \\n            for _ in range(size): \\n                if stack: node.val = stack.pop()\\n                node = node.next \\n            n -= size\\n        return head \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n, node = 0, head\\n        while node: n, node = n+1, node.next\\n        \\n        k, node = 0, head \\n        while n: \\n            k += 1\\n            size = min(k, n)\\n            stack = []\\n            if not size & 1: \\n                temp = node \\n                for _ in range(size): \\n                    stack.append(temp.val)\\n                    temp = temp.next \\n            for _ in range(size): \\n                if stack: node.val = stack.pop()\\n                node = node.next \\n            n -= size\\n        return head \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577265,
                "title": "java-easy-code",
                "content": "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        ListNode temp = head;\\n        int num=1;\\n        \\n        while(temp!=null)\\n        {\\n            int count=0;\\n            ListNode start = temp;\\n            Stack st = new Stack();\\n            \\n            while(count!=num && temp!=null)\\n            {\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n                    \\n            }\\n            \\n            if(count%2==0)\\n            {\\n                while(temp!=start)\\n                {\\n                  start.val=(int) st.pop();\\n                 start=start.next;  \\n                }\\n                \\n            }\\n            \\n            num++;\\n        }\\n        \\n        \\n        return head;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        ListNode temp = head;\\n        int num=1;\\n        \\n        while(temp!=null)\\n        {\\n            int count=0;\\n            ListNode start = temp;\\n            Stack st = new Stack();\\n            \\n            while(count!=num && temp!=null)\\n            {\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n                    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3746598,
                "title": "java-c-o-n-solution-readable-code-illustration",
                "content": "This problem can be broken down into 2 steps:\\n\\n1.  Since we need to reverse the nodes in each group with an even length, we need to check length of each group. It it is odd then there is no need to reverse.\\n2.  If we need to reverse the **N** nodes, how to do that? Following is my idea:\\n \\n\\n\\t\\nIf the structure of the linkedlist is like this:\\n\\n\\n\\t\\t1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 \\n\\t\\n\\t\\nSince group 1 will always have one node. It doesn\\'t need to be reversed.\\n\\nWe will have node as a pointer :\\n```\\n\\tListNode node=head;\\n\\tint group=1;\\n```\\n\\nAfter we have node as the pointer, the linked list will look like this:\\n```\\n\\t1 (node) -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n```\\nNow we will start counting & reversing from 2nd node.\\nTo count number of nodes in a group we will use following code:\\n```\\n\\tint countNodes=0;\\n    ListNode temp=node.next;\\n     while(temp!=null && countNodes<group)\\n\\t\\t {\\n\\t\\t\\t  temp=temp.next;\\n              countNodes++;\\n         }\\n```\\n\\nSuppose that there are **even** nodes to be reversed, we just use the \"reverse linked list\" trick to reverse the k nodes. Please refer to \"https://leetcode.com/problems/reverse-linked-list/\" if you don\\'t know how to reverse a linked list.\\n\\nIf **countNodes is even** i.e for second group `countNodes= 2, we can reverse 2 to 3`  using the following code:\\n\\n```\\n\\tListNode curr=node.next,prev=null,next=null;\\n     for(int i=0;i<countNodes;i++)\\n\\t\\t{\\n\\t\\t\\t  next=curr.next;\\n              curr.next=prev;\\n              prev=curr;\\n              curr=next;\\n        }             \\n```\\n\\nThis is the illustartion of the first 2 steps:\\n\\n```\\n    We will begin reversing form 2nd node\\n\\t\\n    Step1: 1 (node)  -> 2      3 -> 4 -> 5 -> 6 -> 7\\n\\tStep2: 1 (node)  -> 2 <- 3      4 -> 5 -> 6 -> 7\\n\\t\\n```\\n\\nThis is an easy and general algorithm to reverse a linked list. However, if you are careful enough, you will find that after the for-loop, the link from 3 to 4 will be cut (as shown in step 2).\\n\\nNow we need to reconstruct the linked list and fix the issue. You will figure out that at step3, the 3 is the **prev** node, 4 is the **curr** node.\\n\\n```\\nstep2: 1 (node) -> 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n```\\n\\n\\t\\nWe can fix the sequence based on the following codes. The basic idea is to link the `node to 3` and `link 2 to 4`:\\n\\n```\\n\\tListNode tail=node.next;\\n    tail.next=curr;\\n    node.next=prev;\\n    node=tail;\\n```\\n\\nThen the result is:\\n```\\n\\tafter first line:        1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\tafter second line:       1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t         |________________________\\u2191\\n\\tafter third line:   \\n\\t\\t\\t\\t\\t\\t\\t\\t |--------------------\\u2193\\n\\t\\t\\t\\t\\t\\t     1 (node)    2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t     |________________________\\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\tafter forth line:\\t     1  -> 3  -> 2  (node) -> 4 -> 5 -> 6 -> 7\\n```\\n\\nNow we get the new **node** as pointer, and we can repeat the process.\\n\\n` `**Edge Case**:  if the last group is incomplete, we still need to reverse it if it has even number of elements.\\n\\n\\n\\nIf group has odd number of nodes then we can skip the reverse process by following code:\\n```\\n\\tfor(int i=0;i<countNodes;i++)\\n\\t\\t node=node.next;\\n```\\n\\nHere is the code:\\n\\n**Java**\\n\\n```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        //  if LL has 1 or 2 nodes only\\n        if (head.next == null || head.next.next == null) return head;\\n        ListNode node = head;\\n        int group = 1;\\n\\n        while (node != null && node.next != null) {\\n            group++;\\n\\t\\t\\t\\n            //first check number of nodes \\n            int countNodes = 0;\\n            ListNode temp = node.next;\\n            while (temp != null && countNodes < group) {\\n                temp = temp.next;\\n                countNodes++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//now we have count now we will check if it is even then do reverse else skip\\n            if (countNodes % 2 == 0) {\\n                ListNode curr = node.next, prev = null, next = null;\\n                for (int i = 0; i < countNodes; i++) {\\n                    next = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = next;\\n                }\\n\\n                ListNode tail = node.next;\\n                tail.next = curr;\\n                node.next = prev;\\n                node = tail;\\n            } else {\\n                for (int i = 0; i < countNodes; i++)\\n                    node = node.next;\\n            }\\n        }\\n        return head;\\n    }\\n```\\n\\n**C++**\\n```\\nListNode* reverseEvenLengthGroups(ListNode *head)\\n\\t\\t{\\n\\t\\t\\t//  if LL has 1 or 2 nodes only\\n\\t\\t\\tif (head->next == nullptr || head->next->next == nullptr) return head;\\n\\n\\t\\t\\tListNode *node = head;\\n\\t\\t\\tint group = 1;\\n\\n\\t\\t\\twhile (node != nullptr && node->next != nullptr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgroup++;\\n\\n\\t\\t\\t\\tint countNodes = 0;\\n\\t\\t\\t\\tListNode *temp = node->next;\\n\\t\\t\\t\\twhile (temp != nullptr && countNodes < group)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t\\t\\tcountNodes++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (countNodes % 2 == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tListNode *curr = node->next, *prev = nullptr, *next = nullptr;\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnext = curr->next;\\n\\t\\t\\t\\t\\t\\tcurr->next = prev;\\n\\t\\t\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\t\\t\\tcurr = next;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tListNode *tail = node->next;\\n\\t\\t\\t\\t\\ttail->next = curr;\\n\\t\\t\\t\\t\\tnode->next = prev;\\n\\t\\t\\t\\t\\tnode = tail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnode = node->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn head;\\n\\t\\t}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8e188750-ff71-4621-b32f-f28d92186d1b_1689008854.9552872.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\tListNode node=head;\\n\\tint group=1;\\n```\n```\\n\\t1 (node) -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n```\n```\\n\\tint countNodes=0;\\n    ListNode temp=node.next;\\n     while(temp!=null && countNodes<group)\\n\\t\\t {\\n\\t\\t\\t  temp=temp.next;\\n              countNodes++;\\n         }\\n```\n```\\n\\tListNode curr=node.next,prev=null,next=null;\\n     for(int i=0;i<countNodes;i++)\\n\\t\\t{\\n\\t\\t\\t  next=curr.next;\\n              curr.next=prev;\\n              prev=curr;\\n              curr=next;\\n        }             \\n```\n```\\n    We will begin reversing form 2nd node\\n\\t\\n    Step1: 1 (node)  -> 2      3 -> 4 -> 5 -> 6 -> 7\\n\\tStep2: 1 (node)  -> 2 <- 3      4 -> 5 -> 6 -> 7\\n\\t\\n```\n```\\nstep2: 1 (node) -> 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n```\n```\\n\\tListNode tail=node.next;\\n    tail.next=curr;\\n    node.next=prev;\\n    node=tail;\\n```\n```\\n\\tafter first line:        1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\tafter second line:       1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t         |________________________\\u2191\\n\\tafter third line:   \\n\\t\\t\\t\\t\\t\\t\\t\\t |--------------------\\u2193\\n\\t\\t\\t\\t\\t\\t     1 (node)    2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t     |________________________\\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\tafter forth line:\\t     1  -> 3  -> 2  (node) -> 4 -> 5 -> 6 -> 7\\n```\n```\\n\\tfor(int i=0;i<countNodes;i++)\\n\\t\\t node=node.next;\\n```\n```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        //  if LL has 1 or 2 nodes only\\n        if (head.next == null || head.next.next == null) return head;\\n        ListNode node = head;\\n        int group = 1;\\n\\n        while (node != null && node.next != null) {\\n            group++;\\n\\t\\t\\t\\n            //first check number of nodes \\n            int countNodes = 0;\\n            ListNode temp = node.next;\\n            while (temp != null && countNodes < group) {\\n                temp = temp.next;\\n                countNodes++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//now we have count now we will check if it is even then do reverse else skip\\n            if (countNodes % 2 == 0) {\\n                ListNode curr = node.next, prev = null, next = null;\\n                for (int i = 0; i < countNodes; i++) {\\n                    next = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = next;\\n                }\\n\\n                ListNode tail = node.next;\\n                tail.next = curr;\\n                node.next = prev;\\n                node = tail;\\n            } else {\\n                for (int i = 0; i < countNodes; i++)\\n                    node = node.next;\\n            }\\n        }\\n        return head;\\n    }\\n```\n```\\nListNode* reverseEvenLengthGroups(ListNode *head)\\n\\t\\t{\\n\\t\\t\\t//  if LL has 1 or 2 nodes only\\n\\t\\t\\tif (head->next == nullptr || head->next->next == nullptr) return head;\\n\\n\\t\\t\\tListNode *node = head;\\n\\t\\t\\tint group = 1;\\n\\n\\t\\t\\twhile (node != nullptr && node->next != nullptr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgroup++;\\n\\n\\t\\t\\t\\tint countNodes = 0;\\n\\t\\t\\t\\tListNode *temp = node->next;\\n\\t\\t\\t\\twhile (temp != nullptr && countNodes < group)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t\\t\\tcountNodes++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (countNodes % 2 == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tListNode *curr = node->next, *prev = nullptr, *next = nullptr;\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnext = curr->next;\\n\\t\\t\\t\\t\\t\\tcurr->next = prev;\\n\\t\\t\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\t\\t\\tcurr = next;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tListNode *tail = node->next;\\n\\t\\t\\t\\t\\ttail->next = curr;\\n\\t\\t\\t\\t\\tnode->next = prev;\\n\\t\\t\\t\\t\\tnode = tail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnode = node->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn head;\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832053,
                "title": "clean-python-solution-simple-beats-100-explanation",
                "content": "# Intuition\\nWhen considering this problem, we need to be comfortable with various linked list operations and concepts. These include understanding how to traverse a linked list, reverse a section of it without disrupting the rest of the list, and reconnect reversed segments seamlessly back into the list. With these tools in hand, the problem becomes a matter of grouping nodes, reversing the groups of even length, and then reconnecting these altered groups back into a complete linked list.\\n\\n# Approach\\nWe use a two-pointer approach to solve this problem. One pointer, `connector`, keeps track of the node preceding the current group. The other, `curr`, navigates the nodes within the current group.\\n\\nThe process begins with `curr` pointing to the head of the list and `connector` being None. We also have two counters, `group_count` to keep track of which group we are in, and `count` to track the length of the current group.\\n\\nWe have a helper function, `reverse_between`, which performs an in-place reversal of a section of the linked list starting from the node after `pre`, and does this for `n` nodes. It uses the classic three-pointer method for list reversal, with a twist to maintain the continuity of the list. Instead of breaking off the section to be reversed, it leaves the start node of this section linked to the rest of the list and moves the remaining nodes one by one to the front. This results in the list being reversed, but the original start node is now the end node of the reversed section and still connected to the rest of the list. After the reversal, the function returns the new end node of the section (which was the original start node).\\n\\nWe proceed with traversing the list, checking at each step whether we are at the end of a group. This is determined either by the counters `group_count` and `count` being equal, or by reaching the end of the list (`curr.next` is None). If we are at the end of a group and the group has an even length, we reverse it with our helper function and update the pointers accordingly. We then increment `group_count` and reset `count` to 0. We repeat this until we have traversed the entire list.\\n\\nThis approach ensures that even-length groups are reversed while maintaining the continuity of the list.\\n\\n# Complexity\\n- Time complexity: The time complexity is **O(n)**, where n is the number of nodes in the linked list. We achieve this by traversing the list only once, with each operation (reversing and reconnecting a group) taking constant time.\\n\\n- Space complexity: The space complexity is **O(1)**. We use a fixed amount of space to store our pointers and counters, and since we perform the reversal in-place, we do not use any additional data structures that scale with the size of the input.\\n\\nFor a detailed explanation of the list reversal process used in reverse_between, you can refer to this [problem](https://leetcode.com/problems/reverse-linked-list-ii/description/).\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        connector = None\\n        curr = head\\n        group_count = 1\\n        count = 1\\n\\n        def reverse_between(pre, n):\\n            start = pre.next\\n            then = start.next\\n            after = start\\n\\n            for _ in range(n - 1):\\n                start.next = then.next\\n                then.next = pre.next\\n                pre.next = then\\n                then = start.next\\n\\n            return after\\n\\n        while curr:\\n            if group_count == count or not curr.next:\\n                if count % 2 == 0:\\n                    curr = reverse_between(connector, count)\\n                connector = curr\\n                group_count += 1\\n                count = 0\\n\\n            count += 1\\n            curr = curr.next\\n\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        connector = None\\n        curr = head\\n        group_count = 1\\n        count = 1\\n\\n        def reverse_between(pre, n):\\n            start = pre.next\\n            then = start.next\\n            after = start\\n\\n            for _ in range(n - 1):\\n                start.next = then.next\\n                then.next = pre.next\\n                pre.next = then\\n                then = start.next\\n\\n            return after\\n\\n        while curr:\\n            if group_count == count or not curr.next:\\n                if count % 2 == 0:\\n                    curr = reverse_between(connector, count)\\n                connector = curr\\n                group_count += 1\\n                count = 0\\n\\n            count += 1\\n            curr = curr.next\\n\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519575,
                "title": "python-simple-neat-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        start_joint = head \\n        group_size = 1\\n        while start_joint and start_joint.next: \\n            group_size += 1\\n            start = end = start_joint.next \\n            group_num = 1 \\n            while end and end.next and group_num < group_size: \\n                end = end.next \\n                group_num += 1 \\n            end_joint = end.next \\n            if group_num % 2 != 0: \\n                start_joint = end \\n                continue \\n            start_joint.next = self.reverse(start, end, end_joint)\\n            start_joint = start \\n        return head\\n    def reverse(self, start, end, end_joint): \\n        prev, curr = end_joint, start\\n        while curr and curr != end_joint: \\n            next_node = curr.next\\n            curr.next = prev\\n            prev, curr = curr, next_node\\n        return prev\\n```\\nComments: This questions is a hard, it uses concepts from other hard questions like Reverse K-Nodes in Group, do not attempt if you are a beginner or haven\\'t had experience with those type of problems. The helper function reverse neatly reverses between start and end, makes sure the reversed end points to the node after end originally(end_joint), and `start_joint.next = self.reverse()` ties it all up. The remainder of the tricky part is handling the odd/even and not matching group_sizes. For those still confused of why there is start_joint, end_joint, this is because you need to maintain the node before and after the part that is being reversed.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        start_joint = head \\n        group_size = 1\\n        while start_joint and start_joint.next: \\n            group_size += 1\\n            start = end = start_joint.next \\n            group_num = 1 \\n            while end and end.next and group_num < group_size: \\n                end = end.next \\n                group_num += 1 \\n            end_joint = end.next \\n            if group_num % 2 != 0: \\n                start_joint = end \\n                continue \\n            start_joint.next = self.reverse(start, end, end_joint)\\n            start_joint = start \\n        return head\\n    def reverse(self, start, end, end_joint): \\n        prev, curr = end_joint, start\\n        while curr and curr != end_joint: \\n            next_node = curr.next\\n            curr.next = prev\\n            prev, curr = curr, next_node\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577126,
                "title": "java-recursion-well-commented",
                "content": "very similar to \\n* https://leetcode.com/problems/reverse-nodes-in-k-group/\\n\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // passing head and current group length\\n\\t\\treturn helper(head, 1);\\n    }\\n    \\n    public ListNode helper(ListNode head, int curr_grp){\\n        if(head == null) return head;\\n        ListNode curr = head, save = null;\\n\\t\\t// \"check\" for the last group when curr == null and we have to decide\\n\\t\\t//  whether to reverse the group or not\\n        int temp = curr_grp, check = 1;\\n        ListNode reverse_head = null;\\n        while(temp > 1){\\n            curr = curr.next;\\n            if(curr == null){\\n                if(check % 2 == 0)\\n                    return reverse(head);\\n                return head;\\n            }\\n            check++;\\n            temp--;\\n        }\\n        save = curr.next;\\n        curr.next = null;\\n        ListNode rec_ = helper(save, curr_grp + 1);\\n        if(curr != null && (curr_grp % 2) == 0){    // reversing this group\\n            reverse_head = reverse(head);\\n            head.next = rec_;\\n            return reverse_head;\\n        }\\n        curr.next = rec_;    // odd length so not required\\n        return head;\\n    }\\n\\t// reverse\\n    public ListNode reverse(ListNode head){\\n        ListNode prev = null;\\n        ListNode curr = head, frwd = curr;\\n        while(curr != null){\\n            frwd = frwd.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = frwd;\\n        }\\n        return prev;\\n    }\\n}\\n//    i was able to do this just a minute before the contest ends but then i realised i had a\\n//    penalty of 5 minutes so didn\\'t got submitted :(",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // passing head and current group length\\n\\t\\treturn helper(head, 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1576946,
                "title": "c-recursion",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode *rev(ListNode* head, int &len, int k){\\n        if(head==NULL) return head;\\n        \\n        ListNode *nextHead; // head node of next group\\n\\t\\tListNode* prevNextHead; // last node of current group\\n        nextHead=head, prevNextHead=nextHead;\\n\\t\\t\\n        for(int i=0;i<k;i++){\\n            prevNextHead=nextHead;\\n            nextHead=nextHead->next;\\n        }\\n        len-=k;\\n        \\n        ListNode *newHead=rev(nextHead,len,min(k+1,len)); // for edge cases like: [0,4,2,1,3] --> [0,2,4,3,1], we need to pass on length of next group accordingly\\n        \\n        ListNode *p, *q;\\n        p=head, q=NULL;\\n        if(k%2==0){ // if length is even, we need to reverse the links of current group\\n            while(p!=nextHead){\\n                ListNode* on=p->next;\\n                p->next=q;\\n                q=p;\\n                p=on;\\n            }\\n        }\\n        if(k%2==0){\\n            head->next=newHead; // as we have reversed the links, initial head node is now last node for the group \\n        }else{\\n            prevNextHead->next=newHead;\\n        }\\n        return (k%2==0 ? q:head);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL) return head;\\n        \\n        ListNode* p=head;\\n        int len=1;\\n        while(p->next!=NULL){\\n            p=p->next;\\n            len++;\\n        }\\n        \\n        return rev(head,len,1);\\n    }\\n};\\n```\\n\\n**Do Upvote if it helps**",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode *rev(ListNode* head, int &len, int k){\\n        if(head==NULL) return head;\\n        \\n        ListNode *nextHead; // head node of next group\\n\\t\\tListNode* prevNextHead; // last node of current group\\n        nextHead=head, prevNextHead=nextHead;\\n\\t\\t\\n        for(int i=0;i<k;i++){\\n            prevNextHead=nextHead;\\n            nextHead=nextHead->next;\\n        }\\n        len-=k;\\n        \\n        ListNode *newHead=rev(nextHead,len,min(k+1,len)); // for edge cases like: [0,4,2,1,3] --> [0,2,4,3,1], we need to pass on length of next group accordingly\\n        \\n        ListNode *p, *q;\\n        p=head, q=NULL;\\n        if(k%2==0){ // if length is even, we need to reverse the links of current group\\n            while(p!=nextHead){\\n                ListNode* on=p->next;\\n                p->next=q;\\n                q=p;\\n                p=on;\\n            }\\n        }\\n        if(k%2==0){\\n            head->next=newHead; // as we have reversed the links, initial head node is now last node for the group \\n        }else{\\n            prevNextHead->next=newHead;\\n        }\\n        return (k%2==0 ? q:head);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL) return head;\\n        \\n        ListNode* p=head;\\n        int len=1;\\n        while(p->next!=NULL){\\n            p=p->next;\\n            len++;\\n        }\\n        \\n        return rev(head,len,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183665,
                "title": "javascript-solution-iterative-approach",
                "content": "```\\nvar reverseEvenLengthGroups = function(head) {\\n    let groupSize = 2;\\n\\n    let start = head;\\n\\n    let prev = head;\\n    let curr = head.next;\\n\\n    let count = 0;\\n    \\n    while (curr != null) {\\n        if (count === groupSize) {\\n            if (groupSize % 2 === 0) { // we only reverse when it is even\\n                const end = curr;\\n                const tail = start.next; // the starting node of the reverse linked list will be the tail after the reverse takes place\\n                reverseList(start, end, count); // we need to reverse everything in the middle of start and end \\n                start = tail; // we set the new start to the end of the reversed linked list\\n            }\\n            else { // when groupSize is even we don\\'t need to reverse, but need to set the new start to the prev node\\n                start = prev;\\n            }\\n            count = 0; // whenever we reached the group size we need to reset our count and up our groupSize\\n            ++groupSize;\\n        }\\n        else { // just a normal traversal when we haven\\'t hit our groupSize\\n            prev = curr;        \\n            curr = curr.next;\\n            ++count;\\n        }\\n    }\\n   \\n    if (count % 2 === 0) { // in the case where we ended early on even count\\n         reverseList(start, null, count);\\n    }\\n    \\n    return head;\\n    \\n    \\n    function reverseList(start, end, count) {\\n        if (start.next == null) return start; // for case when we have a single node\\n        \\n        let prev = start;\\n        \\n        let curr = start.next;\\n        let tail = start.next;\\n        \\n        for (let i = 0; i < count; ++i) {\\n            const next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        start.next = prev;\\n        tail.next = end;\\n        \\n        return ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar reverseEvenLengthGroups = function(head) {\\n    let groupSize = 2;\\n\\n    let start = head;\\n\\n    let prev = head;\\n    let curr = head.next;\\n\\n    let count = 0;\\n    \\n    while (curr != null) {\\n        if (count === groupSize) {\\n            if (groupSize % 2 === 0) { // we only reverse when it is even\\n                const end = curr;\\n                const tail = start.next; // the starting node of the reverse linked list will be the tail after the reverse takes place\\n                reverseList(start, end, count); // we need to reverse everything in the middle of start and end \\n                start = tail; // we set the new start to the end of the reversed linked list\\n            }\\n            else { // when groupSize is even we don\\'t need to reverse, but need to set the new start to the prev node\\n                start = prev;\\n            }\\n            count = 0; // whenever we reached the group size we need to reset our count and up our groupSize\\n            ++groupSize;\\n        }\\n        else { // just a normal traversal when we haven\\'t hit our groupSize\\n            prev = curr;        \\n            curr = curr.next;\\n            ++count;\\n        }\\n    }\\n   \\n    if (count % 2 === 0) { // in the case where we ended early on even count\\n         reverseList(start, null, count);\\n    }\\n    \\n    return head;\\n    \\n    \\n    function reverseList(start, end, count) {\\n        if (start.next == null) return start; // for case when we have a single node\\n        \\n        let prev = start;\\n        \\n        let curr = start.next;\\n        let tail = start.next;\\n        \\n        for (let i = 0; i < count; ++i) {\\n            const next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        start.next = prev;\\n        tail.next = end;\\n        \\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576971,
                "title": "python-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group = 2\\n        tail = head # tail of previous group\\n        while tail and tail.next:\\n            cnt = 1 # actual size of the current group\\n            cur = tail.next # first node of the current group\\n            while cur.next and cnt < group:\\n                cur = cur.next\\n                cnt += 1\\n            pre, cur = tail, tail.next\\n            if cnt % 2 == 0: # if group size is even \\n                while cnt and cur:\\n                    nxt = cur.next\\n                    cur.next = pre\\n                    pre = cur\\n                    cur = nxt\\n                    cnt -= 1\\n                first = tail.next # first node of the original group\\n                first.next = cur\\n                tail.next = pre\\n                tail = first\\n            else:\\n                while cnt and cur:\\n                    pre, cur = cur, cur.next\\n                    cnt -= 1\\n                tail = pre\\n            group += 1\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group = 2\\n        tail = head # tail of previous group\\n        while tail and tail.next:\\n            cnt = 1 # actual size of the current group\\n            cur = tail.next # first node of the current group\\n            while cur.next and cnt < group:\\n                cur = cur.next\\n                cnt += 1\\n            pre, cur = tail, tail.next\\n            if cnt % 2 == 0: # if group size is even \\n                while cnt and cur:\\n                    nxt = cur.next\\n                    cur.next = pre\\n                    pre = cur\\n                    cur = nxt\\n                    cnt -= 1\\n                first = tail.next # first node of the original group\\n                first.next = cur\\n                tail.next = pre\\n                tail = first\\n            else:\\n                while cnt and cur:\\n                    pre, cur = cur, cur.next\\n                    cnt -= 1\\n                tail = pre\\n            group += 1\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576942,
                "title": "c-solution-put-nodes-into-an-array",
                "content": "\\n\\nIf length of group nodes is even then reverse this group in the arr, and then re-construct the List.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<ListNode*> arr;\\n        auto node = head;\\n        while(node) {\\n            arr.push_back(node);\\n            node = node->next;\\n        }\\n        int idx = 0;\\n        int cnt = 1;\\n        while(idx < arr.size()) {\\n            int offset = min(idx + cnt, (int)arr.size());\\n            if((offset - idx) % 2 == 0)\\n                reverse(arr.begin() + idx, arr.begin() + offset);\\n            idx += cnt;\\n            ++cnt;\\n        }\\n        for(int i = 1; i < arr.size(); i++) {\\n            arr[i - 1]->next = arr[i];\\n        }\\n        arr.back()->next = NULL;\\n        return arr[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<ListNode*> arr;\\n        auto node = head;\\n        while(node) {\\n            arr.push_back(node);\\n            node = node->next;\\n        }\\n        int idx = 0;\\n        int cnt = 1;\\n        while(idx < arr.size()) {\\n            int offset = min(idx + cnt, (int)arr.size());\\n            if((offset - idx) % 2 == 0)\\n                reverse(arr.begin() + idx, arr.begin() + offset);\\n            idx += cnt;\\n            ++cnt;\\n        }\\n        for(int i = 1; i < arr.size(); i++) {\\n            arr[i - 1]->next = arr[i];\\n        }\\n        arr.back()->next = NULL;\\n        return arr[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660389,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseEvenLengthGroups(head, 1);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head, int k) {\\n        \\n        if (head == NULL)\\n            return NULL;\\n        \\n        int count = 0;\\n        ListNode *cNode = NULL, *nNode = NULL, *pNode = NULL;\\n        \\n        for (count = 0, cNode = head; count < k && cNode != NULL; ++count)\\n            cNode = cNode->next;\\n        \\n        if (count % 2 == 1) {\\n            for (cNode = head; count > 0; --count) {\\n                pNode = cNode;\\n                cNode = cNode->next;\\n            }\\n            \\n            pNode->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return head;\\n        } else {\\n        \\n            for (cNode = head; count > 0; --count) {\\n                nNode = cNode->next;\\n                cNode->next = pNode;\\n                pNode = cNode;\\n                cNode = nNode;\\n            }\\n            \\n            head->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return pNode;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseEvenLengthGroups(head, 1);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head, int k) {\\n        \\n        if (head == NULL)\\n            return NULL;\\n        \\n        int count = 0;\\n        ListNode *cNode = NULL, *nNode = NULL, *pNode = NULL;\\n        \\n        for (count = 0, cNode = head; count < k && cNode != NULL; ++count)\\n            cNode = cNode->next;\\n        \\n        if (count % 2 == 1) {\\n            for (cNode = head; count > 0; --count) {\\n                pNode = cNode;\\n                cNode = cNode->next;\\n            }\\n            \\n            pNode->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return head;\\n        } else {\\n        \\n            for (cNode = head; count > 0; --count) {\\n                nNode = cNode->next;\\n                cNode->next = pNode;\\n                pNode = cNode;\\n                cNode = nNode;\\n            }\\n            \\n            head->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return pNode;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577114,
                "title": "c-vector-solution",
                "content": "**Create Vector from linked list : O(n)\\nDo operations on vector : O(n)\\nCreate linked list from vector : O(n)\\n3*O(n) :\\nOverall Time : O(n)\\nSpace : O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<int> res, ans;\\n        while(head != nullptr)\\n        {\\n            res.push_back(head->val);\\n            head=head->next;\\n        }\\n        \\n        int c=1;\\n        for(int i=0; i<res.size(); i+=c-1)\\n        {\\n            vector<int> temp;\\n            int j=i, co=c;\\n            while(co-- && j<res.size())\\n            {\\n                temp.push_back(res[j]);\\n                j++;\\n            }\\n            if(temp.size()%2==0)\\n                reverse(temp.begin(), temp.end());\\n            ans.insert(ans.end(), temp.begin(), temp.end());\\n            c++;\\n        }\\n        \\n        ListNode* ptr = new ListNode(ans[0]);\\n        ListNode* h = ptr;\\n        \\n        for(int i=1; i<ans.size(); i++)\\n        {\\n            ListNode* node = new ListNode(ans[i]);\\n            ptr->next = node;\\n            ptr = node;\\n        }\\n        \\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<int> res, ans;\\n        while(head != nullptr)\\n        {\\n            res.push_back(head->val);\\n            head=head->next;\\n        }\\n        \\n        int c=1;\\n        for(int i=0; i<res.size(); i+=c-1)\\n        {\\n            vector<int> temp;\\n            int j=i, co=c;\\n            while(co-- && j<res.size())\\n            {\\n                temp.push_back(res[j]);\\n                j++;\\n            }\\n            if(temp.size()%2==0)\\n                reverse(temp.begin(), temp.end());\\n            ans.insert(ans.end(), temp.begin(), temp.end());\\n            c++;\\n        }\\n        \\n        ListNode* ptr = new ListNode(ans[0]);\\n        ListNode* h = ptr;\\n        \\n        for(int i=1; i<ans.size(); i++)\\n        {\\n            ListNode* node = new ListNode(ans[i]);\\n            ptr->next = node;\\n            ptr = node;\\n        }\\n        \\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576979,
                "title": "c-2074-reverse-nodes-in-even-length-groups",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int n = 0; \\n        for (ListNode* node = head; node; node = node->next, ++n); \\n        \\n        ListNode* node = head; \\n        for (int k = 1; n; ++k) {\\n            int size = min(k, n); \\n            stack<int> stk; \\n            if (size % 2 == 0) {\\n                ListNode* temp = node; \\n                for (int i = 0; i < size; ++i) {\\n                    stk.push(temp->val); \\n                    temp = temp->next; \\n                }\\n            }\\n            for (int i = 0; i < size; ++i) {\\n                if (stk.size()) node->val = stk.top(), stk.pop(); \\n                node = node->next; \\n            }\\n            n -= size; \\n        }\\n        return head; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int n = 0; \\n        for (ListNode* node = head; node; node = node->next, ++n); \\n        \\n        ListNode* node = head; \\n        for (int k = 1; n; ++k) {\\n            int size = min(k, n); \\n            stack<int> stk; \\n            if (size % 2 == 0) {\\n                ListNode* temp = node; \\n                for (int i = 0; i < size; ++i) {\\n                    stk.push(temp->val); \\n                    temp = temp->next; \\n                }\\n            }\\n            for (int i = 0; i < size; ++i) {\\n                if (stk.size()) node->val = stk.top(), stk.pop(); \\n                node = node->next; \\n            }\\n            n -= size; \\n        }\\n        return head; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576917,
                "title": "c-two-pass",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Two Pass\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/reverse-nodes-in-even-length-groups/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int getLength(ListNode *head) {\\n        int len = 0;\\n        for (; head; head = head->next) ++len;\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        for (int i = 0, total = getLength(head); head; ++i) {\\n            int len = min(total, i + 1); // the length of the current section\\n            ListNode *newTail = NULL; // The new tail if we need to reverse the current section\\n            for (int j = 0; j < len && head; ++j) {\\n                auto p = head;\\n                head = head->next;\\n                if (len % 2) { // direct append\\n                    tail->next = p;\\n                    tail = p;\\n                } else { // append in reverse order\\n                    if (newTail == NULL) newTail = p;\\n                    p->next = tail->next; \\n                    tail->next = p;\\n                }\\n            }\\n            if (newTail) tail = newTail;\\n            tail->next = NULL;\\n            total -= len;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/reverse-nodes-in-even-length-groups/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int getLength(ListNode *head) {\\n        int len = 0;\\n        for (; head; head = head->next) ++len;\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        for (int i = 0, total = getLength(head); head; ++i) {\\n            int len = min(total, i + 1); // the length of the current section\\n            ListNode *newTail = NULL; // The new tail if we need to reverse the current section\\n            for (int j = 0; j < len && head; ++j) {\\n                auto p = head;\\n                head = head->next;\\n                if (len % 2) { // direct append\\n                    tail->next = p;\\n                    tail = p;\\n                } else { // append in reverse order\\n                    if (newTail == NULL) newTail = p;\\n                    p->next = tail->next; \\n                    tail->next = p;\\n                }\\n            }\\n            if (newTail) tail = newTail;\\n            tail->next = NULL;\\n            total -= len;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862614,
                "title": "best-c-solution-simple-approach-with-comments-beats-100",
                "content": "\\n\\n\\n### - Time complexity: O(N)\\n\\n### - Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Reverse function\\n    ListNode* reverse(ListNode* head) {\\n        if(head == NULL)\\n            return head;\\n        \\n        ListNode* prev = NULL, *forward = NULL;\\n        while(head != NULL) {\\n            forward = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = forward;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode(), *prev = dummy;\\n        dummy->next = head;\\n        \\n        // Step 1 - determine the length of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head, *nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail != NULL && tail->next != NULL) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail->next;\\n            if((j % 2) == 0) {\\n                // If group size is even then reverse the group and set prev and head\\n                tail->next = NULL;\\n                prev->next = reverse(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            else {     // If group is odd sized then simply go to the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Reverse function\\n    ListNode* reverse(ListNode* head) {\\n        if(head == NULL)\\n            return head;\\n        \\n        ListNode* prev = NULL, *forward = NULL;\\n        while(head != NULL) {\\n            forward = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = forward;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode(), *prev = dummy;\\n        dummy->next = head;\\n        \\n        // Step 1 - determine the length of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head, *nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail != NULL && tail->next != NULL) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail->next;\\n            if((j % 2) == 0) {\\n                // If group size is even then reverse the group and set prev and head\\n                tail->next = NULL;\\n                prev->next = reverse(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            else {     // If group is odd sized then simply go to the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651408,
                "title": "python-c-faster-than-90-easy-implementation-clean-concise-code",
                "content": "# Approach\\n```txt\\nk = odd\\ndummy -> 1 -> || 2 -> 3 -> 4 || -> 5 -> 6 -> 7\\n       grpPrev            kth  grpNxt   --> No Reverse \\n```\\n```txt\\nk = even\\ndummy -> 1 -> || 2 -> 3 -> 4 -> 5 || -> 6 -> 7\\n        grpPrev                kth   grpNxt  --> Reverse \\n```\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```python []\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n\\n    def getKth(self, cur, k):\\n        cnt = k\\n        while cur and cur.next and  k > 0:\\n            cur = cur.next\\n            k -= 1\\n        return [cur, cnt - k]\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(0, head)\\n        groupPrev = dummy\\n\\n        k = 1\\n        while groupPrev and groupPrev.next:\\n            kth, newK = self.getKth(groupPrev, k)\\n            k = newK\\n            groupNext = kth.next\\n\\n            if k%2:\\n                groupPrev = kth\\n            else:\\n                prev, curr = kth.next, groupPrev.next\\n                while curr and curr != groupNext:\\n                    # storing for future use\\n                    nxt = curr.next\\n\\n                    # pointing to the prev ptr\\n                    curr.next = prev\\n\\n                    # updating the ptr\\'s\\n                    prev = curr\\n                    curr = nxt\\n                tmp = groupPrev.next\\n                groupPrev.next = kth\\n                groupPrev = tmp\\n            k += 1\\n        return dummy.next\\n\\n\\n```\\n```C++ []\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n```\\n\\nYou Can also Look At My SDE Prep Repo [\\uD83E\\uDDE2 GitHub](https://github.com/Ayon-SSP/The-SDE-Prep)\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```txt\\nk = odd\\ndummy -> 1 -> || 2 -> 3 -> 4 || -> 5 -> 6 -> 7\\n       grpPrev            kth  grpNxt   --> No Reverse \\n```\n```txt\\nk = even\\ndummy -> 1 -> || 2 -> 3 -> 4 -> 5 || -> 6 -> 7\\n        grpPrev                kth   grpNxt  --> Reverse \\n```\n```python []\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n\\n    def getKth(self, cur, k):\\n        cnt = k\\n        while cur and cur.next and  k > 0:\\n            cur = cur.next\\n            k -= 1\\n        return [cur, cnt - k]\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(0, head)\\n        groupPrev = dummy\\n\\n        k = 1\\n        while groupPrev and groupPrev.next:\\n            kth, newK = self.getKth(groupPrev, k)\\n            k = newK\\n            groupNext = kth.next\\n\\n            if k%2:\\n                groupPrev = kth\\n            else:\\n                prev, curr = kth.next, groupPrev.next\\n                while curr and curr != groupNext:\\n                    # storing for future use\\n                    nxt = curr.next\\n\\n                    # pointing to the prev ptr\\n                    curr.next = prev\\n\\n                    # updating the ptr\\'s\\n                    prev = curr\\n                    curr = nxt\\n                tmp = groupPrev.next\\n                groupPrev.next = kth\\n                groupPrev = tmp\\n            k += 1\\n        return dummy.next\\n\\n\\n```\n```C++ []\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454408,
                "title": "python-3-14-lines-w-example-t-m-97-52",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: ListNode) -> ListNode:\\n\\n        node, nums, ans = head, [], []\\n        T = lambda x: x*(x+1)//2\\n        flip = lambda x: x if len(x)%2 else x[::-1]         #  Example: head = 1->5->4->2->6->3->0->8\\n\\n        while node:                                         #    nums = [1,5,4,2,6,3,0,8]\\n            nums.append(node.val)\\n            node = node.next\\n\\n        for i in range(ceil(-0.5+sqrt(0.25+2*len(nums)))):  #     ans = [[1], [5,4], [2,6,3], [0,8]]\\n            ans.append(nums[T(i):T(i+1)])\\n\\n        ans = chain(*map(flip,ans))                         #     ans = chain(*[[1], [4,5], [2,6,3], [8,0]])\\n                                                            #         = chain([1], [4,5], [2,6,3], [8,0])\\n                                                            #         = [1, 4,5, 2,6,3, 8,0]\\n\\n        node = head                                         #    head = 1->4->5->2->6->3->8->0\\n        for a in ans:\\n            node.val  = a\\n            node = node.next\\n\\n        return head\\n```\\n[https://leetcode.com/problems/reverse-nodes-in-even-length-groups/submissions/939576037/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: ListNode) -> ListNode:\\n\\n        node, nums, ans = head, [], []\\n        T = lambda x: x*(x+1)//2\\n        flip = lambda x: x if len(x)%2 else x[::-1]         #  Example: head = 1->5->4->2->6->3->0->8\\n\\n        while node:                                         #    nums = [1,5,4,2,6,3,0,8]\\n            nums.append(node.val)\\n            node = node.next\\n\\n        for i in range(ceil(-0.5+sqrt(0.25+2*len(nums)))):  #     ans = [[1], [5,4], [2,6,3], [0,8]]\\n            ans.append(nums[T(i):T(i+1)])\\n\\n        ans = chain(*map(flip,ans))                         #     ans = chain(*[[1], [4,5], [2,6,3], [8,0]])\\n                                                            #         = chain([1], [4,5], [2,6,3], [8,0])\\n                                                            #         = [1, 4,5, 2,6,3, 8,0]\\n\\n        node = head                                         #    head = 1->4->5->2->6->3->8->0\\n        for a in ans:\\n            node.val  = a\\n            node = node.next\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302693,
                "title": "python-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next or not head.next.next:\\n            return head\\n\\n        dummy = before = nullCheck = head\\n        before = head\\n        count = 1\\n        \\n        while head:\\n            # length check\\n            length = 0\\n            while nullCheck and length < count:\\n                nullCheck = nullCheck.next\\n                length += 1\\n            \\n            # odd length\\n            if length % 2 == 1:\\n                for _ in range(length):\\n                    before = head\\n                    head = head.next\\n            \\n            else:\\n                tail = head\\n\\n                # reverse\\n                prev = None\\n                for _ in range(length):\\n                    nextNode = head.next\\n                    head.next = prev\\n                    prev = head\\n                    head = nextNode\\n                \\n                # join\\n                before.next = prev\\n                before = tail\\n                tail.next = head\\n            \\n            count += 1\\n        \\n        return dummy\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next or not head.next.next:\\n            return head\\n\\n        dummy = before = nullCheck = head\\n        before = head\\n        count = 1\\n        \\n        while head:\\n            # length check\\n            length = 0\\n            while nullCheck and length < count:\\n                nullCheck = nullCheck.next\\n                length += 1\\n            \\n            # odd length\\n            if length % 2 == 1:\\n                for _ in range(length):\\n                    before = head\\n                    head = head.next\\n            \\n            else:\\n                tail = head\\n\\n                # reverse\\n                prev = None\\n                for _ in range(length):\\n                    nextNode = head.next\\n                    head.next = prev\\n                    prev = head\\n                    head = nextNode\\n                \\n                # join\\n                before.next = prev\\n                before = tail\\n                tail.next = head\\n            \\n            count += 1\\n        \\n        return dummy\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982897,
                "title": "c-faster-than-90-easy-implementation-clean-concise-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724203,
                "title": "c-94-faster-than-all-easy",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534967,
                "title": "java-solution-with-comments-for-better-understanding",
                "content": "```\\npublic ListNode reverseEvenLengthGroups(ListNode head) {\\n        //If there is only one node or only two nodes in the list then list remains unchanged\\n        if(head.next == null || head.next.next == null) return head;\\n        \\n        \\n        //Since group 1 will always have one node\\n        ListNode temp = head;\\n        ListNode prevNode = head;\\n        int group = 1;\\n        \\n        while(temp.next != null){\\n            //Move to the next group\\n            group++;\\n\\n            //Find how many nodes will be in this group. \\n            //Number of nodes cannot exceed group number\\n            int nodes = 0;\\n            while(temp.next != null && nodes < group){\\n                temp = temp.next;\\n                nodes++;\\n            }\\n\\n            //After this loop, temp will be pointing to the last node of this group\\n            ListNode nodeAfterGroup = temp.next;\\n\\n            //If the length of this group is even then reverse this group\\n            if(nodes % 2 == 0){\\n                //Get the list to reverse\\n                ListNode listToReverse = prevNode.next;\\n                ListNode ptr = listToReverse;\\n                while(ptr != temp) ptr = ptr.next;\\n                ptr.next = null;\\n\\n                //Reverse this list\\n                listToReverse = reverse(listToReverse);\\n                ListNode revPtr = listToReverse;\\n                while(revPtr.next != null) revPtr = revPtr.next;\\n\\n                //Attach it back to the original list properly \\n                prevNode.next = listToReverse;\\n                revPtr.next = nodeAfterGroup;\\n                \\n                //Make sure temp now points to the last node of this group after we reversed it.\\n                temp = revPtr;\\n            }\\n                \\n            //Set the previousNode as temp i.e., the node just before the beginning of next group\\n            prevNode = temp;\\n        }\\n        \\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode reverseEvenLengthGroups(ListNode head) {\\n        //If there is only one node or only two nodes in the list then list remains unchanged\\n        if(head.next == null || head.next.next == null) return head;\\n        \\n        \\n        //Since group 1 will always have one node\\n        ListNode temp = head;\\n        ListNode prevNode = head;\\n        int group = 1;\\n        \\n        while(temp.next != null){\\n            //Move to the next group\\n            group++;\\n\\n            //Find how many nodes will be in this group. \\n            //Number of nodes cannot exceed group number\\n            int nodes = 0;\\n            while(temp.next != null && nodes < group){\\n                temp = temp.next;\\n                nodes++;\\n            }\\n\\n            //After this loop, temp will be pointing to the last node of this group\\n            ListNode nodeAfterGroup = temp.next;\\n\\n            //If the length of this group is even then reverse this group\\n            if(nodes % 2 == 0){\\n                //Get the list to reverse\\n                ListNode listToReverse = prevNode.next;\\n                ListNode ptr = listToReverse;\\n                while(ptr != temp) ptr = ptr.next;\\n                ptr.next = null;\\n\\n                //Reverse this list\\n                listToReverse = reverse(listToReverse);\\n                ListNode revPtr = listToReverse;\\n                while(revPtr.next != null) revPtr = revPtr.next;\\n\\n                //Attach it back to the original list properly \\n                prevNode.next = listToReverse;\\n                revPtr.next = nodeAfterGroup;\\n                \\n                //Make sure temp now points to the last node of this group after we reversed it.\\n                temp = revPtr;\\n            }\\n                \\n            //Set the previousNode as temp i.e., the node just before the beginning of next group\\n            prevNode = temp;\\n        }\\n        \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2384715,
                "title": "c-iterative-method",
                "content": "This problem is similar as [reverse-nodes-in-k-group](https://leetcode.com/problems/reverse-nodes-in-k-group/) here k vary .\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head)\\n    {\\n        int len=0;  ListNode*cur=head;\\n        while(cur!=NULL)\\n        { len++ ;cur=cur->next;}                                                                                  //count length of linked list\\n        \\n        ListNode* dummy=new ListNode(0) ;\\n\\t\\tListNode *nex=NULL ,*prev=NULL;\\n        dummy->next=head ; prev=dummy;\\n        \\n        int k=1;\\n\\t\\t\\n        while(len>0)\\n        {\\n            cur=prev->next;\\n            nex=cur->next;\\n                                                \\n            if((k%2!=0 && len>=k) || (len<k && len%2!=0))\\n               for(int i=1;i<k && (len-i) ;i++)                                     // no reverse at odd group and if last group is odd\\n                cur=cur->next;\\n            \\n            else if((k%2==0 && len>=k) || (len<k && len%2==0)) \\n                for(int i=1;i<k && (len-i) ;i++)                                // reverse at even group and if last group is even\\n               {\\n                cur->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=cur->next;\\n               }\\n            \\n            len-=k;\\n            prev=cur;\\n            k++;\\n        }\\n        return dummy->next;\\n    }\\n};\\nFeel free to ask any doubt in comment section",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head)\\n    {\\n        int len=0;  ListNode*cur=head;\\n        while(cur!=NULL)\\n        { len++ ;cur=cur->next;}",
                "codeTag": "Java"
            },
            {
                "id": 1584154,
                "title": "java-easy-explained-solution-o-n-time-complexity-o-1-space-complexity",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public static ListNode reverse(ListNode head,ListNode last,int len){\\n        while(len>0){\\n            ListNode temp=head.next;\\n            head.next=last;\\n            last=head;\\n            head=temp;\\n            len--;\\n        }\\n        return last;\\n    }\\n    public static int len(ListNode node,int maxlen){\\n        int cnt=0;\\n        while(node.next!=null && maxlen>0){\\n            node=node.next;\\n            cnt++;\\n            maxlen--;\\n        }\\n        return cnt;\\n    }\\n    public static ListNode next(ListNode node,int size){\\n        while(size>0){\\n            node=node.next;\\n            size--;\\n        }\\n        return node;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        //It is very obvious that we cann\\'t reverse grp of size 1 so head node will not change in modified LinkedList.\\n        int grpno=2;\\n        ListNode res=head;\\n        while(head!=null){\\n            \\n            //Finding the grp length of given grpno bcz it is always not true that grpno == grp length(mainly in last part of LL)\\n            int grplen=len(head,grpno);\\n            \\n            //Find the node ending at the given grplen\\n            ListNode node=next(head,grplen);\\n            \\n            ListNode temp=head.next;\\n            //reverse the grp with grplen even\\n            if(grplen%2==0){\\n                head.next=reverse(head.next,node.next,grplen);\\n                head=temp;\\n            }\\n            else{\\n                head=node;\\n            }\\n            grpno++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public static ListNode reverse(ListNode head,ListNode last,int len){\\n        while(len>0){\\n            ListNode temp=head.next;\\n            head.next=last;\\n            last=head;\\n            head=temp;\\n            len--;\\n        }\\n        return last;\\n    }\\n    public static int len(ListNode node,int maxlen){\\n        int cnt=0;\\n        while(node.next!=null && maxlen>0){\\n            node=node.next;\\n            cnt++;\\n            maxlen--;\\n        }\\n        return cnt;\\n    }\\n    public static ListNode next(ListNode node,int size){\\n        while(size>0){\\n            node=node.next;\\n            size--;\\n        }\\n        return node;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        //It is very obvious that we cann\\'t reverse grp of size 1 so head node will not change in modified LinkedList.\\n        int grpno=2;\\n        ListNode res=head;\\n        while(head!=null){\\n            \\n            //Finding the grp length of given grpno bcz it is always not true that grpno == grp length(mainly in last part of LL)\\n            int grplen=len(head,grpno);\\n            \\n            //Find the node ending at the given grplen\\n            ListNode node=next(head,grplen);\\n            \\n            ListNode temp=head.next;\\n            //reverse the grp with grplen even\\n            if(grplen%2==0){\\n                head.next=reverse(head.next,node.next,grplen);\\n                head=temp;\\n            }\\n            else{\\n                head=node;\\n            }\\n            grpno++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055037,
                "title": "java-solution-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    static void reverse(ArrayList<Integer> arr, int i, int j){\\n\\n        while(i<j){\\n            int a = arr.get(i);\\n            arr.set(i,arr.get(j));\\n            arr.set(j,a);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        if(head.next==null) return head;\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        ListNode t = head;\\n\\n        while(t!=null){\\n            arr.add(t.val);\\n            t=t.next;\\n        }\\n\\n        int prev = 2;\\n        int idx = -1;\\n\\n        for(int i=1; i+prev-1<arr.size();){\\n            reverse(arr,i,i+prev-1);\\n            if(i+2*prev+1>=arr.size()) idx = i+prev;\\n            else{\\n                idx = i+2*prev+1;\\n            }\\n            i=i+2*prev+1;\\n            prev=prev+2;\\n        }\\n\\n        if(arr.size()-idx>0 && (arr.size()-idx)%2==0){\\n            reverse(arr,idx,arr.size()-1);\\n        }\\n\\n        \\n\\n        ListNode ans = new ListNode(-1);\\n        t=ans;\\n        for(int i=0; i<arr.size(); i++){\\n            t.next = new ListNode(arr.get(i));\\n            t=t.next;\\n        }\\n\\n        return ans.next;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    static void reverse(ArrayList<Integer> arr, int i, int j){\\n\\n        while(i<j){\\n            int a = arr.get(i);\\n            arr.set(i,arr.get(j));\\n            arr.set(j,a);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        if(head.next==null) return head;\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        ListNode t = head;\\n\\n        while(t!=null){\\n            arr.add(t.val);\\n            t=t.next;\\n        }\\n\\n        int prev = 2;\\n        int idx = -1;\\n\\n        for(int i=1; i+prev-1<arr.size();){\\n            reverse(arr,i,i+prev-1);\\n            if(i+2*prev+1>=arr.size()) idx = i+prev;\\n            else{\\n                idx = i+2*prev+1;\\n            }\\n            i=i+2*prev+1;\\n            prev=prev+2;\\n        }\\n\\n        if(arr.size()-idx>0 && (arr.size()-idx)%2==0){\\n            reverse(arr,idx,arr.size()-1);\\n        }\\n\\n        \\n\\n        ListNode ans = new ListNode(-1);\\n        t=ans;\\n        for(int i=0; i<arr.size(); i++){\\n            t.next = new ListNode(arr.get(i));\\n            t=t.next;\\n        }\\n\\n        return ans.next;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878657,
                "title": "not-so-fast-but-understandable-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n****1)First convert linked list to list.\\n\\n2)Then create the temporary list of the desired length like 1,2,3,4...\\n\\n3)Then check if length of temp list is even:\\nif it is even then first reverse it and add it to the ans list\\nelse add temp to ans directly.\\n\\n4)Then we have to check for the remaining elements:\\nlike temp of size 1,2,3 are present but of size 4 is not present, there should be 1,2,3 element remaing in the list.\\n\\n5)so we have to check the no. of remaing element is even then reverse them else add as it is to the ans list.\\n\\n6)Then The final step is to convert the list to linked list again.****\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        ans = []\\n        while head:\\n            l.append(head.val)\\n            head = head.next\\n\\n        right = 1\\n        left = 0\\n        while left+right<=len(l):\\n            temp = l[left:left+right]\\n            if len(temp)%2==0:\\n                temp = temp[::-1]\\n                ans+= temp\\n            else:\\n                ans+= temp\\n            left+=right\\n            right+=1\\n\\n        remain = len(l)-len(ans)\\n        temp2=[]\\n        if remain%2==0:\\n            for i in range(-remain,0,1):\\n                temp2.append(l[i])\\n            ans+=temp2[::-1]\\n        else:    \\n            for i in range(-remain,0,1):\\n                ans.append(l[i])\\n\\n\\n        head=temp=ListNode(ans[0])\\n        for i in range(1,len(ans)):\\n            temp.next = ListNode(ans[i])\\n            temp = temp.next\\n        return head\\n\\n\\n        \\n```\\n**IF YOU LIKE IT PLEASE UPVOTE :))**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        ans = []\\n        while head:\\n            l.append(head.val)\\n            head = head.next\\n\\n        right = 1\\n        left = 0\\n        while left+right<=len(l):\\n            temp = l[left:left+right]\\n            if len(temp)%2==0:\\n                temp = temp[::-1]\\n                ans+= temp\\n            else:\\n                ans+= temp\\n            left+=right\\n            right+=1\\n\\n        remain = len(l)-len(ans)\\n        temp2=[]\\n        if remain%2==0:\\n            for i in range(-remain,0,1):\\n                temp2.append(l[i])\\n            ans+=temp2[::-1]\\n        else:    \\n            for i in range(-remain,0,1):\\n                ans.append(l[i])\\n\\n\\n        head=temp=ListNode(ans[0])\\n        for i in range(1,len(ans)):\\n            temp.next = ListNode(ans[i])\\n            temp = temp.next\\n        return head\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718294,
                "title": "efficient-approach-reverse-even-length-groups-optimal-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a recursive approach to reverse even-length groups of nodes in a linked list. It iterates through the list, reversing each group individually. The time complexity is O(n), and the space complexity is O(n) due to the recursive calls.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the head is NULL or there\\'s only one node, return the head.\\n- Initialize count to 0.\\n- If the group\\'s length is even and there are enough remaining nodes, or if n is less than or equal to k and n is even, reverse the group.\\n- Within a loop, reverse the links between nodes by updating pointers.\\n- Recursively update head->next and return the reversed group\\'s head.\\n- If the group\\'s length is odd or there are fewer remaining nodes, update pointers without reversing.\\n- Recursively update prev->next and return the original head.\\n- Calculate the total number of nodes.\\n- Call the recursive function with initial parameters.\\n- Return the modified linked list.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is **O(n)** as each node is visited once. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is **O(n)** due to the recursive calls, with a maximum depth of n/2.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reveven(ListNode* head, int k, int& n){\\n        if(head==NULL|| head->next == NULL) return head;\\n        int count = 0;\\n        if((k%2 == 0 && n>=k) || (n<=k && n%2 == 0)){\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            ListNode* nextt = NULL;\\n            while(count < k && curr!= NULL){\\n                nextt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nextt;\\n                count++;\\n                n--;\\n            }\\n            head->next = reveven(curr,k+1,n);\\n            return prev;\\n        }\\n        else{\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            while(count < k && curr!= NULL){\\n                prev = curr;\\n                curr = curr->next;\\n                count++;\\n                n--;\\n            }\\n            prev->next = reveven(curr,k+1,n);\\n            return head;\\n        }\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL) return head;\\n        int n = 0;\\n        ListNode* temp = head;\\n        while(temp!=NULL){\\n            temp= temp->next;\\n            n++;\\n        }\\n\\n        return reveven(head, 1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reveven(ListNode* head, int k, int& n){\\n        if(head==NULL|| head->next == NULL) return head;\\n        int count = 0;\\n        if((k%2 == 0 && n>=k) || (n<=k && n%2 == 0)){\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            ListNode* nextt = NULL;\\n            while(count < k && curr!= NULL){\\n                nextt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nextt;\\n                count++;\\n                n--;\\n            }\\n            head->next = reveven(curr,k+1,n);\\n            return prev;\\n        }\\n        else{\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            while(count < k && curr!= NULL){\\n                prev = curr;\\n                curr = curr->next;\\n                count++;\\n                n--;\\n            }\\n            prev->next = reveven(curr,k+1,n);\\n            return head;\\n        }\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL) return head;\\n        int n = 0;\\n        ListNode* temp = head;\\n        while(temp!=NULL){\\n            temp= temp->next;\\n            n++;\\n        }\\n\\n        return reveven(head, 1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578732,
                "title": "python-solution-use-4-pointers-with-clear-explanation",
                "content": "This solution was inspired by @astroash\\'s C++ solution, which can be found at https://leetcode.com/problems/reverse-nodes-in-even-length-groups/solutions/1576952/c-well-commented-clear-code-idea-explained-in-brief/. \\nThis is an implementation of the same solution in Python. The key aspects of this solution will be outlined in this post, with emphasis on the major features and the steps taken to solve the problem.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is essentially a variant of the \\'partial reverse linked list\\' problem, where we only reverse parts of the linked list based on some criteria. In this case, we reverse parts of the linked list that fall into groups of even lengths. Key points in solving this type of problem include:\\n\\n1. Identify the **pattern** of the specific part of the linked list that needs to be reversed and divide it into groups.\\n2. Understand the role of the **prev**, **head**, **tail**, and **next_head** pointers:\\n   - **prev** refers to the node **before** the pattern group. It links the reversed group back to the unmodified part of the list.\\n   - **head** refers to the **start** of the pattern group, which becomes the tail after the group is reversed.\\n   - **tail** refers to the **end** of the pattern group, which becomes the head after the group is reversed.\\n   - **next_head** refers to the **start** of the next group. It links the reversed group to the next part of the list.\\n3. Deal with **edge** conditions. A sentinel node is useful in dealing with edge conditions that may occur at the head or end of the linked list.\\n\\n# Approach\\n![\\u672A\\u547D\\u540D\\u6587\\u4EF6 (16).png](https://assets.leetcode.com/users/images/55cbcf64-5288-4bd4-bceb-a0963d00a90e_1685449691.6244676.png)\\n\\nWe first segment the linked list into different groups based on the provided conditions. We then check each group and reverse it if its length is even. The reversal is achieved using the prev, head, tail, and next_head pointers.\\n\\n1. We define a helper function, `reverse()`, that reverses a linked list from a specified head node and returns the head of the reversed list.\\n2. We create a sentinel node that will aid in handling edge conditions. It also simplifies our code by providing a uniform starting point for each group.\\n3. For each length from 1 to 100000, we manually segment the linked list into groups. For each group, we identify the head, tail, and next_head nodes.\\n4. We check if the group is of even length. If it is, we reverse it by calling our `reverse()` function, and then link the reversed group back to the list.\\n\\n# Complexity\\n\\n- Time complexity: O(n), where n is the number of nodes in the linked list.\\n- Space complexity: O(1), because no additional space is used apart from the original linked list.\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head):\\n            if not head:\\n                return head\\n            prev = None\\n            while head:\\n                next_node = head.next\\n                head.next = prev\\n                prev = head\\n                head = next_node\\n            return prev\\n\\n        sentinel = ListNode(0, head)\\n        prev = sentinel\\n        for length in range(1, 100000):\\n            if not head:\\n                break\\n            tail = head\\n            j = 1\\n            while j < length and tail and tail.next:\\n                tail = tail.next\\n                j += 1\\n\\n            next_head = tail.next\\n\\n            if j % 2 == 0:\\n                tail.next = None\\n                prev.next = reverse(head)\\n                head.next = next_head\\n                prev = head\\n                head = next_head\\n            else:\\n                prev = tail\\n                head = next_head\\n\\n        return sentinel.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head):\\n            if not head:\\n                return head\\n            prev = None\\n            while head:\\n                next_node = head.next\\n                head.next = prev\\n                prev = head\\n                head = next_node\\n            return prev\\n\\n        sentinel = ListNode(0, head)\\n        prev = sentinel\\n        for length in range(1, 100000):\\n            if not head:\\n                break\\n            tail = head\\n            j = 1\\n            while j < length and tail and tail.next:\\n                tail = tail.next\\n                j += 1\\n\\n            next_head = tail.next\\n\\n            if j % 2 == 0:\\n                tail.next = None\\n                prev.next = reverse(head)\\n                head.next = next_head\\n                prev = head\\n                head = next_head\\n            else:\\n                prev = tail\\n                head = next_head\\n\\n        return sentinel.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287091,
                "title": "simple-c-solution-faster-than-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *cur=head,*prev=NULL;\\n        int count=0;\\n        while(cur){\\n            count++;\\n            cur=cur->next;\\n        }\\n        cur=head;\\n        int grpNo=1;\\n        while(cur && grpNo<=count){\\n            int x=grpNo;\\n            while(cur && x){\\n                prev=cur;\\n                cur=cur->next;\\n                x--;\\n            }\\n            count-=grpNo;\\n            grpNo++;\\n            if(cur && grpNo<=count){\\n                ListNode *nxt;\\n                x=grpNo;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n                prev=cur;\\n                cur=cur->next;\\n                count-=grpNo;\\n                grpNo++;\\n            }\\n            else\\n                break;\\n        }\\n        if(count && count%2==0){\\n            ListNode *nxt;\\n                int x=count;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *cur=head,*prev=NULL;\\n        int count=0;\\n        while(cur){\\n            count++;\\n            cur=cur->next;\\n        }\\n        cur=head;\\n        int grpNo=1;\\n        while(cur && grpNo<=count){\\n            int x=grpNo;\\n            while(cur && x){\\n                prev=cur;\\n                cur=cur->next;\\n                x--;\\n            }\\n            count-=grpNo;\\n            grpNo++;\\n            if(cur && grpNo<=count){\\n                ListNode *nxt;\\n                x=grpNo;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n                prev=cur;\\n                cur=cur->next;\\n                count-=grpNo;\\n                grpNo++;\\n            }\\n            else\\n                break;\\n        }\\n        if(count && count%2==0){\\n            ListNode *nxt;\\n                int x=count;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143164,
                "title": "o-n-java-solutions-beats-97",
                "content": "# Approach\\nUse sliding window idea by keeping track of last node (of previous group), left node (of current group), pointer node (traverse list), groupSize, count of nodes in current group.\\n\\nOnce you start iterating, you will have to reverse current group if it meets the 2 conditions.\\n1. Count == groupSize\\n2. groupSize is even\\n\\nYou reverse and connect the reversed list back to your main list. Then you must update your iteration pointer since it will be in the back of the reversed list.\\n\\nAlso update last seen node (of previous group), new left node, count, and groupsize.\\n\\nDo the same reverse for the remaining nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(N): One iteration of list is done.\\n\\n- Space complexity:\\nO(1): Constant # of variables/pointers\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int groupSize = 1;\\n        int count = 0;\\n        ListNode left = null;\\n        ListNode ptr = head;\\n        ListNode last = null;\\n        \\n        while(ptr != null) {\\n            count++;\\n            if(count == groupSize) {\\n                if(groupSize  % 2 == 0) {\\n                    ListNode end = ptr.next;\\n                   // reverse\\n                    ListNode cur = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n                    while(cur != end) {\\n                        next = cur.next;\\n                        cur.next = prev;\\n                        prev = cur;\\n                        cur = next;\\n                    }\\n                    // connect\\n                    last.next = prev;\\n                    ptr = left;\\n                   \\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                count = 0;\\n                groupSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(count > 0 && count % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int groupSize = 1;\\n        int count = 0;\\n        ListNode left = null;\\n        ListNode ptr = head;\\n        ListNode last = null;\\n        \\n        while(ptr != null) {\\n            count++;\\n            if(count == groupSize) {\\n                if(groupSize  % 2 == 0) {\\n                    ListNode end = ptr.next;\\n                   // reverse\\n                    ListNode cur = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n                    while(cur != end) {\\n                        next = cur.next;\\n                        cur.next = prev;\\n                        prev = cur;\\n                        cur = next;\\n                    }\\n                    // connect\\n                    last.next = prev;\\n                    ptr = left;\\n                   \\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                count = 0;\\n                groupSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(count > 0 && count % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849465,
                "title": "python-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        gr = 1\\n        stack = []\\n\\n        node = head\\n\\n        while(node):\\n            stack = []\\n\\n            temp = node\\n\\n            for _ in range(gr):\\n\\n                if temp == None:\\n                    break\\n\\n                stack.append(temp.val)\\n                temp = temp.next\\n\\n            if len(stack)%2 == 0:\\n                while(stack):\\n                    node.val = stack.pop()\\n                    node = node.next\\n            else:\\n                for _ in range(gr):\\n                    if node == None:\\n                        break\\n\\n                    node = node.next\\n\\n            gr += 1\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        gr = 1\\n        stack = []\\n\\n        node = head\\n\\n        while(node):\\n            stack = []\\n\\n            temp = node\\n\\n            for _ in range(gr):\\n\\n                if temp == None:\\n                    break\\n\\n                stack.append(temp.val)\\n                temp = temp.next\\n\\n            if len(stack)%2 == 0:\\n                while(stack):\\n                    node.val = stack.pop()\\n                    node = node.next\\n            else:\\n                for _ in range(gr):\\n                    if node == None:\\n                        break\\n\\n                    node = node.next\\n\\n            gr += 1\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809531,
                "title": "java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prev = dummy;\\n        int groupSize = 1;\\n        while(prev.next != null) {\\n            ListNode curr = prev;\\n            int count = 0;\\n            for(int i = 0; i < groupSize && curr.next != null; ++i) {\\n                curr = curr.next;\\n                count += 1;\\n            }\\n            \\n            if(count % 2 == 0) {\\n                ListNode nextGroupHead = curr.next;\\n                curr.next = null;\\n                \\n                ListNode groupHead = prev.next;\\n                prev.next = reverseList(groupHead);\\n                groupHead.next = nextGroupHead;\\n                prev = groupHead;\\n            } else {\\n                prev = curr;\\n            }\\n            \\n            groupSize += 1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    private ListNode reverseList(ListNode node) {\\n        ListNode prev = null;\\n        while(node != null) {\\n            ListNode next = node.next;\\n            node.next = prev;\\n            prev = node;\\n            node = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prev = dummy;\\n        int groupSize = 1;\\n        while(prev.next != null) {\\n            ListNode curr = prev;\\n            int count = 0;\\n            for(int i = 0; i < groupSize && curr.next != null; ++i) {\\n                curr = curr.next;\\n                count += 1;\\n            }\\n            \\n            if(count % 2 == 0) {\\n                ListNode nextGroupHead = curr.next;\\n                curr.next = null;\\n                \\n                ListNode groupHead = prev.next;\\n                prev.next = reverseList(groupHead);\\n                groupHead.next = nextGroupHead;\\n                prev = groupHead;\\n            } else {\\n                prev = curr;\\n            }\\n            \\n            groupSize += 1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    private ListNode reverseList(ListNode node) {\\n        ListNode prev = null;\\n        while(node != null) {\\n            ListNode next = node.next;\\n            node.next = prev;\\n            prev = node;\\n            node = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782454,
                "title": "java-concise",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n// 12:29\\n\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n        \\n        int groupSize = 1;\\n        ListNode current = head, lastOfGroup = new ListNode(-1);\\n\\n        while(current != null) {\\n            ListNode start = current, last = null, temp = current;\\n            int size = 0;\\n            while(size < groupSize && temp != null) {\\n                temp = temp.next;\\n                size++;\\n            }\\n        \\n            if (size % 2 == 0) {\\n                lastOfGroup.next = reverse(start, temp);\\n                lastOfGroup = start;\\n                current = temp;\\n            } else {\\n                current = start;\\n                for(int j = 1; j <= groupSize; j++) {\\n                    if (current != null) {\\n                        lastOfGroup.next = current; \\n                        current = current.next;\\n                        lastOfGroup = lastOfGroup.next;\\n                    }\\n                }\\n            }\\n            groupSize++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail) {\\n        ListNode current = head, prev = null, next = null;\\n        while(current != tail) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n// 12:29\\n\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n        \\n        int groupSize = 1;\\n        ListNode current = head, lastOfGroup = new ListNode(-1);\\n\\n        while(current != null) {\\n            ListNode start = current, last = null, temp = current;\\n            int size = 0;\\n            while(size < groupSize && temp != null) {\\n                temp = temp.next;\\n                size++;\\n            }\\n        \\n            if (size % 2 == 0) {\\n                lastOfGroup.next = reverse(start, temp);\\n                lastOfGroup = start;\\n                current = temp;\\n            } else {\\n                current = start;\\n                for(int j = 1; j <= groupSize; j++) {\\n                    if (current != null) {\\n                        lastOfGroup.next = current; \\n                        current = current.next;\\n                        lastOfGroup = lastOfGroup.next;\\n                    }\\n                }\\n            }\\n            groupSize++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail) {\\n        ListNode current = head, prev = null, next = null;\\n        while(current != tail) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598790,
                "title": "c-solution",
                "content": "```\\nListNode* reverse(ListNode* head,int k)\\n    {\\n        if(!head or !head->next) return head;\\n        //useful in finding len and in odd case\\n        ListNode* cur = head, *tail = head;\\n        int len = 0;\\n        //finding length of every segment each time\\n        while(cur && len < k) {\\n            tail = cur;\\n            cur = cur->next;\\n            len++;\\n        }\\n        // cout<<len<<\" \";\\n        if(len%2==0)\\n        {\\n            int cnt=len;\\n            ListNode* prev=nullptr,*cur=head,*n;\\n            while(cur and cnt--)\\n            {\\n                n=cur->next;\\n                cur->next=prev;\\n                prev=cur;\\n                cur=n;\\n            }\\n            \\n            head->next=reverse(n,len+1);\\n            return prev;\\n        }\\n        tail->next=reverse(cur,len+1);\\n        return head;        \\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head or !head->next) return head;\\n        return reverse(head,1);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nListNode* reverse(ListNode* head,int k)\\n    {\\n        if(!head or !head->next) return head;\\n        //useful in finding len and in odd case\\n        ListNode* cur = head, *tail = head;\\n        int len = 0;\\n        //finding length of every segment each time\\n        while(cur && len < k) {\\n            tail = cur;\\n            cur = cur->next;\\n            len++;\\n        }\\n        // cout<<len<<\" \";\\n        if(len%2==0)\\n        {\\n            int cnt=len;\\n            ListNode* prev=nullptr,*cur=head,*n;\\n            while(cur and cnt--)\\n            {\\n                n=cur->next;\\n                cur->next=prev;\\n                prev=cur;\\n                cur=n;\\n            }\\n            \\n            head->next=reverse(n,len+1);\\n            return prev;\\n        }\\n        tail->next=reverse(cur,len+1);\\n        return head;        \\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head or !head->next) return head;\\n        return reverse(head,1);\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2495340,
                "title": "python-easy-to-catch-o-n",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head.next == None:\\n            return head\\n        last: Optional[ListNode] = head\\n        first: Optional[ListNode] = head\\n        prev: Optional[ListNode] = head\\n        lastprev: Optional[ListNode] = head\\n        group: int = 1\\n        length: int = 1\\n            \\n        while last:\\n            # length += 1\\n            if length == group:\\n                if length%2==0:\\n                    prev.next = last\\n                    nextG = last.next\\n                    prev = self.reverse(first,last)\\n                    prev.next = nextG\\n                    last = nextG   \\n                    first = nextG\\n                    group += 1\\n                    length = 1\\n                    continue\\n                \\n                first = last.next\\n                prev = last\\n                group += 1\\n                length = 1\\n                last = last.next\\n                continue\\n            length += 1\\n            lastprev = last\\n            last = last.next\\n            \\n        if (length - 1) != 0 and (length - 1)%2==0:\\n            prev.next = lastprev\\n            self.reverse(first,lastprev).next = last\\n        return head\\n        \\n    def reverse(self,first: Optional[ListNode],last: Optional[ListNode]):\\n        \\n        # to reverse\\n        prev: Optional[ListNode] = None\\n        current: Optional[ListNode] = first\\n        last: Optional[ListNode] = last.next\\n        temp: Optional[ListNode]\\n            \\n        while (current != last):\\n            temp = current.next\\n            current.next = prev\\n            prev = current\\n            current = temp\\n        \\n        return first\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head.next == None:\\n            return head\\n        last: Optional[ListNode] = head\\n        first: Optional[ListNode] = head\\n        prev: Optional[ListNode] = head\\n        lastprev: Optional[ListNode] = head\\n        group: int = 1\\n        length: int = 1\\n            \\n        while last:\\n            # length += 1\\n            if length == group:\\n                if length%2==0:\\n                    prev.next = last\\n                    nextG = last.next\\n                    prev = self.reverse(first,last)\\n                    prev.next = nextG\\n                    last = nextG   \\n                    first = nextG\\n                    group += 1\\n                    length = 1\\n                    continue\\n                \\n                first = last.next\\n                prev = last\\n                group += 1\\n                length = 1\\n                last = last.next\\n                continue\\n            length += 1\\n            lastprev = last\\n            last = last.next\\n            \\n        if (length - 1) != 0 and (length - 1)%2==0:\\n            prev.next = lastprev\\n            self.reverse(first,lastprev).next = last\\n        return head\\n        \\n    def reverse(self,first: Optional[ListNode],last: Optional[ListNode]):\\n        \\n        # to reverse\\n        prev: Optional[ListNode] = None\\n        current: Optional[ListNode] = first\\n        last: Optional[ListNode] = last.next\\n        temp: Optional[ListNode]\\n            \\n        while (current != last):\\n            temp = current.next\\n            current.next = prev\\n            prev = current\\n            current = temp\\n        \\n        return first\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494303,
                "title": "python-o-n-01-easy",
                "content": "```\\n  \\nclass Solution:\\n  def length(self,head):\\n    fast= head \\n    count=0\\n    while fast and fast.next:\\n      fast = fast.next.next \\n      count+=2\\n    if fast:\\n      return count+1 \\n    return count \\n  \\n  def reverseEvenLengthGroups(self ,\\n  head):\\n    size = self.length(head)\\n    temp = head \\n    res = None\\n    updater = res \\n    even = False \\n    k = 1\\n    \\n    while (size>=k) or (size<k and size%2==0 and size>1):\\n     \\n      cond = size<k and size%2==0\\n      if (not even) and (not cond):\\n        curr = temp\\n        i = 1 \\n        while i <= k:\\n          if res==None:\\n            res = curr \\n            updater = res \\n          else:\\n            updater.next = curr \\n            updater = curr\\n          curr = curr.next\\n          i = i+1 \\n        temp = curr\\n      \\n     \\n      if even or cond:\\n        if size<k:\\n          k = size\\n        i = 1\\n        curr = temp.next\\n        prev = temp \\n        next_updater = prev \\n        while i  < k:\\n          next = curr.next\\n          curr.next = prev\\n          prev = curr \\n          curr = next \\n          i+=1\\n        \\n        updater.next = prev \\n        updater = next_updater\\n        temp = curr \\n        \\n      even = not even\\n      size -=k\\n      k+=1 \\n    \\n    updater.next = temp \\n    return res \\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n  \\nclass Solution:\\n  def length(self,head):\\n    fast= head \\n    count=0\\n    while fast and fast.next:\\n      fast = fast.next.next \\n      count+=2\\n    if fast:\\n      return count+1 \\n    return count \\n  \\n  def reverseEvenLengthGroups(self ,\\n  head):\\n    size = self.length(head)\\n    temp = head \\n    res = None\\n    updater = res \\n    even = False \\n    k = 1\\n    \\n    while (size>=k) or (size<k and size%2==0 and size>1):\\n     \\n      cond = size<k and size%2==0\\n      if (not even) and (not cond):\\n        curr = temp\\n        i = 1 \\n        while i <= k:\\n          if res==None:\\n            res = curr \\n            updater = res \\n          else:\\n            updater.next = curr \\n            updater = curr\\n          curr = curr.next\\n          i = i+1 \\n        temp = curr\\n      \\n     \\n      if even or cond:\\n        if size<k:\\n          k = size\\n        i = 1\\n        curr = temp.next\\n        prev = temp \\n        next_updater = prev \\n        while i  < k:\\n          next = curr.next\\n          curr.next = prev\\n          prev = curr \\n          curr = next \\n          i+=1\\n        \\n        updater.next = prev \\n        updater = next_updater\\n        temp = curr \\n        \\n      even = not even\\n      size -=k\\n      k+=1 \\n    \\n    updater.next = temp \\n    return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250551,
                "title": "most-straightforward-solution-with-comments",
                "content": "\\nclass Solution {\\npublic:\\n\\t\\n\\t// Reverse function to reverse the even length parts of linked list, and returns\\n\\t// the new head and tail of reversed linked list\\n    pair<ListNode*,ListNode*> reverse(ListNode *head)\\n    {\\n        pair<ListNode*,ListNode*>ans;\\n        ans.second = head;\\n        \\n        ListNode *p = head,*q = NULL,*r = NULL;\\n        \\n        while(p)\\n        {\\n            r = q;\\n            q = p;\\n            p = p->next;\\n            q->next = r;\\n        }\\n        head = q;\\n        ans.first = head;\\n        \\n        return ans;\\n    }\\n    \\n    ListNode *helper(ListNode *head,int k)\\n    {\\n         if(head == NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        ListNode *p = head,*q = head;\\n        ListNode *nhead = NULL,*ntail = NULL;\\n        int i = 1;\\n        \\n        while(q && i < k)\\n        {\\n            q = q->next;\\n            i++;\\n        }\\n        \\n        ListNode *nextHead = NULL;\\n        if(q)\\n        {\\n            nextHead = q->next;\\n            q->next = NULL;\\n        }\\n        \\n\\t\\t// important condition for reverse -> \\n\\t\\t// i) k is even (even length portion) and q!=NULL to ensure that this portion is not\\n\\t\\t// the last portion , (as last portion may have incomplete nodes)\\n\\t\\t\\n\\t\\t// ii) If k is not even but the last portion has even no. of nodes\\n\\t\\t// (i-1)%2 == 0 for even no. of nodes, i is increased +1 more before exit so -1 is done\\n\\t\\t// and q == NULL to ensure that this is the incomplete nodes portion the last portion\\n\\n        if((k%2 == 0 && q!=NULL)) || (q == NULL && (i-1)%2 == 0))\\n        {\\n            pair<ListNode*,ListNode*> ans = reverse(p);\\n            nhead = ans.first;\\n            ntail = ans.second; \\n        }\\n        else\\n        {\\n            nhead = p;\\n            ntail = q;\\n        }\\n        \\n        if(ntail)\\n        {\\n            ntail->next = helper(nextHead,k+1);\\n\\t\\t\\t// k+1 for next portion\\n        }\\n        \\n        return nhead;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head == NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        return helper(head,1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\t\\n\\t// Reverse function to reverse the even length parts of linked list, and returns\\n\\t// the new head and tail of reversed linked list\\n    pair<ListNode*,ListNode*> reverse(ListNode *head)\\n    {\\n        pair<ListNode*,ListNode*>ans;\\n        ans.second = head;\\n        \\n        ListNode *p = head,*q = NULL,*r = NULL;\\n        \\n        while(p)\\n        {\\n            r = q;\\n            q = p;\\n            p = p->next;\\n            q->next = r;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2234029,
                "title": "c-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        ListNode* tmp = NULL;\\n        ListNode* trav = head;\\n        ListNode *flag = head->next;\\n        \\n        while(trav != NULL)\\n        {\\n            trav->next = tmp;\\n            tmp = trav;\\n            trav = flag;\\n            if(flag != NULL) flag = flag->next;\\n        }\\n        \\n        return tmp;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        \\n        int len = 1, temp;\\n        vector<ListNode*> v;\\n        ListNode* trav = head;\\n        ListNode* tmp = NULL;\\n        int count = 0;\\n        \\n        while(trav != NULL)\\n        {\\n            v.push_back(trav);\\n            temp = len;\\n            for(int i=0; i<temp-1; i++)\\n            {\\n                if(trav == NULL) break;\\n                trav = trav->next;\\n            }\\n            if(trav != NULL)\\n            {\\n                tmp = trav->next;\\n                trav->next = NULL;\\n                trav = tmp;\\n                len++;\\n            }\\n            \\n        }\\n        \\n        for(int i=1; i<v.size()-1; i++)\\n        {\\n            v[i] = reverse(v[i]);\\n            i++; \\n        }\\n                \\n        for(int i=0; i<v.size()-1; i++)\\n        {\\n            trav = v[i];\\n            while(trav->next != NULL)\\n            {\\n                trav = trav->next;\\n            }\\n            if(i != v.size()-2) trav->next = v[i+1];\\n        }\\n        \\n        tmp = trav;\\n        \\n        trav = v[v.size()-1];\\n        while(trav != NULL)\\n        {\\n            trav = trav->next;\\n            count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n        {\\n            v[v.size()-1] = reverse(v[v.size()-1]);\\n        }\\n        \\n        tmp->next = v[v.size()-1];\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        ListNode* tmp = NULL;\\n        ListNode* trav = head;\\n        ListNode *flag = head->next;\\n        \\n        while(trav != NULL)\\n        {\\n            trav->next = tmp;\\n            tmp = trav;\\n            trav = flag;\\n            if(flag != NULL) flag = flag->next;\\n        }\\n        \\n        return tmp;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        \\n        int len = 1, temp;\\n        vector<ListNode*> v;\\n        ListNode* trav = head;\\n        ListNode* tmp = NULL;\\n        int count = 0;\\n        \\n        while(trav != NULL)\\n        {\\n            v.push_back(trav);\\n            temp = len;\\n            for(int i=0; i<temp-1; i++)\\n            {\\n                if(trav == NULL) break;\\n                trav = trav->next;\\n            }\\n            if(trav != NULL)\\n            {\\n                tmp = trav->next;\\n                trav->next = NULL;\\n                trav = tmp;\\n                len++;\\n            }\\n            \\n        }\\n        \\n        for(int i=1; i<v.size()-1; i++)\\n        {\\n            v[i] = reverse(v[i]);\\n            i++; \\n        }\\n                \\n        for(int i=0; i<v.size()-1; i++)\\n        {\\n            trav = v[i];\\n            while(trav->next != NULL)\\n            {\\n                trav = trav->next;\\n            }\\n            if(i != v.size()-2) trav->next = v[i+1];\\n        }\\n        \\n        tmp = trav;\\n        \\n        trav = v[v.size()-1];\\n        while(trav != NULL)\\n        {\\n            trav = trav->next;\\n            count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n        {\\n            v[v.size()-1] = reverse(v[v.size()-1]);\\n        }\\n        \\n        tmp->next = v[v.size()-1];\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118503,
                "title": "trick-to-solve-it-very-easily",
                "content": "```\\n// This Question can be solved easily using two standard methods of LinkedList\\n// 1) addFirst (it adds node in front of the LinkedList)\\n// 2) addLast (it adds node in end of the LinkedList)\\n\\nclass Solution {\\n    \\n    static ListNode oh;\\n    static ListNode ot;\\n    static ListNode th;\\n    static ListNode tt;\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        oh = null;\\n        ot = null;\\n        th = null;\\n        tt = null;\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        int size = length(head);\\n        int idx = 1;\\n        ListNode curr = head;\\n        int group = 1;\\n        \\n        while(curr!=null)\\n        {\\n            int temp = size - idx + 1;\\n            if((temp>=group && group%2 == 0) || (temp<group && temp%2 == 0))\\n            {\\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addFirst(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            else\\n            { \\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addLast(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            \\n            if(oh==null && ot==null)\\n            {\\n                oh = th;\\n                ot = tt;\\n            }\\n            else\\n            {\\n                ot.next = th;\\n                ot = tt;\\n            }\\n            \\n            th = null;\\n            tt = null;\\n            group++;\\n        }\\n        \\n        return oh;\\n    }\\n    \\n    public int length (ListNode head)\\n    {\\n        if(head==null) return 0;\\n        ListNode curr = head;\\n        int k = 0;\\n        while(curr!=null)\\n        {\\n             k++;\\n            curr = curr.next;\\n        }\\n        return k;\\n    }\\n    \\n    public void addFirst(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            head.next = th;\\n            th = head;\\n        }\\n    }\\n    \\n    public void addLast(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            tt.next = head;\\n            tt = head;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// This Question can be solved easily using two standard methods of LinkedList\\n// 1) addFirst (it adds node in front of the LinkedList)\\n// 2) addLast (it adds node in end of the LinkedList)\\n\\nclass Solution {\\n    \\n    static ListNode oh;\\n    static ListNode ot;\\n    static ListNode th;\\n    static ListNode tt;\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        oh = null;\\n        ot = null;\\n        th = null;\\n        tt = null;\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        int size = length(head);\\n        int idx = 1;\\n        ListNode curr = head;\\n        int group = 1;\\n        \\n        while(curr!=null)\\n        {\\n            int temp = size - idx + 1;\\n            if((temp>=group && group%2 == 0) || (temp<group && temp%2 == 0))\\n            {\\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addFirst(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            else\\n            { \\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addLast(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            \\n            if(oh==null && ot==null)\\n            {\\n                oh = th;\\n                ot = tt;\\n            }\\n            else\\n            {\\n                ot.next = th;\\n                ot = tt;\\n            }\\n            \\n            th = null;\\n            tt = null;\\n            group++;\\n        }\\n        \\n        return oh;\\n    }\\n    \\n    public int length (ListNode head)\\n    {\\n        if(head==null) return 0;\\n        ListNode curr = head;\\n        int k = 0;\\n        while(curr!=null)\\n        {\\n             k++;\\n            curr = curr.next;\\n        }\\n        return k;\\n    }\\n    \\n    public void addFirst(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            head.next = th;\\n            th = head;\\n        }\\n    }\\n    \\n    public void addLast(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            tt.next = head;\\n            tt = head;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102638,
                "title": "c-solution",
                "content": "Approach: **T.C -> O(n), S.C -> O(1)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = nullptr, *next = nullptr, *curr = head;\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len <= 1e5 && head; len++) {\\n            // len denotes the max length of a current group\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determine the length of the current group\\n            int j = 1;\\n            while(j < len and tail and tail->next) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            nextHead = tail->next;\\n            \\n            if(j % 2 == 0) {\\n                \\n                // isolate and reverse the group\\n                tail->next = nullptr;\\n                prev->next = reverseList(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            \\n            else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = nullptr, *next = nullptr, *curr = head;\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len <= 1e5 && head; len++) {\\n            // len denotes the max length of a current group\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determine the length of the current group\\n            int j = 1;\\n            while(j < len and tail and tail->next) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            nextHead = tail->next;\\n            \\n            if(j % 2 == 0) {\\n                \\n                // isolate and reverse the group\\n                tail->next = nullptr;\\n                prev->next = reverseList(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            \\n            else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084250,
                "title": "brute-force-cpp",
                "content": "```\\n ListNode* curr=head;\\n        vector<int>v;\\n        while(curr!=NULL)\\n        {\\n            v.push_back(curr->val);\\n            curr=curr->next;\\n        }\\n        int n=v.size();\\n        int k=1,i=0;\\n        while(n>1)\\n        {\\n            if(k==1)\\n            {\\n                n-=1;\\n                k++;\\n                i++;\\n            }\\n            if(k%2==0&&n>=k)\\n            {\\n                n-=k;\\n                reverse(v.begin()+i,v.begin()+i+k);\\n                i+=k;\\n                k++;\\n            }\\n            else if(k%2!=0&&n>=k)\\n            {\\n                n-=k;\\n                i+=k;\\n                k++;\\n            }\\n            else if(n<k&&n%2==0)\\n            {\\n                reverse(v.begin()+i,v.end());\\n                n-=k;\\n            }\\n            else\\n                break;\\n            \\n        }\\n        \\n        ListNode* res=new ListNode(0);\\n        ListNode* a=res;\\n        for(auto x:v)\\n        {\\n            a->next=new ListNode(x);\\n            a=a->next;\\n        }\\n        return res->next;\\n```",
                "solutionTags": [],
                "code": "```\\n ListNode* curr=head;\\n        vector<int>v;\\n        while(curr!=NULL)\\n        {\\n            v.push_back(curr->val);\\n            curr=curr->next;\\n        }\\n        int n=v.size();\\n        int k=1,i=0;\\n        while(n>1)\\n        {\\n            if(k==1)\\n            {\\n                n-=1;\\n                k++;\\n                i++;\\n            }\\n            if(k%2==0&&n>=k)\\n            {\\n                n-=k;\\n                reverse(v.begin()+i,v.begin()+i+k);\\n                i+=k;\\n                k++;\\n            }\\n            else if(k%2!=0&&n>=k)\\n            {\\n                n-=k;\\n                i+=k;\\n                k++;\\n            }\\n            else if(n<k&&n%2==0)\\n            {\\n                reverse(v.begin()+i,v.end());\\n                n-=k;\\n            }\\n            else\\n                break;\\n            \\n        }\\n        \\n        ListNode* res=new ListNode(0);\\n        ListNode* a=res;\\n        for(auto x:v)\\n        {\\n            a->next=new ListNode(x);\\n            a=a->next;\\n        }\\n        return res->next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925750,
                "title": "c-easy-stack-solution",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\t\\t\\tListNode* root = head->next;\\n\\t\\t\\tfor(int i = 2; root; i++){\\n\\t\\t\\t\\t\\tstack<int>s; \\n\\t\\t\\t\\t\\tListNode* tmp = root;\\n\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\twhile(cnt!=i and tmp) cnt++,s.push(tmp->val),tmp = tmp->next; \\n\\t\\t\\t\\t\\tif((i%2==0 and cnt==i) or (cnt%2==0 and !tmp)){\\n\\t\\t\\t\\t\\t\\twhile(cnt--){\\n\\t\\t\\t\\t\\t\\t\\troot->val = s.top();s.pop(); root = root->next;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse root = tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\t\\t\\tListNode* root = head->next;\\n\\t\\t\\tfor(int i = 2; root; i++){\\n\\t\\t\\t\\t\\tstack<int>s; \\n\\t\\t\\t\\t\\tListNode* tmp = root;\\n\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\twhile(cnt!=i and tmp) cnt++,s.push(tmp->val),tmp = tmp->next; \\n\\t\\t\\t\\t\\tif((i%2==0 and cnt==i) or (cnt%2==0 and !tmp)){\\n\\t\\t\\t\\t\\t\\twhile(cnt--){\\n\\t\\t\\t\\t\\t\\t\\troot->val = s.top();s.pop(); root = root->next;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1822855,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *helper(ListNode *head,int reqLen,ListNode *parent) {\\n        if(!head || !head->next) {\\n            return head;\\n        }\\n        int count=1;\\n        ListNode *tmp=head;\\n        while(count<reqLen && tmp) {\\n            tmp=tmp->next;\\n            count++;\\n        }\\n        if(!tmp) {\\n            count--;\\n        }\\n        if(count%2==0) {\\n            ListNode *later=NULL,*curr=head,*prev=NULL,*target=tmp?tmp->next:NULL;\\n            if(parent) {\\n                parent->next=NULL;\\n            }\\n            while(curr!=target) {\\n                later=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=later;\\n            }\\n            if(parent) {\\n                parent->next=prev;\\n            }\\n            head->next=target?helper(target,reqLen+1,head):head->next;\\n            return prev;\\n        }\\n        else {\\n            if(parent) {\\n                parent->next=head;\\n            }\\n            if(tmp) {\\n                tmp->next=helper(tmp->next,reqLen+1,tmp);\\n            }\\n            return head;\\n        }\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return helper(head,1,NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *helper(ListNode *head,int reqLen,ListNode *parent) {\\n        if(!head || !head->next) {\\n            return head;\\n        }\\n        int count=1;\\n        ListNode *tmp=head;\\n        while(count<reqLen && tmp) {\\n            tmp=tmp->next;\\n            count++;\\n        }\\n        if(!tmp) {\\n            count--;\\n        }\\n        if(count%2==0) {\\n            ListNode *later=NULL,*curr=head,*prev=NULL,*target=tmp?tmp->next:NULL;\\n            if(parent) {\\n                parent->next=NULL;\\n            }\\n            while(curr!=target) {\\n                later=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=later;\\n            }\\n            if(parent) {\\n                parent->next=prev;\\n            }\\n            head->next=target?helper(target,reqLen+1,head):head->next;\\n            return prev;\\n        }\\n        else {\\n            if(parent) {\\n                parent->next=head;\\n            }\\n            if(tmp) {\\n                tmp->next=helper(tmp->next,reqLen+1,tmp);\\n            }\\n            return head;\\n        }\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return helper(head,1,NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789918,
                "title": "lc-2074-reverse-nodes-in-even-length-groups-simple-python-maps-iteration",
                "content": "```\\n\\'\\'\\'\\nProblem: LC 2074 - Reverse Nodes in Even Length Groups\\nAuthor: Anando Zaman\\nDifficulty: Medium\\nDate: February 21, 2022\\n\\nNotes:\\nNodes are grouped based on their positions.\\nSo first node is group 1\\nNext two nodes are group 2\\nNext three nodes are group 3\\nNext four nodes are group 4.\\n\\nWe only want to reverse the groups that have even lengths\\nand return head of modified linkedList\\n\\nNOTE:\\nLength of the last group may be less than or equal to 1 + the length of the second to last group.\\n\\n\\nSOLUTION:\\nCreate three helper functions that takes the next node and a length:\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next sublist\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next reversed sublist\\n    - nextValidSubListSize: Returns the max size of the grouping possible\\n\\nUse a local variable to track the desired length of each grouping.\\nWe use the nextValidSubListSize function to determine if that length is possible, if not, return the number of nodes it supports.\\n\\nDepending on whether that result is odd or even, we return the reversed/non-reversed result\\nas a mapping of \\'head\\' and \\'last\\' nodes.\\n\\nUpdate our curr.next to point to the returned sublist, then continue reversing the next group\\nnodes starting at last.next node.\\n\\'\\'\\'\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        def nextValidSubListSize(head: ListNode, len_: int):\\n            \\n            node_cnt = 0\\n            while head and node_cnt < len_:\\n                head = head.next\\n                node_cnt += 1\\n                \\n            return node_cnt\\n            \\n        \\n        def NextHeadAndLastNodes_Reversed(head: ListNode, len_: int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            last = head\\n            prev, curr = None, head\\n            \\n            while (len_ > 0 and curr):\\n                temp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = temp\\n                len_ -= 1\\n                \\n            new_head = prev\\n            last.next = curr # linkage needed so that we can reference next grouping\\n            return {\\'head\\':new_head, \\'last\\':last}\\n        \\n        def NextHeadAndLastNodes(head: ListNode, len_:int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            prev = None\\n            curr = head\\n            while curr and len_ > 0:\\n                prev = curr\\n                curr = curr.next\\n                len_ -= 1\\n                \\n            return {\\'head\\':head, \\'last\\':prev}\\n        \\n        # MAIN EXECUTION\\n        nodes_len = 1\\n        curr = head\\n        while curr:\\n            nodes_len += 1\\n            nodes_size_avail =  nextValidSubListSize(curr.next, nodes_len)\\n            \\n            NextHeadLastMap = {}\\n            if nodes_size_avail % 2 == 0:\\n                NextHeadLastMap = NextHeadAndLastNodes_Reversed(curr.next, nodes_len)\\n            else:\\n                NextHeadLastMap = NextHeadAndLastNodes(curr.next, nodes_len)\\n            \\n            curr.next = NextHeadLastMap[\\'head\\']\\n            curr = NextHeadLastMap[\\'last\\']\\n            \\n        return head\\n        \\n        \\n                \\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\'\\'\\'\\nProblem: LC 2074 - Reverse Nodes in Even Length Groups\\nAuthor: Anando Zaman\\nDifficulty: Medium\\nDate: February 21, 2022\\n\\nNotes:\\nNodes are grouped based on their positions.\\nSo first node is group 1\\nNext two nodes are group 2\\nNext three nodes are group 3\\nNext four nodes are group 4.\\n\\nWe only want to reverse the groups that have even lengths\\nand return head of modified linkedList\\n\\nNOTE:\\nLength of the last group may be less than or equal to 1 + the length of the second to last group.\\n\\n\\nSOLUTION:\\nCreate three helper functions that takes the next node and a length:\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next sublist\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next reversed sublist\\n    - nextValidSubListSize: Returns the max size of the grouping possible\\n\\nUse a local variable to track the desired length of each grouping.\\nWe use the nextValidSubListSize function to determine if that length is possible, if not, return the number of nodes it supports.\\n\\nDepending on whether that result is odd or even, we return the reversed/non-reversed result\\nas a mapping of \\'head\\' and \\'last\\' nodes.\\n\\nUpdate our curr.next to point to the returned sublist, then continue reversing the next group\\nnodes starting at last.next node.\\n\\'\\'\\'\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        def nextValidSubListSize(head: ListNode, len_: int):\\n            \\n            node_cnt = 0\\n            while head and node_cnt < len_:\\n                head = head.next\\n                node_cnt += 1\\n                \\n            return node_cnt\\n            \\n        \\n        def NextHeadAndLastNodes_Reversed(head: ListNode, len_: int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            last = head\\n            prev, curr = None, head\\n            \\n            while (len_ > 0 and curr):\\n                temp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = temp\\n                len_ -= 1\\n                \\n            new_head = prev\\n            last.next = curr # linkage needed so that we can reference next grouping\\n            return {\\'head\\':new_head, \\'last\\':last}\\n        \\n        def NextHeadAndLastNodes(head: ListNode, len_:int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            prev = None\\n            curr = head\\n            while curr and len_ > 0:\\n                prev = curr\\n                curr = curr.next\\n                len_ -= 1\\n                \\n            return {\\'head\\':head, \\'last\\':prev}\\n        \\n        # MAIN EXECUTION\\n        nodes_len = 1\\n        curr = head\\n        while curr:\\n            nodes_len += 1\\n            nodes_size_avail =  nextValidSubListSize(curr.next, nodes_len)\\n            \\n            NextHeadLastMap = {}\\n            if nodes_size_avail % 2 == 0:\\n                NextHeadLastMap = NextHeadAndLastNodes_Reversed(curr.next, nodes_len)\\n            else:\\n                NextHeadLastMap = NextHeadAndLastNodes(curr.next, nodes_len)\\n            \\n            curr.next = NextHeadLastMap[\\'head\\']\\n            curr = NextHeadLastMap[\\'last\\']\\n            \\n        return head\\n        \\n        \\n                \\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776421,
                "title": "c-naive-approach-but-easy-to-understand",
                "content": "```\\n  int calculate(ListNode* head)\\n    {\\n        int count=0;\\n        while(head!=NULL)\\n        {\\n            count++;\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverse(ListNode* head,int len)\\n    {\\n        ListNode* curr=head;\\n        ListNode* prev=NULL,*next=NULL;\\n        while(curr!=NULL && len>0)\\n        {\\n             next=curr->next;\\n            ListNode* newTemp=new ListNode(curr->val);\\n             newTemp->next=prev;\\n            prev=newTemp;\\n            curr=curr->next;\\n            len--;\\n        }\\n        \\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int totalnodes=calculate(head);\\n        int i=1;\\n        ListNode* pseudonode=new ListNode(-1);\\n        ListNode* prev=pseudonode;\\n        while(i)\\n        {\\n            int remnodes=totalnodes-i;\\n            if(remnodes>0)\\n            {\\n                int val=i;\\n                prev->next=head;\\n                if(i%2==0)\\n                {\\n                    ListNode* newlist=reverse(head,i);\\n                    ListNode* temp=newlist;\\n                    while(temp!=NULL)\\n                    {\\n                        temp=temp->next;\\n                    }\\n                    prev->next=newlist;\\n                }\\n                 while(val>0 && head!=NULL)\\n                    {\\n                     val--;\\n                        prev=prev->next;\\n                        head=head->next;\\n                    }\\n            }\\n            else\\n            {\\n                if(totalnodes%2==0)\\n                {\\n                      ListNode* newlist=reverse(head,i);\\n                      prev->next=newlist;\\n                     return pseudonode->next;\\n                }\\n                else\\n                {\\n                    prev->next=head;\\n                    return pseudonode->next;\\n                }\\n            }\\n            totalnodes-=i; i++;\\n        }\\n        return pseudonode->next;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int calculate(ListNode* head)\\n    {\\n        int count=0;\\n        while(head!=NULL)\\n        {\\n            count++;\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverse(ListNode* head,int len)\\n    {\\n        ListNode* curr=head;\\n        ListNode* prev=NULL,*next=NULL;\\n        while(curr!=NULL && len>0)\\n        {\\n             next=curr->next;\\n            ListNode* newTemp=new ListNode(curr->val);\\n             newTemp->next=prev;\\n            prev=newTemp;\\n            curr=curr->next;\\n            len--;\\n        }\\n        \\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int totalnodes=calculate(head);\\n        int i=1;\\n        ListNode* pseudonode=new ListNode(-1);\\n        ListNode* prev=pseudonode;\\n        while(i)\\n        {\\n            int remnodes=totalnodes-i;\\n            if(remnodes>0)\\n            {\\n                int val=i;\\n                prev->next=head;\\n                if(i%2==0)\\n                {\\n                    ListNode* newlist=reverse(head,i);\\n                    ListNode* temp=newlist;\\n                    while(temp!=NULL)\\n                    {\\n                        temp=temp->next;\\n                    }\\n                    prev->next=newlist;\\n                }\\n                 while(val>0 && head!=NULL)\\n                    {\\n                     val--;\\n                        prev=prev->next;\\n                        head=head->next;\\n                    }\\n            }\\n            else\\n            {\\n                if(totalnodes%2==0)\\n                {\\n                      ListNode* newlist=reverse(head,i);\\n                      prev->next=newlist;\\n                     return pseudonode->next;\\n                }\\n                else\\n                {\\n                    prev->next=head;\\n                    return pseudonode->next;\\n                }\\n            }\\n            totalnodes-=i; i++;\\n        }\\n        return pseudonode->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732265,
                "title": "kotlin-easy-recursive",
                "content": "Shortly this solution uses backtracking reverse groups from last group\\n\\n```\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        return reverse(head, arrayOf(null), intArrayOf(1), 1)\\n    }\\n    \\n    private fun reverse(head: ListNode?, tail: Array<ListNode?>, k: IntArray, g: Int): ListNode? {\\n        if (head == null || head.next == null) return head\\n        if (k[0] == g) {\\n            tail[0] = reverse(head.next, tail, intArrayOf(1), g + 1)\\n            return head.apply { this.next = tail[0] }\\n        }\\n        val rest = reverse(head.next, tail, k.apply { this[0]++ }, g)\\n        if ((k[0] and 1) == 0) {\\n            head.next.next = head\\n            head.next = tail[0]  \\n            return rest\\n        }\\n        return head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        return reverse(head, arrayOf(null), intArrayOf(1), 1)\\n    }\\n    \\n    private fun reverse(head: ListNode?, tail: Array<ListNode?>, k: IntArray, g: Int): ListNode? {\\n        if (head == null || head.next == null) return head\\n        if (k[0] == g) {\\n            tail[0] = reverse(head.next, tail, intArrayOf(1), g + 1)\\n            return head.apply { this.next = tail[0] }\\n        }\\n        val rest = reverse(head.next, tail, k.apply { this[0]++ }, g)\\n        if ((k[0] and 1) == 0) {\\n            head.next.next = head\\n            head.next = tail[0]  \\n            return rest\\n        }\\n        return head\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697132,
                "title": "reverse-nodes-in-even-length-groups-o-n-faster-than-75-submission",
                "content": "\\tLogic is to maintain the window of even length list and reverse them .\\n...\\nListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL || head->next ==NULL )\\n            return head;\\n        \\n        ListNode* newhead = reverse(head->next);\\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newhead;\\n        \\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL)\\n            return head;\\n        \\n        ListNode* temp = head;\\n        ListNode* tempprev = head;\\n        ListNode* temphead = head;\\n        ListNode* tempheadprev = head;\\n        int k = 1;\\n        int tempk = k;\\n        bool isodd = true;\\n        int flag = 1;\\n        while(temp!=NULL)\\n        {\\n            if(isodd)\\n            {\\n                while(temp != NULL && k)\\n                {   \\n                    tempprev = temp;\\n                    temp = temp->next;\\n                    k--;\\n                    \\n                }\\n                if(k != 0 && ((tempk - k)%2) == 0)\\n                {   \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                temphead = temp;\\n                tempheadprev = tempprev;\\n                isodd = false;\\n                k = tempk + 1;\\n                tempk++;\\n            }\\n            else\\n            {\\n                while(temp != NULL && k)\\n                {\\n                    k--;\\n                    tempprev = temp;\\n                    temp = temp->next;\\n                }\\n                \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                if(k != 0 && (((tempk - k)%2) == 0))\\n                {   \\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                tempprev->next = NULL;\\n                ListNode* newhead = reverse(temphead);\\n                tempheadprev->next = newhead;\\n                temphead->next = temp;\\n                tempheadprev = temphead;\\n                temphead = temp;\\n                \\n                k = tempk + 1;\\n                tempk++;\\n                isodd = true;\\n            }\\n        }\\n        if(flag == 0)\\n        {   \\n            tempprev->next = NULL;\\n            ListNode* newhead = reverse(temphead);\\n            tempheadprev->next = newhead;\\n            temphead->next = temp;\\n        }\\n        return head;\\n    }\\n\\t...\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tLogic is to maintain the window of even length list and reverse them .\\n...\\nListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL || head->next ==NULL )\\n            return head;\\n        \\n        ListNode* newhead = reverse(head->next);\\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newhead;\\n        \\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL)\\n            return head;\\n        \\n        ListNode* temp = head;\\n        ListNode* tempprev = head;\\n        ListNode* temphead = head;\\n        ListNode* tempheadprev = head;\\n        int k = 1;\\n        int tempk = k;\\n        bool isodd = true;\\n        int flag = 1;\\n        while(temp!=NULL)\\n        {\\n            if(isodd)\\n            {\\n                while(temp != NULL && k)\\n                {   \\n                    tempprev = temp;\\n                    temp = temp->next;\\n                    k--;\\n                    \\n                }\\n                if(k != 0 && ((tempk - k)%2) == 0)\\n                {   \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                temphead = temp;\\n                tempheadprev = tempprev;\\n                isodd = false;\\n                k = tempk + 1;\\n                tempk++;\\n            }\\n            else\\n            {\\n                while(temp != NULL && k)\\n                {\\n                    k--;\\n                    tempprev = temp;\\n                    temp = temp->next;\\n                }\\n                \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                if(k != 0 && (((tempk - k)%2) == 0))\\n                {   \\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                tempprev->next = NULL;\\n                ListNode* newhead = reverse(temphead);\\n                tempheadprev->next = newhead;\\n                temphead->next = temp;\\n                tempheadprev = temphead;\\n                temphead = temp;\\n                \\n                k = tempk + 1;\\n                tempk++;\\n                isodd = true;\\n            }\\n        }\\n        if(flag == 0)\\n        {   \\n            tempprev->next = NULL;\\n            ListNode* newhead = reverse(temphead);\\n            tempheadprev->next = newhead;\\n            temphead->next = temp;\\n        }\\n        return head;\\n    }\\n\\t...\\n",
                "codeTag": "C++"
            },
            {
                "id": 1678290,
                "title": "java-solution-without-extra-space",
                "content": "This method has two helper functions.\\n\\n1) height  - to determine height of list (straightforward)\\n2) reverese - to reverse the group ( usual reverse function with little tweak by just pointing intial head to last element of the group.\\n\\nAlgo:\\n1) if your current number (count % 2 == 0) is even then do reverse else just move forward in the list.\\n2) On the each loop just decrement height by count and once the height becomes less than number,\\n   break loop in case if its even , if its odd just increment the number and continue with the loop because even will take care of it.\\n```    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        int count = 1;\\n        int height = height(head);\\n        while (head != null) {\\n            if (count%2 == 0) {\\n                if (height < count && height %2 == 1)\\n                    break;\\n                ListNode next = head.next;\\n                head.next = reverse(head.next, count);\\n                head = next;\\n                if (height < count)\\n                    break;\\n            }\\n            else {\\n                if (height < count) {\\n                    if (height %2 == 1)\\n                        break;\\n                    else {\\n                        count++;\\n                        continue;\\n                    }\\n                }\\n                int index = count;\\n                while (head != null && index-- > 0 && count !=1) \\n                    head = head.next;\\n            }\\n            height -= count;\\n            count++;\\n        }\\n        return temp;\\n    }\\n    public int height (ListNode head) {\\n        int height = 0;\\n        while (head != null) {\\n            head = head.next;\\n            height++;\\n        }\\n        return height;\\n    }\\n    \\n    public ListNode reverse(ListNode head, int count) {\\n        if (head == null)\\n            return head;\\n        ListNode pointer = head, prev = null;\\n        while (head != null && count-- > 0) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        pointer.next = head;\\n        return prev;\\n    }",
                "solutionTags": [],
                "code": "This method has two helper functions.\\n\\n1) height  - to determine height of list (straightforward)\\n2) reverese - to reverse the group ( usual reverse function with little tweak by just pointing intial head to last element of the group.\\n\\nAlgo:\\n1) if your current number (count % 2 == 0) is even then do reverse else just move forward in the list.\\n2) On the each loop just decrement height by count and once the height becomes less than number,\\n   break loop in case if its even , if its odd just increment the number and continue with the loop because even will take care of it.\\n```    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        int count = 1;\\n        int height = height(head);\\n        while (head != null) {\\n            if (count%2 == 0) {\\n                if (height < count && height %2 == 1)\\n                    break;\\n                ListNode next = head.next;\\n                head.next = reverse(head.next, count);\\n                head = next;\\n                if (height < count)\\n                    break;\\n            }\\n            else {\\n                if (height < count) {\\n                    if (height %2 == 1)\\n                        break;\\n                    else {\\n                        count++;\\n                        continue;\\n                    }\\n                }\\n                int index = count;\\n                while (head != null && index-- > 0 && count !=1) \\n                    head = head.next;\\n            }\\n            height -= count;\\n            count++;\\n        }\\n        return temp;\\n    }\\n    public int height (ListNode head) {\\n        int height = 0;\\n        while (head != null) {\\n            head = head.next;\\n            height++;\\n        }\\n        return height;\\n    }\\n    \\n    public ListNode reverse(ListNode head, int count) {\\n        if (head == null)\\n            return head;\\n        ListNode pointer = head, prev = null;\\n        while (head != null && count-- > 0) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        pointer.next = head;\\n        return prev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1657173,
                "title": "java-solution-using-recursion",
                "content": "\\tclass Solution {\\n\\t\\tpublic ListNode reverseEvenLengthGroups(ListNode head) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tListNode slow = head;\\n\\n\\t\\t\\twhile(slow!=null) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn helper(head, count, 1);\\n\\t\\t}\\n\\n\\t\\tpublic ListNode helper(ListNode head, int length, int groupLength) {\\n\\t\\t\\tListNode current = head;\\n\\t\\t\\tListNode prev = null;\\n\\n\\t\\t\\tif(length < groupLength) groupLength = length;\\n\\n\\t\\t\\tif(groupLength%2 == 1) {\\n\\t\\t\\t\\tint k = groupLength;\\n\\t\\t\\t\\twhile(k-- > 0 && current!=null) {\\n\\t\\t\\t\\t\\tprev = current;\\n\\t\\t\\t\\t\\tcurrent = current.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(current!=null)\\n\\t\\t\\t\\t\\tprev.next = helper(current, length-groupLength, groupLength+1);\\n\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint k = groupLength;\\n\\t\\t\\t\\tListNode next = null;\\n\\n\\t\\t\\t\\twhile(k-- > 0 && current!=null) {\\n\\t\\t\\t\\t\\tnext = current.next;\\n\\t\\t\\t\\t\\tcurrent.next = prev;\\n\\t\\t\\t\\t\\tprev = current;\\n\\t\\t\\t\\t\\tcurrent = next;    \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(current!=null)\\n\\t\\t\\t\\t\\thead.next = helper(current, length-groupLength, groupLength+1);\\n\\n\\t\\t\\t\\treturn prev;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic ListNode reverseEvenLengthGroups(ListNode head) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tListNode slow = head;\\n\\n\\t\\t\\twhile(slow!=null) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1652176,
                "title": "python-o-1-space",
                "content": "Approach:\\n\\tCount number of nodes until they are less than those in previous group.\\n\\ti.e. **groupCount+1>count**\\n\\tIf count is odd then modify pointers.\\n\\tElse reverse those nodes and also modify pointers.\\n\\nptr1 = pointer to last node of previous group\\nptr2 = pointer to start of current group\\nptr3 = pointer to start of next group\\nptr4 = pointer to end of current group\\n\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        groupCount = 0\\n        ptr1 = None\\n        ptr2 = head\\n        \\n        while ptr2:\\n            count = 0\\n            ptr3 = ptr2\\n            ptr4 = None\\n            while ptr3 and count<groupCount+1:\\n                ptr4 = ptr3\\n                ptr3 = ptr3.next\\n                count += 1\\n            \\n            if count%2:\\n                ptr1 = ptr4\\n            else:\\n                ptr1.next = self.reverse(ptr2, ptr3)\\n                ptr1 = ptr2\\n            ptr2 = ptr3\\n            groupCount += 1\\n        \\n        return head\\n            \\n    def reverse(self, curr, until):\\n        prev = until\\n        next = curr.next\\n        \\n        while next!=until:\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n            next = next.next\\n        \\n        curr.next = prev\\n        return curr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        groupCount = 0\\n        ptr1 = None\\n        ptr2 = head\\n        \\n        while ptr2:\\n            count = 0\\n            ptr3 = ptr2\\n            ptr4 = None\\n            while ptr3 and count<groupCount+1:\\n                ptr4 = ptr3\\n                ptr3 = ptr3.next\\n                count += 1\\n            \\n            if count%2:\\n                ptr1 = ptr4\\n            else:\\n                ptr1.next = self.reverse(ptr2, ptr3)\\n                ptr1 = ptr2\\n            ptr2 = ptr3\\n            groupCount += 1\\n        \\n        return head\\n            \\n    def reverse(self, curr, until):\\n        prev = until\\n        next = curr.next\\n        \\n        while next!=until:\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n            next = next.next\\n        \\n        curr.next = prev\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650251,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head, k):\\n            if head is None:\\n                return\\n\\t\\t\\t# traverse k node\\n            temp, kth, count = head, None, 0\\n            while temp and count < k:\\n                kth = temp\\n                temp = temp.next\\n                count += 1\\n\\t\\t\\t# return head for odd count\\n            if count % 2 and count != k: \\n                return head\\n            else:\\n                k = count # if count is even, reset k to count\\n            x = reverse(temp, k + 1)  # temp is (k + 1)th node\\n\\t\\t\\t# reverse list if k is even\\n            if k % 2 == 0:\\n                curr, pre = head, None\\n                while curr != temp:\\n                    next_ = curr.next\\n                    curr.next = pre\\n                    pre = curr\\n                    curr = next_\\n                head.next = x\\n                return pre\\n\\t\\t\\t\\n\\t\\t\\t# if k is odd\\n            kth.next = x\\n            return head\\n            \\n        return reverse(head, 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head, k):\\n            if head is None:\\n                return\\n\\t\\t\\t# traverse k node\\n            temp, kth, count = head, None, 0\\n            while temp and count < k:\\n                kth = temp\\n                temp = temp.next\\n                count += 1\\n\\t\\t\\t# return head for odd count\\n            if count % 2 and count != k: \\n                return head\\n            else:\\n                k = count # if count is even, reset k to count\\n            x = reverse(temp, k + 1)  # temp is (k + 1)th node\\n\\t\\t\\t# reverse list if k is even\\n            if k % 2 == 0:\\n                curr, pre = head, None\\n                while curr != temp:\\n                    next_ = curr.next\\n                    curr.next = pre\\n                    pre = curr\\n                    curr = next_\\n                head.next = x\\n                return pre\\n\\t\\t\\t\\n\\t\\t\\t# if k is odd\\n            kth.next = x\\n            return head\\n            \\n        return reverse(head, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594762,
                "title": "c-solution-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverselist(ListNode*& leftnode, ListNode*& rightnode, ListNode*& head) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        head=prevptr;\\n    }\\n    void reverseList(ListNode*& leftnode, ListNode*& rightnode) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode->next;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        leftnode->next=prevptr;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* rightnode=head;\\n        while(right>0 && rightnode){\\n            rightnode=rightnode->next;\\n            right--;\\n        }\\n        ListNode* leftnode=head;\\n        if(left!=1){\\n            left=left-2;\\n            while(left--) leftnode=leftnode->next;\\n            reverseList(leftnode, rightnode);\\n            return head;\\n        }\\n        reverselist(leftnode, rightnode, head);\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* temp=head;\\n        int length=0;\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        int k=1, i=1;\\n        while((k*(k+1)/2)<=length){\\n            if(k%2==0){\\n                head=reverseBetween(head, i, i+k-1);\\n            }\\n            i+=k;\\n            k++;\\n        }\\n        if((length-i+1)%2==0){\\n            head=reverseBetween(head, i, length);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverselist(ListNode*& leftnode, ListNode*& rightnode, ListNode*& head) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        head=prevptr;\\n    }\\n    void reverseList(ListNode*& leftnode, ListNode*& rightnode) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode->next;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        leftnode->next=prevptr;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* rightnode=head;\\n        while(right>0 && rightnode){\\n            rightnode=rightnode->next;\\n            right--;\\n        }\\n        ListNode* leftnode=head;\\n        if(left!=1){\\n            left=left-2;\\n            while(left--) leftnode=leftnode->next;\\n            reverseList(leftnode, rightnode);\\n            return head;\\n        }\\n        reverselist(leftnode, rightnode, head);\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* temp=head;\\n        int length=0;\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        int k=1, i=1;\\n        while((k*(k+1)/2)<=length){\\n            if(k%2==0){\\n                head=reverseBetween(head, i, i+k-1);\\n            }\\n            i+=k;\\n            k++;\\n        }\\n        if((length-i+1)%2==0){\\n            head=reverseBetween(head, i, length);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581686,
                "title": "c-brute-force-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<ListNode *>> arr;\\n        \\n        ListNode *p = head;\\n        if(!p)\\n            return p;\\n        \\n        \\n        int c = 0;\\n        \\n        while(p){\\n            c++;\\n            vector<ListNode *> v;\\n            for(int i = 0; i < c && p; i++){\\n                v.push_back(p);\\n                p = p->next;\\n            }\\n\\n            arr.push_back(v);\\n        }\\n        \\n        vector<ListNode *> l;\\n\\n        for(int i = 0; i < arr.size(); i++){\\n\\n            if(arr[i].size() % 2 == 0)\\n                reverse(arr[i].begin(), arr[i].end());\\n            \\n            for(int j = 0; j < arr[i].size(); j++)\\n                l.push_back(arr[i][j]);\\n        }\\n        \\n        for(int i = 1; i < l.size(); i++){\\n            l[i]->next = NULL;\\n            l[i-1]->next = l[i];\\n        }\\n            \\n        return l[0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<ListNode *>> arr;\\n        \\n        ListNode *p = head;\\n        if(!p)\\n            return p;\\n        \\n        \\n        int c = 0;\\n        \\n        while(p){\\n            c++;\\n            vector<ListNode *> v;\\n            for(int i = 0; i < c && p; i++){\\n                v.push_back(p);\\n                p = p->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1580899,
                "title": "brute-force-well-commented-and-easy-to-understand-java-solution",
                "content": "**Intuition** : we will be Creating a linkedlist (templist say) having all nodes which belongs to a single group (size k) and if k is odd then merge templist and resulting linkedlist directly and if k is even then we will reverse templist first and then merge it with resulting linkedlist.\\n**Approach :**  \\n1. traverse the given list in groups.\\n2. while traversing on a group we will be creating our templist and updating given linkedlist simultaneously.\\n3. Check if the size of the group we traversed was even ? if yes then reverse templist.\\n4. Merge templist and resulting Linkedlist.\\n\\n```\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        //ans is going to be head of our resulting linkedlist\\n        \\n\\n//         adding 1st group nodes to ans and removing them from given list\\n//         1st group only contains head of given linkedlist\\n        ListNode ans=head;  \\n        ListNode temp=head.next;\\n        \\n        head.next=null;\\n        head=temp;\\n        int size=Size(head); //size of given likedlist\\n        \\n        int k=2;  //size of current group \\n        \\n        \\n// this loop will create a linkedlist templist having all nodes of a group (of size k)\\n        while(temp!=null && k<=size){\\n            \\n            ListNode templist=null; \\n            int count=k;\\n            \\n//             adding all nodes of group to templist and removing respective nodes from given linkedlist\\n            while(count-->0){\\n                \\n                templist=addLast(templist,temp.val);  \\n                temp=remFirst(temp);\\n                \\n            }\\n            \\n//             now check if size of group is even then\\n            if(k%2==0){\\n                templist=rev(templist);  //reverse templist\\n            }\\n            \\n            ans= add(ans,templist);  //merge ans and templist \\n            \\n            size-=k;\\n            k++; \\n        }\\n        \\n        size=Size(temp);\\n        if(size%2==0){\\n            temp=rev(temp);\\n        }\\n        ans=add(ans,temp);\\n        return ans;\\n    }\\n    \\n//     Function to determine size of the LinkedList\\n    public int Size(ListNode head){\\n        ListNode temp=head;\\n        int size=0;\\n        while(temp!=null){\\n            temp=temp.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n    \\n//     this Function will add a node(having data val) at the last of linkedlist\\n    public ListNode addLast(ListNode head,int val){\\n        ListNode nn= new ListNode(val);\\n        if(head==null){\\n            return nn;\\n        }\\n        \\n        ListNode temp=head;\\n        \\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        \\n        temp.next=nn;\\n        return head;\\n    }\\n    \\n    \\n//     this function will remove the first node of the linkedlist\\n    public ListNode remFirst(ListNode head){\\n        ListNode temp=head;\\n        head=head.next;\\n        temp.next=null;\\n        return head;\\n    }\\n    \\n    \\n//     This function will merge two linkedlist\\n    public ListNode add(ListNode list1,ListNode list2){\\n        \\n        ListNode temp=list1;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next=list2;\\n        return list1;\\n    }\\n    \\n//     this Function will reverse the LinkedList\\n    public ListNode rev(ListNode head){\\n        \\n        ListNode prev=null;\\n        ListNode curr= head;\\n        while(curr!=null){\\n            ListNode currnext=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=currnext;\\n        }\\n        head=prev;\\n        return head;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        //ans is going to be head of our resulting linkedlist\\n        \\n\\n//         adding 1st group nodes to ans and removing them from given list\\n//         1st group only contains head of given linkedlist\\n        ListNode ans=head;  \\n        ListNode temp=head.next;\\n        \\n        head.next=null;\\n        head=temp;\\n        int size=Size(head); //size of given likedlist\\n        \\n        int k=2;  //size of current group \\n        \\n        \\n// this loop will create a linkedlist templist having all nodes of a group (of size k)\\n        while(temp!=null && k<=size){\\n            \\n            ListNode templist=null; \\n            int count=k;\\n            \\n//             adding all nodes of group to templist and removing respective nodes from given linkedlist\\n            while(count-->0){\\n                \\n                templist=addLast(templist,temp.val);  \\n                temp=remFirst(temp);\\n                \\n            }\\n            \\n//             now check if size of group is even then\\n            if(k%2==0){\\n                templist=rev(templist);  //reverse templist\\n            }\\n            \\n            ans= add(ans,templist);  //merge ans and templist \\n            \\n            size-=k;\\n            k++; \\n        }\\n        \\n        size=Size(temp);\\n        if(size%2==0){\\n            temp=rev(temp);\\n        }\\n        ans=add(ans,temp);\\n        return ans;\\n    }\\n    \\n//     Function to determine size of the LinkedList\\n    public int Size(ListNode head){\\n        ListNode temp=head;\\n        int size=0;\\n        while(temp!=null){\\n            temp=temp.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n    \\n//     this Function will add a node(having data val) at the last of linkedlist\\n    public ListNode addLast(ListNode head,int val){\\n        ListNode nn= new ListNode(val);\\n        if(head==null){\\n            return nn;\\n        }\\n        \\n        ListNode temp=head;\\n        \\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        \\n        temp.next=nn;\\n        return head;\\n    }\\n    \\n    \\n//     this function will remove the first node of the linkedlist\\n    public ListNode remFirst(ListNode head){\\n        ListNode temp=head;\\n        head=head.next;\\n        temp.next=null;\\n        return head;\\n    }\\n    \\n    \\n//     This function will merge two linkedlist\\n    public ListNode add(ListNode list1,ListNode list2){\\n        \\n        ListNode temp=list1;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next=list2;\\n        return list1;\\n    }\\n    \\n//     this Function will reverse the LinkedList\\n    public ListNode rev(ListNode head){\\n        \\n        ListNode prev=null;\\n        ListNode curr= head;\\n        while(curr!=null){\\n            ListNode currnext=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=currnext;\\n        }\\n        head=prev;\\n        return head;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580446,
                "title": "2074-reverse-nodes-in-even-length-groups",
                "content": "---\\n\\n- Contest - https://leetcode.com/contest/weekly-contest-267/\\n  - Q1 Answer\\n    - https://leetcode.com/problems/time-needed-to-buy-tickets/discuss/1578174/2073.-Time-Needed-to-Buy-Tickets\\n  - Q2 Answer\\n    - below\\n      - https://leetcode.com/problems/reverse-nodes-in-even-length-groups/discuss/1580446/2074.-Reverse-Nodes-in-Even-Length-Groups\\n  - Q3 Answer\\n    - https://leetcode.com/problems/decode-the-slanted-ciphertext/discuss/1588186/2075.-Decode-the-Slanted-Ciphertext\\n\\n---\\n\\nTwo solutions:\\n- Creating intermediate arrays\\n- Without creating intermediate arrays\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Creating intermediate arrays**\\n\\n```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // cut into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let reversePart = values.slice(k, k + count).reverse();\\n        if (reversePart.length % 2 === 0)\\n            for (let i = 0; i < reversePart.length; i++) {\\n                values[k + i] = reversePart[i];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```\\n\\n---\\n\\n**Without creating intermediate arrays**\\n\\n```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // take into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let size = Math.min(k + count, n) - k;\\n        if (size % 2 === 0)\\n            for (let i = k, j = k + size - 1; i < j; i++, j--) {\\n                [values[i], values[j]] = [values[j], values[i]];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // cut into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let reversePart = values.slice(k, k + count).reverse();\\n        if (reversePart.length % 2 === 0)\\n            for (let i = 0; i < reversePart.length; i++) {\\n                values[k + i] = reversePart[i];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```\n```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // take into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let size = Math.min(k + count, n) - k;\\n        if (size % 2 === 0)\\n            for (let i = k, j = k + size - 1; i < j; i++, j--) {\\n                [values[i], values[j]] = [values[j], values[i]];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580441,
                "title": "java-recursive-o-n-in-place-o-1-space",
                "content": "```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        return rec(0,1,head)[0];\\n    }\\n    private boolean evenNumberGroup = false;\\n    //return {head, tail for rev}\\n    private ListNode[] rec(int i, int group, ListNode currNode){\\n        if(currNode == null) {\\n            evenNumberGroup = i%2==0;\\n            return new ListNode[2];\\n        }\\n        i++;\\n        ListNode[] ret = rec(i%group, group + i/group, currNode.next);\\n        if(i==group)\\n            evenNumberGroup = i%2==0;\\n        if(ret[1]!=null && evenNumberGroup && i!=group ){\\n            currNode.next = ret[1].next;\\n            ret[1].next = currNode;\\n            ret[1] = currNode;\\n            return ret;\\n        }\\n        currNode.next = ret[0];\\n        ret[1]=ret[0]=currNode;\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        return rec(0,1,head)[0];\\n    }\\n    private boolean evenNumberGroup = false;\\n    //return {head, tail for rev}\\n    private ListNode[] rec(int i, int group, ListNode currNode){\\n        if(currNode == null) {\\n            evenNumberGroup = i%2==0;\\n            return new ListNode[2];\\n        }\\n        i++;\\n        ListNode[] ret = rec(i%group, group + i/group, currNode.next);\\n        if(i==group)\\n            evenNumberGroup = i%2==0;\\n        if(ret[1]!=null && evenNumberGroup && i!=group ){\\n            currNode.next = ret[1].next;\\n            ret[1].next = currNode;\\n            ret[1] = currNode;\\n            return ret;\\n        }\\n        currNode.next = ret[0];\\n        ret[1]=ret[0]=currNode;\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580122,
                "title": "2-solution-c-clean-code-with-comment",
                "content": "```\\n//solution 1\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // not effitient solution\\n        // cheating code, convert to array then make linked list again\\n        vector<int> elements;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            elements.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        vector<int> ans;\\n        int index = 0;\\n        for(int len = 1; len <= elements.size(); len++) {\\n            // end of the current segment \\n            int n = min(index + len, (int)elements.size());\\n            \\n            //trick for last segment...if they have odd then no reverse\\n            //else reversly add the elements to the ans array\\n            if((n-index)%2 == 1) {\\n                for(; index < n && index < elements.size(); index++) \\n                    ans.push_back(elements[index]);\\n            }\\n            else {\\n                for(int i = n-1; i >= index; i--) \\n                    ans.push_back(elements[i]);\\n                index = n;\\n            }\\n        }\\n        \\n        // make linked list from array \\n        head = new ListNode(ans[0]);\\n        current = head;\\n        for(int i = 1; i < ans.size(); i++) {\\n            current->next = new ListNode(ans[i]);\\n            current = current-> next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n\\n//solution 2\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int length = 1;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            int count = 0;\\n            ListNode* tmp = current;\\n            stack<int> stk;\\n            while(count != length && current != nullptr) {\\n                count++;\\n                stk.push(current->val);\\n                current = current->next;\\n            }\\n            \\n            if(count%2 == 0) {\\n                while(tmp != current) {\\n                    tmp->val = stk.top();\\n                    stk.pop();\\n                    tmp = tmp->next;\\n                }\\n            }\\n            \\n            length++;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//solution 1\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // not effitient solution\\n        // cheating code, convert to array then make linked list again\\n        vector<int> elements;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            elements.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        vector<int> ans;\\n        int index = 0;\\n        for(int len = 1; len <= elements.size(); len++) {\\n            // end of the current segment \\n            int n = min(index + len, (int)elements.size());\\n            \\n            //trick for last segment...if they have odd then no reverse\\n            //else reversly add the elements to the ans array\\n            if((n-index)%2 == 1) {\\n                for(; index < n && index < elements.size(); index++) \\n                    ans.push_back(elements[index]);\\n            }\\n            else {\\n                for(int i = n-1; i >= index; i--) \\n                    ans.push_back(elements[i]);\\n                index = n;\\n            }\\n        }\\n        \\n        // make linked list from array \\n        head = new ListNode(ans[0]);\\n        current = head;\\n        for(int i = 1; i < ans.size(); i++) {\\n            current->next = new ListNode(ans[i]);\\n            current = current-> next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n\\n//solution 2\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int length = 1;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            int count = 0;\\n            ListNode* tmp = current;\\n            stack<int> stk;\\n            while(count != length && current != nullptr) {\\n                count++;\\n                stk.push(current->val);\\n                current = current->next;\\n            }\\n            \\n            if(count%2 == 0) {\\n                while(tmp != current) {\\n                    tmp->val = stk.top();\\n                    stk.pop();\\n                    tmp = tmp->next;\\n                }\\n            }\\n            \\n            length++;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577570,
                "title": "c-solution-brute-force-o-n-space",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<int>v;\\n        for(;head!=NULL;head=head->next)\\n        {\\n            v.push_back(head->val);\\n        }\\n        int n=v.size();\\n        map<int,vector<int>>mp;\\n        int len=1;\\n        for(int i=0;i<n;i++)\\n        {\\n             if(mp[len].size()==len)\\n            {\\n                len++;\\n            }\\n            mp[len].push_back(v[i]);\\n        }\\n        for(auto &it:mp)\\n        {\\n            if(it.second.size()%2==0)\\n            {\\n                reverse(it.second.begin(),it.second.end());\\n            }\\n        }\\n        ListNode*dummy_node=new ListNode(-1);\\n        ListNode*curr=dummy_node;\\n        for(auto it:mp)\\n        {\\n            for(auto ch:it.second)\\n            {\\n               curr->next=new ListNode(ch);\\n                curr=curr->next;\\n            }\\n        }\\n        return dummy_node->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<int>v;\\n        for(;head!=NULL;head=head->next)\\n        {\\n            v.push_back(head->val);\\n        }\\n        int n=v.size();\\n        map<int,vector<int>>mp;\\n        int len=1;\\n        for(int i=0;i<n;i++)\\n        {\\n             if(mp[len].size()==len)\\n            {\\n                len++;\\n            }\\n            mp[len].push_back(v[i]);\\n        }\\n        for(auto &it:mp)\\n        {\\n            if(it.second.size()%2==0)\\n            {\\n                reverse(it.second.begin(),it.second.end());\\n            }\\n        }\\n        ListNode*dummy_node=new ListNode(-1);\\n        ListNode*curr=dummy_node;\\n        for(auto it:mp)\\n        {\\n            for(auto ch:it.second)\\n            {\\n               curr->next=new ListNode(ch);\\n                curr=curr->next;\\n            }\\n        }\\n        return dummy_node->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577392,
                "title": "easy-to-understand-java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode prev = new ListNode(0);\\n        prev.next = head;\\n        \\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        \\n        int length = 0;\\n        ListNode node = head;\\n        while(node != null) {\\n            node = node.next;\\n            length++;\\n        }\\n        \\n        int currentGroup = 1;\\n        \\n        while(length > 0 ) {\\n            \\n            //next group is not last group, and number of nodes are odd\\n            if (length >= currentGroup && currentGroup % 2 != 0) {\\n                int temp = currentGroup;\\n                while(temp > 0) {\\n                    prev = head;\\n                    head = head.next;\\n                    temp = temp - 1;\\n                }\\n                length = length - currentGroup;\\n                //remining is last group, and number of nodes are odd\\n            } else if (length < currentGroup && length % 2 != 0) {\\n                break;\\n                //next group is even\\n            } else {\\n                ListNode tempNode = reverseList(prev, Math.min(currentGroup, length));\\n                head = tempNode.next;\\n                prev = tempNode;\\n                length = length - currentGroup;\\n            }\\n            \\n            currentGroup++;\\n        }\\n        return dummyHead.next;\\n    }\\n    \\n    \\n    // l >= 2\\n    private ListNode reverseList(ListNode prev, int l) {\\n\\n        ListNode curr = prev.next;\\n        ListNode temp = curr;\\n        \\n        while (curr != null && l > 0) {\\n            ListNode next = curr.next;\\n            \\n            curr.next = prev.next;\\n            prev.next = next;\\n            \\n            \\n            temp.next = next.next;\\n            next.next = curr;\\n\\n            curr = temp.next;\\n            \\n            l = l - 2;\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode prev = new ListNode(0);\\n        prev.next = head;\\n        \\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        \\n        int length = 0;\\n        ListNode node = head;\\n        while(node != null) {\\n            node = node.next;\\n            length++;\\n        }\\n        \\n        int currentGroup = 1;\\n        \\n        while(length > 0 ) {\\n            \\n            //next group is not last group, and number of nodes are odd\\n            if (length >= currentGroup && currentGroup % 2 != 0) {\\n                int temp = currentGroup;\\n                while(temp > 0) {\\n                    prev = head;\\n                    head = head.next;\\n                    temp = temp - 1;\\n                }\\n                length = length - currentGroup;\\n                //remining is last group, and number of nodes are odd\\n            } else if (length < currentGroup && length % 2 != 0) {\\n                break;\\n                //next group is even\\n            } else {\\n                ListNode tempNode = reverseList(prev, Math.min(currentGroup, length));\\n                head = tempNode.next;\\n                prev = tempNode;\\n                length = length - currentGroup;\\n            }\\n            \\n            currentGroup++;\\n        }\\n        return dummyHead.next;\\n    }\\n    \\n    \\n    // l >= 2\\n    private ListNode reverseList(ListNode prev, int l) {\\n\\n        ListNode curr = prev.next;\\n        ListNode temp = curr;\\n        \\n        while (curr != null && l > 0) {\\n            ListNode next = curr.next;\\n            \\n            curr.next = prev.next;\\n            prev.next = next;\\n            \\n            \\n            temp.next = next.next;\\n            next.next = curr;\\n\\n            curr = temp.next;\\n            \\n            l = l - 2;\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577331,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t#helper function which reverses the linked list upto given length\\n        def help(head,n):\\n            a=head\\n            pre=None\\n            cur=head\\n            jam=head\\n            nex=head\\n            while nex and n:\\n                n-=1\\n                cur=nex\\n                nex=nex.next\\n                cur.next=pre\\n                pre=cur\\n            jam.next=nex            \\n            return cur\\n\\t\\t# traverse through the linked list and if its odd do nothing else call helper function\\n        le=0\\n        b=head\\n        while b:#length of complete linked list\\n            le+=1\\n            b=b.next\\n        cc=1\\n        ss=0\\n        r=head\\n        par=None\\n        opp=le\\n        while ss<=opp-1 and r:#while we reach the end\\n            if cc%2!=0:#if odd traverse the linked lisst normally\\n                op=cc\\n                while op and r:\\n                    par=r\\n                    r=r.next\\n                    op-=1\\n            else:    #else call helper function and reverse\\n                par.next=help(r,cc)\\n                op=cc            \\n                while op and par:\\n                    par=par.next            \\n                    op-=1\\n                r=par.next\\n            if ss==opp-1:\\n                break\\n            le-=cc\\n            cc+=1\\n            if le<cc:#if we got the number as 4 but we only have 2 left then we need to reverse the 2 nodes this helps to solve that edge case\\n                cc=le\\n            ss+=cc\\n        return head\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t#helper function which reverses the linked list upto given length\\n        def help(head,n):\\n            a=head\\n            pre=None\\n            cur=head\\n            jam=head\\n            nex=head\\n            while nex and n:\\n                n-=1\\n                cur=nex\\n                nex=nex.next\\n                cur.next=pre\\n                pre=cur\\n            jam.next=nex            \\n            return cur\\n\\t\\t# traverse through the linked list and if its odd do nothing else call helper function\\n        le=0\\n        b=head\\n        while b:#length of complete linked list\\n            le+=1\\n            b=b.next\\n        cc=1\\n        ss=0\\n        r=head\\n        par=None\\n        opp=le\\n        while ss<=opp-1 and r:#while we reach the end\\n            if cc%2!=0:#if odd traverse the linked lisst normally\\n                op=cc\\n                while op and r:\\n                    par=r\\n                    r=r.next\\n                    op-=1\\n            else:    #else call helper function and reverse\\n                par.next=help(r,cc)\\n                op=cc            \\n                while op and par:\\n                    par=par.next            \\n                    op-=1\\n                r=par.next\\n            if ss==opp-1:\\n                break\\n            le-=cc\\n            cc+=1\\n            if le<cc:#if we got the number as 4 but we only have 2 left then we need to reverse the 2 nodes this helps to solve that edge case\\n                cc=le\\n            ss+=cc\\n        return head\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577047,
                "title": "easy-commented-cpp-solution",
                "content": "The idea is to keep a running `curGrpSize` which keeps the current size and compare it to `grpSize` (which keeps the natural number to corresponding to the required size for the current grp).\\nEach grp will begin from `l->next` and end at `r.`\\nAs the `grpSize == curGrpSize`, we check if grpSize is even. If it is even, we reverse the grp using revList method, otherwise we move to the next grp.\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    // method to reverse List, returns [head, tail];\\n    vector<ListNode*> revList(ListNode* head){\\n        ListNode* prev = NULL, * curr = head, *nxt = NULL;\\n        while(curr){\\n            nxt = curr -> next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        return {prev, head};\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // grpSize will keep the Natural Number, which should be the size of the grp\\n        int grpSize = 1;\\n        // curGrpSize will keep the current size\\n        int curGrpSize = 1;\\n        // dummy will help in flipping from the next node if necessary\\n        ListNode* dummy = new ListNode();\\n        dummy->next = head;\\n        // The grp will start from l->next and end at r.\\n        ListNode* l = dummy, *r = head;\\n        while(r){\\n            // if the grp is even and has ended\\n            if(curGrpSize == grpSize and grpSize%2 == 0){\\n                // save imp pointers before flipping grp\\n                ListNode* tempHead = l->next;\\n                ListNode* tempLastNext = r->next;\\n                // make r pointer of grp as null so that reversing stops there\\n                r->next = NULL;\\n                // reverse the grp\\n                vector<ListNode*> nodes = revList(tempHead);\\n                // reconnect necessary pointers\\n                l->next = nodes[0];\\n                nodes[1]->next = tempLastNext;\\n                // prepare for next grp\\n                l =  nodes[1];\\n                r =  nodes[1]->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has ended, but is odd\\n            else if(curGrpSize == grpSize){\\n                l = r;\\n                r = r->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has not ended\\n            else{\\n                r = r->next;\\n                curGrpSize++;\\n            }\\n        }\\n        \\n        // if the last group is less than its Natural Number size, but is even.\\n        if((curGrpSize-1)%2 == 0){\\n            if(!l) return head;\\n            vector<ListNode*> nodes = revList(l -> next);\\n            l->next = nodes[0];\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    // method to reverse List, returns [head, tail];\\n    vector<ListNode*> revList(ListNode* head){\\n        ListNode* prev = NULL, * curr = head, *nxt = NULL;\\n        while(curr){\\n            nxt = curr -> next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        return {prev, head};\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // grpSize will keep the Natural Number, which should be the size of the grp\\n        int grpSize = 1;\\n        // curGrpSize will keep the current size\\n        int curGrpSize = 1;\\n        // dummy will help in flipping from the next node if necessary\\n        ListNode* dummy = new ListNode();\\n        dummy->next = head;\\n        // The grp will start from l->next and end at r.\\n        ListNode* l = dummy, *r = head;\\n        while(r){\\n            // if the grp is even and has ended\\n            if(curGrpSize == grpSize and grpSize%2 == 0){\\n                // save imp pointers before flipping grp\\n                ListNode* tempHead = l->next;\\n                ListNode* tempLastNext = r->next;\\n                // make r pointer of grp as null so that reversing stops there\\n                r->next = NULL;\\n                // reverse the grp\\n                vector<ListNode*> nodes = revList(tempHead);\\n                // reconnect necessary pointers\\n                l->next = nodes[0];\\n                nodes[1]->next = tempLastNext;\\n                // prepare for next grp\\n                l =  nodes[1];\\n                r =  nodes[1]->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has ended, but is odd\\n            else if(curGrpSize == grpSize){\\n                l = r;\\n                r = r->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has not ended\\n            else{\\n                r = r->next;\\n                curGrpSize++;\\n            }\\n        }\\n        \\n        // if the last group is less than its Natural Number size, but is even.\\n        if((curGrpSize-1)%2 == 0){\\n            if(!l) return head;\\n            vector<ListNode*> nodes = revList(l -> next);\\n            l->next = nodes[0];\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577010,
                "title": "javascript-simple-value-change",
                "content": "```javascript\\nvar reverseEvenLengthGroups = function(head) {\\n    const headNode = new ListNode(0, head);\\n    let prev = headNode;\\n    let group = 0;\\n    while (prev.next) {\\n        group++;\\n        const values = [];\\n        let start = prev\\n        for (let count = 0; count < group && start.next; count++) {\\n            start = start.next;\\n            values.push(start.val);\\n        }\\n        if (values.length % 2 === 0) {\\n            start = prev;\\n            for (let count = 0; count < group && start.next; count++) {\\n                start = start.next;\\n                start.val = values.pop();\\n            }\\n        }\\n        for (let count = 0; count < group && prev.next; count++) {\\n            prev = prev.next;\\n        }\\n    }\\n    return headNode.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar reverseEvenLengthGroups = function(head) {\\n    const headNode = new ListNode(0, head);\\n    let prev = headNode;\\n    let group = 0;\\n    while (prev.next) {\\n        group++;\\n        const values = [];\\n        let start = prev\\n        for (let count = 0; count < group && start.next; count++) {\\n            start = start.next;\\n            values.push(start.val);\\n        }\\n        if (values.length % 2 === 0) {\\n            start = prev;\\n            for (let count = 0; count < group && start.next; count++) {\\n                start = start.next;\\n                start.val = values.pop();\\n            }\\n        }\\n        for (let count = 0; count < group && prev.next; count++) {\\n            prev = prev.next;\\n        }\\n    }\\n    return headNode.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576995,
                "title": "python3-reversing-slices",
                "content": "We change the linked list into normal list.\\nWe reverse the groups in the list.\\nWe create a new linked list and return the head.\\nTime is O(N). \\nSpace is O(N).\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nodes=[]\\n        node=head\\n        while node:\\n            nodes.append(node.val)\\n            node=node.next\\n        n=len(nodes)\\n        i=0\\n        j=1\\n        while i<n:\\n            if j%2==0 and i+j<=n or 0==(n-i)%2 and n-i<j:\\n                nodes[i:i+j]=nodes[i:i+j][::-1]\\n            i+=j\\n            j+=1\\n        \\n        newHead=ListNode(nodes[0])\\n        node=newHead\\n        for x in nodes[1:]:\\n            node.next=ListNode(x)\\n            node=node.next    \\n        \\n        return newHead\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nodes=[]\\n        node=head\\n        while node:\\n            nodes.append(node.val)\\n            node=node.next\\n        n=len(nodes)\\n        i=0\\n        j=1\\n        while i<n:\\n            if j%2==0 and i+j<=n or 0==(n-i)%2 and n-i<j:\\n                nodes[i:i+j]=nodes[i:i+j][::-1]\\n            i+=j\\n            j+=1\\n        \\n        newHead=ListNode(nodes[0])\\n        node=newHead\\n        for x in nodes[1:]:\\n            node.next=ListNode(x)\\n            node=node.next    \\n        \\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576945,
                "title": "python-solution-using-group-dictionary",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    \\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        group_dict = defaultdict(list)\\n        temp = head\\n        group = 1\\n        count = 0\\n        while temp:\\n            group_dict[group].append(temp)\\n            temp = temp.next\\n            count+=1\\n            if count % group == 0:\\n                count = 0\\n                group+= 1\\n        head = None\\n        curr = None\\n        for i in range(1, group+1):\\n            if i == 1:\\n                head = group_dict[i][0]\\n                head.next = None\\n                curr = head\\n                continue\\n            lst = group_dict[i]\\n            if len(lst) % 2 == 0:\\n                lst.reverse()\\n            for root  in lst:\\n                curr.next = root\\n                curr = root\\n            curr.next = None\\n                \\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    \\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        group_dict = defaultdict(list)\\n        temp = head\\n        group = 1\\n        count = 0\\n        while temp:\\n            group_dict[group].append(temp)\\n            temp = temp.next\\n            count+=1\\n            if count % group == 0:\\n                count = 0\\n                group+= 1\\n        head = None\\n        curr = None\\n        for i in range(1, group+1):\\n            if i == 1:\\n                head = group_dict[i][0]\\n                head.next = None\\n                curr = head\\n                continue\\n            lst = group_dict[i]\\n            if len(lst) % 2 == 0:\\n                lst.reverse()\\n            for root  in lst:\\n                curr.next = root\\n                curr = root\\n            curr.next = None\\n                \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059620,
                "title": "python-brute-force-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        values = []\\n        grp = 1\\n        itr = head\\n        temp = []\\n        while(itr!=None):\\n            temp.append(itr.val)\\n            if len(temp) == grp:\\n                if len(temp)%2 == 0:\\n                    temp = temp[::-1]\\n                values.append(temp)\\n                grp += 1\\n                temp = []\\n            itr = itr.next\\n        if len(temp)!= 0:\\n            if len(temp)%2 == 0:\\n                temp = temp[::-1]\\n            values.append(temp)\\n        itr = head\\n        for i in values:\\n            for j in i:\\n                itr.val = j\\n                itr = itr.next\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        values = []\\n        grp = 1\\n        itr = head\\n        temp = []\\n        while(itr!=None):\\n            temp.append(itr.val)\\n            if len(temp) == grp:\\n                if len(temp)%2 == 0:\\n                    temp = temp[::-1]\\n                values.append(temp)\\n                grp += 1\\n                temp = []\\n            itr = itr.next\\n        if len(temp)!= 0:\\n            if len(temp)%2 == 0:\\n                temp = temp[::-1]\\n            values.append(temp)\\n        itr = head\\n        for i in values:\\n            for j in i:\\n                itr.val = j\\n                itr = itr.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047401,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n\\n        func reverse(\\n            _ size: Int,\\n            _ tail: ListNode?,\\n            _ begin: ListNode?,\\n            _ end: ListNode?\\n        ) -> ListNode? {\\n            \\n            guard size != 0, size % 2 == 0 else {\\n                return end\\n            }\\n\\n            var prev = begin\\n            var cur = prev?.next\\n\\n            while true {\\n                let next = cur?.next\\n                cur?.next = prev\\n                prev = cur\\n                cur = next\\n\\n                if prev === end {\\n                    break\\n                }\\n            }\\n\\n            tail?.next = prev\\n            begin?.next = cur\\n\\n            return begin\\n        }\\n        \\n        var tail: ListNode?\\n        var begin = head\\n        var end: ListNode?\\n        var cur = head\\n\\n        var target = 1\\n        var size = 0\\n\\n        while true {\\n\\n            if cur != nil {\\n                size += 1\\n                end = cur\\n            }\\n            \\n            if size == target || cur == nil {\\n                tail = reverse(size, tail, begin, end)\\n\\n                cur = tail\\n                begin = cur?.next\\n                end = cur?.next\\n\\n                target += 1\\n                size = 0\\n            }\\n\\n            if cur == nil {\\n                break\\n            }\\n\\n            cur = cur?.next\\n        }\\n\\n        return head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n\\n        func reverse(\\n            _ size: Int,\\n            _ tail: ListNode?,\\n            _ begin: ListNode?,\\n            _ end: ListNode?\\n        ) -> ListNode? {\\n            \\n            guard size != 0, size % 2 == 0 else {\\n                return end\\n            }\\n\\n            var prev = begin\\n            var cur = prev?.next\\n\\n            while true {\\n                let next = cur?.next\\n                cur?.next = prev\\n                prev = cur\\n                cur = next\\n\\n                if prev === end {\\n                    break\\n                }\\n            }\\n\\n            tail?.next = prev\\n            begin?.next = cur\\n\\n            return begin\\n        }\\n        \\n        var tail: ListNode?\\n        var begin = head\\n        var end: ListNode?\\n        var cur = head\\n\\n        var target = 1\\n        var size = 0\\n\\n        while true {\\n\\n            if cur != nil {\\n                size += 1\\n                end = cur\\n            }\\n            \\n            if size == target || cur == nil {\\n                tail = reverse(size, tail, begin, end)\\n\\n                cur = tail\\n                begin = cur?.next\\n                end = cur?.next\\n\\n                target += 1\\n                size = 0\\n            }\\n\\n            if cur == nil {\\n                break\\n            }\\n\\n            cur = cur?.next\\n        }\\n\\n        return head\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042361,
                "title": "java-o-1-space-solution-beats-96",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode oddTail = null, evenTail = null, curr = head;\\n        int currSize = 1;\\n        while (curr != null) {\\n            int mySize = 0;\\n            ListNode dummy = curr;\\n            while (dummy != null && mySize++ < currSize) dummy = dummy.next;\\n            if (mySize < currSize) currSize = mySize;\\n            if ((currSize & 1) == 1) {\\n                for (int i = 0; i < currSize; i++) {\\n                    if (i == currSize - 1) oddTail = curr;\\n                    curr = curr.next;\\n                }\\n            } else {\\n                evenTail = curr;\\n                ListNode prev = null;\\n                for (int i = 0; i < currSize && curr != null; i++) {\\n                    ListNode temp = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = temp;\\n                }\\n                oddTail.next = prev;\\n                evenTail.next = curr;\\n                oddTail = evenTail;\\n            }\\n            currSize++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode oddTail = null, evenTail = null, curr = head;\\n        int currSize = 1;\\n        while (curr != null) {\\n            int mySize = 0;\\n            ListNode dummy = curr;\\n            while (dummy != null && mySize++ < currSize) dummy = dummy.next;\\n            if (mySize < currSize) currSize = mySize;\\n            if ((currSize & 1) == 1) {\\n                for (int i = 0; i < currSize; i++) {\\n                    if (i == currSize - 1) oddTail = curr;\\n                    curr = curr.next;\\n                }\\n            } else {\\n                evenTail = curr;\\n                ListNode prev = null;\\n                for (int i = 0; i < currSize && curr != null; i++) {\\n                    ListNode temp = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = temp;\\n                }\\n                oddTail.next = prev;\\n                evenTail.next = curr;\\n                oddTail = evenTail;\\n            }\\n            currSize++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038421,
                "title": "python3-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst = []\\n        while head != None:\\n            lst.append(head.val)\\n            head = head.next\\n        N = len(lst)\\n        groups = []\\n        size = 1\\n        i = 0\\n        while i+size < N:\\n            tmp = []\\n            for j in range(i, size+i):\\n                tmp.append(lst[j])\\n            groups.append(tmp)\\n            i += size\\n            size += 1\\n        tmp = []\\n        for j in range(i, N):\\n            tmp.append(lst[j])\\n        groups.append(tmp)\\n\\n        ans = []\\n        for i, g in enumerate(groups):\\n            if len(g)%2==0:\\n                for j in range(len(g)-1, -1, -1):\\n                    ans.append(g[j])\\n            else:\\n                for j in range(len(g)):\\n                    ans.append(g[j])\\n\\n        root = ListNode(ans[0])\\n        prev = root\\n        for i in range(1, len(ans)):\\n            tmp = ListNode(ans[i])\\n            prev.next = tmp\\n            prev = tmp\\n\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst = []\\n        while head != None:\\n            lst.append(head.val)\\n            head = head.next\\n        N = len(lst)\\n        groups = []\\n        size = 1\\n        i = 0\\n        while i+size < N:\\n            tmp = []\\n            for j in range(i, size+i):\\n                tmp.append(lst[j])\\n            groups.append(tmp)\\n            i += size\\n            size += 1\\n        tmp = []\\n        for j in range(i, N):\\n            tmp.append(lst[j])\\n        groups.append(tmp)\\n\\n        ans = []\\n        for i, g in enumerate(groups):\\n            if len(g)%2==0:\\n                for j in range(len(g)-1, -1, -1):\\n                    ans.append(g[j])\\n            else:\\n                for j in range(len(g)):\\n                    ans.append(g[j])\\n\\n        root = ListNode(ans[0])\\n        prev = root\\n        for i in range(1, len(ans)):\\n            tmp = ListNode(ans[i])\\n            prev.next = tmp\\n            prev = tmp\\n\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013470,
                "title": "c-c-iterative-one-pass-solution-with-five-pointers-95-time-complexity",
                "content": "Idea is very similar to solving [#25: Reverse nodes in k-group](https://leetcode.com/problems/reverse-nodes-in-k-group/). You only need five pointers to solve this problem. In the worst case, each node is traversed twice since you do not know the length of the next segment prior to visiting the node once.\\n\\n```\\nclass Solution {\\nprivate:\\n    ListNode *prev, *node, *next, *beforeprev;\\n    void reverseGroup(ListNode* beforeprev, ListNode* last, int k) {\\n        prev = beforeprev;\\n        node = prev->next;\\n        next = node->next;\\n        for (int i = 0; i < k - 1; i++) {\\n            node->next = prev;\\n            prev = node;\\n            node = next;\\n            next = node ? next->next : next;\\n        }\\n        node->next = prev;\\n        prev = node;\\n        node = next;\\n        beforeprev->next->next = last;\\n        beforeprev->next = prev;\\n    }\\n    \\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        node = head;\\n        int n = 2;\\n        while (node->next) {\\n            beforeprev = node;\\n            int i = 0;\\n            for (; i < n && node->next; i++) {\\n                node = node->next;\\n            }\\n            if (i % 2 == 0) {\\n                ListNode *save = beforeprev->next;\\n                reverseGroup(beforeprev, node ? node->next : 0, i);\\n                node = save;\\n            }\\n            n++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    ListNode *prev, *node, *next, *beforeprev;\\n    void reverseGroup(ListNode* beforeprev, ListNode* last, int k) {\\n        prev = beforeprev;\\n        node = prev->next;\\n        next = node->next;\\n        for (int i = 0; i < k - 1; i++) {\\n            node->next = prev;\\n            prev = node;\\n            node = next;\\n            next = node ? next->next : next;\\n        }\\n        node->next = prev;\\n        prev = node;\\n        node = next;\\n        beforeprev->next->next = last;\\n        beforeprev->next = prev;\\n    }\\n    \\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        node = head;\\n        int n = 2;\\n        while (node->next) {\\n            beforeprev = node;\\n            int i = 0;\\n            for (; i < n && node->next; i++) {\\n                node = node->next;\\n            }\\n            if (i % 2 == 0) {\\n                ListNode *save = beforeprev->next;\\n                reverseGroup(beforeprev, node ? node->next : 0, i);\\n                node = save;\\n            }\\n            n++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012613,
                "title": "reverse-list-in-groups-of-k-method",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSize(ListNode *head){\\n        int ct=0;\\n        while(head) {\\n            head=head->next;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head) return head;\\n        ListNode *dummy = new ListNode(-100);\\n        dummy->next=head;\\n        ListNode *prev=dummy,*curr;\\n        \\n        int size = findSize(head);\\n        \\n        for(int i=1,ct=1;i<size;i+=ct-1){\\n            curr=prev->next;\\n            // cout<<i<<\" \";\\n            for(int j=0;j<ct-1;j++){\\n                if(ct%2==0 and i+ct-1<size){\\n                    ListNode *nxt = curr->next;\\n                    curr->next = nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                }\\n                else if(i+ct-1>=size){\\n                    int sz = findSize(curr);\\n                    // cout<<sz;\\n                    if(sz%2==0){\\n                        while(curr->next){\\n                            ListNode *nxt = curr->next;\\n                            curr->next = nxt->next;\\n                            nxt->next=prev->next;\\n                            prev->next=nxt;\\n                        }\\n                    }\\n                    else break;\\n                }\\n                else curr=curr->next;\\n            }\\n            \\n            prev=curr;\\n            ct++;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSize(ListNode *head){\\n        int ct=0;\\n        while(head) {\\n            head=head->next;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head) return head;\\n        ListNode *dummy = new ListNode(-100);\\n        dummy->next=head;\\n        ListNode *prev=dummy,*curr;\\n        \\n        int size = findSize(head);\\n        \\n        for(int i=1,ct=1;i<size;i+=ct-1){\\n            curr=prev->next;\\n            // cout<<i<<\" \";\\n            for(int j=0;j<ct-1;j++){\\n                if(ct%2==0 and i+ct-1<size){\\n                    ListNode *nxt = curr->next;\\n                    curr->next = nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                }\\n                else if(i+ct-1>=size){\\n                    int sz = findSize(curr);\\n                    // cout<<sz;\\n                    if(sz%2==0){\\n                        while(curr->next){\\n                            ListNode *nxt = curr->next;\\n                            curr->next = nxt->next;\\n                            nxt->next=prev->next;\\n                            prev->next=nxt;\\n                        }\\n                    }\\n                    else break;\\n                }\\n                else curr=curr->next;\\n            }\\n            \\n            prev=curr;\\n            ct++;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3986533,
                "title": "readable-ruby-solution-reverse-even-length-groups-in-o-n-time-o-1-space",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @return {ListNode}\\ndef reverse_even_length_groups(head)\\n    return head if !head.next || !head.next.next\\n\\n    select = head\\n    group = 1\\n    while select && select.next\\n        group += 1\\n\\n        # Check number of nodes\\n        count = 0\\n        temp = select.next\\n        while temp && count < group\\n            temp = temp.next\\n            count += 1\\n        end\\n\\n        # IF event THEN reverse\\n        if count % 2 == 0\\n            curr = select.next\\n            prev = nil\\n            for i in 0...count\\n                next_node = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = next_node\\n            end\\n\\n            tail = select.next\\n            tail.next = curr\\n            select.next = prev\\n            select = tail\\n        else\\n            for i in 0...count\\n                select = select.next\\n            end\\n        end\\n    end\\n    head\\n    # Time Complexity: O(n)\\n    # Space Complexity: O(1)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @return {ListNode}\\ndef reverse_even_length_groups(head)\\n    return head if !head.next || !head.next.next\\n\\n    select = head\\n    group = 1\\n    while select && select.next\\n        group += 1\\n\\n        # Check number of nodes\\n        count = 0\\n        temp = select.next\\n        while temp && count < group\\n            temp = temp.next\\n            count += 1\\n        end\\n\\n        # IF event THEN reverse\\n        if count % 2 == 0\\n            curr = select.next\\n            prev = nil\\n            for i in 0...count\\n                next_node = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = next_node\\n            end\\n\\n            tail = select.next\\n            tail.next = curr\\n            select.next = prev\\n            select = tail\\n        else\\n            for i in 0...count\\n                select = select.next\\n            end\\n        end\\n    end\\n    head\\n    # Time Complexity: O(n)\\n    # Space Complexity: O(1)\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986487,
                "title": "readable-typescript-solution-reverse-even-length-groups-in-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction reverseEvenLengthGroups(head: ListNode | null): ListNode | null {\\n    if (!head.next || !head.next.next) return head;\\n    \\n    let select = head;\\n    let group = 1;\\n    while (select && select.next) {\\n        group++;\\n\\n        // Check number of nodes\\n        let count = 0;\\n        let temp = select.next;\\n        while (temp && count < group) {\\n            temp = temp.next\\n            count++;\\n        }\\n\\n        // IF even THEN reverse\\n        if (count % 2 === 0) {\\n            let curr = select.next;\\n            let prev = null;\\n            for (let i = 0; i < count; i++) {\\n                const nextNode = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = nextNode;\\n            }\\n\\n            let tail = select.next;\\n            tail.next = curr;\\n            select.next = prev;\\n            select = tail;\\n        } else {\\n            for (let i = 0; i < count; i++) {\\n                select = select.next;\\n            }\\n        }\\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction reverseEvenLengthGroups(head: ListNode | null): ListNode | null {\\n    if (!head.next || !head.next.next) return head;\\n    \\n    let select = head;\\n    let group = 1;\\n    while (select && select.next) {\\n        group++;\\n\\n        // Check number of nodes\\n        let count = 0;\\n        let temp = select.next;\\n        while (temp && count < group) {\\n            temp = temp.next\\n            count++;\\n        }\\n\\n        // IF even THEN reverse\\n        if (count % 2 === 0) {\\n            let curr = select.next;\\n            let prev = null;\\n            for (let i = 0; i < count; i++) {\\n                const nextNode = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = nextNode;\\n            }\\n\\n            let tail = select.next;\\n            tail.next = curr;\\n            select.next = prev;\\n            select = tail;\\n        } else {\\n            for (let i = 0; i < count; i++) {\\n                select = select.next;\\n            }\\n        }\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984990,
                "title": "c-simple-implementation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseNode(ListNode*head){\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* nxt=head->next;\\n        while(curr!=NULL){\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        //setting head of reversed node\\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL||head->next==NULL){\\n            return head;\\n        }\\n        int group=1;\\n        ListNode* t1=head;\\n        ListNode* t2=head;\\n        //here prev and nxr refers to different context\\n        ListNode* prev=head;\\n        ListNode* nxt=head->next;\\n        ListNode* revHead=NULL;\\n        while(t1!=NULL&&t2!=NULL){\\n            if(group%2==0){\\n                //then we have to reverse it \\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                //reverse only if in even group node\\'s length is even\\n                if(count%2==0){\\n                //storing addres of t2\\'s next group\\n                nxt=t2->next;\\n                //reverse nodes from t1 to t2\\n                t2->next=NULL;\\n                revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }\\n                else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;                    \\n                }\\n            }else{\\n                //check if group lenght is even then only reverse it\\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                if(count%2==0){\\n                    //its means group length is still even so reverse it\\n                     //storing addres of t2\\'s next group\\n                    nxt=t2->next;\\n                    //reverse nodes from t1 to t2\\n                    t2->next=NULL;\\n                    revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;\\n                }\\n            }\\n            t1=nxt;\\n            t2=nxt;\\n            group++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseNode(ListNode*head){\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* nxt=head->next;\\n        while(curr!=NULL){\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        //setting head of reversed node\\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL||head->next==NULL){\\n            return head;\\n        }\\n        int group=1;\\n        ListNode* t1=head;\\n        ListNode* t2=head;\\n        //here prev and nxr refers to different context\\n        ListNode* prev=head;\\n        ListNode* nxt=head->next;\\n        ListNode* revHead=NULL;\\n        while(t1!=NULL&&t2!=NULL){\\n            if(group%2==0){\\n                //then we have to reverse it \\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                //reverse only if in even group node\\'s length is even\\n                if(count%2==0){\\n                //storing addres of t2\\'s next group\\n                nxt=t2->next;\\n                //reverse nodes from t1 to t2\\n                t2->next=NULL;\\n                revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }\\n                else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;                    \\n                }\\n            }else{\\n                //check if group lenght is even then only reverse it\\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                if(count%2==0){\\n                    //its means group length is still even so reverse it\\n                     //storing addres of t2\\'s next group\\n                    nxt=t2->next;\\n                    //reverse nodes from t1 to t2\\n                    t2->next=NULL;\\n                    revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;\\n                }\\n            }\\n            t1=nxt;\\n            t2=nxt;\\n            group++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976647,
                "title": "java-o-n-solution",
                "content": "# Intuition\\nI used ArrayList\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        ListNode temp = head;\\n        while (temp != null) {\\n            list.add(temp.val);\\n            temp = temp.next;\\n        }\\n        int idx = 0, count = 0;\\n        while (idx < list.size()) {\\n            if ((Math.min(idx + count, list.size() - 1) - idx) % 2 == 1)\\n                reverse(list, idx, Math.min(idx + count, list.size() - 1));\\n            idx += count + 1;\\n            count++;\\n        }\\n        temp = head;\\n        count = 0;\\n        while (temp != null) {\\n            temp.val = list.get(count++);\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n\\n    private static void reverse(List<Integer> list, int l, int r) {\\n        for (int i = l, k = 0; i <= (r + l) / 2; i++) {\\n            int t = list.get(r - k);\\n            list.set(r - k++, list.get(i));\\n            list.set(i, t);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        ListNode temp = head;\\n        while (temp != null) {\\n            list.add(temp.val);\\n            temp = temp.next;\\n        }\\n        int idx = 0, count = 0;\\n        while (idx < list.size()) {\\n            if ((Math.min(idx + count, list.size() - 1) - idx) % 2 == 1)\\n                reverse(list, idx, Math.min(idx + count, list.size() - 1));\\n            idx += count + 1;\\n            count++;\\n        }\\n        temp = head;\\n        count = 0;\\n        while (temp != null) {\\n            temp.val = list.get(count++);\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n\\n    private static void reverse(List<Integer> list, int l, int r) {\\n        for (int i = l, k = 0; i <= (r + l) / 2; i++) {\\n            int t = list.get(r - k);\\n            list.set(r - k++, list.get(i));\\n            list.set(i, t);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964587,
                "title": "java-beats-96-o-n-time-o-1-space-simple-solution",
                "content": "# Intuition\\nI think is HARD problem.\\nComing up with the logic of the solution is quite easy. It all consists in implementing the reversal of the linked list with the input: head, tail and the previous element behind the head\\nThe difficulty lies in writing the algorithm itself and handling the edge cases\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null) return head;\\n        ListNode node = head;\\n        ListNode temp = head;\\n        int i = 2;\\n        int ind = 0;\\n        while (node.next != null) {\\n            node = temp;\\n            ind = 0;\\n            while (ind < i && node.next != null) {\\n                node = node.next;\\n                ind++;\\n            }\\n            if ((i % 2 == 0 && node.next != null) || (node.next == null && ind % 2 == 0)) {\\n                ListNode temp1 = temp.next;\\n                temp.next = reverse(temp1, node, node.next);\\n                temp = temp1;\\n            } else if (node.next != null) {\\n                temp = node;\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail, ListNode prev1) {\\n        if (head == null) return head;\\n        ListNode prev = prev1;\\n        ListNode curr = head;\\n        ListNode next = curr.next == null ? null : curr.next;\\n        while (curr != tail) {\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            next = next.next == null ? null : next.next;\\n        }\\n        curr.next = prev;\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null) return head;\\n        ListNode node = head;\\n        ListNode temp = head;\\n        int i = 2;\\n        int ind = 0;\\n        while (node.next != null) {\\n            node = temp;\\n            ind = 0;\\n            while (ind < i && node.next != null) {\\n                node = node.next;\\n                ind++;\\n            }\\n            if ((i % 2 == 0 && node.next != null) || (node.next == null && ind % 2 == 0)) {\\n                ListNode temp1 = temp.next;\\n                temp.next = reverse(temp1, node, node.next);\\n                temp = temp1;\\n            } else if (node.next != null) {\\n                temp = node;\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail, ListNode prev1) {\\n        if (head == null) return head;\\n        ListNode prev = prev1;\\n        ListNode curr = head;\\n        ListNode next = curr.next == null ? null : curr.next;\\n        while (curr != tail) {\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            next = next.next == null ? null : next.next;\\n        }\\n        curr.next = prev;\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960822,
                "title": "don-t-use-this-code-don-t",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI am speechless, 3 - 4 hours... I am glad I kept with it but whatever you do. Don\\'t try to understand it. I was so stubborn I didn\\'t want to look up the right way to do it so I just kept trying and trying.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode * dummy = new ListNode(0, head);\\n        ListNode * curr = dummy->next;\\n        ListNode * prevNode = nullptr;\\n        ListNode * prevprevNode = nullptr;\\n\\n        int index, nodesAccessed = 0;\\n        int needToBeAcessed = 1;\\n        int groupCount = 0;\\n\\n        bool checking = false;\\n        int checkingInt = 0;\\n\\n\\n        while(curr != nullptr)\\n        {\\n            if(nodesAccessed == needToBeAcessed)\\n            {\\n\\n                ListNode * prev = nullptr;\\n                ListNode * firstNode = nullptr;\\n\\n                if(curr->next != nullptr) firstNode = curr;\\n\\n                for(int i = 0; i < (nodesAccessed + 1); i++)\\n                {\\n                    checkingInt++;\\n                    if(curr == nullptr){\\n                        checking = true;\\n                        break;\\n                    } \\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;                \\n                }\\n\\n                \\n\\n                prevNode->next = prev;\\n                if(firstNode != nullptr && curr != nullptr) firstNode->next = curr;\\n                nodesAccessed = 0; groupCount = 0; needToBeAcessed += 2; \\n\\n                if(checking != true) checkingInt = 0;\\n                if(checking != true) groupCount = 0;\\n\\n\\n            }\\n\\n            nodesAccessed++;\\n            groupCount++;\\n\\n            index++;\\n            prevNode = curr;\\n\\n            if(curr != nullptr) curr = curr->next;\\n        }\\n\\n        if(groupCount % 2 == 0)\\n        {\\n            ListNode * first = head;\\n\\n            for(int i = 0; i < groupCount + 1; i++)\\n            {\\n                first = first->next;\\n            }\\n\\n            ListNode * second = head;\\n\\n            while(first!=nullptr)\\n            {\\n                first = first->next;\\n                second = second->next;\\n            }\\n\\n\\n            ListNode * curr = second->next;\\n            ListNode * prev = nullptr;\\n\\n            for(int j = 0; j < groupCount; j++)\\n            {\\n                if(curr == nullptr) break;\\n                ListNode* nextNode = curr->next; \\n                curr->next = prev;            \\n                prev = curr;                   \\n                curr = nextNode;   \\n            }\\n\\n            second->next = prev;\\n\\n        }\\n\\n        if(checking == true)\\n        {\\n            if(checkingInt % 2 == 0){\\n\\n\\n                ListNode * first = head;\\n\\n                for(int i = 0; i < checkingInt; i++)\\n                {\\n                    first = first->next;\\n                }\\n\\n                ListNode * second = head;\\n\\n                while(first!=nullptr)\\n                {\\n                    first = first->next;\\n                    second = second->next;\\n                }\\n\\n                ListNode * curr = second->next;\\n                ListNode * prev = nullptr;\\n\\n\\n\\n\\n                \\n\\n                for(int j = 0; j < checkingInt; j++)\\n                {\\n                    if(curr == nullptr) break;\\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;   \\n                }\\n                \\n\\n                second->next = prev;\\n            }\\n        }\\n\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode * dummy = new ListNode(0, head);\\n        ListNode * curr = dummy->next;\\n        ListNode * prevNode = nullptr;\\n        ListNode * prevprevNode = nullptr;\\n\\n        int index, nodesAccessed = 0;\\n        int needToBeAcessed = 1;\\n        int groupCount = 0;\\n\\n        bool checking = false;\\n        int checkingInt = 0;\\n\\n\\n        while(curr != nullptr)\\n        {\\n            if(nodesAccessed == needToBeAcessed)\\n            {\\n\\n                ListNode * prev = nullptr;\\n                ListNode * firstNode = nullptr;\\n\\n                if(curr->next != nullptr) firstNode = curr;\\n\\n                for(int i = 0; i < (nodesAccessed + 1); i++)\\n                {\\n                    checkingInt++;\\n                    if(curr == nullptr){\\n                        checking = true;\\n                        break;\\n                    } \\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;                \\n                }\\n\\n                \\n\\n                prevNode->next = prev;\\n                if(firstNode != nullptr && curr != nullptr) firstNode->next = curr;\\n                nodesAccessed = 0; groupCount = 0; needToBeAcessed += 2; \\n\\n                if(checking != true) checkingInt = 0;\\n                if(checking != true) groupCount = 0;\\n\\n\\n            }\\n\\n            nodesAccessed++;\\n            groupCount++;\\n\\n            index++;\\n            prevNode = curr;\\n\\n            if(curr != nullptr) curr = curr->next;\\n        }\\n\\n        if(groupCount % 2 == 0)\\n        {\\n            ListNode * first = head;\\n\\n            for(int i = 0; i < groupCount + 1; i++)\\n            {\\n                first = first->next;\\n            }\\n\\n            ListNode * second = head;\\n\\n            while(first!=nullptr)\\n            {\\n                first = first->next;\\n                second = second->next;\\n            }\\n\\n\\n            ListNode * curr = second->next;\\n            ListNode * prev = nullptr;\\n\\n            for(int j = 0; j < groupCount; j++)\\n            {\\n                if(curr == nullptr) break;\\n                ListNode* nextNode = curr->next; \\n                curr->next = prev;            \\n                prev = curr;                   \\n                curr = nextNode;   \\n            }\\n\\n            second->next = prev;\\n\\n        }\\n\\n        if(checking == true)\\n        {\\n            if(checkingInt % 2 == 0){\\n\\n\\n                ListNode * first = head;\\n\\n                for(int i = 0; i < checkingInt; i++)\\n                {\\n                    first = first->next;\\n                }\\n\\n                ListNode * second = head;\\n\\n                while(first!=nullptr)\\n                {\\n                    first = first->next;\\n                    second = second->next;\\n                }\\n\\n                ListNode * curr = second->next;\\n                ListNode * prev = nullptr;\\n\\n\\n\\n\\n                \\n\\n                for(int j = 0; j < checkingInt; j++)\\n                {\\n                    if(curr == nullptr) break;\\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;   \\n                }\\n                \\n\\n                second->next = prev;\\n            }\\n        }\\n\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953470,
                "title": "java-use-list-to-reverse-even-group-items",
                "content": "# Intuition\\n# Approach\\n- Traverse linked list for # group items and add into a list\\n- if even items in group, reverse items in list\\n- From start of group node, replace values of node using reversed list\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr != null) {\\n            count++;\\n            int i=0;\\n            ListNode start = curr;\\n            List<Integer> nums = new ArrayList<>();\\n            while(i<count && curr != null) {\\n                nums.add(curr.val);\\n                curr = curr.next;\\n                i++;\\n            }\\n            if(i%2 == 0) {\\n                Collections.reverse(nums);\\n                for(int j = 0; j<i; j++) {\\n                    start.val = nums.get(j);\\n                    start = start.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr != null) {\\n            count++;\\n            int i=0;\\n            ListNode start = curr;\\n            List<Integer> nums = new ArrayList<>();\\n            while(i<count && curr != null) {\\n                nums.add(curr.val);\\n                curr = curr.next;\\n                i++;\\n            }\\n            if(i%2 == 0) {\\n                Collections.reverse(nums);\\n                for(int j = 0; j<i; j++) {\\n                    start.val = nums.get(j);\\n                    start = start.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946091,
                "title": "kotlin-two-pointers",
                "content": "# Intuition\\nI\\'m new here and this problem turned out to be hard for me, so I used the hints and that\\'s what I\\'ve got :)\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var prevGroup: ListNode? = null   // pointer to the end of the previous group\\n        var begGroup = head               // pointer to the beginning of the current group\\n        var endGroup = head               // pointer to the end of the current group\\n        var nextGroup = head?.next        // pointer to the next group\\n        var groupCount = 1\\n\\n        while (nextGroup?.next != null) {\\n            groupCount++\\n\\n            // depends on whether the previous group was even or not\\n            prevGroup = if (groupCount % 2 == 0) endGroup else begGroup\\n            begGroup = nextGroup\\n            endGroup = begGroup\\n\\n            // traverse through a group\\n            var groupLength = 1\\n            while (groupLength < groupCount && endGroup?.next != null) {\\n                endGroup = endGroup.next\\n                groupLength++\\n            }\\n            nextGroup = endGroup?.next\\n\\n            // reverse the group if the group length is even\\n            if (groupLength % 2 == 0) {\\n                reverseList(begGroup, prevGroup, nextGroup)\\n\\n                // fix the connections\\n                prevGroup!!.next = endGroup\\n                if (begGroup != null) {\\n                    begGroup!!.next = nextGroup\\n                }\\n            }\\n        }\\n\\n        return head\\n    }\\n\\n    fun reverseList(currNode: ListNode?, prevNode: ListNode?, nextGroup: ListNode?) {\\n        var curr = currNode\\n        var prev = prevNode\\n\\n        while (curr != nextGroup) {\\n            val nextNode = curr?.next\\n            curr!!.next = prev\\n            prev = curr\\n            curr = nextNode\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var prevGroup: ListNode? = null   // pointer to the end of the previous group\\n        var begGroup = head               // pointer to the beginning of the current group\\n        var endGroup = head               // pointer to the end of the current group\\n        var nextGroup = head?.next        // pointer to the next group\\n        var groupCount = 1\\n\\n        while (nextGroup?.next != null) {\\n            groupCount++\\n\\n            // depends on whether the previous group was even or not\\n            prevGroup = if (groupCount % 2 == 0) endGroup else begGroup\\n            begGroup = nextGroup\\n            endGroup = begGroup\\n\\n            // traverse through a group\\n            var groupLength = 1\\n            while (groupLength < groupCount && endGroup?.next != null) {\\n                endGroup = endGroup.next\\n                groupLength++\\n            }\\n            nextGroup = endGroup?.next\\n\\n            // reverse the group if the group length is even\\n            if (groupLength % 2 == 0) {\\n                reverseList(begGroup, prevGroup, nextGroup)\\n\\n                // fix the connections\\n                prevGroup!!.next = endGroup\\n                if (begGroup != null) {\\n                    begGroup!!.next = nextGroup\\n                }\\n            }\\n        }\\n\\n        return head\\n    }\\n\\n    fun reverseList(currNode: ListNode?, prevNode: ListNode?, nextGroup: ListNode?) {\\n        var curr = currNode\\n        var prev = prevNode\\n\\n        while (curr != nextGroup) {\\n            val nextNode = curr?.next\\n            curr!!.next = prev\\n            prev = curr\\n            curr = nextNode\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943025,
                "title": "simple-solution-with-recursion-o-n",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n \\n        prev_node, cnt, len_group = head, 1, 1\\n        while prev_node.next:\\n            if cnt == len_group:\\n                last_group = prev_node\\n                if len_group%2:\\n                    node = prev_node.next\\n                    new_head, next_node = self.reverseList(node, len_group, 0)\\n                    if new_head:             \\n                        prev_node.next = new_head\\n                        node.next = next_node\\n                    if not next_node:\\n                        return head             \\n                cnt = 0\\n                len_group += 1\\n            cnt += 1           \\n            prev_node = prev_node.next\\n            \\n        if last_group.next:\\n            node = last_group.next\\n            new_head, _ = self.reverseList(node, len_group, 0)\\n            if new_head:             \\n                last_group.next = new_head\\n                node.next = None\\n        return head  \\n\\n    def reverseList(self, head: Optional[ListNode], k, cnt) -> Optional[ListNode]:\\n        if k == cnt:\\n            return head, head.next\\n        if not head.next and cnt%2:\\n            return head, None\\n        elif not head.next:\\n            return None, None\\n        new_head, next_node = self.reverseList(head.next, k, cnt+1)\\n        if new_head:\\n            head.next.next = head\\n        return new_head, next_node\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n \\n        prev_node, cnt, len_group = head, 1, 1\\n        while prev_node.next:\\n            if cnt == len_group:\\n                last_group = prev_node\\n                if len_group%2:\\n                    node = prev_node.next\\n                    new_head, next_node = self.reverseList(node, len_group, 0)\\n                    if new_head:             \\n                        prev_node.next = new_head\\n                        node.next = next_node\\n                    if not next_node:\\n                        return head             \\n                cnt = 0\\n                len_group += 1\\n            cnt += 1           \\n            prev_node = prev_node.next\\n            \\n        if last_group.next:\\n            node = last_group.next\\n            new_head, _ = self.reverseList(node, len_group, 0)\\n            if new_head:             \\n                last_group.next = new_head\\n                node.next = None\\n        return head  \\n\\n    def reverseList(self, head: Optional[ListNode], k, cnt) -> Optional[ListNode]:\\n        if k == cnt:\\n            return head, head.next\\n        if not head.next and cnt%2:\\n            return head, None\\n        elif not head.next:\\n            return None, None\\n        new_head, next_node = self.reverseList(head.next, k, cnt+1)\\n        if new_head:\\n            head.next.next = head\\n        return new_head, next_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938887,
                "title": "java-solution-o-n-time-and-in-place",
                "content": "\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode cur = head;\\n        ListNode pre = head;\\n        int distance = 1;\\n        int remain = 0;\\n        while (cur != null) {\\n            remain++;\\n            cur = cur.next;\\n        }\\n        cur = head;\\n\\n        while (cur != null && cur.next != null) {\\n            if ((remain >= distance && distance % 2 == 1) || (remain < distance && remain % 2 == 1)) { // keep\\n                for (int i = 0; i < distance && cur.next != null; i++) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else { // reverse\\n                for (int i = 0; i < distance - 1 && cur.next != null; i++) {\\n                    ListNode newCur = cur.next;\\n                    cur.next = newCur.next;\\n                    newCur.next = pre.next;\\n                    pre.next = newCur;\\n                }\\n                if (cur.next != null) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n            remain -= distance;\\n            distance++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode cur = head;\\n        ListNode pre = head;\\n        int distance = 1;\\n        int remain = 0;\\n        while (cur != null) {\\n            remain++;\\n            cur = cur.next;\\n        }\\n        cur = head;\\n\\n        while (cur != null && cur.next != null) {\\n            if ((remain >= distance && distance % 2 == 1) || (remain < distance && remain % 2 == 1)) { // keep\\n                for (int i = 0; i < distance && cur.next != null; i++) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else { // reverse\\n                for (int i = 0; i < distance - 1 && cur.next != null; i++) {\\n                    ListNode newCur = cur.next;\\n                    cur.next = newCur.next;\\n                    newCur.next = pre.next;\\n                    pre.next = newCur;\\n                }\\n                if (cur.next != null) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n            remain -= distance;\\n            distance++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937333,
                "title": "java-easiest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp=head;\\n        int num=1;\\n        while(temp!=null){\\n            int count=0;\\n            ListNode start=temp;\\n            Stack st=new Stack();\\n            while(count!=num && temp!=null){\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n            }\\n            if(count%2==0){\\n                while(temp!=start){\\n                    start.val=(int) st.pop();\\n                    start=start.next;\\n                }\\n            }\\n            num++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp=head;\\n        int num=1;\\n        while(temp!=null){\\n            int count=0;\\n            ListNode start=temp;\\n            Stack st=new Stack();\\n            while(count!=num && temp!=null){\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n            }\\n            if(count%2==0){\\n                while(temp!=start){\\n                    start.val=(int) st.pop();\\n                    start=start.next;\\n                }\\n            }\\n            num++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924897,
                "title": "python-simple-solution-not-reverse-linked-list-in-place",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        while head:\\n            l.append(head)\\n            head = head.next\\n        n = len(l)\\n        start, end, cur = 0, 1, 1\\n        while end <= n:\\n            if cur%2 == 0:\\n                #reverse\\n                l[start:end] = l[start:end][::-1]\\n            start += cur\\n            cur += 1\\n            end += cur\\n        if (n-start)%2 == 0: l[start:n] = l[start:n][::-1]\\n\\n        node = dummy = ListNode()\\n        for n in l:\\n            node.next = n\\n            node = node.next\\n        node.next = None\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        while head:\\n            l.append(head)\\n            head = head.next\\n        n = len(l)\\n        start, end, cur = 0, 1, 1\\n        while end <= n:\\n            if cur%2 == 0:\\n                #reverse\\n                l[start:end] = l[start:end][::-1]\\n            start += cur\\n            cur += 1\\n            end += cur\\n        if (n-start)%2 == 0: l[start:n] = l[start:n][::-1]\\n\\n        node = dummy = ListNode()\\n        for n in l:\\n            node.next = n\\n            node = node.next\\n        node.next = None\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921501,
                "title": "explained-beats-98-c-recursive-approach-for-multiple-question",
                "content": "# Intuition\\nIs same as, Solve below in order for better understanding. \\n1. https://leetcode.com/problems/swap-nodes-in-pairs/\\n2. https://leetcode.com/problems/reverse-nodes-in-k-group/\\n\\n# Approach\\nWe will use recursive approach to handle dynamic length reversal.\\n\\nTo handling last group case\\n### Observation \\nIt can be happend in both odd/even group case when \\'curr\\' become NULL. Also you can say, last group len will always <= current group.\\n### Requirement\\nReverse the nodes in each group with an even length\\n\\nSo last group may be of any length in both cases.\\nwe can find the length using \\'k\\'. and perform re-reverse/reverse operation corresponding to if/else statement.\\n\\nIn event group case i.e. if condition, if remaining \\'k\\' is odd -> len(last group) is odd. re-reverse needed.\\n\\nIn odd  group case i.e. else condition, if remaining \\'k\\' = odd -> len(last group) is even. reverse needed.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ for recursive stack\\n\\n# Code\\n```\\nclass Solution {\\n    // for handling last group case only\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* prev = NULL, *curr = head, *next = NULL;\\n\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n        if(!head) return head;\\n\\n        ListNode *prev = NULL, *curr = head, *next = NULL;\\n        int k = group;\\n\\n        if(k % 2 == 0) {\\n            while(curr && k) {\\n                next = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = next;\\n                k--;\\n            }\\n            head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in even group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will odd, so we will revert.\\n                return reverse(prev);\\n            }\\n            return prev;\\n\\n        } else {\\n            while(curr && k) {\\n                prev = curr;\\n                curr = curr->next;\\n                k--;\\n            }\\n\\n            prev->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in odd group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will even, so we will reverse it.\\n                return reverse(head);\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n\\n```\\n### Below code just for reference\\n```\\n// In below code the last group case is not handled\\n\\nListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n    if(!head) return head;\\n\\n    ListNode *prev = NULL, *curr = head, *next = NULL;\\n    int k = group;\\n\\n    if(k % 2 == 0) {\\n        while(curr && k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            k--;\\n        }\\n        head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n        return prev;\\n\\n    } else {\\n        while(curr && k) {\\n            prev = curr;\\n            curr = curr->next;\\n            k--;\\n        }\\n        prev->next = reverseEvenLengthGroups(curr, group+1);\\n    }\\n\\n    return head;\\n}\\n```\\n# Please Vote Up",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    // for handling last group case only\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* prev = NULL, *curr = head, *next = NULL;\\n\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n        if(!head) return head;\\n\\n        ListNode *prev = NULL, *curr = head, *next = NULL;\\n        int k = group;\\n\\n        if(k % 2 == 0) {\\n            while(curr && k) {\\n                next = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = next;\\n                k--;\\n            }\\n            head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in even group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will odd, so we will revert.\\n                return reverse(prev);\\n            }\\n            return prev;\\n\\n        } else {\\n            while(curr && k) {\\n                prev = curr;\\n                curr = curr->next;\\n                k--;\\n            }\\n\\n            prev->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in odd group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will even, so we will reverse it.\\n                return reverse(head);\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n\\n```\n```\\n// In below code the last group case is not handled\\n\\nListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n    if(!head) return head;\\n\\n    ListNode *prev = NULL, *curr = head, *next = NULL;\\n    int k = group;\\n\\n    if(k % 2 == 0) {\\n        while(curr && k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            k--;\\n        }\\n        head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n        return prev;\\n\\n    } else {\\n        while(curr && k) {\\n            prev = curr;\\n            curr = curr->next;\\n            k--;\\n        }\\n        prev->next = reverseEvenLengthGroups(curr, group+1);\\n    }\\n\\n    return head;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918520,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 3 ms ( O ( n ) )\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverse(ListNode head){\\n         ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n         while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n       \\n        return prev;\\n    }\\n    public ListNode solve(ListNode head,int n){\\n        if(head==null) return null;\\n        ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        int c=0;\\n        if(n%2==1){\\n           while(curr!=null&&c<n){\\n               next=curr;\\n                curr=curr.next;\\n                c++;\\n           }\\n           if(c%2==0) return solve(head,n-1);\\n           if(curr!=null) next.next=solve(curr,n+1);\\n           return head;\\n\\n        }\\n        while(curr!=null&&c<n){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n            c++;\\n        }\\n        if(c%2==1) return reverse(prev);\\n        if(next!=null) head.next=solve(next,n+1);\\n        return prev;\\n\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        return solve(head,1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverse(ListNode head){\\n         ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n         while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n       \\n        return prev;\\n    }\\n    public ListNode solve(ListNode head,int n){\\n        if(head==null) return null;\\n        ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        int c=0;\\n        if(n%2==1){\\n           while(curr!=null&&c<n){\\n               next=curr;\\n                curr=curr.next;\\n                c++;\\n           }\\n           if(c%2==0) return solve(head,n-1);\\n           if(curr!=null) next.next=solve(curr,n+1);\\n           return head;\\n\\n        }\\n        while(curr!=null&&c<n){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n            c++;\\n        }\\n        if(c%2==1) return reverse(prev);\\n        if(next!=null) head.next=solve(next,n+1);\\n        return prev;\\n\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        return solve(head,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909824,
                "title": "c-linked-list-beats-77-62-of-users-with-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n #define null NULL\\nclass Solution {\\npublic:\\n     ListNode* prev=null,*temp,*curr;\\n     int i,n;\\n     void even()\\n     {\\n                 int count=i;\\n                 temp=curr;\\n                 vector<int>vt;\\n                 while(count--&&temp!=null) \\n                 {\\n                     vt.insert(vt.begin(),temp->val);\\n                     temp=temp->next;\\n                 }\\n                 count=i;\\n                 int n=0;\\n                 while(count--&&curr!=null)\\n                {\\n                    curr->val=vt[n++];\\n                    prev=curr;\\n                    curr=curr->next;\\n                   \\n                }\\n\\n     }\\n     void odd()\\n     {\\n                int count=i;\\n                while(count--&&curr!=null)\\n                {\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n     }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n         i=1;\\n         curr=head;\\n        temp=head;\\n        while(temp!=null) \\n        {\\n            n++;\\n            temp=temp->next;\\n        }\\n        while(curr!=null)\\n        {\\n            if(i%2==0)\\n            {\\n                int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2==0) even();\\n                     else odd();\\n                 }\\n                 else even();\\n            }\\n            else\\n            {\\n                  int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2!=0) odd();\\n                     else even();\\n                 }\\n                 else odd();\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n #define null NULL\\nclass Solution {\\npublic:\\n     ListNode* prev=null,*temp,*curr;\\n     int i,n;\\n     void even()\\n     {\\n                 int count=i;\\n                 temp=curr;\\n                 vector<int>vt;\\n                 while(count--&&temp!=null) \\n                 {\\n                     vt.insert(vt.begin(),temp->val);\\n                     temp=temp->next;\\n                 }\\n                 count=i;\\n                 int n=0;\\n                 while(count--&&curr!=null)\\n                {\\n                    curr->val=vt[n++];\\n                    prev=curr;\\n                    curr=curr->next;\\n                   \\n                }\\n\\n     }\\n     void odd()\\n     {\\n                int count=i;\\n                while(count--&&curr!=null)\\n                {\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n     }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n         i=1;\\n         curr=head;\\n        temp=head;\\n        while(temp!=null) \\n        {\\n            n++;\\n            temp=temp->next;\\n        }\\n        while(curr!=null)\\n        {\\n            if(i%2==0)\\n            {\\n                int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2==0) even();\\n                     else odd();\\n                 }\\n                 else even();\\n            }\\n            else\\n            {\\n                  int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2!=0) odd();\\n                     else even();\\n                 }\\n                 else odd();\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887165,
                "title": "very-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int group = 1;\\n        ListNode node = head;\\n        while(node!=null && node.next!=null){\\n            group++;\\n            int countGps=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && countGps<group ){\\n                temp=temp.next;\\n                countGps++;\\n            }\\n            if(countGps % 2==0){\\n                ListNode present = node.next;\\n                ListNode newEnd = present;\\n                ListNode prev = node;\\n                ListNode next= present.next;\\n                for(int i =0 ; i<countGps ; i++){\\n                    present.next=prev;\\n                    prev=present;\\n                    present=next;\\n                    if(next!=null){\\n                        next=next.next;\\n                    }\\n                   node.next=prev;\\n                   newEnd.next=present;\\n\\n\\n                }\\n                node=newEnd;\\n            }else{\\n                for(int i =0 ; i<countGps ;i++){\\n                    node = node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int group = 1;\\n        ListNode node = head;\\n        while(node!=null && node.next!=null){\\n            group++;\\n            int countGps=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && countGps<group ){\\n                temp=temp.next;\\n                countGps++;\\n            }\\n            if(countGps % 2==0){\\n                ListNode present = node.next;\\n                ListNode newEnd = present;\\n                ListNode prev = node;\\n                ListNode next= present.next;\\n                for(int i =0 ; i<countGps ; i++){\\n                    present.next=prev;\\n                    prev=present;\\n                    present=next;\\n                    if(next!=null){\\n                        next=next.next;\\n                    }\\n                   node.next=prev;\\n                   newEnd.next=present;\\n\\n\\n                }\\n                node=newEnd;\\n            }else{\\n                for(int i =0 ; i<countGps ;i++){\\n                    node = node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886130,
                "title": "simple-and-fast-java-solution-list-l",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null){\\n            return head;\\n        }\\n\\n        int grup=1;\\n        ListNode node=head;\\n        while(node!=null && node.next!=null){\\n            grup++;\\n            int ct=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && ct<grup){\\n                temp=temp.next;\\n                ct++;\\n            }\\n\\n            if(ct%2==0){\\n                ListNode curr=node.next;\\n                ListNode prev=null;\\n                ListNode nextNode =null;\\n\\n                for(int i=0;i<ct;i++){\\n                    nextNode=curr.next;\\n                    curr.next=prev;\\n                    prev=curr;\\n                    curr=nextNode;\\n                }\\n                ListNode tail=node.next;\\n                tail.next=curr;\\n                node.next=prev;\\n                node=tail;\\n            }\\n            else{\\n                for(int i=0;i<ct;i++){\\n                    node=node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null){\\n            return head;\\n        }\\n\\n        int grup=1;\\n        ListNode node=head;\\n        while(node!=null && node.next!=null){\\n            grup++;\\n            int ct=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && ct<grup){\\n                temp=temp.next;\\n                ct++;\\n            }\\n\\n            if(ct%2==0){\\n                ListNode curr=node.next;\\n                ListNode prev=null;\\n                ListNode nextNode =null;\\n\\n                for(int i=0;i<ct;i++){\\n                    nextNode=curr.next;\\n                    curr.next=prev;\\n                    prev=curr;\\n                    curr=nextNode;\\n                }\\n                ListNode tail=node.next;\\n                tail.next=curr;\\n                node.next=prev;\\n                node=tail;\\n            }\\n            else{\\n                for(int i=0;i<ct;i++){\\n                    node=node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881612,
                "title": "java-in-memory",
                "content": "# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        int groupSize = 1; \\n\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        head = dummy; \\n\\n        while(head!=null && head.next!=null){\\n\\n            ListNode currentGroupStartNode = head.next;  \\n            ListNode temp = head; \\n            int count = 0; \\n            \\n            while(count < groupSize && temp.next!=null){\\n                temp = temp.next; \\n                count++; \\n            }\\n\\n            ListNode currentGroupEndNode = temp;\\n            ListNode nextGroupStartNode = currentGroupEndNode == null ? null : currentGroupEndNode.next; \\n\\n            boolean shouldReverse = count%2==0; \\n            if(shouldReverse){   \\n                head.next = reverse(currentGroupStartNode, nextGroupStartNode, nextGroupStartNode);\\n                head = currentGroupStartNode; \\n            }else{\\n                head = currentGroupEndNode; \\n            }\\n\\n            groupSize++;\\n        }\\n        return dummy.next; \\n    }\\n\\n    ListNode reverse(ListNode startInclusive, ListNode endNodeExclusive, ListNode currentReverse){\\n        ListNode temp = startInclusive; \\n        while(temp != endNodeExclusive){\\n            ListNode tempNext = temp.next;\\n            temp.next = currentReverse;\\n            currentReverse = temp; \\n            temp = tempNext;\\n        }\\n        return currentReverse; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        int groupSize = 1; \\n\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        head = dummy; \\n\\n        while(head!=null && head.next!=null){\\n\\n            ListNode currentGroupStartNode = head.next;  \\n            ListNode temp = head; \\n            int count = 0; \\n            \\n            while(count < groupSize && temp.next!=null){\\n                temp = temp.next; \\n                count++; \\n            }\\n\\n            ListNode currentGroupEndNode = temp;\\n            ListNode nextGroupStartNode = currentGroupEndNode == null ? null : currentGroupEndNode.next; \\n\\n            boolean shouldReverse = count%2==0; \\n            if(shouldReverse){   \\n                head.next = reverse(currentGroupStartNode, nextGroupStartNode, nextGroupStartNode);\\n                head = currentGroupStartNode; \\n            }else{\\n                head = currentGroupEndNode; \\n            }\\n\\n            groupSize++;\\n        }\\n        return dummy.next; \\n    }\\n\\n    ListNode reverse(ListNode startInclusive, ListNode endNodeExclusive, ListNode currentReverse){\\n        ListNode temp = startInclusive; \\n        while(temp != endNodeExclusive){\\n            ListNode tempNext = temp.next;\\n            temp.next = currentReverse;\\n            currentReverse = temp; \\n            temp = tempNext;\\n        }\\n        return currentReverse; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874081,
                "title": "python-simple-solutions-faster-than-98-6-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        def get_size(node, last_length):\\n            length = 0\\n            while node:\\n                length+=1\\n                if length==last_length+1:\\n                    return length, node\\n                node = node.next\\n            return length, None\\n\\n        def reverse(node, curr_length):\\n            prev = None\\n            curr = node\\n            while curr_length>0:\\n                curr_length-=1\\n                next = curr.next\\n                curr.next = prev\\n                prev, curr = curr, next\\n\\n            return prev, node\\n\\n\\n        last_length = 1\\n        curr = head\\n        while curr and curr.next:\\n            last_length, last_node = get_size(curr.next, last_length)\\n            if last_length%2==0:\\n                if last_node:\\n                    last_node = last_node.next\\n                sub_head, tail = reverse(curr.next, last_length)\\n                curr.next = sub_head\\n                tail.next = last_node\\n                curr = tail\\n            else:\\n                curr = last_node\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        def get_size(node, last_length):\\n            length = 0\\n            while node:\\n                length+=1\\n                if length==last_length+1:\\n                    return length, node\\n                node = node.next\\n            return length, None\\n\\n        def reverse(node, curr_length):\\n            prev = None\\n            curr = node\\n            while curr_length>0:\\n                curr_length-=1\\n                next = curr.next\\n                curr.next = prev\\n                prev, curr = curr, next\\n\\n            return prev, node\\n\\n\\n        last_length = 1\\n        curr = head\\n        while curr and curr.next:\\n            last_length, last_node = get_size(curr.next, last_length)\\n            if last_length%2==0:\\n                if last_node:\\n                    last_node = last_node.next\\n                sub_head, tail = reverse(curr.next, last_length)\\n                curr.next = sub_head\\n                tail.next = last_node\\n                curr = tail\\n            else:\\n                curr = last_node\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870545,
                "title": "java-in-memory-reverse-time-6ms-beats-74-84-users-space-68-45mb-beats-68-54-users",
                "content": "# Intuition\\nUse in-memory reverse.\\n\\n# Approach\\n->Use in-memory reverse approach.\\n->check if current group is last or not, i.e. no. of unprocessed nodes is >= 1 + processed_group_len, is it\\'s NOT last then return -1 from isLastG(); method.\\n->if not last group, then increament \\'gLen\\' by 1 otherwise use lastGLen as \\'gLen\\'\\n->if, \\'gLen\\' is add then do NOT reversing and skip \\'gLen\\' no. of nodes of current odd group.\\n->otherwise, start reversing \"even\" group nodes as follows:-\\n\\n    -NOTE : before reversing current even-group, the first-node of even-group will become the last-node of even-group, post reversing the order by changing the \\'cur.next\\' pointer. Hence, we can take it\\'s reference for backup in \\'evenEnd\\'(variable) so that after reversing the even-group nodes the last node of even-group (i.e. \\'evenEnd\\') can be further connected to next-group first node.\\n\\n    ex : evenEnd.next = next;\\n\\n    -Also, after reversing the even-group nodes \\'prev\\' pointer would become the first-node of the reversed even-group. Hence it also need to be linked to last-node of previous group.\\n\\n    ex : prevGEnd.next = prev;\\n\\n    -Also after each reversing of even-group nodes, we need to keep updating the \\'prevGEnd\\' pointer with \\'evenEnd\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int gLen = 0;\\n        ListNode cur = head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        \\n        ListNode prevGEnd = null;\\n        ListNode evenEnd = null;\\n        int count = 0;\\n        int skip = 0;\\n        int isLastG = 0;\\n        boolean isNotLastGroup = false;\\n\\n        while (cur != null) {\\n            isLastG = isLastG(cur, gLen);\\n            isNotLastGroup = isLastG == -1 ? true : false;\\n            if (isNotLastGroup) {\\n                gLen++;\\n            } else if (!isNotLastGroup) {\\n                gLen = isLastG;\\n            }\\n\\n            if ((gLen & 1) == 0) {\\n                evenEnd = cur;\\n\\n                //rev start\\n                count = gLen;\\n                prev = null;\\n                next = null;\\n                while (count-- != 0) {\\n                    next = cur.next;\\n                    cur.next = prev;\\n                    prev = cur;\\n                    cur = next;\\n                }\\n                //rev end                \\n                \\n                prevGEnd.next = prev;\\n                evenEnd.next = next;\\n                prevGEnd = evenEnd;\\n            } else {\\n                skip = gLen;\\n                while (skip-- != 0) {\\n                    prevGEnd = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n        }\\n        return head;        \\n    }\\n\\n    public int isLastG(ListNode cur, int prevGLen) {\\n        int count = 0;\\n        while (cur != null) {\\n            cur = cur.next;\\n            count++;\\n            if (count > (prevGLen+1)) {\\n                count = -1;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int gLen = 0;\\n        ListNode cur = head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        \\n        ListNode prevGEnd = null;\\n        ListNode evenEnd = null;\\n        int count = 0;\\n        int skip = 0;\\n        int isLastG = 0;\\n        boolean isNotLastGroup = false;\\n\\n        while (cur != null) {\\n            isLastG = isLastG(cur, gLen);\\n            isNotLastGroup = isLastG == -1 ? true : false;\\n            if (isNotLastGroup) {\\n                gLen++;\\n            } else if (!isNotLastGroup) {\\n                gLen = isLastG;\\n            }\\n\\n            if ((gLen & 1) == 0) {\\n                evenEnd = cur;\\n\\n                //rev start\\n                count = gLen;\\n                prev = null;\\n                next = null;\\n                while (count-- != 0) {\\n                    next = cur.next;\\n                    cur.next = prev;\\n                    prev = cur;\\n                    cur = next;\\n                }\\n                //rev end                \\n                \\n                prevGEnd.next = prev;\\n                evenEnd.next = next;\\n                prevGEnd = evenEnd;\\n            } else {\\n                skip = gLen;\\n                while (skip-- != 0) {\\n                    prevGEnd = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n        }\\n        return head;        \\n    }\\n\\n    public int isLastG(ListNode cur, int prevGLen) {\\n        int count = 0;\\n        while (cur != null) {\\n            cur = cur.next;\\n            count++;\\n            if (count > (prevGLen+1)) {\\n                count = -1;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837513,
                "title": "using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode ReverseEvenLengthGroups(ListNode head) {\\n        Stack s=new Stack();\\n        int c=1;\\n        var p=head;\\n        while(head!=null){\\n                var t=head;\\n                for(int i=0;i<c;i++){\\n                            if(head!=null){\\n                                s.Push(head.val);\\n                                head=head.next;\\n                            }\\n                        }\\n                    if(s.Count%2==0 ){\\n                        for(int i=0;i<c;i++){\\n                            if(t!=null){\\n                                t.val=(int)s.Pop();\\n                                t=t.next;\\n                            }\\n                        }\\n                    }\\n                s.Clear();\\n                c=c+1;\\n                }\\n              return p;\\n        }\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode ReverseEvenLengthGroups(ListNode head) {\\n        Stack s=new Stack();\\n        int c=1;\\n        var p=head;\\n        while(head!=null){\\n                var t=head;\\n                for(int i=0;i<c;i++){\\n                            if(head!=null){\\n                                s.Push(head.val);\\n                                head=head.next;\\n                            }\\n                        }\\n                    if(s.Count%2==0 ){\\n                        for(int i=0;i<c;i++){\\n                            if(t!=null){\\n                                t.val=(int)s.Pop();\\n                                t=t.next;\\n                            }\\n                        }\\n                    }\\n                s.Clear();\\n                c=c+1;\\n                }\\n              return p;\\n        }\\n    }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824032,
                "title": "800-ms-c-solution",
                "content": "# Intuition\\nThis problem is about traversal, reversal and counting the number of elements in the list. \\n\\n# Approach\\nSplit the problem into groups, meaning either traverse the group without changing it or reverse the group depending on the length of the group.\\n\\nLength of the group ==> group number itself, except the last group which could be length of remaining elements or group number itself. \\n\\nTo compute the length of the last group, we keep a counter \"count\" which returns the number of nodes seen thus far. In addition, we also need to know the number of nodes in the list, via `calcLength()` function. \\n\\n\\nHence, we need two methods: \\n1. `reverseN()` that reverses a list of length N while returning tail of the new list.\\n2. `traverseN()` that traverses the list of N nodes, either stops the traversal at reaching sentinel or if the method has traversed N nodes. Returns the last element of the list.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // reverses the list starting at head until head+group \\n    // and connects the reversed list to prev.\\n    ListNode* reverseN(ListNode* head, ListNode* prev, int num_nodes) {\\n        ListNode* cur = head;\\n        int i = 1;\\n        while(cur != NULL && i <= num_nodes) {\\n            ListNode* temp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = temp;\\n            i++;\\n        }\\n        // head->next is pointing to original prev but prev is pointing\\n        // to last node of the current list\\n        // hence, point previous list end node to new list\\'s head\\n        head->next->next = prev;\\n\\n        // point the last node of the new list to first node of the \\n        // next group\\n        head->next = cur;\\n        return head;\\n    }\\n\\n    int calcLength(ListNode* cur) {\\n        int i = 0;\\n        while(cur != NULL) {\\n            i++;\\n            cur = cur->next;\\n        }\\n        return i;\\n    }\\n\\n    ListNode* traverseN(ListNode* cur, int n) {\\n        int i = 1;\\n        while(cur != NULL && i < n) {\\n            cur = cur->next;\\n            i++;\\n        }\\n        return cur;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len = calcLength(head);\\n\\n        int count = 0;\\n        int group_num = 0;\\n        int group_len = 0;\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        while(cur != NULL) {\\n            group_num++;\\n            group_len = min(len-count, group_num);\\n\\n            // reverse an even group\\n            if (group_len%2 == 0) {\\n                cur = reverseN(cur, prev, group_len);\\n                count += group_len;\\n            } else {\\n                cur = traverseN(cur, group_len);\\n                count += group_len;\\n            }\\n\\n            prev = cur;\\n            if (cur != NULL) {\\n                 cur = cur->next;    \\n            } \\n              \\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // reverses the list starting at head until head+group \\n    // and connects the reversed list to prev.\\n    ListNode* reverseN(ListNode* head, ListNode* prev, int num_nodes) {\\n        ListNode* cur = head;\\n        int i = 1;\\n        while(cur != NULL && i <= num_nodes) {\\n            ListNode* temp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = temp;\\n            i++;\\n        }\\n        // head->next is pointing to original prev but prev is pointing\\n        // to last node of the current list\\n        // hence, point previous list end node to new list\\'s head\\n        head->next->next = prev;\\n\\n        // point the last node of the new list to first node of the \\n        // next group\\n        head->next = cur;\\n        return head;\\n    }\\n\\n    int calcLength(ListNode* cur) {\\n        int i = 0;\\n        while(cur != NULL) {\\n            i++;\\n            cur = cur->next;\\n        }\\n        return i;\\n    }\\n\\n    ListNode* traverseN(ListNode* cur, int n) {\\n        int i = 1;\\n        while(cur != NULL && i < n) {\\n            cur = cur->next;\\n            i++;\\n        }\\n        return cur;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len = calcLength(head);\\n\\n        int count = 0;\\n        int group_num = 0;\\n        int group_len = 0;\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        while(cur != NULL) {\\n            group_num++;\\n            group_len = min(len-count, group_num);\\n\\n            // reverse an even group\\n            if (group_len%2 == 0) {\\n                cur = reverseN(cur, prev, group_len);\\n                count += group_len;\\n            } else {\\n                cur = traverseN(cur, group_len);\\n                count += group_len;\\n            }\\n\\n            prev = cur;\\n            if (cur != NULL) {\\n                 cur = cur->next;    \\n            } \\n              \\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814320,
                "title": "solution-without-conversion-to-list-python",
                "content": "# Intuition\\ngo through the linked list and if sublist must be reversed, we reverse with sub-while loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = prev = lenHead = head\\n\\n        curr = prev.next\\n        counter = 2\\n        length = 0\\n        while lenHead:\\n            length += 1\\n            lenHead = lenHead.next\\n        total = 1\\n        while curr:\\n            countTemp = counter\\n            print((length - total), counter)\\n            if ((length - total) >= counter and counter % 2 == 0) or ((length - total) < counter and (length - total) % 2 == 0 ):\\n                seqPrev = prev\\n                seqEnd = curr\\n                prev = curr\\n                curr = curr.next\\n                while countTemp - 1 and curr:\\n                    nextNode = curr.next\\n                    curr.next = prev\\n                    prev = curr\\n                    curr = nextNode\\n                    countTemp -= 1\\n                \\n                seqPrev.next = prev\\n                seqEnd.next = curr\\n                prev = seqEnd\\n            else:\\n                while countTemp and curr:\\n                    prev = curr\\n                    curr = curr.next\\n                    countTemp -= 1\\n            total += counter\\n            counter += 1\\n            \\n        \\n        return dummy\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = prev = lenHead = head\\n\\n        curr = prev.next\\n        counter = 2\\n        length = 0\\n        while lenHead:\\n            length += 1\\n            lenHead = lenHead.next\\n        total = 1\\n        while curr:\\n            countTemp = counter\\n            print((length - total), counter)\\n            if ((length - total) >= counter and counter % 2 == 0) or ((length - total) < counter and (length - total) % 2 == 0 ):\\n                seqPrev = prev\\n                seqEnd = curr\\n                prev = curr\\n                curr = curr.next\\n                while countTemp - 1 and curr:\\n                    nextNode = curr.next\\n                    curr.next = prev\\n                    prev = curr\\n                    curr = nextNode\\n                    countTemp -= 1\\n                \\n                seqPrev.next = prev\\n                seqEnd.next = curr\\n                prev = seqEnd\\n            else:\\n                while countTemp and curr:\\n                    prev = curr\\n                    curr = curr.next\\n                    countTemp -= 1\\n            total += counter\\n            counter += 1\\n            \\n        \\n        return dummy\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805562,
                "title": "simplest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        vector<int> tmp;\\n        ListNode* n = head;\\n        ListNode* h2 = nullptr;\\n        ListNode* n2 = h2;\\n\\n        int i=1;\\n        while(n!=nullptr)\\n        {\\n            for(int j=i; j>0; j--)\\n            {\\n                if(!n)\\n                {\\n                    break;\\n                }\\n                tmp.push_back(n->val);\\n                n=n->next;\\n            }\\n            \\n            if(!(tmp.size()%2))\\n            {\\n                std::reverse(tmp.begin(), tmp.end());\\n            }\\n            \\n            for(int j=0; j<tmp.size(); j++)\\n            {\\n                if(n2)\\n                {\\n                    n2->next = new ListNode(tmp[j]);\\n                    n2 = n2->next;\\n                }\\n                else\\n                {\\n                    n2 = new ListNode(tmp[j]);\\n                    h2 = n2;\\n                }\\n            }\\n            \\n            tmp.clear();\\n            i++;\\n\\n        }\\n\\n        return h2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        vector<int> tmp;\\n        ListNode* n = head;\\n        ListNode* h2 = nullptr;\\n        ListNode* n2 = h2;\\n\\n        int i=1;\\n        while(n!=nullptr)\\n        {\\n            for(int j=i; j>0; j--)\\n            {\\n                if(!n)\\n                {\\n                    break;\\n                }\\n                tmp.push_back(n->val);\\n                n=n->next;\\n            }\\n            \\n            if(!(tmp.size()%2))\\n            {\\n                std::reverse(tmp.begin(), tmp.end());\\n            }\\n            \\n            for(int j=0; j<tmp.size(); j++)\\n            {\\n                if(n2)\\n                {\\n                    n2->next = new ListNode(tmp[j]);\\n                    n2 = n2->next;\\n                }\\n                else\\n                {\\n                    n2 = new ListNode(tmp[j]);\\n                    h2 = n2;\\n                }\\n            }\\n            \\n            tmp.clear();\\n            i++;\\n\\n        }\\n\\n        return h2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787693,
                "title": "two-methodes-o-n-tc-and-o-n-sc",
                "content": "# First method: Using math\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem here is the last group, because is the only one that can not matche the number of nodes in it. The others do, for example, group numer 3 has 3 node, groupe number 5 has 5 node...\\nThe group numer 7 if it is the last group, can have 1 node, 2, 3... or even 6 nodes.\\nIf we know the number of groups, and also the number of nodes that it contains, we can handle this problem by reverse all nodes in the even group, and in the final, reverse the last group, if the number of its items is even.\\nBut how can we do that?\\n\\nIf we take a look at the number of the elements in each group:\\n1 | 2 - 3 | 4 - 5 - 6 | ...\\nHow elements we have?\\n1 + 2 + 3 = (3 * (3-1)) // 2 (Gauss\\'s formula)\\n\\nIf we know the lenght of the input, we can know the number of the groups and the nodes in the last group.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI use two functions, one to compute the length of the listNode and the other, the nomber of groups and the number of nodes in the last group.\\nWe can add at that a third fucction that reverse the groups.\\n\\n# Complexity\\n- Time complexity $$O(n)$$:\\n1. Iterate throught the linked list $$O(n)$$;\\n2. Compute the number of group and the number of nodes in the last node $$O(log(n))$$ (using binary search for that);\\n3. Iterate throught the linked list and reverse the groupe. It takes $$O(n + n/2)$$.\\nThe result of all of that: $$O(n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity $$O(1)$$:\\nWe don\\'t use any extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getLength(self, head):\\n        count, current = 0, head\\n        while current:\\n            count = count + 1\\n            current = current.next\\n        return count\\n\\n    def getNumGroups(self, num: int) -> List[int]:\\n        if num == 1: return [1, 0]\\n        num_2 = num * 2\\n        start, end = 1, num_2 // 2\\n        while start <= end:\\n            mid = (start + end) // 2\\n            pr = mid * mid\\n            if pr == num_2:\\n                ans = mid\\n                break\\n            elif pr < num_2:\\n                ans = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        if ans * (ans + 1) // 2 > num:\\n            # In some cases, the number is begger.\\n            ans = ans - 1\\n        carry = num - ans * (ans + 1) // 2\\n            \\n        return [ans, carry] \\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        length = self.getLength(head)\\n        groups_carry = self.getNumGroups(length)\\n\\n        num_groups, carry =  groups_carry[0], groups_carry[1]\\n\\n        count_groups, prev, current = 1, head, head\\n        while count_groups <= num_groups:\\n            count = 1\\n            tail_group = current\\n            while count < count_groups:\\n                tail_group = tail_group.next\\n                count = count + 1\\n\\n            if count_groups % 2:\\n                current = tail_group.next\\n                prev = tail_group\\n            else:\\n                node = current\\n                save_tail_next = tail_group.next\\n                while count > 0:\\n                    save_node_next = node.next\\n                    node.next = save_tail_next\\n                    save_tail_next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = tail_group\\n                prev = current\\n                current = node\\n\\n            count_groups = count_groups + 1\\n\\n        # Hindling the last group.\\n        if not carry % 2:\\n            tail = None\\n            while current:\\n                save_current_next = current.next\\n                current.next = tail\\n                tail = current\\n                current = save_current_next\\n            prev.next = tail\\n\\n        return head\\n```\\n# Second methode\\n# Complexity\\n- Time complexity $$O(n)$$:\\nIterate throught the linked list and reverse the nodes if there number is even.\\n- Space complexity $$O(1)$$:\\nWe don\\'t use any extra space.\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current, prev, num_group = head, None, 1\\n        while current:\\n            count = 1\\n            tail = current\\n            while tail.next and count < num_group:\\n                tail = tail.next\\n                count = count + 1\\n\\n            if not count % 2:\\n                node = current\\n                while count > 1:\\n                    # 1 not 0 because in the first\\n                    # iteration we make tow iterations!\\n                    save_node_next = node.next\\n                    node.next = tail.next\\n                    tail.next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = node\\n                prev = current\\n            else:\\n                prev = tail\\n\\n            current = prev.next\\n            num_group = num_group + 1\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getLength(self, head):\\n        count, current = 0, head\\n        while current:\\n            count = count + 1\\n            current = current.next\\n        return count\\n\\n    def getNumGroups(self, num: int) -> List[int]:\\n        if num == 1: return [1, 0]\\n        num_2 = num * 2\\n        start, end = 1, num_2 // 2\\n        while start <= end:\\n            mid = (start + end) // 2\\n            pr = mid * mid\\n            if pr == num_2:\\n                ans = mid\\n                break\\n            elif pr < num_2:\\n                ans = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        if ans * (ans + 1) // 2 > num:\\n            # In some cases, the number is begger.\\n            ans = ans - 1\\n        carry = num - ans * (ans + 1) // 2\\n            \\n        return [ans, carry] \\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        length = self.getLength(head)\\n        groups_carry = self.getNumGroups(length)\\n\\n        num_groups, carry =  groups_carry[0], groups_carry[1]\\n\\n        count_groups, prev, current = 1, head, head\\n        while count_groups <= num_groups:\\n            count = 1\\n            tail_group = current\\n            while count < count_groups:\\n                tail_group = tail_group.next\\n                count = count + 1\\n\\n            if count_groups % 2:\\n                current = tail_group.next\\n                prev = tail_group\\n            else:\\n                node = current\\n                save_tail_next = tail_group.next\\n                while count > 0:\\n                    save_node_next = node.next\\n                    node.next = save_tail_next\\n                    save_tail_next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = tail_group\\n                prev = current\\n                current = node\\n\\n            count_groups = count_groups + 1\\n\\n        # Hindling the last group.\\n        if not carry % 2:\\n            tail = None\\n            while current:\\n                save_current_next = current.next\\n                current.next = tail\\n                tail = current\\n                current = save_current_next\\n            prev.next = tail\\n\\n        return head\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current, prev, num_group = head, None, 1\\n        while current:\\n            count = 1\\n            tail = current\\n            while tail.next and count < num_group:\\n                tail = tail.next\\n                count = count + 1\\n\\n            if not count % 2:\\n                node = current\\n                while count > 1:\\n                    # 1 not 0 because in the first\\n                    # iteration we make tow iterations!\\n                    save_node_next = node.next\\n                    node.next = tail.next\\n                    tail.next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = node\\n                prev = current\\n            else:\\n                prev = tail\\n\\n            current = prev.next\\n            num_group = num_group + 1\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780551,
                "title": "c-short-code-easy-solution-100-beats-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL) return head;\\n        ListNode* temp = head;\\n        ListNode* rest;\\n        int grp = 1,nodes=1;\\n        do{\\n            \\n            if(nodes==grp || !temp->next){\\n                grp++; \\n               if(nodes%2==0){\\n                   ListNode* forward = rest->next;\\n                   ListNode* Extract = forward->next;\\n                   while((nodes--)>1){\\n                       forward->next = Extract->next;\\n                       Extract->next = rest->next;\\n                       rest->next = Extract;\\n                       Extract = forward->next;\\n                   }\\n                   temp = forward;\\n                 }\\n                 nodes=0;\\n                 rest = temp;\\n            }\\n            nodes++;\\n            temp=temp->next;\\n        }while(temp);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL) return head;\\n        ListNode* temp = head;\\n        ListNode* rest;\\n        int grp = 1,nodes=1;\\n        do{\\n            \\n            if(nodes==grp || !temp->next){\\n                grp++; \\n               if(nodes%2==0){\\n                   ListNode* forward = rest->next;\\n                   ListNode* Extract = forward->next;\\n                   while((nodes--)>1){\\n                       forward->next = Extract->next;\\n                       Extract->next = rest->next;\\n                       rest->next = Extract;\\n                       Extract = forward->next;\\n                   }\\n                   temp = forward;\\n                 }\\n                 nodes=0;\\n                 rest = temp;\\n            }\\n            nodes++;\\n            temp=temp->next;\\n        }while(temp);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778172,
                "title": "java-solution-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncomment for explaination.\\n\\n# Complexity\\n- Time complexity:O(len*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null)return head;\\n        int len=length(head);\\n        int k=2,curr=0;\\n        int l=1;\\n        ListNode node=head;\\n        ListNode prev=head;\\n        while(node!=null){\\n            while(curr<k && node!=null){\\n                curr++;\\n                node=node.next;\\n            }\\n            ListNode temp=prev.next;\\n            if(curr%2==0){\\n                prev.next=reverse(prev.next,node);\\n            }\\n            prev=(curr%2==0)?temp:node;\\n            node=prev;\\n            l+=curr;\\n            curr=0;\\n            k++;\\n            if(k>len-l)k=len-l;\\n        }\\n        return head;\\n\\n    }\\n    public ListNode reverse(ListNode head,ListNode tail){\\n        if(tail!=null)tail=tail.next;\\n        ListNode end=tail;\\n        while(head!=null){\\n            ListNode next=head.next;\\n            head.next=tail;\\n            if(end==next)break;\\n            tail=head;\\n            head=next;\\n        }\\n        return head;\\n    }\\n    public int length(ListNode head)\\n    {\\n        int len=0;\\n        for(ListNode curr=head;curr!=null;curr=curr.next)len++;\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null)return head;\\n        int len=length(head);\\n        int k=2,curr=0;\\n        int l=1;\\n        ListNode node=head;\\n        ListNode prev=head;\\n        while(node!=null){\\n            while(curr<k && node!=null){\\n                curr++;\\n                node=node.next;\\n            }\\n            ListNode temp=prev.next;\\n            if(curr%2==0){\\n                prev.next=reverse(prev.next,node);\\n            }\\n            prev=(curr%2==0)?temp:node;\\n            node=prev;\\n            l+=curr;\\n            curr=0;\\n            k++;\\n            if(k>len-l)k=len-l;\\n        }\\n        return head;\\n\\n    }\\n    public ListNode reverse(ListNode head,ListNode tail){\\n        if(tail!=null)tail=tail.next;\\n        ListNode end=tail;\\n        while(head!=null){\\n            ListNode next=head.next;\\n            head.next=tail;\\n            if(end==next)break;\\n            tail=head;\\n            head=next;\\n        }\\n        return head;\\n    }\\n    public int length(ListNode head)\\n    {\\n        int len=0;\\n        for(ListNode curr=head;curr!=null;curr=curr.next)len++;\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772763,
                "title": "simple-java-code-with-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n\\n1. First, a check is performed to see if the input linked list is either empty or contains only a single node. If so, the function simply returns the head of the list as there is no need to reverse anything.\\n2. A `dummy` node is created and set as the initial `prev` node. The `prev` node is used to keep track of the previous node before the current node (`cur`).\\n3. The function iterates through the linked list until the last node (`cur.next != null`). Within each iteration, it checks if the current group has an even or odd length.\\n4. To determine if the group is even or odd, the function counts the number of available nodes (`availableNode`) in the current group. This is done by traversing the list using a temporary node (`checkNode`) and incrementing `availableNode` until either the end of the list is reached or the count equals the length of the current group (`count`).\\n5. If the group is even (`evenTurn` is `true`), the function reverses the nodes within the group. It uses a counter (`i`) to keep track of the number of nodes processed within the group. The reversal is done by swapping the `next` pointers of the nodes, starting from the second node up to the count (`count - 1`). The `prev` node is updated to maintain the correct connections.\\n6. If the group is odd (`evenTurn` is `false`), the function simply skips the nodes in the current group without making any changes. It advances `prev` and `cur` to the next group by moving `i` nodes ahead.\\n7. After processing the current group, the counters and variables are reset (`i = 1`, `count = count + 1`) to move to the next group.\\n8. Finally, the modified linked list is returned by accessing the `next` pointer of the `dummy` node\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n   public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        int i = 1;\\n        int count = 1;\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode cur = dummy.next;\\n\\n        while (cur.next != null) {\\n            // Count the number of available nodes in the current group\\n            ListNode checkNode = cur;\\n            int availableNode = 0;\\n            while (checkNode != null && availableNode < count) {\\n                availableNode++;\\n                checkNode = checkNode.next;\\n            }\\n\\n            boolean evenTurn = availableNode % 2 == 0;\\n\\n            if (evenTurn) {\\n                // Reverse the nodes within the even-length group\\n                while (cur.next != null && i < count) {\\n                    ListNode temp = cur.next;\\n                    cur.next = temp.next;\\n                    temp.next = prev.next;\\n                    prev.next = temp;\\n                    i++;\\n                }\\n\\n                if (cur.next != null) {\\n                    ListNode temp = cur.next;\\n                    prev = cur;\\n                    cur = temp;\\n                }\\n            } else {\\n                // Skip nodes in the odd-length group\\n                while (cur.next != null && i <= count) {\\n                    prev = cur;\\n                    cur = cur.next;\\n                    i++;\\n                }\\n            }\\n\\n            i = 1;\\n            count = count + 1;\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n   public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        int i = 1;\\n        int count = 1;\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode cur = dummy.next;\\n\\n        while (cur.next != null) {\\n            // Count the number of available nodes in the current group\\n            ListNode checkNode = cur;\\n            int availableNode = 0;\\n            while (checkNode != null && availableNode < count) {\\n                availableNode++;\\n                checkNode = checkNode.next;\\n            }\\n\\n            boolean evenTurn = availableNode % 2 == 0;\\n\\n            if (evenTurn) {\\n                // Reverse the nodes within the even-length group\\n                while (cur.next != null && i < count) {\\n                    ListNode temp = cur.next;\\n                    cur.next = temp.next;\\n                    temp.next = prev.next;\\n                    prev.next = temp;\\n                    i++;\\n                }\\n\\n                if (cur.next != null) {\\n                    ListNode temp = cur.next;\\n                    prev = cur;\\n                    cur = temp;\\n                }\\n            } else {\\n                // Skip nodes in the odd-length group\\n                while (cur.next != null && i <= count) {\\n                    prev = cur;\\n                    cur = cur.next;\\n                    i++;\\n                }\\n            }\\n\\n            i = 1;\\n            count = count + 1;\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772203,
                "title": "python-solution-in-n-time-and-constant-space",
                "content": "# Complexity\\n- Time complexity: \\u0398(n)\\n\\n- Space complexity: \\u0398(1)\\n\\n# Code\\n```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772200,
                "title": "python-solution-in-n-time-and-constant-space",
                "content": "# Complexity\\n- Time complexity: \\u0398(n)\\n\\n- Space complexity: \\u0398(1)\\n\\n# Code\\n```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757957,
                "title": "beats-85-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n       ListNode *connect=head,*ptr=head->next;\\n       int cnt=2;\\n       while(ptr!=NULL){\\n           ListNode *head_maintain=ptr,*prev=NULL;\\n           int i=0;\\n           while(ptr!=NULL&&i<cnt){\\n             prev=ptr;\\n             ptr=ptr->next;\\n             i+=1;\\n             }\\n             if(i%2==0){\\n                ptr=head_maintain;\\n                ListNode *preptr=NULL;\\n                int j=0;\\n                while(j<i){\\n                    ListNode *next=ptr->next;\\n                    ptr->next=preptr;\\n                    preptr=ptr;\\n                    ptr=next;\\n                    j+=1;\\n                }\\n                connect->next=preptr;\\n                connect=head_maintain;\\n            }\\n            else{\\n                connect->next=head_maintain;\\n                connect=prev;\\n            }\\n            cnt+=1;\\n        }\\n       return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n       ListNode *connect=head,*ptr=head->next;\\n       int cnt=2;\\n       while(ptr!=NULL){\\n           ListNode *head_maintain=ptr,*prev=NULL;\\n           int i=0;\\n           while(ptr!=NULL&&i<cnt){\\n             prev=ptr;\\n             ptr=ptr->next;\\n             i+=1;\\n             }\\n             if(i%2==0){\\n                ptr=head_maintain;\\n                ListNode *preptr=NULL;\\n                int j=0;\\n                while(j<i){\\n                    ListNode *next=ptr->next;\\n                    ptr->next=preptr;\\n                    preptr=ptr;\\n                    ptr=next;\\n                    j+=1;\\n                }\\n                connect->next=preptr;\\n                connect=head_maintain;\\n            }\\n            else{\\n                connect->next=head_maintain;\\n                connect=prev;\\n            }\\n            cnt+=1;\\n        }\\n       return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745102,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\n    ListNode* prev = NULL,*curr = head,*nxt = NULL;\\n    while(curr){\\n        nxt = curr -> next;\\n        curr -> next = prev;\\n        prev = curr;\\n        curr = nxt;\\n    }\\n\\n    return prev;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(-1,head);\\n        ListNode* prev = dummy,*tail = head,*newHead = NULL,*curr = head;\\n\\n        int k = 1;\\n        while(curr){\\n            int i = 1;\\n            for( i=1;i<k && tail->next;++i) tail = tail -> next;\\n            if(tail == NULL) return dummy -> next;\\n\\n            newHead = tail -> next;\\n            if(i&1){\\n                 if(curr == NULL) return dummy -> next;\\n                 curr = tail -> next;\\n                 prev = tail;\\n                 tail = curr;\\n            }\\n            else{\\n                  tail -> next = NULL;\\n                  if(curr == NULL) return dummy -> next;\\n                \\n                  ListNode* tmp = reverse(curr);\\n                  curr -> next = newHead;\\n                  prev -> next = tmp;\\n                  tail = curr -> next;\\n                  prev = curr;\\n                  curr = tail;\\n            }\\n\\n            k += 1;\\n        }\\n\\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\n    ListNode* prev = NULL,*curr = head,*nxt = NULL;\\n    while(curr){\\n        nxt = curr -> next;\\n        curr -> next = prev;\\n        prev = curr;\\n        curr = nxt;\\n    }\\n\\n    return prev;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(-1,head);\\n        ListNode* prev = dummy,*tail = head,*newHead = NULL,*curr = head;\\n\\n        int k = 1;\\n        while(curr){\\n            int i = 1;\\n            for( i=1;i<k && tail->next;++i) tail = tail -> next;\\n            if(tail == NULL) return dummy -> next;\\n\\n            newHead = tail -> next;\\n            if(i&1){\\n                 if(curr == NULL) return dummy -> next;\\n                 curr = tail -> next;\\n                 prev = tail;\\n                 tail = curr;\\n            }\\n            else{\\n                  tail -> next = NULL;\\n                  if(curr == NULL) return dummy -> next;\\n                \\n                  ListNode* tmp = reverse(curr);\\n                  curr -> next = newHead;\\n                  prev -> next = tmp;\\n                  tail = curr -> next;\\n                  prev = curr;\\n                  curr = tail;\\n            }\\n\\n            k += 1;\\n        }\\n\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744777,
                "title": "o-1-memory-space-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe traverse through the list step by step, each step has a length $l$, which is also the length of of the group that we are currently traversing. After traverse through the step, we reverse the list in-place, and then merge it back to the original list. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are going to solve this problem in-place to obtain O(1) memory space.\\n\\nStep 1: Traverse up-front to check the length of the group (check if it is long enough or if it reaches the end).\\nStep 2: Reverse the particular part of the list with the length we count in step 1.\\nStep 3: Merge: Noted that we need to store a variable $prev$ (the previous node of the first node in the group) and $next$ (the next node of the last node in the group). If we reverse the list, the last node (variable $tmp$) becomes the first node (variable $current$) and vice versa. We point $prev$ to $tmp$, then point $current$ to $next$ and update $prev$. Note that if we do not reverse the list, $prev$ should be updated as $tmp$.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nEven though we have nested while loop here, the time complexity is O(n). The travelling up-front part cost O(n), the reverseList cost O(n). In the next while loop, we move the the entirely new part of the list, so it is O(n) time complexity. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHere, we only store a few variables to deal with in-place reversal, so the space complexity is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(ListNode *head, int len){\\n        int count = 0;\\n        ListNode *prev = nullptr, *current = head, *next = nullptr;\\n        while(count < len && current){\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int l = 1, count;\\n        if(!head->next) return head;\\n        ListNode *current = head, *tmp = head; // for traversing upfront\\n        ListNode *prev = nullptr, *next = nullptr; // for merging the reversed list\\n        // start from the second node\\n        current = head->next;\\n        prev = head;\\n        while(current){\\n            l++;\\n            tmp = current;\\n            count = 1;\\n            while(count < l && tmp->next){\\n                tmp = tmp->next;\\n                count++;\\n            }\\n            next = tmp->next;   \\n            if(count%2 == 0){\\n                reverseList(current, l);\\n                //merge\\n                prev->next = tmp;\\n                current->next = next;\\n                prev = current;\\n            }else{\\n                prev = tmp;\\n            }\\n            current = next;\\n            tmp = current;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(ListNode *head, int len){\\n        int count = 0;\\n        ListNode *prev = nullptr, *current = head, *next = nullptr;\\n        while(count < len && current){\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int l = 1, count;\\n        if(!head->next) return head;\\n        ListNode *current = head, *tmp = head; // for traversing upfront\\n        ListNode *prev = nullptr, *next = nullptr; // for merging the reversed list\\n        // start from the second node\\n        current = head->next;\\n        prev = head;\\n        while(current){\\n            l++;\\n            tmp = current;\\n            count = 1;\\n            while(count < l && tmp->next){\\n                tmp = tmp->next;\\n                count++;\\n            }\\n            next = tmp->next;   \\n            if(count%2 == 0){\\n                reverseList(current, l);\\n                //merge\\n                prev->next = tmp;\\n                current->next = next;\\n                prev = current;\\n            }else{\\n                prev = tmp;\\n            }\\n            current = next;\\n            tmp = current;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732665,
                "title": "ok",
                "content": "**time: `O(N)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/644226f4-b488-46f0-b048-6a4bbca78b5c_1688747083.092001.png)\\n\\nHere\\'s how inversion is made in more detail:\\n\\n![image](https://assets.leetcode.com/users/images/fa7ff2db-fb7a-46de-96ae-660941354af2_1688748747.976289.png)\\n\\nHere `x` marks the borderline between the already inverted and the not-inverted part.\\n\\n```\\nListNode* reverseEvenLengthGroups(ListNode* l) \\n{\\n\\tint n{2};\\n\\tfor(auto b{l}, e{b->next}; e; ++n)\\n\\t{\\n\\t\\tfor( ; b->next!=e; b=b->next); \\n\\t\\tint i{};\\n\\t\\tfor( ; i<n and e; e=e->next, ++i);\\n\\t\\tif(1+i&1) for(auto x{b->next}; x->next!=e; b->next = exchange(x->next, exchange(x->next->next, b->next)));   \\n\\t}\\n\\treturn l;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nListNode* reverseEvenLengthGroups(ListNode* l) \\n{\\n\\tint n{2};\\n\\tfor(auto b{l}, e{b->next}; e; ++n)\\n\\t{\\n\\t\\tfor( ; b->next!=e; b=b->next); \\n\\t\\tint i{};\\n\\t\\tfor( ; i<n and e; e=e->next, ++i);\\n\\t\\tif(1+i&1) for(auto x{b->next}; x->next!=e; b->next = exchange(x->next, exchange(x->next->next, b->next)));   \\n\\t}\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731160,
                "title": "beats-92-c-iterative-solution-for-beginners",
                "content": "\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n\\n    //make a pair class to return both head and tail from \\n    //reverse function\\n\\n    class Pair{\\n        public:\\n        ListNode* head;\\n        ListNode* tail;\\n    };\\n\\n    //recursive reverse function which returns an object of \\n    //pair class\\n\\n    Pair reverse(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            Pair ans;\\n            ans.head=head;\\n            ans.tail=head;\\n            return ans;\\n        }\\n        Pair smallAns=reverse(head->next);\\n        smallAns.tail->next=head;\\n        head->next=NULL;\\n        Pair ans;\\n        ans.head=smallAns.head;\\n        ans.tail=head;\\n        return ans;\\n    }\\npublic:\\n\\n    //maintain dummy nodes and iterate on every group\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode*dummy=head;ListNode*newHead=head;\\n        ListNode*h1=newHead->next;\\n        ListNode*t1=newHead->next;\\n        int count=0;int group=2;bool free=false;\\n        while(dummy->next!=NULL){\\n            dummy=dummy->next;\\n            count++;\\n\\n        //condition when group is of even length\\n\\n            if((count%2==0 && group%2==0 && count==group)){\\n                t1=dummy;\\n                ListNode*temp=dummy->next;\\n                t1->next=NULL;\\n                Pair ans=reverse(h1);\\n                newHead->next=ans.head;\\n                ans.tail->next=temp;\\n                newHead=ans.tail;\\n                dummy=ans.tail;\\n                count=0;group++;\\n\\n            }\\n\\n        //condition when group is of odd length\\n\\n            if(!free && count==group){\\n                count=0;\\n                group++;\\n                newHead=dummy;\\n                h1=dummy->next;\\n\\n            }\\n        }\\n\\n        //when no group is left\\n\\n        if(count==0)return head;\\n\\n        //when left nodes are even in number \\n        //then we need to reverse them \\n        //(group can be odd also in this case)\\n\\n        if(count%2==0){\\n            Pair ans=reverse(newHead->next);\\n            newHead->next=ans.head;\\n            ans.tail->next=NULL;\\n            return head;\\n        }\\n\\n        //when nodes left are odd in number\\n        //in this case no need to reverse them\\n        //simply return head\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n\\n    //make a pair class to return both head and tail from \\n    //reverse function\\n\\n    class Pair{\\n        public:\\n        ListNode* head;\\n        ListNode* tail;\\n    };\\n\\n    //recursive reverse function which returns an object of \\n    //pair class\\n\\n    Pair reverse(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            Pair ans;\\n            ans.head=head;\\n            ans.tail=head;\\n            return ans;\\n        }\\n        Pair smallAns=reverse(head->next);\\n        smallAns.tail->next=head;\\n        head->next=NULL;\\n        Pair ans;\\n        ans.head=smallAns.head;\\n        ans.tail=head;\\n        return ans;\\n    }\\npublic:\\n\\n    //maintain dummy nodes and iterate on every group\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode*dummy=head;ListNode*newHead=head;\\n        ListNode*h1=newHead->next;\\n        ListNode*t1=newHead->next;\\n        int count=0;int group=2;bool free=false;\\n        while(dummy->next!=NULL){\\n            dummy=dummy->next;\\n            count++;\\n\\n        //condition when group is of even length\\n\\n            if((count%2==0 && group%2==0 && count==group)){\\n                t1=dummy;\\n                ListNode*temp=dummy->next;\\n                t1->next=NULL;\\n                Pair ans=reverse(h1);\\n                newHead->next=ans.head;\\n                ans.tail->next=temp;\\n                newHead=ans.tail;\\n                dummy=ans.tail;\\n                count=0;group++;\\n\\n            }\\n\\n        //condition when group is of odd length\\n\\n            if(!free && count==group){\\n                count=0;\\n                group++;\\n                newHead=dummy;\\n                h1=dummy->next;\\n\\n            }\\n        }\\n\\n        //when no group is left\\n\\n        if(count==0)return head;\\n\\n        //when left nodes are even in number \\n        //then we need to reverse them \\n        //(group can be odd also in this case)\\n\\n        if(count%2==0){\\n            Pair ans=reverse(newHead->next);\\n            newHead->next=ans.head;\\n            ans.tail->next=NULL;\\n            return head;\\n        }\\n\\n        //when nodes left are odd in number\\n        //in this case no need to reverse them\\n        //simply return head\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729175,
                "title": "python-simple-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # To be able to reverse, we need to keep the previous node that we visited\\n        curr, prev = head, None\\n        # starting the counter form 1 and will be incrementing by 1 later in the loop\\n        ctr = 1\\n        # continue until we reach the end of the loop\\n        while curr:\\n            # count the number of nodes in this step where counter is ctr\\n            i = 0\\n            # keep a pointer to the start of the node, in case the number of nodes \\n            start = curr\\n            while curr and i < ctr:\\n                # keep track of previous node in case we need to reverse\\n                next_prev_node = curr\\n                curr = curr.next\\n                i += 1\\n            # if the count of nodes in this iteration are even, then we need to reverse\\n            if not i & 1:\\n                tail = start\\n                curr = start\\n                # to reverse\\n                temp_prev = None\\n                j = 0\\n                # continue the iteration for the number of nodes seen in this step (ctr)\\n                while curr and j < i:\\n                    next_node = curr.next\\n                    curr.next = temp_prev\\n                    temp_prev = curr\\n                    curr = next_node\\n                    j += 1\\n                prev.next = temp_prev\\n                tail.next = curr\\n                # since it is reversed the new previous node will be the tail of current list\\n                prev = tail\\n            else:\\n                # if not reversed the previous node will be the next_prev_node\\n                prev = next_prev_node\\n            ctr += 1\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # To be able to reverse, we need to keep the previous node that we visited\\n        curr, prev = head, None\\n        # starting the counter form 1 and will be incrementing by 1 later in the loop\\n        ctr = 1\\n        # continue until we reach the end of the loop\\n        while curr:\\n            # count the number of nodes in this step where counter is ctr\\n            i = 0\\n            # keep a pointer to the start of the node, in case the number of nodes \\n            start = curr\\n            while curr and i < ctr:\\n                # keep track of previous node in case we need to reverse\\n                next_prev_node = curr\\n                curr = curr.next\\n                i += 1\\n            # if the count of nodes in this iteration are even, then we need to reverse\\n            if not i & 1:\\n                tail = start\\n                curr = start\\n                # to reverse\\n                temp_prev = None\\n                j = 0\\n                # continue the iteration for the number of nodes seen in this step (ctr)\\n                while curr and j < i:\\n                    next_node = curr.next\\n                    curr.next = temp_prev\\n                    temp_prev = curr\\n                    curr = next_node\\n                    j += 1\\n                prev.next = temp_prev\\n                tail.next = curr\\n                # since it is reversed the new previous node will be the tail of current list\\n                prev = tail\\n            else:\\n                # if not reversed the previous node will be the next_prev_node\\n                prev = next_prev_node\\n            ctr += 1\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727274,
                "title": "easy-solution-using-intution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Copy all the elements of linked list. divide each group , whenever a group length is even, reverse it using stack. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI collected all the elements of the linked list using cursor, until cursor is `NULL`. Divide it into groups of increasing sizes (ind + n  gives the start of next group). until ind + n is less than size of vector. If the size of last group is even reverse that part also. \\n\\n# Complexity\\n- Time complexity:O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUpvote if you like this approach \\uD83D\\uDC4D\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // reversing the vector from start to end\\n    void rev(vector<int>& v, int start, int end){\\n        stack<int> st; \\n        for(int i=start; i<= end; i++) st.push(v[i]); \\n        for(int i=start; i<= end; i++){v[i] = st.top(); st.pop(); }\\n\\n    }\\n\\n    //Dividing the vector into parts and reversing even sized ones\\n    void modify(vector<int>& v){\\n     // ind stores the starting index of group and n the size of group\\n      int ind = 0, n = 1; \\n      while(ind + n < v.size()){\\n          if(n%2 == 0){\\n              rev(v, ind, ind+n-1); ind += n; n++; \\n          }\\n          else {\\n              ind += n; n++; \\n          }\\n      }\\n     // checking length of last group \\n      if((v.size() - ind)%2 == 0) rev(v, ind, v.size()-1); \\n\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* cursor = head; vector<int> v; \\n    // Copying the elements of linked list to a vector. \\n        while(cursor){v.push_back(cursor->val); cursor = cursor->next; }\\n        modify(v); \\n        cursor = head; \\n        for(int i=0; i<v.size(); i++){\\n            cursor->val = v[i]; cursor = cursor->next; \\n        }\\n\\n        return head; \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // reversing the vector from start to end\\n    void rev(vector<int>& v, int start, int end){\\n        stack<int> st; \\n        for(int i=start; i<= end; i++) st.push(v[i]); \\n        for(int i=start; i<= end; i++){v[i] = st.top(); st.pop(); }\\n\\n    }\\n\\n    //Dividing the vector into parts and reversing even sized ones\\n    void modify(vector<int>& v){\\n     // ind stores the starting index of group and n the size of group\\n      int ind = 0, n = 1; \\n      while(ind + n < v.size()){\\n          if(n%2 == 0){\\n              rev(v, ind, ind+n-1); ind += n; n++; \\n          }\\n          else {\\n              ind += n; n++; \\n          }\\n      }\\n     // checking length of last group \\n      if((v.size() - ind)%2 == 0) rev(v, ind, v.size()-1); \\n\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* cursor = head; vector<int> v; \\n    // Copying the elements of linked list to a vector. \\n        while(cursor){v.push_back(cursor->val); cursor = cursor->next; }\\n        modify(v); \\n        cursor = head; \\n        for(int i=0; i<v.size(); i++){\\n            cursor->val = v[i]; cursor = cursor->next; \\n        }\\n\\n        return head; \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720968,
                "title": "c-program-recursion",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode *reverseList(struct ListNode *head)\\n{\\n    if (head == NULL || head->next == NULL)\\n    {\\n        return head;\\n    }\\n    struct ListNode *prev = NULL;\\n    struct ListNode *curr = head;\\n    struct ListNode *Next = head->next;\\n    while (curr->next != NULL)\\n    {\\n        curr->next = prev;\\n        prev = curr;\\n        curr = Next;\\n        Next = curr->next;\\n    }\\n    curr->next = prev;\\n    return curr;\\n}\\nint len(struct ListNode *temp)\\n{\\n    int count = 0;\\n    while (temp != NULL)\\n    {\\n        count++;\\n        temp = temp->next;\\n    }\\n    return count;\\n}\\nstruct ListNode *reverseEven(struct ListNode *head, int k)\\n{\\n    if (len(head) < k)\\n    {\\n        if(len(head)%2==0)\\n        {\\n            return reverseList(head);\\n        }\\n        else\\n        {\\n            return head;\\n        }\\n    }\\n    else\\n    {\\n        int i = 0;\\n        if (k % 2 == 0)\\n        {\\n\\n            struct ListNode *prev = NULL;\\n            struct ListNode *curr = head;\\n            struct ListNode *Next = curr->next;\\n            struct ListNode *temp = head;\\n            while (i < k)\\n            {\\n                curr->next = prev;\\n                prev = curr;\\n                curr = Next;\\n                if (Next != NULL)\\n                {\\n\\n                    Next = curr->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                i++;\\n            }\\n            head->next = reverseEven(curr, k+1);\\n            return prev;\\n        }\\n        else\\n        {\\n            struct ListNode *temp = head;\\n            while(i<k-1\\n            )\\n            {\\n                temp=temp->next;\\n                i++;\\n            }\\n            temp->next=reverseEven(temp->next,k+1);\\n            return head;\\n        }\\n    }\\n}\\nstruct ListNode *reverseEvenLengthGroups(struct ListNode *head)\\n{\\n    return reverseEven(head, 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode *reverseList(struct ListNode *head)\\n{\\n    if (head == NULL || head->next == NULL)\\n    {\\n        return head;\\n    }\\n    struct ListNode *prev = NULL;\\n    struct ListNode *curr = head;\\n    struct ListNode *Next = head->next;\\n    while (curr->next != NULL)\\n    {\\n        curr->next = prev;\\n        prev = curr;\\n        curr = Next;\\n        Next = curr->next;\\n    }\\n    curr->next = prev;\\n    return curr;\\n}\\nint len(struct ListNode *temp)\\n{\\n    int count = 0;\\n    while (temp != NULL)\\n    {\\n        count++;\\n        temp = temp->next;\\n    }\\n    return count;\\n}\\nstruct ListNode *reverseEven(struct ListNode *head, int k)\\n{\\n    if (len(head) < k)\\n    {\\n        if(len(head)%2==0)\\n        {\\n            return reverseList(head);\\n        }\\n        else\\n        {\\n            return head;\\n        }\\n    }\\n    else\\n    {\\n        int i = 0;\\n        if (k % 2 == 0)\\n        {\\n\\n            struct ListNode *prev = NULL;\\n            struct ListNode *curr = head;\\n            struct ListNode *Next = curr->next;\\n            struct ListNode *temp = head;\\n            while (i < k)\\n            {\\n                curr->next = prev;\\n                prev = curr;\\n                curr = Next;\\n                if (Next != NULL)\\n                {\\n\\n                    Next = curr->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                i++;\\n            }\\n            head->next = reverseEven(curr, k+1);\\n            return prev;\\n        }\\n        else\\n        {\\n            struct ListNode *temp = head;\\n            while(i<k-1\\n            )\\n            {\\n                temp=temp->next;\\n                i++;\\n            }\\n            temp->next=reverseEven(temp->next,k+1);\\n            return head;\\n        }\\n    }\\n}\\nstruct ListNode *reverseEvenLengthGroups(struct ListNode *head)\\n{\\n    return reverseEven(head, 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3696908,
                "title": "beats-97-80-java-solution-linkedlist",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int grpSize = 1;\\n        int cnt = 0;\\n\\n        ListNode left = null;\\n        ListNode last = null;\\n        ListNode ptr = head;\\n\\n        while(ptr != null){\\n            cnt++;\\n            if(cnt == grpSize){\\n                if(grpSize% 2 == 0 ){\\n                    ListNode end = ptr.next;\\n                    // reverse the lst;\\n                    ListNode curr = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n\\n                    while(curr != end){\\n                        next = curr.next;\\n                        curr.next = prev;\\n                        prev = curr;\\n                        curr = next;\\n                    }\\n                    //connect\\n                    last.next = prev;\\n                    ptr = left;\\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                cnt = 0;\\n                grpSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(cnt > 0 && cnt % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int grpSize = 1;\\n        int cnt = 0;\\n\\n        ListNode left = null;\\n        ListNode last = null;\\n        ListNode ptr = head;\\n\\n        while(ptr != null){\\n            cnt++;\\n            if(cnt == grpSize){\\n                if(grpSize% 2 == 0 ){\\n                    ListNode end = ptr.next;\\n                    // reverse the lst;\\n                    ListNode curr = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n\\n                    while(curr != end){\\n                        next = curr.next;\\n                        curr.next = prev;\\n                        prev = curr;\\n                        curr = next;\\n                    }\\n                    //connect\\n                    last.next = prev;\\n                    ptr = left;\\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                cnt = 0;\\n                grpSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(cnt > 0 && cnt % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671444,
                "title": "easy-implementation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimulate the process .\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len=0;\\n        ListNode* p=head;\\n        while(p!=NULL){\\n            len++;\\n            p=p->next;\\n        }\\n        int gr=1;\\n        int cov=0;\\n        ListNode* curr=head;\\n        ListNode* prev;\\n        while(curr!=NULL){\\n            if((gr%2==0 && (len-cov)>=gr)|| ((len-cov)%2==0 && (len-cov)<=gr)){\\n                ListNode* a=curr;\\n                ListNode* b=a->next;\\n                ListNode* cur=b->next;\\n                ListNode* end=curr;\\n                int ct=gr;\\n                while(ct-- && end!=NULL){\\n                    end=end->next;\\n                }\\n                while(cur!=NULL && cur!=end){\\n                    b->next=a;\\n                    a=b;\\n                    b=cur;\\n                    cur=cur->next;\\n                }\\n                b->next=a;\\n                curr->next=end;\\n                prev->next=b;\\n                prev=curr;\\n                curr=end;\\n            }else{\\n                int ct=gr;\\n                while(ct-- && curr!=NULL){\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n            }\\n            cov+=gr;\\n            gr++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len=0;\\n        ListNode* p=head;\\n        while(p!=NULL){\\n            len++;\\n            p=p->next;\\n        }\\n        int gr=1;\\n        int cov=0;\\n        ListNode* curr=head;\\n        ListNode* prev;\\n        while(curr!=NULL){\\n            if((gr%2==0 && (len-cov)>=gr)|| ((len-cov)%2==0 && (len-cov)<=gr)){\\n                ListNode* a=curr;\\n                ListNode* b=a->next;\\n                ListNode* cur=b->next;\\n                ListNode* end=curr;\\n                int ct=gr;\\n                while(ct-- && end!=NULL){\\n                    end=end->next;\\n                }\\n                while(cur!=NULL && cur!=end){\\n                    b->next=a;\\n                    a=b;\\n                    b=cur;\\n                    cur=cur->next;\\n                }\\n                b->next=a;\\n                curr->next=end;\\n                prev->next=b;\\n                prev=curr;\\n                curr=end;\\n            }else{\\n                int ct=gr;\\n                while(ct-- && curr!=NULL){\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n            }\\n            cov+=gr;\\n            gr++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668258,
                "title": "i-woke-up-and-wrote-perfect-code",
                "content": "# Intuition\\nI didn\\'t like any of the solutions, so I slept. When I woke up I coded this in one go. I like how clean this is compared to my previous tries at this problem. \\nIt is verry self explanatory to just know when we are entering a odd section and even section. \\nThat is denoted by \\n\\n```\\nnodesRemaining\\n``` \\n\\nIf we enter odd, we just traverse over the section till our head is in even section\\n\\nIf we enter even we just use the reverse trick of reversing a Linked List - II problem to cover it in single pass.\\n\\n```\\nwhile(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n\\n```\\neg.    lets say we just entered section of even with count 4 and want to reverse A->B->C->D\\n\\n```\\n.... X -> A -> B-> C ->D ->Z ....\\nPrev ->  X\\nHead -> A\\n\\n```\\nthen assign as following:\\n\\n```\\n.... X -> A -> B-> C ->D ->Z ....\\n     P    H    F   T\\n\\nwhere P=> prev, H=> head, F=> forward, T=>tmp\\n\\n```\\nSince, we have a pointer T to the remaining chain we can directly make F point to something else. But to what?\\n\\nIf we make it point to H, then Prev will connect to the wrong stuff for the case where :\\n\\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n     P             H   F  T\\n\\n\\n```\\nSo, we  must make F go the beginning of whatever we reversed till now\\nSo \\n\\n```\\nF-> next = P-> next;\\n\\n```\\nThis was the key observation, \\nNow, we make our head drag its way always to connect with T. You can directly join H to T as H doesnt need to point to F anymore\\n\\n```\\nhead->next = tmp\\n\\n```\\nand subsequently just make P point to F since its the newest addition in the back of reversed string up till now\\n\\n```\\nprev->next = fwd;\\n\\n```\\n\\nKeep doing this till we have Head->next && --count still present as if it is present then it means there is something in front (F) of head which we must move back\\n\\n\\n```\\n.... X -> D -> C-> B -> A ->Z -> NULL\\n     P                  H   F     T\\n\\n\\n```\\n\\nAt the end Head will still be pointing to an element of even section and thats why we move it along to enter the odd section as in below code.\\n\\nWe also Need to help the prev move over the whole section once we have covered so the lines of \\n\\n```\\n prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n```\\nSo finally we get:\\n\\n\\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n                   P   H\\n                       odd section starts from D\\n\\n\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n O(2n) = O(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode *prev;\\n\\n    ListNode* traverseOdd(ListNode *head, int count){\\n        for(int i=0;i<count;i++){\\n            if(head->next != nullptr){\\n                prev = head;\\n                head = head->next;\\n            } else {\\n                return head;\\n            }\\n        }\\n        return head;\\n    }\\n\\n    ListNode* reverseEven(ListNode* head, int count){\\n        \\n        while(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n        prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n\\n    }\\n\\n    int countForward(ListNode* tmp, int count) {\\n        int j = 0;\\n        while(tmp && j<count) {\\n            tmp = tmp->next;\\n            j++;\\n        }\\n        return j;\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head == nullptr){\\n            return head;\\n        }\\n        ListNode *dummy = new ListNode(0);\\n        dummy = head;\\n        int count = 1;\\n        prev = new ListNode(0);\\n        prev->next = head;\\n        while(head->next){\\n            ListNode* tmp = head;\\n            int nodesRemaining = countForward(tmp, count);\\n            if(nodesRemaining >= count){\\n                if(count%2){\\n                    head = traverseOdd(head, count);\\n                } else {\\n                    head = reverseEven(head, count); \\n                }\\n            } else {\\n                if(nodesRemaining%2){\\n                     head = traverseOdd(head, nodesRemaining);\\n                } else {\\n                    head = reverseEven(head, nodesRemaining); \\n                }\\n            }\\n            \\n        count++;\\n        }\\n        return dummy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nnodesRemaining\\n```\n```\\nwhile(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n\\n```\n```\\n.... X -> A -> B-> C ->D ->Z ....\\nPrev ->  X\\nHead -> A\\n\\n```\n```\\n.... X -> A -> B-> C ->D ->Z ....\\n     P    H    F   T\\n\\nwhere P=> prev, H=> head, F=> forward, T=>tmp\\n\\n```\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n     P             H   F  T\\n\\n\\n```\n```\\nF-> next = P-> next;\\n\\n```\n```\\nhead->next = tmp\\n\\n```\n```\\nprev->next = fwd;\\n\\n```\n```\\n.... X -> D -> C-> B -> A ->Z -> NULL\\n     P                  H   F     T\\n\\n\\n```\n```\\n prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n```\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n                   P   H\\n                       odd section starts from D\\n\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode *prev;\\n\\n    ListNode* traverseOdd(ListNode *head, int count){\\n        for(int i=0;i<count;i++){\\n            if(head->next != nullptr){\\n                prev = head;\\n                head = head->next;\\n            } else {\\n                return head;\\n            }\\n        }\\n        return head;\\n    }\\n\\n    ListNode* reverseEven(ListNode* head, int count){\\n        \\n        while(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n        prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n\\n    }\\n\\n    int countForward(ListNode* tmp, int count) {\\n        int j = 0;\\n        while(tmp && j<count) {\\n            tmp = tmp->next;\\n            j++;\\n        }\\n        return j;\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head == nullptr){\\n            return head;\\n        }\\n        ListNode *dummy = new ListNode(0);\\n        dummy = head;\\n        int count = 1;\\n        prev = new ListNode(0);\\n        prev->next = head;\\n        while(head->next){\\n            ListNode* tmp = head;\\n            int nodesRemaining = countForward(tmp, count);\\n            if(nodesRemaining >= count){\\n                if(count%2){\\n                    head = traverseOdd(head, count);\\n                } else {\\n                    head = reverseEven(head, count); \\n                }\\n            } else {\\n                if(nodesRemaining%2){\\n                     head = traverseOdd(head, nodesRemaining);\\n                } else {\\n                    head = reverseEven(head, nodesRemaining); \\n                }\\n            }\\n            \\n        count++;\\n        }\\n        return dummy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659487,
                "title": "javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\nAmortized O(n), as the check for `isEvenGroup` occurs in the last group, which increases proportionally to n, resulting in a complexity of O(sqrt(n)). However, these calculations can be shared among other groups, thus leading to an amortized complexity of O(1) for `isEvenGroup`\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseEvenLengthGroups = function(head) {\\n    if(head?.next?.next == null) {\\n        return head;\\n    }\\n    let fastNode = head;\\n    let slowNode = head;\\n\\n    let firstNode = head;\\n    let nthGroup = 2;\\n    while(slowNode != null && slowNode.next != null) {\\n        fastNode = fastNode?.next?.next\\n        firstNode = slowNode;\\n        slowNode = slowNode.next;\\n        if(fastNode != null && nthGroup % 2 === 0 || fastNode == null && isEvenGroup(slowNode)) {\\n            [fastNode, slowNode] = reverseNodesMutation(firstNode, slowNode, fastNode)\\n        }\\n\\n        nthGroup++\\n        for(let i = 0; i < nthGroup - 2; i++) {\\n            fastNode = fastNode?.next;\\n            slowNode = slowNode?.next;\\n        }\\n    }\\n    return head;\\n};\\n\\nfunction isEvenGroup(slowNode) {\\n    let count = 0;\\n    while(slowNode != null) {\\n        slowNode = slowNode.next;\\n        count++\\n    }\\n    return count % 2 === 0;\\n}\\n\\n// 0 | 1 2 null |\\nfunction reverseNodesMutation(firstNode, slowNode, fastNode) {\\n    const lastNode = fastNode?.next ?? null;\\n    let prevSlowNode = lastNode;\\n    let slowNodePointer = slowNode;\\n    while(slowNodePointer != lastNode) {\\n        const nextSlowNode = slowNodePointer.next;\\n        slowNodePointer.next = prevSlowNode;\\n        prevSlowNode = slowNodePointer\\n        slowNodePointer = nextSlowNode\\n    }\\n    firstNode.next = fastNode ?? prevSlowNode\\n    return [slowNode, fastNode];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseEvenLengthGroups = function(head) {\\n    if(head?.next?.next == null) {\\n        return head;\\n    }\\n    let fastNode = head;\\n    let slowNode = head;\\n\\n    let firstNode = head;\\n    let nthGroup = 2;\\n    while(slowNode != null && slowNode.next != null) {\\n        fastNode = fastNode?.next?.next\\n        firstNode = slowNode;\\n        slowNode = slowNode.next;\\n        if(fastNode != null && nthGroup % 2 === 0 || fastNode == null && isEvenGroup(slowNode)) {\\n            [fastNode, slowNode] = reverseNodesMutation(firstNode, slowNode, fastNode)\\n        }\\n\\n        nthGroup++\\n        for(let i = 0; i < nthGroup - 2; i++) {\\n            fastNode = fastNode?.next;\\n            slowNode = slowNode?.next;\\n        }\\n    }\\n    return head;\\n};\\n\\nfunction isEvenGroup(slowNode) {\\n    let count = 0;\\n    while(slowNode != null) {\\n        slowNode = slowNode.next;\\n        count++\\n    }\\n    return count % 2 === 0;\\n}\\n\\n// 0 | 1 2 null |\\nfunction reverseNodesMutation(firstNode, slowNode, fastNode) {\\n    const lastNode = fastNode?.next ?? null;\\n    let prevSlowNode = lastNode;\\n    let slowNodePointer = slowNode;\\n    while(slowNodePointer != lastNode) {\\n        const nextSlowNode = slowNodePointer.next;\\n        slowNodePointer.next = prevSlowNode;\\n        prevSlowNode = slowNodePointer\\n        slowNodePointer = nextSlowNode\\n    }\\n    firstNode.next = fastNode ?? prevSlowNode\\n    return [slowNode, fastNode];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653124,
                "title": "python-in-place-reversal-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        #count total_length\\n        def count_length(head):\\n            pointer, counter = head, 0\\n            while pointer:\\n                pointer, counter = pointer.next, counter + 1\\n            return counter\\n\\n        #reverse n nodes starting from parent.next\\n        def reverse_n_nodes(parent, n):\\n            prev, current, next_ = parent.next, parent.next.next, parent.next.next.next\\n            tail = prev\\n            for i in range(n - 1):\\n                parent.next = current\\n                current.next = prev\\n                prev, current, next_ = current, next_, next_.next if next_ else None\\n            tail.next = current\\n            return tail\\n            \\n        total_length, length, parent = count_length(head), 1, ListNode(-1, head)\\n\\n        while total_length > 0:\\n            if length % 2 == 1:\\n                # Go to the parent of the next group\\n                for i in range(length):\\n                    parent = parent.next\\n            else:\\n                #Reverse length nodes\\n                parent = reverse_n_nodes(parent, length)\\n            total_length -= length\\n            length = min(length + 1, total_length)\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        #count total_length\\n        def count_length(head):\\n            pointer, counter = head, 0\\n            while pointer:\\n                pointer, counter = pointer.next, counter + 1\\n            return counter\\n\\n        #reverse n nodes starting from parent.next\\n        def reverse_n_nodes(parent, n):\\n            prev, current, next_ = parent.next, parent.next.next, parent.next.next.next\\n            tail = prev\\n            for i in range(n - 1):\\n                parent.next = current\\n                current.next = prev\\n                prev, current, next_ = current, next_, next_.next if next_ else None\\n            tail.next = current\\n            return tail\\n            \\n        total_length, length, parent = count_length(head), 1, ListNode(-1, head)\\n\\n        while total_length > 0:\\n            if length % 2 == 1:\\n                # Go to the parent of the next group\\n                for i in range(length):\\n                    parent = parent.next\\n            else:\\n                #Reverse length nodes\\n                parent = reverse_n_nodes(parent, length)\\n            total_length -= length\\n            length = min(length + 1, total_length)\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651016,
                "title": "c-reverse-nodes-in-even-length-groups",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* Reverse(ListNode* p, ListNode* q){\\n        ListNode* prev = nullptr;\\n        ListNode* curr = p;\\n        ListNode* next = nullptr;\\n        \\n        while (curr != nullptr && curr != q) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        curr->next = prev;\\n        prev = curr;\\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *ans=head, *p =head->next, *curr = head, *s, *e, *t, *z;\\n        int x = 1, n = 1, a;\\n        while(p){\\n            t = p;\\n            s = p;\\n            x = 1 + x;\\n            a = x;\\n            n=1;\\n            while(a>1 && t->next){\\n                t = t->next;\\n                a--;\\n                n++;\\n            }\\n            e = t;\\n            p = t->next;\\n            if(n%2 == 0){\\n                z = Reverse(s, e);\\n                curr->next = z;\\n                while(curr->next){\\n                    curr = curr->next;\\n                }\\n            }\\n            else{\\n                curr->next = s;\\n                curr = e;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* Reverse(ListNode* p, ListNode* q){\\n        ListNode* prev = nullptr;\\n        ListNode* curr = p;\\n        ListNode* next = nullptr;\\n        \\n        while (curr != nullptr && curr != q) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        curr->next = prev;\\n        prev = curr;\\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *ans=head, *p =head->next, *curr = head, *s, *e, *t, *z;\\n        int x = 1, n = 1, a;\\n        while(p){\\n            t = p;\\n            s = p;\\n            x = 1 + x;\\n            a = x;\\n            n=1;\\n            while(a>1 && t->next){\\n                t = t->next;\\n                a--;\\n                n++;\\n            }\\n            e = t;\\n            p = t->next;\\n            if(n%2 == 0){\\n                z = Reverse(s, e);\\n                curr->next = z;\\n                while(curr->next){\\n                    curr = curr->next;\\n                }\\n            }\\n            else{\\n                curr->next = s;\\n                curr = e;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649759,
                "title": "kotlin-same-as-all-other-solutions-o-n-o-1-no-negative-marking-for-bad-humour",
                "content": "# Intuition\\nTrack groups with even nodes ( edge case where last group was odd but has only even nodes due to shortage, is also part of this)\\n# Approach\\nTraverse the whole LL from start to end. For each group maintain the following: \\n- Group number\\n- Number of nodes in the group\\n- Pointer to start of current group\\n\\nFor reversing the LL, we need to perform the few extra steps as follows:\\n- The start of LL will be end so store it and return so that p can be updated\\n- start and end are actually subset of a bigger LL so point the end and terminal nodes. \\n- Happy reversing. \\n\\n# Complexity\\n- Time complexity:\\nO(N + N/2)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var group = 1   // Holds the group number\\n        var groupCounter = 0  // Number of nodes in current group\\n        var prevGroupNode = head  // Start of our current group\\n        var p = head\\n        while(p != null){\\n            ++groupCounter\\n            if(groupCounter == group || p!!.next == null){ // End of current group\\n                if(groupCounter % 2 == 0){\\n                    p = swap(prevGroupNode, prevGroupNode!!.next, prevGroupNode!!.next!!.next, p)\\n                }\\n                groupCounter = 0\\n                prevGroupNode = p\\n                ++group\\n            }\\n            p = p!!.next\\n        }\\n        return head\\n    }\\n\\n    // None of these will be [null] to begin with as we will be reversing atleast 2 nodes\\n    // Endnode is required to understand the terminal condition as it will not be null\\n    fun swap( p1: ListNode?, p2: ListNode?, p3: ListNode?, endNode: ListNode?): ListNode? { \\n\\n        // Please forgive me for shadowing some good vals. Kids this is bad coding. Don\\'t follow this at home\\n        var p1 = p1  \\n        var p2 = p2\\n        var p3 = p3\\n\\n        // Preparation\\n        var op = p2 // This will be our new p\\n        p1!!.next = endNode\\n        p2!!.next = endNode!!.next\\n\\n        // Time to move pointers after preparations\\n        p1 = p2\\n        p2 = p3\\n        p3 = p3!!.next\\n\\n        // Happy hunting\\n        while(p1 != endNode){\\n            p2!!.next = p1\\n            p1 = p2\\n            p2 = p3\\n            if(p3 != null)\\n            p3 = p3!!.next\\n        }\\n\\n        // Dinner is ready\\n        return op\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var group = 1   // Holds the group number\\n        var groupCounter = 0  // Number of nodes in current group\\n        var prevGroupNode = head  // Start of our current group\\n        var p = head\\n        while(p != null){\\n            ++groupCounter\\n            if(groupCounter == group || p!!.next == null){ // End of current group\\n                if(groupCounter % 2 == 0){\\n                    p = swap(prevGroupNode, prevGroupNode!!.next, prevGroupNode!!.next!!.next, p)\\n                }\\n                groupCounter = 0\\n                prevGroupNode = p\\n                ++group\\n            }\\n            p = p!!.next\\n        }\\n        return head\\n    }\\n\\n    // None of these will be [null] to begin with as we will be reversing atleast 2 nodes\\n    // Endnode is required to understand the terminal condition as it will not be null\\n    fun swap( p1: ListNode?, p2: ListNode?, p3: ListNode?, endNode: ListNode?): ListNode? { \\n\\n        // Please forgive me for shadowing some good vals. Kids this is bad coding. Don\\'t follow this at home\\n        var p1 = p1  \\n        var p2 = p2\\n        var p3 = p3\\n\\n        // Preparation\\n        var op = p2 // This will be our new p\\n        p1!!.next = endNode\\n        p2!!.next = endNode!!.next\\n\\n        // Time to move pointers after preparations\\n        p1 = p2\\n        p2 = p3\\n        p3 = p3!!.next\\n\\n        // Happy hunting\\n        while(p1 != endNode){\\n            p2!!.next = p1\\n            p1 = p2\\n            p2 = p3\\n            if(p3 != null)\\n            p3 = p3!!.next\\n        }\\n\\n        // Dinner is ready\\n        return op\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636539,
                "title": "short-clean-c-o-n-constant-space-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind my approach is similar to other solutions but just cleaner code for your reference. Basically it involves 3 steps:\\n1. obtain the actual current group length\\n2. reverse the group if actual length turns to be even length\\n3. reconnect the disconnected group due to reversal. Reset some pointers for the next iteration\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first 2 steps are intuitive and should be easy to implement. For the 3rd step, it\\'s a little bit tricky to get all details right. In my approach, I have the head and end pointers pointing to the starting and ending node of each group. When the reversal is happening, set the prev pointer to be the next group\\'s first node so that it automatically connects the reversed group to the rest of the linked list. Then, we only need to reconnect the previous part of the linked list by pointing prev->next to the original ending node, which is the starting node of the reveresed group.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) since we linearly iterate through the list\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) since fixed number of variables are used\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *end = head, *prev = nullptr, *newHead = head;\\n        for (int groupLen = 1; head; ++groupLen, prev = head, head = head->next, end = head) {\\n            int currLen = 1;\\n            while (currLen < groupLen && end->next) {\\n                end = end->next;\\n                ++currLen;\\n            }\\n\\n            if (currLen % 2 == 0) {\\n                reverseList(head, end->next);\\n                prev->next = end;\\n            } else {\\n                head = end;\\n            }\\n        }\\n        return newHead;\\n    }\\n\\nprivate:\\n    void reverseList(ListNode* head, ListNode* end) {\\n        ListNode *prev = end, *next = head;\\n        while (head != end) {\\n            next = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *end = head, *prev = nullptr, *newHead = head;\\n        for (int groupLen = 1; head; ++groupLen, prev = head, head = head->next, end = head) {\\n            int currLen = 1;\\n            while (currLen < groupLen && end->next) {\\n                end = end->next;\\n                ++currLen;\\n            }\\n\\n            if (currLen % 2 == 0) {\\n                reverseList(head, end->next);\\n                prev->next = end;\\n            } else {\\n                head = end;\\n            }\\n        }\\n        return newHead;\\n    }\\n\\nprivate:\\n    void reverseList(ListNode* head, ListNode* end) {\\n        ListNode *prev = end, *next = head;\\n        while (head != end) {\\n            next = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613934,
                "title": "c-solution-with-explanation",
                "content": "# EXPLANATION\\nWe started from the first node of list.\\nWe kept a count **i** for the **i**th group of list.\\nOur intuition is that we check for **i**th group.\\nIf that group has even length we reverse that set of list or else move formward to the next group.\\nFinally returning the answer.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *a=head;\\n        int i=1;\\n        while(a){\\n            i++;\\n            int j=0;\\n            ListNode *b=a->next,*c=a;\\n            while(b && j<i){\\n                c=c->next;\\n                j++;\\n                b=b->next;\\n            }\\n            if(j%2==0 && j!=0){\\n                ListNode *x=a->next,*y=NULL,*z=x,*t=a->next;\\n                while(j-->0){\\n                    z=x->next;\\n                    x->next=y;\\n                    y=x;\\n                    x=z;\\n                }\\n                a->next=y;\\n                a=t;\\n                a->next=x;\\n            }\\n            else if(b)\\n                a=c;\\n            else \\n                a=b;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *a=head;\\n        int i=1;\\n        while(a){\\n            i++;\\n            int j=0;\\n            ListNode *b=a->next,*c=a;\\n            while(b && j<i){\\n                c=c->next;\\n                j++;\\n                b=b->next;\\n            }\\n            if(j%2==0 && j!=0){\\n                ListNode *x=a->next,*y=NULL,*z=x,*t=a->next;\\n                while(j-->0){\\n                    z=x->next;\\n                    x->next=y;\\n                    y=x;\\n                    x=z;\\n                }\\n                a->next=y;\\n                a=t;\\n                a->next=x;\\n            }\\n            else if(b)\\n                a=c;\\n            else \\n                a=b;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611498,
                "title": "python-solution",
                "content": "# Intuition\\nUse a similar approach to [reverse nodes in k-group](https://leetcode.com/problems/reverse-nodes-in-k-group/solutions/3071426/c-solution/). Create a helper function to reverse a linked list that keeps track of the next node to the reversal and make sure we link each group (reversed with non-reversed).\\n\\n# Approach\\nKeep track of the groups and the size. Make a reversal function that ties together the next node from the current group being reversed. We also need to keep track of the current size of the list and choose the minimum between the group size and the remaining size.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def size(self, head):\\n        size = 0\\n        while head:\\n            size, head = size + 1, head.next\\n        return size\\n\\n    def reverse(self, head, count):\\n        # previous, current, tail is next node after reversal\\n        prev, current, tail = None, head, None\\n        while current and count > 0:\\n            next = current.next           \\n\\n            tail = next\\n            current.next = prev\\n            prev = current            \\n            current = next\\n            count -= 1\\n        # prev is the new head\\n        # head is the last\\n        # the next to head is tail\\n        head.next = tail\\n        return prev\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sentinel = ListNode(0, head)\\n        tail, current = sentinel, sentinel.next\\n        size = self.size(head)\\n\\n        group = 1\\n        while current:\\n            group = min(group, size)\\n            if group % 2: # advance\\n                for _ in range(group):\\n                    tail.next = current\\n                    tail = tail.next\\n                    current = current.next\\n            else: # reversal\\n                tail.next = self.reverse(current, group)\\n                tail = current\\n                current = current.next\\n            size -= group\\n            group += 1        \\n        return sentinel.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def size(self, head):\\n        size = 0\\n        while head:\\n            size, head = size + 1, head.next\\n        return size\\n\\n    def reverse(self, head, count):\\n        # previous, current, tail is next node after reversal\\n        prev, current, tail = None, head, None\\n        while current and count > 0:\\n            next = current.next           \\n\\n            tail = next\\n            current.next = prev\\n            prev = current            \\n            current = next\\n            count -= 1\\n        # prev is the new head\\n        # head is the last\\n        # the next to head is tail\\n        head.next = tail\\n        return prev\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sentinel = ListNode(0, head)\\n        tail, current = sentinel, sentinel.next\\n        size = self.size(head)\\n\\n        group = 1\\n        while current:\\n            group = min(group, size)\\n            if group % 2: # advance\\n                for _ in range(group):\\n                    tail.next = current\\n                    tail = tail.next\\n                    current = current.next\\n            else: # reversal\\n                tail.next = self.reverse(current, group)\\n                tail = current\\n                current = current.next\\n            size -= group\\n            group += 1        \\n        return sentinel.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609344,
                "title": "java-solution-o-n-time-o-1-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // pointer before a group\\n        var before = head;\\n\\n        // max nodes in a group (but may be less if the group is the last)\\n        int max = 2; //start with second group right away\\n\\n        while (before.next != null) { // pass through a group\\n            int len = 0;\\n            var curr = before;\\n            \\n            while (curr.next != null && len < max) {   \\n                curr = curr.next;\\n                len++;\\n            }\\n\\n            // group is even && len is even -> reverse\\n            // group is even && len is odd -> last group (odd) -> skip\\n            // group is odd && len is even -> last group (even) -> reverse\\n            // group is odd && len is odd -> reverse\\n            // all boils down to whether len is even or not\\n            if (len % 2 == 0) { // \\n                before = reverse(before, len);\\n            } else {\\n                before = curr;\\n            }\\n            \\n            max++;\\n        }\\n        return head;\\n    }\\n\\n    ListNode reverse(ListNode before, int len) {\\n        var first = before.next; \\n        var curr = first;\\n        ListNode prev = null;\\n        \\n        int count = 0;\\n        while (count < len ) { \\n            // swap pointers\\n            var next = curr.next; \\n            curr.next = prev; \\n            prev = curr; \\n            curr = next; \\n            \\n            count++;\\n        }\\n\\n        // swap node before the current group with last node in the group and  \\n        before.next = prev;\\n        // swap first node in group with first node outside the group\\n        first.next = curr;\\n\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // pointer before a group\\n        var before = head;\\n\\n        // max nodes in a group (but may be less if the group is the last)\\n        int max = 2; //start with second group right away\\n\\n        while (before.next != null) { // pass through a group\\n            int len = 0;\\n            var curr = before;\\n            \\n            while (curr.next != null && len < max) {   \\n                curr = curr.next;\\n                len++;\\n            }\\n\\n            // group is even && len is even -> reverse\\n            // group is even && len is odd -> last group (odd) -> skip\\n            // group is odd && len is even -> last group (even) -> reverse\\n            // group is odd && len is odd -> reverse\\n            // all boils down to whether len is even or not\\n            if (len % 2 == 0) { // \\n                before = reverse(before, len);\\n            } else {\\n                before = curr;\\n            }\\n            \\n            max++;\\n        }\\n        return head;\\n    }\\n\\n    ListNode reverse(ListNode before, int len) {\\n        var first = before.next; \\n        var curr = first;\\n        ListNode prev = null;\\n        \\n        int count = 0;\\n        while (count < len ) { \\n            // swap pointers\\n            var next = curr.next; \\n            curr.next = prev; \\n            prev = curr; \\n            curr = next; \\n            \\n            count++;\\n        }\\n\\n        // swap node before the current group with last node in the group and  \\n        before.next = prev;\\n        // swap first node in group with first node outside the group\\n        first.next = curr;\\n\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598856,
                "title": "6-reverse-nodes-in-even-length-groups",
                "content": "#### Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI immediately thought of using a fast and slow pointers + keeping count of the current number of nodes in the group and the maximum number of nodes in the group. The later was correct, but the former was misguided. The objectives are the position of the last element of the previous group and the last element of the current group, which are needed for reversing. In that sense, it is sliding window, with the one side fixed at the last element of the previous group, while the other is dragged out to the last element of the current group. At each window, we check the oddity of the current number of nodes and reverse if necessary.\\n\\n#### Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the left pointer and max group length.\\n2. Iterate the linked list starting at `head.next` (the first element does not need to be reversed), one window up to the max group length at a time.\\n3. If there are even number of nodes in the window, reverse it. Else, do nothing.\\n4. Return `head` after modification.\\n\\n#### Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n)$: Iterate the linked list less than two times.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$: Store only some integers.\\n\\n#### Code\\n\\nThe shorthand reversal in Python is included in comments. While it looks awesome, I think that I should avoid it here as it makes debugging impossible and is certain to confuse my colleagues.\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group_prev = head\\n        curr_max_length = 2\\n\\n        while group_prev.next:\\n            curr = group_prev\\n            count = 0\\n            \\n            for _ in range(curr_max_length):\\n                if not curr.next:\\n                    break\\n                count += 1\\n                curr = curr.next\\n\\n            if count % 2: # Odd, do nothing\\n                group_prev = curr\\n            else:         # Even, reverse\\n                group_next = curr.next\\n                curr = group_prev.next\\n                \\n                for _ in range(count):\\n                    # curr.next, curr, group_next = group_next, curr.next, curr\\n                    curr_next = curr.next\\n                    curr.next = group_next\\n                    group_next = curr\\n                    curr = curr_next\\n                # group_prev.next.next, group_prev.next, group_prev = curr, group_next, group_prev.next\\n                prev_next = group_prev.next\\n                group_prev.next = group_next\\n                group_prev = prev_next\\n            curr_max_length += 1\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group_prev = head\\n        curr_max_length = 2\\n\\n        while group_prev.next:\\n            curr = group_prev\\n            count = 0\\n            \\n            for _ in range(curr_max_length):\\n                if not curr.next:\\n                    break\\n                count += 1\\n                curr = curr.next\\n\\n            if count % 2: # Odd, do nothing\\n                group_prev = curr\\n            else:         # Even, reverse\\n                group_next = curr.next\\n                curr = group_prev.next\\n                \\n                for _ in range(count):\\n                    # curr.next, curr, group_next = group_next, curr.next, curr\\n                    curr_next = curr.next\\n                    curr.next = group_next\\n                    group_next = curr\\n                    curr = curr_next\\n                # group_prev.next.next, group_prev.next, group_prev = curr, group_next, group_prev.next\\n                prev_next = group_prev.next\\n                group_prev.next = group_next\\n                group_prev = prev_next\\n            curr_max_length += 1\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585351,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def reverse(node, size):\\n            prev = None\\n            curr = node\\n            fllw = None\\n\\n            for _ in range(size):\\n                fllw = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = fllw\\n\\n            return prev\\n\\n        group_starts = []\\n        curr = head\\n        group_size = 1 \\n        while curr:\\n            group_starts.append([group_size, curr])\\n            for _ in range(group_size):\\n                if curr:\\n                    curr = curr.next\\n            group_size += 1\\n        \\n        res = []\\n        count = 0\\n        for start in group_starts:\\n            count += 1\\n            if count == len(group_starts):\\n                # last element\\n                length = 0\\n                curr = start[1]\\n                while curr:\\n                    length += 1\\n                    curr = curr.next\\n                if length % 2 == 0:\\n                    res.append([start[0], reverse(start[1], length)])\\n                else:\\n                    res.append(start)\\n            elif start[0] % 2 == 0:\\n                res.append([start[0], reverse(start[1], start[0])])\\n            else:\\n                res.append(start)\\n\\n        dummy = tail = ListNode()\\n        for pair in res:\\n            size = pair[0]\\n            node = pair[1]\\n            tail.next = node\\n            for _ in range(size):\\n                if tail:\\n                    tail = tail.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def reverse(node, size):\\n            prev = None\\n            curr = node\\n            fllw = None\\n\\n            for _ in range(size):\\n                fllw = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = fllw\\n\\n            return prev\\n\\n        group_starts = []\\n        curr = head\\n        group_size = 1 \\n        while curr:\\n            group_starts.append([group_size, curr])\\n            for _ in range(group_size):\\n                if curr:\\n                    curr = curr.next\\n            group_size += 1\\n        \\n        res = []\\n        count = 0\\n        for start in group_starts:\\n            count += 1\\n            if count == len(group_starts):\\n                # last element\\n                length = 0\\n                curr = start[1]\\n                while curr:\\n                    length += 1\\n                    curr = curr.next\\n                if length % 2 == 0:\\n                    res.append([start[0], reverse(start[1], length)])\\n                else:\\n                    res.append(start)\\n            elif start[0] % 2 == 0:\\n                res.append([start[0], reverse(start[1], start[0])])\\n            else:\\n                res.append(start)\\n\\n        dummy = tail = ListNode()\\n        for pair in res:\\n            size = pair[0]\\n            node = pair[1]\\n            tail.next = node\\n            for _ in range(size):\\n                if tail:\\n                    tail = tail.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579251,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can\\'t determine if the current group working on has enough length while traversing the group, so we must move forward some steps to determine if it has before deciding whether we reverse or not. We\\'ll have a auxilliary function `nextnum` to do this.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermine if the number of nodes from the current node equals the group length at every first node of groups.\\n\\nIf it does has the right number of nodes available, and the group number is even, we reverse such number of nodes. if it\\'s odd, just iterate through such number of nodes.\\n\\nIf not, it means that we meet the last group, with possibly 0 members. if the number it contains is not 0 and it is even, just reverse it like above, but with the number of nodes reversed be the number of this group, rather than the group number, as the current group does not have so many nodes as the group number.\\n\\nAbove is the main logic. Let\\'s talk about implementation.\\n\\nThe process of reversing and iterating nodes is similar, so we can use a single segment of code to do the both. In the code segment, we check whether the number of nodes we\\'re reversing is even, if so, just add some reversing specific code, like `cur->next = prev`.\\n\\nThere\\'s one thing to notice, after reversing the nodes, we have to modify `prev`, as after reversing, the node `prev` points to is indeed the start node of the reversed region, not the end node, we should ensure `prev` points to the right node by `prev = end`.\\n\\n\\n# Complexity\\n- Time complexity:O(n) obviously\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) obviously\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *prev(head),*cur(head->next);\\n        int gn(2);\\n        int n;\\n        while ((n = nextnum(cur,gn)) == gn) {\\n            //reverse or just iterate, depending on evenness of gn\\n            traverse(prev,cur,gn);\\n            ++gn;\\n        }\\n        //meets the last group with possibly 0 member\\n        if (n != 0 && !(n & 1)) {\\n            //reverse n nodes from cur\\n            traverse(prev,cur,n);\\n        }\\n        return head;\\n    }\\nprivate:\\n    //auxilliary counting function\\n    int nextnum(ListNode *node,int n) {\\n        int cnt(0);\\n        for (; node && cnt < n; ++cnt) {\\n            node = node->next;\\n        }\\n        return cnt;\\n    }\\n    void traverse(ListNode *&prev,ListNode *&cur,int n) {\\n        //save some ordinary infos in reversing process\\n        auto begprev = prev, end = cur;\\n        for (int i(0); i < n; ++i) {\\n            auto next = cur->next;\\n            //if we are reversing, some extra work is required\\n            if (!(n & 1)) {\\n                cur->next = prev;\\n            }\\n            prev = cur;\\n            cur = next;\\n        }\\n        //if we are reversing, some extra work is required\\n        if (!(n & 1)) {\\n            begprev->next = prev;\\n            end->next = cur;\\n            //adjust prev\\n            prev = end;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *prev(head),*cur(head->next);\\n        int gn(2);\\n        int n;\\n        while ((n = nextnum(cur,gn)) == gn) {\\n            //reverse or just iterate, depending on evenness of gn\\n            traverse(prev,cur,gn);\\n            ++gn;\\n        }\\n        //meets the last group with possibly 0 member\\n        if (n != 0 && !(n & 1)) {\\n            //reverse n nodes from cur\\n            traverse(prev,cur,n);\\n        }\\n        return head;\\n    }\\nprivate:\\n    //auxilliary counting function\\n    int nextnum(ListNode *node,int n) {\\n        int cnt(0);\\n        for (; node && cnt < n; ++cnt) {\\n            node = node->next;\\n        }\\n        return cnt;\\n    }\\n    void traverse(ListNode *&prev,ListNode *&cur,int n) {\\n        //save some ordinary infos in reversing process\\n        auto begprev = prev, end = cur;\\n        for (int i(0); i < n; ++i) {\\n            auto next = cur->next;\\n            //if we are reversing, some extra work is required\\n            if (!(n & 1)) {\\n                cur->next = prev;\\n            }\\n            prev = cur;\\n            cur = next;\\n        }\\n        //if we are reversing, some extra work is required\\n        if (!(n & 1)) {\\n            begprev->next = prev;\\n            end->next = cur;\\n            //adjust prev\\n            prev = end;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572320,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n\\n        int l=2;\\n\\n        ListNode *prev = head;\\n        while(prev->next)\\n        {\\n            int i;\\n            ListNode *node = prev;\\n            for(i=0;i<l;i++)\\n            {\\n                if(!node->next)\\n                {\\n                    break;\\n                }\\n                node = node->next;\\n            }\\n\\n            if(i%2) //odd len\\n            {\\n                prev=node;\\n            }\\n            else\\n            {\\n                ListNode *reverse = node->next;\\n                ListNode *current = prev->next;\\n\\n                ListNode *nextNode = nullptr;\\n                for(int k=0;k<i;k++)\\n                {\\n                    nextNode = current->next;\\n                    current->next = reverse;\\n                    reverse = current;\\n                    current = nextNode; \\n                }\\n                ListNode *prevNext = prev->next;\\n                prev->next = reverse;\\n                prev = prevNext;\\n            }\\n\\n            l++;\\n        }\\n\\n\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n\\n        int l=2;\\n\\n        ListNode *prev = head;\\n        while(prev->next)\\n        {\\n            int i;\\n            ListNode *node = prev;\\n            for(i=0;i<l;i++)\\n            {\\n                if(!node->next)\\n                {\\n                    break;\\n                }\\n                node = node->next;\\n            }\\n\\n            if(i%2) //odd len\\n            {\\n                prev=node;\\n            }\\n            else\\n            {\\n                ListNode *reverse = node->next;\\n                ListNode *current = prev->next;\\n\\n                ListNode *nextNode = nullptr;\\n                for(int k=0;k<i;k++)\\n                {\\n                    nextNode = current->next;\\n                    current->next = reverse;\\n                    reverse = current;\\n                    current = nextNode; \\n                }\\n                ListNode *prevNext = prev->next;\\n                prev->next = reverse;\\n                prev = prevNext;\\n            }\\n\\n            l++;\\n        }\\n\\n\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552974,
                "title": "java-o-n-solution-using-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null){\\n            return head;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        if(head.next != null && head.next.next == null){\\n            return head;\\n        }\\n        ListNode dummy = head;\\n        ListNode ptr = head.next;\\n        int k = 2;\\n        while(ptr != null){\\n        ListNode curr = ptr;\\n        ListNode nextHead = curr;\\n        int start = 1;\\n        while(start < k){\\n            ptr = ptr.next;\\n            if(ptr == null){\\n                break;\\n            }\\n            start++;\\n        }\\n        if(ptr != null){\\n        ptr = ptr.next;\\n        }\\n        if(start %2 == 0){\\n        ListNode prev = ptr;\\n        while(start-- > 0){\\n        ListNode forward = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = forward;\\n        }\\n        dummy.next = prev;\\n        dummy = nextHead;\\n        }\\n        else{\\n            while(start-- > 0){\\n                dummy = dummy.next;\\n        }\\n        }\\n        k++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null){\\n            return head;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        if(head.next != null && head.next.next == null){\\n            return head;\\n        }\\n        ListNode dummy = head;\\n        ListNode ptr = head.next;\\n        int k = 2;\\n        while(ptr != null){\\n        ListNode curr = ptr;\\n        ListNode nextHead = curr;\\n        int start = 1;\\n        while(start < k){\\n            ptr = ptr.next;\\n            if(ptr == null){\\n                break;\\n            }\\n            start++;\\n        }\\n        if(ptr != null){\\n        ptr = ptr.next;\\n        }\\n        if(start %2 == 0){\\n        ListNode prev = ptr;\\n        while(start-- > 0){\\n        ListNode forward = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = forward;\\n        }\\n        dummy.next = prev;\\n        dummy = nextHead;\\n        }\\n        else{\\n            while(start-- > 0){\\n                dummy = dummy.next;\\n        }\\n        }\\n        k++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539547,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        ListNode *prev,*curr,*nxt,*t1,*t2;\\n        ListNode *dummy=new ListNode();\\n\\n        int i,k;\\n        k=1;\\n\\n        dummy->next=head;\\n        prev=NULL;\\n        curr=head;\\n        t1=dummy;\\n        t2=head;\\n\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp;\\n            temp=curr;\\n\\n            for(i=0;temp!=NULL && i<k;i++)\\n            {\\n                temp=temp->next;\\n            }\\n\\n            if(temp==NULL)\\n            {\\n                k=i;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==0 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==1 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            if(k%2==0)\\n            {\\n                if(t1!=NULL)\\n                {\\n\\n                t1->next=prev;\\n                }\\n                if(t2!=NULL)\\n                {\\n\\n                t2->next=curr;\\n                }\\n                prev=t2;\\n            }\\n\\n            t1=prev;\\n            t2=curr;\\n            k++;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        ListNode *prev,*curr,*nxt,*t1,*t2;\\n        ListNode *dummy=new ListNode();\\n\\n        int i,k;\\n        k=1;\\n\\n        dummy->next=head;\\n        prev=NULL;\\n        curr=head;\\n        t1=dummy;\\n        t2=head;\\n\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp;\\n            temp=curr;\\n\\n            for(i=0;temp!=NULL && i<k;i++)\\n            {\\n                temp=temp->next;\\n            }\\n\\n            if(temp==NULL)\\n            {\\n                k=i;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==0 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==1 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            if(k%2==0)\\n            {\\n                if(t1!=NULL)\\n                {\\n\\n                t1->next=prev;\\n                }\\n                if(t2!=NULL)\\n                {\\n\\n                t2->next=curr;\\n                }\\n                prev=t2;\\n            }\\n\\n            t1=prev;\\n            t2=curr;\\n            k++;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531254,
                "title": "c-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\nstruct ListNode* reverseList(struct ListNode* head)\\n{\\n    if (!head)\\n        return head;\\n    struct ListNode* prev = NULL;\\n    while (head)\\n    {\\n        struct ListNode* temp = head->next;\\n        head->next = prev;\\n        prev = head;\\n        head = temp;\\n    }\\n    return prev;\\n}\\n\\nstruct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n\\n    struct ListNode* prev = dummy;\\n\\n    for (int len = 1; len < 1e5 && head; len++)\\n    {\\n        struct ListNode* tail = head;\\n        struct ListNode* nextHead;\\n\\n        int j = 1;\\n        while (j < len && tail && tail->next)\\n        {\\n            tail = tail->next;\\n            j++;\\n        }\\n\\n        nextHead = tail->next;\\n\\n        if ((j % 2) == 0)\\n        {\\n            tail->next = NULL;\\n            prev->next = reverseList(head);\\n            prev = head;\\n            head->next = nextHead;\\n            head = nextHead;\\n        }\\n        else\\n        {\\n            prev = tail;\\n            head = nextHead;\\n        }\\n    }\\n    return dummy->next;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\nstruct ListNode* reverseList(struct ListNode* head)\\n{\\n    if (!head)\\n        return head;\\n    struct ListNode* prev = NULL;\\n    while (head)\\n    {\\n        struct ListNode* temp = head->next;\\n        head->next = prev;\\n        prev = head;\\n        head = temp;\\n    }\\n    return prev;\\n}\\n\\nstruct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n\\n    struct ListNode* prev = dummy;\\n\\n    for (int len = 1; len < 1e5 && head; len++)\\n    {\\n        struct ListNode* tail = head;\\n        struct ListNode* nextHead;\\n\\n        int j = 1;\\n        while (j < len && tail && tail->next)\\n        {\\n            tail = tail->next;\\n            j++;\\n        }\\n\\n        nextHead = tail->next;\\n\\n        if ((j % 2) == 0)\\n        {\\n            tail->next = NULL;\\n            prev->next = reverseList(head);\\n            prev = head;\\n            head->next = nextHead;\\n            head = nextHead;\\n        }\\n        else\\n        {\\n            prev = tail;\\n            head = nextHead;\\n        }\\n    }\\n    return dummy->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530903,
                "title": "reverseevenlengthgroups-solved-recursively-through-the-reversekgroup-solution-code-runtime-87",
                "content": "# Intuition\\nI solved this problem after the reverseKGroup, so I thought i could use the same algorithm, using some little tweaks.\\n# Approach\\nI can use the reverseKGroup called with an initial k=1, then using a recursive call with an incremented k.\\nI can choose to reverse only the groups which have an even k, since i know that\\'s the length they will have.\\nThe only thing to fix was to check the length of the last group (recognised by the fact that the \"tail\" of the current list is None or not), since it can be \"not complete\", to choose if I have to reverse it or not.\\n\\n# Code\\n```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverseKGroup(head, 1)\\n\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        #Base cases\\n        if (head is None) or (head.next is None):\\n            return head\\n            \\n        #Subdivision of the groups\\n        node = head\\n        for i in range(k-1):\\n            node = node.next\\n            if node.next is None:\\n                break\\n        \\n        #Recursive call\\n        app = self.reverseKGroup(node.next, k+1)\\n        node.next = app\\n\\n        #Dont reverse if it\\'s not the final group and k isn\\'t even\\n        if app is not None and (k%2) != 0:\\n            return head\\n\\n        #Counting the length of the last group to decide to reverse\\n        i = 0\\n        if app is None:\\n            node = head\\n            while node:\\n                node = node.next\\n                i += 1\\n            if (i%2) != 0:\\n                return head\\n        \\n        #Reverse the group\\n        curr = app\\n        while head is not app:\\n            node = head.next\\n            head.next = curr\\n            curr = head\\n            head = node\\n\\n        return curr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverseKGroup(head, 1)\\n\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        #Base cases\\n        if (head is None) or (head.next is None):\\n            return head\\n            \\n        #Subdivision of the groups\\n        node = head\\n        for i in range(k-1):\\n            node = node.next\\n            if node.next is None:\\n                break\\n        \\n        #Recursive call\\n        app = self.reverseKGroup(node.next, k+1)\\n        node.next = app\\n\\n        #Dont reverse if it\\'s not the final group and k isn\\'t even\\n        if app is not None and (k%2) != 0:\\n            return head\\n\\n        #Counting the length of the last group to decide to reverse\\n        i = 0\\n        if app is None:\\n            node = head\\n            while node:\\n                node = node.next\\n                i += 1\\n            if (i%2) != 0:\\n                return head\\n        \\n        #Reverse the group\\n        curr = app\\n        while head is not app:\\n            node = head.next\\n            head.next = curr\\n            curr = head\\n            head = node\\n\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529183,
                "title": "java-easy-codes-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n           ListNode temp = head;\\n         int num=1;\\n    \\n    while(temp!=null)\\n    {\\n        int count=0;\\n        ListNode start = temp;\\n        Stack a = new Stack();\\n        \\n        while(count!=num && temp!=null)\\n        {\\n            a.push(temp.val);\\n            temp=temp.next;\\n            count++;       \\n        }\\n        if(count%2==0)\\n        {\\n            while(temp!=start)\\n            {\\n              start.val=(int) a.pop();\\n             start=start.next;  \\n                }\\n            \\n        } \\n        num++;\\n    }\\n    \\n    return head;\\n    \\n}\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n           ListNode temp = head;\\n         int num=1;\\n    \\n    while(temp!=null)\\n    {\\n        int count=0;\\n        ListNode start = temp;\\n        Stack a = new Stack();\\n        \\n        while(count!=num && temp!=null)\\n        {\\n            a.push(temp.val);\\n            temp=temp.next;\\n            count++;       \\n        }\\n        if(count%2==0)\\n        {\\n            while(temp!=start)\\n            {\\n              start.val=(int) a.pop();\\n             start=start.next;  \\n                }\\n            \\n        } \\n        num++;\\n    }\\n    \\n    return head;\\n    \\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526126,
                "title": "very-easy-solution-c-using-stack",
                "content": "```\\n  \\n```class Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL)return head;\\n        \\n        ListNode* temp=head,*hd=head;\\n        int i=1;\\n        \\n        \\n        while(temp!=NULL){\\n           \\n           hd=temp;\\n            \\n           stack<int> st;\\n           int j=0;\\n            \\n            while(j<i && temp!=NULL){\\n               \\n                st.push(temp->val);\\n                \\n                j++;\\n                temp=temp->next;\\n            }\\n            \\n            if(st.size()%2==0){\\n                \\n                while(!st.empty()){\\n                    \\n                    hd->val=st.top();\\n                    st.pop();\\n                    hd=hd->next;\\n                }\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516336,
                "title": "c-2-traversals-well-commented",
                "content": "# Approach\\nDo the first traversal to store the starting nodes from which we have to reverse and also store the length of the group to be reversed in a vector of pair. Now do the second traversal to actually reverse the groups based on the pointers which you saved in vector. For the last group if the length is smaller than it should be, we have to manually reverse the last group by storing the pointer of the node previous to the last group\\'s starting node and reverse the last group after the previous pointer by simply applying the logic to reverse a linked list.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        //to store the pointer of the starting node\\n        //of the group and the length of the group\\n        vector<pair<ListNode*,int>> vec;\\n        ListNode* tmp = head;\\n        //k is length of 1st group and it will increase like \\n        // 1, 2, 3 ...\\n        int k = 1;\\n        while(tmp!=NULL)\\n        {\\n            int cnt = 0;\\n            ListNode* tmp1 = tmp;\\n            while(cnt<k && tmp!=NULL)\\n            {\\n                cnt++;\\n                tmp = tmp->next;\\n            }\\n            if(cnt%2==0)\\n            {\\n                vec.push_back({tmp1,cnt});\\n            }\\n            k++;\\n        }\\n        //this is for last group if length is smaller than needed\\n        int flg = 0;\\n        ListNode* lastPtr1 = NULL;\\n        ListNode* lastPtr2 = NULL;\\n        if(vec.size()>1 && vec[vec.size()-1].second<=vec[vec.size()-2].second)\\n        {\\n            flg = 1;\\n            lastPtr1 = vec[vec.size()-1].first;\\n        }\\n        //............\\n\\n        tmp = head;\\n        int ptr = 0;\\n        while(ptr<vec.size() && tmp!=NULL)\\n        {\\n            if(tmp->next==vec[ptr].first)\\n            {\\n                int cnt = vec[ptr].second;\\n                ListNode* first = tmp->next;\\n                ListNode* prev = NULL;\\n                ListNode* cur = first;\\n                int tcnt = 0;\\n                while(cur!=NULL && tcnt<cnt)\\n                {\\n                    tcnt++;\\n                    ListNode* tm = cur->next;\\n                    cur->next = prev;\\n                    prev = cur;\\n                    cur = tm;\\n                    if(tcnt==cnt-1)\\n                    {\\n                        ListNode* tmp2 = cur->next;\\n                        \\n                        cur->next = prev;\\n                        first->next = tmp2;\\n                        //here we are storing the \\n                        //previous pointer of the \\n                        //last group\\'s first node to \\n                        // reverse it at last.\\n                        if(first->next==lastPtr1 && flg)\\n                        {\\n                            lastPtr2 = first;\\n                        }\\n                        //........\\n\\n                        tmp->next = cur;\\n                        tmp = tmp2;\\n                        break;\\n                    }\\n                }\\n                ptr++;\\n            }\\n            else\\n            {\\n                tmp = tmp->next;\\n            }\\n        }\\n\\n        //this is the code to reverse the last group if \\n        // it was not reversed in the above part.\\n        if(lastPtr2!=NULL)\\n        {\\n            ListNode* prev = NULL;\\n            ListNode* cur = lastPtr2->next;\\n            while(cur!=NULL)\\n            {\\n                ListNode* tm = cur->next;\\n                cur->next = prev;\\n                prev = cur;\\n                cur = tm;\\n            }\\n            lastPtr2->next = prev;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        //to store the pointer of the starting node\\n        //of the group and the length of the group\\n        vector<pair<ListNode*,int>> vec;\\n        ListNode* tmp = head;\\n        //k is length of 1st group and it will increase like \\n        // 1, 2, 3 ...\\n        int k = 1;\\n        while(tmp!=NULL)\\n        {\\n            int cnt = 0;\\n            ListNode* tmp1 = tmp;\\n            while(cnt<k && tmp!=NULL)\\n            {\\n                cnt++;\\n                tmp = tmp->next;\\n            }\\n            if(cnt%2==0)\\n            {\\n                vec.push_back({tmp1,cnt});\\n            }\\n            k++;\\n        }\\n        //this is for last group if length is smaller than needed\\n        int flg = 0;\\n        ListNode* lastPtr1 = NULL;\\n        ListNode* lastPtr2 = NULL;\\n        if(vec.size()>1 && vec[vec.size()-1].second<=vec[vec.size()-2].second)\\n        {\\n            flg = 1;\\n            lastPtr1 = vec[vec.size()-1].first;\\n        }\\n        //............\\n\\n        tmp = head;\\n        int ptr = 0;\\n        while(ptr<vec.size() && tmp!=NULL)\\n        {\\n            if(tmp->next==vec[ptr].first)\\n            {\\n                int cnt = vec[ptr].second;\\n                ListNode* first = tmp->next;\\n                ListNode* prev = NULL;\\n                ListNode* cur = first;\\n                int tcnt = 0;\\n                while(cur!=NULL && tcnt<cnt)\\n                {\\n                    tcnt++;\\n                    ListNode* tm = cur->next;\\n                    cur->next = prev;\\n                    prev = cur;\\n                    cur = tm;\\n                    if(tcnt==cnt-1)\\n                    {\\n                        ListNode* tmp2 = cur->next;\\n                        \\n                        cur->next = prev;\\n                        first->next = tmp2;\\n                        //here we are storing the \\n                        //previous pointer of the \\n                        //last group\\'s first node to \\n                        // reverse it at last.\\n                        if(first->next==lastPtr1 && flg)\\n                        {\\n                            lastPtr2 = first;\\n                        }\\n                        //........\\n\\n                        tmp->next = cur;\\n                        tmp = tmp2;\\n                        break;\\n                    }\\n                }\\n                ptr++;\\n            }\\n            else\\n            {\\n                tmp = tmp->next;\\n            }\\n        }\\n\\n        //this is the code to reverse the last group if \\n        // it was not reversed in the above part.\\n        if(lastPtr2!=NULL)\\n        {\\n            ListNode* prev = NULL;\\n            ListNode* cur = lastPtr2->next;\\n            while(cur!=NULL)\\n            {\\n                ListNode* tm = cur->next;\\n                cur->next = prev;\\n                prev = cur;\\n                cur = tm;\\n            }\\n            lastPtr2->next = prev;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443879,
                "title": "long-but-understandable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverselast(ListNode* head){\\n    ListNode* prev=nullptr;\\n    ListNode* curr=head;\\n    ListNode* right=curr->next;\\n    while(curr!=nullptr){\\nright=curr->next;\\ncurr->next=prev;\\nprev=curr;\\ncurr=right;\\n    }\\n    return prev;\\n}\\nint cnt(ListNode* head){\\n    ListNode* temp=head;\\n    int i=0;\\n    while(temp!=nullptr){\\n        i++;\\n        temp=temp->next;\\n    }\\n    return i;\\n}\\nListNode* reverse(ListNode* head,int i){\\n    if(head==nullptr){\\n        return nullptr;\\n    }\\n\\n\\n    int count=cnt(head);\\n    //yecode last ke liye\\nif(count<i){\\n    if(count%2==0){\\nreturn reverselast(head);\\n    }\\n    else{\\n        return head;\\n    }\\n}\\n////////\\nif(i%2==0){\\nint j=0;\\nListNode* prev=NULL;\\nListNode* curr=head;\\nListNode* right=curr->next;\\nwhile(j<i){\\n    right=curr->next;\\n    curr->next=prev;\\n    prev=curr;\\n    curr=right;\\n    j++;\\n}\\nif(right!=nullptr){\\n    int x=i+1;\\n    ListNode* rightkaans=reverse(right,x);\\n    head->next=rightkaans;\\n}\\nreturn prev;}\\nelse{\\n    int k=0;\\n    ListNode* temp=head;\\n    ListNode* follow=head;\\n    while(k<i){\\n        follow=temp;\\ntemp=temp->next;\\nk++;\\n    }\\n    if(temp!=nullptr){\\n         ListNode* ans=reverse(temp,++i);\\n         follow->next=ans;\\n    }\\n    return head;\\n}\\nreturn nullptr;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int i=1;\\n        return reverse(head, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverselast(ListNode* head){\\n    ListNode* prev=nullptr;\\n    ListNode* curr=head;\\n    ListNode* right=curr->next;\\n    while(curr!=nullptr){\\nright=curr->next;\\ncurr->next=prev;\\nprev=curr;\\ncurr=right;\\n    }\\n    return prev;\\n}\\nint cnt(ListNode* head){\\n    ListNode* temp=head;\\n    int i=0;\\n    while(temp!=nullptr){\\n        i++;\\n        temp=temp->next;\\n    }\\n    return i;\\n}\\nListNode* reverse(ListNode* head,int i){\\n    if(head==nullptr){\\n        return nullptr;\\n    }\\n\\n\\n    int count=cnt(head);\\n    //yecode last ke liye\\nif(count<i){\\n    if(count%2==0){\\nreturn reverselast(head);\\n    }\\n    else{\\n        return head;\\n    }\\n}\\n////////\\nif(i%2==0){\\nint j=0;\\nListNode* prev=NULL;\\nListNode* curr=head;\\nListNode* right=curr->next;\\nwhile(j<i){\\n    right=curr->next;\\n    curr->next=prev;\\n    prev=curr;\\n    curr=right;\\n    j++;\\n}\\nif(right!=nullptr){\\n    int x=i+1;\\n    ListNode* rightkaans=reverse(right,x);\\n    head->next=rightkaans;\\n}\\nreturn prev;}\\nelse{\\n    int k=0;\\n    ListNode* temp=head;\\n    ListNode* follow=head;\\n    while(k<i){\\n        follow=temp;\\ntemp=temp->next;\\nk++;\\n    }\\n    if(temp!=nullptr){\\n         ListNode* ans=reverse(temp,++i);\\n         follow->next=ans;\\n    }\\n    return head;\\n}\\nreturn nullptr;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int i=1;\\n        return reverse(head, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439964,
                "title": "using-stack-and-loop-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int flag = 0, counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                if(flag == 1){\\n                    if(i==counter-1) flag = 0;\\n                }\\n                else if(flag == 0){\\n                    if(i==counter-1) flag = 1;\\n                }\\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int flag = 0, counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                if(flag == 1){\\n                    if(i==counter-1) flag = 0;\\n                }\\n                else if(flag == 0){\\n                    if(i==counter-1) flag = 1;\\n                }\\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421371,
                "title": "c-three-pointer-solution-clean-code-explanation-o-1-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTo solve this problem, I decided to use three pointers, `prev` for the node before the first one in the current group, `start` for the first node in the group and `end` for the node after the last one in the group, or `nullptr` if the last one has no `node->next`.\\n\\nWe can track the `end_pos` and the `start_pos` to decide if the size of the group is even or not by moving the pointers and getting their new position. If it is, reverse the nodes in the group and move to the next group.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe function `move_to` tries to move the pointer to the position `target` from `position` and writes the actual position after moving to `position`. If a `nullptr` is encountered, the position will be 1 above the last non-null node.\\n\\nOn every iteration, we move the pointer `prev` to position `target` which increases by `length` every time; `length` also increases by one. Pointers `start` and `end` will be calculated using `prev` for the next group since their vaules can be inaccurate after `reverse`.\\n\\nThe function `reverse` reverses the range `(start, end)` and returns the pointer to the new start of the range. On each iteration, copy the next node `node->next` to a temp variable and set `node->next` to `prev`. Initialize `prev` with `end` so that the list stays connected and set it to the current node at the end of the loop.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* move_to(ListNode* node, int &position, int target) {\\n        for (; position < target; ++position) {\\n            if (node == nullptr) {\\n                return node;\\n            }\\n            node = node->next;\\n        }\\n        return node;\\n    }\\n    \\n    ListNode* reverse(ListNode *start, ListNode *end, int size) {\\n        ListNode *prev = end;\\n        ListNode *node = start;\\n        for (int i = 0; i < size; ++i) {\\n            ListNode *temp = node->next;\\n            node->next = prev;\\n            prev = node;\\n            node = temp;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        auto prev = head;\\n        auto start = head;\\n        auto end = head;\\n     \\n        int prev_pos = 0;\\n        int start_pos = 0;\\n        int end_pos = 1;   \\n\\n        for (int length = 2, target = 0; start != nullptr; target += length, length++) {\\n\\n            if ((end_pos - start_pos) % 2 == 0) {\\n                prev->next = reverse(start, end, end_pos - start_pos);\\n            }\\n            \\n            int position = prev_pos;\\n            prev = move_to(prev, position, target);\\n            prev_pos = position;\\n\\n            start = move_to(prev, position, position + 1);\\n            start_pos = position;\\n\\n            end = move_to(start, position, position + length);\\n            end_pos = position;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* move_to(ListNode* node, int &position, int target) {\\n        for (; position < target; ++position) {\\n            if (node == nullptr) {\\n                return node;\\n            }\\n            node = node->next;\\n        }\\n        return node;\\n    }\\n    \\n    ListNode* reverse(ListNode *start, ListNode *end, int size) {\\n        ListNode *prev = end;\\n        ListNode *node = start;\\n        for (int i = 0; i < size; ++i) {\\n            ListNode *temp = node->next;\\n            node->next = prev;\\n            prev = node;\\n            node = temp;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        auto prev = head;\\n        auto start = head;\\n        auto end = head;\\n     \\n        int prev_pos = 0;\\n        int start_pos = 0;\\n        int end_pos = 1;   \\n\\n        for (int length = 2, target = 0; start != nullptr; target += length, length++) {\\n\\n            if ((end_pos - start_pos) % 2 == 0) {\\n                prev->next = reverse(start, end, end_pos - start_pos);\\n            }\\n            \\n            int position = prev_pos;\\n            prev = move_to(prev, position, target);\\n            prev_pos = position;\\n\\n            start = move_to(prev, position, position + 1);\\n            start_pos = position;\\n\\n            end = move_to(start, position, position + length);\\n            end_pos = position;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412965,
                "title": "really-a-very-weird-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\n        vector<vector<ListNode*>>v;\\n        \\n        int c = 1;\\n        ListNode* t = head;\\n        vector<ListNode*>a;\\n        int grp = 1;\\n\\n        while(t){\\n            a.push_back(t);\\n            t = t->next;\\n\\n            if(a.size()==grp){\\n\\n                a[a.size()-1]->next = NULL;\\n                v.push_back(a);\\n                a.clear();\\n                grp++;\\n\\n            }\\n\\n        }\\n\\n        if(a.size()>0)v.push_back(a);\\n        vector<ListNode*>temp;\\n\\n        for(auto i : v){\\n\\n            vector<ListNode*>k = i;\\n\\n            if(k.size()%2==0){\\n                reverse(k.begin(),k.end());\\n            \\n            }\\n\\n            for(auto j : k)temp.push_back(j);\\n        }\\n        int i = 1;\\n        while(i<temp.size()){\\n\\n            temp[i-1]->next = temp[i];\\n            i++;\\n        }\\n        temp[temp.size()-1]->next = NULL;\\n        return temp[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\n        vector<vector<ListNode*>>v;\\n        \\n        int c = 1;\\n        ListNode* t = head;\\n        vector<ListNode*>a;\\n        int grp = 1;\\n\\n        while(t){\\n            a.push_back(t);\\n            t = t->next;\\n\\n            if(a.size()==grp){\\n\\n                a[a.size()-1]->next = NULL;\\n                v.push_back(a);\\n                a.clear();\\n                grp++;\\n\\n            }\\n\\n        }\\n\\n        if(a.size()>0)v.push_back(a);\\n        vector<ListNode*>temp;\\n\\n        for(auto i : v){\\n\\n            vector<ListNode*>k = i;\\n\\n            if(k.size()%2==0){\\n                reverse(k.begin(),k.end());\\n            \\n            }\\n\\n            for(auto j : k)temp.push_back(j);\\n        }\\n        int i = 1;\\n        while(i<temp.size()){\\n\\n            temp[i-1]->next = temp[i];\\n            i++;\\n        }\\n        temp[temp.size()-1]->next = NULL;\\n        return temp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406451,
                "title": "beats-90-full-explained-cpp-code-pls-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis is a very good q consist of reversing linked list and in a group of k\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The first while loop is used to count the total number of nodes in the linked list. This is done by iterating through each node of the list and incrementing the cnt variable for each node.\\n\\nThe next while loop is used to process the linked list in groups of even length. The cnt variable is used to keep track of the remaining nodes to be processed. The size variable is used to keep track of the size of the current group, which is initially set to 1.\\n\\nInside this while loop, if cnt is less than size, then size is set to cnt. This is because if the remaining number of nodes is less than the size of the current group, then the group size should be reduced accordingly.\\n\\nNext, if the group size t is even, then the group is reversed. A new pointer prev is set to the current node, and another pointer curr is set to the next node. Then the prev and curr pointers are swapped, and the next pointer is updated to point to the next node after curr. This process is repeated t-1 times to reverse the even-sized group. Finally, the tail of the previous group is updated to point to the head of the reversed group, and the tail of the reversed group is updated to point to the next node after the reversed group\\'s tail. The temp pointer is then updated to point to the next node after the reversed group\\'s tail.\\n\\nIf the group size t is odd, then the current node is skipped, and the tail pointer is set to the current node. Then the tail pointer is updated by iterating t-1 times to point to the node before the next group\\'s head. The temp pointer is then updated to point to the next node after the current group\\'s tail.\\n\\nFinally, the size variable is incremented, and the while loop continues until all nodes in the linked list are processed.\\n\\nThe function then returns the new head of the modified linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        ListNode* temp=head;\\n        int cnt=0;\\n        while(temp){\\n            cnt++;\\n            temp=temp->next;\\n        }\\n              temp=head;\\n              ListNode* tail=head;\\n        int size=1;\\n        while(cnt){\\n            if(cnt<size) size=cnt;\\n            cnt-=size;\\n                int t=size;\\n                if(t%2==0){\\n                    t--;\\n                  ListNode* prev=temp;\\n                  ListNode* curr=temp->next;\\n                  prev->next=NULL;\\n                  ListNode* next=curr;\\n                  while(t--){\\n                      next=curr->next;\\n                        curr->next=prev;\\n                         prev=curr;\\n                         curr=next;\\n                  }\\n                  tail->next=prev;\\n                  tail=temp;\\n                  temp->next=curr;\\n                  temp=curr;\\n                }\\n                else{\\n                    tail=temp;\\n                    temp=temp->next;\\n                    t--;\\n                    while(t--){\\n                        tail=temp;\\n                        temp=temp->next;\\n                    }\\n                }\\n                  size++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        ListNode* temp=head;\\n        int cnt=0;\\n        while(temp){\\n            cnt++;\\n            temp=temp->next;\\n        }\\n              temp=head;\\n              ListNode* tail=head;\\n        int size=1;\\n        while(cnt){\\n            if(cnt<size) size=cnt;\\n            cnt-=size;\\n                int t=size;\\n                if(t%2==0){\\n                    t--;\\n                  ListNode* prev=temp;\\n                  ListNode* curr=temp->next;\\n                  prev->next=NULL;\\n                  ListNode* next=curr;\\n                  while(t--){\\n                      next=curr->next;\\n                        curr->next=prev;\\n                         prev=curr;\\n                         curr=next;\\n                  }\\n                  tail->next=prev;\\n                  tail=temp;\\n                  temp->next=curr;\\n                  temp=curr;\\n                }\\n                else{\\n                    tail=temp;\\n                    temp=temp->next;\\n                    t--;\\n                    while(t--){\\n                        tail=temp;\\n                        temp=temp->next;\\n                    }\\n                }\\n                  size++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401470,
                "title": "c-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<int>> v;\\n        ListNode* h = head;\\n        int k=0;\\n        while(h!=NULL)\\n        {\\n            k++;\\n            int count=0;\\n            ListNode* h1 = h;\\n            vector<int> v1;\\n            while(h1!=NULL)\\n            {\\n                \\n                count++;\\n                if(count==k)\\n                    break;\\n                else\\n                    v1.push_back(h1->val);\\n                h1=h1->next;\\n            }\\n            v.push_back(v1);\\n            h=h1;\\n\\n        }\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i].size()%2==0)\\n            {\\n                reverse(v[i].begin(),v[i].end());\\n            }\\n        }\\n        ListNode* h1 = new ListNode(0);\\n        ListNode* ans = h1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                h1->next=new ListNode(v[i][j]);\\n                h1=h1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<int>> v;\\n        ListNode* h = head;\\n        int k=0;\\n        while(h!=NULL)\\n        {\\n            k++;\\n            int count=0;\\n            ListNode* h1 = h;\\n            vector<int> v1;\\n            while(h1!=NULL)\\n            {\\n                \\n                count++;\\n                if(count==k)\\n                    break;\\n                else\\n                    v1.push_back(h1->val);\\n                h1=h1->next;\\n            }\\n            v.push_back(v1);\\n            h=h1;\\n\\n        }\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i].size()%2==0)\\n            {\\n                reverse(v[i].begin(),v[i].end());\\n            }\\n        }\\n        ListNode* h1 = new ListNode(0);\\n        ListNode* ans = h1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                h1->next=new ListNode(v[i][j]);\\n                h1=h1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401055,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode curr = null;\\n\\n    public ListNode reverse(ListNode head,int m){\\n        ListNode c = head;\\n        ListNode next = head;\\n        ListNode p = null;\\n        ListNode n = null;\\n        while(m > 0 && c!=null){\\n            n = c.next;\\n            c.next = p;\\n            p = c;\\n            c = n;\\n            m--;\\n        }\\n        curr = c;\\n        return p;\\n    }\\n    public int length(ListNode head){\\n        int count = 0;\\n        while(head != null){\\n            head = head.next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode res = head;\\n        ListNode run = head;\\n        int len = length(head);\\n        int n = 0;\\n        int i = 1;\\n        while(n < len){\\n            int min = Math.min(i,len - n);\\n            if(min%2 == 1){\\n                for(int j = 0;j<min && head != null;j++){\\n                    run = head;\\n                    head = head.next;\\n                }\\n            }\\n            else{\\n                ListNode temp = reverse(head,min);\\n                run.next = temp;\\n                head.next = curr;\\n                run = head;\\n                head = curr;\\n            }\\n            i++;\\n            n += min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode curr = null;\\n\\n    public ListNode reverse(ListNode head,int m){\\n        ListNode c = head;\\n        ListNode next = head;\\n        ListNode p = null;\\n        ListNode n = null;\\n        while(m > 0 && c!=null){\\n            n = c.next;\\n            c.next = p;\\n            p = c;\\n            c = n;\\n            m--;\\n        }\\n        curr = c;\\n        return p;\\n    }\\n    public int length(ListNode head){\\n        int count = 0;\\n        while(head != null){\\n            head = head.next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode res = head;\\n        ListNode run = head;\\n        int len = length(head);\\n        int n = 0;\\n        int i = 1;\\n        while(n < len){\\n            int min = Math.min(i,len - n);\\n            if(min%2 == 1){\\n                for(int j = 0;j<min && head != null;j++){\\n                    run = head;\\n                    head = head.next;\\n                }\\n            }\\n            else{\\n                ListNode temp = reverse(head,min);\\n                run.next = temp;\\n                head.next = curr;\\n                run = head;\\n                head = curr;\\n            }\\n            i++;\\n            n += min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386218,
                "title": "python-simple-solution",
                "content": "```\\ndef reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tlst, cur, node, n, k = [], [], head, head, 1\\n\\twhile(node):\\n\\t\\tcur.append(node.val)\\n\\t\\tnode = node.next\\n\\t\\tif len(cur)==k or not node:\\n\\t\\t\\tif len(cur)%2==0:\\n\\t\\t\\t\\tcur = cur[::-1]\\n\\t\\t\\tlst.extend(cur)\\n\\t\\t\\tcur, k = [], k+1\\n\\tfor i in range(len(lst)):\\n\\t\\tn.val = lst[i]\\n\\t\\tn = n.next\\n\\treturn head\\n```",
                "solutionTags": [],
                "code": "```\\ndef reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tlst, cur, node, n, k = [], [], head, head, 1\\n\\twhile(node):\\n\\t\\tcur.append(node.val)\\n\\t\\tnode = node.next\\n\\t\\tif len(cur)==k or not node:\\n\\t\\t\\tif len(cur)%2==0:\\n\\t\\t\\t\\tcur = cur[::-1]\\n\\t\\t\\tlst.extend(cur)\\n\\t\\t\\tcur, k = [], k+1\\n\\tfor i in range(len(lst)):\\n\\t\\tn.val = lst[i]\\n\\t\\tn = n.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3370953,
                "title": "o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current_node = head\\n        current_tail = None\\n        group_size = 1\\n        while(current_node):\\n            group_start, group_tail, next_node = Solution.consume_group(group_size, current_node)\\n            if current_tail:\\n                current_tail.next = group_start\\n                current_tail = group_tail\\n            else:\\n                current_tail = group_tail\\n            \\n            current_node = next_node\\n            group_size += 1\\n\\n        return head\\n\\n    @staticmethod\\n    def consume_group(group_size, head):\\n        \"\"\"\\n\\n        :param group_size: will try to consume that many nodes\\n        :param head: the first_node in the group\\n        :return: the start of the group, the tail of the group, next_node\\n        \"\"\"\\n        if group_size == 0 or not head:\\n            return None, None, None\\n\\n        count = 0\\n\\n        current = head\\n\\n        if group_size % 2 == 0:\\n            group_tail = None\\n            group = None\\n            while current and count < group_size :\\n                next_node = current.next\\n                current.next = group\\n                if not group:\\n                    group_tail = current\\n\\n                group = current\\n                current = next_node\\n                count += 1\\n\\n            if count < group_size and count % 2 == 1:\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, group_tail, current\\n\\n        else:\\n            prev = None\\n            group = head\\n            while current and count < group_size:\\n                if prev:\\n                    prev.next = current\\n\\n                prev = current\\n\\n                current = current.next\\n                count += 1\\n\\n            if count < group_size and count % 2 == 0:\\n                # reverse linked list\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, prev, current\\n\\n\\n\\n    @staticmethod\\n    def reverse_linked_list(head):\\n        result = None\\n        tail = None\\n        while(head):\\n            next_node = head.next\\n            head.next = result\\n            if not result:\\n                tail = head\\n\\n            result = head\\n            head = next_node\\n\\n        return result, tail, head\\n\\n\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current_node = head\\n        current_tail = None\\n        group_size = 1\\n        while(current_node):\\n            group_start, group_tail, next_node = Solution.consume_group(group_size, current_node)\\n            if current_tail:\\n                current_tail.next = group_start\\n                current_tail = group_tail\\n            else:\\n                current_tail = group_tail\\n            \\n            current_node = next_node\\n            group_size += 1\\n\\n        return head\\n\\n    @staticmethod\\n    def consume_group(group_size, head):\\n        \"\"\"\\n\\n        :param group_size: will try to consume that many nodes\\n        :param head: the first_node in the group\\n        :return: the start of the group, the tail of the group, next_node\\n        \"\"\"\\n        if group_size == 0 or not head:\\n            return None, None, None\\n\\n        count = 0\\n\\n        current = head\\n\\n        if group_size % 2 == 0:\\n            group_tail = None\\n            group = None\\n            while current and count < group_size :\\n                next_node = current.next\\n                current.next = group\\n                if not group:\\n                    group_tail = current\\n\\n                group = current\\n                current = next_node\\n                count += 1\\n\\n            if count < group_size and count % 2 == 1:\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, group_tail, current\\n\\n        else:\\n            prev = None\\n            group = head\\n            while current and count < group_size:\\n                if prev:\\n                    prev.next = current\\n\\n                prev = current\\n\\n                current = current.next\\n                count += 1\\n\\n            if count < group_size and count % 2 == 0:\\n                # reverse linked list\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, prev, current\\n\\n\\n\\n    @staticmethod\\n    def reverse_linked_list(head):\\n        result = None\\n        tail = None\\n        while(head):\\n            next_node = head.next\\n            head.next = result\\n            if not result:\\n                tail = head\\n\\n            result = head\\n            head = next_node\\n\\n        return result, tail, head\\n\\n\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358401,
                "title": "simplest-c-solution",
                "content": "# Intuition-\\nfirst reverse k node than call for reversing k+1 node so on.\\n\\n# Approach\\nkeep track of last group ..if length even than only reverse\\n\\n# Complexity\\n- Time complexity:\\n time complexity  O(n) only once traversing in linkedlist-->\\n\\n- Space complexity:\\n!--  space complexity O(\\u221An) --\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n ListNode* reverseK(ListNode* head,int k) {\\n     if(head==NULL or head->next==NULL )return head;\\n     ListNode *temp=head;\\n         int i=1;\\n         while(temp!=NULL and i<k){temp=temp->next;i++; }\\n         if(temp==NULL)\\n         {   i--;\\n             if(i%2==0)\\n             {\\n                 ListNode *curr=head,*next=NULL,*pre=NULL;\\n                 i=0;\\n                while(curr!=NULL)\\n                {\\n                  next=curr->next;\\n                   curr->next=pre;\\n                    pre=curr;curr=next;i++;\\n                }\\n                return pre;\\n             }\\n             return head;\\n         }\\n        // cout<<endl;\\n     if(k%2)\\n     {\\n          if(temp->next!=NULL) temp->next=reverseK(temp->next,k+1);\\n           return head;\\n     }\\n     ListNode *curr=head,*next=NULL,*pre=NULL;\\n      i=0;\\n     while(curr!=NULL and i<k)\\n     {\\n        next=curr->next;\\n        curr->next=pre;\\n        pre=curr;curr=next;i++;\\n     }\\n     if(curr)head->next=reverseK(next,k+1);\\n     return pre;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseK(head,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n ListNode* reverseK(ListNode* head,int k) {\\n     if(head==NULL or head->next==NULL )return head;\\n     ListNode *temp=head;\\n         int i=1;\\n         while(temp!=NULL and i<k){temp=temp->next;i++; }\\n         if(temp==NULL)\\n         {   i--;\\n             if(i%2==0)\\n             {\\n                 ListNode *curr=head,*next=NULL,*pre=NULL;\\n                 i=0;\\n                while(curr!=NULL)\\n                {\\n                  next=curr->next;\\n                   curr->next=pre;\\n                    pre=curr;curr=next;i++;\\n                }\\n                return pre;\\n             }\\n             return head;\\n         }\\n        // cout<<endl;\\n     if(k%2)\\n     {\\n          if(temp->next!=NULL) temp->next=reverseK(temp->next,k+1);\\n           return head;\\n     }\\n     ListNode *curr=head,*next=NULL,*pre=NULL;\\n      i=0;\\n     while(curr!=NULL and i<k)\\n     {\\n        next=curr->next;\\n        curr->next=pre;\\n        pre=curr;curr=next;i++;\\n     }\\n     if(curr)head->next=reverseK(next,k+1);\\n     return pre;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseK(head,1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3355200,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n        ListNode* pre=NULL;\\n        ListNode* cur=head;\\n        while(cur!=NULL)\\n        {\\n            ListNode* nex=cur->next;\\n            cur->next=pre;\\n            pre=cur;\\n            cur=nex;\\n        }\\n        head=pre;\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        int k=1;\\n        ListNode* temp=head;\\n        ListNode* prev=NULL;\\n        while(temp)\\n        {\\n            if(k%2==0)\\n            {\\n                ListNode* n=temp; // previous head\\n                ListNode* t=n;    //\\n                int cnt=0, f=0;\\n                for(int x=1; x<k; x++)\\n                {\\n                    t=t->next;\\n                    cnt++;\\n                    if(!t && cnt%2) return head;\\n                    if(!t)\\n                    {\\n                        f=1;break;\\n                    }\\n                }\\n                if(f)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                    return head;\\n                }\\n                ListNode* nex=t->next;\\n                t->next=NULL;\\n                prev->next=NULL;\\n                ListNode* l=reverseList(n);\\n                n->next=nex;\\n                temp=n;\\n                prev->next=l;\\n            }\\n            else\\n            {\\n                int cnt=1, f=0;\\n                ListNode* n=temp;\\n                for(int x=1; x<k; x++)\\n                {\\n                    temp=temp->next;\\n                    cnt++;\\n                    if(!temp)\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(f && cnt%2)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                }\\n            }\\n            k++;\\n            prev=temp;\\n            if(temp)temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n        ListNode* pre=NULL;\\n        ListNode* cur=head;\\n        while(cur!=NULL)\\n        {\\n            ListNode* nex=cur->next;\\n            cur->next=pre;\\n            pre=cur;\\n            cur=nex;\\n        }\\n        head=pre;\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        int k=1;\\n        ListNode* temp=head;\\n        ListNode* prev=NULL;\\n        while(temp)\\n        {\\n            if(k%2==0)\\n            {\\n                ListNode* n=temp; // previous head\\n                ListNode* t=n;    //\\n                int cnt=0, f=0;\\n                for(int x=1; x<k; x++)\\n                {\\n                    t=t->next;\\n                    cnt++;\\n                    if(!t && cnt%2) return head;\\n                    if(!t)\\n                    {\\n                        f=1;break;\\n                    }\\n                }\\n                if(f)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                    return head;\\n                }\\n                ListNode* nex=t->next;\\n                t->next=NULL;\\n                prev->next=NULL;\\n                ListNode* l=reverseList(n);\\n                n->next=nex;\\n                temp=n;\\n                prev->next=l;\\n            }\\n            else\\n            {\\n                int cnt=1, f=0;\\n                ListNode* n=temp;\\n                for(int x=1; x<k; x++)\\n                {\\n                    temp=temp->next;\\n                    cnt++;\\n                    if(!temp)\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(f && cnt%2)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                }\\n            }\\n            k++;\\n            prev=temp;\\n            if(temp)temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337342,
                "title": "c-beats-99-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a position integer and a pointer, then keep on reversing the substrings when needed.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(struct ListNode*& first, struct ListNode*& last) {\\n    if (first == nullptr || last == nullptr || first == last) {\\n        return;\\n    }\\n\\n    struct ListNode* prev = nullptr;\\n    struct ListNode* curr = first;\\n    struct ListNode* next = nullptr;\\n\\n    while (curr != last) {\\n        next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n\\n    curr->next = prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int pos=0, len=1; //len is length to achieve\\n        struct ListNode* first, *last, *curr;\\n        curr = head;\\n        while(curr){\\n            pos++;\\n            if(pos==int(len*(len+1)/2)){\\n                if(len%2==0){\\n                    last=curr;\\n                    curr = curr->next;\\n                    \\n                    // cout<<\"the value of last is \"<<last->val<<endl;\\n            \\n                    // reverse starts\\n                    reverseList(first->next, last);\\n                    first->next->next = curr;\\n                    first->next = last;\\n                    // reverse ends\\n                    for(int i=0;i<len;i++) first = first->next;\\n                    // cout<<\"the value of len is \"<<len<<endl;\\n                  \\n                    len++;\\n                    }\\n                else{ len++; if(len%2==0) first=curr; curr = curr->next; }\\n            }\\n            else{ curr=curr->next;}            \\n        }\\n\\n        // the loop has ended, last values are remaining\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n        // if(len%2!=0)\\n        // first = first->next;\\n        if(first)\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n\\n        \\n        len = pos-int(len*(len-1)/2);\\n        if(len>0 && len%2==0){\\n            last = first;\\n            for(int i=0;i<len;i++) last = last->next;\\n            // cout<<\"the value of last is \"<<last->val<<endl;\\n\\n            // reverse starts\\n            reverseList(first->next, last);\\n            first->next->next = curr;\\n            first->next = last;\\n            // reverse ends\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(struct ListNode*& first, struct ListNode*& last) {\\n    if (first == nullptr || last == nullptr || first == last) {\\n        return;\\n    }\\n\\n    struct ListNode* prev = nullptr;\\n    struct ListNode* curr = first;\\n    struct ListNode* next = nullptr;\\n\\n    while (curr != last) {\\n        next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n\\n    curr->next = prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int pos=0, len=1; //len is length to achieve\\n        struct ListNode* first, *last, *curr;\\n        curr = head;\\n        while(curr){\\n            pos++;\\n            if(pos==int(len*(len+1)/2)){\\n                if(len%2==0){\\n                    last=curr;\\n                    curr = curr->next;\\n                    \\n                    // cout<<\"the value of last is \"<<last->val<<endl;\\n            \\n                    // reverse starts\\n                    reverseList(first->next, last);\\n                    first->next->next = curr;\\n                    first->next = last;\\n                    // reverse ends\\n                    for(int i=0;i<len;i++) first = first->next;\\n                    // cout<<\"the value of len is \"<<len<<endl;\\n                  \\n                    len++;\\n                    }\\n                else{ len++; if(len%2==0) first=curr; curr = curr->next; }\\n            }\\n            else{ curr=curr->next;}            \\n        }\\n\\n        // the loop has ended, last values are remaining\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n        // if(len%2!=0)\\n        // first = first->next;\\n        if(first)\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n\\n        \\n        len = pos-int(len*(len-1)/2);\\n        if(len>0 && len%2==0){\\n            last = first;\\n            for(int i=0;i<len;i++) last = last->next;\\n            // cout<<\"the value of last is \"<<last->val<<endl;\\n\\n            // reverse starts\\n            reverseList(first->next, last);\\n            first->next->next = curr;\\n            first->next = last;\\n            // reverse ends\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3337219,
                "title": "java-solution-with-map-and-deque",
                "content": "```\\n public static ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        Map<Integer, Deque<ListNode>> map = new LinkedHashMap<>();\\n        int counter=1;\\n        while (temp!=null){\\n            for (int i = 0; i < counter; i++) {\\n                if(temp==null)\\n                    break;\\n                map.computeIfAbsent(counter,e->new ArrayDeque<>()).addLast(temp);\\n                temp=temp.next;\\n            }\\n            counter++;\\n        }\\n        temp=null;\\n        for (int i = 1; i <counter;  i++) {\\n            if(map.get(i).size()%2!=0 ){\\n                if(temp!=null)\\n                    temp.next=map.get(i).getFirst();\\n                temp= map.get(i).getLast();\\n            }\\n            else if(map.get(i).size()%2==0){\\n                int indexCounter=map.get(i).size();\\n                for (int j = 0; j <indexCounter; j++) {\\n                    temp.next=map.get(i).getLast();\\n                    temp=map.get(i).removeLast();\\n                }\\n            }\\n        }\\n        temp.next=null;\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n public static ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        Map<Integer, Deque<ListNode>> map = new LinkedHashMap<>();\\n        int counter=1;\\n        while (temp!=null){\\n            for (int i = 0; i < counter; i++) {\\n                if(temp==null)\\n                    break;\\n                map.computeIfAbsent(counter,e->new ArrayDeque<>()).addLast(temp);\\n                temp=temp.next;\\n            }\\n            counter++;\\n        }\\n        temp=null;\\n        for (int i = 1; i <counter;  i++) {\\n            if(map.get(i).size()%2!=0 ){\\n                if(temp!=null)\\n                    temp.next=map.get(i).getFirst();\\n                temp= map.get(i).getLast();\\n            }\\n            else if(map.get(i).size()%2==0){\\n                int indexCounter=map.get(i).size();\\n                for (int j = 0; j <indexCounter; j++) {\\n                    temp.next=map.get(i).getLast();\\n                    temp=map.get(i).removeLast();\\n                }\\n            }\\n        }\\n        temp.next=null;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3331872,
                "title": "simple-and-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   Leetcode K-Reversal for better understanding\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode *s,ListNode *e){\\n        ListNode *prev=NULL,*curr=s,*nex=s->next;\\n        while(prev!=e){\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n            if(nex){\\n                nex=nex->next;\\n            }\\n        }\\n        return prev;\\n    }\\n \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *dummy=new ListNode(-1);\\n        dummy->next=head;\\n        ListNode *prev=dummy;\\n        for(int i=1;head!=NULL && 1e5;i++){\\n            ListNode *temp=head;\\n            ListNode *nexthead;\\n            int j=1;\\n            while(j<i && temp && temp->next){\\n                temp=temp->next;\\n                j++;\\n            }\\n            nexthead=temp->next;\\n            if((j%2)==0){\\n                 reverse(head,temp);\\n                 prev->next=temp;\\n                 prev=head;\\n                 head->next=nexthead;\\n                 head=nexthead;\\n            }\\n            else{\\n                prev=temp;\\n                head=nexthead;\\n            }\\n        }\\n       return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode *s,ListNode *e){\\n        ListNode *prev=NULL,*curr=s,*nex=s->next;\\n        while(prev!=e){\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n            if(nex){\\n                nex=nex->next;\\n            }\\n        }\\n        return prev;\\n    }\\n \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *dummy=new ListNode(-1);\\n        dummy->next=head;\\n        ListNode *prev=dummy;\\n        for(int i=1;head!=NULL && 1e5;i++){\\n            ListNode *temp=head;\\n            ListNode *nexthead;\\n            int j=1;\\n            while(j<i && temp && temp->next){\\n                temp=temp->next;\\n                j++;\\n            }\\n            nexthead=temp->next;\\n            if((j%2)==0){\\n                 reverse(head,temp);\\n                 prev->next=temp;\\n                 prev=head;\\n                 head->next=nexthead;\\n                 head=nexthead;\\n            }\\n            else{\\n                prev=temp;\\n                head=nexthead;\\n            }\\n        }\\n       return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324768,
                "title": "simple-using-recursion-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* start,ListNode* end){\\n        ListNode* prev=NULL;\\n        //ListNode* curr=head;\\n        ListNode* next=start;\\n        while(start!=end){\\n            next=start->next;\\n            start->next=prev;\\n            prev=start;\\n            start=next;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseeven(ListNode* head,int len){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int count=0;\\n        ListNode* start=head;\\n        ListNode* end=head;\\n        while(start!=NULL && count<len){\\n            end=start;\\n            start=start->next;\\n            count++;\\n        }\\n        if(count%2==0){\\n            ListNode* temp=reverse(head,start);\\n            head->next=reverseeven(start,len+1);\\n            return temp;\\n        }\\n        end->next=reverseeven(start,len+1);\\n        return head;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseeven(head,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* start,ListNode* end){\\n        ListNode* prev=NULL;\\n        //ListNode* curr=head;\\n        ListNode* next=start;\\n        while(start!=end){\\n            next=start->next;\\n            start->next=prev;\\n            prev=start;\\n            start=next;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseeven(ListNode* head,int len){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int count=0;\\n        ListNode* start=head;\\n        ListNode* end=head;\\n        while(start!=NULL && count<len){\\n            end=start;\\n            start=start->next;\\n            count++;\\n        }\\n        if(count%2==0){\\n            ListNode* temp=reverse(head,start);\\n            head->next=reverseeven(start,len+1);\\n            return temp;\\n        }\\n        end->next=reverseeven(start,len+1);\\n        return head;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseeven(head,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322065,
                "title": "swift-hashmap-approach",
                "content": "# Swift | HashMap\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head!.next == nil {\\n            return head \\n        }\\n\\n        var dict = [Int: [ListNode?]]()\\n        var prev: ListNode? = nil\\n        var dummy = head\\n        var currentGroup = 1\\n        \\n        while dummy != nil {\\n            for _ in 1...currentGroup {\\n                prev = dummy\\n                dict[currentGroup, default: []].append(dummy)\\n                dummy = dummy?.next\\n                if dummy == nil { break }\\n            }\\n\\n            prev?.next = nil\\n            var count = dict[currentGroup]!.count\\n\\n            if count.isMultiple(of: 2) {\\n                var head = reverseList(dict[currentGroup]!.first!)\\n                dict[currentGroup]!.swapAt(0, count-1)\\n                dict[currentGroup-1]?.last!!.next = head\\n            } else {\\n                dict[currentGroup-1]?.last!!.next = dict[currentGroup]!.first!\\n            }\\n\\n            currentGroup += 1\\n        }\\n       \\n        return head\\n    }\\n\\n    func reverseList(_ head: ListNode?) -> ListNode? {\\n        var dummy = head\\n        var prev: ListNode? = nil\\n\\n        while dummy != nil {\\n            var nextNode = dummy?.next\\n            dummy?.next = prev\\n            prev = dummy\\n            dummy = nextNode\\n        }\\n        return prev\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head!.next == nil {\\n            return head \\n        }\\n\\n        var dict = [Int: [ListNode?]]()\\n        var prev: ListNode? = nil\\n        var dummy = head\\n        var currentGroup = 1\\n        \\n        while dummy != nil {\\n            for _ in 1...currentGroup {\\n                prev = dummy\\n                dict[currentGroup, default: []].append(dummy)\\n                dummy = dummy?.next\\n                if dummy == nil { break }\\n            }\\n\\n            prev?.next = nil\\n            var count = dict[currentGroup]!.count\\n\\n            if count.isMultiple(of: 2) {\\n                var head = reverseList(dict[currentGroup]!.first!)\\n                dict[currentGroup]!.swapAt(0, count-1)\\n                dict[currentGroup-1]?.last!!.next = head\\n            } else {\\n                dict[currentGroup-1]?.last!!.next = dict[currentGroup]!.first!\\n            }\\n\\n            currentGroup += 1\\n        }\\n       \\n        return head\\n    }\\n\\n    func reverseList(_ head: ListNode?) -> ListNode? {\\n        var dummy = head\\n        var prev: ListNode? = nil\\n\\n        while dummy != nil {\\n            var nextNode = dummy?.next\\n            dummy?.next = prev\\n            prev = dummy\\n            dummy = nextNode\\n        }\\n        return prev\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1769960,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1960006,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1794919,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1761796,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1898418,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1771113,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2054286,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2018696,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1860681,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2062205,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1769960,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1960006,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1794919,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1761796,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1898418,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1771113,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2054286,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2018696,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1860681,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2062205,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            }
        ]
    },
    {
        "title": "Decode the Slanted Ciphertext",
        "question_content": "<p>A string <code>originalText</code> is encoded using a <strong>slanted transposition cipher</strong> to a string <code>encodedText</code> with the help of a matrix having a <strong>fixed number of rows</strong> <code>rows</code>.</p>\n\n<p><code>originalText</code> is placed first in a top-left to bottom-right manner.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa11.png\" style=\"width: 300px; height: 185px;\" />\n<p>The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of <code>originalText</code>. The arrow indicates the order in which the cells are filled. All empty cells are filled with <code>&#39; &#39;</code>. The number of columns is chosen such that the rightmost column will <strong>not be empty</strong> after filling in <code>originalText</code>.</p>\n\n<p><code>encodedText</code> is then formed by appending all characters of the matrix in a row-wise fashion.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa12.png\" style=\"width: 300px; height: 200px;\" />\n<p>The characters in the blue cells are appended first to <code>encodedText</code>, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.</p>\n\n<p>For example, if <code>originalText = &quot;cipher&quot;</code> and <code>rows = 3</code>, then we encode it in the following manner:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/desc2.png\" style=\"width: 281px; height: 211px;\" />\n<p>The blue arrows depict how <code>originalText</code> is placed in the matrix, and the red arrows denote the order in which <code>encodedText</code> is formed. In the above example, <code>encodedText = &quot;ch ie pr&quot;</code>.</p>\n\n<p>Given the encoded string <code>encodedText</code> and number of rows <code>rows</code>, return <em>the original string</em> <code>originalText</code>.</p>\n\n<p><strong>Note:</strong> <code>originalText</code> <strong>does not</strong> have any trailing spaces <code>&#39; &#39;</code>. The test cases are generated such that there is only one possible <code>originalText</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> encodedText = &quot;ch   ie   pr&quot;, rows = 3\n<strong>Output:</strong> &quot;cipher&quot;\n<strong>Explanation:</strong> This is the same example described in the problem description.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" style=\"width: 250px; height: 168px;\" />\n<pre>\n<strong>Input:</strong> encodedText = &quot;iveo    eed   l te   olc&quot;, rows = 4\n<strong>Output:</strong> &quot;i love leetcode&quot;\n<strong>Explanation:</strong> The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/eg2.png\" style=\"width: 300px; height: 51px;\" />\n<pre>\n<strong>Input:</strong> encodedText = &quot;coding&quot;, rows = 1\n<strong>Output:</strong> &quot;coding&quot;\n<strong>Explanation:</strong> Since there is only 1 row, both originalText and encodedText are the same.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= encodedText.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>encodedText</code> consists of lowercase English letters and <code>&#39; &#39;</code> only.</li>\n\t<li><code>encodedText</code> is a valid encoding of some <code>originalText</code> that <strong>does not</strong> have trailing spaces.</li>\n\t<li><code>1 &lt;= rows &lt;= 1000</code></li>\n\t<li>The testcases are generated such that there is <strong>only one</strong> possible <code>originalText</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576914,
                "title": "jump-columns-1",
                "content": "Knowing `rows`, we can find out `cols`. Knowing `cols`, we can jump to the next letter (`cols + 1`).\\n\\nExample: `\"ch   ie   pr\"`, rows = 3, columns = 12 / 3 = 4.\\n0: [0, 5, 10] `\"cip\"`\\n1: [1, 6, 11] `\"her\"`\\n2: [2, 7] `\"  \"` <- we will trim this.\\n3: [3, 8] `\"  \"` <- we will trim this.\\n\\n**Java**\\n```java\\npublic String decodeCiphertext(String encodedText, int rows) {\\n    int sz = encodedText.length(), cols = sz / rows;\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            sb.append(encodedText.charAt(j));\\n    return sb.toString().stripTrailing();\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols, res = len(encodedText) // rows, \"\"\\n        for i in range(cols):\\n            for j in range(i, len(encodedText), cols + 1):\\n                res += encodedText[j]\\n        return res.rstrip()\\n```\\n**C++**\\n```cpp\\nstring decodeCiphertext(string encodedText, int rows) {\\n    int sz = encodedText.size(), cols = sz / rows;\\n    string res;\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            res += encodedText[j];\\n    while (!res.empty() && isspace(res.back()))\\n        res.pop_back();\\n    return res;\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```java\\npublic String decodeCiphertext(String encodedText, int rows) {\\n    int sz = encodedText.length(), cols = sz / rows;\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            sb.append(encodedText.charAt(j));\\n    return sb.toString().stripTrailing();\\n}\\n```\n```python\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols, res = len(encodedText) // rows, \"\"\\n        for i in range(cols):\\n            for j in range(i, len(encodedText), cols + 1):\\n                res += encodedText[j]\\n        return res.rstrip()\\n```\n```cpp\\nstring decodeCiphertext(string encodedText, int rows) {\\n    int sz = encodedText.size(), cols = sz / rows;\\n    string res;\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            res += encodedText[j];\\n    while (!res.empty() && isspace(res.back()))\\n        res.pop_back();\\n    return res;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577049,
                "title": "java-c-python-soluiton-with-explanation",
                "content": "# **Observations**\\n1. `s.length() = rows * cols`\\n2. `s[i]` and `s[i+cols+1]` are adjacent characters in original text.\\nFor example,\\n`\"cipher\"` to `\"ch   ie   pr\"`, `cols = 3`\\n`s[0] = \\'c\\'`\\n`s[4] = \\'i\\'`\\n`s[8] = \\'p\\'`\\n<br>\\n\\n# **Explanation**\\nFor every character in the first row in the matrix,\\nfind it\\'s adjacent characters in diagonal position in the matrix.\\nRead all these chara one by one,\\nreturn the trimmed result string.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public String decodeCiphertext(String s, int rows) {\\n        int n = s.length(), cols = n / rows;\\n        StringBuilder res = new StringBuilder(10);\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res.append(s.charAt(j));\\n        while (res.length()  > 0 && res.charAt(res.length() - 1) == \\' \\')\\n            res.setLength(res.length() - 1);\\n        return res.toString();\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    string decodeCiphertext(string s, int rows) {\\n        int n = s.size(), cols = n / rows;\\n        string res;\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res += s[j];\\n        while (res.back() == \\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def decodeCiphertext(self, s, n):\\n        m = len(s) / n\\n        res = []\\n        for i in xrange(m):\\n            while i < len(s):\\n                res.append(s[i])\\n                i += m + 1\\n        return \\'\\'.join(res).rstrip()\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public String decodeCiphertext(String s, int rows) {\\n        int n = s.length(), cols = n / rows;\\n        StringBuilder res = new StringBuilder(10);\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res.append(s.charAt(j));\\n        while (res.length()  > 0 && res.charAt(res.length() - 1) == \\' \\')\\n            res.setLength(res.length() - 1);\\n        return res.toString();\\n    }\\n```\n```cpp\\n    string decodeCiphertext(string s, int rows) {\\n        int n = s.size(), cols = n / rows;\\n        string res;\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res += s[j];\\n        while (res.back() == \\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```\n```py\\n    def decodeCiphertext(self, s, n):\\n        m = len(s) / n\\n        res = []\\n        for i in xrange(m):\\n            while i < len(s):\\n                res.append(s[i])\\n                i += m + 1\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1576943,
                "title": "c-concise-commented-code-idea-explained",
                "content": "\\n\\n**Idea**\\n* Since the encoded text contains all the characters of the matrix, we can determine the number of columns of the matrix and then form the matrix.\\n* Once the matrix is ready, we need to traverse it diagonally to obtain the original text. After taking some examples it becomes clear that when a boundary is hit, the pointer for row resets to 0, and the pointer for column is subtracted by the *currentrow minus 1*. \\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        \\n        // Determining the number of columns\\n        int cols = n / rows;\\n        vector<vector<char>> mat(rows, vector<char>(cols, \\' \\'));\\n        int i = 0, j = 0;\\n        int k = 0;\\n        \\n        \\n        string ans = \"\";\\n        \\n        // Filling the matrix using encodedText\\n        // Row wise\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                mat[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        // Only the upper triangular part of the matrix will\\n        // contain characters of the originalText\\n        // so, this loop traverses that area\\n        for(int k = 0; k < n - (rows * (rows - 1)) / 2; k++) {\\n            // i, j are the two pointers for tracking rows and columns\\n            ans.push_back(mat[i++][j++]);\\n            \\n            // If any boundary is hit, then column pointer is subtracted \\n            // by row_pointer - 1\\n            // and row pointer is reset to 0\\n            if(i == rows || j == cols) {\\n                j -= (i - 1);\\n                i = 0;\\n            }\\n        }\\n        \\n        // Removing all trailing spaces\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n*Space Complexity: O(n), where n is the size of encodedText*\\n*Time Complexity: O(n), where n is the size of encodedText*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        \\n        // Determining the number of columns\\n        int cols = n / rows;\\n        vector<vector<char>> mat(rows, vector<char>(cols, \\' \\'));\\n        int i = 0, j = 0;\\n        int k = 0;\\n        \\n        \\n        string ans = \"\";\\n        \\n        // Filling the matrix using encodedText\\n        // Row wise\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                mat[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        // Only the upper triangular part of the matrix will\\n        // contain characters of the originalText\\n        // so, this loop traverses that area\\n        for(int k = 0; k < n - (rows * (rows - 1)) / 2; k++) {\\n            // i, j are the two pointers for tracking rows and columns\\n            ans.push_back(mat[i++][j++]);\\n            \\n            // If any boundary is hit, then column pointer is subtracted \\n            // by row_pointer - 1\\n            // and row pointer is reset to 0\\n            if(i == rows || j == cols) {\\n                j -= (i - 1);\\n                i = 0;\\n            }\\n        }\\n        \\n        // Removing all trailing spaces\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577269,
                "title": "detailed-explanation-with-clean-code-diagonal-traversal",
                "content": "<br/>\\n\\n>  You can solve this problem using the diagram given in sample testcase\\n\\n<br/>\\n<img src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" height=\"200px\" />\\n\\n<br/>\\n\\nIf you are just confused about the diagonal traversal, you can see the last part of this blog :)\\n\\n**Steps:**\\n\\n* cols = encodedText.size() / rows\\n* Fill all the characters in a 2D vector of size rows * cols (including spaces)\\n* Add all the diagonals to answer string\\n* Remove trailing zeros\\n\\nFor the example shown in above image when you traverse diagonally, you will get these substrings\\n```\\n\"i lo\" \\n\"ve l\"\\n\"eetc\"\\n\"ode\"\\n\"  \"\\n\" \"\\n```\\nAnd when you keep adding these character by character, you will have original text as\\n`\"i love leetcode  \"`\\nthen you can remove the trailing spaces\\n<br/>\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encoded, int rows) {\\n        \\n        int n = encoded.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encoded[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```\\n\\n<br/>\\n\\n**If you are confused about how to traverse diagonally:**\\n\\n<p>Traversing diagonals in a matrix simply means going from `row = 0; row < rows` and `col = 0; col < cols\\n` by doing `row++, col++` at each stage\\n<br/>\\n\\n**Diagonal traversal for matrix of size (4 * 6) (Shown in image) will be as follows:**\\n\\n```\\n(0, 0) -> (1, 1) -> (2, 2) -> (3, 3)\\n(0, 1) -> (1, 2) -> (2, 3) -> (3, 4)\\n(0, 2) -> (1, 3) -> (2, 4) -> (3, 5)\\n(0, 3) -> (1, 4) -> (2, 5)\\n(0, 4) -> (1, 5)\\n(0, 5)\\n```\\n\\n</p>\\n\\n**Time complexity = Space complexity = O(n) = O(rows * cols)**\\n\\n<br/>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\"i lo\" \\n\"ve l\"\\n\"eetc\"\\n\"ode\"\\n\"  \"\\n\" \"\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encoded, int rows) {\\n        \\n        int n = encoded.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encoded[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```\n```\\n(0, 0) -> (1, 1) -> (2, 2) -> (3, 3)\\n(0, 1) -> (1, 2) -> (2, 3) -> (3, 4)\\n(0, 2) -> (1, 3) -> (2, 4) -> (3, 5)\\n(0, 3) -> (1, 4) -> (2, 5)\\n(0, 4) -> (1, 5)\\n(0, 5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577075,
                "title": "python-build-the-cipher-matrix",
                "content": "This solution works as the problem states \"the rightmost column will not be empty after filling in `originalText`\". But then just wonder why it not avoid corner cases as `len(originalText) == 0`. Anyway, testcase like `\"a    \", 4` is treated as invalid case.\\n```\\ndef decodeCiphertext(s, r):\\n\\tk = len(s) // r\\n\\tmat = [s[i*k+i:i*k+k] for i in range(r)]\\n\\tmat[-1] += \" \"  # handle trailing characters for rows in mat[:-1]\\n\\treturn \"\".join(map(\"\".join, zip(*mat))).rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef decodeCiphertext(s, r):\\n\\tk = len(s) // r\\n\\tmat = [s[i*k+i:i*k+k] for i in range(r)]\\n\\tmat[-1] += \" \"  # handle trailing characters for rows in mat[:-1]\\n\\treturn \"\".join(map(\"\".join, zip(*mat))).rstrip()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2455783,
                "title": "c-easy-understanding-comments-images",
                "content": "![image](https://assets.leetcode.com/users/images/490d4bba-7328-4e7f-b735-38f2bf6e03b9_1661026373.273487.png)\\n![image](https://assets.leetcode.com/users/images/823894aa-6fac-44e2-9cf6-185e8c27e290_1661026380.454058.png)\\n![image](https://assets.leetcode.com/users/images/02554695-2d77-4b9e-aee3-0e0dc62a9893_1661026913.1704528.png)\\n\\n\\n\\tCODE\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring decodeCiphertext(string e, int rows) {\\n\\t\\t\\tint size=e.size();\\n\\t\\t\\tint col=size/rows;\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile (isspace(ans.back()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nComplexity Analysis\\nSpace Complexity: O(n), where n is the size of encodedText\\nTime Complexity: O(n), where n is the size of encodedText",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring decodeCiphertext(string e, int rows) {\\n\\t\\t\\tint size=e.size();\\n\\t\\t\\tint col=size/rows;\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1594638,
                "title": "intuition-explained-simple-simulation-c-clean-code",
                "content": "# **Approach 1:** \\n**Intuition :**\\n\\n* Idea here is to just do what we are asked to perform. That is **simulate** decoding steps. \\n* First, we need to make `cipher` matrix using `encodedText`. \\n* Then, for each column in first row, we traverse diagonally and add those characters to `decodedText` string.\\n* In the end, since trailing spaces are not allowed, so we remove it from `decodedString`. \\n* We can have two cases. \\n\\t* One when `rows = 1`. In this case, we `decodedText` is same as `encodedText`.\\n\\t* And other when `rows > 1`. In this, we need to perform above simulation. \\n\\n* Lets understand through simple example : \\n\\n\\t\\tCase 1 : if rows == 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t  Ex: \"c o d i n g\"\\n            \\n\\t\\t\\t-> In this case we do not need to decode text. We can simply return encodedText directly. \\n\\t\\t\\t-> This is because all characters are in first row.\\n\\t\\t\\n\\t\\tCase 2: if rows > 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tEx: encodedText = \"ch   ie   pr\" , rows = 3\\n\\t\\t\\t\\n\\t\\t\\tcipher matrix : \\n\\t\\t\\t\\t  \"c h _ _\\n\\t\\t\\t       _ i e _  \\n\\t\\t\\t\\t   _ _ p r\"\\n           \\n\\t\\t   -> Note : Here, just for sake of explanation, I have take space(\" \") as underscore(_).\\n\\t\\t   \\n            i. k = 0 => {(0,0) : \\'c\\'}, {(1,1) : \\'i\\'}, {(2,2) : \\'p\\'} \\n            ii. k = 1 => {(0,1) : \\'h\\'}, {(1,2) : \\'e\\'}, {(2,3) : \\'r\\'}\\n\\t\\t\\tiii. k = 2 => {(0,2) : \\'_\\'}, {(1,3) : \\'_\\'}\\n\\t\\t\\t\\n\\t\\t\\tThus, decodedString with trailing spaces = \"cipher_ _\". \\n\\t\\t\\tWe need to remove these trailing spaces, and then return resultant string.\\n        \\n\\t\\t\\t\\n# Code :\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(rows == 1) {\\n            return encodedText;\\n        }\\n        \\n        int cols = encodedText.size() / rows;\\n        \\n        vector<vector<char>> cipher(rows, vector<char>(cols));\\n        \\n        int k = 0;\\n        for(int i=0; i<rows; i++) {\\n            for(int j=0; j<cols; j++) {\\n                cipher[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n\\t\\t// Just added to print cipher \\n        // for(auto& r : cipher) {\\n        //     for(auto& c : r) {\\n        //         cout << c << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n        \\n        string decodedText = \"\";\\n\\t\\t\\n\\t\\t// Traverse diagonally for each column\\n        for(int k=0; k<cols; k++) {\\n            int i=0, j=k;\\n            while(i<rows && j<cols) {\\n                decodedText.push_back(cipher[i++][j++]);\\n            }\\n        }\\n        \\n        // Remove trailing spaces\\n        while(decodedText.back() == \\' \\') {\\n            decodedText.pop_back();\\n        }\\n        \\n        return decodedText;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N + N)`, create `cipher` matrix, and build `decodedText` string.\\n\\t* N is size of `encodedText` string\\n\\n* Space : `O(N)`, for `cipher` matrix for simulation.\\n-------------------------------------------------------\\n------------------------------------------------------\\n# **Approach 2:** \\n\\n**Intuition :**\\n\\n* We can optimize it further, by skipping `cipher` matrix part. We can directly get using `encodedText.` \\n\\n* Idea here is to move `(col+1)` steps each time in `encodedText`, to get next diagonal element. \\n* Since, if we are some coordinate `[i,j]`, then next diagonal element i.e `[i+1, j+1]`. \\n* Now, this is at a distance `(cols + 1)` from `[i,j]`. \\n* So we can directly move by this distance to get next character of `decodedText`\\n\\n# Code : \\n\\n```\\nstring decodeCiphertext(string encodedText, int rows) {\\n        \\n\\tint n = encodedText.size();\\n\\tint cols = n / rows;\\n\\n\\tstring decodedText = \"\";\\n\\n\\tfor(int i=0; i < cols; i++) {\\n\\t\\t// Move by distance (col+1) to get next character\\n\\t\\tfor(int j=i; j<n; j += (cols+1)) {\\n\\t\\t\\tdecodedText += encodedText[j];\\n\\t\\t}\\n\\t}\\n\\n\\twhile(decodedText.back() == \\' \\') decodedText.pop_back();\\n\\n\\treturn decodedText;\\n}\\n```\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(rows == 1) {\\n            return encodedText;\\n        }\\n        \\n        int cols = encodedText.size() / rows;\\n        \\n        vector<vector<char>> cipher(rows, vector<char>(cols));\\n        \\n        int k = 0;\\n        for(int i=0; i<rows; i++) {\\n            for(int j=0; j<cols; j++) {\\n                cipher[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n\\t\\t// Just added to print cipher \\n        // for(auto& r : cipher) {\\n        //     for(auto& c : r) {\\n        //         cout << c << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n        \\n        string decodedText = \"\";\\n\\t\\t\\n\\t\\t// Traverse diagonally for each column\\n        for(int k=0; k<cols; k++) {\\n            int i=0, j=k;\\n            while(i<rows && j<cols) {\\n                decodedText.push_back(cipher[i++][j++]);\\n            }\\n        }\\n        \\n        // Remove trailing spaces\\n        while(decodedText.back() == \\' \\') {\\n            decodedText.pop_back();\\n        }\\n        \\n        return decodedText;\\n    }\\n};\\n```\n```\\nstring decodeCiphertext(string encodedText, int rows) {\\n        \\n\\tint n = encodedText.size();\\n\\tint cols = n / rows;\\n\\n\\tstring decodedText = \"\";\\n\\n\\tfor(int i=0; i < cols; i++) {\\n\\t\\t// Move by distance (col+1) to get next character\\n\\t\\tfor(int j=i; j<n; j += (cols+1)) {\\n\\t\\t\\tdecodedText += encodedText[j];\\n\\t\\t}\\n\\t}\\n\\n\\twhile(decodedText.back() == \\' \\') decodedText.pop_back();\\n\\n\\treturn decodedText;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1580595,
                "title": "c-straight-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int rows) {\\n        int cols = text.length()/rows;\\n        \\n        char** array = new char*[rows];\\n        for(int i = 0; i < rows; i++)\\n            array[i] = new char[cols];\\n        \\n        int index = 0;\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) \\n                array[i][j] = text[index++];\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            int r = 0, c = i;\\n            while(r < rows && c < cols) \\n                ans += array[r++][c++];\\n        }\\n        \\n        if(ans.size() == 0) \\n            return ans;\\n        \\n        while(ans[ans.size()-1] == \\' \\') \\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int rows) {\\n        int cols = text.length()/rows;\\n        \\n        char** array = new char*[rows];\\n        for(int i = 0; i < rows; i++)\\n            array[i] = new char[cols];\\n        \\n        int index = 0;\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) \\n                array[i][j] = text[index++];\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            int r = 0, c = i;\\n            while(r < rows && c < cols) \\n                ans += array[r++][c++];\\n        }\\n        \\n        if(ans.size() == 0) \\n            return ans;\\n        \\n        while(ans[ans.size()-1] == \\' \\') \\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576999,
                "title": "javascript-string-builder",
                "content": "```javascript\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const numColumns = encodedText.length / rows;\\n    const stringBuilder = [];\\n    let nextCol = 1;\\n    let row = 0;\\n    let col = 0;\\n    let index = 0\\n    while (index < encodedText.length) {\\n        stringBuilder.push(encodedText[index]);\\n        if (row === rows - 1 || col === numColumns - 1) {\\n            row = 0;\\n            col = nextCol;\\n            nextCol++;\\n        } else {\\n            row++;\\n            col++;\\n        }\\n        index = calcIndex(row, col, numColumns);\\n    }\\n    while (stringBuilder[stringBuilder.length - 1] === \\' \\') {\\n        stringBuilder.pop();\\n    }\\n    return stringBuilder.join(\\'\\');\\n};\\n\\nfunction calcIndex(row, col, numColumns) {\\n    return row * numColumns + col;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```javascript\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const numColumns = encodedText.length / rows;\\n    const stringBuilder = [];\\n    let nextCol = 1;\\n    let row = 0;\\n    let col = 0;\\n    let index = 0\\n    while (index < encodedText.length) {\\n        stringBuilder.push(encodedText[index]);\\n        if (row === rows - 1 || col === numColumns - 1) {\\n            row = 0;\\n            col = nextCol;\\n            nextCol++;\\n        } else {\\n            row++;\\n            col++;\\n        }\\n        index = calcIndex(row, col, numColumns);\\n    }\\n    while (stringBuilder[stringBuilder.length - 1] === \\' \\') {\\n        stringBuilder.pop();\\n    }\\n    return stringBuilder.join(\\'\\');\\n};\\n\\nfunction calcIndex(row, col, numColumns) {\\n    return row * numColumns + col;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576924,
                "title": "c-simulation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Simulation\\n\\nSimply traverse the string diagonally. Position `(x, y)` corresponds to `s[y * col + x]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/decode-the-slanted-ciphertext/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int row) {\\n        int col = s.size() / row;\\n        string ans;\\n        for (int i = 0; i < col; ++i) { // start from each column\\n            for (int x = i, y = 0; x < col && y < row; ++x, ++y) ans += s[y * col + x]; // traverse the string diagonally\\n        }\\n        while (ans.size() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/decode-the-slanted-ciphertext/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int row) {\\n        int col = s.size() / row;\\n        string ans;\\n        for (int i = 0; i < col; ++i) { // start from each column\\n            for (int x = i, y = 0; x < col && y < row; ++x, ++y) ans += s[y * col + x]; // traverse the string diagonally\\n        }\\n        while (ans.size() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688232,
                "title": "simple-and-easy-explained-every-steps",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")return encodedText;    // base cases\\n        if(rows == 1) return encodedText;           // if rows = 1 simply return\\n        \\n        \\n// create a mat matix where we store our encodedText lineraly row by row as shown in example\\n        // mat\\'s row = rows\\n        // mat\\'s col = encodedText.size() / rows\\n        \\n        vector<vector<char>> mat(rows, vector<char>(encodedText.size() / rows, \\' \\'));\\n        int k = 0;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j < mat[i].size(); j++){\\n                mat[i][j] = encodedText[k];\\n                k += 1;\\n            }\\n        }\\n        \\n        \\n        \\n        string ret = \"\";\\n        int i = 0;\\n        int col = mat[0].size();\\n        \\n    // now traversing diagonally in mat matix to store answer in ret\\n        while(i != col){\\n            int temp_i = 0;\\n            int temp_j = i;\\n            while(temp_i < rows && temp_j < col){\\n                ret += mat[temp_i][temp_j];\\n                temp_i += 1;\\n                temp_j += 1;\\n            }\\n            i += 1;\\n        }\\n        \\n// erasing tralling space as there are the possibilities that we might find tralling spaces while traversing diagonally \\n        \\n        int last = ret.size() - 1;\\n        while(ret[last] == \\' \\'){\\n            ret.erase(ret.begin() + last);\\n            last -= 1;\\n        }\\n        \\n        return ret;  //returning the decoded string\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")return encodedText;    // base cases\\n        if(rows == 1) return encodedText;           // if rows = 1 simply return\\n        \\n        \\n// create a mat matix where we store our encodedText lineraly row by row as shown in example\\n        // mat\\'s row = rows\\n        // mat\\'s col = encodedText.size() / rows\\n        \\n        vector<vector<char>> mat(rows, vector<char>(encodedText.size() / rows, \\' \\'));\\n        int k = 0;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j < mat[i].size(); j++){\\n                mat[i][j] = encodedText[k];\\n                k += 1;\\n            }\\n        }\\n        \\n        \\n        \\n        string ret = \"\";\\n        int i = 0;\\n        int col = mat[0].size();\\n        \\n    // now traversing diagonally in mat matix to store answer in ret\\n        while(i != col){\\n            int temp_i = 0;\\n            int temp_j = i;\\n            while(temp_i < rows && temp_j < col){\\n                ret += mat[temp_i][temp_j];\\n                temp_i += 1;\\n                temp_j += 1;\\n            }\\n            i += 1;\\n        }\\n        \\n// erasing tralling space as there are the possibilities that we might find tralling spaces while traversing diagonally \\n        \\n        int last = ret.size() - 1;\\n        while(ret[last] == \\' \\'){\\n            ret.erase(ret.begin() + last);\\n            last -= 1;\\n        }\\n        \\n        return ret;  //returning the decoded string\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588641,
                "title": "simple-python-solution-using-matrix-and-performing-operations-as-given-in-question-brute-force",
                "content": "![image](https://assets.leetcode.com/users/images/f4dad618-812b-4567-acfb-b02c4394eb06_1637437871.282986.png)\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        #print(len(encodedText),rows,len(encodedText)//rows)\\n        if len(encodedText)==0:\\n            return \"\"\\n        ans =\\'\\'\\n        x =[]\\n        c = len(encodedText)//rows\\n        for i in range(0,len(encodedText),c):\\n            x.append(list(encodedText[i:i+c]))\\n        #print(x)\\n        for i in range(c):\\n            k = i\\n            p=\\'\\'\\n            for j in range(rows):\\n                try:\\n                    p = p+x[j][k]\\n                except:\\n                    pass\\n                k = k+1\\n            ans = ans+p\\n        return ans.rstrip()\\n```\\n#  Upvote if useful",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        #print(len(encodedText),rows,len(encodedText)//rows)\\n        if len(encodedText)==0:\\n            return \"\"\\n        ans =\\'\\'\\n        x =[]\\n        c = len(encodedText)//rows\\n        for i in range(0,len(encodedText),c):\\n            x.append(list(encodedText[i:i+c]))\\n        #print(x)\\n        for i in range(c):\\n            k = i\\n            p=\\'\\'\\n            for j in range(rows):\\n                try:\\n                    p = p+x[j][k]\\n                except:\\n                    pass\\n                k = k+1\\n            ans = ans+p\\n        return ans.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578294,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        char[] chars = encodedText.toCharArray();\\n        \\n        int cols = chars.length / rows;\\n        \\n        int i = 0;\\n        int j = 0;\\n        //use this variable to reset j\\'s value.\\n        int counter = 0;\\n        \\n        while (j < cols) {\\n            while (i < rows && j < cols) {\\n                int arrayIndex = i * cols + j;\\n                sb.append(chars[arrayIndex]);\\n                i++;\\n                j++;\\n            }\\n            counter++;\\n            \\n            i = 0;\\n            j = counter;\\n        }\\n        \\n        return removeSpaces(sb).toString();\\n    }\\n    \\n    private StringBuilder removeSpaces(StringBuilder sb) {\\n        if (sb.length() < 1) return sb;\\n        \\n        while(sb.charAt(sb.length() - 1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        \\n        return sb;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        char[] chars = encodedText.toCharArray();\\n        \\n        int cols = chars.length / rows;\\n        \\n        int i = 0;\\n        int j = 0;\\n        //use this variable to reset j\\'s value.\\n        int counter = 0;\\n        \\n        while (j < cols) {\\n            while (i < rows && j < cols) {\\n                int arrayIndex = i * cols + j;\\n                sb.append(chars[arrayIndex]);\\n                i++;\\n                j++;\\n            }\\n            counter++;\\n            \\n            i = 0;\\n            j = counter;\\n        }\\n        \\n        return removeSpaces(sb).toString();\\n    }\\n    \\n    private StringBuilder removeSpaces(StringBuilder sb) {\\n        if (sb.length() < 1) return sb;\\n        \\n        while(sb.charAt(sb.length() - 1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        \\n        return sb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577027,
                "title": "java-fast-and-also-memory-efficient",
                "content": "```\\n int column = encodedText.length() / rows;\\n        char[][] array = new char[rows][column];\\n\\n        int counter = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < column; j++) {\\n                array[i][j] = encodedText.charAt(counter);\\n                counter++;\\n            }\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n\\n        for (int i = 0; i < column; i++) {\\n            int cnt = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (cnt < column)\\n                    builder.append(array[j][cnt++]);\\n            }\\n        }\\n\\n        String result = builder.toString();\\n\\n        return result.stripTrailing();\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n int column = encodedText.length() / rows;\\n        char[][] array = new char[rows][column];\\n\\n        int counter = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < column; j++) {\\n                array[i][j] = encodedText.charAt(counter);\\n                counter++;\\n            }\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n\\n        for (int i = 0; i < column; i++) {\\n            int cnt = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (cnt < column)\\n                    builder.append(array[j][cnt++]);\\n            }\\n        }\\n\\n        String result = builder.toString();\\n\\n        return result.stripTrailing();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576933,
                "title": "java-bruteforce-concise-solution",
                "content": "`\\n\\njAVA BRUTE FORCE SOLUTION\\n\\n    public String decodeCiphertext(String str, int rows) {\\n        \\n        if(rows==1) return str;\\n        int num=0;\\n        \\n        int i=0,len=str.length();\\n        int j=0;\\n        int temp=len/rows+1;\\n        if(len%rows!=0) temp++;\\n        \\n        char arr[][]=new char[rows][temp];\\n        while(i<len){\\n            int c=Math.min(temp,len-i);\\n            if(c!=temp){\\n                for(int k=0;k<c;k++){\\n                    arr[j][k]=str.charAt(i+k);\\n                }\\n            }\\n            else{\\n                arr[j++]=str.substring(i,i+temp).toCharArray();\\n            }\\n            \\n            i+=temp;\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(i=0;i<temp;i++){\\n            for(j=0;j<rows;j++){\\n                sb.append(arr[j][i]);\\n            }\\n        }\\n        str=sb.toString();\\n        i=str.length()-1;\\n        while(i>=0 && (str.charAt(i)==\\'\\\\u0000\\' || str.charAt(i)==\\' \\')) i--;\\n        return str.substring(0,i+1);\\n    }\\n\\t\\n\\tAPPROACH 2\\n\\t  public String decodeCiphertext(String encodedText, int rows) {\\n        int l = (encodedText.length() % rows == 0) ? encodedText.length()/rows : encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int j = 0; j < l; j++) {     \\n            for (int i = 0; i < rows; i++) {\\n                if (i + j + i * l < encodedText.length())\\n                    sb.append(encodedText.charAt(i + j + i * l));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "`\\n\\njAVA BRUTE FORCE SOLUTION\\n\\n    public String decodeCiphertext(String str, int rows) {\\n        \\n        if(rows==1) return str;\\n        int num=0;\\n        \\n        int i=0,len=str.length();\\n        int j=0;\\n        int temp=len/rows+1;\\n        if(len%rows!=0) temp++;\\n        \\n        char arr[][]=new char[rows][temp];\\n        while(i<len){\\n            int c=Math.min(temp,len-i);\\n            if(c!=temp){\\n                for(int k=0;k<c;k++){\\n                    arr[j][k]=str.charAt(i+k);\\n                }\\n            }\\n            else{\\n                arr[j++]=str.substring(i,i+temp).toCharArray();\\n            }\\n            \\n            i+=temp;\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(i=0;i<temp;i++){\\n            for(j=0;j<rows;j++){\\n                sb.append(arr[j][i]);\\n            }\\n        }\\n        str=sb.toString();\\n        i=str.length()-1;\\n        while(i>=0 && (str.charAt(i)==\\'\\\\u0000\\' || str.charAt(i)==\\' \\')) i--;\\n        return str.substring(0,i+1);\\n    }\\n\\t\\n\\tAPPROACH 2\\n\\t  public String decodeCiphertext(String encodedText, int rows) {\\n        int l = (encodedText.length() % rows == 0) ? encodedText.length()/rows : encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int j = 0; j < l; j++) {     \\n            for (int i = 0; i < rows; i++) {\\n                if (i + j + i * l < encodedText.length())\\n                    sb.append(encodedText.charAt(i + j + i * l));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3735249,
                "title": "c-o-1-space-o-n-time-10-lines-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n=eT.size();\\n        int col=n/rows;\\n        string s=\"\";\\n        for(int i=0;i<col;i++){\\n            int j=i;\\n            while(j<n){\\n                s+=eT[j];\\n                j=j+col+1;\\n            }\\n        }\\n        while(isspace(s.back())){\\n            s.pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n=eT.size();\\n        int col=n/rows;\\n        string s=\"\";\\n        for(int i=0;i<col;i++){\\n            int j=i;\\n            while(j<n){\\n                s+=eT[j];\\n                j=j+col+1;\\n            }\\n        }\\n        while(isspace(s.back())){\\n            s.pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645156,
                "title": "beats-90-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor encoded text length times traverse diagonally and add it to the result. remove all the trail spaces and return. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse no of columns times and add characters diagonally (2d array as 1d array method) until it crosses limits. and remove trailing spaces. \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")  return encodedText; \\n        int columns = ceil(encodedText.length()/rows);\\n        string ans = \"\"; \\n        for(int i=0; i<columns; i++){\\n            int r = 0, c = i; \\n            while(c < columns && r<rows){ ans += encodedText[r*columns + c]; r++; c++;}\\n        }\\n        int len = ans.length(); \\n        while(ans[len-1] == \\' \\') len--;\\n        ans = ans.substr(0, len); \\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")  return encodedText; \\n        int columns = ceil(encodedText.length()/rows);\\n        string ans = \"\"; \\n        for(int i=0; i<columns; i++){\\n            int r = 0, c = i; \\n            while(c < columns && r<rows){ ans += encodedText[r*columns + c]; r++; c++;}\\n        }\\n        int len = ans.length(); \\n        while(ans[len-1] == \\' \\') len--;\\n        ans = ans.substr(0, len); \\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404765,
                "title": "python3-solution-time-99-33-space-100",
                "content": "![Capture d\\u2019\\xE9cran (96).png](https://assets.leetcode.com/users/images/3e9f8a31-b0d3-4995-ae49-64d20c8c39d1_1681219407.2042663.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102251,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int m = rows;\\n        int n = (encodedText.length()/rows);\\n        vector<vector<char>> vc(m,vector<char>(n));\\n        int ind = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<n;j++){\\n                vc[i][j]=encodedText[j+ind];\\n            }\\n            ind+=n;\\n        } \\n        string ans = \"\";\\n        for(int j=0;j<n;j++){\\n            int starti = 0;\\n            int startj = j;\\n            while(starti<m && startj<n){\\n                ans+=vc[starti][startj];\\n                starti++;\\n                startj++;\\n            }\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int m = rows;\\n        int n = (encodedText.length()/rows);\\n        vector<vector<char>> vc(m,vector<char>(n));\\n        int ind = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<n;j++){\\n                vc[i][j]=encodedText[j+ind];\\n            }\\n            ind+=n;\\n        } \\n        string ans = \"\";\\n        for(int j=0;j<n;j++){\\n            int starti = 0;\\n            int startj = j;\\n            while(starti<m && startj<n){\\n                ans+=vc[starti][startj];\\n                starti++;\\n                startj++;\\n            }\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943766,
                "title": "c-2d-index-conversion",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size() / r;\\n        string ans = \"\";\\n        for (int i = 0; i < c; ++i)\\n            ans += findDiagonal(0, i, s, c, r);\\n        while (!ans.empty() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n    string findDiagonal(int i, int y, string& s, int& c, int& r){\\n        int nextInd = i * c + y;\\n        if (nextInd >= s.size()) return \"\";\\n        return s[nextInd] + findDiagonal(i + 1, y + 1, s, c, r);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size() / r;\\n        string ans = \"\";\\n        for (int i = 0; i < c; ++i)\\n            ans += findDiagonal(0, i, s, c, r);\\n        while (!ans.empty() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n    string findDiagonal(int i, int y, string& s, int& c, int& r){\\n        int nextInd = i * c + y;\\n        if (nextInd >= s.size()) return \"\";\\n        return s[nextInd] + findDiagonal(i + 1, y + 1, s, c, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724209,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396405,
                "title": "memory-limit-exceeded",
                "content": "If your answer is in string ans.\\ndon\\'t do ans = ans + char\\n\\nThis causes MLE!",
                "solutionTags": [
                    "C"
                ],
                "code": "If your answer is in string ans.\\ndon\\'t do ans = ans + char\\n\\nThis causes MLE!",
                "codeTag": "Unknown"
            },
            {
                "id": 2034993,
                "title": "javascript-solution-simulation",
                "content": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const n = encodedText.length;\\n    const cols = n / rows;\\n    let res = \"\";\\n    \\n    for (let i = 0; i < cols; ++i) {\\n        let str = \"\";\\n        \\n        let row = 0;\\n        let col = i % cols;\\n        \\n        while (row < rows && col < cols) {\\n            const idx = (row * cols) + col;\\n            \\n            str += encodedText.charAt(idx);\\n            \\n            row += 1;\\n            col += 1;\\n        }\\n        \\n        res += str;\\n    }\\n\\n    return res.trimEnd();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Simulation"
                ],
                "code": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const n = encodedText.length;\\n    const cols = n / rows;\\n    let res = \"\";\\n    \\n    for (let i = 0; i < cols; ++i) {\\n        let str = \"\";\\n        \\n        let row = 0;\\n        let col = i % cols;\\n        \\n        while (row < rows && col < cols) {\\n            const idx = (row * cols) + col;\\n            \\n            str += encodedText.charAt(idx);\\n            \\n            row += 1;\\n            col += 1;\\n        }\\n        \\n        res += str;\\n    }\\n\\n    return res.trimEnd();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1813633,
                "title": "c-solution-with-simple-explanation-diagonal-traversal",
                "content": "Idea: - Its given in Question that matrix would be filled up till last coloumn and we will always be starting from (0,0) ,and we are given encrypted string and rows . we will find no of cols then  firstly we will construct a 2D matrix and fill our encypted string just as shown in question\\'s pic . Then we will traverse it diagonally and construct our orignal string . In the last step we will remove extra spaces at end of orignal string\\n\\n\\n**Step 1 :** To find no of cols , its basically length of encypted string / rows .(because we know from question that filling would start from (0,0) and go uptill last col for sure )\\n\\n**Step 2 :**  Now we will fill our encypted string in that matrix . Will fill first row then move to second row and continue this uptill last row\\n\\n**Step 3 :** -  Now all we need to do is traverse diagonally and start building up our orignal string .lets see this step in detail . eg we need to traverse  matrix of row=4 , col=6 (example of I love leetcoding matrix given in question)\\n\\n(0,0)  -> (1,1) -> (2,2) -> (3,3)\\n(0,1)  -> (1,2) -> (2,3) -> (3,4)\\n(0,2)  -> (1,3) -> (2,4) -> (3,5)\\n(0,3)  -> (1,4) -> (2,5)\\n(0,4)  -> (1,5)\\n(0,5)\\n\\nHere we clearly see we need to do 6 iteration (or we can say no of iteration=no of cols), and in every iteration ith index will start from 0 and go at max till no of rows -1 , jth index starts 0 in first iteration , from 1 in second iteration and will go at max till col-1 . Now we just need to write that in code \\n\\n\\n\\n```\\nstring decodeCiphertext(string encodedText, int rows) \\n    {\\n      int n=encodedText.size();\\n\\t  \\n\\t  // finding no of cols (Step 1)\\n\\t  \\n      int col=n/rows;\\n      \\n      // creating 2D matrix  (Step 2)\\n\\t  \\n      vector<vector<char>>matrix(rows,vector<char>(col));\\n      \\n      int index=0;\\n\\t  \\n\\t  // Filling 2D matrix (Step 2)\\n\\t  \\n      for(int i=0;i<rows;i++)\\n      {\\n        for(int j=0;j<col;j++)\\n        {\\n          matrix[i][j]=encodedText[index++];\\n        }\\n      }\\n      \\n\\t  \\n\\t  // Traversing diagonally (Step 3)\\n\\t  \\n      string ans=\"\";\\n\\t  \\n      for(int j = 0; j < col; j++) \\n      {\\n            int r = 0;\\n            int c = j;\\n            while(c < col and r < rows) \\n            {\\n                ans += matrix[r++][c++];\\n            }\\n      }\\n      \\n     \\n\\t // Last Step (Removing extra spaces from our orignal string)\\n\\t \\n     while (!ans.empty() && ans.back() == \\' \\') \\n     {\\n            ans.pop_back();\\n     }\\n      \\n      return ans;\\n      \\n\\n      \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring decodeCiphertext(string encodedText, int rows) \\n    {\\n      int n=encodedText.size();\\n\\t  \\n\\t  // finding no of cols (Step 1)\\n\\t  \\n      int col=n/rows;\\n      \\n      // creating 2D matrix  (Step 2)\\n\\t  \\n      vector<vector<char>>matrix(rows,vector<char>(col));\\n      \\n      int index=0;\\n\\t  \\n\\t  // Filling 2D matrix (Step 2)\\n\\t  \\n      for(int i=0;i<rows;i++)\\n      {\\n        for(int j=0;j<col;j++)\\n        {\\n          matrix[i][j]=encodedText[index++];\\n        }\\n      }\\n      \\n\\t  \\n\\t  // Traversing diagonally (Step 3)\\n\\t  \\n      string ans=\"\";\\n\\t  \\n      for(int j = 0; j < col; j++) \\n      {\\n            int r = 0;\\n            int c = j;\\n            while(c < col and r < rows) \\n            {\\n                ans += matrix[r++][c++];\\n            }\\n      }\\n      \\n     \\n\\t // Last Step (Removing extra spaces from our orignal string)\\n\\t \\n     while (!ans.empty() && ans.back() == \\' \\') \\n     {\\n            ans.pop_back();\\n     }\\n      \\n      return ans;\\n      \\n\\n      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1776864,
                "title": "js-simple-solution-easy-to-understand",
                "content": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText.length == 0)\\n        return \"\"\\n    var mat= [];\\n    var n=(encodedText.length/rows);\\n    var temp = [];\\n    for(var i=0, c=1; i<encodedText.length; i++, c++)\\n        {\\n            temp.push(encodedText[i]);\\n            if(c == n)\\n                {\\n                    mat.push(temp);\\n                    c=0;\\n                    temp = [];\\n                }\\n        }\\n    var output = \"\";\\n    for(var i=0; i<mat[0].length; i++)\\n        {\\n            var r=0, c=i;\\n            while(r<mat.length && c<mat[0].length)\\n                {\\n                    output+=mat[r++][c++];\\n                }\\n        }\\n    return output.trimEnd();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText.length == 0)\\n        return \"\"\\n    var mat= [];\\n    var n=(encodedText.length/rows);\\n    var temp = [];\\n    for(var i=0, c=1; i<encodedText.length; i++, c++)\\n        {\\n            temp.push(encodedText[i]);\\n            if(c == n)\\n                {\\n                    mat.push(temp);\\n                    c=0;\\n                    temp = [];\\n                }\\n        }\\n    var output = \"\";\\n    for(var i=0; i<mat[0].length; i++)\\n        {\\n            var r=0, c=i;\\n            while(r<mat.length && c<mat[0].length)\\n                {\\n                    output+=mat[r++][c++];\\n                }\\n        }\\n    return output.trimEnd();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753881,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        if not s: return \"\"\\n        n=len(s)\\n        cols=n//rows\\n        arr=[\" \"]*n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if i>j: continue\\n                arr[i+rows*(j-i)]=s[i*cols+j]\\n        i=n-1\\n        while i>=0 and arr[i]==\" \":\\n            i-=1\\n        return \\'\\'.join(arr[:i+1])\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        if not s: return \"\"\\n        n=len(s)\\n        cols=n//rows\\n        arr=[\" \"]*n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if i>j: continue\\n                arr[i+rows*(j-i)]=s[i*cols+j]\\n        i=n-1\\n        while i>=0 and arr[i]==\" \":\\n            i-=1\\n        return \\'\\'.join(arr[:i+1])\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682589,
                "title": "easy-cpp-col-1-jumps",
                "content": "```\\ncommented for better explanation , tried best to deliver the concept of code\\n```\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) \\n    {\\n        // to find the col of the table we are doing this \\n        int sz = s.size();\\n        int col = sz/rows;\\n        // we move till col and add the chars using col+1 jumps on full string \\n        string ans;\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=i;j<sz;j+=col+1)\\n            {\\n                ans+=s[j];\\n               \\n            }\\n        }\\n        // at last we will left with some spaces , to clear we make this \\n        // to return our result correct \\n        while(!ans.empty() and ans.back()==\\' \\')\\n        {\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ncommented for better explanation , tried best to deliver the concept of code\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) \\n    {\\n        // to find the col of the table we are doing this \\n        int sz = s.size();\\n        int col = sz/rows;\\n        // we move till col and add the chars using col+1 jumps on full string \\n        string ans;\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=i;j<sz;j+=col+1)\\n            {\\n                ans+=s[j];\\n               \\n            }\\n        }\\n        // at last we will left with some spaces , to clear we make this \\n        // to return our result correct \\n        while(!ans.empty() and ans.back()==\\' \\')\\n        {\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627031,
                "title": "python3-260ms-runtime-faster-than-96-and-uses-91-less-memory",
                "content": "`Execution Result`\\n\\n```\\nRuntime: 260 ms, faster than 96.14% of Python3 online submissions for Decode the Slanted Ciphertext.\\nMemory Usage: 26.8 MB, less than 91.49% of Python3 online submissions for Decode the Slanted Ciphertext.\\n```\\n\\n`Code`\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        op = \\'\\'\\n        total_cols = int(   len(encodedText) / rows )\\n        row = 0\\n        col = 0\\n        while True:\\n            try:\\n                calc = (row*total_cols)+row+col\\n                char = encodedText[calc]\\n            except IndexError:\\n                break\\n            op += char\\n            row+=1\\n            if row == rows:\\n                row = 0\\n                col+=1\\n        return op.rstrip()\\n```\\n\\n`Tests`\\n```\\nprint(Solution().decodeCiphertext(encodedText = \"ch   ie   pr\", rows = 3))\\nprint(Solution().decodeCiphertext(encodedText = \"iveo    eed   l te   olc\", rows = 4))\\nprint(Solution().decodeCiphertext(encodedText = \"coding\", rows = 1))\\nprint(Solution().decodeCiphertext(encodedText = \" b  ac\", rows = 2))\\nprint(Solution().decodeCiphertext(\"wmihfwf bddhzaizuzhbuoovyyjstardqceaqzafdzihjbj ywly amkeemr jmvsfaavbpgiafgxzciwmrrtasthc hqfrtwoizoilw\", 2)  )\\nN = pow(10, 6)\\nimport random, string\\nprint(Solution().decodeCiphertext(encodedText = \\'\\'.join(random.choices(string.ascii_lowercase + \\' \\', k=N)), rows = pow(10, 3)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nRuntime: 260 ms, faster than 96.14% of Python3 online submissions for Decode the Slanted Ciphertext.\\nMemory Usage: 26.8 MB, less than 91.49% of Python3 online submissions for Decode the Slanted Ciphertext.\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        op = \\'\\'\\n        total_cols = int(   len(encodedText) / rows )\\n        row = 0\\n        col = 0\\n        while True:\\n            try:\\n                calc = (row*total_cols)+row+col\\n                char = encodedText[calc]\\n            except IndexError:\\n                break\\n            op += char\\n            row+=1\\n            if row == rows:\\n                row = 0\\n                col+=1\\n        return op.rstrip()\\n```\n```\\nprint(Solution().decodeCiphertext(encodedText = \"ch   ie   pr\", rows = 3))\\nprint(Solution().decodeCiphertext(encodedText = \"iveo    eed   l te   olc\", rows = 4))\\nprint(Solution().decodeCiphertext(encodedText = \"coding\", rows = 1))\\nprint(Solution().decodeCiphertext(encodedText = \" b  ac\", rows = 2))\\nprint(Solution().decodeCiphertext(\"wmihfwf bddhzaizuzhbuoovyyjstardqceaqzafdzihjbj ywly amkeemr jmvsfaavbpgiafgxzciwmrrtasthc hqfrtwoizoilw\", 2)  )\\nN = pow(10, 6)\\nimport random, string\\nprint(Solution().decodeCiphertext(encodedText = \\'\\'.join(random.choices(string.ascii_lowercase + \\' \\', k=N)), rows = pow(10, 3)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606713,
                "title": "simple-and-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int col = n/rows;  //bcs n = rows*cols(always) -> observation\\n        string res;\\n        for(int i=0;i<col;i++){\\n            for(int j=i; j<n; j+=(col+1)) //we can observe that to travel diagonallly we have to increamnt by (col+1)\\n                res += (encodedText[j]);\\n        }\\n        while(res.back() == \\' \\') res.pop_back();\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int col = n/rows;  //bcs n = rows*cols(always) -> observation\\n        string res;\\n        for(int i=0;i<col;i++){\\n            for(int j=i; j<n; j+=(col+1)) //we can observe that to travel diagonallly we have to increamnt by (col+1)\\n                res += (encodedText[j]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1592079,
                "title": "golang-solution-with-explanation",
                "content": "The main idea of this solution is to find the number of columns. The solution comes together pretty quickly after that.\\n\\nTo explain my thinking to how I found the number of columns we have to take a matrix. We should know the number rows and columns in that matrix. For example:\\n\\n`[a][d][g][ ]`\\n`[ ][b][e][h]`\\n`[ ][ ][c][f]`\\n\\nWe have a matrix with 3 rows and 4 columns, and 12 items. `3 * 4 = 12`, so if we are given a matrix of size 12 and 3 rows, we can do `12 / 3 = 4` to get the number of columns. Since we know that the number of values in the matrix can be shown using `len(encodedText)` and the problem gives us the number of rows, we can do `len(encodedText) / rows = cols`.\\n\\nThen all we have to do is add all the letters in a particular order.\\n\\nNote that `res` is not a `string` because that will output a TLE.\\n\\n``` go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    n := len(encodedText)\\n    cols := n / rows\\n    res := []string{}\\n    \\n    for i := 0; i < cols; i++ {\\n        for j := i; j < n; j += cols + 1 {\\n            res = append(res, string(encodedText[j]))\\n        }\\n    }\\n    \\n    return strings.TrimRight(strings.Join(res, \"\"), \" \")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    n := len(encodedText)\\n    cols := n / rows\\n    res := []string{}\\n    \\n    for i := 0; i < cols; i++ {\\n        for j := i; j < n; j += cols + 1 {\\n            res = append(res, string(encodedText[j]))\\n        }\\n    }\\n    \\n    return strings.TrimRight(strings.Join(res, \"\"), \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584499,
                "title": "python3-solution-time-o-n-space-o-1",
                "content": "Python3 Solution\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        total_index = cols*rows\\n        final_str = \"\"\\n        for i in range(cols):\\n            cur_ind = i\\n            \\n            while cur_ind < total_index:\\n                final_str += encodedText[cur_ind]\\n                cur_ind += cols+1\\n                \\n\\n            \\n        return final_str.rstrip()\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        total_index = cols*rows\\n        final_str = \"\"\\n        for i in range(cols):\\n            cur_ind = i\\n            \\n            while cur_ind < total_index:\\n                final_str += encodedText[cur_ind]\\n                cur_ind += cols+1\\n                \\n\\n            \\n        return final_str.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580159,
                "title": "c-o-n-solution",
                "content": "**Example:**\\n```\\n// \\'_\\' - space\\n// encodedText = \"c h _ _ _ i e _ _ _ p r\",  encodedLength = 12, rows = 3, \\n// columns = encodedText.Length/rows = 4\\n// encodedText[0] = c\\n// encodedText[5] = i\\n// encodedText[10] = p\\n// encodedText[1] = h\\n// encodedText[6] = e\\n// encodedText[11] = r\\n// encodedText[2] = _  \\n// encodedText[7] = _\\n// encodedText[3] = _\\nHere we can see pattern - 0, 5, 10, 1, 6, 11, ...\\n```\\n\\n**Solution with array:**\\n\\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1; \\n        var decodedArr = new char[encodedText.Length];\\n        var decodedIndex = 0;\\n        var lastLetterIndex = 0;\\n        for (int start=0; start<columns; start++) \\n        {\\n            for (int index = start; index < encodedText.Length; index += offset) \\n            {\\n                decodedArr[decodedIndex] = encodedText[index];\\n                if (Char.IsLower(decodedArr[decodedIndex]))\\n                    lastLetterIndex = decodedIndex;\\n                decodedIndex++;\\n            }\\n        }\\n        return new string(decodedArr, 0, lastLetterIndex+1); // remove all trailing spaces\\n    }\\n```\\n\\n**Solution with StringBuilder:**\\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        var sb = new StringBuilder(encodedText.Length);\\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1;\\n        for (int start=0; start<columns; start++) \\n            for (int index = start; index < encodedText.Length; index += offset) \\n                sb.Append(encodedText[index]);\\n        \\n        return sb.ToString().TrimEnd();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// \\'_\\' - space\\n// encodedText = \"c h _ _ _ i e _ _ _ p r\",  encodedLength = 12, rows = 3, \\n// columns = encodedText.Length/rows = 4\\n// encodedText[0] = c\\n// encodedText[5] = i\\n// encodedText[10] = p\\n// encodedText[1] = h\\n// encodedText[6] = e\\n// encodedText[11] = r\\n// encodedText[2] = _  \\n// encodedText[7] = _\\n// encodedText[3] = _\\nHere we can see pattern - 0, 5, 10, 1, 6, 11, ...\\n```\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1; \\n        var decodedArr = new char[encodedText.Length];\\n        var decodedIndex = 0;\\n        var lastLetterIndex = 0;\\n        for (int start=0; start<columns; start++) \\n        {\\n            for (int index = start; index < encodedText.Length; index += offset) \\n            {\\n                decodedArr[decodedIndex] = encodedText[index];\\n                if (Char.IsLower(decodedArr[decodedIndex]))\\n                    lastLetterIndex = decodedIndex;\\n                decodedIndex++;\\n            }\\n        }\\n        return new string(decodedArr, 0, lastLetterIndex+1); // remove all trailing spaces\\n    }\\n```\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        var sb = new StringBuilder(encodedText.Length);\\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1;\\n        for (int start=0; start<columns; start++) \\n            for (int index = start; index < encodedText.Length; index += offset) \\n                sb.Append(encodedText[index]);\\n        \\n        return sb.ToString().TrimEnd();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580075,
                "title": "c-diagonal-traversal-o-n-time-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string res = \"\";\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> v(rows, vector<char>(cols));\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                v[i][j] = encodedText[i*cols + j];\\n            }\\n        }\\n        for(int g=0; g<cols; g++){\\n            for(int i=0, j=i+g; i<rows && j<cols; i++, j++){\\n                res += v[i][j];\\n            }\\n        }\\n        int l = res.length();\\n        while(l > 0 && res[l-1] == \\' \\'){\\n            res.pop_back();\\n            l--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string res = \"\";\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> v(rows, vector<char>(cols));\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                v[i][j] = encodedText[i*cols + j];\\n            }\\n        }\\n        for(int g=0; g<cols; g++){\\n            for(int i=0, j=i+g; i<rows && j<cols; i++, j++){\\n                res += v[i][j];\\n            }\\n        }\\n        int l = res.length();\\n        while(l > 0 && res[l-1] == \\' \\'){\\n            res.pop_back();\\n            l--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579817,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        res = []\\n        cols = n // rows\\n        \\n        for i in range(cols):\\n            for j in range(i, n, cols+1):\\n                res.append(encodedText[j])  # it is observed that skipping cols+1 from a given pos gives the required char\\n                \\n        return \\'\\'.join(res).rstrip(\\' \\')  # removes trailing spaces from right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        res = []\\n        cols = n // rows\\n        \\n        for i in range(cols):\\n            for j in range(i, n, cols+1):\\n                res.append(encodedText[j])  # it is observed that skipping cols+1 from a given pos gives the required char\\n                \\n        return \\'\\'.join(res).rstrip(\\' \\')  # removes trailing spaces from right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578286,
                "title": "python-2-approaches",
                "content": "Python O(n**2) / O(n) - matrix construction\\n```\\nclass Solution:\\n    def generate_matrix(self, s, rows, cols, N):\\n        i = 0\\n        m = [[None] * cols for _ in range(rows)]\\n        for r in range(rows):\\n            for c in range(cols):\\n                m[r][c] = s[i]\\n                i += 1\\n                if i >= N: return m\\n                \\n    def decipher_by_matrix(self, m, rows, cols, N):\\n        i = 0        \\n        result = []\\n        \\n        for c in range(cols):\\n            ci, ri = c, 0\\n            if i >= N: return result  \\n            while ci < cols and ri < rows and i < N:\\n                result.append(m[ri][ci])\\n                ri += 1\\n                ci += 1\\n                i += 1\\n                \\n        return result  \\n    \\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        N = len(s)        \\n        cols = N // rows\\n        \\n        m = self.generate_matrix(s, rows, cols, N)                \\n        result = self.decipher_by_matrix(m, rows, cols, N)\\n                                    \\n        return \\'\\'.join(result).rstrip()\\n```\\n\\nPython O(n)/O(1)\\n```\\nclass Solution:\\n    def decodeCiphertext(self, s, rows):\\n        cols, N, result = len(s) // rows, len(s), []\\n        for col in range(cols):\\n            for move in range(col, N, cols + 1):\\n                result.append(s[move])                \\n        return \\'\\'.join(result).rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generate_matrix(self, s, rows, cols, N):\\n        i = 0\\n        m = [[None] * cols for _ in range(rows)]\\n        for r in range(rows):\\n            for c in range(cols):\\n                m[r][c] = s[i]\\n                i += 1\\n                if i >= N: return m\\n                \\n    def decipher_by_matrix(self, m, rows, cols, N):\\n        i = 0        \\n        result = []\\n        \\n        for c in range(cols):\\n            ci, ri = c, 0\\n            if i >= N: return result  \\n            while ci < cols and ri < rows and i < N:\\n                result.append(m[ri][ci])\\n                ri += 1\\n                ci += 1\\n                i += 1\\n                \\n        return result  \\n    \\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        N = len(s)        \\n        cols = N // rows\\n        \\n        m = self.generate_matrix(s, rows, cols, N)                \\n        result = self.decipher_by_matrix(m, rows, cols, N)\\n                                    \\n        return \\'\\'.join(result).rstrip()\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, s, rows):\\n        cols, N, result = len(s) // rows, len(s), []\\n        for col in range(cols):\\n            for move in range(col, N, cols + 1):\\n                result.append(s[move])                \\n        return \\'\\'.join(result).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578283,
                "title": "python-solution-with-explanation-approach",
                "content": "First we need to understand the format in which the encrypted answer is given. We get it in the length of (math.ceil(len(encodedText)/rows)).\\nNow just start 2 for loops. One for the ith element and the other for the row. \\nIf we visualize it becomes,\\nFIrst word first letter, Second Word second letter, Third word third letter till end\\nThen the next time it\\'s First word second letter, second word third letter and so on.\\n\\n\\n\\n```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = (math.ceil(len(encodedText)/rows))\\n        if rows==1:\\n            return encodedText\\n        if n==0:\\n            return \"\"\\n        out = [(encodedText[i:i+n]) for i in range(0, len(encodedText), n)]\\n        res = \"\"\\n        for i in range(n):\\n            for j in range(0,rows):\\n                try:\\n                    if j+i<=n:\\n                        res += out[j][j+i]\\n                    else:\\n                        return res\\n                except:\\n                    return res.rstrip()\\n\\t```\\n\\t\\n\\tNot the best explaination but I learning how to explain my approach to others. Do ask if any doubt.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = (math.ceil(len(encodedText)/rows))\\n        if rows==1:\\n            return encodedText\\n        if n==0:\\n            return \"\"\\n        out = [(encodedText[i:i+n]) for i in range(0, len(encodedText), n)]\\n        res = \"\"\\n        for i in range(n):\\n            for j in range(0,rows):\\n                try:\\n                    if j+i<=n:\\n                        res += out[j][j+i]\\n                    else:\\n                        return res\\n                except:\\n                    return res.rstrip()\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1577063,
                "title": "python3-simulation",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        ans = []\\n        for offset in range(cols): \\n            i, j = 0, offset\\n            while i*cols+j < len(encodedText): \\n                ans.append(encodedText[i*cols+j])\\n                i, j = i+1, j+1\\n        return \"\".join(ans).rstrip()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        ans = []\\n        for offset in range(cols): \\n            i, j = 0, offset\\n            while i*cols+j < len(encodedText): \\n                ans.append(encodedText[i*cols+j])\\n                i, j = i+1, j+1\\n        return \"\".join(ans).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576987,
                "title": "c-2075-decode-the-slanted-ciphertext",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows; \\n        string ans; \\n        for (int offset = 0; offset < cols; ++offset) \\n            for (int i = 0, j = offset;  i*cols+j < encodedText.size(); ++i, ++j) \\n                ans.push_back(encodedText[i*cols+j]); \\n        return ans.substr(0, 1+ans.find_last_not_of(\\' \\')); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows; \\n        string ans; \\n        for (int offset = 0; offset < cols; ++offset) \\n            for (int i = 0, j = offset;  i*cols+j < encodedText.size(); ++i, ++j) \\n                ans.push_back(encodedText[i*cols+j]); \\n        return ans.substr(0, 1+ans.find_last_not_of(\\' \\')); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576961,
                "title": "c-easy-simple-iterate",
                "content": "1) Just create matrix from given encoded text.\\n2) Iterate Diagonally\\n\\nNote : the number of column is **ceil value of (size of given string / given rows)**\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size()/r + (s.size()%r!=0);\\n        vector<vector<char>>vc(r,vector<char>(c));\\n        int row = -1 , col = -1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(i%c==0)\\n            {\\n                row++;\\n                col=0;\\n            }\\n            vc[row][col++] = s[i];\\n        }\\n        \\n//         for(int i=0;i<r;i++)\\n//         {\\n//             for(int j=0;j<c;j++)\\n//             {\\n//                 cout<<vc[i][j];\\n    \\n//             }\\n//             cout<<endl;\\n//         }\\n        string ans = \"\";\\n        int column=0;\\n        while(column<c)\\n        {\\n            int crRow = 0;\\n            int crCol = column;\\n            while(crRow<r and crCol<c)\\n            {\\n                ans+=vc[crRow++][crCol++];\\n            }\\n            column++;\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size()/r + (s.size()%r!=0);\\n        vector<vector<char>>vc(r,vector<char>(c));\\n        int row = -1 , col = -1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(i%c==0)\\n            {\\n                row++;\\n                col=0;\\n            }\\n            vc[row][col++] = s[i];\\n        }\\n        \\n//         for(int i=0;i<r;i++)\\n//         {\\n//             for(int j=0;j<c;j++)\\n//             {\\n//                 cout<<vc[i][j];\\n    \\n//             }\\n//             cout<<endl;\\n//         }\\n        string ans = \"\";\\n        int column=0;\\n        while(column<c)\\n        {\\n            int crRow = 0;\\n            int crCol = column;\\n            while(crRow<r and crCol<c)\\n            {\\n                ans+=vc[crRow++][crCol++];\\n            }\\n            column++;\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1576940,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        ans = \"\"\\n        \\n        # Iterate over each index of first row\\n        for i in range(cols):\\n            # Keep adding letters with an interval of (cols+1) (diagonally) till you reach the end of the matrix\\n            for j in range(i, rows*cols, cols+1):\\n                ans += encodedText[j]\\n        \\n        # Remove the trailing spaces\\n        return ans.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        ans = \"\"\\n        \\n        # Iterate over each index of first row\\n        for i in range(cols):\\n            # Keep adding letters with an interval of (cols+1) (diagonally) till you reach the end of the matrix\\n            for j in range(i, rows*cols, cols+1):\\n                ans += encodedText[j]\\n        \\n        # Remove the trailing spaces\\n        return ans.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576938,
                "title": "c-straightforward-solution",
                "content": "\\n\\nGet col number with `encodedText.size() / rows` and then re-construct the answer with the rules.\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows;\\n        string ans;\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = 0; j < rows; j++) {\\n                int idx = j * cols + j + i;\\n                if(idx >= encodedText.size()) break;\\n                ans += encodedText[idx];\\n            }\\n        }\\n        while(ans.back() == \\' \\' && ans.size())ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows;\\n        string ans;\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = 0; j < rows; j++) {\\n                int idx = j * cols + j + i;\\n                if(idx >= encodedText.size()) break;\\n                ans += encodedText[idx];\\n            }\\n        }\\n        while(ans.back() == \\' \\' && ans.size())ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576915,
                "title": "java-iterate-diagonally",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String str, int rows) {\\n\\n        //first find column size!!\\n    \\tint cols=str.length()/rows;\\n    \\tStringBuilder res=new StringBuilder(),new_res=new StringBuilder();;\\n    \\tfor(int i=0;i<cols;i++) {\\n        \\n            //iterating diagonally!!\\n            for(int j=i;j<str.length();j+=cols+1)\\n    \\t\\t\\tres.append(str.charAt(j));\\n    \\t}\\n        \\n        //removing last spaces!!!\\n        int fg=0;\\n        for(int i=res.length()-1;i>=0;i--) {\\n            \\n            if(fg==0&&res.charAt(i)==\\' \\')\\n                continue;\\n            fg=1;\\n            new_res.append(res.charAt(i));\\n        }\\n        return new_res.reverse().toString();\\n    }\\n}\\n````",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String str, int rows) {\\n\\n        //first find column size!!\\n    \\tint cols=str.length()/rows;\\n    \\tStringBuilder res=new StringBuilder(),new_res=new StringBuilder();;\\n    \\tfor(int i=0;i<cols;i++) {\\n        \\n            //iterating diagonally!!\\n            for(int j=i;j<str.length();j+=cols+1)\\n    \\t\\t\\tres.append(str.charAt(j));\\n    \\t}\\n        \\n        //removing last spaces!!!\\n        int fg=0;\\n        for(int i=res.length()-1;i>=0;i--) {\\n            \\n            if(fg==0&&res.charAt(i)==\\' \\')\\n                continue;\\n            fg=1;\\n            new_res.append(res.charAt(i));\\n        }\\n        return new_res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063729,
                "title": "simple-simulation-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        c=ceil(len(encodedText)/rows)\\n        ans=\"\"\\n        for i in range(c):\\n            j=0\\n            while(i+j<len(encodedText)):\\n                ans+=encodedText[i+j]\\n                j+=c+1\\n        i=len(ans)-1\\n        while(i>=0):\\n            if(ans[i]==\\' \\'):\\n                i-=1\\n            else: break\\n\\n        return ans[:i+1]\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        c=ceil(len(encodedText)/rows)\\n        ans=\"\"\\n        for i in range(c):\\n            j=0\\n            while(i+j<len(encodedText)):\\n                ans+=encodedText[i+j]\\n                j+=c+1\\n        i=len(ans)-1\\n        while(i>=0):\\n            if(ans[i]==\\' \\'):\\n                i-=1\\n            else: break\\n\\n        return ans[:i+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872331,
                "title": "step-by-step-beginner-s-friendly-explanation",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n^2)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n\\n     //step 1 : find no. of columns needed in the matrix\\n     int cols = encodedText.length()/rows;\\n     string ans = \"\"; \\n     int k = 0, i = 0, j = 0, nxtCol = 1;\\n\\n     //step 2 : form the matrix from the given string\\n     vector<vector<char>> grid(rows,vector<char>(cols,\\' \\'));\\n      for(int i=0; i<rows; i++){\\n           for(int j=0; j<cols; j++){\\n                 grid[i][j] = encodedText[k++];\\n           }\\n       }\\n\\n      //step 3 : form the decoded string by traversing the matrix diagonally\\n       k = 0;\\n       while(nxtCol <= cols)\\n       {\\n           if(i >= rows || j >= cols) //always keep i and j as valid index\\n           {\\n               i = 0;\\n               j = nxtCol;\\n               nxtCol++;\\n           }\\n          if(j < cols) ans += grid[i][j];\\n          i++;\\n          j++;\\n       }\\n\\n      //step 4 : remove leading spaces, if any\\n       while(!ans.empty() && ans.back() == \\' \\')\\n        ans.pop_back();\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n\\n     //step 1 : find no. of columns needed in the matrix\\n     int cols = encodedText.length()/rows;\\n     string ans = \"\"; \\n     int k = 0, i = 0, j = 0, nxtCol = 1;\\n\\n     //step 2 : form the matrix from the given string\\n     vector<vector<char>> grid(rows,vector<char>(cols,\\' \\'));\\n      for(int i=0; i<rows; i++){\\n           for(int j=0; j<cols; j++){\\n                 grid[i][j] = encodedText[k++];\\n           }\\n       }\\n\\n      //step 3 : form the decoded string by traversing the matrix diagonally\\n       k = 0;\\n       while(nxtCol <= cols)\\n       {\\n           if(i >= rows || j >= cols) //always keep i and j as valid index\\n           {\\n               i = 0;\\n               j = nxtCol;\\n               nxtCol++;\\n           }\\n          if(j < cols) ans += grid[i][j];\\n          i++;\\n          j++;\\n       }\\n\\n      //step 4 : remove leading spaces, if any\\n       while(!ans.empty() && ans.back() == \\' \\')\\n        ans.pop_back();\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584778,
                "title": "just-construct-matrix-and-traverse-diagonally",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int c=n/rows;\\n        vector<vector<char>>m(rows,vector<char>(c));\\n        int k=0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<c;j++){\\n                m[i][j]=encodedText[k++];\\n            }\\n        }\\n        string ans;\\n        for(int k=0;k<c;k++){\\n                int j=k;\\n                int i=0;\\n                while(i<rows && j<c){\\n                    ans+=m[i][j];\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        bool f=true;\\n        string s;\\n        for(int i=ans.size()-1;i>=0;i--){\\n            if(f && ans[i]==\\' \\'){\\n               \\n            }\\n            else{\\n                f=false;\\n                s+=ans[i];\\n            }\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int c=n/rows;\\n        vector<vector<char>>m(rows,vector<char>(c));\\n        int k=0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<c;j++){\\n                m[i][j]=encodedText[k++];\\n            }\\n        }\\n        string ans;\\n        for(int k=0;k<c;k++){\\n                int j=k;\\n                int i=0;\\n                while(i<rows && j<c){\\n                    ans+=m[i][j];\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        bool f=true;\\n        string s;\\n        for(int i=ans.size()-1;i>=0;i--){\\n            if(f && ans[i]==\\' \\'){\\n               \\n            }\\n            else{\\n                f=false;\\n                s+=ans[i];\\n            }\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516695,
                "title": "c-easy-solution-simulation-diagonal-traversal",
                "content": "# Intuition\\n**Columns = encodedText.size/rows** . Now make the grid as given in example and do diagonal traversal from every column.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n = eT.size();\\n        if(n==0)\\n        return \"\";\\n        int cols = n/rows;\\n        vector<vector<char>> grid(rows,vector<char>(cols));\\n        int ptr = 0;\\n        int col = 0;\\n        int row = 0;\\n        while(ptr<n)\\n        {\\n            grid[row][col] = eT[ptr];\\n            ptr++;\\n            col = (col+1)%cols;\\n            if(col==0)\\n            row++;\\n        }\\n        string ans = \"\";\\n        for(int j=0;j<cols;j++)\\n        {\\n            int c = j;\\n            int r = 0;\\n            while(c<cols && r<rows)\\n            {\\n                ans+=grid[r][c];\\n                c++;\\n                r++;\\n            }\\n        }\\n        while(ans[ans.size()-1]==\\' \\')\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n = eT.size();\\n        if(n==0)\\n        return \"\";\\n        int cols = n/rows;\\n        vector<vector<char>> grid(rows,vector<char>(cols));\\n        int ptr = 0;\\n        int col = 0;\\n        int row = 0;\\n        while(ptr<n)\\n        {\\n            grid[row][col] = eT[ptr];\\n            ptr++;\\n            col = (col+1)%cols;\\n            if(col==0)\\n            row++;\\n        }\\n        string ans = \"\";\\n        for(int j=0;j<cols;j++)\\n        {\\n            int c = j;\\n            int r = 0;\\n            while(c<cols && r<rows)\\n            {\\n                ans+=grid[r][c];\\n                c++;\\n                r++;\\n            }\\n        }\\n        while(ans[ans.size()-1]==\\' \\')\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470468,
                "title": "simulation-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) \\n    {\\n        if(rows==1) return encodedText;\\n        int cols=encodedText.size()/rows;\\n        vector<vector<char>> v(rows, vector<char> (cols,\\' \\'));\\n        int i=0, done=0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                v[x][y]=encodedText[i++];\\n                if(i==encodedText.size()) \\n                {\\n                    done=1;\\n                    break;\\n                }\\n            }\\n            if(done) break;\\n        }\\n        string ans=\"\";\\n        int r=0, c=0, col=0;\\n        while(col<cols)\\n        {\\n            ans+=v[r][c];\\n            r++, c++;\\n            if(r==rows || c==cols)\\n            {\\n                r=0; col++;\\n                c=col;\\n            }\\n        }\\n        int j=ans.size()-1;\\n        while(j>=0 && ans[j]==\\' \\') j--;\\n        ans=ans.substr(0,j+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) \\n    {\\n        if(rows==1) return encodedText;\\n        int cols=encodedText.size()/rows;\\n        vector<vector<char>> v(rows, vector<char> (cols,\\' \\'));\\n        int i=0, done=0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                v[x][y]=encodedText[i++];\\n                if(i==encodedText.size()) \\n                {\\n                    done=1;\\n                    break;\\n                }\\n            }\\n            if(done) break;\\n        }\\n        string ans=\"\";\\n        int r=0, c=0, col=0;\\n        while(col<cols)\\n        {\\n            ans+=v[r][c];\\n            r++, c++;\\n            if(r==rows || c==cols)\\n            {\\n                r=0; col++;\\n                c=col;\\n            }\\n        }\\n        int j=ans.size()-1;\\n        while(j>=0 && ans[j]==\\' \\') j--;\\n        ans=ans.substr(0,j+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416162,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = i; j < n; j += cols + 1) {\\n                ans += encodedText[j];\\n            }\\n        }\\n        while(ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = i; j < n; j += cols + 1) {\\n                ans += encodedText[j];\\n            }\\n        }\\n        while(ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382410,
                "title": "python-solution-with-explanation",
                "content": "### simulation\\n\\n```python\\n\\'\\'\\'\\ntraverse string diagonally, \\nif the index of row or columns is out of bound,\\nback to the fisrt row.\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1: return encodedText\\n        numCol = len(encodedText) // rows\\n        ans = []  \\n        mapping = lambda r, c: numCol * r + c\\n        for curCol in range(numCol):\\n            r, c = 0, curCol\\n            while mapping(r, c) < rows * numCol:\\n                ans.append(encodedText[mapping(r, c)])\\n                r += 1\\n                c += 1\\n        return \\'\\'.join(ans).rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\ntraverse string diagonally, \\nif the index of row or columns is out of bound,\\nback to the fisrt row.\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1: return encodedText\\n        numCol = len(encodedText) // rows\\n        ans = []  \\n        mapping = lambda r, c: numCol * r + c\\n        for curCol in range(numCol):\\n            r, c = 0, curCol\\n            while mapping(r, c) < rows * numCol:\\n                ans.append(encodedText[mapping(r, c)])\\n                r += 1\\n                c += 1\\n        return \\'\\'.join(ans).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365847,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size() ;\\n        int cols = n/rows ;\\n        vector<vector<char>>mat(rows, vector<char>(cols)) ;\\n        for(int i = 0; i < n; i++){\\n            mat[i/cols][i%cols] = encodedText[i] ;\\n        }\\n        string ret ;\\n        for(int i = 0; i < cols; i++){\\n            int r = 0, c = i ;\\n            while(r < rows && c < cols){\\n                ret.push_back(mat[r][c] ) ;\\n                r++ ;\\n                c++ ;\\n            }\\n        }\\n        while(ret.size() && ret.back() == \\' \\')\\n            ret.pop_back() ;\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size() ;\\n        int cols = n/rows ;\\n        vector<vector<char>>mat(rows, vector<char>(cols)) ;\\n        for(int i = 0; i < n; i++){\\n            mat[i/cols][i%cols] = encodedText[i] ;\\n        }\\n        string ret ;\\n        for(int i = 0; i < cols; i++){\\n            int r = 0, c = i ;\\n            while(r < rows && c < cols){\\n                ret.push_back(mat[r][c] ) ;\\n                r++ ;\\n                c++ ;\\n            }\\n        }\\n        while(ret.size() && ret.back() == \\' \\')\\n            ret.pop_back() ;\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325766,
                "title": "c-stright-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string et, int rows) {\\n        cout << et.size() << \" \" << rows;\\n        string res = \"\";\\n        int col = et.size() / rows;\\n        int idx = 0;\\n        string space = \"\";\\n        // cout << col << \" \" << rows << \" \";\\n        while(idx < col - rows + 2) {\\n            for(int i = 0; i < rows && idx + i + i * col < et.size(); i++) {\\n                if(et[idx + i + i * col] == \\' \\')\\n                    space += \\' \\';\\n                else {\\n                    res += (space + et[idx + i + i * col]);                    \\n                    space = \"\";\\n                }\\n\\n            }\\n            idx++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string et, int rows) {\\n        cout << et.size() << \" \" << rows;\\n        string res = \"\";\\n        int col = et.size() / rows;\\n        int idx = 0;\\n        string space = \"\";\\n        // cout << col << \" \" << rows << \" \";\\n        while(idx < col - rows + 2) {\\n            for(int i = 0; i < rows && idx + i + i * col < et.size(); i++) {\\n                if(et[idx + i + i * col] == \\' \\')\\n                    space += \\' \\';\\n                else {\\n                    res += (space + et[idx + i + i * col]);                    \\n                    space = \"\";\\n                }\\n\\n            }\\n            idx++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3324281,
                "title": "2-solutions-beginner-friendly-c",
                "content": "***Please do upvote \\u2B06\\uFE0F my solution to keep me motivated :)***\\n***Doubts?? I am super active at the comments section. \\uD83D\\uDE00***\\n\\n\\n\\n## Brute Force \\n**Tc - O(m*n)**\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        vector<vector<char>> mat(rows,vector<char>(cols,\\' \\'));\\n        int i=0;\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                if(i<n) {\\n                    mat[r][c] = encodedText[i++];\\n                }\\n            }\\n        }\\n\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                cout<<mat[r][c]<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n\\n        string originalText = \"\";\\n        int r=0;\\n        for(int c=0;c<cols;c++) {\\n            int tc = c;\\n                while(r!=rows && tc!=cols) {\\n                originalText += mat[r][tc];\\n                r++;\\n                tc++;\\n            }\\n            r = 0;\\n        }\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n``` \\n## Optimised Solution\\n**Tc - O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        string originalText = \"\";\\n        for(int i=0;i<cols;i++) {\\n            for(int j=i;j<n;j+=cols+1) {\\n                originalText += encodedText[j];\\n            }\\n        }\\n\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        vector<vector<char>> mat(rows,vector<char>(cols,\\' \\'));\\n        int i=0;\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                if(i<n) {\\n                    mat[r][c] = encodedText[i++];\\n                }\\n            }\\n        }\\n\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                cout<<mat[r][c]<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n\\n        string originalText = \"\";\\n        int r=0;\\n        for(int c=0;c<cols;c++) {\\n            int tc = c;\\n                while(r!=rows && tc!=cols) {\\n                originalText += mat[r][tc];\\n                r++;\\n                tc++;\\n            }\\n            r = 0;\\n        }\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        string originalText = \"\";\\n        for(int i=0;i<cols;i++) {\\n            for(int j=i;j<n;j+=cols+1) {\\n                originalText += encodedText[j];\\n            }\\n        }\\n\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3269614,
                "title": "easy-c-solution-string-and-index-manipulation",
                "content": "```\\n    string decodeCiphertext(string text, int rows) {\\n        \\n        string ans = \"\";\\n        int n = text.size();\\n        int fac = n/rows;\\n        \\n        for(int i = 0;i<fac;i++){\\n            int temp = i;\\n            while(temp<n){\\n                ans+=text[temp];\\n                temp+=(fac+1);\\n            }\\n        }\\n        \\n        while(!ans.empty() and ans.back()==\\' \\'){\\n            ans.pop_back();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n    string decodeCiphertext(string text, int rows) {\\n        \\n        string ans = \"\";\\n        int n = text.size();\\n        int fac = n/rows;\\n        \\n        for(int i = 0;i<fac;i++){\\n            int temp = i;\\n            while(temp<n){\\n                ans+=text[temp];\\n                temp+=(fac+1);\\n            }\\n        }\\n        \\n        while(!ans.empty() and ans.back()==\\' \\'){\\n            ans.pop_back();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260455,
                "title": "javascript-100-runtime",
                "content": "```\\nconst decodeCiphertext = (text, rows) => {\\n  if (rows == 1 || text.length < rows) return text;\\n\\n  const reg = new RegExp(`.{1,${text.length / rows}}`, \"g\");\\n  rows = text.match(reg);\\n\\n  let res = \"\";\\n  for (let i = 0; i < rows[0].length; i++) {\\n    for (let j = 0, k = i; j < rows.length; j++, k++) {\\n      if (k > rows[0].length - 1) return res.replace(/\\\\s+$/, \"\");\\n      res += rows[j][k];\\n    }\\n  }\\n\\n  return res.replace(/\\\\s+$/, \"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decodeCiphertext = (text, rows) => {\\n  if (rows == 1 || text.length < rows) return text;\\n\\n  const reg = new RegExp(`.{1,${text.length / rows}}`, \"g\");\\n  rows = text.match(reg);\\n\\n  let res = \"\";\\n  for (let i = 0; i < rows[0].length; i++) {\\n    for (let j = 0, k = i; j < rows.length; j++, k++) {\\n      if (k > rows[0].length - 1) return res.replace(/\\\\s+$/, \"\");\\n      res += rows[j][k];\\n    }\\n  }\\n\\n  return res.replace(/\\\\s+$/, \"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3199343,
                "title": "python-solution",
                "content": "```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        str_len = len(encodedText)\\n        print(str_len)\\n        m = rows\\n        n = str_len // m\\n        def read(i, remain, arr):\\n            if remain > 0:\\n                print(encodedText[i])\\n                arr.append(encodedText[i])\\n                next_i = i + n + 1\\n                read(next_i, remain - 1, arr)\\n        remain = m\\n        res_arr = []\\n        for i in range(n):\\n            if i <= n - m:\\n                read(i, remain, res_arr)\\n            else:\\n                new_remain = n - i\\n                read(i, new_remain, res_arr)\\n        res_str1 = \"\".join(res_arr)\\n        res_str2 = res_str1.rstrip()\\n        return res_str2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        str_len = len(encodedText)\\n        print(str_len)\\n        m = rows\\n        n = str_len // m\\n        def read(i, remain, arr):\\n            if remain > 0:\\n                print(encodedText[i])\\n                arr.append(encodedText[i])\\n                next_i = i + n + 1\\n                read(next_i, remain - 1, arr)\\n        remain = m\\n        res_arr = []\\n        for i in range(n):\\n            if i <= n - m:\\n                read(i, remain, res_arr)\\n            else:\\n                new_remain = n - i\\n                read(i, new_remain, res_arr)\\n        res_str1 = \"\".join(res_arr)\\n        res_str2 = res_str1.rstrip()\\n        return res_str2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3196538,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def decodeCiphertext(encodedText: String, rows: Int): String = {\\n        if(encodedText.length < 1) return encodedText\\n        val rowlength = encodedText.length / rows\\n        val ts = encodedText.sliding(rowlength, rowlength)\\n        val res = (0 until rows).foldLeft(new Array[String](rows))((ans, i) =>{\\n            val t = ts.next()\\n            ans(i) = t.drop(i) + (\" \" * rows)\\n            ans\\n        })\\n        (for{j<- 0 until rowlength\\n            i <- 0 until rows} yield res(i)(j)).mkString.reverse.dropWhile(_ == \\' \\').reverse\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def decodeCiphertext(encodedText: String, rows: Int): String = {\\n        if(encodedText.length < 1) return encodedText\\n        val rowlength = encodedText.length / rows\\n        val ts = encodedText.sliding(rowlength, rowlength)\\n        val res = (0 until rows).foldLeft(new Array[String](rows))((ans, i) =>{\\n            val t = ts.next()\\n            ans(i) = t.drop(i) + (\" \" * rows)\\n            ans\\n        })\\n        (for{j<- 0 until rowlength\\n            i <- 0 until rows} yield res(i)(j)).mkString.reverse.dropWhile(_ == \\' \\').reverse\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3186887,
                "title": "beats-100-runtime-memory-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first if statement checks if the encodedText is empty and returns an empty string if it is.\\n\\nNext, charIdx and nextColumnIdx are initialized to 0 and 1 respectively. The charIdx variable represents the index of the character in the encoded text that we are currently processing. The nextColumnIdx variable is used to keep track of the next column index when we have finished decoding the current column.\\n\\nThe number of columns is calculated based on the encoded text\\'s length and the number of rows used for encoding. If the length of the encoded text is not a multiple of the number of rows, the function returns the original encoded text.\\n\\nA result variable is initialized as an empty string, which will hold the decoded text.\\n\\nThe while loop decodes the text one character at a time, starting from the first character in the first row. We add the current character to the result string and then move to the next character in the same column by adding the number of columns to the current index and moving to the next row.\\n\\nIf we have reached the last column, we break out of the loop as we have finished decoding the text. If we have not reached the last column, we continue decoding by moving to the next column.\\n\\nIf we have reached the end of the rows, we move to the next column and start decoding from the first row of the next column.\\n\\nFinally, we return the result string with any trailing spaces removed.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    if (encodedText.length == 0) return \"\"\\n    let charIdx: number = 0;\\n    let nextColumnIdx: number = 1\\n    const columns = encodedText.length / rows\\n    if (encodedText.length !== rows * columns)\\n        return encodedText\\n    let result: string = \"\"\\n    while (true) {\\n        result += encodedText[charIdx]\\n        // break when reached last column\\n        if (charIdx === columns - 1) break;\\n        // move one row below, one column right\\n        charIdx = charIdx + columns + 1;\\n        // move up to first row if passed the row limit\\n        if (charIdx > columns * rows - 1) {\\n            charIdx = nextColumnIdx\\n            nextColumnIdx++\\n        }\\n    }\\n    return result.trimEnd()\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    if (encodedText.length == 0) return \"\"\\n    let charIdx: number = 0;\\n    let nextColumnIdx: number = 1\\n    const columns = encodedText.length / rows\\n    if (encodedText.length !== rows * columns)\\n        return encodedText\\n    let result: string = \"\"\\n    while (true) {\\n        result += encodedText[charIdx]\\n        // break when reached last column\\n        if (charIdx === columns - 1) break;\\n        // move one row below, one column right\\n        charIdx = charIdx + columns + 1;\\n        // move up to first row if passed the row limit\\n        if (charIdx > columns * rows - 1) {\\n            charIdx = nextColumnIdx\\n            nextColumnIdx++\\n        }\\n    }\\n    return result.trimEnd()\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3181434,
                "title": "c-easy-undestanding-one-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        int n=s.size(),k=0;\\n        vector<string>v(rows);\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<n/rows;j++)\\n                v[i].push_back(s[k++]);\\n        s=\"\";\\n        for(int k=0;k<n/rows;k++)\\n            for(int i=0,j=k;i<rows && j<n/rows;i++,j++)\\n                    s+=v[i][j];\\n        n=s.size()-1;\\n        while(n>=0 && s[n]==\\' \\')\\n            n--;\\n        return s.substr(0,n+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        int n=s.size(),k=0;\\n        vector<string>v(rows);\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<n/rows;j++)\\n                v[i].push_back(s[k++]);\\n        s=\"\";\\n        for(int k=0;k<n/rows;k++)\\n            for(int i=0,j=k;i<rows && j<n/rows;i++,j++)\\n                    s+=v[i][j];\\n        n=s.size()-1;\\n        while(n>=0 && s[n]==\\' \\')\\n            n--;\\n        return s.substr(0,n+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086658,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int rows) {\\n        int l = str.size();\\n        int m = l / rows;\\n        \\n        string ans;\\n        for(int i = 0; i < m; i++) {\\n            int j = i;\\n            while(j < l) {\\n                ans += str[j];\\n                j += m + 1;\\n            }\\n        }\\n\\n        for(int i = ans.size() - 1; i >= 0 and ans[i] == \\' \\'; i--)\\n            ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int rows) {\\n        int l = str.size();\\n        int m = l / rows;\\n        \\n        string ans;\\n        for(int i = 0; i < m; i++) {\\n            int j = i;\\n            while(j < l) {\\n                ans += str[j];\\n                j += m + 1;\\n            }\\n        }\\n\\n        for(int i = ans.size() - 1; i >= 0 and ans[i] == \\' \\'; i--)\\n            ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085408,
                "title": "c-simple-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string enctext, int rows) {\\n        if(rows==1) return enctext;\\n        int len = enctext.length();\\n        int col = len/rows;\\n        string ans;\\n        int count = 0;\\n        for(char c : enctext) if(c!=\\' \\') count++;\\n        for(int i=0;i<len;i++){\\n            int j = i;\\n            while(j<len){\\n                if(count==0) break;\\n                if(enctext[j]!=\\' \\') count--;\\n                ans+=enctext[j];\\n                j+=col+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string enctext, int rows) {\\n        if(rows==1) return enctext;\\n        int len = enctext.length();\\n        int col = len/rows;\\n        string ans;\\n        int count = 0;\\n        for(char c : enctext) if(c!=\\' \\') count++;\\n        for(int i=0;i<len;i++){\\n            int j = i;\\n            while(j<len){\\n                if(count==0) break;\\n                if(enctext[j]!=\\' \\') count--;\\n                ans+=enctext[j];\\n                j+=col+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072911,
                "title": "python-simulation-simple-solution-o-mn",
                "content": "# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        matrix = [[0]*cols for _ in range(rows)]\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix[i][j] = encodedText[i*cols + j]\\n        i,j = 0,0\\n        res = []\\n        while 0<=i<rows and 0<=j<cols:\\n            res.append(matrix[i][j])\\n            i = (i+1)%rows\\n            j += 1\\n            j = j-(rows-1)*(i==0)\\n        return \"\".join(res).rstrip()\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        matrix = [[0]*cols for _ in range(rows)]\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix[i][j] = encodedText[i*cols + j]\\n        i,j = 0,0\\n        res = []\\n        while 0<=i<rows and 0<=j<cols:\\n            res.append(matrix[i][j])\\n            i = (i+1)%rows\\n            j += 1\\n            j = j-(rows-1)*(i==0)\\n        return \"\".join(res).rstrip()\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047748,
                "title": "simple-java-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int count = 0;\\n        for (char c : encodedText.toCharArray()) if (c != \\' \\') count++;\\n        int col = encodedText.length() / rows;\\n        StringBuilder sb = new StringBuilder();\\n        int r = 0, c = 0;\\n        while (count > 0) {\\n            int index = col * r + c;\\n            if (encodedText.charAt(index) != \\' \\') count--;\\n            sb.append(encodedText.charAt(index));\\n            r++;\\n            c++;\\n            if (r == rows) {\\n                r = 0;\\n                c -= rows - 1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int count = 0;\\n        for (char c : encodedText.toCharArray()) if (c != \\' \\') count++;\\n        int col = encodedText.length() / rows;\\n        StringBuilder sb = new StringBuilder();\\n        int r = 0, c = 0;\\n        while (count > 0) {\\n            int index = col * r + c;\\n            if (encodedText.charAt(index) != \\' \\') count--;\\n            sb.append(encodedText.charAt(index));\\n            r++;\\n            c++;\\n            if (r == rows) {\\n                r = 0;\\n                c -= rows - 1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989033,
                "title": "rust-translating-x-y-coors-to-a-1d-index",
                "content": "# Intuition and Approach\\nThis is a fairly simple diagonal traversal solution. The examples paint things pretty clearly such that we may just follow the arrows to a satisfactory solution. Basically we want a simple loop over a 2 dimensional cipher like this:\\n\\n`cipher[j][i+j] for i in 0..columns for j in 0..rows if i + j < columns`\\n\\nInstead of building the cipher as a matrix, we may index into our string directly by simply translating matrix indices to an integer. This is a straight forward translation:\\n\\n```\\n[y][x] == num_columns * y + x \\n# or in a more complete, algorithmic form\\n[encoded_text[j * columns + j + i] for i in range(columns) for j in range(rows) if i + j < columns]\\n```\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        let len = encoded_text.len() / (rows as usize);\\n        let encoded_text = encoded_text.chars().collect::<Vec<char>>();\\n        let mut output = String::from(\"\");\\n        for i in 0..len {\\n            let mut x = i;\\n            let mut y = 0;\\n            while y < rows as usize && x < len {\\n                output.push(encoded_text[len * y + x]);\\n                y += 1;\\n                x += 1;\\n            }\\n        }\\n\\n        String::from(output.trim_end())\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n[y][x] == num_columns * y + x \\n# or in a more complete, algorithmic form\\n[encoded_text[j * columns + j + i] for i in range(columns) for j in range(rows) if i + j < columns]\\n```\n```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        let len = encoded_text.len() / (rows as usize);\\n        let encoded_text = encoded_text.chars().collect::<Vec<char>>();\\n        let mut output = String::from(\"\");\\n        for i in 0..len {\\n            let mut x = i;\\n            let mut y = 0;\\n            while y < rows as usize && x < len {\\n                output.push(encoded_text[len * y + x]);\\n                y += 1;\\n                x += 1;\\n            }\\n        }\\n\\n        String::from(output.trim_end())\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2980186,
                "title": "c-o-1-space-o-endodedstring-size-time-optimized-explained",
                "content": "# Intuition\\nMy main objective was not to construct the matrix, for that i tried to somehow map the useful indexes of the matrix to the ```endodedString``` index\\n\\n# Approach\\nEverytime we move one row down in the matrix we leave ```cols``` number of characters behind, I used to the same to comeup with the solution.\\n\\n# Complexity\\n- Time complexity: O(```embededText.size()```)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) , if we do not consider the output, else O(```outputLength```)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cur=0,n=encodedText.size(),cols=n/rows;\\n\\n        string res=\"\";\\n        for(int j=0;j<cols;j++){\\n            int x=0,y=j;\\n            while(x<rows && y<cols){\\n                res+=encodedText[(x*cols)+y];\\n                x++,y++;\\n            }\\n        }\\n\\n        int idx=-1;\\n        for(int i=0;i<res.size();i++){\\n            if(res[i]!=\\' \\'){\\n                idx=i;\\n            }\\n        }\\n\\n        return res.substr(0,idx+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```endodedString```\n```cols```\n```embededText.size()```\n```outputLength```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cur=0,n=encodedText.size(),cols=n/rows;\\n\\n        string res=\"\";\\n        for(int j=0;j<cols;j++){\\n            int x=0,y=j;\\n            while(x<rows && y<cols){\\n                res+=encodedText[(x*cols)+y];\\n                x++,y++;\\n            }\\n        }\\n\\n        int idx=-1;\\n        for(int i=0;i<res.size();i++){\\n            if(res[i]!=\\' \\'){\\n                idx=i;\\n            }\\n        }\\n\\n        return res.substr(0,idx+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894756,
                "title": "beginner-friendly-python-easy-to-understand-and-fast-approach",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        arr = [[\\'\\' for i in range(cols)] for j in range(rows)]\\n        ith = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                arr[i][j] = encodedText[ith]\\n                ith += 1\\n        wrapup = \\'\\'\\n        for i in range(cols):\\n            cntr = i\\n            for j in range(rows):\\n                try:\\n                    wrapup += arr[j][cntr]\\n                except:\\n                    return wrapup.rstrip()\\n                cntr += 1\\n        return wrapup.rstrip()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        arr = [[\\'\\' for i in range(cols)] for j in range(rows)]\\n        ith = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                arr[i][j] = encodedText[ith]\\n                ith += 1\\n        wrapup = \\'\\'\\n        for i in range(cols):\\n            cntr = i\\n            for j in range(rows):\\n                try:\\n                    wrapup += arr[j][cntr]\\n                except:\\n                    return wrapup.rstrip()\\n                cntr += 1\\n        return wrapup.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883787,
                "title": "python3-one-liner-explained-with-extended-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne liners are not really readable which is bad, but using list comprehensions/generators in python is likely to be quicker than extended loop.\\n\\nBelow you can find three versions, which gradually become more complex and shorter. The last version calls the join operator immediately over the generator of characters which might be the fastest and most efficient regarding memory.\\n\\nBUT: It is utterly unreadable and Python is not exactly the right language to worry about memory efficiency. I just wanted to share my approach, maybe it helps somebody.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start at a column (outer loop) of the first row and then traverse diagonal downwards (step: column + 1 for diagonal).\\n\\nThis gives us the characters in the right order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO((N*M)/2) where N is the amount of rows and M is the amount of columns.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if we omit solution space in the last function.\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext_extended(self, encodedText: str, rows: int) -> str:\\n        column = len(encodedText)//rows\\n        solution = []\\n        for cx in range(column):\\n            for strx in range(cx, len(encodedText), len(encodedText)//rows+1):\\n                solution.append(encodedText[strx])\\n        return \"\".join(solution).rstrip()\\n    \\n    def decodeCiphertext_mixed(self, encodedText: str, rows: int) -> str:\\n        text = [encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)]\\n        return \"\".join(text).rstrip()\\n    \\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        return \"\".join(encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)).rstrip()\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext_extended(self, encodedText: str, rows: int) -> str:\\n        column = len(encodedText)//rows\\n        solution = []\\n        for cx in range(column):\\n            for strx in range(cx, len(encodedText), len(encodedText)//rows+1):\\n                solution.append(encodedText[strx])\\n        return \"\".join(solution).rstrip()\\n    \\n    def decodeCiphertext_mixed(self, encodedText: str, rows: int) -> str:\\n        text = [encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)]\\n        return \"\".join(text).rstrip()\\n    \\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        return \"\".join(encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)).rstrip()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849828,
                "title": "python-simple-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        res = \"\"\\n        \\n        for i in range(cols):\\n            idx = i\\n            for j in range(rows):\\n                if idx >= len(encodedText):\\n                    break\\n                    \\n                res += encodedText[idx]\\n                idx += (cols+1)\\n                \\n        i = len(res)-1       \\n        while i >= 0:\\n            if res[i] !=  \" \":\\n                break\\n            i -= 1\\n                \\n        return res[:i+1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        res = \"\"\\n        \\n        for i in range(cols):\\n            idx = i\\n            for j in range(rows):\\n                if idx >= len(encodedText):\\n                    break\\n                    \\n                res += encodedText[idx]\\n                idx += (cols+1)\\n                \\n        i = len(res)-1       \\n        while i >= 0:\\n            if res[i] !=  \" \":\\n                break\\n            i -= 1\\n                \\n        return res[:i+1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838084,
                "title": "rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        if rows == 1 {\\n            return encoded_text;\\n        }\\n        let col_count = encoded_text.len() as i32 / rows;\\n        let mut new_vec = vec![vec![]; rows as usize];\\n        let mut res: Vec<char> = Vec::new();\\n        let _ =\\n            encoded_text\\n                .chars()\\n                .into_iter()\\n                .fold((0, 0), |(mut tmp_row, mut tmp_col), item| {\\n                    if tmp_col >= col_count {\\n                        tmp_col = 0;\\n                        tmp_row += 1;\\n                    }\\n                    new_vec[tmp_row].push(item);\\n                    tmp_col += 1;\\n\\n                    (tmp_row, tmp_col)\\n                });\\n\\n        for i in 0..col_count {\\n            for (j, _) in new_vec.iter().enumerate().take(rows as usize) {\\n                let y = i as i32 + j as i32;\\n                if y >= col_count {\\n                    break;\\n                }\\n                res.push(new_vec[j][y as usize]);\\n            }\\n        }\\n\\n        res.iter().collect::<String>().trim_end().to_owned()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        if rows == 1 {\\n            return encoded_text;\\n        }\\n        let col_count = encoded_text.len() as i32 / rows;\\n        let mut new_vec = vec![vec![]; rows as usize];\\n        let mut res: Vec<char> = Vec::new();\\n        let _ =\\n            encoded_text\\n                .chars()\\n                .into_iter()\\n                .fold((0, 0), |(mut tmp_row, mut tmp_col), item| {\\n                    if tmp_col >= col_count {\\n                        tmp_col = 0;\\n                        tmp_row += 1;\\n                    }\\n                    new_vec[tmp_row].push(item);\\n                    tmp_col += 1;\\n\\n                    (tmp_row, tmp_col)\\n                });\\n\\n        for i in 0..col_count {\\n            for (j, _) in new_vec.iter().enumerate().take(rows as usize) {\\n                let y = i as i32 + j as i32;\\n                if y >= col_count {\\n                    break;\\n                }\\n                res.push(new_vec[j][y as usize]);\\n            }\\n        }\\n\\n        res.iter().collect::<String>().trim_end().to_owned()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2803981,
                "title": "decode-the-slanted-ciphertext-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int r) {\\n        int c=text.length()/r;\\n        \\n        vector<vector<char>> grid(r, vector<char>(c, \\' \\'));\\n        \\n        int i=0, j=0;\\n        for(int k=0; k<text.length(); k++){\\n            grid[i][j++]=text[k];\\n            if((k+1)%c==0){\\n                i++;\\n                j=0;\\n            }            \\n        }\\n        \\n        int x=0;\\n        i=0; j=x;\\n        string ans=\"\";\\n        \\n        while(i<r && j<c){\\n            ans+=grid[i++][j++];\\n            if(i==r || j==c){\\n                i=0;\\n                j=++x;\\n            }\\n        }\\n        \\n        while(ans.back()==\\' \\') ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int r) {\\n        int c=text.length()/r;\\n        \\n        vector<vector<char>> grid(r, vector<char>(c, \\' \\'));\\n        \\n        int i=0, j=0;\\n        for(int k=0; k<text.length(); k++){\\n            grid[i][j++]=text[k];\\n            if((k+1)%c==0){\\n                i++;\\n                j=0;\\n            }            \\n        }\\n        \\n        int x=0;\\n        i=0; j=x;\\n        string ans=\"\";\\n        \\n        while(i<r && j<c){\\n            ans+=grid[i++][j++];\\n            if(i==r || j==c){\\n                i=0;\\n                j=++x;\\n            }\\n        }\\n        \\n        while(ans.back()==\\' \\') ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724208,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721989,
                "title": "c-sol-run-97-mem-96-simple-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int find_next(int &r,int &c,int rows,int cols) { // Function to find and set next r and c in matrix\\n        if(r!=rows-1) { // If not last row, traverse diagonally\\n            r++;c++;\\n        }\\n        else { // If last row reset to top row of matrix and set column respectively\\n            r=0;c=c-(rows-2); \\n        }\\n        return r*cols+c; // Finding index in the given string\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int r=0,c=0,index=0;\\n        string ans=\"\";\\n        int cols=encodedText.length()/rows;\\n        while(index<encodedText.length()) {\\n            ans+=encodedText[index];\\n            index=find_next(r,c,rows,cols);\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back(); // Removing trailing spaces in the answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_next(int &r,int &c,int rows,int cols) { // Function to find and set next r and c in matrix\\n        if(r!=rows-1) { // If not last row, traverse diagonally\\n            r++;c++;\\n        }\\n        else { // If last row reset to top row of matrix and set column respectively\\n            r=0;c=c-(rows-2); \\n        }\\n        return r*cols+c; // Finding index in the given string\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int r=0,c=0,index=0;\\n        string ans=\"\";\\n        int cols=encodedText.length()/rows;\\n        while(index<encodedText.length()) {\\n            ans+=encodedText[index];\\n            index=find_next(r,c,rows,cols);\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back(); // Removing trailing spaces in the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721766,
                "title": "python-solution-matrix",
                "content": "# Algorithm\\nThe solution makes use of a matrix. From the problem statement we are given the following:\\n1. encodedText\\n2. Number of rows\\n\\nFrom the above, we can calculate the number of columns.\\n**Number of columns (cols) = length of the text / number of rows**\\n\\nSteps for matrix creation:\\n1. Create an **index** to iterate over the encodedText, **row** and **col** to iterate through the matrix.\\n2. For each cell in the matrix insert the character from the text\\n\\n# Example\\nMatrix created from \\nencodedText = \"ch   ie   pr\" => ***(length = 12)***\\nrows = 3\\ncols = 4  => ***(12 / 3)***\\n\\n[[\\'c\\', \\'h\\', \\' \\', \\' \\'], \\n [\\' \\', \\'i\\', \\'e\\', \\' \\'], \\n [\\' \\', \\' \\', \\'p\\', \\'r\\']]\\n \\n Iterate though the cols. For each column increment though the row.\\n \\n#  Code\\n```\\n\\t\\tmatrix = []\\n        cols = len(encodedText) // rows\\n        index = 0\\n        for row in range(rows):\\n            temp = []\\n            for col in range(cols):\\n                char = encodedText[index]\\n                temp.append(char)\\n                index += 1\\n            matrix.append(temp)\\n        result = \"\"\\n        \\n        col = 0 # Keeping track of the start after completion of the inner for loop\\n        for _ in range(cols):\\n            r_index, c_index = 0, _\\n            while r_index < rows and c_index < cols:\\n                result += matrix[r_index][c_index]\\n                r_index += 1\\n                c_index += 1\\n            col += 1\\n        return result.rstrip()\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\n\\t\\tmatrix = []\\n        cols = len(encodedText) // rows\\n        index = 0\\n        for row in range(rows):\\n            temp = []\\n            for col in range(cols):\\n                char = encodedText[index]\\n                temp.append(char)\\n                index += 1\\n            matrix.append(temp)\\n        result = \"\"\\n        \\n        col = 0 # Keeping track of the start after completion of the inner for loop\\n        for _ in range(cols):\\n            r_index, c_index = 0, _\\n            while r_index < rows and c_index < cols:\\n                result += matrix[r_index][c_index]\\n                r_index += 1\\n                c_index += 1\\n            col += 1\\n        return result.rstrip()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690629,
                "title": "python-easy-way",
                "content": "# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        \\n        col = int(len(encodedText) / rows)\\n        lines = [[\\' \\' for _ in range(col)] for _ in range(rows)]\\n        for idx, c in enumerate(encodedText):\\n            lines[idx // col][(idx % col)] = c\\n        \\n        originalText = \"\"\\n\\n        for c in range(col):\\n            begin = c\\n            i = 0\\n            for r in range(rows):\\n                if c+i >= col:\\n                    break\\n\\n                originalText += lines[r][c+i]\\n                i += 1\\n        \\n\\n        return originalText.rstrip()\\n                \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        \\n        col = int(len(encodedText) / rows)\\n        lines = [[\\' \\' for _ in range(col)] for _ in range(rows)]\\n        for idx, c in enumerate(encodedText):\\n            lines[idx // col][(idx % col)] = c\\n        \\n        originalText = \"\"\\n\\n        for c in range(col):\\n            begin = c\\n            i = 0\\n            for r in range(rows):\\n                if c+i >= col:\\n                    break\\n\\n                originalText += lines[r][c+i]\\n                i += 1\\n        \\n\\n        return originalText.rstrip()\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652361,
                "title": "easy-c-clean-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1)\\n            return encodedText;\\n        int l = encodedText.length();\\n        int col = l/rows;\\n        vector<vector<char>> mat(rows, vector<char> (col));\\n        int val = 0;\\n        for(int i = 0 ; i < rows; i++)\\n        {\\n            for(int j = 0 ; j < col ;j++)\\n            {\\n                mat[i][j] = encodedText[val];\\n                val++;\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < col; i++)\\n        {\\n            int row = 0;\\n            int c = i;\\n            while(c < col and row < rows)\\n                ans += mat[row++][c++];\\n        }\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1)\\n            return encodedText;\\n        int l = encodedText.length();\\n        int col = l/rows;\\n        vector<vector<char>> mat(rows, vector<char> (col));\\n        int val = 0;\\n        for(int i = 0 ; i < rows; i++)\\n        {\\n            for(int j = 0 ; j < col ;j++)\\n            {\\n                mat[i][j] = encodedText[val];\\n                val++;\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < col; i++)\\n        {\\n            int row = 0;\\n            int c = i;\\n            while(c < col and row < rows)\\n                ans += mat[row++][c++];\\n        }\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647509,
                "title": "cpp-solution-easy-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619486,
                "title": "java-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        int cols = (len % rows == 0) ? len / rows : (len / rows + 1);\\n\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        int count = 0;\\n        \\n        while (i * cols + (i + count) < len) {\\n            sb.append(encodedText.charAt(i * cols + (i + count)));\\n            count += (i + 1) / rows;\\n            i = (i + 1) % rows;\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        int cols = (len % rows == 0) ? len / rows : (len / rows + 1);\\n\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        int count = 0;\\n        \\n        while (i * cols + (i + count) < len) {\\n            sb.append(encodedText.charAt(i * cols + (i + count)));\\n            count += (i + 1) / rows;\\n            i = (i + 1) % rows;\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616890,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string e, int rows) {\\n        \\n        int c=e.length()/rows;\\n        string ans; \\n        \\n        for(int j=0;j<c;j++)\\n        {  \\n            int rh=0;\\n            int ch=j;\\n            for(int i=0;i<rows;i++)\\n            {\\n                 int z=rh*c+ ch;\\n                ans.push_back(e[z]);\\n                  rh++;\\n                  ch++;\\n                \\n                if(rh>=rows ||ch>=c)\\n                    break;\\n            }       \\n        }   \\n            \\n        for(int i=ans.length()-1;i>=0;i--)\\n        {\\n            if(ans[i]==\\' \\')\\n               ans.pop_back();\\n            else\\n                break;\\n        }\\n                return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string e, int rows) {\\n        \\n        int c=e.length()/rows;\\n        string ans; \\n        \\n        for(int j=0;j<c;j++)\\n        {  \\n            int rh=0;\\n            int ch=j;\\n            for(int i=0;i<rows;i++)\\n            {\\n                 int z=rh*c+ ch;\\n                ans.push_back(e[z]);\\n                  rh++;\\n                  ch++;\\n                \\n                if(rh>=rows ||ch>=c)\\n                    break;\\n            }       \\n        }   \\n            \\n        for(int i=ans.length()-1;i>=0;i--)\\n        {\\n            if(ans[i]==\\' \\')\\n               ans.pop_back();\\n            else\\n                break;\\n        }\\n                return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604545,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        numRows, numCols, res = rows, len(encodedText) // rows, []\\n        for first in range(numCols):\\n            res.append(encodedText[first])\\n            for second in range(first + numCols + 1, numRows * numCols, numCols + 1):\\n                res.append(encodedText[second])\\n        return \\'\\'.join(res).rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        numRows, numCols, res = rows, len(encodedText) // rows, []\\n        for first in range(numCols):\\n            res.append(encodedText[first])\\n            for second in range(first + numCols + 1, numRows * numCols, numCols + 1):\\n                res.append(encodedText[second])\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603496,
                "title": "javascript",
                "content": "```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    let colunm = encodedText.length / rows;\\n    let output = \\'\\';\\n    for (var i = 0; i < colunm; i++) {\\n        output += encodedText[i];\\n        let j = i + colunm + 1;\\n        while(j < encodedText.length) {\\n            output += encodedText[j];\\n            j = j + colunm +1;\\n        }\\n    }\\n    return output.replace(/\\\\s*$/, \\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    let colunm = encodedText.length / rows;\\n    let output = \\'\\';\\n    for (var i = 0; i < colunm; i++) {\\n        output += encodedText[i];\\n        let j = i + colunm + 1;\\n        while(j < encodedText.length) {\\n            output += encodedText[j];\\n            j = j + colunm +1;\\n        }\\n    }\\n    return output.replace(/\\\\s*$/, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2550611,
                "title": "java-two-pointer-approach-optimized-code",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows ;\\n        int m = encodedText.length() ;\\n        StringBuffer originalText = new StringBuffer() ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            originalText.append(encodedText.charAt(i)) ;\\n            for (int j = i+n+1; j < m; j += n+1)\\n                originalText.append(encodedText.charAt(j)) ;\\n        }\\n        int lastIndex = originalText.length()-1 ;\\n        \\n        for (int k = lastIndex; k >= 0; k--)\\n            if (originalText.charAt(k) == \\' \\') lastIndex-- ;\\n            else break ;\\n        \\n        String result = originalText.toString() ;\\n        return result.substring(0, lastIndex+1) ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows ;\\n        int m = encodedText.length() ;\\n        StringBuffer originalText = new StringBuffer() ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            originalText.append(encodedText.charAt(i)) ;\\n            for (int j = i+n+1; j < m; j += n+1)\\n                originalText.append(encodedText.charAt(j)) ;\\n        }\\n        int lastIndex = originalText.length()-1 ;\\n        \\n        for (int k = lastIndex; k >= 0; k--)\\n            if (originalText.charAt(k) == \\' \\') lastIndex-- ;\\n            else break ;\\n        \\n        String result = originalText.toString() ;\\n        return result.substring(0, lastIndex+1) ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510951,
                "title": "python-solution-simple-explanation",
                "content": "res=\"\"\\n\\n        \\n        #find the number of columns for the matrix\\n        col=int(len(encodedText)/rows)\\n        lst= [[0]*col for i in range(rows)] \\n        \\n        \\n        #create matrix and put the characters of the string to its correct location\\n        for i in range(rows):\\n            lst[i]= encodedText[i*col:(i*col)+col]\\n            \\n        \\n        \\n        # retrive the matrix to get original string    \\n        for i in range(col):\\n            for j in range(rows):\\n                if i+j > col-1:\\n                    break\\n                else:\\n                    res=res+lst[j][j+i]\\n\\t\\t\\t\\t\\t\\n\\t\\t#return the decoded string with right trailing space removed\\t\\t\\t\\n        return res.rstrip()",
                "solutionTags": [
                    "String"
                ],
                "code": "res=\"\"\\n\\n        \\n        #find the number of columns for the matrix\\n        col=int(len(encodedText)/rows)\\n        lst= [[0]*col for i in range(rows)] \\n        \\n        \\n        #create matrix and put the characters of the string to its correct location\\n        for i in range(rows):\\n            lst[i]= encodedText[i*col:(i*col)+col]\\n            \\n        \\n        \\n        # retrive the matrix to get original string    \\n        for i in range(col):\\n            for j in range(rows):\\n                if i+j > col-1:\\n                    break\\n                else:\\n                    res=res+lst[j][j+i]\\n\\t\\t\\t\\t\\t\\n\\t\\t#return the decoded string with right trailing space removed\\t\\t\\t\\n        return res.rstrip()",
                "codeTag": "Unknown"
            },
            {
                "id": 2493684,
                "title": "c-solution-simulation",
                "content": "### C++:\\n```\\nclass Solution {\\n    void removeTrailingSpaces(string& str)\\n    {\\n        int end = str.size()-1;\\n\\n        for (int i = str.size()-1; i >= 0; i--)\\n        {\\n            if (str[i] != \\' \\')\\n                break;\\n            else\\n                end--;\\n        }\\n        \\n        str.erase(str.begin()+end+1,str.end());\\n    }\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if (encodedText.empty())\\n            return \"\";\\n        \\n        int columns = encodedText.size() / rows;\\n        \\n        vector<vector<char>> matrix(rows, vector<char>(columns));\\n        \\n        int encodedIndex = 0;\\n        for (int i = 0; i < rows; i++)\\n        {\\n            for (int j = 0; j < columns; j++)\\n            {\\n                if (encodedIndex < encodedText.size())\\n                    matrix[i][j] = encodedText[encodedIndex++];\\n            }\\n        }\\n        \\n        string res;\\n        int i = 0, j = 0;\\n        int orgJ = 0;\\n        \\n        while (true)\\n        {\\n            res.push_back(matrix[i][j]);\\n            \\n            if (i+1 == rows or j+1 == columns)\\n            {\\n                if (orgJ == columns-1)\\n                    break;\\n                \\n                i = 0;\\n                j = ++orgJ;\\n            }\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        \\n        removeTrailingSpaces(res);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void removeTrailingSpaces(string& str)\\n    {\\n        int end = str.size()-1;\\n\\n        for (int i = str.size()-1; i >= 0; i--)\\n        {\\n            if (str[i] != \\' \\')\\n                break;\\n            else\\n                end--;\\n        }\\n        \\n        str.erase(str.begin()+end+1,str.end());\\n    }\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if (encodedText.empty())\\n            return \"\";\\n        \\n        int columns = encodedText.size() / rows;\\n        \\n        vector<vector<char>> matrix(rows, vector<char>(columns));\\n        \\n        int encodedIndex = 0;\\n        for (int i = 0; i < rows; i++)\\n        {\\n            for (int j = 0; j < columns; j++)\\n            {\\n                if (encodedIndex < encodedText.size())\\n                    matrix[i][j] = encodedText[encodedIndex++];\\n            }\\n        }\\n        \\n        string res;\\n        int i = 0, j = 0;\\n        int orgJ = 0;\\n        \\n        while (true)\\n        {\\n            res.push_back(matrix[i][j]);\\n            \\n            if (i+1 == rows or j+1 == columns)\\n            {\\n                if (orgJ == columns-1)\\n                    break;\\n                \\n                i = 0;\\n                j = ++orgJ;\\n            }\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        \\n        removeTrailingSpaces(res);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490448,
                "title": "python-3-straightforward",
                "content": "\\tclass Solution:\\n\\t\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\t\\t\\tres=[]\\n\\t\\t\\tsize=len(encodedText)//rows\\n\\t\\t\\tfor i in range(size):\\n\\t\\t\\t\\tfor k in range(i,len(encodedText),size+1):\\n\\t\\t\\t\\t\\tres.append(encodedText[k])\\n\\t\\t\\treturn \\'\\'.join(res).rstrip()",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\t\\t\\tres=[]\\n\\t\\t\\tsize=len(encodedText)//rows\\n\\t\\t\\tfor i in range(size):\\n\\t\\t\\t\\tfor k in range(i,len(encodedText),size+1):\\n\\t\\t\\t\\t\\tres.append(encodedText[k])\\n\\t\\t\\treturn \\'\\'.join(res).rstrip()",
                "codeTag": "Java"
            },
            {
                "id": 2484168,
                "title": "leap-numberofcolumns-1",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring decodeCiphertext(string str, int rows) {\\n\\t\\t\\tint c=str.length()/rows;\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tfor(int i=0;i<c;i++){\\n\\t\\t\\t\\tfor(int j=i;j<str.length();j+=c+1){\\n\\t\\t\\t\\t\\tres+=str[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint n=res.length()-1;\\n\\t\\t\\twhile(n>=0&&res[n]==\\' \\') n--;\\n\\t\\t\\tres=res.substr(0,n+1);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring decodeCiphertext(string str, int rows) {\\n\\t\\t\\tint c=str.length()/rows;\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tfor(int i=0;i<c;i++){\\n\\t\\t\\t\\tfor(int j=i;j<str.length();j+=c+1){\\n\\t\\t\\t\\t\\tres+=str[j];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2449161,
                "title": "java-easy-implementation",
                "content": "```\\n   class Solution {\\n        public String decodeCiphertext(String encodedText, int rows) {\\n\\n            int col = encodedText.length() / rows;\\n            char[][] mat = new char[rows][col];\\n            for (char[] c : mat) Arrays.fill(c, \\' \\');\\n            \\n            int r = 0, c = 0;\\n            for (int i = 0; i < encodedText.length(); i++) {\\n                if (c >= col) {\\n                    c = 0;\\n                    ++r;\\n                }\\n                \\n                mat[r][c++] = encodedText.charAt(i);\\n            }\\n\\n            StringBuilder sb = new StringBuilder();\\n            int p, q;\\n            int ind = 0;\\n            while (ind < col) {\\n                p = 0;\\n                q = ind;\\n\\n                // keep mv diagonally down\\n                while (p < rows && q < col) sb.append(mat[p++][q++]);\\n                ind++;\\n            }\\n\\n            return sb.toString().replaceFirst(\"\\\\\\\\s++$\", \"\");\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   class Solution {\\n        public String decodeCiphertext(String encodedText, int rows) {\\n\\n            int col = encodedText.length() / rows;\\n            char[][] mat = new char[rows][col];\\n            for (char[] c : mat) Arrays.fill(c, \\' \\');\\n            \\n            int r = 0, c = 0;\\n            for (int i = 0; i < encodedText.length(); i++) {\\n                if (c >= col) {\\n                    c = 0;\\n                    ++r;\\n                }\\n                \\n                mat[r][c++] = encodedText.charAt(i);\\n            }\\n\\n            StringBuilder sb = new StringBuilder();\\n            int p, q;\\n            int ind = 0;\\n            while (ind < col) {\\n                p = 0;\\n                q = ind;\\n\\n                // keep mv diagonally down\\n                while (p < rows && q < col) sb.append(mat[p++][q++]);\\n                ind++;\\n            }\\n\\n            return sb.toString().replaceFirst(\"\\\\\\\\s++$\", \"\");\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366242,
                "title": "python-simple-solution-and-a-bonus-one-liner-solution",
                "content": "- Simple solution:\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        cols = n // rows\\n        step = cols + 1\\n        res = \"\"\\n        \\n        for i in range(cols):\\n            for j in range(i, n, step):\\n                res += encodedText[j]\\n            \\n        return res.rstrip()\\n```\\n\\n- Looking at the previous solution, we can see that it can be transformed into a one-liner:\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n         return \"\".join(encodedText[j] for i in range(len(encodedText) // rows) for j in range(i, len(encodedText), len(encodedText) // rows + 1)).rstrip()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        cols = n // rows\\n        step = cols + 1\\n        res = \"\"\\n        \\n        for i in range(cols):\\n            for j in range(i, n, step):\\n                res += encodedText[j]\\n            \\n        return res.rstrip()\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n         return \"\".join(encodedText[j] for i in range(len(encodedText) // rows) for j in range(i, len(encodedText), len(encodedText) // rows + 1)).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336258,
                "title": "simple",
                "content": "![image](https://assets.leetcode.com/users/images/c2fdab4a-2b0d-4d75-8362-e67029591305_1658843882.4257522.png)\\n\\nDeletion of trailing spaces:\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/edf9dee2-654a-4ece-9656-8fd61f219ef1_1658850236.0707505.png)\\n\\n<br>\\n\\n```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out{};\\n\\tfor(int j{}, w(size(e)/r); j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); out.push_back(e[i*(w+1)+j]));\\t\\t\\t\\n\\treturn {begin(out), begin(out)+1+out.find_last_not_of(\\' \\')};\\n}\\n```\\n||\\n```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out;\\n\\tint w(size(e)/r), end{};\\n\\tfor(int j{}; j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); ++i)\\n\\t\\t{\\n\\t\\t\\tint x=i*(w+1)+j;\\n\\t\\t\\tout.push_back(e[x]);\\n\\t\\t\\tif(e[x]!=\\' \\') end=size(out);\\n\\t\\t}\\n\\treturn {begin(out), begin(out)+end};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out{};\\n\\tfor(int j{}, w(size(e)/r); j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); out.push_back(e[i*(w+1)+j]));\\t\\t\\t\\n\\treturn {begin(out), begin(out)+1+out.find_last_not_of(\\' \\')};\\n}\\n```\n```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out;\\n\\tint w(size(e)/r), end{};\\n\\tfor(int j{}; j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); ++i)\\n\\t\\t{\\n\\t\\t\\tint x=i*(w+1)+j;\\n\\t\\t\\tout.push_back(e[x]);\\n\\t\\t\\tif(e[x]!=\\' \\') end=size(out);\\n\\t\\t}\\n\\treturn {begin(out), begin(out)+end};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2251018,
                "title": "simple-python-solution-7-lines-of-code-only",
                "content": "1. Notice that the next letter is always ```cols+1``` away from the current letter.\\n2. Once we reach the end of ```encodedText```, we continue from the next column in the first row.\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        results = []\\n        for i in range(cols):\\n            while i < len(encodedText):\\n                results.append(encodedText[i])\\n                i += cols + 1\\n            \\n        return \\'\\'.join(results).rstrip()\\n```",
                "solutionTags": [],
                "code": "```cols+1```\n```encodedText```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        results = []\\n        for i in range(cols):\\n            while i < len(encodedText):\\n                results.append(encodedText[i])\\n                i += cols + 1\\n            \\n        return \\'\\'.join(results).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226175,
                "title": "iterative-solution-no-extra-space-c",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    \\n    string decodeCiphertext(string eT, int r) {\\n        int len = eT.length();\\n        if(len == 0) return eT;\\n        if(r == 1) return eT;\\n        string ans;\\n        int c = len/r;\\n        int i=0,u=0;\\n        while(i != c-1){\\n            int l = ans.length()-1;\\n            ans += eT[i];\\n            i += c+1;\\n            if(i>=len) i = ++u;\\n        }\\n        ans += eT[i];\\n        while(ans[ans.size() - 1] == \\' \\')  ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string decodeCiphertext(string eT, int r) {\\n        int len = eT.length();\\n        if(len == 0) return eT;\\n        if(r == 1) return eT;\\n        string ans;\\n        int c = len/r;\\n        int i=0,u=0;\\n        while(i != c-1){\\n            int l = ans.length()-1;\\n            ans += eT[i];\\n            i += c+1;\\n            if(i>=len) i = ++u;\\n        }\\n        ans += eT[i];\\n        while(ans[ans.size() - 1] == \\' \\')  ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190758,
                "title": "python-compute-the-index-one-pass-easy-to-understand",
                "content": "The logic is to find the number of columns based on the length of encodedText. The floor or integer divison is helpful here. \\n\\nI compute the index of row and column of imaginary matrix (no need to build the matrix). Then compute the corresponding index in the encodedText. We traverse the diagonal to reach end of current diagonal. That means the r (row_index) has reached to last row (rows - 1). Then increase the curr_diag (current diagnoal index) and continue from the top row again with the col starting at curr_diag. \\n\\n\\t\\n\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows==1:\\n            return encodedText\\n        \\n        num_col = len(encodedText) // rows\\n        ans = []\\n        r, c, curr_diag = 0, 0, 0\\n        \\n        while curr_diag < num_col:\\n            idx = r * num_col + c\\n            # we reached the right top position in the matrix\\n            if idx >= len(encodedText):\\n                break\\n            ans.append(encodedText[idx])\\n            if r == rows - 1:\\n                curr_diag += 1\\n                r = 0\\n                c = curr_diag\\n            else:\\n                r += 1\\n                c += 1\\n        \\n        return \\'\\'.join(ans).rstrip()\\n    \\nI thinkg the time complexity is linear O(N) where N is the len(encodedText) and Space complexity is O(M) where M is the length of the decoded message since I have to create the string in the end. Otherwise, during the computation, I only have few pointers and I need O(1) space for them.\\t\\n\\nPlease share your suggestions on how to improve the solution.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The logic is to find the number of columns based on the length of encodedText. The floor or integer divison is helpful here. \\n\\nI compute the index of row and column of imaginary matrix (no need to build the matrix). Then compute the corresponding index in the encodedText. We traverse the diagonal to reach end of current diagonal. That means the r (row_index) has reached to last row (rows - 1). Then increase the curr_diag (current diagnoal index) and continue from the top row again with the col starting at curr_diag. \\n\\n\\t\\n\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows==1:\\n            return encodedText\\n        \\n        num_col = len(encodedText) // rows\\n        ans = []\\n        r, c, curr_diag = 0, 0, 0\\n        \\n        while curr_diag < num_col:\\n            idx = r * num_col + c\\n            # we reached the right top position in the matrix\\n            if idx >= len(encodedText):\\n                break\\n            ans.append(encodedText[idx])\\n            if r == rows - 1:\\n                curr_diag += 1\\n                r = 0\\n                c = curr_diag\\n            else:\\n                r += 1\\n                c += 1\\n        \\n        return \\'\\'.join(ans).rstrip()\\n    \\nI thinkg the time complexity is linear O(N) where N is the len(encodedText) and Space complexity is O(M) where M is the length of the decoded message since I have to create the string in the end. Otherwise, during the computation, I only have few pointers and I need O(1) space for them.\\t\\n\\nPlease share your suggestions on how to improve the solution.",
                "codeTag": "Python3"
            },
            {
                "id": 2159521,
                "title": "step-by-step-approach-easyy-intuitive-thinking",
                "content": "```\\n string decodeCiphertext(string encode, int rows) {\\n        \\n        if(encode.empty())  //if encode kuch hai hi nahi\\n            return \"\";\\n        \\n        int k=0,cols=encode.size()/rows;    //  cols= total_size/rows  (SIMPLE)\\n        vector<vector<char>> arr(rows,vector<char> (cols,\\' \\'));\\n        \\n        //step 1 Fill the code in the matrix\\n        \\n        for(int i=0;i<rows;i++)\\n           for(int j=0;j<cols;j++)\\n                arr[i][j]=encode[k++];\\n         \\n        //Step 2 Decode the code through diagonal traversal\\n        \\n        string ans=\"\";\\n        for(int k=0;k<cols;k++)\\n        {\\n            int i=0,j=k;\\n            while(i<rows and j<cols)\\n                ans+=arr[i++][j++];\\n        }\\n        \\n        //Step 3 Removing trailing whitespaces from answer\\n        int idx=ans.size()-1;\\n        while(ans[idx]==\\' \\')\\n            idx--;\\n        \\n        return ans.substr(0,idx+1);\\n    }",
                "solutionTags": [],
                "code": "```\\n string decodeCiphertext(string encode, int rows) {\\n        \\n        if(encode.empty())  //if encode kuch hai hi nahi\\n            return \"\";\\n        \\n        int k=0,cols=encode.size()/rows;    //  cols= total_size/rows  (SIMPLE)\\n        vector<vector<char>> arr(rows,vector<char> (cols,\\' \\'));\\n        \\n        //step 1 Fill the code in the matrix\\n        \\n        for(int i=0;i<rows;i++)\\n           for(int j=0;j<cols;j++)\\n                arr[i][j]=encode[k++];\\n         \\n        //Step 2 Decode the code through diagonal traversal\\n        \\n        string ans=\"\";\\n        for(int k=0;k<cols;k++)\\n        {\\n            int i=0,j=k;\\n            while(i<rows and j<cols)\\n                ans+=arr[i++][j++];\\n        }\\n        \\n        //Step 3 Removing trailing whitespaces from answer\\n        int idx=ans.size()-1;\\n        while(ans[idx]==\\' \\')\\n            idx--;\\n        \\n        return ans.substr(0,idx+1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2065097,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n       string res; \\n       if (!rows ||!encodedText.size()) return res;\\n       int col = encodedText.size()/rows;    \\n       int step = 0, x = 0, y = 0;\\n       while(step < col) { \\n            res += encodedText[y*col+x];             \\n            x++; y++; \\n            if (y >= rows || x >= col) { y = 0; x = ++step; }   \\n       } \\n       while(res.back()==\\' \\') res.resize(res.size()-1); \\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n       string res; \\n       if (!rows ||!encodedText.size()) return res;\\n       int col = encodedText.size()/rows;    \\n       int step = 0, x = 0, y = 0;\\n       while(step < col) { \\n            res += encodedText[y*col+x];             \\n            x++; y++; \\n            if (y >= rows || x >= col) { y = 0; x = ++step; }   \\n       } \\n       while(res.back()==\\' \\') res.resize(res.size()-1); \\n       return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045726,
                "title": "python-solution-clean-code",
                "content": "```\\nclass Solution:\\n\\tdef decodeCiphertext(self, e: str, r: int) -> str:\\n        n = len(e)\\n        it = (n // r) + 1\\n        ans = \"\"\\n        if r == 1:\\n            return e\\n        for i in range(it - 1):\\n            ans += e[i:n:it]\\n        return ans.rstrip(\" \")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef decodeCiphertext(self, e: str, r: int) -> str:\\n        n = len(e)\\n        it = (n // r) + 1\\n        ans = \"\"\\n        if r == 1:\\n            return e\\n        for i in range(it - 1):\\n            ans += e[i:n:it]\\n        return ans.rstrip(\" \")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031681,
                "title": "calculate-columns-and-jump-column-1-java",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows==1||encodedText.length()==0){\\n            return encodedText;\\n        }\\n        int col=encodedText.length()/rows;\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<col;i++){\\n            int k=i;\\n            for(int j=0;j<rows&&k<encodedText.length();j++){\\n            ans.append(encodedText.charAt(k));\\n            k+=col+1;\\n            }\\n        }\\n        \\n        int j=ans.length()-1;\\n        while(ans.charAt(j)==\\' \\'){\\n                j--;\\n        }\\n        return ans.substring(0,j+1);\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows==1||encodedText.length()==0){\\n            return encodedText;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1976128,
                "title": "python-solution-by-building-the-grid",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        ans = [\"\"] * n\\n        cols = n//rows\\n        \\n        grid = [[\" \"] * cols for _ in range(rows)]\\n        k = 0\\n        for i, j in product(range(rows), range(cols)):\\n            grid[i][j] = encodedText[k]\\n            k += 1\\n        i, j = 0, 0\\n        l = 0\\n        t = 0\\n        while i < rows and j < cols:\\n            ans[l] = grid[i][j]\\n            i += 1\\n            j += 1\\n            l += 1\\n            if i >= rows:\\n                t += 1\\n                i = 0\\n                j = t\\n            if j >= cols:\\n                break\\n        \\n        finalAns = (\\'\\'.join(ans)).rstrip()\\n        return finalAns\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        ans = [\"\"] * n\\n        cols = n//rows\\n        \\n        grid = [[\" \"] * cols for _ in range(rows)]\\n        k = 0\\n        for i, j in product(range(rows), range(cols)):\\n            grid[i][j] = encodedText[k]\\n            k += 1\\n        i, j = 0, 0\\n        l = 0\\n        t = 0\\n        while i < rows and j < cols:\\n            ans[l] = grid[i][j]\\n            i += 1\\n            j += 1\\n            l += 1\\n            if i >= rows:\\n                t += 1\\n                i = 0\\n                j = t\\n            if j >= cols:\\n                break\\n        \\n        finalAns = (\\'\\'.join(ans)).rstrip()\\n        return finalAns\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951361,
                "title": "python-solution-with-anti-diag-property",
                "content": "Important property of 2D matrix:\\n1. a constant value for the **sum** of diag element index: **i+j**\\n2. a constant value for the **difference** of anti_diag element index: **i-j**\\nNote that all of cells are empty in lower-triangle, so we will consider **j-i** only\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, txt: str, r: int) -> str:\\n        c = len(txt)//r\\n        res = [[] for _ in range(max(r,c))]\\n        for k in range(len(txt)):\\n            i, j = k//c, k%c\\n            res[j-i].append(txt[k])\\n        res = [\\'\\'.join(l) for l in res]\\n        return \\'\\'.join(res).rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, txt: str, r: int) -> str:\\n        c = len(txt)//r\\n        res = [[] for _ in range(max(r,c))]\\n        for k in range(len(txt)):\\n            i, j = k//c, k%c\\n            res[j-i].append(txt[k])\\n        res = [\\'\\'.join(l) for l in res]\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951081,
                "title": "python-short-and-fast-faster-than-95-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/65d90c3c-bea1-4128-990a-3d8e6119ed1c_1650056602.9725244.png)\\n\\'v\\' is the number of slanted lines needed in the cipher table. The algorithm basically is to read along a sloping line and jump a gap and turn to the next one.\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        l = n//rows\\n        v= l-(rows-1)\\n        ans = \\'\\'\\n        r,i=0,0\\n        while r<v+1:\\n            if i<n:\\n                ans+=encodedText[i]\\n                i+=(l+1)\\n            else:\\n                r+=1;i=r\\n        return ans.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        l = n//rows\\n        v= l-(rows-1)\\n        ans = \\'\\'\\n        r,i=0,0\\n        while r<v+1:\\n            if i<n:\\n                ans+=encodedText[i]\\n                i+=(l+1)\\n            else:\\n                r+=1;i=r\\n        return ans.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946110,
                "title": "c-95-faster-no-extra-space-no-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1) return encodedText;\\n        if(encodedText.size()<=1) return encodedText;\\n        string s;\\n        int size = encodedText.length();\\n        int len = size/rows;\\n        for(int i = 0 ; i < len ; i++){\\n            for(int j = 0; j < min(len-i , rows) ; j++){\\n                s += encodedText[i+(len+1)*j];\\n            }\\n        }\\n\\t\\t// to remove extra spaces in the back\\n        size = s.length();\\n        while(s[size-1] == \\' \\')size--;\\n        s = s.substr(0,size);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1) return encodedText;\\n        if(encodedText.size()<=1) return encodedText;\\n        string s;\\n        int size = encodedText.length();\\n        int len = size/rows;\\n        for(int i = 0 ; i < len ; i++){\\n            for(int j = 0; j < min(len-i , rows) ; j++){\\n                s += encodedText[i+(len+1)*j];\\n            }\\n        }\\n\\t\\t// to remove extra spaces in the back\\n        size = s.length();\\n        while(s[size-1] == \\' \\')size--;\\n        s = s.substr(0,size);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944085,
                "title": "easy-solution-by-preparing-and-traversing-matrix-in-c",
                "content": "```\\npublic class Solution {\\n    public string DecodeCiphertext(string str, int row) {\\n        if(row == 1) return str;\\n        \\n        int k = 0;\\n        int col = str.Length/row;\\n        char[][] matrix = new char[row][];\\n        for(int i =0;i<row;++i)\\n        {\\n            matrix[i] = new char[col];\\n        }\\n        \\n        for(int i = 0; i<row;++i)\\n        {\\n            for(int j = 0; j<col;j++)\\n            {\\n                matrix[i][j] = str[k++];\\n            }\\n        }\\n        \\n        var sb = new StringBuilder();\\n        for(int i = 0; i<col;++i)\\n        {\\n            for(int j = 0; j<row && i+j < col;j++)\\n            {\\n                var ch = matrix[j][i+j];\\n                sb.Append(ch);\\n            }\\n        }\\n        \\n        return sb.ToString().TrimEnd(\\' \\');\\n    }\\n}",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\n    public string DecodeCiphertext(string str, int row) {\\n        if(row == 1) return str;\\n        \\n        int k = 0;\\n        int col = str.Length/row;\\n        char[][] matrix = new char[row][];\\n        for(int i =0;i<row;++i)\\n        {\\n            matrix[i] = new char[col];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1930015,
                "title": "c-easy-to-understand-simple-logic-diagonal-traversal",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void solve(string encodedText,string& ans,int row,int m)\\n    {\\n        \\n       for(int j=0;j<m;j++)\\n       {\\n           int r=0;\\n           int c=j;\\n           while(r<row && c<m)\\n           {\\n               ans+=encodedText[r*m+c];\\n               r++;\\n               c++;\\n           }\\n       }\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string ans=\"\";\\n        int n=encodedText.length();\\n        int m=n/rows; //no of column\\n      \\n        \\n        solve(encodedText,ans,rows,m);\\n        \\n        while(ans.length()>=1 && ans[ans.length()-1]==\\' \\') //if trailing spaces \\' \\'\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void solve(string encodedText,string& ans,int row,int m)\\n    {\\n        \\n       for(int j=0;j<m;j++)\\n       {\\n           int r=0;\\n           int c=j;\\n           while(r<row && c<m)\\n           {\\n               ans+=encodedText[r*m+c];\\n               r++;\\n               c++;\\n           }\\n       }\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string ans=\"\";\\n        int n=encodedText.length();\\n        int m=n/rows; //no of column\\n      \\n        \\n        solve(encodedText,ans,rows,m);\\n        \\n        while(ans.length()>=1 && ans[ans.length()-1]==\\' \\') //if trailing spaces \\' \\'\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879453,
                "title": "java-simple-two-approach",
                "content": "1st\\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        char[][] ch = new char[rows][encodedText.length()/rows];\\n        int index = 0;\\n        for(int i=0;i<ch.length;i++){\\n            for(int j=0;j<ch[0].length;j++){\\n                ch[i][j]= encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int gap =0;gap<ch[0].length;gap++){\\n            for(int i=0,j=gap;i<rows && j<encodedText.length()/rows;i++,j++){\\n                sb.append(ch[i][j]);\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n2nd \\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows == 1 || encodedText.length() == 0){\\n            return encodedText;\\n        }\\n        int cur = 0;\\n        int start = 0;\\n        int inc = encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        while(start<inc){\\n            sb.append(encodedText.charAt(cur));\\n            cur+=inc;\\n            if(cur>=encodedText.length()){\\n                cur = ++start;\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        char[][] ch = new char[rows][encodedText.length()/rows];\\n        int index = 0;\\n        for(int i=0;i<ch.length;i++){\\n            for(int j=0;j<ch[0].length;j++){\\n                ch[i][j]= encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int gap =0;gap<ch[0].length;gap++){\\n            for(int i=0,j=gap;i<rows && j<encodedText.length()/rows;i++,j++){\\n                sb.append(ch[i][j]);\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows == 1 || encodedText.length() == 0){\\n            return encodedText;\\n        }\\n        int cur = 0;\\n        int start = 0;\\n        int inc = encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        while(start<inc){\\n            sb.append(encodedText.charAt(cur));\\n            cur+=inc;\\n            if(cur>=encodedText.length()){\\n                cur = ++start;\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842300,
                "title": "python3-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        res=[]\\n        cols=len(encodedText)//rows\\n        for j in range(cols):\\n            idx=j\\n            while idx<len(encodedText):\\n                res.append(encodedText[idx])\\n                idx+=cols+1\\n        return \\'\\'.join(res).rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        res=[]\\n        cols=len(encodedText)//rows\\n        for j in range(cols):\\n            idx=j\\n            while idx<len(encodedText):\\n                res.append(encodedText[idx])\\n                idx+=cols+1\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798577,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int row) {\\n        string str = \"\";\\n        if(encodedText==\"\")\\n            return str;\\n        if(row == 1)\\n            return encodedText;\\n        int col = encodedText.size()/row;\\n        \\n        vector<char>mat[row];\\n       \\n        for(int k = 0;k<encodedText.size();k++){\\n            int x = floor(k/col);\\n            mat[x].push_back(encodedText[k]);\\n        }\\n        \\n        string res = \"\";\\n        for(int i = 0;i<= mat[0].size();i++){\\n            int j = 0,k = i;\\n            while(j<row && k<col){\\n                res.push_back(mat[j][k]);\\n                j++;\\n                k++;\\n            }\\n        }\\n        int j = res.size()-1;\\n        while(res[j] == \\' \\')\\n            j--;\\n        res = res.substr(0,j+1);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int row) {\\n        string str = \"\";\\n        if(encodedText==\"\")\\n            return str;\\n        if(row == 1)\\n            return encodedText;\\n        int col = encodedText.size()/row;\\n        \\n        vector<char>mat[row];\\n       \\n        for(int k = 0;k<encodedText.size();k++){\\n            int x = floor(k/col);\\n            mat[x].push_back(encodedText[k]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1779780,
                "title": "java-recursive",
                "content": "```\\nclass Solution {\\n    private static int ROWS, COLS;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        ROWS = rows;\\n        COLS = encodedText.length()/rows;\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int c = 0; c < COLS; c++){\\n            diag(encodedText, 0, c, res);\\n        }\\n        int l = res.length()-1;\\n        while(l>=0){\\n            if(res.charAt(l)!=\\' \\') break;\\n            l--;\\n        }\\n        res.setLength(l+1);\\n        return res.toString();\\n    }\\n    \\n    private void diag(String enc, int r, int c, StringBuilder res){\\n        \\n        if(r>=ROWS || c>=COLS) return;\\n        \\n        int pos = r*COLS + c;\\n        \\n        res.append(enc.charAt(pos));\\n        diag(enc, ++r, ++c, res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static int ROWS, COLS;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        ROWS = rows;\\n        COLS = encodedText.length()/rows;\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int c = 0; c < COLS; c++){\\n            diag(encodedText, 0, c, res);\\n        }\\n        int l = res.length()-1;\\n        while(l>=0){\\n            if(res.charAt(l)!=\\' \\') break;\\n            l--;\\n        }\\n        res.setLength(l+1);\\n        return res.toString();\\n    }\\n    \\n    private void diag(String enc, int r, int c, StringBuilder res){\\n        \\n        if(r>=ROWS || c>=COLS) return;\\n        \\n        int pos = r*COLS + c;\\n        \\n        res.append(enc.charAt(pos));\\n        diag(enc, ++r, ++c, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757057,
                "title": "simple",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(encodedText.length() == 0 || rows < 2) return encodedText;\\n        \\n        int cols = encodedText.length() / rows;\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        int row = 0;\\n        for(int x = 1; x <= rows; x++) {\\n            map.put(x, row);\\n            row = 1 + row + cols;\\n        }\\n        \\n        final StringBuilder sb = new StringBuilder();\\n        while(map.size() > 0) {\\n            for(int key = 1 ; key <= rows ; key++) {\\n                if(map.containsKey(key)) {\\n                    int idx = map.get(key);\\n                    if(idx < encodedText.length()) sb.append(encodedText.charAt(idx));\\n\\n                    if((idx + 1) % cols== 0) {\\n                        map.remove(key);\\n                    } else {\\n                        map.put(key, idx + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(sb.charAt(sb.length() -1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() -1);\\n        }\\n        \\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(encodedText.length() == 0 || rows < 2) return encodedText;\\n        \\n        int cols = encodedText.length() / rows;\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        int row = 0;\\n        for(int x = 1; x <= rows; x++) {\\n            map.put(x, row);\\n            row = 1 + row + cols;\\n        }\\n        \\n        final StringBuilder sb = new StringBuilder();\\n        while(map.size() > 0) {\\n            for(int key = 1 ; key <= rows ; key++) {\\n                if(map.containsKey(key)) {\\n                    int idx = map.get(key);\\n                    if(idx < encodedText.length()) sb.append(encodedText.charAt(idx));\\n\\n                    if((idx + 1) % cols== 0) {\\n                        map.remove(key);\\n                    } else {\\n                        map.put(key, idx + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(sb.charAt(sb.length() -1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() -1);\\n        }\\n        \\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740992,
                "title": "time-memory-o-n-construct-matrix-and-read-diagonally",
                "content": "### Idea\\n\\nConstruct a matrix for decoding, and read the matrix diagonally from `[0, 0]`.\\n\\n### Complexity\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\nwhere `n = encodedText.length`\\n\\n```typescript\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    const m = rows\\n    const n = encodedText.length / m\\n    const mat = [...Array(m)].map(() => [])\\n    for (let i=0; i<encodedText.length; i+=1) {\\n        mat[Math.floor(i / n)].push(encodedText[i])\\n    }\\n    let text = \"\"\\n    for (let x=0; x<=mat[0].length; x+=1) {\\n        for (let i=0; i<Math.min(m, n-x); i+=1) {\\n            text += mat[i][x+i]\\n        }\\n    }\\n    return text.trimEnd()\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    const m = rows\\n    const n = encodedText.length / m\\n    const mat = [...Array(m)].map(() => [])\\n    for (let i=0; i<encodedText.length; i+=1) {\\n        mat[Math.floor(i / n)].push(encodedText[i])\\n    }\\n    let text = \"\"\\n    for (let x=0; x<=mat[0].length; x+=1) {\\n        for (let i=0; i<Math.min(m, n-x); i+=1) {\\n            text += mat[i][x+i]\\n        }\\n    }\\n    return text.trimEnd()\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1736145,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int encodedLength =  encodedText.length();\\n        \\n        int cols = encodedLength/rows;\\n        \\n       StringBuilder res= new StringBuilder();\\n        \\n        \\n        for(int j=0; j<cols; j++) {\\n            int k = j;\\n            for(int i=0; i<rows; i++) {\\n                if(cols*i+k < encodedLength) {\\n                  res.append(encodedText.charAt(cols*i+k));\\n                  k++;\\n                }\\n            }\\n        }\\n        \\n        return res.toString().stripTrailing();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int encodedLength =  encodedText.length();\\n        \\n        int cols = encodedLength/rows;\\n        \\n       StringBuilder res= new StringBuilder();\\n        \\n        \\n        for(int j=0; j<cols; j++) {\\n            int k = j;\\n            for(int i=0; i<rows; i++) {\\n                if(cols*i+k < encodedLength) {\\n                  res.append(encodedText.charAt(cols*i+k));\\n                  k++;\\n                }\\n            }\\n        }\\n        \\n        return res.toString().stripTrailing();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726703,
                "title": "2075-decode-the-slanted-ciphertext-beats-98",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(encodedText.length()==0)\\n            return \"\";\\n        string ans=\"\";\\n        \\n        int i=0;\\n        int j=0;\\n        int cols=encodedText.length()/rows;\\n        int k=0;\\n        while(i<rows && j<cols && k<cols)\\n        {\\n            ans+=encodedText[i++*cols+k++]; \\n            if(i==rows)\\n            {\\n                j++;\\n                k=j;\\n                i=0;\\n            }\\n        }\\n        \\n        while(ans[ans.length()-1]==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(encodedText.length()==0)\\n            return \"\";\\n        string ans=\"\";\\n        \\n        int i=0;\\n        int j=0;\\n        int cols=encodedText.length()/rows;\\n        int k=0;\\n        while(i<rows && j<cols && k<cols)\\n        {\\n            ans+=encodedText[i++*cols+k++]; \\n            if(i==rows)\\n            {\\n                j++;\\n                k=j;\\n                i=0;\\n            }\\n        }\\n        \\n        while(ans[ans.length()-1]==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700561,
                "title": "simple-diagonal-traversal",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        m, n = rows, len(encodedText) // rows\\n        op = \"\"\\n        for i in range(n):\\n            for j in range(m):\\n                if i + j < n:\\n                    op += encodedText[(n + 1) * j + i]\\n        return op.rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        m, n = rows, len(encodedText) // rows\\n        op = \"\"\\n        for i in range(n):\\n            for j in range(m):\\n                if i + j < n:\\n                    op += encodedText[(n + 1) * j + i]\\n        return op.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682307,
                "title": "javascript-code",
                "content": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText == \"\"){\\n        return \"\";\\n    }\\n    var result = [];\\n    var output = \"\";\\n    var data = encodedText.split(\\'\\');\\n    var col = Math.floor(data.length /rows);\\n    \\n    for(let i = 0; i< data.length; i++){\\n        if(i%col == 0){\\n            result.push([]);\\n        }\\n        result[parseInt(i/col)].push(data[i]);\\n    }\\n    \\n    for(let colum = 0; colum < result[0].length; colum++){\\n        let rowNum = 0;\\n        let colNum = colum;\\n        output = output + result[rowNum][colum];\\n        \\n        while(rowNum + 1 <= result.length - 1 && colNum + 1 <= result[0].length - 1){\\n            output = output + result[rowNum + 1][colNum + 1];\\n            rowNum++;\\n            colNum++;\\n        }\\n    }\\n    return output.trimEnd();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText == \"\"){\\n        return \"\";\\n    }\\n    var result = [];\\n    var output = \"\";\\n    var data = encodedText.split(\\'\\');\\n    var col = Math.floor(data.length /rows);\\n    \\n    for(let i = 0; i< data.length; i++){\\n        if(i%col == 0){\\n            result.push([]);\\n        }\\n        result[parseInt(i/col)].push(data[i]);\\n    }\\n    \\n    for(let colum = 0; colum < result[0].length; colum++){\\n        let rowNum = 0;\\n        let colNum = colum;\\n        output = output + result[rowNum][colum];\\n        \\n        while(rowNum + 1 <= result.length - 1 && colNum + 1 <= result[0].length - 1){\\n            output = output + result[rowNum + 1][colNum + 1];\\n            rowNum++;\\n            colNum++;\\n        }\\n    }\\n    return output.trimEnd();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1669760,
                "title": "dfs-java",
                "content": "```\\n\\n        StringBuilder sb;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        \\n        if(rows==1) return encodedText ; \\n        \\n        //1000 \\n        \\n        //constructing the grid  O(n*n)\\n        \\n        //traversing and creating the string O(n*n)\\n        \\n        int col = encodedText.length()/rows; \\n        \\n        \\n        char[][] grid = new char[rows][col];\\n        \\n        int k = 0 ; \\n        \\n        for(int i=0 ;i<rows ; i++){\\n            \\n            for(int j=0 ; j<col ; j++){\\n                \\n                grid[i][j] = encodedText.charAt(k); \\n                \\n                k++;\\n                \\n            }\\n        }\\n        \\n        \\n        sb = new StringBuilder(); \\n        \\n        for(int i=0 ; i<col ; i++){\\n            \\n            dfs(0,i,grid);\\n            \\n        }\\n         \\n        \\n       String regex = \"\\\\\\\\s+$\";\\n        \\n       return sb.toString().replaceAll(regex,\"\");\\n    }\\n    \\n    void dfs(int i , int j, char[][] grid){\\n        \\n        if(i<0 || i>grid.length-1 || j<0 || j>grid[0].length-1) return ;\\n        \\n        sb.append(grid[i][j]);\\n        \\n        dfs(i+1,j+1,grid);\\n        \\n        return ;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n        StringBuilder sb;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        \\n        if(rows==1) return encodedText ; \\n        \\n        //1000 \\n        \\n        //constructing the grid  O(n*n)\\n        \\n        //traversing and creating the string O(n*n)\\n        \\n        int col = encodedText.length()/rows; \\n        \\n        \\n        char[][] grid = new char[rows][col];\\n        \\n        int k = 0 ; \\n        \\n        for(int i=0 ;i<rows ; i++){\\n            \\n            for(int j=0 ; j<col ; j++){\\n                \\n                grid[i][j] = encodedText.charAt(k); \\n                \\n                k++;\\n                \\n            }\\n        }\\n        \\n        \\n        sb = new StringBuilder(); \\n        \\n        for(int i=0 ; i<col ; i++){\\n            \\n            dfs(0,i,grid);\\n            \\n        }\\n         \\n        \\n       String regex = \"\\\\\\\\s+$\";\\n        \\n       return sb.toString().replaceAll(regex,\"\");\\n    }\\n    \\n    void dfs(int i , int j, char[][] grid){\\n        \\n        if(i<0 || i>grid.length-1 || j<0 || j>grid[0].length-1) return ;\\n        \\n        sb.append(grid[i][j]);\\n        \\n        dfs(i+1,j+1,grid);\\n        \\n        return ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1661876,
                "title": "bfs-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n\\t/*\\n\\t\\t1. Add the starting index of each appendable characters from each row in a queue.\\n\\t\\t\\n\\t\\t2. Now extract the element, add it into the answer string and push the next character \\n\\t\\tfrom the same row in the queue.\\n\\t\\t\\n\\t\\t3. Do it for the length of the encodedText. Later, trim the ending spaces from the answer string.\\n\\t*/\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        queue<int> bfs;\\n        string ans = \"\";\\n        \\n        int i = 1, pointer = 0;\\n        while(i <= rows) {\\n            bfs.push(pointer);\\n            pointer += cols;\\n            pointer += 1;\\n            i++;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            int t = bfs.front();\\n            bfs.pop();\\n            if(t<0 || t>=n) continue;            \\n            ans += encodedText[t++];\\n            bfs.push(t);\\n        }\\n        \\n        int j;\\n        for(j=ans.size()-1; j>=0; j--) {            \\n            if(ans[j] >= \\'a\\' && ans[j] <=\\'z\\') break;\\n        }\\n        \\n        ans.erase(ans.begin()+j+1, ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t/*\\n\\t\\t1. Add the starting index of each appendable characters from each row in a queue.\\n\\t\\t\\n\\t\\t2. Now extract the element, add it into the answer string and push the next character \\n\\t\\tfrom the same row in the queue.\\n\\t\\t\\n\\t\\t3. Do it for the length of the encodedText. Later, trim the ending spaces from the answer string.\\n\\t*/\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        queue<int> bfs;\\n        string ans = \"\";\\n        \\n        int i = 1, pointer = 0;\\n        while(i <= rows) {\\n            bfs.push(pointer);\\n            pointer += cols;\\n            pointer += 1;\\n            i++;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            int t = bfs.front();\\n            bfs.pop();\\n            if(t<0 || t>=n) continue;            \\n            ans += encodedText[t++];\\n            bfs.push(t);\\n        }\\n        \\n        int j;\\n        for(j=ans.size()-1; j>=0; j--) {            \\n            if(ans[j] >= \\'a\\' && ans[j] <=\\'z\\') break;\\n        }\\n        \\n        ans.erase(ans.begin()+j+1, ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659037,
                "title": "c-accepted-solution-explained-on-basis-of-hint-s",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int encodeSize = encodedText.size();\\n\\t\\t// HINT 1 - Get Column , using rows and encodedText\\n        int columns = encodeSize/rows;\\n        vector<vector<char>> mat;\\n        int counter = 0;\\n        vector<char> v;\\n\\t\\t// HINT 2 -- Place in matrix\\n        for(int i=0;i<encodeSize;i++)\\n        {\\n\\n            counter++;\\n            v.push_back(encodedText[i]);\\n            if(counter==columns)\\n            {\\n                counter = 0;\\n                mat.push_back(v);\\n                v.clear();\\n            }\\n        }\\n        string ans;\\n        int colCounter = 0;\\n\\t\\t// HINT 3 - Traverse to get originalText\\n        for(int i=0;i<columns;i++)\\n        {\\n            int rowCounter = 0;\\n            for(int j=0;j<rows && j+colCounter<columns;j++)\\n            {\\n                ans.push_back(mat[rowCounter][j+colCounter]);\\n                rowCounter++;\\n            }\\n            colCounter++;\\n        }\\n\\t\\t//Remove extra spaces at last. Can alternatively use pop_back() also\\n        int lastCharCounter = 0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i]!=\\' \\')\\n                lastCharCounter = i;\\n        }\\n        return ans.substr(0,lastCharCounter+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int encodeSize = encodedText.size();\\n\\t\\t// HINT 1 - Get Column , using rows and encodedText\\n        int columns = encodeSize/rows;\\n        vector<vector<char>> mat;\\n        int counter = 0;\\n        vector<char> v;\\n\\t\\t// HINT 2 -- Place in matrix\\n        for(int i=0;i<encodeSize;i++)\\n        {\\n\\n            counter++;\\n            v.push_back(encodedText[i]);\\n            if(counter==columns)\\n            {\\n                counter = 0;\\n                mat.push_back(v);\\n                v.clear();\\n            }\\n        }\\n        string ans;\\n        int colCounter = 0;\\n\\t\\t// HINT 3 - Traverse to get originalText\\n        for(int i=0;i<columns;i++)\\n        {\\n            int rowCounter = 0;\\n            for(int j=0;j<rows && j+colCounter<columns;j++)\\n            {\\n                ans.push_back(mat[rowCounter][j+colCounter]);\\n                rowCounter++;\\n            }\\n            colCounter++;\\n        }\\n\\t\\t//Remove extra spaces at last. Can alternatively use pop_back() also\\n        int lastCharCounter = 0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i]!=\\' \\')\\n                lastCharCounter = i;\\n        }\\n        return ans.substr(0,lastCharCounter+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653689,
                "title": "js-simple-solution-string-array-string-builder",
                "content": "```\\n\\t/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const cols = Math.round(encodedText.length / rows);\\n    const matrix = new Array(rows).fill(null).map(item => []);\\n    let c = 0;\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            const char = encodedText.charAt(c++); \\n            matrix[i][j] = char;\\n        }\\n    }\\n    let result = \\'\\';\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = 0; j < rows; j++) {\\n            if (matrix[j][i + j]) result += matrix[j][i + j]\\n        }\\n    }\\n    return result.trimRight();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\t/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const cols = Math.round(encodedText.length / rows);\\n    const matrix = new Array(rows).fill(null).map(item => []);\\n    let c = 0;\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            const char = encodedText.charAt(c++); \\n            matrix[i][j] = char;\\n        }\\n    }\\n    let result = \\'\\';\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = 0; j < rows; j++) {\\n            if (matrix[j][i + j]) result += matrix[j][i + j]\\n        }\\n    }\\n    return result.trimRight();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1650044,
                "title": "o-n-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int n) {\\n        int m=encodedText.length()/n;\\n        string s=\"\";\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i+j<m && i<n;i++){\\n                s+= encodedText[i*m+i+j];\\n            }\\n        }\\n        while(s.size() && s.back()==\\' \\') s.pop_back();\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int n) {\\n        int m=encodedText.length()/n;\\n        string s=\"\";\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i+j<m && i<n;i++){\\n                s+= encodedText[i*m+i+j];\\n            }\\n        }\\n        while(s.size() && s.back()==\\' \\') s.pop_back();\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649232,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if len(encodedText) == 0: return \"\"\\n        \\n        m, n, ls = rows, len(encodedText) // rows, []    \\n        matrix = [encodedText[n * i: n * (i + 1)] for i in range(m)]\\n\\n        i, j, idx = 0, 0, 0\\n        while True:\\n            ls.append(matrix[i][j])\\n            if i == 0 and j == n - 1: break\\n            if i == m - 1 or j == n - 1:\\n                idx += 1\\n                i, j = 0, idx\\n            else:\\n                i += 1\\n                j += 1\\n        \\n        while ls[-1] == \\' \\': ls.pop()\\n\\n        return \\'\\'.join(ls)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if len(encodedText) == 0: return \"\"\\n        \\n        m, n, ls = rows, len(encodedText) // rows, []    \\n        matrix = [encodedText[n * i: n * (i + 1)] for i in range(m)]\\n\\n        i, j, idx = 0, 0, 0\\n        while True:\\n            ls.append(matrix[i][j])\\n            if i == 0 and j == n - 1: break\\n            if i == m - 1 or j == n - 1:\\n                idx += 1\\n                i, j = 0, idx\\n            else:\\n                i += 1\\n                j += 1\\n        \\n        while ls[-1] == \\' \\': ls.pop()\\n\\n        return \\'\\'.join(ls)",
                "codeTag": "Java"
            },
            {
                "id": 1646892,
                "title": "python-o-n-by-diagonal-decode-w-visualization",
                "content": "Python O(n) by diagonal decode.\\n\\n![image](https://assets.leetcode.com/users/images/5c422b5a-921a-4c3b-8c2b-83a3264fd292_1640454409.9887652.png)\\n\\n\\n---\\n**Hint** and **Algorithm**:\\n\\nStep_1.\\nGet the codec matrix **heigh** and **width**, \\nwhere height is given = rows, and \\nwidth = len(encode string) // rows \\n\\nStep_2.\\nDecode order is blue axis, then red axis, then yellow axis, ..., and so on \\n\\nStep_3.\\nThose characters belong to same axis has the index **offset (width+1)** in **encode string** by observation\\n\\nTake blue axis for example\\n```\\nindex on codec matrix :(0, 0) -> (1, 1)  -> (2, 2)   -> ...\\nindex in encode text:  s[ 0 ] -> s[w+1]  -> s[2w+2 ] -> ...\\n```\\n\\nStep_4.\\nDecode each diagonal axis one by one to generate plain text.\\nPaintext on blue axis = join ( s[ 0 ], s[ 0 + w + 1 ], s[ 0 + 2w + 2 ], ... )\\n\\nPaintext on red axis = join ( s[ 1 ], s[ 1 + w + 1], s[ 1 + 2w + 2 ], ... )\\n\\nPaintext on yellow axis = join ( s[ 2 ], s[ 2 + w + 1], s[ 2 + 2w + 2 ], ... )\\n...and so on till we reach last column\\n\\nStep_5.\\nFinally, **remember to remove redundant whitespaces** on the tail.\\n\\n---\\n\\n**Implementation** by diagonal decode:\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\n        if rows == 1:\\n            # Quick response on simple case\\n            return encodedText\\n        \\n        # get the codec matrix dimension\\n        h = rows\\n        w = len(encodedText) // h\\n        \\n        # Concatenate diagonal string level by level\\n        # Remeber to remove redundant whitespaces on the tail\\n        return \"\".join( encodedText[diag_level::w+1]for diag_level in range(w)).rstrip()\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "```\\nindex on codec matrix :(0, 0) -> (1, 1)  -> (2, 2)   -> ...\\nindex in encode text:  s[ 0 ] -> s[w+1]  -> s[2w+2 ] -> ...\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\n        if rows == 1:\\n            # Quick response on simple case\\n            return encodedText\\n        \\n        # get the codec matrix dimension\\n        h = rows\\n        w = len(encodedText) // h\\n        \\n        # Concatenate diagonal string level by level\\n        # Remeber to remove redundant whitespaces on the tail\\n        return \"\".join( encodedText[diag_level::w+1]for diag_level in range(w)).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637753,
                "title": "simple-logical-solution",
                "content": "\\n\\n\\nstring decodeCiphertext(string encodedText, int rows) \\n\\n{\\n        \\n\\t\\t\\n\\t\\tint n = encodedText.length();\\n        int cols = n/rows;\\n        \\n        string ans = \"\";\\n        for(int i=0; i<cols; i=i+1){\\n            //if(encodedText[i] == \\' \\')\\n               //break;\\n            for(int j=i; j<n; j=j+cols+1)\\n               ans += encodedText[j];\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "\\n\\n\\nstring decodeCiphertext(string encodedText, int rows) \\n\\n{\\n        \\n\\t\\t\\n\\t\\tint n = encodedText.length();\\n        int cols = n/rows;\\n        \\n        string ans = \"\";\\n        for(int i=0; i<cols; i=i+1){\\n            //if(encodedText[i] == \\' \\')\\n               //break;\\n            for(int j=i; j<n; j=j+cols+1)\\n               ans += encodedText[j];\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1625315,
                "title": "cpp-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        if(s==\"\" || rows==1)return s; //BASE CASE\\n       vector<vector<char>>arr(rows,vector<char>(s.size()/rows,\\' \\')); //CREATING MATRIX;\\n        int ind=0;\\n        for(int i=0;i<arr.size();i++) //FILLING MATRIX WITH CHARACTERS;\\n        {\\n            for(int j=0;j<arr[0].size();j++)\\n            {\\n                if(ind<s.size())\\n                {\\n                    arr[i][j]=s[ind++];\\n                }\\n            }\\n        }\\n        s=\"\";\\n        for(int i=0;i<arr[0].size();i++) //TRAVERSING MATRIX ACCORDING TO QUESTION;\\n        {\\n            int j=0,t=i;\\n            while(j<arr.size()&&t<arr[0].size())\\n            {\\n                s+=arr[j][t];\\n                j++;\\n                t++;\\n            }\\n        }\\n        while(s[s.size()-1]==\\' \\')s.pop_back(); //REMOVE TRAILING SPACES;\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        if(s==\"\" || rows==1)return s; //BASE CASE\\n       vector<vector<char>>arr(rows,vector<char>(s.size()/rows,\\' \\')); //CREATING MATRIX;\\n        int ind=0;\\n        for(int i=0;i<arr.size();i++) //FILLING MATRIX WITH CHARACTERS;\\n        {\\n            for(int j=0;j<arr[0].size();j++)\\n            {\\n                if(ind<s.size())\\n                {\\n                    arr[i][j]=s[ind++];\\n                }\\n            }\\n        }\\n        s=\"\";\\n        for(int i=0;i<arr[0].size();i++) //TRAVERSING MATRIX ACCORDING TO QUESTION;\\n        {\\n            int j=0,t=i;\\n            while(j<arr.size()&&t<arr[0].size())\\n            {\\n                s+=arr[j][t];\\n                j++;\\n                t++;\\n            }\\n        }\\n        while(s[s.size()-1]==\\' \\')s.pop_back(); //REMOVE TRAILING SPACES;\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622063,
                "title": "c-solution",
                "content": "Matrix Rebuilding\\n```\\npublic class Solution {\\n    public string DecodeCiphertext(string e, int rows) {\\n        if (rows == 1 || string.IsNullOrEmpty(e)) return e;\\n        \\n        int l = e.Length, cols = l / rows;\\n        char[,] m = new char[rows, cols];\\n        int k = 0;\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                m[i, j] = e[k++];\\n            }\\n        }\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < m.GetLength(1); ++i) {\\n            int row = 0, col = i;\\n            while (row < rows && col < cols) r.Append(m[row++, col++]);\\n        }\\n        \\n        while (r[r.Length - 1] == \\' \\') r.Length--;\\n        \\n        return r.ToString();\\n    }\\n}\\n```\\n\\nColumn Index Hopping\\n```\\npublic class Solution {\\n    public string DecodeCiphertext(string et, int rows) {\\n        int l = et.Length, cols = et.Length / rows;\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < cols; ++i) { \\n            for (int j = i; j < et.Length; j += cols + 1) { // + 1 for the leading space \\n                r.Append(et[j]);\\n            }\\n        }\\n        \\n        return r.ToString().TrimEnd();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DecodeCiphertext(string e, int rows) {\\n        if (rows == 1 || string.IsNullOrEmpty(e)) return e;\\n        \\n        int l = e.Length, cols = l / rows;\\n        char[,] m = new char[rows, cols];\\n        int k = 0;\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                m[i, j] = e[k++];\\n            }\\n        }\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < m.GetLength(1); ++i) {\\n            int row = 0, col = i;\\n            while (row < rows && col < cols) r.Append(m[row++, col++]);\\n        }\\n        \\n        while (r[r.Length - 1] == \\' \\') r.Length--;\\n        \\n        return r.ToString();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string DecodeCiphertext(string et, int rows) {\\n        int l = et.Length, cols = et.Length / rows;\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < cols; ++i) { \\n            for (int j = i; j < et.Length; j += cols + 1) { // + 1 for the leading space \\n                r.Append(et[j]);\\n            }\\n        }\\n        \\n        return r.ToString().TrimEnd();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604184,
                "title": "javascript-time-o-m-n-space-o-1",
                "content": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const len = encodedText.length\\n    const cols = len / rows\\n    function getCh(i, j) {\\n        const index = i * cols + j\\n        return encodedText[index]\\n    }\\n    \\n    \\n    const chs = []\\n    for (let j = 0; j < cols; j++) {\\n        for (let i = 0; i < rows && j + i < cols; i++) {\\n            const ch = getCh(i, i + j)\\n            chs.push(ch)\\n        }\\n    }\\n    \\n    \\n    let result = chs.join(\\'\\')\\n    result = result.trimEnd()\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const len = encodedText.length\\n    const cols = len / rows\\n    function getCh(i, j) {\\n        const index = i * cols + j\\n        return encodedText[index]\\n    }\\n    \\n    \\n    const chs = []\\n    for (let j = 0; j < cols; j++) {\\n        for (let i = 0; i < rows && j + i < cols; i++) {\\n            const ch = getCh(i, i + j)\\n            chs.push(ch)\\n        }\\n    }\\n    \\n    \\n    let result = chs.join(\\'\\')\\n    result = result.trimEnd()\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588867,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int r) {\\n        int c = str.size() / r; \\n        string ret; \\n        for(int i = 0;i<c;i++) {\\n            for(int j = 0;j<r&&i+j<c;j++) {\\n                ret.push_back(str[j*c + i + j]);\\n            }\\n        }\\n        ret.erase(ret.find_last_not_of(\\' \\')+1);\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int r) {\\n        int c = str.size() / r; \\n        string ret; \\n        for(int i = 0;i<c;i++) {\\n            for(int j = 0;j<r&&i+j<c;j++) {\\n                ret.push_back(str[j*c + i + j]);\\n            }\\n        }\\n        ret.erase(ret.find_last_not_of(\\' \\')+1);\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588272,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic String decodeCiphertext(String encodedText, int rows) {\\n        \\n        int l=encodedText.length();\\n        \\n        int x,c=l/rows;\\n        \\n        if(l==0)\\n            return \"\";\\n        \\n        int j=0;\\n        StringBuilder d= new StringBuilder();\\n        while(j<c){\\n            int y=j;\\n            x=0;\\n            while(y<l){\\n                d=d.append(encodedText.charAt(y));\\n                y=y+c+1;\\n            }\\n            j++;\\n        }\\n        \\n        String t=d.toString();\\n        \\n        int y=t.length();\\n        \\n      while(y>=0 && t.charAt(y-1)==\\' \\')\\n          y--;\\n        \\n        if(y==-1)\\n            return \"\";\\n        \\n        return t.substring(0,y);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic String decodeCiphertext(String encodedText, int rows) {\\n        \\n        int l=encodedText.length();\\n        \\n        int x,c=l/rows;\\n        \\n        if(l==0)\\n            return \"\";\\n        \\n        int j=0;\\n        StringBuilder d= new StringBuilder();\\n        while(j<c){\\n            int y=j;\\n            x=0;\\n            while(y<l){\\n                d=d.append(encodedText.charAt(y));\\n                y=y+c+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1588186,
                "title": "2075-decode-the-slanted-ciphertext",
                "content": "---\\n\\n- Contest - https://leetcode.com/contest/weekly-contest-267/\\n  - Q1 Answer\\n    - https://leetcode.com/problems/time-needed-to-buy-tickets/discuss/1578174/2073.-Time-Needed-to-Buy-Tickets\\n  - Q2 Answer\\n    - https://leetcode.com/problems/reverse-nodes-in-even-length-groups/discuss/1580446/2074.-Reverse-Nodes-in-Even-Length-Groups\\n  - Q3 Answer\\n    - below\\n      - https://leetcode.com/problems/decode-the-slanted-ciphertext/discuss/1588186/2075.-Decode-the-Slanted-Ciphertext\\n\\n---\\n\\n- Code from my contest, worked out on paper for 15 mins, and 4 mins of coding, 1 min of submission. Passed on 1st submit.\\n  - See Q3 at https://leetcode.com/contest/weekly-contest-267/ranking/72/\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar decodeCiphertext = function (encodedText, rows) {\\n    let n = encodedText.length;\\n\\n    let ans = \\'\\';\\n    let cols = Math.round(n / rows);\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = i; j < n; j += cols + 1) {\\n            ans += encodedText[j];\\n        }\\n    }\\n    return ans.trimRight();\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decodeCiphertext = function (encodedText, rows) {\\n    let n = encodedText.length;\\n\\n    let ans = \\'\\';\\n    let cols = Math.round(n / rows);\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = i; j < n; j += cols + 1) {\\n            ans += encodedText[j];\\n        }\\n    }\\n    return ans.trimRight();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588102,
                "title": "pick-characters-columns-1-distant-apart",
                "content": "```\\n// time: O(n) || space : O(1)\\n\\npublic String decodeCiphertext(String encodedText, int rows) {\\n\\tint textLen = encodedText.length();\\n\\tint cols = textLen / rows;\\n\\n\\tStringBuffer decodedStrBuf = new StringBuffer();\\n\\tfor(int i = 0; i < cols; i++) {\\n\\t\\tfor(int j = i; j < textLen; j += (cols + 1)) {\\n\\t\\t\\tdecodedStrBuf.append(encodedText.charAt(j));\\n\\t\\t}\\n\\t}\\n\\n\\treturn decodedStrBuf.toString().stripTrailing();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// time: O(n) || space : O(1)\\n\\npublic String decodeCiphertext(String encodedText, int rows) {\\n\\tint textLen = encodedText.length();\\n\\tint cols = textLen / rows;\\n\\n\\tStringBuffer decodedStrBuf = new StringBuffer();\\n\\tfor(int i = 0; i < cols; i++) {\\n\\t\\tfor(int j = i; j < textLen; j += (cols + 1)) {\\n\\t\\t\\tdecodedStrBuf.append(encodedText.charAt(j));\\n\\t\\t}\\n\\t}\\n\\n\\treturn decodedStrBuf.toString().stripTrailing();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587671,
                "title": "go-solution-with-explanation",
                "content": "1. we can get the column of the matrix: `len(encodedText)/rows`\\n2. we can locate the character in every `blow arrows` if we know where the first character is (0, y). Actually, we know it, they are all in the first `column` character of encodedText. For example, in `example 1`, it\\'s `ch`, in `example 2`, it\\'s `iveo`.\\n3. the latest column must have character, so the second place`(rows-2, column-1)` from last in last column `column-1` may have character. However, the third place`(rows-3, column-1)` from last in last column `column-1` must have no character, actually, the blue arrows including the `(rows-3, column-1)`  must have no character. That is, there are most `column-rows+2` characters in the first line. \\n\\n```go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n\\tif rows == 1 {\\n\\t\\treturn encodedText\\n\\t}\\n\\tcolumn := len(encodedText) / rows\\n\\tans := \"\"\\n\\tvar index int\\n\\tfor round := 0; round <= column-rows+1; round++ {\\n\\t\\toriginIndex := round\\n\\t\\tfor i := 0; i < rows; i++ {\\n\\t\\t\\tindex = originIndex + i*column + i\\n\\t\\t\\tif index >= len(encodedText) {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tans += string(encodedText[index])\\n\\t\\t}\\n\\t}\\n\\treturn strings.TrimRight(ans, \" \")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n\\tif rows == 1 {\\n\\t\\treturn encodedText\\n\\t}\\n\\tcolumn := len(encodedText) / rows\\n\\tans := \"\"\\n\\tvar index int\\n\\tfor round := 0; round <= column-rows+1; round++ {\\n\\t\\toriginIndex := round\\n\\t\\tfor i := 0; i < rows; i++ {\\n\\t\\t\\tindex = originIndex + i*column + i\\n\\t\\t\\tif index >= len(encodedText) {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tans += string(encodedText[index])\\n\\t\\t}\\n\\t}\\n\\treturn strings.TrimRight(ans, \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587467,
                "title": "clarifying-the-question",
                "content": "Just want to clarify what the question requires, so others can know exactly what the question is asking for. It took me 3 wrong submissions to figure it out. \\n1. The word starts at where the blue blocks are as shown in the instruction  (I thought that it starts at the bottom left corner.)\\n2. Any group of slanted blocks that contain nothing but spaces should be retained if they are not at the very end.  (I thought those should be removed)\\n3. There is no trailing space but leading space is allowed (instruction mentioned this but I missed it).\\n\\nHope it help someone.",
                "solutionTags": [],
                "code": "Just want to clarify what the question requires, so others can know exactly what the question is asking for. It took me 3 wrong submissions to figure it out. \\n1. The word starts at where the blue blocks are as shown in the instruction  (I thought that it starts at the bottom left corner.)\\n2. Any group of slanted blocks that contain nothing but spaces should be retained if they are not at the very end.  (I thought those should be removed)\\n3. There is no trailing space but leading space is allowed (instruction mentioned this but I missed it).\\n\\nHope it help someone.",
                "codeTag": "Unknown"
            },
            {
                "id": 1583890,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        if(len==0) return encodedText;\\n        int cols = len/rows;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<cols; i++){\\n            for(int row=0; row<rows; row++){\\n                int idx = cols*row+i+row;\\n                if(idx<len)\\n                    sb.append(encodedText.charAt(idx));\\n                else break;\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        if(len==0) return encodedText;\\n        int cols = len/rows;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<cols; i++){\\n            for(int row=0; row<rows; row++){\\n                int idx = cols*row+i+row;\\n                if(idx<len)\\n                    sb.append(encodedText.charAt(idx));\\n                else break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1583724,
                "title": "after-finding-the-columns-read-off-the-matrix",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if not encodedText: return \\'\\'\\n        \\n        C=len(encodedText)//rows\\n        matrix=[]\\n        for i in range(0,len(encodedText),C):\\n            matrix.append(encodedText[i:i+C])\\n        \\n        output=\\'\\'\\n        \\n        for i in range(C):\\n            k=0\\n            while k<rows and i+k<C:\\n                output+=matrix[k][i+k]\\n                k+=1\\n        \\n        return output.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if not encodedText: return \\'\\'\\n        \\n        C=len(encodedText)//rows\\n        matrix=[]\\n        for i in range(0,len(encodedText),C):\\n            matrix.append(encodedText[i:i+C])\\n        \\n        output=\\'\\'\\n        \\n        for i in range(C):\\n            k=0\\n            while k<rows and i+k<C:\\n                output+=matrix[k][i+k]\\n                k+=1\\n        \\n        return output.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583477,
                "title": "giving-heap-overflow-working-fine-on-my-compiler",
                "content": "This code is giving heap overflow please help me find my mistake.\\n\\n\\n class Solution {\\npublic:\\n    string trim(string& line)\\n{\\n     for(int i=line.size()-1;i>=0;--i){\\n         if(line[i]>=\\'a\\' and line[i] <= \\'z\\'){\\n            return line.substr(0,i+1);\\n         }\\n     }\\n    return line;\\n}\\n    \\n    string decodeCiphertext(string encodedText, int rows) {\\n        int size = encodedText.size();\\n        int col = ceil(size/(rows*1.0));\\n        vector<string> parts;\\n        for(int i=0;i<encodedText.size();i+=col){\\n            parts.push_back(encodedText.substr(i,col));\\n        }\\n        string original;\\n        for(int i=0;i<col;++i){\\n            int temp_col = i;\\n            for(int j=0;j<rows;++j,++temp_col){\\n                original+=parts[j][temp_col];\\n            }\\n        }\\n        \\n        return trim(original);\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string trim(string& line)\\n{\\n     for(int i=line.size()-1;i>=0;--i){\\n         if(line[i]>=\\'a\\' and line[i] <= \\'z\\'){\\n            return line.substr(0,i+1);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1583160,
                "title": "java-easy-intuitive-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        // if(rows==0||encodedText.length()==0)return \"\";\\n        int len=encodedText.length();\\n        int cols=len/rows;\\n        char mat[][]=new char[rows][cols];\\n        int idx=len-1;int r=rows-1,c=cols-1,nr=0,nc=0;\\n        // System.out.println(rows+\"  \"+cols+\"  \"+len);\\n        while(idx>=0){\\n            if(c==0){\\n                nr=r-1;\\n                nc=cols-1;\\n            }else{\\n                nr=r;\\n                nc=c-1;\\n            }\\n            char ch=encodedText.charAt(idx--);\\n            // System.out.println(ch);\\n            // if(ch==\\' \\'){\\n            // mat[r][c]=\\'.\\';    \\n            // }else{\\n                mat[r][c]=ch;\\n            // }\\n            r=nr;\\n            c=nc;\\n            \\n        }\\n        // for(int i=0;i<rows;i++){\\n        //     for(int j=0;j<cols;j++){\\n        //         System.out.print(\" \"+mat[i][j]+\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        StringBuilder sb=new StringBuilder();\\n        for(int d=0;d<Math.max(rows,cols);d++){\\n            for(int i=0,j=i+d;j<cols&&i<rows;i++,j++){\\n                sb.append(mat[i][j]);\\n            }\\n            \\n        }\\n        System.out.println(sb);\\n        int i=sb.length()-1;\\n        String s=sb.toString();\\n        while(i>=0&&s.charAt(i)==\\' \\'){\\n            i--;\\n        }\\n        return s.substring(0,i+1);\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        // if(rows==0||encodedText.length()==0)return \"\";\\n        int len=encodedText.length();\\n        int cols=len/rows;\\n        char mat[][]=new char[rows][cols];\\n        int idx=len-1;int r=rows-1,c=cols-1,nr=0,nc=0;\\n        // System.out.println(rows+\"  \"+cols+\"  \"+len);\\n        while(idx>=0){\\n            if(c==0){\\n                nr=r-1;\\n                nc=cols-1;\\n            }else{\\n                nr=r;\\n                nc=c-1;\\n            }\\n            char ch=encodedText.charAt(idx--);\\n            // System.out.println(ch);\\n            // if(ch==\\' \\'){\\n            // mat[r][c]=\\'.\\';    \\n            // }else{\\n                mat[r][c]=ch;\\n            // }\\n            r=nr;\\n            c=nc;\\n            \\n        }\\n        // for(int i=0;i<rows;i++){\\n        //     for(int j=0;j<cols;j++){\\n        //         System.out.print(\" \"+mat[i][j]+\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        StringBuilder sb=new StringBuilder();\\n        for(int d=0;d<Math.max(rows,cols);d++){\\n            for(int i=0,j=i+d;j<cols&&i<rows;i++,j++){\\n                sb.append(mat[i][j]);\\n            }\\n            \\n        }\\n        System.out.println(sb);\\n        int i=sb.length()-1;\\n        String s=sb.toString();\\n        while(i>=0&&s.charAt(i)==\\' \\'){\\n            i--;\\n        }\\n        return s.substring(0,i+1);\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581454,
                "title": "java-straightforward-solution-with-two-pointers",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows, m = rows, i = 0, j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<m && j<n){\\n            int runI = 0, runJ = j++;\\n            while(runI < m && runJ < n){\\n                sb.append(encodedText.charAt(runI++ * n + runJ++));\\n            }\\n        }\\n        return trimFromLast(sb.toString());\\n    }\\n    public String trimFromLast(String str){\\n        int i = str.length()-1;\\n        while(i>=0){\\n            if(Character.isAlphabetic(str.charAt(i--)))\\n                return str.substring(0,i+2);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows, m = rows, i = 0, j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<m && j<n){\\n            int runI = 0, runJ = j++;\\n            while(runI < m && runJ < n){\\n                sb.append(encodedText.charAt(runI++ * n + runJ++));\\n            }\\n        }\\n        return trimFromLast(sb.toString());\\n    }\\n    public String trimFromLast(String str){\\n        int i = str.length()-1;\\n        while(i>=0){\\n            if(Character.isAlphabetic(str.charAt(i--)))\\n                return str.substring(0,i+2);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581290,
                "title": "c-observation-beginner-level",
                "content": "jumping columns \\n\\'\\'\\'\\n\\n        string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        string str = \"\";\\n        \\n        //exceptional case of str = \"\" \\n        if(n == 0) return str;\\n       \\n        int col = n/rows ;\\n       // col times\\n        for(int i = 0; i<col; i++){\\n            \\n         //((row*col)/ col+1)\\n            for(int j = i; j< n; j+= col + 1){\\n                \\n              str +=   encodedText[j];\\n            }\\n        }\\n        // removes end spaces \\n        while(str[str.size()-1] == \\' \\') str.pop_back();\\n        return str;\\n        \\n    }\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "jumping columns \\n\\'\\'\\'\\n\\n        string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        string str = \"\";\\n        \\n        //exceptional case of str = \"\" \\n        if(n == 0) return str;\\n       \\n        int col = n/rows ;\\n       // col times\\n        for(int i = 0; i<col; i++){\\n            \\n         //((row*col)/ col+1)\\n            for(int j = i; j< n; j+= col + 1){\\n                \\n              str +=   encodedText[j];\\n            }\\n        }\\n        // removes end spaces \\n        while(str[str.size()-1] == \\' \\') str.pop_back();\\n        return str;\\n        \\n    }\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1581065,
                "title": "java-tiny-solution-in-place",
                "content": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int cols = encodedText.length() / rows;        \\n        StringBuilder sb = new StringBuilder();\\n        for(int jj=0;jj<cols;jj++){\\n            for(int i=0,j=jj; i<rows && j<cols; i++,j++){\\n                sb.append(encodedText.charAt(i*cols+j));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int cols = encodedText.length() / rows;        \\n        StringBuilder sb = new StringBuilder();\\n        for(int jj=0;jj<cols;jj++){\\n            for(int i=0,j=jj; i<rows && j<cols; i++,j++){\\n                sb.append(encodedText.charAt(i*cols+j));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580811,
                "title": "optimized-for-time-10ms",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (encodedText.length() <= 1) {\\n            return encodedText;\\n        }\\n        \\n        int n = encodedText.length() / rows;\\n        char[][] cipher = new char[rows][n];\\n        for (int i=0; i < rows; i++) {\\n            int start = i * n;\\n            cipher[i] = encodedText.substring(start, start + n).toCharArray();\\n        }\\n        \\n        int numColumnsToProcess = n-rows+1;\\n        char[] val = new char[encodedText.length() - (rows * (rows - 1))];\\n        int count=0;\\n        for(int i = 0; i<numColumnsToProcess; i++) {\\n            for(int j = 0; j<rows; j++) {\\n                val[count++] = cipher[j][i+j];\\n            }\\n        }\\n        \\n        StringBuilder extraBuilder = new StringBuilder();\\n        for(int j=0; j<rows-1; j++) {\\n            extraBuilder.append(cipher[j][numColumnsToProcess+j]);\\n        }\\n        \\n        String extra = extraBuilder.toString();  \\n        if (extra.trim().isEmpty()) {\\n            return new String(val);\\n        } \\n        \\n        int length = extraBuilder.length() - 1;\\n        while (length > 0 && extraBuilder.charAt(length) == \\' \\') {\\n            length--;\\n        }\\n        extraBuilder.setLength(length + 1);        \\n              \\n        \\n        return new String(val) + extraBuilder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (encodedText.length() <= 1) {\\n            return encodedText;\\n        }\\n        \\n        int n = encodedText.length() / rows;\\n        char[][] cipher = new char[rows][n];\\n        for (int i=0; i < rows; i++) {\\n            int start = i * n;\\n            cipher[i] = encodedText.substring(start, start + n).toCharArray();\\n        }\\n        \\n        int numColumnsToProcess = n-rows+1;\\n        char[] val = new char[encodedText.length() - (rows * (rows - 1))];\\n        int count=0;\\n        for(int i = 0; i<numColumnsToProcess; i++) {\\n            for(int j = 0; j<rows; j++) {\\n                val[count++] = cipher[j][i+j];\\n            }\\n        }\\n        \\n        StringBuilder extraBuilder = new StringBuilder();\\n        for(int j=0; j<rows-1; j++) {\\n            extraBuilder.append(cipher[j][numColumnsToProcess+j]);\\n        }\\n        \\n        String extra = extraBuilder.toString();  \\n        if (extra.trim().isEmpty()) {\\n            return new String(val);\\n        } \\n        \\n        int length = extraBuilder.length() - 1;\\n        while (length > 0 && extraBuilder.charAt(length) == \\' \\') {\\n            length--;\\n        }\\n        extraBuilder.setLength(length + 1);        \\n              \\n        \\n        return new String(val) + extraBuilder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580534,
                "title": "c-easy-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int col=n/rows;\\n        string ans=\"\";\\n        for(int i=0;i<col;i++) // We have to just move column number of times in original string //\\n        {\\n            for(int j=i;j<n;j+=col+1)    // We get the next character at every column+1 ahead //\\n              ans+=encodedText[j];\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();   // Remove the spaces at the end //\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int col=n/rows;\\n        string ans=\"\";\\n        for(int i=0;i<col;i++) // We have to just move column number of times in original string //\\n        {\\n            for(int j=i;j<n;j+=col+1)    // We get the next character at every column+1 ahead //\\n              ans+=encodedText[j];\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();   // Remove the spaces at the end //\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579425,
                "title": "simple-c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public string DecodeCiphertext(string encodedText, int rows)\\n    {\\n        int col = encodedText.Length / rows;\\n        char[] orginal = new char[encodedText.Length];\\n        int startc = 0;\\n        int c = 0;\\n        int length = 0;\\n        for (int i = 0; i < orginal.Length; i++)\\n        {\\n            int r = i % rows;\\n            if (r == 0)\\n                c = startc++;\\n            else\\n                c++;\\n            if (c >= col)\\n                break;\\n            orginal[i] = encodedText[r * col + c];\\n            length++;\\n        }\\n        return new string(orginal, 0, length).TrimEnd();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public string DecodeCiphertext(string encodedText, int rows)\\n    {\\n        int col = encodedText.Length / rows;\\n        char[] orginal = new char[encodedText.Length];\\n        int startc = 0;\\n        int c = 0;\\n        int length = 0;\\n        for (int i = 0; i < orginal.Length; i++)\\n        {\\n            int r = i % rows;\\n            if (r == 0)\\n                c = startc++;\\n            else\\n                c++;\\n            if (c >= col)\\n                break;\\n            orginal[i] = encodedText[r * col + c];\\n            length++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1579310,
                "title": "cut-the-string-and-zip-longest-100-speed-100-memory",
                "content": "![image](https://assets.leetcode.com/users/images/58be7acc-e1a6-456c-8883-4bd064907f04_1636965633.6376953.png)\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        cols = len(encodedText) // rows\\n        matrix = [encodedText[i * cols + i: (i + 1) * cols] for i in range(rows)]\\n        return \"\".join(\"\".join(c)\\n                       for c in zip_longest(*matrix, fillvalue=\" \")).rstrip(\" \")\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        cols = len(encodedText) // rows\\n        matrix = [encodedText[i * cols + i: (i + 1) * cols] for i in range(rows)]\\n        return \"\".join(\"\".join(c)\\n                       for c in zip_longest(*matrix, fillvalue=\" \")).rstrip(\" \")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579257,
                "title": "c-easy-to-understand",
                "content": "```\\npublic class Solution {\\n      public string DecodeCiphertext(string encodedText, int rows)\\n        {\\n            if(rows == 1)\\n            {\\n                return encodedText;\\n            }\\n\\n            int cols = encodedText.Length / rows;\\n            char[,] matrix = new char[rows, cols];\\n            int it = 0;\\n            StringBuilder sb = new();\\n\\n            for (int i = 0; i < matrix.GetLength(0); i++)\\n            {\\n                for (int j = 0; j < matrix.GetLength(1); j++)\\n                {\\n                    matrix[i, j] = encodedText[it++];\\n                }\\n            }\\n\\n\\n            for (int i = 0; i < matrix.GetLength(1); i++)\\n            {\\n                int sI = 0, sJ = i;\\n\\n                while (sI < matrix.GetLength(0) && sJ < matrix.GetLength(1))\\n                {\\n                    sb.Append(matrix[sI, sJ]);\\n                    sI++; sJ++;\\n                }\\n            }\\n\\n            string res = sb.ToString().TrimEnd();\\n\\n            return res;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n      public string DecodeCiphertext(string encodedText, int rows)\\n        {\\n            if(rows == 1)\\n            {\\n                return encodedText;\\n            }\\n\\n            int cols = encodedText.Length / rows;\\n            char[,] matrix = new char[rows, cols];\\n            int it = 0;\\n            StringBuilder sb = new();\\n\\n            for (int i = 0; i < matrix.GetLength(0); i++)\\n            {\\n                for (int j = 0; j < matrix.GetLength(1); j++)\\n                {\\n                    matrix[i, j] = encodedText[it++];\\n                }\\n            }\\n\\n\\n            for (int i = 0; i < matrix.GetLength(1); i++)\\n            {\\n                int sI = 0, sJ = i;\\n\\n                while (sI < matrix.GetLength(0) && sJ < matrix.GetLength(1))\\n                {\\n                    sb.Append(matrix[sI, sJ]);\\n                    sI++; sJ++;\\n                }\\n            }\\n\\n            string res = sb.ToString().TrimEnd();\\n\\n            return res;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579218,
                "title": "java-solution-o-n-5-lines",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0, cols=encodedText.length()/rows; i<cols; i++)\\n            for(int j=i; j<encodedText.length(); j+=(cols+1))\\n                sb.append(encodedText.charAt(j));\\n        return sb.toString().stripTrailing();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0, cols=encodedText.length()/rows; i<cols; i++)\\n            for(int j=i; j<encodedText.length(); j+=(cols+1))\\n                sb.append(encodedText.charAt(j));\\n        return sb.toString().stripTrailing();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578849,
                "title": "javascript-matrix-diagonal-traverse-180ms",
                "content": "```\\n///////////////////////////////////////////// Template //////////////////////////////////////////////////////////////////////////////\\nconst initialize2DArrayNew = (n, m) => { let data = []; for (let i = 0; i < n; i++) { let tmp = Array(m).fill(0); data.push(tmp); } return data; };\\nconst diagonal_traverse_topLeft_to_bottomRight = (g) => {\\n    let n = g.length;\\n    let m = g[0].length;\\n    let top = [];\\n    for (let j = 0; j < m; j++) { // first row as starting point\\n        let tmp = [];\\n        let share = 0; // shared increase control\\n        while (share < n && j + share < m) { // read Diagonally\\n            tmp.push(g[share][j + share]); // row++ col++\\n            share++;\\n        }\\n         if (tmp.length > 0) top.push(tmp);\\n    }\\n    return top;\\n};\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst decodeCiphertext = (s, n) => {\\n    let sn = s.length;\\n    if (n == 1) return s;\\n    let m = sn / n;\\n    let g = initialize2DArrayNew(n, m);\\n    let idx = 0;\\n    for (let i = 0; i < n; i++) { // read string into matrix\\n        for (let j = 0; j < m; j++) {\\n            g[i][j] = s[idx];\\n            idx++;\\n        }\\n    }\\n    let res = \"\";\\n    let d = diagonal_traverse_topLeft_to_bottomRight(g); // get each diagonal traverse(d[i] array) from first row as starting point\\n    let start = 0; end = d.length - 1; // start: first diagonal starting point idx in d,  end: last diagonal starting point idx in d\\n    for (let i = d.length - 1; i >= start; i--) { // get end idx\\n        if (hasChar(d[i])) {\\n            end = i;\\n            break;\\n        }\\n    }\\n    for (let i = start; i <= end; i++) { // append ans from d[start] and d[end]\\n        if (i == end && start != end) { // d[end] last diagonal should ignore empty string in the end\\n            let curEnd = d[i].length - 1;\\n            for (let j = curEnd; j >= 0; j--) {\\n                let c = d[i][j];\\n                if (c != \\' \\') {\\n                    curEnd = j; // get the end index of d[end] last diagonal\\n                    break;\\n                }\\n            }\\n            for (let j = 0; j <= curEnd; j++)  res += d[i][j]; // append chars for last diagonal\\n        } else {\\n            for (const c of d[i]) res += c; // append all chars for all other diagonals\\n        }\\n    }\\n    return res;\\n};\\n\\nconst hasChar = (a) => {\\n    for (const c of a) {\\n        if (c != \\' \\') return true;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n///////////////////////////////////////////// Template //////////////////////////////////////////////////////////////////////////////\\nconst initialize2DArrayNew = (n, m) => { let data = []; for (let i = 0; i < n; i++) { let tmp = Array(m).fill(0); data.push(tmp); } return data; };\\nconst diagonal_traverse_topLeft_to_bottomRight = (g) => {\\n    let n = g.length;\\n    let m = g[0].length;\\n    let top = [];\\n    for (let j = 0; j < m; j++) { // first row as starting point\\n        let tmp = [];\\n        let share = 0; // shared increase control\\n        while (share < n && j + share < m) { // read Diagonally\\n            tmp.push(g[share][j + share]); // row++ col++\\n            share++;\\n        }\\n         if (tmp.length > 0) top.push(tmp);\\n    }\\n    return top;\\n};\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst decodeCiphertext = (s, n) => {\\n    let sn = s.length;\\n    if (n == 1) return s;\\n    let m = sn / n;\\n    let g = initialize2DArrayNew(n, m);\\n    let idx = 0;\\n    for (let i = 0; i < n; i++) { // read string into matrix\\n        for (let j = 0; j < m; j++) {\\n            g[i][j] = s[idx];\\n            idx++;\\n        }\\n    }\\n    let res = \"\";\\n    let d = diagonal_traverse_topLeft_to_bottomRight(g); // get each diagonal traverse(d[i] array) from first row as starting point\\n    let start = 0; end = d.length - 1; // start: first diagonal starting point idx in d,  end: last diagonal starting point idx in d\\n    for (let i = d.length - 1; i >= start; i--) { // get end idx\\n        if (hasChar(d[i])) {\\n            end = i;\\n            break;\\n        }\\n    }\\n    for (let i = start; i <= end; i++) { // append ans from d[start] and d[end]\\n        if (i == end && start != end) { // d[end] last diagonal should ignore empty string in the end\\n            let curEnd = d[i].length - 1;\\n            for (let j = curEnd; j >= 0; j--) {\\n                let c = d[i][j];\\n                if (c != \\' \\') {\\n                    curEnd = j; // get the end index of d[end] last diagonal\\n                    break;\\n                }\\n            }\\n            for (let j = 0; j <= curEnd; j++)  res += d[i][j]; // append chars for last diagonal\\n        } else {\\n            for (const c of d[i]) res += c; // append all chars for all other diagonals\\n        }\\n    }\\n    return res;\\n};\\n\\nconst hasChar = (a) => {\\n    for (const c of a) {\\n        if (c != \\' \\') return true;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578764,
                "title": "from-tle-to-100",
                "content": "At first, I got TLE 37/39. And that case only has 1 row.\\n```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```\\nThen I add one more condition for this case. It is 100%. \\n```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        if rows==1:\\n            return es\\n        #print mat\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```\n```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        if rows==1:\\n            return es\\n        #print mat\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578623,
                "title": "c-python3-worst-solution",
                "content": "C++\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int N = encodedText.size();\\n        int cols = N/rows;\\n        string re = \"\";\\n        for(int j=0;j<cols;++j){\\n            for(int k=j;k<=N;k+=cols+1 ){\\n                if(k==N){//optimizer: Return as soon as hitting the invalid index of encodedText\\n                    while(re.back()==\\' \\')\\n                        re.pop_back();\\n                    return re;\\n                }\\n                re += encodedText[k];\\n            }\\n        }\\n        return re;//In case never hitting the invalid index of encodedText.\\n    }\\n};\\n```\\n\\nPython 3\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        N = len(encodedText)\\n        cols = N//rows\\n        re = \"\"\\n        for j in range(cols):\\n            for k in range(j,N+1,cols+1):\\n                if(k==N): #Return as soon as hitting the invalid index of encodedText\\n                   return re.rstrip(\" \")\\n                re += encodedText[k];\\n        return re #In case never hitting the invalid index of encodedText.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int N = encodedText.size();\\n        int cols = N/rows;\\n        string re = \"\";\\n        for(int j=0;j<cols;++j){\\n            for(int k=j;k<=N;k+=cols+1 ){\\n                if(k==N){//optimizer: Return as soon as hitting the invalid index of encodedText\\n                    while(re.back()==\\' \\')\\n                        re.pop_back();\\n                    return re;\\n                }\\n                re += encodedText[k];\\n            }\\n        }\\n        return re;//In case never hitting the invalid index of encodedText.\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        N = len(encodedText)\\n        cols = N//rows\\n        re = \"\"\\n        for j in range(cols):\\n            for k in range(j,N+1,cols+1):\\n                if(k==N): #Return as soon as hitting the invalid index of encodedText\\n                   return re.rstrip(\" \")\\n                re += encodedText[k];\\n        return re #In case never hitting the invalid index of encodedText.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578508,
                "title": "python-3-simple-traversing-solution-better-time-and-memory-than-83-of-submission",
                "content": "\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n        ncols = int(len(encodedText)/nrows)\\n        ## the total number of slanted lines will be equal to the number of columns. so we print each slanted line, indexed by j, using the first loop below.\\n\\t\\tfor j in range(ncols):\\n\\t\\t\\t## the \"first\" slanted lines will have a length equal to the number of rows but the slanted line near the end of string will have a length lower than the number of rows\\n\\t\\t\\t## because you will hit the final column, and it prevents you from having a slanted line with length of number of rows. the value i, shows the indices of rows that contribute\\n\\t\\t\\t## to the current slanted line ( indexed by j) before.\\n            for i in range(0,min(ncols-j, nrows)):\\n\\t\\t\\t\\t\\t\\t# addressing the value of encodedTextMatrix[i,j] without actually construcing the matrix from encodedText. you can replace this line with\\n\\t\\t\\t\\t\\t\\t# decoded_str += encodedTextMatrix[i,j] if you prefer to first reconstruct the encodedTextMatrix matrix to keep things nice and clean\\n                        decoded_str += encodedText[i*ncols+i+j]\\n        return decoded_str.rstrip(\" \")\\n                \\n```\\ntime complexity is O(n^2) as we add all elements from the original matrix (including the trailing spaces) and then will remove them. \\na simple modification can turn the algorithm to O(n) though. simply check if all of non-space characters are already added to decoded_str and in that case just stop.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n\\t\\t## keep track of characters from encodedText that were added to our to-be-returned result string (decoded_str)\\n        used_chars = defaultdict(int)\\n\\t\\t## length of non-space characters in encodedText\\n        all_chars = len([encodedText[i] for i in range(len(encodedText)) if encodedText[i]!=\" \"])\\n        ncols = int(len(encodedText)/nrows)\\n        for j in range(ncols):\\n\\t\\t\\t# check if all non-space characters from encodedText are already added to decoded_str\\n            if len(used_chars) == all_chars:\\n                break       \\n            for i in range(0,min(ncols-j, nrows)):\\n                        ind = i*ncols+i+j\\n\\t\\t\\t\\t\\t\\t## if current chracter is not space, add it to used_chars\\n                        if encodedText[ind] != \" \":\\n                            used_chars[ind] = 1\\n                        decoded_str += encodedText[ind]\\n\\t\\t# we may still have a few (less than n) spaced at the end of string but it doesn\\'t affect time complexity and can get stripped simply. \\n\\t\\t#the reason is that you can\\'t break from the inner loop in a nested loops in python! and doing that would make the code a bit ugly\\n        return decoded_str.rstrip(\" \")\\n                \\n```\\ntime complexity O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n        ncols = int(len(encodedText)/nrows)\\n        ## the total number of slanted lines will be equal to the number of columns. so we print each slanted line, indexed by j, using the first loop below.\\n\\t\\tfor j in range(ncols):\\n\\t\\t\\t## the \"first\" slanted lines will have a length equal to the number of rows but the slanted line near the end of string will have a length lower than the number of rows\\n\\t\\t\\t## because you will hit the final column, and it prevents you from having a slanted line with length of number of rows. the value i, shows the indices of rows that contribute\\n\\t\\t\\t## to the current slanted line ( indexed by j) before.\\n            for i in range(0,min(ncols-j, nrows)):\\n\\t\\t\\t\\t\\t\\t# addressing the value of encodedTextMatrix[i,j] without actually construcing the matrix from encodedText. you can replace this line with\\n\\t\\t\\t\\t\\t\\t# decoded_str += encodedTextMatrix[i,j] if you prefer to first reconstruct the encodedTextMatrix matrix to keep things nice and clean\\n                        decoded_str += encodedText[i*ncols+i+j]\\n        return decoded_str.rstrip(\" \")\\n                \\n```\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n\\t\\t## keep track of characters from encodedText that were added to our to-be-returned result string (decoded_str)\\n        used_chars = defaultdict(int)\\n\\t\\t## length of non-space characters in encodedText\\n        all_chars = len([encodedText[i] for i in range(len(encodedText)) if encodedText[i]!=\" \"])\\n        ncols = int(len(encodedText)/nrows)\\n        for j in range(ncols):\\n\\t\\t\\t# check if all non-space characters from encodedText are already added to decoded_str\\n            if len(used_chars) == all_chars:\\n                break       \\n            for i in range(0,min(ncols-j, nrows)):\\n                        ind = i*ncols+i+j\\n\\t\\t\\t\\t\\t\\t## if current chracter is not space, add it to used_chars\\n                        if encodedText[ind] != \" \":\\n                            used_chars[ind] = 1\\n                        decoded_str += encodedText[ind]\\n\\t\\t# we may still have a few (less than n) spaced at the end of string but it doesn\\'t affect time complexity and can get stripped simply. \\n\\t\\t#the reason is that you can\\'t break from the inner loop in a nested loops in python! and doing that would make the code a bit ugly\\n        return decoded_str.rstrip(\" \")\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578401,
                "title": "detailed-explanation-pictures-included-time-complexity-o-n-c",
                "content": "Lets take an Example of \\n\"iveo    eed   l te   olc\", rows = 4\\n![image](https://assets.leetcode.com/users/images/0e48373f-3ed3-436a-bdb7-15bb3da81f00_1636918352.7840478.png)\\n\\nFor the final answer , we can assume ,\\nour final matrix will look like \\n\\n![image](https://assets.leetcode.com/users/images/700fb0e5-ccc7-40d1-a66b-1de51d4345a2_1636918445.377144.png)\\n\\n( all the element at 0,0 will be appended , same for 0,1 )\\nSo for the (0,0) we\\'ll have \\n![image](https://assets.leetcode.com/users/images/2d640e3c-dfad-4ac8-b982-eb4faa804904_1636919025.3151329.png)\\nto->\\n\\n![image](https://assets.leetcode.com/users/images/4cef7439-0431-4828-a09b-50e4efa7d105_1636919300.2266514.png)\\n\\nand for (0,1)\\nwe have \\n![image](https://assets.leetcode.com/users/images/72e759aa-b918-4a08-9a0f-97831722ddb1_1636919551.0411148.png)\\nand so on .\\nWith little manupulation , we can omit the 2D array and it can we solved with 1D ,\\nbecause \\nall the (0,0) cells can we appended at index 0 in 1D array , \\nall the (0,1) cells can we appended at index 1 in 1D array              \\nall the (0,2) cells can we appended at index 2 in 1D array\\nand so on . \\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows ==1){\\n            return encodedText;\\n        }\\n        if(encodedText.size()==0){\\n            return \"\";\\n        }\\n        int cols = encodedText.size()/rows;\\n        vector<string>temp(cols,\"\");\\n \\n        int c = -1;\\n        for(int i = 0;i<encodedText.size();i++){\\n            if(i%cols == 0){\\n                c++;\\n            }\\n            \\n            if((i%cols)-c >=0)\\n            temp[(i%cols)-c] += encodedText[i];\\n        }\\n        string ans = \"\";\\n        for(auto x: temp){\\n            ans = ans+x;\\n        }\\n        int n = ans.size()-1;\\n        c = 0;\\n        while(ans[n]==\\' \\'){\\n            n--;\\n            c++;\\n        }\\n        ans = ans.substr(0,ans.size()-c);\\n        return ans;\\n    }\\n};\\n```\\nTime complexity O(n) : n-> size of encodedText . \\nHope , it helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows ==1){\\n            return encodedText;\\n        }\\n        if(encodedText.size()==0){\\n            return \"\";\\n        }\\n        int cols = encodedText.size()/rows;\\n        vector<string>temp(cols,\"\");\\n \\n        int c = -1;\\n        for(int i = 0;i<encodedText.size();i++){\\n            if(i%cols == 0){\\n                c++;\\n            }\\n            \\n            if((i%cols)-c >=0)\\n            temp[(i%cols)-c] += encodedText[i];\\n        }\\n        string ans = \"\";\\n        for(auto x: temp){\\n            ans = ans+x;\\n        }\\n        int n = ans.size()-1;\\n        c = 0;\\n        while(ans[n]==\\' \\'){\\n            n--;\\n            c++;\\n        }\\n        ans = ans.substr(0,ans.size()-c);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578400,
                "title": "golang-solution",
                "content": "```\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    cols := len(encodedText)/rows\\n    var sb strings.Builder\\n    for i:=0;i<cols;i++ {\\n        for j:=i;j<len(encodedText);j+=cols+1 {\\n            sb.WriteByte(encodedText[j])\\n        }\\n    }\\n    return strings.TrimRight(sb.String(), \" \")\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    cols := len(encodedText)/rows\\n    var sb strings.Builder\\n    for i:=0;i<cols;i++ {\\n        for j:=i;j<len(encodedText);j+=cols+1 {\\n            sb.WriteByte(encodedText[j])\\n        }\\n    }\\n    return strings.TrimRight(sb.String(), \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578265,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length();\\n        int cols = n/rows,index=0;\\n        char[][] array = new char[rows][cols];\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                array[i][j]=encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<cols;i++){\\n            int start=0,end=i;\\n            StringBuilder curr = new StringBuilder();\\n            while(start<rows && end<cols){\\n                curr.append(array[start][end]);\\n                start++;end++;\\n            }\\n            sb.append(curr);\\n        }\\n        int len = sb.length();\\n        int i=len-1;\\n        for(;i>=0&&sb.charAt(i)==\\' \\';i--);\\n        return sb.toString().substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length();\\n        int cols = n/rows,index=0;\\n        char[][] array = new char[rows][cols];\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                array[i][j]=encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<cols;i++){\\n            int start=0,end=i;\\n            StringBuilder curr = new StringBuilder();\\n            while(start<rows && end<cols){\\n                curr.append(array[start][end]);\\n                start++;end++;\\n            }\\n            sb.append(curr);\\n        }\\n        int len = sb.length();\\n        int i=len-1;\\n        for(;i>=0&&sb.charAt(i)==\\' \\';i--);\\n        return sb.toString().substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578209,
                "title": "c-o-n-solution",
                "content": "```\\nstring decodeCiphertext(string str, int rows) {\\n        if(rows==1)\\n            return str;\\n        string res;\\n        int n=rows, m=str.size()/rows, i=0,j=0,x,y;\\n        \\n        while(j<m) {\\n            \\n            x=i; y=j;\\n            while(x<n && y<m) {\\n                res.push_back(str[x*m + y]);\\n                ++x;\\n                ++y;\\n            }\\n            ++j;\\n        }        \\n        while(res.size() && res.back()==\\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring decodeCiphertext(string str, int rows) {\\n        if(rows==1)\\n            return str;\\n        string res;\\n        int n=rows, m=str.size()/rows, i=0,j=0,x,y;\\n        \\n        while(j<m) {\\n            \\n            x=i; y=j;\\n            while(x<n && y<m) {\\n                res.push_back(str[x*m + y]);\\n                ++x;\\n                ++y;\\n            }\\n            ++j;\\n        }        \\n        while(res.size() && res.back()==\\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578132,
                "title": "java-solution-with-clean-code",
                "content": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (rows == 1) {\\n            return encodedText;\\n        }\\n\\n        int columns = encodedText.length() / rows;\\n\\n        char[][] matrix = new char[rows][columns];\\n        for (int i = 0; i < rows; i++) {\\n            matrix[i] = encodedText.substring(i * columns, (i + 1) * columns).toCharArray();\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < columns; i++) {\\n            int counter = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (counter < columns) {\\n                    result.append(matrix[j][counter++]);\\n                }\\n            }\\n        }\\n\\n        return result.toString().replaceAll(\"\\\\\\\\s+$\", \"\");\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (rows == 1) {\\n            return encodedText;\\n        }\\n\\n        int columns = encodedText.length() / rows;\\n\\n        char[][] matrix = new char[rows][columns];\\n        for (int i = 0; i < rows; i++) {\\n            matrix[i] = encodedText.substring(i * columns, (i + 1) * columns).toCharArray();\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < columns; i++) {\\n            int counter = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (counter < columns) {\\n                    result.append(matrix[j][counter++]);\\n                }\\n            }\\n        }\\n\\n        return result.toString().replaceAll(\"\\\\\\\\s+$\", \"\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578068,
                "title": "c-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string last_string=\"\",ans=\"\",anss=\"\";\\n        if (encodedText.length()==0) \\n            return \"\";\\n        int col= encodedText.size()/rows;\\n        if (col==0 || rows==1) return encodedText;\\n        char mat[rows][col];\\n        // to keep track of the visited diagonals\\n        vector<vector<int>> visited(rows, vector<int>(col, 0));\\n        int k=0;\\n        for (int i=0;i<rows;i++){\\n            for (int j=0;j<col;j++){\\n                mat[i][j]=encodedText[k];\\n                k++;\\n            }\\n        }\\n        // once we visit a diagonal mark all the elements as in visited matrix 1 to ensure we dont visit same diagonal to reuce time complexity\\n        for (int i=0;i<rows;i++){\\n            for (int j=0;j<col;j++){\\n                int a=i,b=j;\\n                if (visited[a][b]==0){\\n                   while (a< rows && b < col){\\n                         ans+=mat[a][b];\\n                         visited[a][b]=1;\\n                         a++;\\n                         b++;\\n                    }\\n                }\\n            }\\n        }\\n        int i=ans.length()-1;\\n        // to erase trailing spaces in answer\\n        while (ans[i]==\\' \\'){\\n            ans.pop_back();\\n            i--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string last_string=\"\",ans=\"\",anss=\"\";\\n        if (encodedText.length()==0) \\n            return \"\";\\n        int col= encodedText.size()/rows;\\n        if (col==0 || rows==1) return encodedText;\\n        char mat[rows][col];\\n        // to keep track of the visited diagonals\\n        vector<vector<int>> visited(rows, vector<int>(col, 0));\\n        int k=0;\\n        for (int i=0;i<rows;i++){\\n            for (int j=0;j<col;j++){\\n                mat[i][j]=encodedText[k];\\n                k++;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1738999,
                "content": [
                    {
                        "username": "ranjeet43",
                        "content": "Approach 1:\\nIntuition :\\n\\nIdea here is to just do what we are asked to perform. That is simulate decoding steps.\\n\\nFirst, we need to make cipher matrix using encodedText.\\n\\nThen, for each column in first row, we traverse diagonally and add those characters to decodedText string.\\n\\nIn the end, since trailing spaces are not allowed, so we remove it from decodedString.\\n\\nWe can have two cases.\\n\\nOne when rows = 1. In this case, we decodedText is same as encodedText.\\nAnd other when rows > 1. In this, we need to perform above simulation.\\nLets understand through simple example :\\n\\n  Case 1 : if rows == 1\\n  \\t\\t\\t\\t\\n    Ex: \"c o d i n g\"\\n      \\n  \\t-> In this case we do not need to decode text. We can simply return encodedText directly. \\n  \\t-> This is because all characters are in first row.\\n  \\n  Case 2: if rows > 1\\n  \\t\\t\\t\\t\\n  \\tEx: encodedText = \"ch   ie   pr\" , rows = 3\\n  \\t\\n  \\tcipher matrix : \\n  \\t\\t  \"c h _ _\\n  \\t       _ i e _  \\n  \\t\\t   _ _ p r\"\\n     \\n     -> Note : Here, just for sake of explanation, I have take space(\" \") as underscore(_).\\n     \\n      i. k = 0 => {(0,0) : \\'c\\'}, {(1,1) : \\'i\\'}, {(2,2) : \\'p\\'} \\n      ii. k = 1 => {(0,1) : \\'h\\'}, {(1,2) : \\'e\\'}, {(2,3) : \\'r\\'}\\n  \\tiii. k = 2 => {(0,2) : \\'_\\'}, {(1,3) : \\'_\\'}\\n  \\t\\n  \\tThus, decodedString with trailing spaces = \"cipher_ _\". \\n  \\tWe need to remove these trailing spaces, and then return resultant string.\\n  \\n  \\t"
                    }
                ]
            }
        ]
    }
]